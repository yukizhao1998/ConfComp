Summary,Issue key,Issue id,Issue Type,Status,Project key,Project name,Project type,Project lead,Project description,Project url,Priority,Resolution,Assignee,Reporter,Creator,Created,Updated,Last Viewed,Resolved,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Component/s,Component/s,Component/s,Due Date,Votes,Labels,Labels,Labels,Labels,Labels,Labels,Description,Environment,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Original Estimate,Remaining Estimate,Time Spent,Work Ratio,Σ Original Estimate,Σ Remaining Estimate,Σ Time Spent,Security Level,Inward issue link (Cloners),Outward issue link (Cloners),Inward issue link (Completes),Outward issue link (Container),Outward issue link (Container),Outward issue link (Container),Inward issue link (Duplicate),Outward issue link (Duplicate),Outward issue link (Duplicate),Inward issue link (Problem/Incident),Inward issue link (Reference),Inward issue link (Reference),Inward issue link (Reference),Inward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Regression),Inward issue link (Related),Inward issue link (Related),Outward issue link (Related),Outward issue link (Related),Inward issue link (dependent),Outward issue link (dependent),Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Custom field (Affects version (Component)),Custom field (Attachment count),Custom field (Blog - New Blog Administrators),Custom field (Blog - New Blog PMC),Custom field (Blog - Write access),Custom field (Blog Administrator?),Custom field (Blogs - Admin for blog),Custom field (Blogs - Email Address),Custom field (Blogs - Existing Blog Access Level),Custom field (Blogs - Existing Blog Name),Custom field (Blogs - New Blog Write Access),Custom field (Blogs - Username),Custom field (Bug Category),Custom field (Bugzilla - Email Notification Address),Custom field (Bugzilla - List of usernames),Custom field (Bugzilla - PMC Name),Custom field (Bugzilla - Project Name),Custom field (Bugzilla Id),Custom field (Bugzilla Id),Custom field (Change Category),Custom field (Complexity),Custom field (Discovered By),Custom field (Docs Text),Custom field (Enable Automatic Patch Review),Custom field (Epic Link),Custom field (Estimated Complexity),Custom field (Evidence Of Open Source Adoption),Custom field (Evidence Of Registration),Custom field (Evidence Of Use On World Wide Web),Custom field (Existing GitBox Approval),Custom field (External issue URL),Custom field (Fix version (Component)),Custom field (Flags),Custom field (Flags),Custom field (Git Notification Mailing List),Custom field (Git Repository Import Path),Custom field (Git Repository Name),Custom field (Git Repository Type),Custom field (GitHub Options),Custom field (Github Integration),Custom field (Github Integrations - Other),Custom field (Global Rank),Custom field (INFRA - Subversion Repository Path),Custom field (Initial Confluence Contributors),Custom field (Last public comment date),Custom field (Level of effort),Custom field (Machine Readable Info),Custom field (Mentor),Custom field (New-TLP-TLPName),Custom field (Original story points),Custom field (Parent Link),Custom field (Priority),Custom field (Project),Custom field (Protected Branch),Custom field (Rank),Custom field (Rank (Obsolete)),Custom field (Review Date),Custom field (Reviewer),Custom field (Severity),Custom field (Severity),Custom field (Skill Level),Custom field (Source Control Link),Custom field (Space Description),Custom field (Space Key),Custom field (Space Name),Custom field (Start Date),Custom field (Tags),Custom field (Target end),Custom field (Target start),Custom field (Team),Custom field (Test and Documentation Plan),Custom field (Testcase included),Custom field (Tester),Custom field (Workaround),Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment
Static type checking fails when compiling against a Java8 interface with inherited methods,GROOVY-7721,12924506,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,gromopetr,gromopetr,28/Dec/15 14:25,14/Sep/17 02:07,14/Jul/23 06:01,13/Sep/17 15:09,2.4.0,,,,,,,,,,,,,,,,,2.4.13,2.5.0-beta-2,2.6.0-alpha-2,3.0.0-alpha-1,Static compilation,Static Type Checker,,,0,,,,,,,"Create classes.java:
{code}
interface I {
    R[] method();
}

interface I2 extends I {
    R2[] method();
}

interface R {}
interface R2 extends R {}
{code}

compile it with JDK 8 javac.

Then create usage.groovy:

{code}import groovy.transform.CompileStatic

@CompileStatic
class Gr {
    R2[] x(I2 i) {
       return i.method();
    }
}
{code}

Compile it with groovyc (also run with Java8) with the classes from previous compilation in the classpath. Compilation fails:

{code}
usage.groovy: 6: [Static type checking] - Reference to method is ambiguous. Cannot choose between [R2[] I2#method(), R[] I2#method()]
 @ line 6, column 15.
          return i.method();
                 ^

1 error
{code}

Originally reported as https://youtrack.jetbrains.com/issue/IDEA-148973",,Alexey Afanasiev,blackdrag,daniel_sun,daniilo,githubbot,gromopetr,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7849,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 13 15:09:14 UTC 2017,,,,,,,,,,"0|i2qcbz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Dec/15 12:06;blackdrag;This would mean the static compiler does not ignore the synthetic bridge method in I2 (created for the R[] returning method);;;","13/Sep/17 10:24;githubbot;GitHub user avafanasiev opened a pull request:

    https://github.com/apache/groovy/pull/599

    GROOVY-7721: Static type checking fails when compiling against a Java interface call

    Arrays is also covariants in java, so they should be also compared. 
    Can't find exact documentation, but  JLS 15.12.2.5 says:
    – Otherwise, if all the maximally specific methods are abstract or default, and
    the signatures of all of the maximally specific methods have the same erasure
    (§4.6), then the most specific method is chosen arbitrarily among the subset
    of the maximally specific methods that have the most specific return type.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/avafanasiev/groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/599.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #599
    
----
commit 98d82aeff501cd996f1a9aebfae793160c8d3cfe
Author: alexey.afanasiev <alexey.afanasiev@jetbrains.com>
Date:   2017-09-13T10:14:58Z

    GROOVY-7721: Static type checking fails when compiling against a Java8 interface with inherited methods

----
;;;","13/Sep/17 12:20;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/599
;;;","13/Sep/17 15:09;daniel_sun;Fixed by https://github.com/apache/groovy/commit/1c395602ee4929959d451e918015fc7ebf258dec;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.ClassFormatError: Illegal class name on runtime cast array to trait,GROOVY-7718,12923752,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,hubbitus,hubbitus,22/Dec/15 13:59,22/Feb/16 21:30,14/Jul/23 06:01,23/Dec/15 21:56,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,,,,,0,,,,,,,"{code:java}
trait SimpleTrait {
}

def arr = [""one"", 'two'] as String[];

arr as SimpleTrait
{code}
Produce:
{noformat}
java.lang.ClassFormatError: Illegal class name ""String;2_groovyProxy"" in class file String;2_groovyProxy
	at ConsoleScript1.run(ConsoleScript1:6)
{noformat}

Possibly related to GROOVY-7650.",,hubbitus,pascalschumacher,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 22 21:30:31 UTC 2016,,,,,,,,,,"0|i2q7qv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Dec/15 16:49;shils;This error does not occur on 2_4_X or master.;;;","23/Dec/15 21:56;pascalschumacher;I'm resolving this after reading Shils comment. I guess the fix for [GROOVY-7650] also solved this.;;;","22/Feb/16 20:45;hubbitus;It fixed. Thank you.;;;","22/Feb/16 21:30;pascalschumacher;Thanks for reporting the issue and thanks for letting us know that it is fixed. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StaticTypeCheckingTestCase#shouldFailWithMessages erroneously passes,GROOVY-7717,12923326,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,21/Dec/15 03:49,22/Feb/16 20:48,14/Jul/23 06:01,21/Dec/15 13:51,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,,,,,,,"When StaticTypeCheckingTestCase#shouldFailWithMessages(String, String...) is called with multiple message arguments, the call returns successfully if both of the following are true:

1) at least one argument is contained in a collected error message
2) the number of message arguments equals the number of collected errors

This causes tests to erroneously pass, even if they don't result in all of the desired errors. For example, TypeCheckingExtensionsTest#testPrecompiledExtensionNotExtendingTypeCheckingDSL currently passes even though PrecompiledExtensionNotExtendingTypeCheckingDSL#onMethodSelection throws a MissingPropertyException (which is converted to a compilation error in CompilationUnit#applyToPrimaryClassNodes) instead of actually adding the intended static type error.






",,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 21 13:46:55 UTC 2015,,,,,,,,,,"0|i2q54f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Dec/15 04:00;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/217

    GROOVY-7717 StaticTypeCheckingTestCase#shouldFailWithMessages erroneo…

    …usly passes
    
    *StaticTypeCheckingTestCase: shouldFailWithMessages should only pass if all and only the expected error messages occur
    *PrecompiledExtensionNotExtendingDSL:  fix ASTNode associated with error added in onMethodSelection method

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7717

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/217.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #217
    
----
commit fbcdfe87236a6db6946ba5d29255d7217670b72c
Author: Shil Sinha <shils@apache.org>
Date:   2015-12-21T03:58:55Z

    GROOVY-7717 StaticTypeCheckingTestCase#shouldFailWithMessages erroneously passes
    *StaticTypeCheckingTestCase: shouldFailWithMessages should only pass if all and only the expected error messages occur
    *PrecompiledExtensionNotExtendingDSL:  fix ASTNode associated with error added in onMethodSelection method

----
;;;","21/Dec/15 13:46;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/217
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.json.internal.FastStringUtils.StringImplementation#toCharArray fails on jdk9,GROOVY-7716,12923293,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,iNikem,iNikem,20/Dec/15 15:55,22/Feb/16 20:48,14/Jul/23 06:01,31/Dec/15 22:48,2.3.10,2.4.5,,,,,,,,,,,,,,,,2.4.6,,,,JSON,,,,0,jdk9,,,,,,"Trying to build my application on recent jdk9 build I got the following exception:

java.lang.ClassCastException: [B cannot be cast to [C
	at groovy.json.internal.FastStringUtils$StringImplementation$1.toCharArray(FastStringUtils.java:88)
	at groovy.json.internal.FastStringUtils.toCharArray(FastStringUtils.java:175)
	at groovy.json.internal.BaseJsonParser.parse(BaseJsonParser.java:103)
	at groovy.json.JsonSlurper.parseText(JsonSlurper.java:208)

I believe that jdk9 has changed the inner representation of Strings (see http://openjdk.java.net/jeps/254).",,githubbot,iNikem,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Dec 31 22:48:29 UTC 2015,,,,,,,,,,"0|i2q4x3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Dec/15 17:54;jwagenleitner;Passing ""-Dgroovy.json.faststringutils.disable=true"" to the program could be used as a workaround for this issue until it's fixed.;;;","26/Dec/15 22:07;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/225

    GROOVY-7716 - groovy.json.internal.FastStringUtils fails on jdk9

    JDK 9 Compat Strings enhancement changed the internal representation of the value field from a char[] to a combination of a byte[] and an encoding flag field (see http://openjdk.java.net/jeps/254).  As a workaround this change allows fallback to the normal String#toCharArray method and bypasses using direct access.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7716

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/225.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #225
    
----
commit d6d9647c75edaa187c213f26e1aa3ac2ea708277
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2015-12-26T21:35:01Z

    GROOVY-7716 - groovy.json.internal.FastStringUtils.StringImplementation#toCharArray fails on jdk9
    
    JDK 9 Compat Strings enhancement changed the internal representation of the value field from a char[] to a combination of a byte[] and an encoding flag field (see http://openjdk.java.net/jeps/254).  As a workaround this change allows fallback to the normal String#toCharArray method and bypasses using direct access.

----
;;;","31/Dec/15 22:25;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/225
;;;","31/Dec/15 22:48;jwagenleitner;Since the internal representation changed from a char[] to a byte[] + encoding flag field for jdk 9 the fix falls back to using {{String#toCharArray}}.  I suspect that not having the optimization for jdk9+ wont cause any significant performance issues and at some point it might be worth completely removing {{sun.misc.Unsafe}} since the only use in the codebase is in {{groovy.json.internal.FastStringUtils}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ulimit use is not supported on NonStop,GROOVY-7715,12923233,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pascalschumacher,rsbecker,rsbecker,19/Dec/15 15:05,22/Feb/16 20:48,14/Jul/23 06:01,20/Dec/15 11:34,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,groovy-runtime,,,,0,nonstop,,,,,,"Dependency on ulimit to find the number of file descriptors does not function correctly on the NonStop platform. Reports warnings from gradlew and src/bin/startGroovy. NonStop probably should be handled similarly to cygwin and darwin in this regard.

uname reports NONSTOP_KERNEL, which can be used as a discriminant.

I can supply a git patch for this from commit 310278d if requested.",NONSTOP_KERNEL,pascalschumacher,rsbecker,,,,,,,,,,,,,,,,,,,,,,,,3600,3600,,0%,3600,3600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 20 11:34:15 UTC 2015,,,,,,,,,,"0|i2q4jr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Dec/15 15:45;rsbecker;I have the patch in a fork of apache/groovy.git at github. Pull request #215.;;;","20/Dec/15 11:34;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic checking fails with null returns,GROOVY-7713,12922875,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,uberska,uberska,17/Dec/15 22:51,01/Feb/17 23:18,14/Jul/23 06:01,19/Aug/16 02:38,2.4.4,2.4.5,,,,,,,,,,,,,,,,2.4.8,,,,Static Type Checker,,,,0,,,,,,,"---------
TEST 1
---------
{code}
package test

import groovy.transform.CompileStatic

class TestClass {

	@CompileStatic
	void doTest() {
		Closure<String> closure = {
			return ""foo"";
		}
	}

}
{code}
Compiles fine.

---------
TEST 2
---------
{code}
package test

import groovy.transform.CompileStatic

class TestClass {

	@CompileStatic
	void doTest() {
		Closure<String> closure = {
			if (""bah"".length() == 3) {
				return null
			}
			return ""foo"";
		}
	}

}
{code}
...gives...
{code}
groovyc Test2.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Test2.groovy: 9: [Static type checking] - Incompatible generic argument types. Cannot assign groovy.lang.Closure <java.lang.Object> to: groovy.lang.Closure <String>
 @ line 9, column 29.
   		Closure<String> closure = {
                               ^

1 error
{code}

---------
TEST 3
---------
{code}
package test

import groovy.transform.CompileStatic

class TestClass {

	@CompileStatic
	void doTest() {
		Closure<String> closure = {
			return null;
		}
	}

}
{code}
...gives...
{code}
groovyc Test3.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Test3.groovy: 9: [Static type checking] - Incompatible generic argument types. Cannot assign groovy.lang.Closure <java.lang.Object> to: groovy.lang.Closure <String>
 @ line 9, column 29.
   		Closure<String> closure = {
                               ^

1 error
{code}

---------
TEST 4
---------
{code}
package test

import groovy.transform.CompileStatic

class TestClass {

	@CompileStatic
	void doTest() {
		Closure<String> closure = {

		}
	}

}
{code}
Compiles fine.

---------
COMMENTS
---------
All files were compiled with 'groovyc Test\[1234\].groovy'. I expected all tests to compile. I wouldn't have thought returning null would cause a static compilation failure since null is a valid String. Also, I expected test 3 and test 4 to be equivalent.

The workaround appears to be to cast the closure, like:
{code}
Closure<String> closure = (Closure<String>) {
    ...
}
{code}",,blackdrag,githubbot,jwagenleitner,uberska,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Dec/15 22:53;uberska;Test1.groovy;https://issues.apache.org/jira/secure/attachment/12778369/Test1.groovy","17/Dec/15 22:53;uberska;Test2.groovy;https://issues.apache.org/jira/secure/attachment/12778370/Test2.groovy","17/Dec/15 22:53;uberska;Test3.groovy;https://issues.apache.org/jira/secure/attachment/12778371/Test3.groovy","17/Dec/15 22:53;uberska;Test4.groovy;https://issues.apache.org/jira/secure/attachment/12778372/Test4.groovy",,,,,4.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 19 02:38:31 UTC 2016,,,,,,,,,,"0|i2q2cf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Dec/15 22:53;uberska;Attaching the groovy tests used.;;;","18/Dec/15 10:02;blackdrag;The problem is that null requires a quite different handling in the type system, since it can mean any type. And there are still a lot of bugs in that area. Casting the null should for example also bypass your problems.;;;","14/Aug/16 06:59;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/384

    GROOVY-7713: CompileStatic checking fails with null returns from Clos…

    …ures

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7713

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/384.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #384
    
----
commit cfda1043e1e23d47e7ee6bf1f5928bd34ea0c237
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-08-14T06:34:09Z

    GROOVY-7713: CompileStatic checking fails with null returns from Closures

----
;;;","19/Aug/16 02:34;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/384
;;;","19/Aug/16 02:38;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong method resolution for an overridden method with varargs and covariant return type,GROOVY-7711,12921784,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,fpavageau,fpavageau,14/Dec/15 21:48,22/Feb/16 20:48,14/Jul/23 06:01,28/Dec/15 07:04,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,,,,,,,"Consider the following code:
{code}
class A {}
class B {
    Object m(Object[] args) {
        new Object()
    }
}
class C extends B {
    A m(Object[] args) {
        new A()
    }
}
C c = new C()
A a = c.m()
{code}

It has 50% chance of failing the static type check at the last line, because the STC can resolve to the base definition (with an {{Object}} return type) instead of the override, as it doesn't give precedence to the most specific definition in the ""varargs with 0 argument"" case.

Like for GROOVY-7710, I have a fix for the bug, but it's also based on my pull request for GROOVY-7420 as it's once again in the same method. It's actually in the same commit, because once refactored a bit, the 2 missing method calls become obvious.",,fpavageau,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 28 07:04:07 UTC 2015,,,,,,,,,,"0|i2pvm7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Dec/15 12:37;fpavageau;I've submitted https://github.com/apache/groovy/pull/213 which fixes this issue as well as GROOVY-7710 (on which [~githubbot] commented). The fix has been decoupled from the one for GROOVY-7420.;;;","28/Dec/15 07:04;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Random resolution of an overloaded method with arrays as last parameter called without an argument,GROOVY-7710,12921776,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,fpavageau,fpavageau,14/Dec/15 21:37,22/Feb/16 20:48,14/Jul/23 06:01,28/Dec/15 07:03,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,,,,,,,"When calling a method with overloads that have arrays as their last parameter (such as {{Arrays.sort()}} or {{Arrays.hashCode()}} that have multiple overloads, e.g. with all primitive arrays) but no argument (valid since an array is equivalent to varargs in Groovy), the static type checker resolves to the first (random) method instead of failing because of the ambiguous call.

I have a fix for the bug, but it's based on my pull request for GROOVY-7420 as it's in the same method and I wanted to avoid a painful merge. I'd rather see that fix applied first before creating a new PR, but could extract the same kind of fix based on the current code if necessary, though.",,fpavageau,githubbot,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 28 07:03:30 UTC 2015,,,,,,,,,,"0|i2pvkf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Dec/15 12:31;githubbot;GitHub user fpavageau opened a pull request:

    https://github.com/apache/groovy/pull/213

    GROOVY-7710 GROOVY-7711 Apply the rules to resolve method consistently

    A no-arg call to a varargs method needs to be resolved with the same rules
    as when there are exactly the same number of parameters, or even more, by
    applying the class distance and extension method biases.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fpavageau/groovy GROOVY-7710-7711

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/213.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #213
    
----
commit 77e983f654f757d1d517ede03db4b330b7d20ca5
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-12-02T14:23:42Z

    Extract common behaviors from the method signature resolution

commit 5288b277cae286306b5d0fb0299cd1e8bfc46cdb
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-12-14T21:58:17Z

    GROOVY-7710 GROOVY-7711 Apply the rules to resolve method consistently
    
    A no-arg call to a varargs method needs to be resolved with the same rules
    as when there are exactly the same number of parameters, or even more, by
    applying the class distance and extension method biases.

----
;;;","16/Dec/15 12:34;fpavageau;The fix is now decoupled from the one for GROOVY-7420, which is why I could submit the PR independently.;;;","28/Dec/15 07:00;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/213
;;;","28/Dec/15 07:03;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE with ConvertedClosure,GROOVY-7709,12921044,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,blackdrag,blackdrag,11/Dec/15 12:12,22/Feb/16 20:48,14/Jul/23 06:01,15/Jan/16 16:22,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,,,,,0,,,,,,,"{code}
interface Y extends GroovyObject {}
def cl = {println 1} as Y
assert cl instanceof GroovyObject
if (cl) println ""!cl""
{code}
the code above will cause the execution of the method getMetaClass in the boolean part of the ""if"". It looks like this code path now produces a NPE
{code}
java.lang.NullPointerException
	at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:919)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:902)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToBoolean(DefaultTypeTransformation.java:185)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.booleanUnbox(DefaultTypeTransformation.java:74){code}",,blackdrag,githubbot,jwagenleitner,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 15 16:22:36 UTC 2016,,,,,,,,,,"0|i2prl3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Dec/15 12:12;blackdrag;not tested against master;;;","11/Dec/15 16:03;jwagenleitner;NPE occurs in master.  Testing each point release from 2.4.5 back, last release this worked as expected was 1.6.9.;;;","12/Dec/15 20:00;blackdrag;1.6.9, really? I thought 2.3.6 was working as well;;;","12/Dec/15 20:25;jwagenleitner;Just tried with 2.3.6 (before I mostly tested with 2.X.0 point releases) and confirmed that it throws the NPE. ;;;","23/Dec/15 19:43;shils;The closure itself also appears to be executed twice as a side effect of the {{cl.getMetaClass()}} call.;;;","25/Dec/15 09:14;blackdrag;The question is what the right behaviour is. In case of {code:Java}inteface Foo { def x(); def y()}
def cl = [x:{1},y:{2}]
def object = cl as Foo
assert object instanceof Foo
assert object.x() == 1
assert object.y() == 2
{code}
We have the map taking care of what method is supposed to be used for a specific method. But we do also allow this:
{code:Java}inteface Foo { def x(); def y()}
def cl = {1}
def object = cl as Foo
assert object instanceof Foo
assert object.x() == 1
assert object.y() == 1
{code}
and here the Closure object is taken for everything. So according to that, it is not really wrong if the closure reacts to getMetaClass or asBoolean. but calling getMetaClass twice... hmm... I can't tell for sure if that is wrong or not.

As for the NPE... I have had no time to properly look at this, but could it be that it happens, because the returned meta class is null?
;;;","26/Dec/15 23:41;shils;Yes, the meta class used to create the PogoMetaClassSite (in CallSiteArray#createPogoSite) is the value returned by the closure, which in this case will be null. If the closure is changed to \{ 1 \} for example, the test will instead fail with:
{code}
java.lang.ClassCastException: java.lang.Integer cannot be cast to groovy.lang.MetaClass
{code};;;","27/Dec/15 03:31;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/226

    GROOVY-7709 - ConvertedClosure/ConvertedMap do not work with interface extending GroovyObject

    Just posting for discussion and acknowledge that there is probably a better fix and lots here is not being addressed other the immediate issue.  For this fix I borrowed from what was done in `GroovyResultSetProxy`.
    
    Assuming this is even somewhat close to the right way to address it, it might make sense for the `ConvertedMap` to handle the metaClass in case the map has a `getMetaClass` key.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7709

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/226.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #226
    
----
commit 584840327d484e9a24fd69a3cfc8a8c97fa55e86
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2015-12-27T03:17:07Z

    GROOVY-7709 - ConvertedClosure/ConvertedMap do not work with interface extending GroovyObject

----
;;;","27/Dec/15 03:39;jwagenleitner;The same issue exists for ConvertedMap.  I posted a PR, pretty sure I'm way off base but thought I might as well post it and maybe it'll be worth something.  I tried various ways of delegating the {{GroovyObject}} calls to the {{ConvertedClosure}} delegate but since the object/receiver is a {{java.lang.reflection.Proxy}} and not really a closure it failed in the {{ClosureMetaclass}}.;;;","27/Dec/15 03:45;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/226#discussion_r48451502
  
    --- Diff: src/main/org/codehaus/groovy/runtime/ConversionHandler.java ---
    @@ -189,4 +202,15 @@ public static boolean isCoreObjectMethod(Method method) {
             return Object.class.equals(method.getDeclaringClass());
         }
     
    +    private MetaClass setMetaClass(MetaClass mc) {
    +        metaClass = mc;
    +        return mc;
    +    }
    +
    +    private MetaClass getMetaClass(Object proxy) {
    +        if (metaClass == null) {
    +            metaClass = ((MetaClassRegistryImpl) GroovySystem.getMetaClassRegistry()).getMetaClass(proxy);
    --- End diff --
    
    Not sure if this is the right way to get the `metaClass` for the `Proxy` object.
;;;","31/Dec/15 23:27;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/226
;;;","10/Jan/16 01:54;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/237

    Safely publish MetaClass so threads wont see a partially constructed instance

    Added final where appropriate and limited plugin variable scope in invoke method.
    
    Related to PR #226 (GROOVY-7709), while full synchronization may not be required the lazily initialized `metaClass` should probably be `volatile`.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy ConversionHandler

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/237.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #237
    
----
commit f33df09674728a5d919770ac941873d7f3606826
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-01-10T01:11:57Z

    Safely publish MetaClass so threads wont see a partially constructed instance.
    
    Added final where appropriate and limited plugin variable scope in invoke method.

----
;;;","12/Jan/16 01:12;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/237
;;;","12/Jan/16 08:14;blackdrag;the issue was not fixed by PR 237, was it?;;;","12/Jan/16 14:47;jwagenleitner;No, because I referenced this in that PR I guess the asfgitbot picked it up.  I didn't think it would pick it up unless it was mentioned in the PR title.;;;","12/Jan/16 15:46;jwagenleitner;[PR #226|https://github.com/apache/groovy/pull/226] was the PR that was supposed to resolve this and was merged into 2_4_X and master.  I noticed this was reopened, did you find a problem?;;;","15/Jan/16 16:22;blackdrag;ah sorry, my mistake;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StreamingJsonBuilder produces IllegalStateException when using unescaped output,GROOVY-7707,12920993,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,graemerocher1,graemerocher1,11/Dec/15 07:57,12/Mar/16 21:33,14/Jul/23 06:01,12/Dec/15 05:35,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,,,,,0,,,,,,,"When writing unescaped JSON the state is not reset, resulting in an exception if another entry is written.",,graemerocher1,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Dec 12 05:35:08 UTC 2015,,,,,,,,,,"0|i2pr9r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Dec/15 05:35;jwagenleitner;PR https://github.com/apache/groovy/pull/210 merged, thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"CompileStatic closure accessing ""thisObject"" private field: setProperty instead of synthetic method",GROOVY-7705,12920090,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,gillius,gillius,08/Dec/15 14:11,22/Feb/16 20:48,14/Jul/23 06:01,14/Jan/16 01:29,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Static compilation,,,,0,,,,,,,"When a closure sets the private field of a class, it does it via a ScriptBytecodeAdapter.setGroovyObjectProperty on the closure object itself, whereas when getting a private field of the class it uses a synthetic ""pfaccess$0"" method.

Source:
{code:title=Source}
@CompileStatic
class SetFromClosure {
	private int x

	void doIt() {
		def closure = {
			x = 5
			println x
		}
		closure()
	}
}
{code}

Decompiled result of closure class (via Fernflower in IntelliJ):
{code}
class SetFromClosure$_doIt_closure1 extends Closure implements GeneratedClosure {
  public SetFromClosure$_doIt_closure1(Object _outerInstance, Object _thisObject) {
    super(_outerInstance, _thisObject);
  }

  public Object doCall(Object it) {
    byte var2 = 5;
    ScriptBytecodeAdapter.setGroovyObjectProperty(Integer.valueOf(var2), SetFromClosure$_doIt_closure1.class, this, (String)""x"");
    DefaultGroovyMethods.println((SetFromClosure)this.getThisObject(), Integer.valueOf(SetFromClosure.pfaccess$0((SetFromClosure)this.getThisObject())));
    return null;
  }

  public Object call(Object args) {
    return this.doCall(args);
  }

  public Object call() {
    return this.doCall((Object)null);
  }

  public Object doCall() {
    return this.doCall((Object)null);
  }
}
{code}

Workaround is to remove ""private"" keyword on the variable declaration, which causes Groovy to generate public getter and setter. In that mode, the static compiler does generate direct calls to both the getter and the setter. In one example within my project the performance speedup was 10x with this workaround. The only thing I notice in the workaround that is odd is that instead of normal Java casts used, ScriptBytecodeAdapter.castToType is used on ""getThisObject"" before calling the getters or setters.

This issue could possibly related to GROOVY-6825, but in that case it's an inner class, and the issue description (currently) is not clear enough to see if it's also generating a setProperty call.",,gillius,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 10 22:19:15 UTC 2016,,,,,,,,,,"0|i2plp3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Dec/15 17:14;shils;The static compiler doesn't currently generate bridge methods for setting private fields, resulting in the behavior you described. The difference between this issue and GROOVY-6825 is that the latter deals with the mutation of an outer class variable which is a property (with public getter/setter as you mentioned in your workaround), so bridge methods aren't necessary.;;;","16/Dec/15 22:01;shils;Rough implementation - https://github.com/apache/groovy/compare/master...shils:GROOVY-7705. The solution assumes that private fields which are set from an inner class will also have been stored among the 'PV_FIELDS_ACCESS' fields in the outer class' node metadata. This is generally the case because currently StaticTypeCheckingVisitor#getType and StaticTypeCheckingVisitor#storeField are used to mark private access, and neither differentiates between the get/set cases.;;;","18/Dec/15 21:55;gillius;Awesome work on this, I did look at the code although I can't comment much about it since I don't know anything about Groovy internals, but I will say that's a really cool test framework on the Groovy side that allows you to check for a specific bytecode instruction.;;;","29/Dec/15 21:15;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/229

    GROOVY-7705: Add bridge methods for setting private fields of outer c…

    …lass from inner class or closure

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7705

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/229.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #229
    
----
commit dc7ca7d2a35e5018b73f422dce1c3da29365d84e
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2015-12-10T00:23:24Z

    GROOVY-7705: Add bridge methods for setting private fields of outer class from inner class or closure

----
;;;","14/Jan/16 01:28;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/229
;;;","15/Jan/16 19:35;gillius;Is it possible for this fix to also go into 2.4.6?;;;","05/Feb/16 21:17;shils;[~gillius] This fix will be in 2.4.6.;;;","08/Feb/16 03:10;gillius;That's really good news, I'll try a 2.4.6 snapshot soon and see if it works for me.;;;","10/Feb/16 22:06;gillius;[~shils], awesome work on this, I have used 2.4.6-SNAPSHOT today from JFrog repo and confirmed via bytecode analysis through Fernflower that the fix does work to create direct accessors. For my code there is a substantial performance improvement: a performance test suite goes from 44s to 40s. Within that test suite the average page load time for the most directly affected page drops from 419ms avg to 321ms avg. Note this is with the ""make all fields public"" workaround applied for the most used classes in our framework. If I make the fields private again, the time goes from 2 seconds+ average page load times (total test suite on order of minutes) down to the 321ms, so for those who haven't applied this workaround and are impacted this could be a major win. Even for us who have applied the workaround, the patch catches the less used classes for a 10% overall, or 25% improvement for the page load times.

One thing I had issue with in 2.4.6 is that static compiler gave a handful of errors I had to fix, I filed GROOVY-7753. In other cases the static compiler assumes more specific types than it used to (for example method where I returned Map<String, Object> complains because Groovy now thinks it returns Map<String, Comparable>).;;;","10/Feb/16 22:19;shils;Thanks! That's great to hear. I have a feeling that GROOVY-7753 is a result of the fix for GROOVY-7598.. I'll take a look. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic and the method with(Closure) seem to determine wrong type,GROOVY-7702,12918696,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,shils,trapongx,trapongx,04/Dec/15 04:15,22/Feb/16 20:48,14/Jul/23 06:01,29/Dec/15 15:24,2.4.4,2.4.5,,,,,,,,,,,,,,,,2.4.6,,,,,,,,0,,,,,,,"In the code below. When refer to time without the ""it"" prefix. The compiler get type of ""time"" wrongly. ""time"" is Date but it determined as long.

{code}
@CompileStatic
class GMain {
    static void main(String[] args) {
        Calendar.instance.with {
            println time.class//This print java.util.Date which is OK
            Date d1 = time//This line failed to compile with error Groovyc: [Static type checking] - Cannot assign value of type long to variable of type java.util.Date
            Date d2 = it.time//This line is OK
        }
    }
}
{code}",,githubbot,rahulsom,shils,trapongx,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 29 15:22:35 UTC 2015,,,,,,,,,,"0|i2pd3r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Dec/15 00:06;rahulsom;Replacing that line with this works:
{code:java}
Date d1 = getTime()
{code};;;","07/Dec/15 19:00;shils;This occurs because StaticTypeCheckingVisitor#existsProperty determines 'time' to be a reference to the {{protected long time}} field of Calendar, rather than to the getter that Rahul mentioned. This in turn seems to occur because the 'time' property expression created in StaticTypeCheckingVisitor#tryVariableExpressionAsProperty has implicitThis set to true, and though the receiver (the calendar instance) is not the same as 'this', the 'time' field is preferred over the getter.;;;","28/Dec/15 22:17;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/227

    GROOVY-7702: @CompileStatic and the method with(Closure) seem to dete…

    …rmine wrong type

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7702

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/227.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #227
    
----
commit 06e84dfb7a5a7e4af119f38a59c157d6907f703d
Author: Shil Sinha <shils@apache.org>
Date:   2015-12-28T22:16:09Z

    GROOVY-7702: @CompileStatic and the method with(Closure) seem to determine wrong type

----
;;;","29/Dec/15 15:22;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/227
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"org.codehaus.groovy.runtime.typehandling.GroovyCastException in Groovy "".with { ... }"" - Block",GROOVY-7701,12917914,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,MaikIgloffstein,MaikIgloffstein,03/Dec/15 08:15,16/May/23 13:34,14/Jul/23 06:01,13/Jun/20 13:34,2.4.3,2.4.4,2.4.5,,,,,,,,,,,,,,,2.5.13,3.0.5,4.0.0-alpha-1,,groovy-jdk,,,,0,,,,,,,"h1. Problem
{code}
subClass.with {
  type = ['String']
}
{code}

Should change _SubClass.type_ and not _TopClass.type_.
The script works fine with _type2_ instead of _type_. Is _type_ a reserved word? I can't find any documentation about this.

h2. Unit-Test / Groovy Console-Test

{code}
class SubClass{
    List type
}

class TopClass{

    int type = 10

    @Lazy
    List something = {
        List tmp = []
        for(int i = 0; i < 5; i++){
            def subClass = new SubClass()
            subClass.with {
                type = ['String'] // throws org.codehaus.groovy.runtime.typehandling.GroovyCastException
            }
            tmp.add(subClass)
        }
        tmp
    }()
}

def topClass = new TopClass()
println GroovySystem.version
println(topClass.type)
println(topClass.something)
println(topClass.type)
{code}

h2. Exception
{code}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object '[String]' with class 'java.util.ArrayList' to class 'int'
	at TopClass$_getSomething_closure1$_closure2.doCall(ConsoleScript3:15)
	at TopClass$_getSomething_closure1.doCall(ConsoleScript3:14)
	at TopClass$_getSomething_closure1.doCall(ConsoleScript3)
	at TopClass.getSomething(ConsoleScript3:11)
	at ConsoleScript3.run(ConsoleScript3:26)
{code}","all?
Tested with Ubuntu 14.04.3 LTS (64 Bit) | MacOS 10.11 and Groovy 2.4.5, 2.3.4",blackdrag,emilles,jwagenleitner,MaikIgloffstein,monti,shils,,,,,,,,,,"eric-milles opened a new pull request #1268:
URL: https://github.com/apache/groovy/pull/1268


   https://issues.apache.org/jira/browse/GROOVY-7701


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jun/20 19:01;githubbot;600","danielsun1106 merged pull request #1268:
URL: https://github.com/apache/groovy/pull/1268


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;13/Jun/20 13:34;githubbot;600","danielsun1106 commented on pull request #1268:
URL: https://github.com/apache/groovy/pull/1268#issuecomment-643624640


   Merged. Thanks


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;13/Jun/20 13:34;githubbot;600",,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,GROOVY-11056,,,,,,GROOVY-9655,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 24 07:46:02 UTC 2020,,,,,,,,,,"0|i2p8a7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Dec/15 19:03;shils;This occurs for me with any choice of name in place of 'type' (provided the same name is used in both TopClass and SubClass.) Also, 'type' is not a reserved word.;;;","12/Dec/15 18:01;jwagenleitner;A workaround would be to use

{code}
subClass.with {
    delegate.type = ['String']
}
{code}

It only seems to be a problem if the name is the same but the types are incompatible.  If TopClass.type type is String it works correctly (only the SubClass.type is set).;;;","15/Dec/15 19:41;shils;A simplified version of the example from the description:

{code}
class SubClass {
    List type
}

class TopClass {
    int type
    
    void test() {
        def subClass = new SubClass()
        subClass.with {
            type = ['String']           
        }
    }
}

new TopClass().test()
{code}

It's worth noting that if TopClass is statically compiled, a NumberFormatException is thrown due to an attempt to convert 'String' to an int. 


;;;","16/Dec/15 06:12;MaikIgloffstein;Are there any performance issue using {{delegate.<var>}} in the _with closure_ by default?;;;","17/Dec/15 18:35;jwagenleitner;Not sure, I would suspect not but it wouldn't hurt to test.  You can also compare against dropping the delegate and calling the setter {{setType(...)}} and that should also work as a workaround.;;;","05/Jan/16 08:45;MaikIgloffstein;Will this bug be fixed in the next release?;;;","05/Jan/16 13:01;blackdrag;as long as the bug is open, you cannot expect it been fixed in the next version;;;","04/Jun/20 18:26;emilles;BinaryExpressionHelper#evaluateEqual is adding a cast in between visiting the RHS of the assignment and the LHS.  Since the LHS has not been visited yet, it cannot be determined if the variable ""type"" references the field in SubClass or TopClass yet.  https://github.com/apache/groovy/blob/49ee146850d866513aa84bc49bf22e06687484d5/src/main/java/org/codehaus/groovy/classgen/asm/BinaryExpressionHelper.java#L475;;;","24/Jul/20 07:46;monti;Since this was the only issue relating to {{with}}  in Groovy 3.0.5, I think this fix might have broken behaviour in Spock (using 2.0-M3):

This works in 3.0.4:
{code:java}
    static BOOKING = 123
    def 'get stuff'() {
      given:
        def stuff = [ booking: 123 ]

      expect:
        with(stuff) {
            booking == BOOKING
        }
    }
{code}

But fails in 3.0.5 with:
{code:java}
Condition not satisfied:

booking == BOOKING
|       |  |
123     |  null
        false
{code}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
collate() on empty list shall return empty list,GROOVY-7699,12917606,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,mmally,mmally,02/Dec/15 15:23,01/Feb/17 23:18,14/Jul/23 06:01,29/Jul/16 10:52,2.4.4,2.4.5,,,,,,,,,,,,,,,,2.4.8,,,,groovy-jdk,,,,0,,,,,,,"collate() on empty list shall return empty list instead of list containing one element (empty list).

Expected:
{code:java}[].collate(n) == []{code}

Actual:
{code:java}[].collate(n) == [[]]{code}

where *n* is *int* in *(1..oo)*","Darwin Michas-MacBook-Pro.local 15.0.0 Darwin Kernel Version 15.0.0: Sat Sep 19 15:53:46 PDT 2015; root:xnu-3247.10.11~1/RELEASE_X86_64 x86_64

Groovy Version: 2.4.5 JVM: 1.8.0_60 Vendor: Oracle Corporation OS: Mac OS X",githubbot,mmally,paulk,rahulsom,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 29 10:52:29 UTC 2016,,,,,,,,,,"0|i2p6dz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Dec/15 01:02;githubbot;GitHub user rahulsom opened a pull request:

    https://github.com/apache/groovy/pull/205

    GROOVY-7699: collate() on an empty list is an empty list.

    I think GROOVY-7699 should be fixed, but I noticed it's by design that it returns a list of one empty list.
    
    I committed code from IDEA, and it removed trailing spaces from lines. If that's a problem, I'll close this and resend a PR.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/rahulsom/incubator-groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/205.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #205
    
----
commit e390a9ccb79660cb2ce89e9a104b6a0de25ce73a
Author: Rahul Somasunderam <rahul.som@gmail.com>
Date:   2015-12-06T00:58:31Z

    GROOVY-7699: collate() on an empty list is an empty list.

----
;;;","06/Dec/15 01:02;rahulsom;There is a test that specifically checks this

{code:java}
  void testEmpty() {
    assert [].collate( 3 ) == [[]]
  }
{code}

So I believe it is by design. However I see why it makes sense to return an empty list.

I've opened a PR, and would like to learn from the experts on this.;;;","29/Jul/16 10:50;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/205
;;;","29/Jul/16 10:52;paulk;Proposed PR merged. Thanks to all involved!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic safe navigation is broken for property style non-synthetic setter calls,GROOVY-7698,12917304,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,leonard84,leonard84,01/Dec/15 16:38,22/Feb/16 20:48,14/Jul/23 06:01,17/Dec/15 05:56,2.4.0,2.4.1,2.4.2,2.4.3,2.4.4,2.4.5,,,,,,,,,,,,2.4.6,,,,,,,,1,,,,,,,"{{@CompileStatic}} does not create correct safe-navigation code for java setters when using property syntax. This regression happened with the update to 2.4 and affects all released versions up till now. The 2.3.x versions produce correct instructions.

I've created a small demo project to reproduce this issue https://github.com/leonard84/groovy-compilestatic-bug

Here a minimal excerpt to visualize the problem.
{code:java|title=SafeNavigation.groovy}
@CompileStatic
class SafeNavigation {
    void javaSafeNavigation6() {
        DetailJava detailJava = null
        detailJava?.id = 'new'
    }
}
{code}

{code:java|title=DetailJava.java}
public class DetailJava {

    private String id;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
}
{code}

Using IntelliJs decompiler (Fernflower)

{code:java|title=groovy-2.4.x}
   public void javaSafeNavigation6() {
        Object detailJava = null;
        String var2 = ""new"";
        ((DetailJava)detailJava).setId(var2);
        Object var10001 = null;
    }
{code}

{code:java|title=groovy-2.3.x}
    public void javaSafeNavigation6() {
        Object detailJava = null;
        Object var10000;
        if(detailJava != null) {
            ((DetailJava)detailJava).setId(""new"");
            var10000 = null;
        } else {
            var10000 = null;
        }
    }
{code}

As you can see the null check is completely omitted. When using the setter directly it works, also reading the value works for both getter and property style. It also works correctly for groovy classes.",,githubbot,leonard84,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Dec 17 05:42:21 UTC 2015,,,,,,,,,,"0|i2p4iv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Dec/15 23:43;shils;This doesn't appear to be a case of java vs. groovy classes, but rather properties vs. fields with explicitly defined setters. The following example also reproduces the issue:

{code}
class Foo {

    private String id

    String setId(String id) {                    
        this.id = id
    }
}
      
@groovy.transform.CompileStatic            
void test(Foo foo) {            
    foo?.id = 'new'
}
test(null)
{code}

The cause is the same as what you pointed out in the decompiled code - there's no branching for the null case.;;;","02/Dec/15 00:27;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/201

    GROOVY-7698 Safe navigation is broken for property style non-syntheti…

    …c setter calls under static compilation

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7698

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/201.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #201
    
----
commit 93a9ea6b4cb539bb446a7da3025bd9fab3dfc2cb
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2015-12-02T00:26:21Z

    GROOVY-7698 Safe navigation is broken for property style non-synthetic setter calls under static compilation

----
;;;","02/Dec/15 01:06;leonard84;That was quick :) Should I update the title to reflect the correct cause?;;;","02/Dec/15 19:52;shils;Sure, thanks for reporting this!;;;","17/Dec/15 05:42;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/201
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"GroovyScriptEngine.loadScriptByName doesn't support environment variable ""groovy.ast""",GROOVY-7697,12917260,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,m.ewert,m.ewert,01/Dec/15 14:35,01/Feb/17 23:18,14/Jul/23 06:01,07/Jul/16 20:34,,,,,,,,,,,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"When setting the environment variable ""groovy.ast"" to ""xml"" and calling GroovyScriptEngine.loadScriptByName  a FileNotFoundException is thrown (which is caught internally), because a FileWriter is created from a String representation of an URI.

In class SourceUnit method saveAsXML there should be some code added like:

{code}
FileWriter writer;
if (name.startsWith(""file:"")) {
  writer = new FileWriter(new File(new URI(name + "".xml"")));
} else {
  writer = new FileWriter(name + "".xml"")
}
...
{code}

Or however URIs are handled in Groovy. Exception handling still has to be added.",,githubbot,jwagenleitner,m.ewert,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 07 20:34:02 UTC 2016,,,,,,,,,,"0|i2p493:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/May/16 17:23;githubbot;GitHub user andresteingress opened a pull request:

    https://github.com/apache/groovy/pull/330

    GROOVY-7697: GroovyScriptEngine.loadScriptByName doesn't support envi…

    …ronment variable ""groovy.ast""
    
    This PR fixes an issue where the ""groovy.ast"" dump (only god, its author and the ticket author knew this existed) would not be saved when a script was loaded by name via the GSE. In that case, the `XStreamUtils` instance was given an URI (String) instead of an absolute path and the code there broke.
    
    Regarding error handling in `XStreamUtils` (as this was also mentioned in the ticket): I did not change anything into that direction as I am not convinced that such a secondary ""add-on"" feature should in any way influence behaviour in `SourceUnit#convert`.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/andresteingress/groovy GROOVY-7697

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/330.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #330
    
----
commit 70fee35eef16dd68128410a5f51e1ed94742b47a
Author: Andre Steingress <me@andresteingress.com>
Date:   2016-05-07T16:58:39Z

    GROOVY-7697: GroovyScriptEngine.loadScriptByName doesn't support environment variable ""groovy.ast""

----
;;;","07/Jul/16 19:38;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/330
;;;","07/Jul/16 20:34;jwagenleitner;Merged PR from [~andresteingress]

Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bug with @TypeChecked and generic properties of Java classes used in binary expressions,GROOVY-7696,12917192,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,m.ewert,m.ewert,01/Dec/15 09:12,02/May/17 02:03,14/Jul/23 06:01,26/May/16 05:28,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Compiler,,,,0,,,,,,,"I have the following two Java Classes:

{code}
import java.math.BigDecimal;

public abstract class Attribute<T> {

    private BigDecimal numericValue;

    public abstract T getValue();

    public abstract void setValue(T value);

    public BigDecimal getNumericValue() {
        return numericValue;
    }

    public void setNumericValue(BigDecimal numericValue) {
        this.numericValue = numericValue;
    }
}
{code}

{code}
import java.math.BigDecimal;

public class LongAttribute extends Attribute<Long> {
    public Long getValue() {
        return getNumericValue() == null ? null : getNumericValue().longValue();
    }
    public void setValue(Long value) {
        setNumericValue(BigDecimal.valueOf(value));
    }
}
{code}

And a Groovy test class with @TypeChecked annotation:

{code}
import groovy.transform.TypeChecked

@TypeChecked
class Scratch {
    public static void main(String[] args) {
        LongAttribute attr = new LongAttribute();
        attr.value = 0L
        println ""getter: "" + attr.value
        println ""smaller as 0? "" + (attr.value < 0)
    }
}
{code}

Compiling the class leads to the error message:

{code}
Error:(10, 36) Groovyc: [Static type checking] - Cannot find matching method java.lang.Object#compareTo(int). Please check if the declared type is right and if the method exists.
{code}

Removing the @TypeChecked annotation or moving the Java classes into the Groovy class as static inner classes suppresses the compilation error.",,m.ewert,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 26 05:28:53 UTC 2016,,,,,,,,,,"0|i2p3tz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/May/16 05:28;paulk;I can replicate this error on 2.4.5 but it appears to be fixed on 2.4.6 and master. Resolving for now. Please reopen if you are still having problems.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Results of spread safe method calls should be stored in temporary variables,GROOVY-7694,12916748,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,shils,shils,shils,28/Nov/15 17:53,22/Feb/16 20:48,14/Jul/23 06:01,05/Dec/15 05:55,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Static compilation,,,,0,,,,,,,"Currently, the following code throws an NPE during class generation because the static compiler creates variables of the form ""spreadresultX"" to store the results of spread safe method calls. See GROOVY-7656 for the original discussion.

{code}
@groovy.transform.CompileStatic
static void test(String a, String b, List spreadresult1) {
    [a, b]*.length()
}
test('a', 'b', [])
{code}",,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Dec 05 05:45:30 UTC 2015,,,,,,,,,,"0|i2p13b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Nov/15 18:38;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/200

    GROOVY-7694 Results of spread safe method calls should be stored in t…

    …emporary variables

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7694

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/200.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #200
    
----
commit e8375876967a262cceeda73d108240b2d09e896f
Author: Shil Sinha <shils@apache.org>
Date:   2015-11-30T18:36:57Z

    GROOVY-7694 Results of spread safe method calls should be stored in temporary variables

----
;;;","05/Dec/15 05:45;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/200
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checking error on generic property with covariant type in subclass,GROOVY-7691,12916519,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,fpavageau,fpavageau,26/Nov/15 22:27,09/Jun/20 10:07,14/Jul/23 06:01,13/May/18 13:18,2.4.5,,,,,,,,,,,,,,,,,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,,Static Type Checker,,,,0,test,,,,,,"A property declared with a generic type in a superclass is not seen with the correct covariant type in a subclass narrowing the type:
{code}
abstract class AbstractNumberWrapper<S extends Number> {
    protected final S number;

    AbstractNumberWrapper(S number) {
        this.number = number
    }
}
class LongWrapper<S extends Long> extends AbstractNumberWrapper<S> {
    LongWrapper(S longNumber) {
        super(longNumber)
    }

    S getValue() {
        return number;
    }
}
assert new LongWrapper<Long>(42L).value == 42L
{code}
raises the following error when type checked:
{noformat}
[Static type checking] - Cannot return value of type java.lang.Number on method returning type S
 @ line 15, column 28.
                       return number;
                              ^

1 error{noformat}",,daniel_sun,fpavageau,githubbot,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 09 10:07:54 UTC 2020,,,,,,,,,,"0|i2ozon:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Nov/15 22:40;githubbot;GitHub user fpavageau opened a pull request:

    https://github.com/apache/incubator-groovy/pull/198

    GROOVY-7691 Create a test

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fpavageau/incubator-groovy GROOVY-7691

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/198.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #198
    
----
commit e5823bb963f41b23057f4fce7e5c2262e3dc74b0
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-11-26T22:37:46Z

    GROOVY-7691 Create a test

----
;;;","28/Nov/15 10:07;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/198
;;;","11/May/18 06:40;daniel_sun;It is fixed by the proposed PR. Thanks!
https://github.com/apache/groovy/pull/198;;;","11/May/18 20:25;fpavageau;Actually, my PR added a test annotated {{@NotYetImplemented}} demonstrating the problem, and that's still the case in [master|https://github.com/fpavageau/groovy/blob/master/src/test/groovy/transform/stc/GenericsSTCTest.groovy#L1784]: the problem is still present, the issue shouldn't be closed.;;;","13/May/18 13:18;daniel_sun;Fixed by https://github.com/apache/groovy/commit/67675780a258aa27c62ce29dcbda7683502e6a67;;;","09/Jun/20 10:07;paulk;See GROOVY-9580 for followup fix for @NotYetImplemented test.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TypeChecked Groovy does not throw illegal assignment error at compile time when using raw generic type,GROOVY-7690,12916423,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,eseidinger,eseidinger,26/Nov/15 11:52,03/Feb/22 22:32,14/Jul/23 06:01,21/Oct/21 14:41,2.4.5,,,,,,,,,,,,,,,,,4.0.0-beta-2,,,,,,,,0,,,,,,,"I want to provoke a compiler error. I am omitting the type parameter of a generic List and use it as a raw type. When getting an object from the raw list it should be of type Object. When casting this Object implicitly to an Integer the compiler should throw an illegal assignment error but it doesn't. 

The following code example should illustrate the problem. Case 2 and 3 should throw the same error but only case 3 is producing an error.

{code}
import groovy.transform.TypeChecked

@TypeChecked
class Test {

    static method() {
        ArrayList<Integer> integerArrayList = new ArrayList<>();
        ArrayList rawArrayList = new ArrayList();
        ArrayList<Object> objectArrayList = new ArrayList<>();

        integerArrayList << 1;
        rawArrayList << new Object();
        objectArrayList << new Object();

        Integer x = integerArrayList.get(0);    // Case 1: works as expected
        Integer y = rawArrayList.get(0);        // Case 2: doesn't throw a compile error but should
        Integer z = objectArrayList.get(0);     // Case 3: throws a compile error as expected
    }
}
{code}",,eseidinger,haridsv,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10055,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-11-26 11:52:20.0,,,,,,,,,,"0|i2oz3b:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using spread operator on function with compile static results in two calls to function,GROOVY-7688,12916379,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,shils,m.levvy@gmail.com,m.levvy@gmail.com,26/Nov/15 08:40,22/Feb/16 20:48,14/Jul/23 06:01,30/Nov/15 23:43,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,,,,,0,,,,,,,"Method *heavyOperation()* will be called twice. If we remove @CompileStatic, problem is solved.

{noformat}
    @CompileStatic
    List<String> invokeCompileStatic(Service service){
        service.heavyOperation()*.toString()
    }
{noformat}
A test which confirms it, can be found in [my Gist|https://gist.github.com/mlevvy/948e13414be360a20212]",,githubbot,jwagenleitner,m.levvy@gmail.com,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 30 18:34:01 UTC 2015,,,,,,,,,,"0|i2oytj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Nov/15 16:18;jwagenleitner;Looks similiar to issue GROOVY-7656.;;;","28/Nov/15 01:43;shils;As John mentioned, this is a more general case of the bug in GROOVY-7656. Receivers for spread safe method calls are visited twice - once as a receiver of the spread safe method call, and once as a receiver of the iterator of the resulting for loop. ;;;","28/Nov/15 17:59;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/199

    GROOVY-7688 Spread safe method call receivers with side effects shoul…

    …d not be visited twice
    
    * StaticInvocationWriter#makeCall: use temporary variables for spread safe receiver expressions which are not variable or constant expressions
    * StaticTypesStatementWriter#writeOptimizedForEachLoop: remove temporary variables from compileStack after their use

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7688

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/199.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #199
    
----
commit 8bcbc62401a8f8704992d730ebbf95dca5ee2fec
Author: Shil Sinha <shils@apache.org>
Date:   2015-11-28T17:42:54Z

    GROOVY-7688 Spread safe method call receivers with side effects should not be visited twice
    * StaticInvocationWriter#makeCall: use temporary variables for spread safe receiver expressions which are not variable or constant expressions
    * StaticTypesStatementWriter#writeOptimizedForEachLoop: remove temporary variables from compileStack after their use

----
;;;","30/Nov/15 18:34;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/199
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bug with @CompileStatic and nested closures,GROOVY-7687,12916163,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,m.ewert,m.ewert,25/Nov/15 14:28,03/Apr/19 05:50,14/Jul/23 06:01,22/Jan/19 04:45,2.4.5,,,,,,,,,,,,,,,,,2.5.6,3.0.0-beta-1,,,Compiler,,,,1,,,,,,,"I've encountered a strange bug in conjunction with closures, delegates and @CompileStatic. The following code works as expected:

{code}
import groovy.transform.CompileStatic

@CompileStatic
class SimpleTest {

    static class Foo {
        List<Bar> bars = Arrays.asList(new Bar())
    }

    static class Bar {
        String message
        public String toString() {return message}
    }


    void execute(Foo foo) {
        interactions(foo, {
            bars.each ( { bar -> bar.message = ""hello world""})
        })
    }

    void interactions(Foo foo, @DelegatesTo(Foo) Closure closure) {
        closure.delegate = foo
        closure.resolveStrategy = Closure.DELEGATE_FIRST
        closure()
    }

    static void main(String... args) {
        SimpleTest test = new SimpleTest()
        Foo foo = new Foo()
        test.execute(foo)
        println foo.bars
    }
}
{code}

But when the bars member is prefixed with a public modifier the following compilation error is thrown

{code}
Exception in thread ""main"" java.lang.ClassCastException: SimpleTest$_execute_closure1 cannot be cast to SimpleTest$Foo
	at SimpleTest$_execute_closure1.doCall(SimpleTest.groovy:18)
	at SimpleTest$_execute_closure1.call(SimpleTest.groovy)
	at SimpleTest.interactions(SimpleTest.groovy:25)
	at SimpleTest.execute(SimpleTest.groovy:17)
	at SimpleTest.main(SimpleTest.groovy:31)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
{code}

Here the code causing the error:

{code}
import groovy.transform.CompileStatic

@CompileStatic
class SimpleTest {

    static class Foo {
        public List<Bar> bars = Arrays.asList(new Bar())
    }

    static class Bar {
        String message
        public String toString() {return message}
    }


    void execute(Foo foo) {
        interactions(foo, {
            bars.each ( { bar -> bar.message = ""hello world""})
        })
    }

    void interactions(Foo foo, @DelegatesTo(Foo) Closure closure) {
        closure.delegate = foo
        closure.resolveStrategy = Closure.DELEGATE_FIRST
        closure()
    }

    static void main(String... args) {
        SimpleTest test = new SimpleTest()
        Foo foo = new Foo()
        test.execute(foo)
        println foo.bars
    }
}
{code}",,m.ewert,paulk,werickson,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-9063,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 22 04:45:55 UTC 2019,,,,,,,,,,"0|i2oxhj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Dec/15 15:00;m.ewert;The following test is better suited to be executed in the groovy project:

{code}
package groovy.bugs

/**
 * See https://issues.apache.org/jira/browse/GROOVY-7687.
 */
class NestedClosureWithCompileStaticBug extends GroovyTestCase  {

    void testBug() {
        assertScript '''
        @groovy.transform.CompileStatic
        class BugTest {
            static class Foo {
                public List<String> messages = Arrays.asList(""hello world"")
            }

            void interactions(Foo foo, @DelegatesTo(Foo) Closure closure) {
                closure.delegate = foo
                closure()
            }

            void execute() {
                interactions(new Foo(), {
                    messages.each ( { message -> println message})
                })
            }
        }
        new BugTest().execute()
        '''
    }
}
{code}

The bug doesn't occur, if I change line 42 in file StaticTypesTypeChooser from 

{code}
inferredType = (ClassNode) target.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
{code}

to 

{code}
inferredType = null; //(ClassNode) target.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
{code}

I don't know, what is disabled now, but at least my use case now works just fine. Would be great if someone may hunt down this bug, I had to stop here, because it was getting too complicated for an external. ;-)
;;;","22/Jan/19 04:45;paulk;I believe this was fixed as part of GROOVY-7996.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Can not see local variable from overriden method called from the constructor of an anonymous class instance,GROOVY-7686,12915935,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,roman.saveljev,roman.saveljev,24/Nov/15 21:21,31/Jan/22 18:02,14/Jul/23 06:01,20/Mar/21 02:19,2.4.5,,,,,,,,,,,,,,,,,2.5.16,3.0.8,4.0.0-alpha-3,,Compiler,groovy-runtime,,,0,,,,,,,"Reduced code showing the problem: https://gist.github.com/RomanSaveljev/71ed29b0df3eb306485c

In the runtime it fails with:

{noformat}
Caught: java.lang.NullPointerException
java.lang.NullPointerException
	at bug$1.func(bug.groovy:14)
	at A.<init>(bug.groovy:3)
	at bug$1.<init>(bug.groovy)
	at bug.func(bug.groovy:11)
	at bug.run(bug.groovy:22)
{noformat}

It happens, because inside the overriden method it tries to access locally defined {{t}}. I have translated the same code to Java (see the gist) and it works as expected.",Linux,roman.saveljev,,,,,,,,,,,,,,,"eric-milles opened a new pull request #1522:
URL: https://github.com/apache/groovy/pull/1522


   https://issues.apache.org/jira/browse/GROOVY-7686


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;17/Mar/21 14:04;githubbot;600","danielsun1106 merged pull request #1522:
URL: https://github.com/apache/groovy/pull/1522


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;19/Mar/21 20:06;githubbot;600","danielsun1106 commented on pull request #1522:
URL: https://github.com/apache/groovy/pull/1522#issuecomment-803089699


   Merged. Thanks!


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;19/Mar/21 20:06;githubbot;600",,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-11-24 21:21:16.0,,,,,,,,,,"0|i2ow2v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Memory leak when using Groovy as JSR-223 scripting language.,GROOVY-7683,12915354,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,jigga,jigga,23/Nov/15 14:56,23/May/17 10:13,14/Jul/23 06:01,11/Sep/16 04:03,2.4.5,,,,,,,,,,,,,,,,,2.4.8,,,,GroovyScriptEngine,,,,9,jsr-223,,,,,,"We have a Java EE 7 web application in production that when handling single HTTP request can load and execute up to several Groovy scripts using the jsr-223 API. This application is deployed to GlassFish 4.1 server cluster with 4 instances, each having 8 GB of RAM available (Xmx=8g). We have to restart them every couple of days (3-4), because of leaking memory. After analyzing a couple of heap dumps, our main suspect is Groovy with its MetaMethodIndex$Entry class (the below table shows the top object from one of the heap dumps).

||Class Name||Objects||Shallow Heap||Retained Heap||
|MetaMethodIndex$Entry| 3 360 001 |  188 160 056 | >= 305 408 024

To confirm our suspicions, I created simple Maven project with a single test case. The project is available on [GitHub|https://github.com/jigga/groovy-jsr223-leak]. The test case executes 10 different scripts (minimal differences) obtained from a single template 20000 times in 64 worker threads (the main thread is put to sleep for 10 seconds before starting worker threads, so that one can attach JVisualVM to the test process). After all threads are done, System.gc() is called to provoke full GC. Attaching to the process in which tests are run with JVisualVM reveals that the memory is not reclaimed.

To run the test in your local environment, simply clone the [GitHub|https://github.com/jigga/groovy-jsr223-leak] project and run:
{code}
mvn test
{code}

The same test can be run with the *-Dlanguage=javascript* system option, which switches ScriptEngine from Groovy to Nashorn and uses slightly modified script template (only syntactical differences).
{code}
mvn -Dlanguage=javascript test
{code}
Running the test case using built-in Nashorn engine reveals no problems - all allocated memory is reclaimed after full GC.

I know that the test case is run in Java SE environment, but I guess that it clearly reflects the issue. If it's not enough, I can create an arquillian test case.

This may be a possible duplicate of [GROOVY-7109|https://issues.apache.org/jira/browse/GROOVY-7109].

Any workarounds for this issue would be greatly appreciated.","OS: tested on Mac OS X El Capitan and Windows 10.
JVM: tested on 1.8.0_60 and 1.8.0_65.",belkaram,blackdrag,githubbot,gsAndrew,jexler,jigga,jkemnade,jwagenleitner,lari.hotari@sagire.fi,maciekjira,moshe@egis-software.com,pascalschumacher,PetiKoch,pmouawad,vguna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7623,GROOVY-7646,GROOVY-8189,GROOVY-8199,GROOVY-7913,GROOVY-7109,GROOVY-7731,,,,,,,,,,,"16/Dec/15 14:52;jkemnade;0001-GROOVY-7683-replace-hard-reference-from-ClassInfo-to.patch;https://issues.apache.org/jira/secure/attachment/12778009/0001-GROOVY-7683-replace-hard-reference-from-ClassInfo-to.patch","17/Aug/16 03:03;gsAndrew;Screen Shot 2016-08-16 at 10.53.04 PM.png;https://issues.apache.org/jira/secure/attachment/12824056/Screen+Shot+2016-08-16+at+10.53.04+PM.png",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Important,,,,,,,,,9223372036854775807,,,Wed Sep 28 00:26:03 UTC 2016,,,,,,,,,,"0|i2oshr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Nov/15 18:55;blackdrag;It could also be related to GROOVY-7591. This can be verified by setting the system property groovy.use.classvalue and see if the memory leak still happens;;;","23/Nov/15 19:42;jigga;Unfortunately, adding *-Dgroovy.use.classvalue=false* system property when running the test did not help - the memory was not reclaimed after the full GC. Any other options? :);;;","24/Nov/15 07:44;jigga;The other thing that bothers me is that each time the test is run, there are always 20000 different script classes loaded (Script1 to Script20000), even though there's only 10 variations of the script. Is this the expected behavior? The good thing tough is that there are no instances of the script classes, only the script classes themselves.;;;","27/Nov/15 22:28;jwagenleitner;{quote}there are always 20000 different script classes loaded (Script1 to Script20000), even though there's only 10 variations of the script. Is this the expected behavior?{quote}

Since the test project creates 20,000 engines and since the script class cache is per engine this will create 20k classes.  This also creates lots of classloader instances and global cached methods.  In this particular case it seems like creating a single engine with a logger binding and then using the {{context}} bean parameter to pass the {{taskId}} and receive the {{result}} would be the way to go.  I realize the test project may have crafted to show the leak and not a real world example.  A global class cache would help here, but I'm not sure if there are reasons (i.e., classloader) to keep it per instance.  I'm not that familiar with JSR-223 so may be misunderstanding the use-case here.

As for the large number of uncollected {{MetaMethodIndex$Entry}} instances I wonder if this might be similar to the issue reported in GROOVY-7083, since the [script metaclass is modified|https://github.com/apache/incubator-groovy/blob/aa5fa948de5222abc570d9e1c41dcea6799964cf/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java#L317] and this might be why the classes are not unloaded.;;;","28/Nov/15 09:09;blackdrag;Thanks John. From the javadoc for ScriptEngineFactory:
{code}
ScriptEngine getScriptEngine()

Returns an instance of the ScriptEngine associated with this ScriptEngineFactory. A new ScriptEngine is generally returned, but implementations may pool, share or reuse engines.{code}
So it is not wrong to have 20k engines can happen... But of course this should still not cause a memory leak. As for the setting the meta class... The case in GROOVY-7083 sets a meta class in the registry, which forces the registry to keep a reference to this class at all times. But in the case here we set the meta class directly on the object, which only that object will have a reference to the meta class. So this should not have an effect and the object along with the meta class should be collectable (independent of the class and the classloader)
;;;","28/Nov/15 22:24;jwagenleitner;I tested the sample project with Groovy 2.3.11 and after the gc() call it unloaded all but about 2k classes.   The MetaMethodIndex$Entry instance count dropped to 522.  Tested with 2.4.0 and it behaves similar to 2.4.5 by not unloading the script classes.

It looks like [commit 97d78e9e52deb52c8e66db501ef208f30384d014|https://github.com/apache/incubator-groovy/commit/97d78e9e52deb52c8e66db501ef208f30384d014] may have introduced a hard reference to the class (klazz) in combination of the ClassValue whereas I think it was a soft reference prior.  In analyzing the heap dump it looks like

{code}
java.lang.Thread
- <Java Local>, contextClassLoader sun.misc.Launcher$AppClassLoader
    '- classes java.util.Vector
      '- elementData java.lang.Object[1280]
         '- [822] class org.codehaus.groovy.reflection.ClassInfo
            '- globalClassValue org.codehaus.groovy.reflection.GroovyClassValuePreJava7
               '- map org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Map
                  '- segments org.codehaus.groovy.util.AbstractConcurrentMapBase$Segment[16]
                     '- [8] org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Segment
                        '- table java.lang.Object[2048]  
                           '- [1127] org.codehaus.groovy.reflection.GroovyClassValuePreJava7$EntryWithValue
                              '- value org.codehaus.groovy.reflection.ClassInfo 
                                 '- klazz class Script15965                                        
                                    '- <classloader> groovy.lang.GroovyClassLoader$InnerLoader
{code}

I'm not sure, but wanted to point it out since it seems to be a significant change between 2.3.x and 2.4.x that may have an affect on this issue.;;;","29/Nov/15 09:27;blackdrag;the change you mention was made to use ClassValue, yes. But because of GROOVY-7591 (and https://bugs.openjdk.java.net/browse/JDK-8136353) Groovy 2.4.5 does not use ClassValue by default anymore... and it does not show up in the dump you show here as well. But yes... if those are all hard references (and it looks like it), then it is not right.;;;","15/Dec/15 13:06;jkemnade;I'm also experiencing those leaks.
{noformat}
this     - value: org.codehaus.groovy.reflection.ClassInfo #392
 <- value     - class: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$EntryWithValue, value: org.codehaus.groovy.reflection.ClassInfo #392
  <- [65]     - class: java.lang.Object[], value: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$EntryWithValue #317
   <- table     - class: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Segment, value: java.lang.Object[] #424042
    <- [11]     - class: org.codehaus.groovy.util.AbstractConcurrentMapBase$Segment[], value: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Segment #5
     <- segments     - class: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Map, value: org.codehaus.groovy.util.AbstractConcurrentMapBase$Segment[] #2
      <- map     - class: org.codehaus.groovy.reflection.GroovyClassValuePreJava7, value: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Map #1
       <- globalClassValue     - class: org.codehaus.groovy.reflection.ClassInfo, value: org.codehaus.groovy.reflection.GroovyClassValuePreJava7 #1
        <- [8080]     - class: java.lang.Object[], value: org.codehaus.groovy.reflection.ClassInfo class ClassInfo
         <- elementData     - class: java.util.Vector, value: java.lang.Object[] #78509
          <- classes     - class: org.apache.catalina.loader.WebappClassLoader, value: java.util.Vector #242
{noformat}

 Can we do something about them for 2.4.6? I'd try to help with a patch but I'm afraid that this part of the Groovy code is still over my head.;;;","16/Dec/15 14:52;jkemnade;If it's just a matter of replacing the hard reference by a soft one, here's a patch. If not, maybe someone can give a hint as to how this should be solved.;;;","16/Dec/15 15:15;blackdrag;normally the ClassInfo object does not only refer to the class directly, but also indirectly using hard references, for example through method methods, which are based on the real methods of the class, which are based on reflection, which then have direct references to classes again, of which usually the class in question is one. If a patch like this fixes the problem so should enabling CMS. So frankly I would not expect this patch to work, in fact I would be quite surprised if it does. But if someone has this problem and can try out if the patch changes anything, I am curious to hear about the results. I would help even if the patch would not work out;;;","16/Dec/15 15:38;jkemnade;This does not seem to fix GROOVY-7083 however.;;;","16/Dec/15 15:43;jkemnade;Oh, I read your comment too late. Yes, apparently it doesn't fix the problem. Maybe I misunderstood your comment about the hard references.;;;","16/Dec/15 21:54;jwagenleitner;I tested the referenced Github LeakTest project again and this time created some memory pressure after the loop by calling the following method:

{code}
    // Create memory pressure to force soft reference collection
    private void createOOM() {
        List<Long[]> buffer = new ArrayList<Long[]>(100);
        int chunk = 128 * 1024 * 1024;
        int limit = 50000;
        try {
            for (int i = 0; i < limit; i++) {
                buffer.add(new Long[chunk]);
            }
        } catch (OutOfMemoryError oom) {
            buffer.clear();
            return;
        }
        throw new RuntimeException(""OOM expected"");
    }
{code}

Using the default setting with {{ClassValue}} disabled things looked pretty much the same as before.  However, enabling {{ClassValue}} by adding the following to the static initializer:

{code}
System.setProperty(""groovy.use.classvalue"", ""true"");
{code}

Seemed to dramatically reduce the heap size. 

Size: 60mb vs 1.2G
Classes: 2.6k vs 22.6k
Objects: 1.5m vs 18.2m
Class Loader: 6 vs 40k

So I think [~blackdrag] original suggestion to try enabling ClassValue is worth a try.  You might still see heap usage creep up over time but I would expect as memory pressure builds close to the 8G max you'll see GC work and should experience a lot less severe leak than without using it.;;;","17/Dec/15 07:50;jkemnade;Yes, the classes are properly cleaned up with {{groovy.use.classvalue=true}}, so I guess the problem must be in {{GroovyClassValuePreJava7}}.
Err, this may be a stupid question, but, is {{GroovyClassValue.remove(Class)}} ever called?;;;","20/Dec/15 13:14;pascalschumacher;If the problem is in GroovyClassValuePreJava7 one could compare [https://github.com/apache/groovy/blob/master/src/main/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java] and [http://hg.openjdk.java.net/jdk8u/jdk8u60-dev/jdk/file/tip/src/share/classes/java/lang/ClassValue.java] for differences.;;;","20/Dec/15 13:25;pascalschumacher;Intellij can not find any usages of GroovyClassValue.remove(Class). I do not know anything about this part of Groovy so no idea were it's supposed to be used.;;;","21/Dec/15 18:52;jwagenleitner;With {{GroovyClassValuePreJava7}} I don't think {{GroovyClassValue.remove(Class)}} is designed to be called directly, I think it would be enough if the cached Entry in the ManagedConcurrentMap was collected due to its weakly held key (Class) being collected.  I believe the issue is that the cached value in the map (ClassInfo) stores a [strong reference to the cached key (Class)|https://github.com/apache/groovy/blob/73f5979a468f1508134eba20ce503630b0fe0cc7/src/main/org/codehaus/groovy/reflection/ClassInfo.java#L47].  So I don't think the Entry ever gets cleared.  I think changing this to a weak ref would allow the cache entry to be cleared, but hard to tell what problems that might cause or if it would ever be possible for the Class to be collected while the ClassInfo is used causing the weak ref to return null for the Class.

I also think the [ClassInfoCleanup|https://github.com/apache/groovy/blob/73f5979a468f1508134eba20ce503630b0fe0cc7/src/main/org/codehaus/groovy/reflection/ClassInfo.java#L77] is not [doing what it's expected to do for cleanup|https://github.com/apache/groovy/blob/73f5979a468f1508134eba20ce503630b0fe0cc7/src/main/org/codehaus/groovy/reflection/ClassInfo.java#L477-L489].  Since it's not stored it goes out of scope immediately and will be collected long before the ClassInfo it's meant to clean up after is eligible for collection.

I'm not familiar with this part of the code, so might be way off.;;;","22/Dec/15 01:17;blackdrag;How things on the JVM are supposed to be working is the following... imagine a class that is nowhere referenced anymore, but in an equally otherwise non-referenced class loader and another object. Imagine this other object is softly reachable, meaning no strong/weak/phantom reference is pointing to it.This is supposed to mean, that the class is softly reachable as well. So in theory, as long as the ClassInfo object is not strongly reachable, the ClassInfo object could be collected along with the class.
In the practice though, things do not always work like that. I know for sure, that the IBM JVM for example needs special options given to it, to even check such a case. For the Oracle JVM enabling CMS used to help with this problem. For the Oracle JVM the problem is that normally the garbage collection for classes and the garbage collection for instances is not done together. So unless the ClassInfo object is collected it happens that the class will stay. Since ClassInfo objects are normally softly referenced, they will stay till the very last moment, increasing the probability of the problem to occur. The fact, that there is a multitude of objects referenced by ClassInfo, which hold strong references to the class (for example a reflective method object could be one, but the type information in the meta methods is already enough) does not help the garbage collector at all.
As bad as it sounds, in the end it depends on the implementation of the garbage collector if that object can be collected. So it is supposed to work, but can for several reasons not sometimes.

Of course that is all theory and past experience. It is very possible, that there is somewhere a strong reference, where it should not be. But as I tried to explain above, changing ClassInfo to use a weak key for the Class is not something I would expect to really help. The patch that is attached here, tries it with a SoftReference. WeakReference could be better, but frankly there are still many many strong references to the class through other objects hard referenced by the ClassInfo object. Could be, that this decreases the number of hard references just enough to not be over some threshold optimization in the garbage collector and then allows the garbage collector to collect. Or it might not have any effect. My expectation is that it won't change anything.

As for the ClassInfoCleanup.. it is not right that it is not stored. When you create a Soft/WeakReference, then there will be a reference object and a ReferenceQueue. The queue will know the reference. And it is not that those references simply vanish. In fact, if you don't clean up the queue, you will get a memory leak from that side, even if the objects you reference would be collected. But for Weak/SoftReference this is not actually the case, you would need PhantomReference for that. On the other hand, you are right, that this code has almost zero relevance when it comes to the automatic removal of ClassInfo. If the ClassInfo has a strong reference set, the ClassInfo object itself will not be weak referenced. Same for the cleanups... there are more to support garbage collection a little, than that they are really needed. The real code managing the reference is in ManagedLinkedList as far as GlobalClassSet is concerned. Or the manged hashmap in GroovyClassValuePreJava7.

Oh, one correction... ClassInfo is mostly weakly reachable in those structures, not softly. cachedClassRef and artifactClassLoader are should be soft reachable, same for the entries of LocalMap;;;","22/Dec/15 08:51;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/219

    GROOVY-7683 - Memory leak when using Groovy as JSR-223 scripting language

    I am unsure what if any problems making the Class a `WeakReference` might have but thought I'd put this out there for review. 
    
    I also tested against [GROOVY-7646](https://issues.apache.org/jira/browse/GROOVY-7646) which was consistently throwing OOME after <2 mins prior to these changes and ran to completion with changes.
    
    Another thing I noticed in looking at this class is that [uses a `PhantomReference`](https://github.com/apache/groovy/blob/73f5979a468f1508134eba20ce503630b0fe0cc7/src/main/org/codehaus/groovy/reflection/ClassInfo.java#L405) and attempts [to use the value from `get()`](https://github.com/apache/groovy/blob/73f5979a468f1508134eba20ce503630b0fe0cc7/src/main/org/codehaus/groovy/reflection/ClassInfo.java#L435).  However, this will always return `null` so the code path never executes.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7683

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/219.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #219
    
----
commit 10689a29cbf167c40b05c38aa5c144724045eeb0
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2015-12-17T00:44:29Z

    GROOVY-7683 - Memory leak when using Groovy as JSR-223 scripting language

----
;;;","22/Dec/15 09:10;jwagenleitner;Created a PR, this is scary and unfamiliar part of the code but thought I'd put it out there for review. :)  Am really interested in learning more about this part of the code so appreciate the comments so far.

{quote}As for the ClassInfoCleanup.. it is not right that it is not stored. When you create a Soft/WeakReference, then there will be a reference object and a ReferenceQueue. The queue will know the reference. And it is not that those references simply vanish.{quote}

My understanding is that the ReferenceQueue will know of the reference (ClassInfoCleanup) when the referent (ClassInfo) is no longer reachable by strong or soft references.  However, in order for the reference (ClassInfoCleanup) to be enqueued it must be alive when this happens.  But I don't see any reason why the GC would hold on to this object (the ClassInfoCleanup) after the constructor completes.  So that's why I believe that ClassInfoCleanup and DebugRef will never run the finalize method.  Not to mention that both do not override the {{ManagedReference#finalizeReference}} but instead have it named {{finalizeRef}}.;;;","22/Dec/15 10:10;blackdrag;John, you are right... I should not write comments on JIRA at 2:00 in the morning. The Reference has to be alive to be enqueued, you are fully right there. The conclusion that ClassInfoCleanup is then doing about nothing is most likely right as well, some for DebugRef. Those have been handled different before the ClassValue rewrite.;;;","02/May/16 16:19;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/219#discussion_r61761426
  
    --- Diff: src/main/org/codehaus/groovy/util/ManagedReference.java ---
    @@ -46,7 +46,6 @@ public final T get() {
         
         public final void clear() {
             ref.clear();
    -        manager.removeStallEntries();
    --- End diff --
    
    Why did you remove this call?
;;;","02/May/16 16:22;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/219#discussion_r61761881
  
    --- Diff: src/main/org/codehaus/groovy/reflection/ClassInfo.java ---
    @@ -35,13 +36,13 @@
      *
      * @author Alex.Tkachman
      */
    -public class ClassInfo {
    +public class ClassInfo implements Finalizable {
     
         private final LazyCachedClassRef cachedClassRef;
         private final LazyClassLoaderRef artifactClassLoader;
         private final LockableObject lock = new LockableObject();
         public final int hash = -1;
    -    private final Class klazz;
    +    private final WeakReference<Class<?>> klazz;
    --- End diff --
    
    I wonder what we should do if the referenced class has been collected. At least in the non - ClassValue version, it might be, that the ClassInfo still exists. And if then somebody tries to get the meta class using that ClassInfo things will blow up
;;;","02/May/16 16:38;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/219#discussion_r61764022
  
    --- Diff: src/main/org/codehaus/groovy/util/ManagedReference.java ---
    @@ -46,7 +46,6 @@ public final T get() {
         
         public final void clear() {
             ref.clear();
    -        manager.removeStallEntries();
    --- End diff --
    
    `ClassInfo#finalizeReference` calls `setStrongMetaClass(null)` which in turn calls `replaceWeakMetaClassRef(null)` which calls `weakRef#clear` which is on ManagedReference.  This causes a recursive call back into the queue can can lead to stackoverflow if there are lots of ClassInfo ManagedReferences in the Reference Queue.
    
    A related PR that attempts to prevent this reentrant processing is PR #298.
;;;","02/May/16 16:45;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/219#discussion_r61764947
  
    --- Diff: src/main/org/codehaus/groovy/reflection/ClassInfo.java ---
    @@ -35,13 +36,13 @@
      *
      * @author Alex.Tkachman
      */
    -public class ClassInfo {
    +public class ClassInfo implements Finalizable {
     
         private final LazyCachedClassRef cachedClassRef;
         private final LazyClassLoaderRef artifactClassLoader;
         private final LockableObject lock = new LockableObject();
         public final int hash = -1;
    -    private final Class klazz;
    +    private final WeakReference<Class<?>> klazz;
    --- End diff --
    
    That's the question I've struggled with too.  My assumption here is that only the Groovy Runtime should ever ask for ClassInfo objects and in most places I can find they do so either with a Class or an instance of the Class which I think would mean it wouldn't have been collected.  But it's been difficult for me to be certain that the case can never happen.  Best I can think of is maybe check if the ref is null and throw a `GroovyBugError`.
;;;","02/May/16 17:15;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/219#discussion_r61768963
  
    --- Diff: src/main/org/codehaus/groovy/util/ManagedReference.java ---
    @@ -46,7 +46,6 @@ public final T get() {
         
         public final void clear() {
             ref.clear();
    -        manager.removeStallEntries();
    --- End diff --
    
    ok, I +1ed PR #298 
;;;","02/May/16 17:19;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/219#discussion_r61769520
  
    --- Diff: src/main/org/codehaus/groovy/reflection/ClassInfo.java ---
    @@ -35,13 +36,13 @@
      *
      * @author Alex.Tkachman
      */
    -public class ClassInfo {
    +public class ClassInfo implements Finalizable {
     
         private final LazyCachedClassRef cachedClassRef;
         private final LazyClassLoaderRef artifactClassLoader;
         private final LockableObject lock = new LockableObject();
         public final int hash = -1;
    -    private final Class klazz;
    +    private final WeakReference<Class<?>> klazz;
    --- End diff --
    
    I think it would be sufficent to add to each method an according javadoc comment, as well as a class comment, that it is not safe to use  without a Class associated with this ClassInfo. I would even consider a method to get the referenced Class, so people can check/ensure it will continue to exist. In that case we can probably avoid the checks and exceptions
;;;","03/May/16 03:17;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/219#discussion_r61834705
  
    --- Diff: src/main/org/codehaus/groovy/util/ManagedReference.java ---
    @@ -46,7 +46,6 @@ public final T get() {
         
         public final void clear() {
             ref.clear();
    -        manager.removeStallEntries();
    --- End diff --
    
    Thanks for reviewing that other PR.  I merged that PR and will rebase this and leave the call to manager.removeStallEntries().
;;;","15/Aug/16 07:49;vguna;Any news on this?

I also encountered the mentioned problem, that MetaMethodIndex$Entry classes are growing quickly without being able to be GCed.
My scenario is during loadtests on the client side. I use restassured 2.9.0 (uses groovy 2.4.6) to perform json parsing. I could track it down to this little snippet
to reproduce the behavior:

{code}
...
import com.jayway.restassured.path.json.JsonPath;
...
	public static void main(String[] args) throws InterruptedException {
		for (int ci = 0; ci < 100000; ci++) {
			JsonPath.from(""{\""id\"": \"""" + UUID.randomUUID().toString() + ""\""}"").getUUID(""id"");
			Thread.sleep(1);
		}
	}
{code}

Simply take a look using jvisualvm and you see the results.
I also tried the latest 2.4.x groovy version and latest 2.3.x with the same results.
;;;","17/Aug/16 03:03;gsAndrew;I've been tracking/trying to isolate this memory leak for a while now.  I was running Grails 2.5.3 (using Groovy 2.4.4) on Heroku monitoring with New Relic.  First I ran into New Relic's leaky agent with issues around async servlets, upgraded to their latest agent, and then I started running into this. 

I've since forced Grails 2.5.3 to load Groovy 2.4.5 when I was seeing a massive amount of ClassInfo's hanging around and the ""Expando"" class.  Recently I've been seeing a ton of java.ref.lang.Finalizer's..  

Anyhow, I wanted to comment that I've played around with toggling groovy.use.classvalue and the image I attached is when I switched it to true.  It's an interesting visualization to how the GC is behaving and how my non-heap memory is continuing to creep higher and higher although it appears to be at a slower pace than without it set.

!Screen Shot 2016-08-16 at 10.53.04 PM.png!
;;;","30/Aug/16 02:34;gsAndrew;Linking to [Groovy-7623|https://issues.apache.org/jira/browse/GROOVY-7623] as it claims to be a possible solution path to this memory leak issue. ;;;","30/Aug/16 14:20;gsAndrew;Also linking because I added a walkthrough on how I got that JDK to play nice with my grails project.;;;","11/Sep/16 03:07;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/219
;;;","11/Sep/16 04:03;jwagenleitner;Thanks for reporting the issue.  I believe the referenced PR will fix the issue, but please re-open if you find that to not be the case.;;;","11/Sep/16 05:39;gsAndrew;Any idea when the expected 2.4.8 release date is?;;;","28/Sep/16 00:26;jwagenleitner;Not sure, but there's been some talk about it on the dev mailing list which is usually a sign that it's not too far off.;;;",,,,,,,,,,,,,,,,
JsonBuilder or JsonOutput incompatible with JodaTime,GROOVY-7682,12914943,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,jppellerin,jppellerin,20/Nov/15 18:50,03/Feb/22 22:35,14/Jul/23 06:01,14/Jan/22 10:59,2.4.5,,,,,,,,,,,,,,,,,4.0.0,,,,JSON,,,,3,"DateTime,",Json,StackOverflowError,,,,"Using groovy's built-in methods to serialize Joda DateTime to JSON always conclude in a {{StackOverflowError}}.

{code:title=ExampleMethod|type=java}
package com.mgd

import groovy.json.JsonOutput

import org.joda.time.DateTime
import org.joda.time.format.DateTimeFormat
import org.joda.time.format.DateTimeFormatter

class JodaBugJson {

	public static void main(String[] args) {
		DateTimeFormatter formatter = DateTimeFormat.forPattern(""yyyy-MM-dd HH:mm:ss.SSS z"")

		DateTime dt = formatter.parseDateTime(""2015-11-20 13:37:21.123 EST"")

		//String json = new JsonBuilder(dt).toString()	//same outcome
		String json = JsonOutput.toJson(dt)
		println json
	}
}
{code}

Running the above will result in : 

{code: title=Error}
Exception in thread ""main"" java.lang.StackOverflowError
	at org.codehaus.groovy.reflection.ClassInfo.getClassInfo(ClassInfo.java:119)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:261)
	at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:871)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.getMetaPropertyValues(DefaultGroovyMethods.java:364)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.getProperties(DefaultGroovyMethods.java:383)
	at groovy.json.JsonOutput.writeObject(JsonOutput.java:290)
	at groovy.json.JsonOutput.writeMap(JsonOutput.java:424)
	at groovy.json.JsonOutput.writeObject(JsonOutput.java:294)
	at groovy.json.JsonOutput.writeMap(JsonOutput.java:424)
	at groovy.json.JsonOutput.writeObject(JsonOutput.java:294)
	at groovy.json.JsonOutput.writeMap(JsonOutput.java:424)
        ...
{code}

Whether this be only the date, or an object including a Joda DateTime the outcome is the same.","JVM: 1.8.0_65 (Oracle)
Mac OS X 10.11.1 (El Capitan)",andre.steingress,bestan,emilles,jerrywiltse@gmail.com,jppellerin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8371,,,,GROOVY-10438,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 04 20:58:56 UTC 2022,,,,,,,,,,"0|i2opyn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Nov/15 04:39;jwagenleitner;Looks like this is caused by [{{DateTime#getZone}}|http://joda-time.sourceforge.net/apidocs/org/joda/time/base/AbstractInstant.html#getZone()] that returns a {{DateTimeZone}}.  This creates a cycle when it tries to serialize the [{{DateTimeZone#getDefault}}|http://joda-time.sourceforge.net/apidocs/org/joda/time/DateTimeZone.html#getDefault()] property which returns the same type.

The following will reproduce the stackoverflow:

{code}
import groovy.json.JsonOutput

class Foo {
    private static final DEFAULT = new Foo('The Foo')
    private final String name
    Foo(String name) { this.name = name }
    String getName() { return name }
    static Foo getDefault() { return DEFAULT }
}

JsonOutput.toJson( new Foo('test foo') )
{code};;;","17/Mar/16 15:47;bestan;Same exception is raised when serializing [LocalDateTime|https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html].;;;","07/May/16 19:39;andre.steingress;When having a look at Jackson, I saw they solve the issue of self referencing objects with either annotations (in Jackson 2) or a specific ""module configuration"" in case of Joda Time (= specific support for it).

So I came about this approach for {{JsonOutput}}:

We introduce new {{toJson(..., Map)}} methods that will allow to specify a map as 2nd parameter. The map is treated as configuration map (similar to the map used in the ToString AST xform) and allows to exclude properties of specified classes. 

An example can be found here:

https://github.com/andresteingress/groovy/blob/e1141a2f6d0e324b6a416b0a38df586da17c1406/subprojects/groovy-json/src/test/groovy/groovy/json/JsonOutputTest.groovy#L430

The implementation has support for specifying a list of properties or only a single property {{String}}, thus giving some flexibility in configuration style and footprint.

I like this approach as it could give more flexibility for additional configuration entries for the future. However, the disadvantage of this approach is that it does not directly solve the {{StackOverflowException}}, instead the caller needs to know which properties cause the exception to exlcude them in the configuration (which is tricky and maybe can not be demanded).

For introducing the configuration map, I am not totally sure right now which toJson methods should actually get that new parameter (besides {{toJson(Object)}}), but maybe that's already details. 

I also should note here: from my pov it does not make sense to demand the same or equal functionality from {{JsonOutput}} as dedicated JSON libraries like Jackson provide, but a little bit more flexibility in terms of configuring JsonOutput would make it maybe more applicable in certain cases.

What do you guys think about that - or any other approaches how to solve this issue?;;;","07/May/16 21:08;jwagenleitner;I think that approach would be good, while it may not directly solve the StackOverflow it's probably a feature that would helpful (similar to GROOVY-6699) to have and at least indirectly could help as a workaround for the StackOverflow.

I started on an approach using an IdentityHashMap to track which objects had already been serialized and just write some kind of reference id instead, but never quite finished.

https://github.com/jwagenleitner/groovy/commit/673873d7b1828f849c8a4212cbaceaa9bd8175d2;;;","08/May/16 07:39;andre.steingress;Thanks for the fast feedback, John.

{quote}
I started on an approach using an IdentityHashMap to track which objects had already been serialized and just write some kind of reference id instead, but never quite finished.
{quote}

I also thought about that, however, it seemed to introduce vast complexity and, to be honest, I wasn't even sure this can cover all the cases that can come up (e.g. an object is part of a list and later on the same object is part of a property - there would be the need to determine the rendering order or some way to reference the list object in JSON?), so property exclusions sounded much easier (when the disadvantages can be accepted) and provided some additional benefits.

Anyone else has some feedback or should I keep going into the proposed direction?;;;","08/May/16 20:39;andre.steingress;Squashed my latest commits on my branch (though still not done, I need to add more doc and additional argument validation to JsonOutput and I want to extend the JsonOutput testing a bit on that issue):

https://github.com/andresteingress/groovy/commit/3873a4929ed4772b9a641764300383517ce3eacb
;;;","14/May/16 06:54;andre.steingress;Latest (squashed) commit can be found here. I have to fix/tweak documentation for JsonOutput a bit, but overall the functionality should be ready:

https://github.com/andresteingress/groovy/commit/3b72fe3584dafb764ba0ffeb67d8442b8a591767;;;","14/May/16 14:04;jerrywiltse@gmail.com;Does this happen to cover both Joda and Java8 time/date objects, or just Joda?;;;","25/Oct/16 17:15;jwagenleitner;A workaround for this in 2.5 would be the use of the new {{JsonGenerator}}.  A custom converter could be registered to handle correctly outputting the JodaTime or JSR310 dates.  

{code}
import groovy.json.*

import java.time.LocalDateTime
import static java.time.format.DateTimeFormatter.ISO_LOCAL_DATE_TIME

def generator = new JsonGenerator.Options()
                    .addConverter(LocalDateTime) {
                        '""' + it.format(ISO_LOCAL_DATE_TIME) + '""'
                    }
                    .build()

// Following will produce StackOverflowError
//JsonOutput.toJson(LocalDateTime.now())

// Following will print (for example): ""2016-10-25T10:08:42.539""
println generator.toJson(LocalDateTime.now())
println new JsonBuilder(LocalDateTime.now(), generator)
{code};;;","25/Oct/16 19:37;jerrywiltse@gmail.com;In case you are not aware, there's also a ticket for Java8 time, same bug.

Sent from my iPhone

;;;","25/Oct/16 20:41;jwagenleitner;Thanks.  I tried searching but couldn't find any tickets for java.time and JSON.  If I come across it I'll be sure to update it with a comment.;;;","25/Oct/16 21:22;jerrywiltse@gmail.com;Nvm, I commented in this ticket in May, but did not open another ticket. ;;;","04/Jan/22 20:58;emilles;https://github.com/apache/groovy/pull/1670/commits/924efcd480532480556413d8c12103c2ac890a15;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
calling super in Groovy (version 2.4.5) miss the parent class?,GROOVY-7679,12914079,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,blackdrag,blackdrag,18/Nov/15 10:54,01/Feb/17 23:18,14/Jul/23 06:01,08/Jan/17 20:49,2.4.5,,,,,,,,,,,,,,,,,2.4.8,,,,groovy-runtime,,,,2,,,,,,,"Taken from http://stackoverflow.com/questions/33764666/why-does-calling-super-in-groovy-version-2-4-5-miss-the-parent-class

{code:Java}
class GrandParent { 
    String init() { 
        return ""GrandParent init, "" 
    } 
}

class Parent extends GrandParent { 
    String init() { 
        return super.init() + ""Parent init, "" 
    } 
}

class ChildInitAndVisit extends Parent { 
    String init() { 
        return super.init() + ""Child init"" 
    }

    String visit() { 
        return super.init() + ""Child visit"" 
    } 
}

class ChildVisitOnly extends Parent { 
    String visit() { 
        return super.init() + ""Child visit"" 
    } 
}

iv = new ChildInitAndVisit()
println ""ChildInitAndVisit - calling init() -> ${iv.init()}""
println ""ChildInitAndVisit - calling visit() -> ${iv.visit()}""

v = new ChildVisitOnly()
println ""ChildVisitOnly - calling visit() -> ${v.visit()}""
{code}

I would expect to see:
{{ChildVisitOnly - calling visit() -> GrandParent init, Parent init, Child visit}}

as the output of the last println. Instead I see:
{{ChildVisitOnly - calling visit() -> GrandParent init, Child visit}}

The bug has been verified by me.",,blackdrag,jwagenleitner,nlancaster,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jan 08 20:49:02 UTC 2017,,,,,,,,,,"0|i2oknb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Jan/17 20:49;jwagenleitner;Verified this was fixed by GROOVY-7655 in commit [e150025556|https://github.com/apache/groovy/commit/e150025556f1b30aa7ee2bd074d1e943d9bc4a99].  The tests for that commit look like they sufficiently cover this issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler customization builder not resolve secureAst properties ,GROOVY-7675,12913455,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pascalschumacher,chiquitinxx,chiquitinxx,16/Nov/15 21:13,22/Feb/16 20:48,14/Jul/23 06:01,17/Nov/15 17:45,,,,,,,,,,,,,,,,,,2.4.6,,,,Compiler,,,,0,compilerconfiguration,,,,,,"When using compilerCustomizationBuilder withConfig method, if you set secureAst properties as:

{code}
CompilerCustomizationBuilder.withConfig(config) {
      secureAst {
           importsWhitelist = []
      }
}
{code}
Properties as importsWhitelist are totally ignored.",Any environment,chiquitinxx,githubbot,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 17 17:45:19 UTC 2015,,,,,,,,,,"0|i2ogtb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Nov/15 17:43;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/190
;;;","17/Nov/15 17:45;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Remove synchronized methods of groovy.sql.Sql and document it as not thread-safe,GROOVY-7673,12913101,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,acefael,acefael,14/Nov/15 19:53,02/May/17 02:03,14/Jul/23 06:01,04/Jan/16 18:05,2.4.5,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,SQL processing,,,,0,breaking,,,,,,"I am using groovy.sql.Sql with a commons dbcp2 BasicDataSource and am encountering a stacktrace as in \[2\] below.  I do create many identical closures with different data, and I pass them all at once to ExecutorService.invokeAll.  The closures are all using the same Sql instance.

I believe this is a race condition because it happens only when the database is over a network, and not when the database is local.

To work around I can set Sql.cacheNamedQueries = false.  Problem is reliably gone in this case.  So I guess the culprit is in \[1\], with my sql already being cached in namedParamSqlCache, but not yet in namedParamIndexPropCache?

\[1\] the line in the source code
https://github.com/apache/incubator-groovy/blob/GROOVY_2_4_X/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java#L4407

\[2\] the stacktrace
{noformat}
> java.lang.NullPointerException
>       at java.util.ArrayList.<init>(ArrayList.java:168) ~[?:1.8.0]
>       at groovy.sql.Sql.buildSqlWithIndexedProps(Sql.java:4422) ~[groovy-all-2.4.5.jar:2.4.5]
>       at groovy.sql.Sql.checkForNamedParams(Sql.java:4369) ~[groovy-all-2.4.5.jar:2.4.5]
>       at groovy.sql.Sql.getPreparedStatement(Sql.java:4360) ~[groovy-all-2.4.5.jar:2.4.5]
>       at groovy.sql.Sql.getPreparedStatement(Sql.java:4439) ~[groovy-all-2.4.5.jar:2.4.5]
>       at groovy.sql.Sql.execute(Sql.java:2366) ~[groovy-all-2.4.5.jar:2.4.5]
>       at groovy.sql.Sql.execute(Sql.java:2438) ~[groovy-all-2.4.5.jar:2.4.5]
>       at groovy.sql.Sql$execute$1.call(Unknown Source) ~[?:?]
>       at es.acefael.BaseMigration.execute(BaseMigration.groovy:2017) ~[es-acefael-dostuff-SNAPSHOT.jar:?]
{noformat}",,acefael,blackdrag,jwagenleitner,pascalschumacher,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 04 23:47:43 UTC 2016,,,,,,,,,,"0|i2oen3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Nov/15 20:04;acefael;to reproduce a code block like below could be used:

{code}
def sql = new groovy.sql.Sql( dataSource() )
def vals = []
200000.times { i -> vals.add( { i -> sql.execute( [ key: i ] , 'insert into tbl(col)values(:key)' ) }.curry(i) }
def pool = java.util.concurrent.Executors.newFixedThreadPool( 10 )
pool.invokeAll(vals)
pool.shutdown()
while(true){pool.awaitTermination(5,TimeUnit.SECONDS)}
{code}
;;;","20/Nov/15 22:24;jwagenleitner;Besides the [non thread-safe map access|https://github.com/apache/incubator-groovy/blob/22c749fea5c41fdb89d4739ec9a2249d97de58cc/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java#L4407-L4409] that is causing this particular NPE, another definite problem seems to be with the instance variable [updateCount|https://github.com/apache/incubator-groovy/blob/22c749fea5c41fdb89d4739ec9a2249d97de58cc/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java#L249-L250].  It's used in several methods and could cause an incorrect count to be returned if the methods are called by multiple threads ([see here|https://github.com/apache/incubator-groovy/blob/22c749fea5c41fdb89d4739ec9a2249d97de58cc/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java#L2839-L2840]).  While most might avoid {{cacheConnection}} or {{cacheStatement}} settings if they were using in a multi-threaded way, the updateCount would cause a problem.

Hard to tell if these and the issues [~blackdrag] pointed on the dev list should be addressed or if maybe the docs just need to be clear that the class is not thread-safe.;;;","21/Nov/15 12:27;acefael;marking the class non thread-safe would limit its utility quite a lot, to me.
in a threaded environment one would have to resort to creating and discarding Sql instances a lot,
which in turn casts doubt on the built in caching mechanisms.

I understand that, in a multithreaded environment, and when using Sql with a data source, any implicit state ought to be avoided, including the updateCount and prepared statements.  There's a performance penalty through that, which cannot be avoided.

When using the Sql with a j.s.Connection it can cache all it wants and be therefore non thread-safe.

Perhaps that's the distinction?  Thread safe with a DataSource, non thread-safe with a Connection?

[keyColumnNames|https://github.com/apache/incubator-groovy/blob/22c749fea5c41fdb89d4739ec9a2249d97de58cc/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java#L268] appears to me another candidate for concurrency issues.
;;;","22/Nov/15 19:14;jwagenleitner;I took a shot at addressing some of the threading issues, split into separate commits to hopefully make review easier for those that are interested.  As [~acefael] suggested, it seemed reasonable to make the assumption that Connection-backed instances would be used by a single thread and DataSource-backed instances would more than likely be used by multiple threads.

https://github.com/apache/incubator-groovy/compare/master...jwagenleitner:GROOVY-7673

All tests pass.  The [last commit to address {{cacheConnection/cacheStatements}}|https://github.com/apache/incubator-groovy/commit/ebc0e525d4e54c44bfa2a240f84bf8f8077b5b9e] is the biggest change and most likely to be problematic.  I'd still need to do some real world testing of the changes, but thought before I did that I would seek some review of the changes.  Would especially be interested in [~paulk]'s thoughts.;;;","23/Nov/15 07:35;blackdrag; What exactly would we want to share between threads? 
;;;","24/Nov/15 15:42;blackdrag;If there is not really anything we want to share between threads, why not just document the class as not being threadsafe? If you want to use parallel processing using groovy.sql.Sql , you need then to either synchronize yourself properly, or use different instances. What speaks against that?;;;","24/Nov/15 17:47;pascalschumacher;I guess the problem is that groovy.sql.Sql already has some synchronized methods, so people think it is thread-safe. Maybe we should remove the synchronized modifiers (which can be done without breaking binary compatibility [https://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.4.20]) and document the class as not thread-safe?;;;","25/Nov/15 12:34;acefael;I'd be content with that.;;;","01/Dec/15 18:53;pascalschumacher;I changed the title to reflect the discussion results.;;;","02/Dec/15 07:56;paulk;I am not sure it is good practice to have such a breaking change in a point release. Perhaps just keep it in master?;;;","04/Jan/16 07:04;paulk;I'll reopen until we revert in 2.4.x;;;","04/Jan/16 18:05;pascalschumacher;Hi Paul,

I already reverted the change in 2_4_X [https://github.com/apache/groovy/commit/55933a30e478e8793fea21e1b1f569fdefae1eef] and removed the 2.4.6 fix version weeks ago.

Cheers,
Pascal;;;","04/Jan/16 23:47;paulk;Yes, I see that now. Sorry for the noise - I thought I had pulled but apparently not for that branch until after I commented.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurperCharSource decimal parsing producing unexpected results,GROOVY-7665,12911670,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pascalschumacher,jwagenleitner,jwagenleitner,09/Nov/15 21:05,22/Feb/16 20:48,14/Jul/23 06:01,09/Nov/15 22:19,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,JSON,,,,0,,,,,,,"When using the JsonParserType.CHARACTER_SOURCE decimal numbers are first parsed to double value and that value is used to construct the BigDecimal to return.  This can produce some unexpected results.

For example:

{code}
​import groovy.json.*

def parser = new JsonSlurper().setType(JsonParserType.CHARACTER_SOURCE)
def json = parser.parseText('{""num"": 123.40}')

assert json.num instanceof BigDecimal
assert 123.40G == json.num​
{code}

Fails with:

{code}
Assertion failed: 

assert 123.40G == json.num
               |  |    |
               |  |    123.400000000000005684341886080801486968994140625
               |  [num:123.400000000000005684341886080801486968994140625]
               false

	at Script1.run(Script1.groovy:8)
{code}",,githubbot,jwagenleitner,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 09 22:19:40 UTC 2015,,,,,,,,,,"0|i2o5un:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Nov/15 21:22;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/incubator-groovy/pull/183

    GROOVY-7665 - JsonSlurperCharSource decimal parsing producing unexpected results

    Commit 842bcd4e23fefdf5b5e17d8d91af50e1ce565096 introduced the `BigDecimal` return types and reused some of the original parsing methods.  However, in this case I think it makes more sense to just let `BigDecimal` parse the text since converting first to a double can cause some odd results.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/incubator-groovy GROOVY-7665

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/183.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #183
    
----
commit 8d17cc10559c69eb93bb7aa39a9f101bcd3296e5
Author: John Wagenleitner <john.wagenleitner@gmail.com>
Date:   2015-11-09T21:13:20Z

    GROOVY-7665 - JsonSlurperCharSource decimal parsing producing unexpected results

----
;;;","09/Nov/15 22:18;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/183
;;;","09/Nov/15 22:19;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Deserializing Groovy objects results in arbitrary remote code execution,GROOVY-7664,12911624,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,drosenbauer,drosenbauer,09/Nov/15 18:52,09/Nov/15 19:02,14/Jul/23 06:01,09/Nov/15 19:02,2.4.5,,,,,,,,,,,,,,,,,2.4.4,,,,groovy-runtime,,,,0,security,serialization,vulnerability,,,,"A specific object structure of Groovy objects can be used to run arbitrary commands remotely via unchecked deserialization. See issue COLLECTIONS-580 for a related problem in another library.

See the following links for details:

http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/

The payload-building code:

https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Groovy1.java",,drosenbauer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 09 19:02:11 UTC 2015,,,,,,,,,,"0|i2o5kf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Nov/15 19:02;drosenbauer;Disregard this, this was fixed in 2.4.4;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Spread safe method calls on list literals result in the list expression being evaluated twice (SC),GROOVY-7656,12909701,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,shils,shils,shils,02/Nov/15 15:48,22/Feb/16 20:48,14/Jul/23 06:01,15/Nov/15 08:18,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Static compilation,,,,0,,,,,,,"When a list literal is the receiver for a statically compiled spread safe method call expression, the instructions to create the list are included twice. Example:

{code}
@groovy.transform.CompileStatic
void test() {
    ['a']*.size()
}
{code}

The bytecode for the method above is:
{code}
 L0
    LINENUMBER 3 L0
    NEW java/util/ArrayList
    DUP
    INVOKESPECIAL java/util/ArrayList.<init> ()V
    ASTORE 1
   L1
    ALOAD 1
    POP
    ICONST_1
    ANEWARRAY java/lang/Object
    DUP
    ICONST_0
    LDC ""a""
    AASTORE
    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.createList ([Ljava/lang/Object;)Ljava/util/List;
    IFNULL L2
    ACONST_NULL
    ASTORE 2
   L3
    ICONST_1
    ANEWARRAY java/lang/Object
    DUP
    ICONST_0
    LDC ""a""
    AASTORE
    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.createList ([Ljava/lang/Object;)Ljava/util/List;
    INVOKEINTERFACE java/util/List.iterator ()Ljava/util/Iterator;
    ASTORE 3
   L4
    ALOAD 3
    INVOKEINTERFACE java/util/Iterator.hasNext ()Z
    IFEQ L2
    ALOAD 3
    INVOKEINTERFACE java/util/Iterator.next ()Ljava/lang/Object;
    ASTORE 2
    ALOAD 1
    ALOAD 2
    DUP
    ASTORE 4
    IFNULL L5
    ALOAD 4
    INVOKESTATIC org/codehaus/groovy/runtime/typehandling/ShortTypeHandling.castToString (Ljava/lang/Object;)Ljava/lang/String;
    CHECKCAST java/lang/String
    INVOKESTATIC org/codehaus/groovy/runtime/StringGroovyMethods.size (Ljava/lang/String;)I
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    GOTO L6
   L5
    ACONST_NULL
   L6
    INVOKEVIRTUAL java/util/ArrayList.add (Ljava/lang/Object;)Z
    POP
    GOTO L4
   L2
    ALOAD 1
    POP
{code}

If the list expression contains method calls that have side effects, this can cause serious problems. The example below is trivial, but shows the general case:

{code}
@groovy.transform.CompileStatic
void test() {
    def list = ['abc']
    def lengths = [list.removeAt(0)]*.length() // throws IndexOutOfBoundsException
}
{code}",,blackdrag,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 15 08:18:07 UTC 2015,,,,,,,,,,"0|i2ntsv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Nov/15 17:56;shils;This appears to happen because the list expression is visited twice by the ACG - once as a receiver of the spread safe method call, and once as a receiver of the iterator of the resulting for loop.

A potential fix: https://github.com/apache/incubator-groovy/compare/master...shils:GROOVY-7656;;;","02/Nov/15 20:47;blackdrag;your solution idea has two potential problems: 
(1) you declare a variable, which might be already declared. There is no check for this at this point, but imagine what happens should this be used inside the expression you are spreading
(2) your temporary variable will show up as declared variable during debugging, potentially confusing people

Looking at the code you basically do what Cedric did, only that Cedric did that part wrong already. Maybe he had a good reason for using this, don't know. Normally I use defineTemporaryVariable from the compile stack for this (controller.getCompileStack()). But since you need it as node, and not just as a slot number later on I suggest you use then my ExpressionAsVariableSlot or Cedrics TemporaryVariableExpression (which he added after he wrote this part of the code, which is why it is not used there). Beware, you will need to ""remove"" the temporary variable after use. Either by using the compile stack, or if you use TemporaryVariableExpression, the remove method on the expression.;;;","03/Nov/15 01:05;shils;Thanks for taking a look. I was aware of (1), but didn't know the right way to handle it so I indeed did follow Cedric's approach with ""spreadresult"". I'll address those issues and create a pr when I think it's ok (unless someone's already taken care of it).;;;","04/Nov/15 16:40;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/179

    GROOVY-7656 Statically compiled spread safe method calls on list lite…

    …rals result in the list expression being evaluated twice

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7656

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/179.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #179
    
----
commit 3cc4785c80f462b5d9d712bc67cbea0800d6f04d
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2015-11-02T18:54:25Z

    GROOVY-7656 Statically compiled spread safe method calls on list literals result in the list expression being evaluated twice

----
;;;","15/Nov/15 05:29;shils;[~blackdrag] Does the updated fix look ok to you?;;;","15/Nov/15 07:35;blackdrag;yes;;;","15/Nov/15 08:15;githubbot;Github user shils closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/179
;;;","15/Nov/15 08:18;shils;Merged;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong method is chosen when using super with generics,GROOVY-7655,12909666,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,MariusV,MariusV,02/Nov/15 13:29,29/Mar/17 01:13,14/Jul/23 06:01,19/Aug/16 14:03,2.4.4,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,,,,,5,,,,,,,"Given code:
{code:title=generics_extension_test.groovy}
interface ParamInterface{}

class ParamImplementation implements ParamInterface{}

class ParamExtension extends ParamImplementation {}

class A<T extends ParamInterface> {

    def getResult(T a) {
        return ""A""
    }
}

class B<T extends ParamImplementation> extends A<T> {
    def getResult(T b) {
        return ""B""
    }
}

class C extends B<ParamExtension> {
    @Override
    def getResult(ParamExtension b) {
        return super.getResult(b)
    }
}


String result = new C().getResult(new ParamExtension())
assert result == ""B""
{code}
I get output:
{code}
Assertion failed: 

assert result == ""B""
       |      |
       A      false

	at generics_extension_test.run(generics_extension_test.groovy:31)
{code}

When calling super method, instead of looking for method in a class one hierarchy bellow, groovy goes through complex calculations for finding a better method. I debug'ed up to a point in 
groovy.lang.MetaClassImpl#chooseMostSpecificParams
where it turned out that distance for interface was 2 and distance for class that directly extends the method was much bigger, therefore the method from class A is chosen instead of method from class B. However, looking objectively, it would seem that B.getResult is a much better fit:
C extends B and B extends A
parameter hierarchy is shorter (ParamExtension -> ParamImplementation -> ParamInterface)
",,blackdrag,doktorj,MariusV,nlancaster,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"02/Nov/15 13:40;MariusV;generics_extension_test.groovy;https://issues.apache.org/jira/secure/attachment/12770090/generics_extension_test.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 19 14:03:22 UTC 2016,,,,,,,,,,"0|i2ntl3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Aug/16 14:45;doktorj;This appears to be much more general than this, as I can replicate the issue starting with 2.4.0, without the use of generics. In my case, I used the following:
{code:Java}
class A {
    boolean aCalled = false

    protected Map myMethod( def item ) {
        println ""A myMethod""
        aCalled = true
        return [:]
    }
}

class B extends A {
    boolean bCalled = false

    protected Map myMethod( def item ) {
        println ""B myMethod""
        super.myMethod( item )
        bCalled = true
        return [:]
    }
}

class C extends B {
    boolean cCalled = false

    protected Map cMethod( def item ) {
        println ""C cMethod""
        super.myMethod( item )
        //myMethod( item )
        cCalled = true
        return [:]
    }
}
{code}
along with a simple JUnit test:
{code:Java}
import org.junit.Test

class CTest {
    @Test
    public void test() {
        def c = new C()
        def ret = c.cMethod( ""stuff"" )
        
        assert c.aCalled
        assert c.bCalled // Duh ... 2.4.x fails here.
        assert c.cCalled
    }
}
{code}
It's seen that all the 2.4 versions I ran (2.4.0, 2.4.3, 2.4.7) exhibit the same behavior --- B.myMethod is not invoked.

We encountered this while looking at doing a transition from the 2.3.x versions of groovy to 2.4.x, and one of our apps starting failing in an odd manner. It turns out that we did have a class coded invoking super on a method, while the class didn't override the method --- resulting in the invocation of the wrong method.

In our minds at the company I'm working for, this is a very serious bug that may prevent our moving to the 2.4.x groovy runtimes.;;;","16/Aug/16 16:14;blackdrag;to be able to realize a super call in Groovy we have to go to some lengths in the form of helper methods. Only the helper method is able to make the call, because to realize a proper super invocation you will need an invokespecial, and that is not available by reflection or even by generating a helper class. A invokespecial instruction must come from the same class to realize a call to super. Till 2.4 we did blindly create helper methods for all possible cases. We then tried to slim down the class files a bit but reducing them to their minimum. But it seems this case here has been forgotten. There are solutions to this... overwrite the method in C or use @CompileStatic for example. Those are no options for you?;;;","16/Aug/16 17:29;doktorj;Not really; our concern is about precompiled/3rd party libraries more than our own code. While we could keep in mind this situation in our own code, there are limits to that, and someone, someday, is going to miss a case.

This is one of those cases where the current invocation is different than the baseline Java. I read the 2.4 release notes pretty carefully the other night, and was looking at decompiled code and saw the reduction in generated helper methods. If this particular case is one that was overlooked, perhaps a solution in the next release would be forthcoming? It surprises me that a simple case like this would have been overlooked in the unit tests (then again, it surprises me, too, that it seems so few have noticed a case like this).;;;","17/Aug/16 11:24;blackdrag;If the library is precompiled with pre 2.4, then the code there already contains the helper method. And if it is there, it will be used. So unless you recompile, there is no problem.  Of course there is then still a problem once they recompile. But that is the case already if you use 2.3 and they use 2.4 to compile.

I do agree, that this has to be fixed for the next release. The question is the ""how"" beyond a simple ""restore the old behaviour"". I would like to keep the amount of methods at least lowered. Most probably I will make the compiler recognize the super-call and note that this will require a mop helper method later on. Then we would still get a big reduction in generated helper methods compared to 2.4 and it would solve your problem here.;;;","17/Aug/16 13:03;doktorj;Agreed. In our case, looking at the move to using Mule 3.7.3, 2.4 is required (which, overall, is a good thing). Thank you for being so prompt with this; I certainly understand the ""how"" is the difficult part. You've made big strides with groovy and I'd love to keep using it.;;;","19/Aug/16 14:03;blackdrag;after thinking about how to solve the issue for a bit it was actually quite easy to find a solution. The compiler will now ensure, that methods used with super will find their mop helper method. This happens regardless of the signature, so there are still useless methods generated, but still many less than in 2.3;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Iterable as List and Iterable.asList() have different semantics,GROOVY-7654,12909499,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,shils,shils,01/Nov/15 17:10,06/Mar/18 23:14,14/Jul/23 06:01,13/Jun/17 06:18,2.4.5,,,,,,,,,,,,,,,,,2.4.12,,,,groovy-jdk,,,,0,,,,,,,"For an Iterable `foo` which is not also a collection, `foo.asList()` and `foo as List` are not equivalent. The latter goes through the asType(Object, Class) path and ultimately returns a proxy. This is unexpected, and can result in some inconsistencies. A simple example:

{code}
class IterableWrapper implements Iterable {
    Iterable delegate

    Iterator iterator() {
        delegate.iterator()
    }
}

def itw = new IterableWrapper(delegate: [1,2,3])
def itwAsList = itw.asList()
def itwAsTypeList = itw as List
assert itwAsList == itwAsTypeList
assert itwAsList[0] == itwAsTypeList[0]
{code}

The first assertion passes, but the second fails with:
{code}
groovy.lang.MissingMethodException: No signature of method: IterableWrapper.get() is applicable for argument types: (java.lang.Integer) values: [0]
{code}",,githubbot,mauromol,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 19 02:33:40 UTC 2017,,,,,,,,,,"0|i2nsjz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/May/17 19:38;githubbot;GitHub user armsargis opened a pull request:

    https://github.com/apache/groovy/pull/546

    GROOVY-7654: Iterable as List and Iterable.asList() have different semantics

    Introduce DefaultGroovyMethods.asType(Iterable, Class) to handle correctly 'asType' to iterables

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/armsargis/groovy GROOVY-7654

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/546.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #546
    
----
commit faabd7bd65ef9437add8ce451f84a09066e0b448
Author: Sargis Harutyunyan <sargis.harutyunyan@webbfontaine.com>
Date:   2017-05-21T19:35:16Z

    GROOVY-7654: Introduce DefaultGroovyMethods.asType(Iterable, Class) to
    handle correctly 'asType' to iterables

----
;;;","21/May/17 19:44;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/546#discussion_r117640763
  
    --- Diff: src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy ---
    @@ -236,7 +236,28 @@ public class DefaultGroovyMethodsTest extends GroovyTestCase {
             assertEquals(3, list.get(2));
         }
     
    +    // GROOVY-7654
    +    public void testIterableAsList() {
    +        def list = [1, 2, 3]
    +        def iterable = new IterableWrapper(delegate: list)
    +
    +        def iterableAsList = iterable.asList()
    +        def iterableAsType = iterable as List
    +        
    +        assertEquals(iterableAsList, iterableAsType)
    +        assertEquals(1, iterableAsList[0])
    +        assertEquals(1, iterableAsType[0])
    +    }
    +
         private static class MyList extends ArrayList {
             public MyList() {}
         }
    +
    +    private static class IterableWrapper implements Iterable {
    +        Iterable delegate
    +
    +        Iterator iterator() {
    +            delegate.iterator()
    +        }
    +    }
     }
    --- End diff --
    
    I am missing a test 
    
    def iterableAsIterable = iterable as Iterable
    assert iterable.AsIterable.is(iterable)
    def iterableAsIterableWrapper = iterable as IterableWrapper
    assert iterable.AsIterable.is(iterable)
;;;","21/May/17 20:35;githubbot;Github user armsargis commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/546#discussion_r117642093
  
    --- Diff: src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy ---
    @@ -236,7 +236,28 @@ public class DefaultGroovyMethodsTest extends GroovyTestCase {
             assertEquals(3, list.get(2));
         }
     
    +    // GROOVY-7654
    +    public void testIterableAsList() {
    +        def list = [1, 2, 3]
    +        def iterable = new IterableWrapper(delegate: list)
    +
    +        def iterableAsList = iterable.asList()
    +        def iterableAsType = iterable as List
    +        
    +        assertEquals(iterableAsList, iterableAsType)
    +        assertEquals(1, iterableAsList[0])
    +        assertEquals(1, iterableAsType[0])
    +    }
    +
         private static class MyList extends ArrayList {
             public MyList() {}
         }
    +
    +    private static class IterableWrapper implements Iterable {
    +        Iterable delegate
    +
    +        Iterator iterator() {
    +            delegate.iterator()
    +        }
    +    }
     }
    --- End diff --
    
    Actually, test I got from jira issue and meaning I think is to create concrete implementation of Iterable which is not extending from collection. And for concrete implementation we need return some iterator.
    
    Also I thinking to change code like:
    
    ```
    public static <T> T asType(Iterable iterable, Class<T> clazz) {
            if (Collections.class.isAssignableFrom(clazz)) {
                return asType((Collection) toList(iterable), clazz);
            }
    
            return asType((Object) toList(iterable), clazz);
        }
    ```

;;;","21/May/17 20:41;githubbot;Github user armsargis commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/546#discussion_r117642241
  
    --- Diff: src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy ---
    @@ -236,7 +236,28 @@ public class DefaultGroovyMethodsTest extends GroovyTestCase {
             assertEquals(3, list.get(2));
         }
     
    +    // GROOVY-7654
    +    public void testIterableAsList() {
    +        def list = [1, 2, 3]
    +        def iterable = new IterableWrapper(delegate: list)
    +
    +        def iterableAsList = iterable.asList()
    +        def iterableAsType = iterable as List
    +        
    +        assertEquals(iterableAsList, iterableAsType)
    +        assertEquals(1, iterableAsList[0])
    +        assertEquals(1, iterableAsType[0])
    +    }
    +
         private static class MyList extends ArrayList {
             public MyList() {}
         }
    +
    +    private static class IterableWrapper implements Iterable {
    +        Iterable delegate
    +
    +        Iterator iterator() {
    +            delegate.iterator()
    +        }
    +    }
     }
    --- End diff --
    
    I will add missing test cases
;;;","21/May/17 22:58;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/546#discussion_r117645390
  
    --- Diff: src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy ---
    @@ -236,7 +236,28 @@ public class DefaultGroovyMethodsTest extends GroovyTestCase {
             assertEquals(3, list.get(2));
         }
     
    +    // GROOVY-7654
    +    public void testIterableAsList() {
    +        def list = [1, 2, 3]
    +        def iterable = new IterableWrapper(delegate: list)
    +
    +        def iterableAsList = iterable.asList()
    +        def iterableAsType = iterable as List
    +        
    +        assertEquals(iterableAsList, iterableAsType)
    +        assertEquals(1, iterableAsList[0])
    +        assertEquals(1, iterableAsType[0])
    +    }
    +
         private static class MyList extends ArrayList {
             public MyList() {}
         }
    +
    +    private static class IterableWrapper implements Iterable {
    +        Iterable delegate
    +
    +        Iterator iterator() {
    +            delegate.iterator()
    +        }
    +    }
     }
    --- End diff --
    
    If the iterable is an instance of Collection, then why isn´t the Collection taking method called directly?
;;;","21/May/17 23:02;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/546#discussion_r117645462
  
    --- Diff: src/test/org/codehaus/groovy/runtime/DefaultGroovyMethodsTest.groovy ---
    @@ -236,7 +236,28 @@ public class DefaultGroovyMethodsTest extends GroovyTestCase {
             assertEquals(3, list.get(2));
         }
     
    +    // GROOVY-7654
    +    public void testIterableAsList() {
    +        def list = [1, 2, 3]
    +        def iterable = new IterableWrapper(delegate: list)
    +
    +        def iterableAsList = iterable.asList()
    +        def iterableAsType = iterable as List
    +        
    +        assertEquals(iterableAsList, iterableAsType)
    +        assertEquals(1, iterableAsList[0])
    +        assertEquals(1, iterableAsType[0])
    +    }
    +
         private static class MyList extends ArrayList {
             public MyList() {}
         }
    +
    +    private static class IterableWrapper implements Iterable {
    +        Iterable delegate
    +
    +        Iterator iterator() {
    +            delegate.iterator()
    +        }
    +    }
     }
    --- End diff --
    
    interesting choice to use Collection.class.isAssignableFrom(clazz). But sure, why not... +1
;;;","13/Jun/17 06:18;paulk;Given what was produced was at least partially unusable, I think it is safe to assume this is a straight out bug and not some semi-useful behavior that folks might be relying upon - so I've merged back to 2_4_X.;;;","19/Jun/17 02:33;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/546
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Float/Double trunc methods perform rounding for negative values,GROOVY-7652,12909448,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pascalschumacher,jwagenleitner,jwagenleitner,31/Oct/15 21:44,22/Feb/16 20:48,14/Jul/23 06:01,01/Nov/15 09:12,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,groovy-jdk,,,,0,,,,,,,"The {{trunc}} methods on Float/Double use the {{Math.floor}} method for all values, however for negative values this causing rounding.  I think for negative values {{Math.ceil}} needs to be used.

Here are some asserts to show the rounding:

{code}
Float f = -123.739f
Double d = -123.739d

assert -123f == f.trunc() // fails: -124
assert -123d == d.trunc() // fails: -124

assert​ -123.73f == f.trunc(2)​ // fails: -123.74
assert -123.73d == d.trunc(2) // fails: -123.73​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
{code}",,githubbot,jwagenleitner,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 01 09:12:16 UTC 2015,,,,,,,,,,"0|i2ns8n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Oct/15 22:00;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/incubator-groovy/pull/171

    GROOVY-7652 - Float/Double trunc methods perform rounding for negative values

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/incubator-groovy GROOVY-7652

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/171.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #171
    
----
commit b93926c52245f4ba45eb7529784d71e06fd83a16
Author: John Wagenleitner <john.wagenleitner@gmail.com>
Date:   2015-10-31T20:45:05Z

    GROOVY-7652 - Float/Double trunc methods perform rounding for negative values

----
;;;","01/Nov/15 09:09;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/171
;;;","01/Nov/15 09:12;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"CLONE - collectEntries throws cryptic error when used with split(delimiter, limit)",GROOVY-7650,12908752,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,rahulsom,paulk,29/Oct/15 00:05,22/Feb/16 20:48,14/Jul/23 06:01,29/Oct/15 02:04,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,,,,,0,,,,,,,"Here is my code

{code}
def cityList = '''\
1 San Francisco
2 Cupertino
'''
def cityMap = cityList.split('\n').
    collectEntries{ it.split(' ', 2).toList() }
    
def cityMap2 = cityList.split('\n').
    collectEntries{ it.split(' ', 2) }
{code}

I initially only tried the second approach, and got an exception that was rather hard to debug:

{code}
Exception thrown

java.lang.ClassFormatError: Illegal class name ""String;4_groovyProxy"" in class file String;4_groovyProxy
	at ConsoleScript6.run(ConsoleScript6:8)
{code}

Gold would be if Groovy deals with this out of the box.
Silver would be if the error message told me what was wrong.

The link to the discussion is here - http://groovy.329449.n5.nabble.com/Illegal-class-name-String-1-groovyProxy-tp5728011.html

{panel:title=Note|bgColor=#FFFFCE}
Issue split - this part is to handle the incorrect naming for arrays with ProxyGeneratorAdapter
{panel}","Java 7, 8 - all versions
MacOS",githubbot,hubbitus,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7616,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Thu Oct 29 02:03:00 UTC 2015,,,,,,,,,,"0|i2nnxz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Oct/15 00:48;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/166

    GROOVY-7650: CLONE - collectEntries throws cryptic error when used wi…

    …th split(delimiter, limit) (closes #166)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7650

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/166.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #166
    
----
commit 7be5f9eb1b9cbe07188a96616bc5a3988765dab3
Author: paulk <paulk@asert.com.au>
Date:   2015-10-29T00:47:11Z

    GROOVY-7650: CLONE - collectEntries throws cryptic error when used with split(delimiter, limit) (closes #166)

----
;;;","29/Oct/15 02:03;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/166
;;;","29/Oct/15 02:03;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/166
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Grape.resolve() always fails after first unresolved dependency,GROOVY-7649,12908546,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,pluradj,pluradj,28/Oct/15 13:13,22/Feb/16 20:48,14/Jul/23 06:01,28/Oct/15 18:55,2.4.1,,,,,,,,,,,,,,,,,2.4.6,,,,Grape,,,,0,,,,,,,"When there is a failed call to {{Grape.resolve()}}, {{GrapeIvy.resolve()}} hangs onto a reference to the {{IvyGrabRecord}} for the failed dependency. When subsequent {{resolve()}} calls are made, those failed records are still there, so it will continue to fail from that point on.

https://github.com/apache/incubator-groovy/blob/GROOVY_2_4_1/src/main/groovy/grape/GrapeIvy.groovy#L563

Note that {{GrapeIvy.grab()}} cleans up correctly on a failed grab.

https://github.com/apache/incubator-groovy/blob/GROOVY_2_4_1/src/main/groovy/grape/GrapeIvy.groovy#L265-L268

This defect is affecting the Apache TinkerPop Gremlin Console. Find more details here. https://issues.apache.org/jira/browse/TINKERPOP3-906",,githubbot,pascalschumacher,paulk,pluradj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Oct/15 13:15;pluradj;GrapeResolveFailure.groovy;https://issues.apache.org/jira/secure/attachment/12769278/GrapeResolveFailure.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 29 03:27:03 UTC 2015,,,,,,,,,,"0|i2nmo7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Oct/15 13:15;pluradj;Attaching a script example to show the error scenario.;;;","28/Oct/15 13:20;githubbot;GitHub user pluradj opened a pull request:

    https://github.com/apache/incubator-groovy/pull/164

    GROOVY-7649: clean up current dependencies state when resolve fails

    https://issues.apache.org/jira/browse/GROOVY-7649

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/pluradj/incubator-groovy GROOVY-7649

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/164.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #164
    
----
commit c0b236f7e9d96b5b21e0be839dffeeb0d0d67fca
Author: Jason Plurad <pluradj@apache.org>
Date:   2015-10-28T13:17:22Z

    clean up current dependencies state when resolve fails

----
;;;","28/Oct/15 13:22;pluradj;https://github.com/apache/incubator-groovy/pull/164;;;","28/Oct/15 18:53;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/164
;;;","28/Oct/15 18:55;pascalschumacher;Pull request merged! Thanks!;;;","28/Oct/15 21:16;pluradj;when is 2.4.6 expected to release?;;;","29/Oct/15 03:27;paulk;We have no fixed date set as yet. We possibly have sufficient fixes to warrant another release and we aren't waiting on any particular crucial fix before releasing again but one of us has to find the time to be release manager. BTW: Nice work on the PR.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Problem with @CompileStatic, generic types, and varags",GROOVY-7648,12908257,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,roxton,roxton,27/Oct/15 15:25,08/Mar/22 12:16,14/Jul/23 06:01,25/Oct/21 16:32,2.4.4,,,,,,,,,,,,,,,,,,,,,groovy-jdk,,,,0,,,,,,,"Similar to GROOVY-7182, groovyc fails to handle generic types if a class uses @CompileStatic and the generically typed method has a varargs parameter. Removal of @CompileStatic or the varargs parameter eliminates the compile error.

(Clarification: methodOn need not be defined in the @CompileStatic class. In the original case, the method was ControllerLinkBuilder#methodOn from Spring's HATEOAS library.)

{code:title=VarArgsGenericsCase.groovy|borderStyle=solid}
import groovy.transform.CompileStatic

@CompileStatic
class VarArgsGenericsCase {

    def markus(String name) {
        methodOn(VarArgsGenericsCase).markus(name)
    }

    static <T> T methodOn(Class<T> clazz, Object... parameters) {
        return clazz.newInstance()
    }
}
{code}

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
VarArgsGenericsCase.groovy: 7: [Static type checking] - Cannot find matching method java.lang.Object#markus(java.lang.String). Please check if the declared type is correct and if the method exists.
 @ line 7, column 9.
           methodOn(VarArgsGenericsCase).markus(name)
           ^

1 error
{noformat}",,roxton,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7182,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-10-27 15:25:47.0,,,,,,,,,,"0|i2nkxz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect line information for debug,GROOVY-7647,12907929,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,gorrus,gorrus,26/Oct/15 14:46,29/Jun/20 11:50,14/Jul/23 06:01,25/Nov/18 20:18,2.4.5,,,,,,,,,,,,,,,,,2.4.16,2.5.5,3.0.0-alpha-4,,class generator,Compiler,,,3,,,,,,,"Try to debug the code:
{code}
boolean boolVar = false; //line 15
if (boolVar) { // set breakpoint here and step over //line 16
    print ""ok""; //line 17
} // end of file //line 18
{code}
It steps over to the line with print even though it is not executed.

Seems that compiler does not generate line info for the last block (line 18):
{code}
 public java.lang.Object run();
    descriptor: ()Ljava/lang/Object;
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=3, args_size=1
         0: invokestatic  #18                 // Method $getCallSiteArray:()[Lorg/codehaus/groovy/runtime/callsite/CallSite;
         3: astore_1
         4: iconst_0
         5: istore_2
         6: iload_2
         7: pop
         8: iload_2
         9: ifeq          28
        12: aload_1
        13: ldc           #41                 // int 1
        15: aaload
        16: aload_0
        17: ldc           #43                 // String ok
        19: invokeinterface #47,  3           // InterfaceMethod org/codehaus/groovy/runtime/callsite/CallSite.callCurrent:(Lgroovy/lang/GroovyObject;Ljava/lang/Object;)Ljava/lang/Object;
        24: areturn
        25: goto          30
        28: aconst_null
        29: areturn
        30: aconst_null
        31: areturn
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      30     0  this   Lsdfklajsdlkjas/test;
            6      24     2 boolVar   Z
      LineNumberTable:
        line 15: 4
        line 16: 8
        line 17: 12
{code}",,daniel_sun,dmurat,emilles,gillius,githubbot,gorrus,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7918,,,,GROOVY-9126,GROOVY-9610,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 22 15:39:06 UTC 2020,,,,,,,,,,"0|i2nix3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Aug/16 02:34;paulk;May or may not be related to GROOVY-4063.;;;","30/Aug/16 17:20;gillius;It doesn't seem to be related to GROOVY-4063, and in that example Jochen says he added line number before the return (maybe that wasn't kept, as that is the issue here). GROOVY-4063 sounds more like a debugger limitation.;;;","04/Nov/18 23:19;emilles;I have seen the same issue for methods that rely on default return null and sometimes for try/catch constructions as well.
{code:groovy}
def m(boolean condition) {
  if (condition) {
    ""something""
  }
}
{code}

Debugger moves from if line to ""something"" line for true or false.  This is because the last line number information for the method is for the ""something"" line.  There is nothing for either of the closing braces, so the debugger associates all the bytecodes to the something line.;;;","05/Nov/18 01:08;emilles;If I make the following additions to StatementWriter -- a call to {{mv.visitLineNumber}} immediately following each {{mv.visitLabel}} -- the end brace is the next step line after the condition line in case of false.  Can anyone confirm this is the right approach?

{code:java}
    public void writeIfElse(IfStatement ifElse) {
        controller.getAcg().onLineNumber(ifElse,""visitIfElse"");
        writeStatementLabel(ifElse);

        MethodVisitor mv = controller.getMethodVisitor();

        ifElse.getBooleanExpression().visit(controller.getAcg());
        Label l0 = controller.getOperandStack().jump(IFEQ);

        // if-else is here handled as a special version
        // of a boolean expression
        controller.getCompileStack().pushBooleanExpression();
        ifElse.getIfBlock().visit(controller.getAcg());
        controller.getCompileStack().pop();

        if (ifElse.getElseBlock()==EmptyStatement.INSTANCE) {
            mv.visitLabel(l0);
            // GRECLIPSE add
            mv.visitLineNumber(ifElse.getLastLineNumber(), l0);
            // GRECLIPSE end
        } else {
            Label l1 = new Label();
            mv.visitJumpInsn(GOTO, l1);
            mv.visitLabel(l0);
            // GRECLIPSE add
            mv.visitLineNumber(ifElse.getIfBlock().getLastLineNumber(), l0);
            // GRECLIPSE end

            controller.getCompileStack().pushBooleanExpression();
            ifElse.getElseBlock().visit(controller.getAcg());
            controller.getCompileStack().pop();

            mv.visitLabel(l1);
            // GRECLIPSE add
            mv.visitLineNumber(ifElse.getLastLineNumber(), l1);
            // GRECLIPSE end
        } 
    }
{code};;;","05/Nov/18 16:02;emilles;Although if the conditional is written this way, it still steps to the ""something"" line for both cases:
{code:java}
def m(boolean condition) {
  if (condition)
    ""something""
}
{code};;;","05/Nov/18 16:49;emilles;It seems the only critical bit is to add a {{visitLineNumber}} for the path that skips over the else block.  -Only trick is to determine the last line number of the enclosing block.  Does anyone know how to do that from within {{StatementWriter}}?-

{code:java}
    public void writeIfElse(IfStatement ifElse) {
        controller.getAcg().onLineNumber(ifElse,""visitIfElse"");
        writeStatementLabel(ifElse);

        MethodVisitor mv = controller.getMethodVisitor();

        ifElse.getBooleanExpression().visit(controller.getAcg());
        Label l0 = controller.getOperandStack().jump(IFEQ);

        // if-else is here handled as a special version
        // of a boolean expression
        controller.getCompileStack().pushBooleanExpression();
        ifElse.getIfBlock().visit(controller.getAcg());
        controller.getCompileStack().pop();

        if (ifElse.getElseBlock()==EmptyStatement.INSTANCE) {
            mv.visitLabel(l0);
        } else {
            Label l1 = new Label();
            mv.visitJumpInsn(GOTO, l1);
            mv.visitLabel(l0);
            // GRECLIPSE add
            if (ifElse.getLineNumber() > 0 && ifElse.getElseBlock().getLineNumber() <= 0) {
                mv.visitLineNumber(controller.getMethodNode().getLastLineNumber(), l0);
            }
            // GRECLIPSE end

            controller.getCompileStack().pushBooleanExpression();
            ifElse.getElseBlock().visit(controller.getAcg());
            controller.getCompileStack().pop();

            mv.visitLabel(l1);
        }
    }
{code};;;","06/Nov/18 16:30;emilles;This fix does not address a constructor (see example below) since it does not add a return statement.
{code:groovy}
class Pogo {
  String foo, bar
  Pogo(Map args = null) {
    if (args != null) {
      foo = map['foo']
      bar = map['bar']
    }
  }
}
{code}
When calling the no-arg constructor, debugger steps from ""if"" line to ""bar"" line.;;;","06/Nov/18 16:42;emilles;In the Java debugger, stepping always stops on closing brace of method for true or false case.  Probably same for straight line execution of a method or constructor.  So, maybe the line number should be added in the calling method: {{StatementWriter.writeBlockStatement}}?;;;","06/Nov/18 17:18;emilles;If {{StatementWriter.writeBlockStatement}} is patched instead of {{writeIfElse}}, methods and constructors will have step on line of closing brace.  This should also help GROOVY-8742.
{code:java}
    public void writeBlockStatement(BlockStatement block) {
        writeStatementLabel(block);

        int mark = controller.getOperandStack().getStackLength();
        CompileStack compileStack = controller.getCompileStack();
        compileStack.pushVariableScope(block.getVariableScope());
        for (Statement statement : block.getStatements()) {
            statement.visit(controller.getAcg());
        }
        compileStack.pop();

        // GRECLIPSE add
        if (block.getLastLineNumber() > 0) {
            MethodVisitor mv = controller.getMethodVisitor();
            Label blockEnd = new Label(); mv.visitLabel(blockEnd);
            mv.visitLineNumber(block.getLastLineNumber(), blockEnd);
        }
        // GRECLIPSE end

        controller.getOperandStack().popDownTo(mark);
    }
{code};;;","23/Nov/18 06:31;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/830

    GROOVY-7647: Incorrect line information for debug

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7647

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/830.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #830
    
----
commit ae3bb53f64396f9b95fa7f592397b11542397ee9
Author: Paul King <paulk@...>
Date:   2018-11-23T06:29:06Z

    GROOVY-7647: Incorrect line information for debug

----
;;;","24/Nov/18 04:45;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/830
;;;","25/Nov/18 20:18;paulk;Proposed PR merged. Special thanks to [~gorrus] for spotting the issue and [~emilles] for the suggestions.;;;","22/Jan/20 15:19;daniel_sun;[~paulk] [~emilles]

Are there any other solutions to fix the issue? GROOVY-9126 is suffering from the current solution...;;;","22/Jan/20 15:39;emilles;What is higher priority, debugger breakpoint/stepping accuracy or coverage reports?  I have not had a chance to retest debugging with the GROOVY-9126 changes in place.

There may be other solutions.  It is all in how ASM is used to generate bytecode and mark codes or lables with line numbers.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Classes generated by Eval() never collected from Permgen/Metaspace,GROOVY-7646,12907505,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,idooley,idooley,23/Oct/15 18:21,24/May/17 06:29,14/Jul/23 06:01,12/Apr/17 20:13,2.4.5,,,,,,,,,,,,,,,,,2.4.10,,,,groovy-runtime,,,,3,,,,,,,"It seems classes generated by Eval() are never collected, thus causing PermGen or Metaspace to fill up and the JVM to hang/crash.
Reproduce by running the following code, after setting java option {{-XX:MaxMetaspaceSize=50m}}. 

{code}
100000.times{ x -> assert 10 == Eval.x(2, 'x * 4 + 2;') }
{code}

After about 2700 calls to Eval the program will crash with OutOfMemoryError, ",Oracle jdk8u51 and jdk8u66,githubbot,guindous,howardzzhang,idooley,jexler,jkemnade,jwagenleitner,moshe@egis-software.com,neopaf,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6136,,,,GROOVY-8189,GROOVY-8199,,,GROOVY-7683,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 12 20:13:52 UTC 2017,,,,,,,,,,"0|i2ngbb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Apr/16 09:03;neopaf;Colleagues,
I would suggest to cache internally class, generated by Eval, using eval expression String as a key.

This will still not garbage-collect, and given random input to Eval also lead to OOM.

Yet real-life scenarios are usually closer to that in Description, meaning -- little different expressions.

This will be WAY better than current situation, when we just CAN NOT use Eval in long-running apps.;;;","01/May/16 20:42;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/325

    GROOVY-7646 - Classes generated by Eval() never collected from Permgen/Metaspace

    This is also fixed by PR #219 but that requires SoftReferences to be collected (because of beaninfocache).   It seems for cases where a Script class is parsed, executed for its result and the Script class is not retained we can be more aggressive about clearing it from caches so it doesn't require the heap to fill before being collected.
    
    A test is included just to demonstrate the changes do allow the classes to be GC'd but is not a test that is meant to be included if the PR is accepted.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7646

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/325.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #325
    
----
commit 7418b3d7ebd324e0d24c63746e884db632a313d9
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-05-01T19:55:44Z

    GROOVY-7646 - Classes generated by Eval() never collected from Permgen/Metaspace
    
    In cases where a Script class is generated just to obtain a result and the Class is not retained, the Class should be removed from the ClassInfo cache and beanInfoCache in order to allow it to be GC'd.  Otherwise in environments where scripts are repeated executed memory will continue to be consumed by these classes because beanInfoCache retains soft references to the classes.

commit b708bf8585482cc2bd2739e13eda74c9818d77a6
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-05-01T19:57:25Z

    GROOVY-7646 - test
    
    Just to demonstrate this allows GC of the parsed script classes, it should not be included if the PR is accepted.

----
;;;","10/Oct/16 09:18;githubbot;GitHub user jochenberger opened a pull request:

    https://github.com/apache/groovy/pull/444

    GROOVY-7646: allow classes to be removed from the ClassInfo cache

    This is the first part of what @jwagenleitner did for #325.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jochenberger/groovy classinfo-remove

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/444.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #444
    
----
commit 94a3b08bd0ac9ebc045277bdd4bfe0e71d92f26c
Author: Jochen Kemnade <jochen.kemnade@eddyson.de>
Date:   2016-10-10T09:15:55Z

    GROOVY-7646: allow classes to be removed from the ClassInfo cache

----
;;;","10/Oct/16 09:43;githubbot;GitHub user jochenberger opened a pull request:

    https://github.com/apache/groovy/pull/445

    GROOVY-7646: remove classes via InvokerHelper when closing the GroovyClassLoader or flushing its cache

    See #325, this ensures that classes are properly cleaned up after when their ClassLoader or its cache are discarded. Together with #444, this should allow classes to be GC'ed as soon as they are not used anymore.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jochenberger/groovy remove-classes-upon-classloader-close

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/445.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #445
    
----
commit a0e294afbdd1630c2235eb1b5366c6c0db783af1
Author: Jochen Berger <fooberger@gmail.com>
Date:   2016-10-10T09:40:53Z

    GROOVY-7646: remove classes via InvokerHelper when closing the GroovyClassLoader or flushing its cache

----
;;;","10/Oct/16 09:45;githubbot;Github user jochenberger commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/445#discussion_r82572329
  
    --- Diff: src/main/groovy/lang/GroovyClassLoader.java ---
    @@ -969,13 +970,24 @@ public Void run() {
          */
         public void clearCache() {
             synchronized (classCache) {
    +            for (Class cl : classCache.values()) {
    +                InvokerHelper.removeClass(cl);
    +            }
                 classCache.clear();
             }
             synchronized (sourceCache) {
                 sourceCache.clear();
             }
         }
     
    +    @Override
    +    public void close() throws IOException {
    +        super.close();
    +        for (Class cl : classCache.values()) {
    --- End diff --
    
    We could also just call `clearCache()` from here.
;;;","11/Oct/16 12:35;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/445#discussion_r82782344
  
    --- Diff: src/main/groovy/lang/GroovyClassLoader.java ---
    @@ -969,13 +970,24 @@ public Void run() {
          */
         public void clearCache() {
             synchronized (classCache) {
    +            for (Class cl : classCache.values()) {
    +                InvokerHelper.removeClass(cl);
    +            }
                 classCache.clear();
             }
             synchronized (sourceCache) {
                 sourceCache.clear();
             }
         }
     
    +    @Override
    +    public void close() throws IOException {
    +        super.close();
    +        for (Class cl : classCache.values()) {
    --- End diff --
    
    +1 for clear cache... especially since that does proper synchronization
;;;","11/Oct/16 12:43;githubbot;Github user jochenberger commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/445#discussion_r82783539
  
    --- Diff: src/main/groovy/lang/GroovyClassLoader.java ---
    @@ -969,13 +970,24 @@ public Void run() {
          */
         public void clearCache() {
             synchronized (classCache) {
    +            for (Class cl : classCache.values()) {
    +                InvokerHelper.removeClass(cl);
    +            }
                 classCache.clear();
             }
             synchronized (sourceCache) {
                 sourceCache.clear();
             }
         }
     
    +    @Override
    +    public void close() throws IOException {
    +        super.close();
    +        for (Class cl : classCache.values()) {
    --- End diff --
    
    I thought that synchronization might not be an issue since we are `close`-ing the ClassLoader anyway and I wanted to avoid the additional cost of synchronizing over and clearing `sourceCache`. But I guess it's better safe than sorry, so I made the change.
;;;","12/Oct/16 03:14;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/445
;;;","12/Oct/16 03:14;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/444
;;;","22/Jan/17 20:05;githubbot;Github user jwagenleitner closed the pull request at:

    https://github.com/apache/groovy/pull/325
;;;","12/Apr/17 20:13;idooley;I verified that the issue is no longer present in groovy 2.4.10 with JDK 1.8.0u51 by running the example in the description successfully. I watched the JVM metaspace usage over the run, and found that it never exceeded 50MB, as desired.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stub generator unescapes escaped backslashes in String annotation values,GROOVY-7645,12907466,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,svella,svella,23/Oct/15 16:09,22/Feb/16 20:48,14/Jul/23 06:01,31/Oct/15 00:20,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Stub generator / Joint compiler,,,,0,,,,,,,"This is very similar to GROOVY-4604 and GROOVY-4601.

Groovy code:
{code}
import javax.ws.rs.GET
import javax.ws.rs.Path

@Path('/')
class GroovyService {
    @GET
    @Path('{id:[^.]\\.[^.]}')
    String getIt(String id) {
        return id;
    }
}
{code}

Results in stub:
{code}
import java.lang.*;
import java.io.*;
import java.net.*;
import java.util.*;
import groovy.lang.*;
import groovy.util.*;

@javax.ws.rs.Path(value=""/"") public class GroovyService
  extends java.lang.Object  implements
    groovy.lang.GroovyObject {
;
public  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}
public  void setMetaClass(groovy.lang.MetaClass mc) { }
public  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}
public  java.lang.Object getProperty(java.lang.String property) { return null;}
public  void setProperty(java.lang.String property, java.lang.Object value) { }
@javax.ws.rs.GET() @javax.ws.rs.Path(value=""{id:[^.]\.[^.]}"") public  java.lang.String getIt(java.lang.String id) { return (java.lang.String)null;}
}
{code}

Which results in error:

{code}
GroovyService.java:[17,53] error: illegal escape character
{code}
",,githubbot,paulk,svella,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Oct 31 00:20:32 UTC 2015,,,,,,,,,,"0|i2ng2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Oct/15 09:21;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/168

    GROOVY-7645: Stub generator unescapes escaped backslashes in String a…

    …nnotation values (closes #168)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7645

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/168.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #168
    
----

----
;;;","31/Oct/15 00:14;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/168
;;;","31/Oct/15 00:14;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/168
;;;","31/Oct/15 00:20;paulk;Thanks for spotting and reporting the issue with a reproducible test case. I have a fix in place. If you could do any additional testing using one of the snapshot builds, that would be great. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ExternalizeMethods generates incorrect bytecode for statically compiled nested classes,GROOVY-7644,12907262,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,shils,shils,23/Oct/15 01:08,22/Feb/16 20:48,14/Jul/23 06:01,28/Oct/15 00:44,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Static compilation,,,,0,,,,,,,"When @AutoExternalize and @CompileStatic are both applied to a nested (static) class, the generated writeExternal and readExternal methods call writeObject/readObject on 'this' rather than on their arguments. This results in IncompatibleClassChange errors at runtime. Example:

{code}
class Person {
    @groovy.transform.ToString(includePackage=false)
    @groovy.transform.AutoExternalize
    @groovy.transform.CompileStatic
    static class AddressCS {
        String street, town
    }
}
{code}

The bytecode generated for the Person.AddressCS.writeExternal method is:
{code}
public writeExternal(Ljava/io/ObjectOutput;)V throws java/io/IOException 
   L0
    ALOAD 0
    ALOAD 0
    GETFIELD Person$AddressCS.street : Ljava/lang/String;
    INVOKEINTERFACE java/io/ObjectOutput.writeObject (Ljava/lang/Object;)V
    ACONST_NULL
    POP
    ALOAD 0
    ALOAD 0
    GETFIELD Person$AddressCS.town : Ljava/lang/String;
    INVOKEINTERFACE java/io/ObjectOutput.writeObject (Ljava/lang/Object;)V
    ACONST_NULL
    POP
   L1
    RETURN
    LOCALVARIABLE this LPerson$AddressCS; L0 L1 0
    LOCALVARIABLE out Ljava/io/ObjectOutput; L0 L1 1
    MAXSTACK = 2
    MAXLOCALS = 2
{code}

This seems to occur because the writeObject method call expressions within writeExternal have implicitThis set to true. 

The problem is essentially the same for generated readExternal methods.

","OSX 10.10, JDK 1.8",githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Oct 24 09:44:24 UTC 2015,,,,,,,,,,"0|i2netb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Oct/15 01:19;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/157

    GROOVY-7644 ExternalizeMethods generates incorrect bytecode for stati…

    …cally compiled nested classes

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7644

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/157.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #157
    
----
commit 8b1107aa24fedad567d5f72e3dcb0cdfae84ca5e
Author: Shil Sinha <shils@apache.org>
Date:   2015-10-23T01:16:49Z

    GROOVY-7644 ExternalizeMethods generates incorrect bytecode for statically compiled nested classes

----
;;;","24/Oct/15 09:44;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/157
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE when using safe traversal operator with CompileStatic,GROOVY-7639,12905979,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,podollb,podollb,19/Oct/15 16:41,22/Feb/16 20:48,14/Jul/23 06:01,02/Nov/15 20:55,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Compiler,,,,0,,,,,,,"In the code below, the ""if"" condition throws a NPE when it reaches the ""p3"" object. If I remove the @CompileStatic from the ""SomeOther"" class it works.
{code:java}
import groovy.transform.CompileStatic

@CompileStatic
class Person {
  String name
  OtherInfo otherInfo
}

@CompileStatic
class OtherInfo {
  int favoriteNumber
}

@CompileStatic
class SomeOther {
  SomeOther() {
    Person p1 = new Person(name: 'Ben', otherInfo: new OtherInfo(favoriteNumber: 1))
    Person p2 = new Person(name: 'Aaron', otherInfo: new OtherInfo())
    Person p3 = new Person(name: 'Fred')
    [p1,p2,p3].each { Person p ->
      println ""checking: ${p.name}""
      println p?.otherInfo?.favoriteNumber
      if(p?.otherInfo?.favoriteNumber == 7){
        println ""luckiest number!""
      }
    }
  }
}

new SomeOther()
{code}",,blackdrag,githubbot,melix,podollb,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 03 00:54:21 UTC 2015,,,,,,,,,,"0|i2n71z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Oct/15 16:18;shils;This occurs because a primitive compare is performed for {{p?.otherInfo?.favoriteNumber == 7}}, since the inferred type of the lhs is int instead of Integer. The obvious fix would be to store the inferred type of null safe property expressions as the wrapper type in case of primitives (as is done with null safe method call expressions), but this would break the tests put in place for GROOVY-5613. ;;;","22/Oct/15 07:16;blackdrag;do you mean with ""as is done with null safe method call expressions"" something like foo?.bar(), where foo is a priimitive?;;;","22/Oct/15 16:01;shils;I mean things like foo?.doBar() where doBar() returns a primitive type. Example:

{code}
class Foo {
    int bar

    int doBar() {
        bar
    }
}

@groovy.transform.CompileStatic
void test() {
    Foo foo = null
    assert !(foo?.doBar() == 7) // passes
    assert !(foo?.bar == 7) // NPE
}
test()
{code}

When storing the type for safe method call expressions (via StaticTypeCheckingVisitor.storeType), wrapper types are stored in place of primitives, resulting in ScriptBytecodeAdapter.compareEqual comparisons for things like foo?.doBar() == 7. There's no such guard for safe property expressions, so the inferred type of foo?.x is int and a primitive comparison is performed instead.

Though it would be possible to handle this during class generation, it seems logical to me that the inferred return type for a safe expression, method call or property, should not be a primitive type. However, the tests in GROOVY-5613 explicitly test for the opposite in the case of property expressions. 
;;;","23/Oct/15 08:19;blackdrag;Frankly I think GROOVY-5613 has been solved in the wrong way. 0 is not null. 
;;;","23/Oct/15 13:57;shils;Perhaps [~melix] can comment?;;;","23/Oct/15 14:13;melix;Yes, I think the fix for GROOVY-5613 is wrong. The inferred type for a?.foo should be a boxed type, because it can be either {{null}} or a primitive type, so the least upper bound is {{Object}}.;;;","23/Oct/15 14:48;shils;In that case, my proposed fix for this issue should be ok, but we'll need new tests for GROOVY-5613.;;;","24/Oct/15 09:30;blackdrag;I suggest you change the tests to check for the boxed variant as part of this fix. If there will be more tests failing as a result of this, we can discuss further;;;","28/Oct/15 00:47;shils;You mean change the tests for GROOVY-5613? They are the only 3 tests that fail when my fix is applied.;;;","28/Oct/15 06:33;blackdrag;yes;;;","29/Oct/15 04:00;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/167

    GROOVY-7639 Comparing primitive to null safe primitive property expre…

    …ssion should not throw NPE
    
    * Correct assertions in tests for GROOVY-5613

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7639

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/167.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #167
    
----
commit a6e380e3f96e61749f2dea5cec636a7c4bc28ca4
Author: Shil Sinha <shils@apache.org>
Date:   2015-10-29T03:58:56Z

    GROOVY-7639 Comparing primitive to null safe primitive property expression should not throw NPE
    * Correct assertions in tests for GROOVY-5613

----
;;;","01/Nov/15 15:48;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/167
;;;","02/Nov/15 19:43;shils;I don't seem to have the jira rights to resolve this, but it should be fixed.;;;","02/Nov/15 20:55;blackdrag;I resolve the issue for you.... I added some permissions for you, so you should be able to do it yourself next time;;;","03/Nov/15 00:54;shils;Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DefaultTypeTransformation.compareTo not symmetrical,GROOVY-7637,12905947,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,tkruse,tkruse,19/Oct/15 14:21,02/May/17 02:03,14/Jul/23 06:01,25/Jul/16 09:17,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,groovy-jdk,,,,0,,,,,,,"DefaultTypeTransformation.compareTo(Object left, Object right) is being used in plenty of places in Groovy.

However, for several corner cases, it does not provide symmetry, that is: when compareTo(a, b) returns a value (does not fail), then:

signum(compareTo(a, b)) == - signum(compareTo(b, a))

To reproduce:
{code}
  static class MyNumber extends Number {
        def n

        MyNumber(n) {
            this.n = n
        }

        int intValue(){n}
        long longValue(){n}
        float floatValue(){n}
        double doubleValue(){n}
        int hashCode(){-n}
        boolean equals(other) {
            if (other instanceof MyNumber) { return n==other.n}
            return false
        }
        String toString() {n.toString()}
    }

    static class MyNumberCompareTo extends MyNumber {

        MyNumberCompareTo(Object n) {
            super(n)
        }

        int compareTo(MyNumber other) {
            return n <=> other.n
        }
    }

    static class MyNumberComparable extends MyNumberCompareTo implements Comparable<MyNumber> {
        MyNumberComparable(Object n) {
            super(n)
        }

        int compareTo(Object other) {
            return n <=>  (MyNumber) other;
        }
    }

    void testCompareTo() {
        def object1 = new Object()
        def object2 = new Object()
        // objects
        assert compareTo(null, null) == 0
        assert compareTo(object1, null) == 1
        assert compareTo(null, object1) == -1
        assert compareTo(1, 1) == 0

        shouldFail(GroovyRuntimeException) {
            compareTo(object1, object2)
        }

        // chars, int values 49 and 50
        Character char1 = '1' as Character
        Character char2 = '2' as Character
        checkCompareToSymmetricSmallerThan(char1, char2)

        MyNumber number1 = new MyNumber(49)
        MyNumber number2 = new MyNumber(50)

        MyNumberCompareTo numCompTo1 = new MyNumberCompareTo(49)
        MyNumberCompareTo numCompTo2 = new MyNumberCompareTo(50)

        MyNumberComparable numComp1 = new MyNumberComparable(49)
        MyNumberComparable numComp2 = new MyNumberComparable(50)

        List lowers = [49, 49L, 49.0, 49.0G, 49.00G, char1, '1', number1, numCompTo1, numComp1]
        List highers = [50, 50L, 50.0, 50.0G, 50.00G, char2, '2', number2, numCompTo2, numComp2]

        lowers.each { def lower ->
            assert compareTo(lower, lower) == 0
            highers.each { def higher ->
                checkCompareToSymmetricSmallerThan(lower, higher)
            }
        }

        // glitch, failing with ClassCastException
        shouldFail(GroovyRuntimeException) {
            compareTo(1, ""22"")
        }
        shouldFail(GroovyRuntimeException) {
            compareTo(""22"", 1)
        }

        // strings and chars


        assert compareTo('aa1', '2' as Character) > 0
        // bug, classCast exception
        assert compareTo('2' as Character, 'aa1') < 0

        assert compareTo(""aa${1}"", '2' as Character) > 0
        // bug, classCast exception
        assert compareTo('2' as Character, ""aa${1}"") < 0

        // Strings and GStrings
        List lowers2 = ['aa1', ""aa${1}""]
        List highers2 = ['bb2', ""b${2}""]
        lowers2.each { def lower ->
            assert compareTo(lower, lower) == 0
            highers2.each { def higher ->
                checkCompareToSymmetricSmallerThan(lower, higher)
            }
        }
    }

    static void checkCompareToSymmetricSmallerThan(a, b) {
        try {
            assert compareTo(a, b) < 0
            assert compareTo(b, a) > 0
        } catch (AssertionError e) {
            System.err.print(a.class.toString() + ' compared to ' + b.class.toString() )
            throw e
        }
    }
{code}",,githubbot,paulk,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 25 09:17:05 UTC 2016,,,,,,,,,,"0|i2n6uv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Oct/15 14:28;githubbot;GitHub user tkruse opened a pull request:

    https://github.com/apache/incubator-groovy/pull/150

    fix GROOVY-7637 and GROOVY-7636 issues around Number Comparisons

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/tkruse/incubator-groovy groovy-7637-compareTo

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/150.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #150
    
----
commit 48767107d824976c19199e7a863d644fd926e7fe
Author: Thibault Kruse <thibault.kruse@gmx.de>
Date:   2015-09-07T10:05:26Z

    GROOVY-7637: Fix inconsistent missing Symmetry in DefaultTypeTransformation.compareTo()

commit aa5ee3f98d93b22fdb0cdc89f8c3a79e6bc95f98
Author: Thibault Kruse <thibault.kruse@gmx.de>
Date:   2015-10-19T13:47:01Z

    GROOVY-7636: Fall back to BigDecimalMath for custom Number implementations

----
;;;","19/Oct/15 14:29;tkruse;See https://github.com/apache/incubator-groovy/pull/150;;;","19/Oct/15 14:33;tkruse;Note all issues found were such where compareTo(a, b) worked, but compareTo(b, a) failed with some exception. I fixed all those by making compareTo(b, a) also work. Arguably those could also have been fixed by also making compareTo(a, b) fail, but I assumed from the code that all such cases of compareTo(a, b) worked intentionally (because ""if-conditions"" had been written to handle those cases specifically).;;;","19/Oct/15 14:36;tkruse;Related to http://groovy.329449.n5.nabble.com/usage-of-NumberAwareComparator-in-extension-methods-and-number-oddities-a-bit-code-review-td5727501.html;;;","25/Jul/16 09:11;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/150
;;;","25/Jul/16 09:17;paulk;PR merged with some minor tweaks. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NumberMath.getMath suboptimal choice for custom Numbers,GROOVY-7636,12905939,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,tkruse,tkruse,19/Oct/15 13:35,02/May/17 02:03,14/Jul/23 06:01,25/Jul/16 10:05,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,groovy-jdk,,,,0,,,,,,,"When implementing the java.lang.Number interface with a custom class, the groovy NumberMath class file's instanceof check do not find a math, and it defaults to IntegerMath. I believe the default should be BigDecimal for best-effort compatibility.

Also when comparing BigDecimal to a true Float or Double, FloatingPointMath is used, not BigDecimalMath.

to reproduce:
{code}  
    static class MyNumber extends Number {
        def n

        MyNumber(n) {
            this.n = n
        }

        int intValue(){n}
        long longValue(){n}
        float floatValue(){n}
        double doubleValue(){n}
        int hashCode(){-n}
        boolean equals(other) {
            if (other instanceof MyNumber) { return n==other.n}
            return false
        }
        String toString() {return Double.toString(floatValue())}
    }



    void testGetMathCustom() {
        //assert getMath(50.0G, Float.valueOf(""1.0"")) == BigDecimalMath.INSTANCE;
        //assert getMath(50G, Float.valueOf(""1.0"")) == BigDecimalMath.INSTANCE;
        MyNumber num = new MyNumber(42);
        assert getMath(num) == BigDecimalMath.INSTANCE;
        assert getMath(num, 25) == BigDecimalMath.INSTANCE;
    }
{code}

",,githubbot,msgilligan,paulk,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7608,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 26 07:17:45 UTC 2016,,,,,,,,,,"0|i2n6t3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Oct/15 13:42;tkruse;I guess ""promotion"" from bigDecimal or BigInteger to Double of float is the documented Groovy type promotion, so that part is probably not a true bug.;;;","19/Oct/15 14:29;tkruse;See https://github.com/apache/incubator-groovy/pull/151;;;","19/Oct/15 14:36;tkruse;Related to: http://groovy.329449.n5.nabble.com/usage-of-NumberAwareComparator-in-extension-methods-and-number-oddities-a-bit-code-review-td5727501.html;;;","19/Oct/15 15:06;githubbot;GitHub user tkruse opened a pull request:

    https://github.com/apache/incubator-groovy/pull/151

    GROOVY-7636: Fall back to BigDecimalMath for custom Numbers

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/tkruse/incubator-groovy groovy-7636-choose-math

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/151.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #151
    
----
commit 181b7ad7117ec6c95edde10bc8d1f3d34586f162
Author: Thibault Kruse <thibault.kruse@gmx.de>
Date:   2015-10-19T15:05:56Z

    GROOVY-7636: Fall back to BigDecimalMath for custom Number implementations

----
;;;","25/Jul/16 09:59;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/151
;;;","25/Jul/16 10:05;paulk;PR merged, thanks! I wasn't intending to port back to the 2_4_X branch but let me know if you feel strongly about that intention.;;;","26/Jul/16 07:17;msgilligan;If this fixes GROOVY-7608 i'd love to see it back ported to Groovy 2.4.x (assuming that gets released more quickly)
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic compiles 0 != null to false,GROOVY-7631,12905072,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,kgdev,kgdev,15/Oct/15 04:04,22/Feb/16 20:48,14/Jul/23 06:01,19/Oct/15 16:29,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Static compilation,,,,0,,,,,,,"import groovy.transform.*;

// @CompileStatic
class Bug {
    void exec() {
        println 0 != null
    }
}

new Bug().exec()

​The above code prints ""true"". But when @CompileStatic is umcommented, it prints ""false"".",,githubbot,kgdev,pascalschumacher,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 19 16:29:41 UTC 2015,,,,,,,,,,"0|i2n1gn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Oct/15 20:15;shils;I tested this on 2.0.0, 2.0.8, 2.1.9, 2.2.2 and 2.3.11; the behavior is the same across those versions. 

Edit:
This seems to be an issue for all primitive values, not just 0. Example:

{code}
@groovy.transform.CompileStatic
void test() {
    // these all fail
    assert true != null
    assert (byte) 1 != null
    assert (short) 1 != null
    assert 1 != null
    assert 1L != null
    assert 1f != null
    assert 1d != null
    assert (char) 1 != null    
}
test()
{code}

If the types above are replaced with their wrapper types, the test passes. 
The relevant code appears to be in CompareToNullExpression.visit method, where the primitive operand (which is being compared to null) is popped from the stack and a 0 is pushed, regardless of whether the comparison is an equals (==) or not equals (!=). 

This could be a breaking change if people were relying on {{p != null}} to return false for falsy primitives, but it's probably a change that should be made given the behavior in the dynamic case.;;;","18/Oct/15 22:10;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/148

    GROOVY-7631 If p is a primitive value, p != null returns false when s…

    …tatically compiled

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7631

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/148.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #148
    
----
commit ba4d8997fe9de2c9454748b8f247b64828477b02
Author: Shil S <shil.sinha@gmail.com>
Date:   2015-10-18T22:09:05Z

    GROOVY-7631 If p is a primitive value, p != null returns false when statically compiled

----
;;;","19/Oct/15 16:27;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/148
;;;","19/Oct/15 16:29;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper LAX parser with invalid number,GROOVY-7630,12904935,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,reddierocket,reddierocket,14/Oct/15 17:30,12/Mar/16 21:33,14/Jul/23 06:01,21/Dec/15 17:40,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,JSON,,,,0,,,,,,,"The JsonSlurper LAX parser parses an invalid number incorrectly:
{code:title=Example.java|borderStyle=solid}
import groovy.json.*

def obj = new JsonSlurper().setType(JsonParserType.LAX).parseText('{ ""num"": 1a}')
println ""1a: num = ${obj.num}""
println ""1a: type is "" + obj.num.class.name

obj = new JsonSlurper().setType(JsonParserType.LAX).parseText('{ ""num"": 1A}')
println ""1A: num = ${obj.num}""
println ""1A: type is "" + obj.num.class.name
{code}
produces:
1a: num = 59
1a: type is java.lang.Integer
1A: num = 27
1A: type is java.lang.Integer

It seems like the parser should fail this as an invalid number, though one could argue the LAX parser could interpret it as hex 1a, but neither is being done.  Valid numbers are of course parsed correctly.
","DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=14.10
DISTRIB_CODENAME=utopic
DISTRIB_DESCRIPTION=""Ubuntu 14.10""
Linux 3.16.0-44-generic x86_64
",githubbot,jwagenleitner,pascalschumacher,reddierocket,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 21 17:37:46 UTC 2015,,,,,,,,,,"0|i2n0m7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Nov/15 19:20;jwagenleitner;I also think it should fail with an exception.  This same invalid number parsing behavior is also present in {{JsonParserType.INDEX_OVERLAY}}.

Since decimals can be expressed in scientific notation the following is a valid decimal number {{1e12}} and is parsed corrected.  If LAX were to support hex (which would get it closer to supporting JSON5 - GROOVY-6813) it should probably require it to be in the {{0x1e12}} format.;;;","15/Nov/15 18:37;jwagenleitner;Did some checking to see how invalid numbers are handled by the LAX parser.  INDEX_OVERLAY results are pretty much the same except that some handling of multiple decimal points was added to it at some point.  Using the default parser (CHAR_BUFFER) these all fail on parse.

I think these cases should probably all fail on parse for LAX and INDEX_OVERLAY.

{code:title=LAX Parser v2.4.5}
Failed on accesss for [1.1.1] with exception [groovy.json.JsonException]
Parsed [1a] to [59]
Failed on accesss for [1e] with exception [groovy.json.JsonException]
Failed on accesss for [1E] with exception [groovy.json.JsonException]
Parsed [1A] to [27]
Parsed [-1a] to [-59]
Parsed [98ab9] to [103409]
Parsed [12/25/1980] to [1192491980]
Failed on accesss for [1980-12-25] with exception [groovy.json.JsonException]
Failed on accesss for [1.2ee5] with exception [groovy.json.JsonException]
Failed on accesss for [1.2EE5] with exception [groovy.json.JsonException]
Failed on accesss for [1.2Ee5] with exception [groovy.json.JsonException]
Failed on accesss for [1.2e++5] with exception [groovy.json.JsonException]
Failed on accesss for [1.2+e5] with exception [groovy.json.JsonException]
Failed on accesss for [6.92e+5.5] with exception [groovy.json.JsonException]
Failed on accesss for [6+] with exception [groovy.json.JsonException]
Parsed [1~2@3] to [88363]
{code}

Here's the script I used to generate the results:

{code}
import groovy.json.*

def parser = new JsonSlurper().setType(JsonParserType.LAX)

def testNumbers = [
'1.1.1', '1a', '1e', '1E', '1A', '-1a', '98ab9', '12/25/1980', 
'1980-12-25', '1.2ee5', '1.2EE5', '1.2Ee5', '1.2e++5', '1.2+e5', 
'6.92e+5.5', '6+', '1~2@3'
]

for (testNumber in testNumbers) {
    try {
        def json = parser.parseText(""""""{""num"": ${testNumber}}"""""")
        try {
            def result = json.num
            println ""Parsed [${testNumber}] to [${result}]""        
        } catch (JsonException | NumberFormatException ex) {
            println ""Failed on accesss for [${testNumber}] with exception [${ex.getClass().getName()}]""
        }    
    } catch (JsonException | NumberFormatException ex) {
        println ""Failed on Parse for [${testNumber}] with exception [${ex.getClass().getName()}]""
    } 
}
{code};;;","15/Nov/15 19:12;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/incubator-groovy/pull/189

    GROOVY-7630 - JsonSlurper LAX parser with invalid number

    Breaking changes proposed here, but current behavior appears incorrect even in terms of relaxed parsing.  In addition to addressing GROOVY-7630, also found some missing cases around decimal parsing which were partially addressed by commit 8063a9dec07329804f3e1770aa31984bc38a694d for GROOVY-7344.
    
    There seems to be quite a bit of duplication between the LAX and INDEX_OVERLAY parsers that I didn't address in this PR (actually adding more duplication :smile:).  I didn't want to introduce too much change, but at some point would like to come back and remove the duplication.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/incubator-groovy GROOVY-7630

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/189.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #189
    
----
commit 7bb1bdc0611d10605b0c9c441c9d3414fbc7b282
Author: John Wagenleitner <john.wagenleitner@gmail.com>
Date:   2015-11-15T07:08:04Z

    GROOVY-7630 - JsonSlurper LAX parser with invalid number

----
;;;","19/Nov/15 19:03;jwagenleitner;I took a quick look at Jackson and Gson (and a few others) to see how they handle lenient parsing [1].  I couldn't find any settings in Jackson that allowed a value such as {{1a}} to parse successfully.  Gson (lenient by default) parsed {{1a}} as a string instead of treating like like a number.  I tried the JSON5 (javascript) library since it's supposed to be pretty relaxed and it failed to parse.

For the LAX parser, it might be good to emulate Gson's approach of treating it as a string.  Other option would be to allow it to parse but fail on access of the field.

[1] https://github.com/jwagenleitner/testing-groovy/tree/7cd75a374dbacfaf0ecc07e70f2a19bc3c3034a2/GROOVY7630/scripts;;;","24/Nov/15 17:53;pascalschumacher;Almost no feedback to the mailing list thread (other than Guillaume stating he prefers the parser to fail on access). I do not feel qualified to offer any opinion on this. What do you think the behavior should be?;;;","30/Nov/15 22:43;jwagenleitner;I agree with Guillaume that it should fail on parse.  Even though LAX can parse unquoted strings such as {{a1}} I don't think it should parse {{1a}} unquoted since that's not a valid javascript identifier or valid number.  Would be interested to hear from others that might be watching this issue.;;;","02/Dec/15 16:25;reddierocket;I agree if one wanted a hex number, it should be 0x1a or 0x1A and they should parse to the same hex number.  If the general rule for the LAX parser is ""try to make sense of what they put in"", then it seems that anything other than a valid number should parse as a string.  So maybe 1a should just parse as a string, and if they try to use it as a number (e.g. x as int) it should give a NumberFormatException.;;;","12/Dec/15 20:03;jwagenleitner;Gave it some more thought and I agree that LAX should probably be forgiving and treat invalid numbers as a string.  I have updated the [pull request|https://github.com/apache/groovy/pull/189].  Any feedback on it would be most welcomed.;;;","21/Dec/15 17:37;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/189
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Property calls are not correctly type checked if the setter parameter type or getter return type are not the field type,GROOVY-7627,12904437,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,13/Oct/15 05:03,22/Feb/16 20:48,14/Jul/23 06:01,26/Jan/16 05:25,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,,,,,,,"If a class defines a property but also explicitly provides a getter or setter, property style get/set calls are type checked using the underlying field type rather than the getter return type/setter parameter type.

Setter example:
{code}
class Foo {
    Bar bar;

    void setBar(int x) {
        this.bar = new Bar(x: x)
    }
}

class Bar {
    int x
}

@groovy.transform.TypeChecked
void test() {
    Foo foo = new Foo()
    foo.bar = new Bar()
}

test()
{code}

The code above will pass STC and throw a GroovyCastException at runtime. Conversely, code like {{foo.bar = 1}} will not pass STC.  The case for getters with return type different from the field type is similar.",JDK 1.8.0_60,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 26 04:42:50 UTC 2016,,,,,,,,,,"0|i2mxjz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Oct/15 07:16;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/139

    GROOVY-7627 Property calls are not correctly type checked if the sett…

    …er parameter type or getter return type are different from the underlying field type

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7627

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/139.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #139
    
----
commit 211f7426f4fe31aa360fc48bb5af15cee6ea9e3d
Author: Shil S <shil.sinha@gmail.com>
Date:   2015-10-13T07:03:55Z

    GROOVY-7627 Property calls are not correctly type checked if the setter parameter type or getter return type are different from the underlying field type

----
;;;","13/Oct/15 07:19;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/139#discussion_r41833604
  
    --- Diff: src/test/groovy/transform/stc/GenericsSTCTest.groovy ---
    @@ -1613,6 +1613,8 @@ assert result == 'ok'
                 class ComponentFixture<T extends Component> {}
                 class JButtonFixture extends ComponentFixture<JButton> {}
                 class ContainerFixture<T extends Container> extends ComponentFixture<T> {}
    +
    +            @groovy.transform.TypeChecked(groovy.transform.TypeCheckingMode.SKIP)
    --- End diff --
    
    This class wasn't type checked in the example in the issue (GROOVY-5981), so this should be ok.
;;;","13/Oct/15 10:58;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/139#discussion_r41852510
  
    --- Diff: src/test/groovy/transform/stc/GenericsSTCTest.groovy ---
    @@ -1613,6 +1613,8 @@ assert result == 'ok'
                 class ComponentFixture<T extends Component> {}
                 class JButtonFixture extends ComponentFixture<JButton> {}
                 class ContainerFixture<T extends Container> extends ComponentFixture<T> {}
    +
    +            @groovy.transform.TypeChecked(groovy.transform.TypeCheckingMode.SKIP)
    --- End diff --
    
    you mean the compilation of that class would fail without this?
;;;","13/Oct/15 15:16;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/139#discussion_r41879861
  
    --- Diff: src/test/groovy/transform/stc/GenericsSTCTest.groovy ---
    @@ -1613,6 +1613,8 @@ assert result == 'ok'
                 class ComponentFixture<T extends Component> {}
                 class JButtonFixture extends ComponentFixture<JButton> {}
                 class ContainerFixture<T extends Container> extends ComponentFixture<T> {}
    +
    +            @groovy.transform.TypeChecked(groovy.transform.TypeCheckingMode.SKIP)
    --- End diff --
    
    Yes, I thought it may have been the case that that class should not have compiled with STC in the first place. After you commented, I took another look and realized that it was an actual regression - pseudo property calls within the owning class would break with STC. I've updated my pull request accordingly. 
    
    I also created a simpler unit test for pseudo property calls with STC, but that's probably better off in a separate pr/commit.
;;;","14/Oct/15 16:56;shils;Background for the problem and the fix:

If a PropertyNode exists for a given PropertyExpression, StaticTypeCheckingVisitor.existsProperty currently sets the expression's inferred type to the type of the node, without considering the return type of an explicit getter for the property in case of reads, or the parameter type of an explicit setter for the property in case of writes. 

If we are outside (in the type checking context sense) of a candidate receiver type for the property, we should consider any existing getter/setters prior to looking at the property node to determine the expression's type.;;;","26/Jan/16 04:42;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/139
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Collection asImmutable() methods aren't immutable,GROOVY-7624,12903902,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,chrylis,chrylis,09/Oct/15 21:17,10/Apr/18 13:02,14/Jul/23 06:01,06/Mar/18 23:08,2.4.5,,,,,,,,,,,,,,,,,2.5.0-rc-1,,,,groovy-jdk,,,,0,breaking,,,,,,"The contract for the Collection {{asImmutable()}} methods specify that the returned collection is immutable, but in fact the collection is merely read-only; it uses {{Collections.unmodifiable*()}}, which wraps an underlying collection that is still mutable.

These methods should return actual immutable collections, either using Collections unmodifiables with copies of the underlying collections or using an actual immutable backing implementation, a la Guava.",,chrylis,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 06 23:08:01 UTC 2018,,,,,,,,,,"0|i2mu93:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Oct/15 11:39;paulk;Yes, the easiest things is probably calling {{clone()}} on the Collection (and Set, Map etc.) instance before passing to {{unmodifiable}}. Of course Collection is not Cloneable but most of the implementations are, so it's a little messy. We already have a standard way of implementing this though, e.g. the code produced by the @AutoClone AST transform. We could do something similar and just make sure it still makes sense when used in conjunction with @TypeChecked/@CompileStatic.;;;","06/Mar/18 12:18;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/672

    GROOVY-7624: Collection asImmutable() methods aren't immutable

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7624

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/672.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #672
    
----
commit 9326ebe6040bb242d68fc8a835429a846ac9edc1
Author: paulk <paulk@...>
Date:   2018-03-06T12:16:29Z

    GROOVY-7624: Collection asImmutable() methods aren't immutable

----
;;;","06/Mar/18 12:24;paulk;The proposed PR modifies the existing methods to obey their name and advertised behavior in the javadoc. It also adds {{asUnmodifiable()}} variants which provide the existing flawed behavior for those times when a view is sufficient and the extra copying is unwanted.;;;","06/Mar/18 23:05;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/672
;;;","06/Mar/18 23:08;paulk;Proposed PR merged. Thanks for raising the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
IBM Java (J9) ClassValue works correctly so should use it by default,GROOVY-7623,12903831,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,candrews,candrews,09/Oct/15 17:14,30/Aug/16 14:19,14/Jul/23 06:01,19/Oct/15 16:44,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,,,,,0,,,,,,,"GROOVY-7591 disabled the use of java.lang.ClassValue by default due to a bug in OpenJDK: https://bugs.openjdk.java.net/browse/JDK-8136353 The result is that GROOVY-6704 occurs on all versions of Java again.

The bug in OpenJDK does not impact IBM Java, so when running on IBM Java, java.lang.ClassValue should be used by default.  So at least users on IBM Java will not experience GROOVY-6704.",,candrews,githubbot,gsAndrew,pablo72,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7683,GROOVY-6704,GROOVY-7591,,,,,,,,,,,"30/Aug/16 14:17;gsAndrew;Screen Shot 2016-08-30 at 10.11.18 AM.png;https://issues.apache.org/jira/secure/attachment/12826186/Screen+Shot+2016-08-30+at+10.11.18+AM.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 30 14:17:26 UTC 2016,,,,,,,,,,"0|i2mtsn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Oct/15 17:20;candrews;https://github.com/apache/incubator-groovy/pull/137;;;","19/Oct/15 16:43;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/137
;;;","19/Oct/15 16:44;pascalschumacher;Pull request merged. Thanks!;;;","30/Aug/16 14:17;gsAndrew;For anyone who is attempting to use the IBM JDK 8 for a grails project, here is how I did it in my development environment for a Grails 2.5.5 project.  I'm sure there is a lower common denominator of a solution but, this is what I did.  I'm currently deploying to Heroku in production and developing on Mac OSX so it made things a little trickier since I didn't have a Linux environment handy to unpack the .bin from IBM.  

Once you've got the .tar.gz in hand, I had to untar it, remove jre/lib/xml.jar since it's using old versions of xerces/xalan/etc classes and weren't playing nice with my Grails 2.5.5 project.  Then, I added the following files into jre/lib/endorsed:

jaxp-api-1.4.2.jar, serializer-2.7.2.jar, xalan-2.7.2.jar, xercesImpl-2.9.1.jar, xml-apis-1.3.04.jar

Now, there's a fun little piece of code in ClasspathConfigurer that likes to force you to use a particular javax.xml.parsers.DocumentBuilderFactory if Grails finds a xercesImpl dependency (transitive or not) in your BuildConfig.  And, ClasspathConfigurer gets invoked when using ./grailsw (which Heroku makes use of). So, that's why I ""had"" to put xercesImpl in the endorsed lib instead of just using the version in my project.  I attempted to use the IBM JDK as it was combined with Heroku's support for a .jdk-overlay directory but it wasn't strong enough of an override.

{code:title=ClasspathConfigurer.java|borderStyle=solid}
protected void addDependenciesToURLs(Set<String> excludes, List<URL> urls, List<File> runtimeDeps) throws MalformedURLException {
        if (runtimeDeps == null) {
            return;
        }

        for (File file : runtimeDeps) {
            if (file == null ) {
                continue;
            }


            if (file.getName().contains(""xercesImpl"")) {
                // workaround for GRAILS-9708
                System.setProperty(""javax.xml.parsers.DocumentBuilderFactory"",""com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl"");
            }
            if (excludes != null && !excludes.contains(file.getName())) {
                URL url = file.toURI().toURL();
                if (urls.contains(url)) continue;

                urls.add(url);
                excludes.add(file.getName());
            }
        }
    }
{code}

In my BuildConfig.groovy I had to add setting the following dependencies:

{code}
runtime ('org.codehaus.groovy.modules.http-builder:http-builder:0.7.1') {excludes 'xercesImpl'}

runtime ""xalan:xalan:2.7.2""

runtime ""com.fasterxml.woodstox:woodstox-core:5.0.3""
{code}

The xercesImpl exclusion I explained and the woodstox is because the xml.jar IBM had included some streaming XML class files that needed replenishing.

Then......

After I re-tared up the IBM JDK with the xml.jar removed and my other jars inserted I was able to start the Heroku server and get past the step of grailsw that auto-generates the war file. 

Then....

 I ran into the problem where IBM's JSSE loves to default to using TLS 1.0 and my integration with Stripe was failing since that requires TLSv1.2 ""or higher"".  After some more headbanging I ran into this IBM support doc that was satisfyingly infuriating.  I was simultaneously pissed they made the choice not to operate like every other JDK but at least they made it possible to play nice.

{quote}
Use the system property com.ibm.jsse2.overrideDefaultTLS to match the behavior of SSLContext.getInstance(""TLS"") in the IBM SDK with the Oracle implementation.

com.ibm.jsse2.overrideDefaultTLS =true|false
{quote}
from [IBM Support|http://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.security.component.80.doc/security-component/jsse2Docs/matchsslcontext_tls.html#matchsslcontext_tls]

After all of that and I'm still not seeing the classes get garbage collected.  I pray it's because I'm somehow misusing groovy.use.classvalue=true

!Screen Shot 2016-08-30 at 10.11.18 AM.png!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Memory Leak (metaClassRegistry) unable to remove metaClass based on instances,GROOVY-7621,12903085,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,kimbonics,kimbonics,07/Oct/15 18:47,04/Jul/16 12:02,14/Jul/23 06:01,03/Jul/16 19:07,2.3.7,,,,,,,,,,,,,,,,,2.4.6,,,,groovy-runtime,,,,0,,,,,,,"I'm using the GroovyScriptEngine in a web server environment where the scripts are provided properties on-the-fly from database objects.  This is done by implementing script.metaClass.propertyMissing.  When I return a value, I set the metaClass to give the returned value even more sub-properties.  After processing 100k records or so, I run out of memory.  I tried to write code to remove entries from the metaClassRepository, but there's no way to do it for an object instanced based metaClass.  Also, I've outputed the GroovySystem.metaClassRepository.iterator().size() and it kept growing.  The values are out of scope so they should get garbage collected, but the metaClasses aren't getting cleaned up.

The workaround to this problem was to implement a groovy Proxy, though, I liked the metaClass solution better.","Running from Eclipse, JBoss with jdk 1.6",blackdrag,jkemnade,jwagenleitner,kimbonics,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 04 12:02:40 UTC 2016,,,,,,,,,,"0|i2mpe7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Jan/16 06:30;jwagenleitner;Possibly related to GROOVY-7683.;;;","11/Jan/16 09:28;blackdrag;Is script not a GroovyObject? Because in this case (and actually in any other case as well) script.metaClass = null is supposed to delete the per instance  meta class. And if you want to use the registry... There is a setMetaClass(Object,MetaClass) method, which you can give a null meta class, to remove the per instance meta class for that object. And you could use the iterator to remove the per instance meta class by calling remove once you have reached the entry. But script.metaClass = null, and this Iterator.remove are both using MetaClassRegistryImpl.setMetaClass(Object,MetaClass) to remove the per instance meta class for a non-GroovyObject class. For a GroovyObject implementing class you have the meta class stored directly on that instance, but then of course it is collected with the instance as well;;;","11/Jan/16 16:27;kimbonics;Thanks Jochen, I tried your suggestions but still fill up memory.  Here is a test script that you can run to see the problem.  I'm running in Windows and Groovy 2.3.7.  I am not able to use setMetaClass(Object,Metaclass) I get a MissingMethod.  Here is code.  If you can get this code to run (in spirit the same way it does) that would be awesome.  note this is a simplified script of what I am doing in practice.  This script is used in application with million plus of records being processed.

package com.enterworks.groovy.test

import org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl

def sampleSchema = [:]

sampleSchema.table1 = [column1: [name:'column1', dataType : 'varchar']
					 , column2: [name:'column2' ,dataType : 'integer']]


def propMissing = { 
	metaThings
	 ->
	
	
	def pMissing = null;
	
	
	pMissing = { pName ->
		
		
		def innerProp = delegate.hasProperty(""outerType"")
		if (!innerProp ){
			
		
				if ( sampleSchema[pName] ){
					
					def resolved = ""->""+pName 
					
					resolved.metaClass.propertyMissing = pMissing
					resolved.metaClass.outerType = ""table""
					resolved.metaClass.outer = pName
					
					metaThings << resolved
					return resolved
					
				}
						
		} else if (delegate.outerType == ""table"" ) {
		
			if ( sampleSchema[delegate.outer][pName] ){
				
				def resCol = ""->""+pName
				resCol.metaClass.propertyMissing = pMissing
				resCol.metaClass.outerType = ""column""
				resCol.metaClass.outer = sampleSchema[delegate.outer][pName]
				
				metaThings << resCol
				return resCol
				
				
			}
		
		
		} else if (delegate.outerType == ""column""){
		
		// No metaClasses because no more nesting...
			if ( pName == ""dataType"" ){
			
				return delegate.outer.dataType	
			} else if ( pName == ""name""){
			
				return delegate.outer.name
			}
		
		}
		
		throw new MissingPropertyException(pName)
	}
	
	return pMissing
	
}


def sampleScript = 
'def result = table1.column1.dataType\n if ( !(++counter % 1000)) println ""${counter}. ${result}""'



def gs = new GroovyShell();

def binding = new Binding()

binding.counter = 0

def script = gs.parse( sampleScript )


script.setBinding( binding)

def needsCleanup = []

script.metaClass.propertyMissing = propMissing( 
	needsCleanup
	)


for ( int i = 0; i < 1000000; i++){
	

	script.run()	
	
	if ( !(i % 100) ){
		// needsCleanup  ... how to?  I tried remove from metaClassRegistry to no avail...
		//
		// this gives errro:
		//Caught: groovy.lang.MissingMethodException: No signature of method: org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.removeMetaClass() is applicable for argument types: (java.lang.String, null) values: [->table1, null]
		//Possible solutions: removeMetaClass(java.lang.Class)
		//needsCleanup.each{ 
		//	GroovySystem.metaClassRegistry.removeMetaClass(it,null)
		//}
		
		needsCleanup.each{ it.metaClass = null }
		needsCleanup = []
	}
}


;;;","13/Jan/16 22:33;jwagenleitner;One problem with the test script is that it replaces the {{needsCleanup}} reference with a reference to a new list.  So now {{propMissing}} is still populating the original list passed to it and after first time through the loop {{needsCleanup}} is not populated with any more entries so there are no more calls to {{it.metaClass = null}}.  If I change it to {{needsCleanup.clear()}} it runs through all iterations.  Without the change it only runs 16,000 iterations before an OOME for me.  I tested using a 1G max heap.

{code}
.....
needsCleanup.each { it.metaClass = null }
needsCleanup = []   // change to -> needsCleanup.clear()
.....
{code}

;;;","13/Jan/16 23:42;jwagenleitner;I did some testing of the script removing the calls to set the metaclass to null (i.e., no cleanup) and used a 256m max heap size.  Using 2.4.5 and master it completed 4000 iterations before OOME.  With master+PR220 it did 7000 iterations.  And with master+PR220+PR219 the script completed all 1 million iterations.

[PR220 - Fix finalizeReference method override for ManagedReference subclasses|https://github.com/apache/groovy/pull/220]

[PR219 - GROOVY-7683 - Memory leak when using Groovy as JSR-223 scripting language|https://github.com/apache/groovy/pull/219]

Here is the script as tested

{code}
package bugreport

class LeakTest extends GroovyTestCase {

    void testLeak() {
        def sampleSchema = [:]
        sampleSchema.table1 = [column1: [name:'column1', dataType : 'varchar']
                               , column2: [name:'column2' ,dataType : 'integer']]

        def propMissing = { metaThings ->
            def pMissing = null
            pMissing = { pName ->
                def innerProp = delegate.hasProperty(""outerType"")
                if (!innerProp ){
                    if (sampleSchema[pName]) {
                        def resolved = ""->""+pName
                        resolved.metaClass.propertyMissing = pMissing
                        resolved.metaClass.outerType = ""table""
                        resolved.metaClass.outer = pName
//                        metaThings << resolved
                        return resolved
                    }
                } else if (delegate.outerType == ""table"") {
                    if (sampleSchema[delegate.outer][pName]) {
                        def resCol = ""->""+pName
                        resCol.metaClass.propertyMissing = pMissing
                        resCol.metaClass.outerType = ""column""
                        resCol.metaClass.outer = sampleSchema[delegate.outer][pName]
//                        metaThings << resCol
                        return resCol
                    }
                } else if (delegate.outerType == ""column"") {
                    // No metaClasses because no more nesting...
                    if ( pName == ""dataType"" ) {
                        return delegate.outer.dataType
                    } else if ( pName == ""name"") {
                        return delegate.outer.name
                    }
                }
                throw new MissingPropertyException(pName)
            }
            return pMissing
        }

        def sampleScript = '''
            def result = table1.column1.dataType
            if (!(++counter % 1000)) println ""${counter}. ${result}""
        '''

        def gs = new GroovyShell();
        def binding = new Binding()
        binding.counter = 0
        def script = gs.parse( sampleScript )
        script.setBinding(binding)
        def needsCleanup = []
        script.metaClass.propertyMissing = propMissing(needsCleanup)

        for ( int i = 0; i < 1000000; i++) {
            script.run()
//            if (!(i % 100)) {
                // needsCleanup ... how to? I tried remove from metaClassRegistry to no avail...
                //
                // this gives errro:
                //Caught: groovy.lang.MissingMethodException: No signature of method: org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.removeMetaClass() is applicable for argument types: (java.lang.String, null) values: [->table1, null]
                //Possible solutions: removeMetaClass(java.lang.Class)
                //needsCleanup.each { GroovySystem.metaClassRegistry.removeMetaClass(it,null) }
//                needsCleanup.each {
//                    it.metaClass = null
//                }
//                needsCleanup = [] //.clear()
//            }
        }
    }
}
{code};;;","28/Jan/16 17:37;jwagenleitner;Running the test now with master it runs successfully for me, commit [219447d0be82|https://github.com/apache/groovy/commit/219447d0be82ed5cfdc52c57293bd43d8edde2dc] was a slightly modified version of PR220 that was referenced above.  Snapshots are usually found at https://oss.jfrog.org/artifactory/oss-snapshot-local/org/codehaus/groovy/ but looks like it hasn't been updated for a while.  Might suggest testing against the 2.4.6 snapshot once the 2016-01-28 is available, would be helpful to know if it addresses the issue for you.;;;","30/Jan/16 12:04;pascalschumacher;[~kimbonics] 2.4.6 snapshots with the fix mentioned by John are now available. It would be nice if you could give them a try. Thanks! ;;;","30/Jan/16 13:43;kimbonics;Absolutely, I'll do this today.;;;","31/Jan/16 13:53;kimbonics;Very good.  This snapshot passed my volume test that previously failed.

This is running in a server environment inside of JBoss processing a data migration.

Previously, it was slowing down and duration of scripts steadily increasing.

Now the process is good.

I will continue on with other tests on this snapshot.



;;;","02/Feb/16 18:38;pascalschumacher;Thanks for testing the snapshot! :)

Let us know the results of the other tests. Thanks!;;;","10/Feb/16 00:55;kimbonics;I'm still working on load testing.  It's taking a little time because I have to back out the changes I made that were workarounds to the original bug.

But, so far it looks pretty stable.;;;","16/Feb/16 08:04;blackdrag;Can we just close this bug at the 2.4.6 release? Or is there still something left to do?;;;","18/Feb/16 19:26;pascalschumacher;[~kimbonics] I'm resolving this issue. Please reopen if it's not completely fixed. Thanks!;;;","15/Jun/16 16:19;kimbonics;Running groovy in a JBoss server environment, I'm getting the following stack trace after a few days of running in production....


2016-06-14 12:27:05:329 -0500   [org.jboss.jms.asf.StdServerSessionPool] 
	at java.lang.ref.ReferenceQueue.reallyPoll(ReferenceQueue.java:58)
	at java.lang.ref.ReferenceQueue.poll(ReferenceQueue.java:84)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:80)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
	at org.codehaus.groovy.util.ManagedReference.clear(ManagedReference.java:49)
	at org.codehaus.groovy.util.ManagedReference.finalizeReference(ManagedReference.java:53)
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:86)
	at org.codehaus.groovy.util.ReferenceManager$2.removeStallEntries(ReferenceManager.java:128)
;;;","15/Jun/16 18:23;jwagenleitner;Are you using version 2.4.6?  If so are you able to test with 2.4.7, a fix was put in that version in order to guard against this stackoverflow.;;;","15/Jun/16 20:18;kimbonics;I'll give it a try...

On Wed, Jun 15, 2016 at 2:24 PM, John Wagenleitner (JIRA) <jira@apache.org>

;;;","03/Jul/16 19:07;jwagenleitner;I'm going to reclose this issue, if you are seeing the stackoverflow issue in 2.4.7 then it would be good to open a new issue for that.;;;","04/Jul/16 12:02;kimbonics;Thanks

On Sun, Jul 3, 2016 at 3:08 PM, John Wagenleitner (JIRA) <jira@apache.org>

;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
No error if abstract getter is not implemented but static field exists,GROOVY-7620,12903037,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,bsideup,bsideup,07/Oct/15 16:36,12/Jun/16 08:45,14/Jul/23 06:01,01/Jun/16 05:00,2.4.5,,,,,,,,,,,,,,,,,2.4.7,,,,Compiler,,,,0,,,,,,,"Code example:
{code:java}
​abstract class A {
   abstract Object getFoo();

   void test() {
       println getFoo();
   }
}

class B extends A {
   static Object foo;
}

new B().test()


/*
java.lang.AbstractMethodError: A.getFoo()Ljava/lang/Object;
at A.test(Script1.groovy:5)
at A$test.call(Unknown Source)
at Script1.run(Script1.groovy:14)
*/
{code}

CompileStatic will not report an error as well.",,bsideup,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 01 05:00:26 UTC 2016,,,,,,,,,,"0|i2mp3j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/May/16 11:16;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/342

    GROOVY-7620: No error if abstract getter is not implemented but stati…

    …c field exists

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7620

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/342.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #342
    
----
commit 82bf31eac1b3a451f529fe50c35c4e2af93100a6
Author: paulk <paulk@asert.com.au>
Date:   2016-05-31T11:14:54Z

    GROOVY-7620: No error if abstract getter is not implemented but static field exists

----
;;;","01/Jun/16 03:43;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/342
;;;","01/Jun/16 05:00;paulk;Proposed PR applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Parameterless closure to SAM coercion causes NPE during instruction selection with STC,GROOVY-7618,12902888,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,shils,shils,07/Oct/15 04:19,22/Feb/16 20:48,14/Jul/23 06:01,07/Oct/15 19:24,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,,,,,,,"Coercion of parameterless closures (lazy eval blocks) to SAM type arguments  results in an NPE during static type checking.

Example:

{code}
interface SamType {
    int sam()
}

int foo(SamType samt) {
    samt.sam()
}

@groovy.transform.TypeChecked
void doFoo() {
    assert foo { -> 1 } == 1
}

doFoo()
{code}

Results in:
{code}
BUG! exception in phase 'instruction selection' in source unit 'ConsoleScript19' unexpected NullpointerException
Caused by: java.lang.NullPointerException
{code}
","Java 1.8.0_60, OSX 10.10",githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 07 19:17:09 UTC 2015,,,,,,,,,,"0|i2mo6f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Oct/15 04:23;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/135

    GROOVY-7618 Parameterless closure to SAM Type argument coercion cause…

    …s NPE during instruction selection (STC)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7618

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/135.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #135
    
----
commit ea3e8220668734aa009e276d41387f1b36c5641c
Author: Shil S <shil.sinha@gmail.com>
Date:   2015-10-07T04:21:51Z

    GROOVY-7618 Parameterless closure to SAM Type argument coercion causes NPE during instruction selection (STC)

----
;;;","07/Oct/15 19:17;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/135
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Grape fails to load Groovy Extensions,GROOVY-7613,12901550,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pickypg,pickypg,30/Sep/15 10:24,26/Jun/16 10:44,14/Jul/23 06:01,26/Jun/16 10:44,2.1.5,2.4.1,2.4.4,,,,,,,,,,,,,,,2.4.7,,,,Grape,,,,2,,,,,,,"https://github.com/elastic/elasticsearch-groovy/issues/29

*The problem is that it has Groovy itself as a dependency, so using GrabExclude avoids the dependency and therefore the issue.*

A user of mine ran into an issue while trying to use Grape to load a recent version of the elasticsearch-groovy jar. I was able to reproduce in different versions of Groovy.

{code}
@Grapes(
     @Grab(group='org.elasticsearch', module='elasticsearch-groovy', version='1.7.1')
)
import java.lang.String
{code}

Literally that code when launched via:

{code}
$ groovy file.groovy
Caught: BUG! exception in phase 'conversion' in source unit '/Users/pickypg/Dev/es/es-groovy/tmp/elasticsearch.groovy' # Licensed to the Apache Software Foundation (ASF) under one or more
BUG! exception in phase 'conversion' in source unit '/Users/pickypg/Dev/es/es-groovy/tmp/elasticsearch.groovy' # Licensed to the Apache Software Foundation (ASF) under one or more
Caused by: java.lang.ClassNotFoundException: # Licensed to the Apache Software Foundation (ASF) under one or more
{code}

Using this code:

{code}
import groovy.grape.Grape

try {
  Grape.grab(group: 'org.elasticsearch', module: 'elasticsearch-groovy', version: '1.7.1')
}
catch (Throwable t) {
  t.printStackTrace()
}
{code}

This creates a surprising stacktrace:

{code}
java.lang.ClassNotFoundException: # Licensed to the Apache Software Foundation (ASF) under one or more
	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:677)
	at groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:425)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:787)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:775)
	at groovy.lang.GroovyClassLoader$loadClass.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at groovy.grape.GrapeIvy$_processRunners_closure4.doCall(GrapeIvy.groovy:340)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:294)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1019)
	at groovy.lang.Closure.call(Closure.java:426)
	at groovy.lang.Closure.call(Closure.java:442)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:2030)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:2015)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:2056)
	at org.codehaus.groovy.runtime.dgm$162.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:274)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:56)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at groovy.grape.GrapeIvy.processRunners(GrapeIvy.groovy:339)
	at groovy.grape.GrapeIvy$processRunners$3.callCurrent(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:182)
	at groovy.grape.GrapeIvy.processOtherServices(GrapeIvy.groovy:324)
	at groovy.grape.GrapeIvy$processOtherServices$2.callCurrent(Unknown Source)
	at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:265)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:169)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:174)
	at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:239)
	at groovy.grape.Grape.grab(Grape.java:151)
	at groovy.grape.Grape$grab.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at elasticsearch.run(elasticsearch.groovy:4)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:263)
	at groovy.lang.GroovyShell.run(GroovyShell.java:524)
	at groovy.lang.GroovyShell.run(GroovyShell.java:513)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:652)
	at groovy.ui.GroovyMain.run(GroovyMain.java:384)
	at groovy.ui.GroovyMain.process(GroovyMain.java:370)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:129)
	at groovy.ui.GroovyMain.main(GroovyMain.java:109)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131)
{code}",OS X 10.10.5,ascheman,kdabir,paulk,pickypg,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7833,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 26 10:44:40 UTC 2016,,,,,,,,,,"0|i2mg5z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Oct/15 07:45;ascheman;Ran into the same problem and yes, an exclude solves it:
{code}
@GrabExclude('org.codehaus.groovy:groovy-all')
{code}

Nevertheless I would like to see the issue solved since I would not like to care about the transitive dependencies of a used artifact. ;;;","26/Jun/16 10:44;paulk;I believe this was fixed as part of GROOVY-7833;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Null safe is call throws VerifyError when used as condition with CompileStatic,GROOVY-7610,12901216,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,shils,shils,29/Sep/15 04:31,22/Feb/16 20:48,14/Jul/23 06:01,07/Oct/15 19:22,2.4.4,2.4.5,,,,,,,,,,,,,,,,2.4.6,,,,Static compilation,,,,0,,,,,,,"Here's an example:

{code}
import groovy.transform.CompileStatic

@CompileStatic
class A {
    void ifCondition(Object x, Object y) {
        if (x?.is(y))
            return
    }

    void ternaryCondition(Object x, Object y) {
          x?.is(y) ? 'foo' : 'bar'
    }
}
new A()
{code}

The above code throws the following error:

{code}
java.lang.VerifyError: (class: A, method: ternaryCondition signature (Ljava/lang/Object;Ljava/lang/Object;)V) Expecting to find object/array on stack
{code}

This appears to be caused by the ?.is call expression being transformed to a CompareIdentityExpression, which is semantically different.","OS X 10.10, JDK 1.8.0_60
",githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 07 19:17:09 UTC 2015,,,,,,,,,,"0|i2me1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Sep/15 04:55;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/123

    GROOVY-7610 Null safe is calls throw VerifyError when used as conditi…

    …on with CompileStatic
    
    * Null safe .is method call expressions were being transformed to CompareIdentityExpressions

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7610

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/123.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #123
    
----
commit bb2a18b500183999bb3dd9cc57977272d93dc71c
Author: Shil S <shil.sinha@gmail.com>
Date:   2015-09-29T04:53:21Z

    GROOVY-7610 Null safe is calls throw VerifyError when used as condition with CompileStatic
    * Null safe .is method call expressions were being transformed to CompareIdentityExpressions

----
;;;","29/Sep/15 13:57;shils;The problem is explicit in the bytecode:

{code}
 L0
    LINENUMBER 6 L0
    ALOAD 1
    ALOAD 2
    IF_ACMPNE L1
    ICONST_1
    GOTO L2
   L1
    ICONST_0
   L2
    DUP
    IFNONNULL L3
    POP
    ICONST_0
    GOTO L4
{code}

The IFNONNULL instruction expects a reference but sees an int. ;;;","07/Oct/15 19:17;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/123
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.VerifyError when initializing object of inner class within the constructor of its containing class,GROOVY-7609,12901119,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mjolnir11,mjolnir11,28/Sep/15 19:38,25/Feb/22 19:16,14/Jul/23 06:01,31/Oct/19 12:05,2.4.3,,,,,,,,,,,,,,,,,2.5.16,3.0.0-rc-1,,,,,,,1,usertask,,,,,,"When trying to initialize an object of an inner class, from the constructor of it's containing class, a java.lang.VerifyError is thrown. This code worked fine in Java, but when I switched to Groovy, it throws the VerifyError.

Stacktrace:

java.lang.VerifyError: (class: page_objects/Login$LoginNavigationBar$ExploreDestinationsDropdown, method: <init> signature: (Lpage_objects/Login$LoginNavigationBar;)V) Expecting to find object/array on stack
	at java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2671)
	at java.lang.Class.getDeclaredConstructors(Class.java:2020)
	at org.codehaus.groovy.reflection.CachedClass$2$1.run(CachedClass.java:71)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.codehaus.groovy.reflection.CachedClass$2.initValue(CachedClass.java:69)
	at org.codehaus.groovy.reflection.CachedClass$2.initValue(CachedClass.java:66)
	at org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:46)
	at org.codehaus.groovy.util.LazyReference.get(LazyReference.java:33)
	at org.codehaus.groovy.reflection.CachedClass.getConstructors(CachedClass.java:265)
	at groovy.lang.MetaClassImpl.<init>(MetaClassImpl.java:215)
	at groovy.lang.MetaClassImpl.<init>(MetaClassImpl.java:225)
	at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createNormalMetaClass(MetaClassRegistry.java:168)
	at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createWithCustomLookup(MetaClassRegistry.java:158)
	at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.create(MetaClassRegistry.java:141)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:250)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:282)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:255)
	at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:872)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallConstructorSite(CallSiteArray.java:84)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:232)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:244)
	at page_objects.Login$LoginNavigationBar.<init>(Login.groovy:173)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:422)
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
	at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:232)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:244)
	at page_objects.Login.<init>(Login.groovy:25)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:422)
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
	at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:232)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:244)
	at test_classes.BaseTest.beforeMethod(BaseTest.groovy:74)
	at test_classes.UseMyWeekTest.super$2$beforeMethod(UseMyWeekTest.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1207)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:130)
	at test_classes.UseMyWeekTest.beforeMethod(UseMyWeekTest.groovy:24)


Offending Code:

{code}
class LoginNavigationBar
    {
        ExploreDestinationsDropdown exploreDestinationsDropdown

        private LoginNavigationBar()
        {
            // THIS IS THE LINE THAT PRODUCES THE ERROR
            exploreDestinationsDropdown = new ExploreDestinationsDropdown() 
        }

        class ExploreDestinationsDropdown extends NavigationBarDropdown<ExploreDestinationsDropdown>
        {
            private ExploreDestinationsDropdown()
            {
                super(Login.this.sw, 0)
            }
        }
}
{code}

It also may be useful to know that LoginNavigationBar itself is an inner class of Login. So ExploreDestinationsDropwown is an inner class of an inner class. Also, the constructor for LoginNavigationBar is being called from the constructor of Login, the enclosing class.",,mjolnir11,pascalschumacher,paulk,werickson,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6809,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 01 01:44:57 UTC 2016,,,,,,,,,,"0|i2mdgf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Oct/15 18:01;pascalschumacher;[~mjolnir11] Can you post a small, self-contained example, so that we can reproduce this? Thanks!;;;","01/Sep/16 00:40;werickson;I get the same error on Groovy v2.4.6 with the below code snippet:
{code:java}
import java.util.concurrent.ThreadFactory

class A {
    public A() {
        this(new ThreadFactory() {
            @Override
            public Thread newThread(final Runnable runnable) {
                return null
            }
        })
    }

    private A(final ThreadFactory factory) {
    }
}

final foo = new A()
{code}

{code}
Caught: java.lang.VerifyError: (class: A, method: <init> signature: ()V) Expecting to find object/array on stack
java.lang.VerifyError: (class: A, method: <init> signature: ()V) Expecting to find object/array on stack
	at foo.run(foo.groovy:18)
{code};;;","01/Sep/16 01:44;paulk;possible duplicate of GROOVY-6809;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Comparison of decimal subclasses of Number with == fails,GROOVY-7608,12896738,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,msgilligan,msgilligan,28/Sep/15 08:57,02/May/17 02:03,14/Jul/23 06:01,26/Jul/16 11:34,2.4.4,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,groovy-runtime,,,,1,,,,,,,"If I create a subclass of {{Number}} that is implemented internally with a decimal value, e.g. using a {{BigDecimal}} even if I implement {{compareTo()}}, Groovy will convert my numbers to {{Integer}} before comparison.

{code}
given:
def one = MyNumberSubclass.of(1)
def oneptone = MyNumberSubclass.of(1.1)

then:
one == onptone          // passes when it shouldn't!
oneptone == oneptone    // fails when it shouldn't!
{code}

This is a critical issue for anyone creating a DSL that has custom numeric types (e.g. for currency handling) and wants to compare them with {{==}}.

Specifically this problem occurs with implementations of {{NumberValue}} in JSR354 aka *JavaMoney*.

I can provide some test cases for this if needed and am interesting in working to contribute a fix.",,msgilligan,pascalschumacher,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7636,,,,GROOVY-2756,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 26 11:34:06 UTC 2016,,,,,,,,,,"0|i2lmev:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Sep/15 09:25;msgilligan;Perhaps this issue will have to wait for 3.0 for a fix, though I'm hoping it can be fixed in 2.5 or a possible 2.6 and would be willing to help with a fix.
;;;","15/Nov/15 09:59;pascalschumacher;Not sure, but it looks like this [pull request|https://github.com/apache/incubator-groovy/pull/151] would solve this issue.;;;","25/Jul/16 10:08;paulk;If you could check whether the fix for GROOVY-7636 also fixes your issue, that would be great.;;;","25/Jul/16 18:07;msgilligan;Great news! I'll check it soon. I believe I wrote some unit tests for this issue -- I'll see if I can find them.
;;;","26/Jul/16 09:03;msgilligan;`master` doesn't seem to build for me. Is there a binary I can test?
;;;","26/Jul/16 09:31;paulk;You could try the CI server:
http://ci.groovy-lang.org/repository/download/Groovy_Jdk7Build/34486:id/target/distributions/apache-groovy-binary-2.5.0-SNAPSHOT.zip

If the link expires in the meantime just work your way down from the top again and click on one of the artifact links.

Out of interest, what errors do you get on master? I get three failing errors on some systems which have only started recently. Just wondering whether you have the same issues.;;;","26/Jul/16 09:37;msgilligan;:performance:clean UP-TO-DATE
:copyResources
:ensureGrammars
Trying to override old definition of datatype antlr
[ant:antlr] ANTLR Parser Generator   Version 2.7.7 (20060906)   1989-2005
[ant:antlr] ANTLR Parser Generator   Version 2.7.7 (20060906)   1989-2005
[ant:antlr] /Users/sean/git/groovy/src/main/org/codehaus/groovy/antlr/java/java.g:1017: warning:Syntactic predicate superfluous for single alternative
[ant:antlr] /Users/sean/git/groovy/src/main/org/codehaus/groovy/antlr/java/java.g:1488: warning:empty alternative makes no sense in (...)* or (...)+

FAILURE: Build failed with an exception.

* What went wrong:
java.lang.NullPointerException (no error message)

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED
;;;","26/Jul/16 09:47;msgilligan;And before that I saw this:


:testExtensionModuleJar
:test

org.codehaus.groovy.runtime.m12n.ExtensionModuleTest > testThatModuleCanBeLoadedWithGrab FAILED
    java.lang.RuntimeException: JUnit version 4.12
    .E
    Time: 3.91
    There was 1 failure:
    1) testCode(TempTest)
    java.lang.ExceptionInInitializerError
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
        at org.codehaus.groovy.runtime.InvokerHelper.createScript(InvokerHelper.java:429)
        at groovy.lang.GroovyShell.parse(GroovyShell.java:700)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:584)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:623)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:604)
        at groovy.test.GroovyAssert.assertScript(GroovyAssert.java:83)
        at groovy.util.GroovyTestCase.assertScript(GroovyTestCase.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrap.invoke(PogoMetaMethodSite.java:190)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:166)
        at TempTest.testCode(Temp.groovy:15)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at junit.framework.TestCase.runTest(TestCase.java:176)
        at junit.framework.TestCase.runBare(TestCase.java:141)
        at junit.framework.TestResult$1.protect(TestResult.java:122)
        at junit.framework.TestResult.runProtected(TestResult.java:142)
        at junit.framework.TestResult.run(TestResult.java:125)
        at junit.framework.TestCase.run(TestCase.java:129)
        at junit.framework.TestSuite.runTest(TestSuite.java:252)
        at junit.framework.TestSuite.run(TestSuite.java:247)
        at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)
        at org.junit.runners.Suite.runChild(Suite.java:128)
        at org.junit.runners.Suite.runChild(Suite.java:27)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
        at org.junit.runner.JUnitCore.runMain(JUnitCore.java:77)
        at org.junit.runner.JUnitCore.main(JUnitCore.java:36)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.invoke(StaticMetaMethodSite.java:46)
        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.call(StaticMetaMethodSite.java:91)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
        at Temp.run(Temp.groovy:34)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1212)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1021)
        at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:923)
        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:906)
        at org.codehaus.groovy.runtime.InvokerHelper.runScript(InvokerHelper.java:410)
        at org.codehaus.groovy.runtime.InvokerHelper$runScript.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
        at Temp.main(Temp.groovy)
    Caused by: java.lang.RuntimeException: Error grabbing Grapes -- [download failed: module-test#module-test;1.3!module-test.jar]
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
        at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:83)
        at org.codehaus.groovy.reflection.CachedConstructor.doConstructorInvoke(CachedConstructor.java:77)
        at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrap.callConstructor(ConstructorSite.java:84)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:60)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:235)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:247)
        at groovy.grape.GrapeIvy.getDependencies(GrapeIvy.groovy:427)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:169)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:64)
        at groovy.grape.GrapeIvy.resolve(GrapeIvy.groovy:574)
        at groovy.grape.GrapeIvy$resolve$1.callCurrent(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at groovy.grape.GrapeIvy$resolve$1.callCurrent(Unknown Source)
        at groovy.grape.GrapeIvy.resolve(GrapeIvy.groovy:541)
        at groovy.grape.GrapeIvy$resolve$0.callCurrent(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at groovy.grape.GrapeIvy$resolve$0.callCurrent(Unknown Source)
        at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:259)
        at groovy.grape.Grape.grab(Grape.java:167)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.invoke(StaticMetaMethodSite.java:46)
        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.callStatic(StaticMetaMethodSite.java:102)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallStatic(CallSiteArray.java:56)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:194)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:214)
        at TestScript0.<clinit>(TestScript0.groovy)
        ... 74 more

    FAILURES!!!
    Tests run: 1,  Failures: 1

    Classpath: /Users/sean/.gradle/caches/modules-2/files-2.1/org.slf4j/jcl-over-slf4j/1.7.21/331b564a3a42f002a0004b039c1c430da89062cd/jcl-over-slf4j-1.7.21.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/jmock/jmock-cglib/1.2.0/e6c89652fe2ff12f4dc53b42dce019643307782c/jmock-cglib-1.2.0.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-classic/1.1.7/9865cf6994f9ff13fce0bf93f2054ef6c65bb462/logback-classic-1.1.7.jar
    /Users/sean/git/groovy/target/resources/main
    /Users/sean/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-core/1.1.7/7873092d39ef741575ca91378a6a21c388363ac8/logback-core-1.1.7.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.ant/ant/1.9.7/3b2a10512ee6537d3852c9b693a0284dcab5de68/ant-1.9.7.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/log4j/log4j/1.2.17/5af35056b4d257e4b64b9e8069c0746e8b08629f/log4j-1.2.17.jar
    /Users/sean/git/groovy/subprojects/groovy-test/target/libs/groovy-test-2.5.0-SNAPSHOT.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm-util/6.0_ALPHA/1407895182c8542f7262cea2d8a26fe3b35690dd/asm-util-6.0_ALPHA.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/xmlunit/xmlunit/1.6/adcae0aff916681dacd2b490e193f1119cd964a9/xmlunit-1.6.jar
    /Users/sean/git/groovy/subprojects/groovy-groovydoc/target/libs/groovy-groovydoc-2.5.0-SNAPSHOT.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/antlr/antlr/2.7.7/83cd2cd674a217ade95a4bb83a8a14f351f48bd0/antlr-2.7.7.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm/6.0_ALPHA/ceaedaebaf6b74e9092959285fbc66cfbc03e43b/asm-6.0_ALPHA.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/com.thoughtworks.xstream/xstream/1.4.9/c43f6e6bfa79b56e04a8898a923c3cf7144dd460/xstream-1.4.9.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.slf4j/slf4j-api/1.7.21/139535a69a4239db087de9bab0bee568bf8e0b70/slf4j-api-1.7.21.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/com.thoughtworks.qdox/qdox/1.12.1/f7122f6ab1f64bdf9f5970b0e89bfb355e036897/qdox-1.12.1.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.codehaus.jsr166-mirror/jsr166y/1.7.0/8547fcb1c29b4f8c745c3f49a536aca58fc30f54/jsr166y-1.7.0.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.ivy/ivy/2.4.0/5abe4c24bbe992a9ac07ca563d5bd3e8d569e9ed/ivy-2.4.0.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.logging.log4j/log4j-api/2.3/8d85ef2675d1b45fe78adad021f809bdf12f2eeb/log4j-api-2.3.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/cglib/cglib-nodep/2.1_3/58d3be5953547c0019e5704d6ed4ffda3b0c7c66/cglib-nodep-2.1_3.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.multiverse/multiverse-core/0.7.0/db77d55199bc5672f05f5d725b70dd10033251ed/multiverse-core-0.7.0.jar
    /Users/sean/git/groovy/target/generated-classes
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar
    /Users/sean/git/groovy/target/classes/test
    /Users/sean/.gradle/caches/modules-2/files-2.1/commons-cli/commons-cli/1.3.1/1303efbc4b181e5a58bf2e967dc156a3132b97c0/commons-cli-1.3.1.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm-analysis/6.0_ALPHA/41176e58e57e6bee25d5e27a59ad6eaacce0d9c/asm-analysis-6.0_ALPHA.jar
    /Users/sean/git/groovy/subprojects/groovy-templates/target/libs/groovy-templates-2.5.0-SNAPSHOT.jar
    /Users/sean/git/groovy/src/test
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm-tree/6.0_ALPHA/1508b4754e3adbe1b67994dce2d94aba90ed1a9/asm-tree-6.0_ALPHA.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.logging.log4j/log4j-core/2.3/58a3e964db5307e30650817c5daac1e8c8ede648/log4j-core-2.3.jar
    /Users/sean/git/groovy/subprojects/groovy-xml/target/libs/groovy-xml-2.5.0-SNAPSHOT.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.ant/ant-launcher/1.9.7/224857a490283e72da13ffe3082dea62c558ec76/ant-launcher-1.9.7.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm-commons/6.0_ALPHA/ba211aef085e25e36678c4f93ddb44bdad93bc33/asm-commons-6.0_ALPHA.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.fusesource.jansi/jansi/1.11/655c643309c2f45a56a747fda70e3fadf57e9f11/jansi-1.11.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/jmock/jmock/1.2.0/75abbeef5da158e2a9275c0d5203f3c9b28d6bd3/jmock-1.2.0.jar
    /Users/sean/git/groovy/target/resources/test
    /Users/sean/git/groovy/target/testFixtures/extmodule/repo
    /Users/sean/git/groovy/target/libs/groovy-2.5.0-SNAPSHOT.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.codehaus.gpars/gpars/1.2.1/c3ea0fbcd67a163bd5e3a3efdaa3428262d0d437/gpars-1.2.1.jar
    /var/folders/6d/12xt4b4m8xjf3t0059_w18bh0000gn/T/groovy-generated-1708883340220225010-tmpdir
    /Users/sean/.gradle/caches/modules-2/files-2.1/com.googlecode/openbeans/1.0/c41a1082d08676a42c780dc77335afb636be113c/openbeans-1.0.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/junit/junit/4.12/2973d150c0dc1fefe998f834810d68f278ea58ec/junit-4.12.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.ant/ant-antlr/1.9.7/9140cf4ecb8c847fa3d1679914444a3b42b4b9c1/ant-antlr-1.9.7.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.ant/ant-junit/1.9.7/12629dc0fe3bc89199f83c1cbf7f844f2d0801de/ant-junit-1.9.7.jar
    /Users/sean/git/groovy/target/classes/main
    /Users/sean/git/groovy/subprojects/groovy-ant/target/libs/groovy-ant-2.5.0-SNAPSHOT.jar
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
        at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:83)
        at org.codehaus.groovy.reflection.CachedConstructor.doConstructorInvoke(CachedConstructor.java:77)
        at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrap.callConstructor(ConstructorSite.java:84)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:60)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:235)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:247)
        at org.codehaus.groovy.runtime.m12n.ExtensionModuleHelperForTests.doInFork(ExtensionModuleHelperForTests.groovy:75)
        at org.codehaus.groovy.runtime.m12n.ExtensionModuleHelperForTests.doInFork(ExtensionModuleHelperForTests.groovy:26)
        at org.codehaus.groovy.runtime.m12n.ExtensionModuleHelperForTests$doInFork.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
        at org.codehaus.groovy.runtime.m12n.ExtensionModuleTest.testThatModuleCanBeLoadedWithGrab(ExtensionModuleTest.groovy:41)

org.codehaus.groovy.runtime.m12n.ExtensionModuleTest > testExtensionModuleUsingGrabAndClosure FAILED
    java.lang.RuntimeException: JUnit version 4.12
    .E
    Time: 1.919
    There was 1 failure:
    1) testCode(TempTest)
    org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
    General error during conversion: Error grabbing Grapes -- [download failed: module-test#module-test;1.3!module-test.jar]

    java.lang.RuntimeException: Error grabbing Grapes -- [download failed: module-test#module-test;1.3!module-test.jar]
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
        at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:83)
        at org.codehaus.groovy.reflection.CachedConstructor.doConstructorInvoke(CachedConstructor.java:77)
        at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrap.callConstructor(ConstructorSite.java:84)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:60)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:235)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:247)
        at groovy.grape.GrapeIvy.getDependencies(GrapeIvy.groovy:427)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:169)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
        at groovy.grape.GrapeIvy.resolve(GrapeIvy.groovy:574)
        at groovy.grape.GrapeIvy$resolve$1.callCurrent(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:190)
        at groovy.grape.GrapeIvy.resolve(GrapeIvy.groovy:541)
        at groovy.grape.GrapeIvy$resolve$0.callCurrent(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:182)
        at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:259)
        at groovy.grape.Grape.grab(Grape.java:167)
        at groovy.grape.GrabAnnotationTransformation.visit(GrabAnnotationTransformation.java:377)
        at org.codehaus.groovy.transform.ASTTransformationVisitor$3.call(ASTTransformationVisitor.java:321)
        at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:948)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:615)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:591)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:568)
        at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
        at groovy.lang.GroovyShell.parseClass(GroovyShell.java:688)
        at groovy.lang.GroovyShell.parse(GroovyShell.java:700)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:584)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:623)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:604)
        at groovy.test.GroovyAssert.assertScript(GroovyAssert.java:83)
        at groovy.util.GroovyTestCase.assertScript(GroovyTestCase.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrap.invoke(PogoMetaMethodSite.java:190)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:166)
        at TempTest.testCode(Temp.groovy:13)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at junit.framework.TestCase.runTest(TestCase.java:176)
        at junit.framework.TestCase.runBare(TestCase.java:141)
        at junit.framework.TestResult$1.protect(TestResult.java:122)
        at junit.framework.TestResult.runProtected(TestResult.java:142)
        at junit.framework.TestResult.run(TestResult.java:125)
        at junit.framework.TestCase.run(TestCase.java:129)
        at junit.framework.TestSuite.runTest(TestSuite.java:252)
        at junit.framework.TestSuite.run(TestSuite.java:247)
        at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)
        at org.junit.runners.Suite.runChild(Suite.java:128)
        at org.junit.runners.Suite.runChild(Suite.java:27)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
        at org.junit.runner.JUnitCore.runMain(JUnitCore.java:77)
        at org.junit.runner.JUnitCore.main(JUnitCore.java:36)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.invoke(StaticMetaMethodSite.java:46)
        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.call(StaticMetaMethodSite.java:91)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
        at Temp.run(Temp.groovy:24)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1212)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1021)
        at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:923)
        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:906)
        at org.codehaus.groovy.runtime.InvokerHelper.runScript(InvokerHelper.java:410)
        at org.codehaus.groovy.runtime.InvokerHelper$runScript.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
        at Temp.main(Temp.groovy)

    1 error

        at org.codehaus.groovy.control.ErrorCollector.failIfErrors(ErrorCollector.java:310)
        at org.codehaus.groovy.control.ErrorCollector.addException(ErrorCollector.java:156)
        at org.codehaus.groovy.control.SourceUnit.addException(SourceUnit.java:335)
        at groovy.grape.GrabAnnotationTransformation.visit(GrabAnnotationTransformation.java:386)
        at org.codehaus.groovy.transform.ASTTransformationVisitor$3.call(ASTTransformationVisitor.java:321)
        at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:948)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:615)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:591)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:568)
        at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
        at groovy.lang.GroovyShell.parseClass(GroovyShell.java:688)
        at groovy.lang.GroovyShell.parse(GroovyShell.java:700)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:584)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:623)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:604)
        at groovy.test.GroovyAssert.assertScript(GroovyAssert.java:83)
        at groovy.util.GroovyTestCase.assertScript(GroovyTestCase.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrap.invoke(PogoMetaMethodSite.java:190)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:166)
        at TempTest.testCode(Temp.groovy:13)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at junit.framework.TestCase.runTest(TestCase.java:176)
        at junit.framework.TestCase.runBare(TestCase.java:141)
        at junit.framework.TestResult$1.protect(TestResult.java:122)
        at junit.framework.TestResult.runProtected(TestResult.java:142)
        at junit.framework.TestResult.run(TestResult.java:125)
        at junit.framework.TestCase.run(TestCase.java:129)
        at junit.framework.TestSuite.runTest(TestSuite.java:252)
        at junit.framework.TestSuite.run(TestSuite.java:247)
        at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)
        at org.junit.runners.Suite.runChild(Suite.java:128)
        at org.junit.runners.Suite.runChild(Suite.java:27)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
        at org.junit.runner.JUnitCore.runMain(JUnitCore.java:77)
        at org.junit.runner.JUnitCore.main(JUnitCore.java:36)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.invoke(StaticMetaMethodSite.java:46)
        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.call(StaticMetaMethodSite.java:91)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
        at Temp.run(Temp.groovy:24)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1212)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1021)
        at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:923)
        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:906)
        at org.codehaus.groovy.runtime.InvokerHelper.runScript(InvokerHelper.java:410)
        at org.codehaus.groovy.runtime.InvokerHelper$runScript.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
        at Temp.main(Temp.groovy)

    FAILURES!!!
    Tests run: 1,  Failures: 1

    Classpath: /Users/sean/.gradle/caches/modules-2/files-2.1/org.slf4j/jcl-over-slf4j/1.7.21/331b564a3a42f002a0004b039c1c430da89062cd/jcl-over-slf4j-1.7.21.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/jmock/jmock-cglib/1.2.0/e6c89652fe2ff12f4dc53b42dce019643307782c/jmock-cglib-1.2.0.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-classic/1.1.7/9865cf6994f9ff13fce0bf93f2054ef6c65bb462/logback-classic-1.1.7.jar
    /Users/sean/git/groovy/target/resources/main
    /Users/sean/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-core/1.1.7/7873092d39ef741575ca91378a6a21c388363ac8/logback-core-1.1.7.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.ant/ant/1.9.7/3b2a10512ee6537d3852c9b693a0284dcab5de68/ant-1.9.7.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/log4j/log4j/1.2.17/5af35056b4d257e4b64b9e8069c0746e8b08629f/log4j-1.2.17.jar
    /var/folders/6d/12xt4b4m8xjf3t0059_w18bh0000gn/T/groovy-generated-6814591926948245189-tmpdir
    /Users/sean/git/groovy/subprojects/groovy-test/target/libs/groovy-test-2.5.0-SNAPSHOT.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm-util/6.0_ALPHA/1407895182c8542f7262cea2d8a26fe3b35690dd/asm-util-6.0_ALPHA.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/xmlunit/xmlunit/1.6/adcae0aff916681dacd2b490e193f1119cd964a9/xmlunit-1.6.jar
    /Users/sean/git/groovy/subprojects/groovy-groovydoc/target/libs/groovy-groovydoc-2.5.0-SNAPSHOT.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/antlr/antlr/2.7.7/83cd2cd674a217ade95a4bb83a8a14f351f48bd0/antlr-2.7.7.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm/6.0_ALPHA/ceaedaebaf6b74e9092959285fbc66cfbc03e43b/asm-6.0_ALPHA.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/com.thoughtworks.xstream/xstream/1.4.9/c43f6e6bfa79b56e04a8898a923c3cf7144dd460/xstream-1.4.9.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.slf4j/slf4j-api/1.7.21/139535a69a4239db087de9bab0bee568bf8e0b70/slf4j-api-1.7.21.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/com.thoughtworks.qdox/qdox/1.12.1/f7122f6ab1f64bdf9f5970b0e89bfb355e036897/qdox-1.12.1.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.codehaus.jsr166-mirror/jsr166y/1.7.0/8547fcb1c29b4f8c745c3f49a536aca58fc30f54/jsr166y-1.7.0.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.ivy/ivy/2.4.0/5abe4c24bbe992a9ac07ca563d5bd3e8d569e9ed/ivy-2.4.0.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.logging.log4j/log4j-api/2.3/8d85ef2675d1b45fe78adad021f809bdf12f2eeb/log4j-api-2.3.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/cglib/cglib-nodep/2.1_3/58d3be5953547c0019e5704d6ed4ffda3b0c7c66/cglib-nodep-2.1_3.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.multiverse/multiverse-core/0.7.0/db77d55199bc5672f05f5d725b70dd10033251ed/multiverse-core-0.7.0.jar
    /Users/sean/git/groovy/target/generated-classes
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.hamcrest/hamcrest-core/1.3/42a25dc3219429f0e5d060061f71acb49bf010a0/hamcrest-core-1.3.jar
    /Users/sean/git/groovy/target/classes/test
    /Users/sean/.gradle/caches/modules-2/files-2.1/commons-cli/commons-cli/1.3.1/1303efbc4b181e5a58bf2e967dc156a3132b97c0/commons-cli-1.3.1.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm-analysis/6.0_ALPHA/41176e58e57e6bee25d5e27a59ad6eaacce0d9c/asm-analysis-6.0_ALPHA.jar
    /Users/sean/git/groovy/subprojects/groovy-templates/target/libs/groovy-templates-2.5.0-SNAPSHOT.jar
    /Users/sean/git/groovy/src/test
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm-tree/6.0_ALPHA/1508b4754e3adbe1b67994dce2d94aba90ed1a9/asm-tree-6.0_ALPHA.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.logging.log4j/log4j-core/2.3/58a3e964db5307e30650817c5daac1e8c8ede648/log4j-core-2.3.jar
    /Users/sean/git/groovy/subprojects/groovy-xml/target/libs/groovy-xml-2.5.0-SNAPSHOT.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.ant/ant-launcher/1.9.7/224857a490283e72da13ffe3082dea62c558ec76/ant-launcher-1.9.7.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.ow2.asm/asm-commons/6.0_ALPHA/ba211aef085e25e36678c4f93ddb44bdad93bc33/asm-commons-6.0_ALPHA.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.fusesource.jansi/jansi/1.11/655c643309c2f45a56a747fda70e3fadf57e9f11/jansi-1.11.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/jmock/jmock/1.2.0/75abbeef5da158e2a9275c0d5203f3c9b28d6bd3/jmock-1.2.0.jar
    /Users/sean/git/groovy/target/resources/test
    /Users/sean/git/groovy/target/testFixtures/extmodule/repo
    /Users/sean/git/groovy/target/libs/groovy-2.5.0-SNAPSHOT.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.codehaus.gpars/gpars/1.2.1/c3ea0fbcd67a163bd5e3a3efdaa3428262d0d437/gpars-1.2.1.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/com.googlecode/openbeans/1.0/c41a1082d08676a42c780dc77335afb636be113c/openbeans-1.0.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/junit/junit/4.12/2973d150c0dc1fefe998f834810d68f278ea58ec/junit-4.12.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.ant/ant-antlr/1.9.7/9140cf4ecb8c847fa3d1679914444a3b42b4b9c1/ant-antlr-1.9.7.jar
    /Users/sean/.gradle/caches/modules-2/files-2.1/org.apache.ant/ant-junit/1.9.7/12629dc0fe3bc89199f83c1cbf7f844f2d0801de/ant-junit-1.9.7.jar
    /Users/sean/git/groovy/target/classes/main
    /Users/sean/git/groovy/subprojects/groovy-ant/target/libs/groovy-ant-2.5.0-SNAPSHOT.jar
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
        at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:83)
        at org.codehaus.groovy.reflection.CachedConstructor.doConstructorInvoke(CachedConstructor.java:77)
        at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrap.callConstructor(ConstructorSite.java:84)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:247)
        at org.codehaus.groovy.runtime.m12n.ExtensionModuleHelperForTests.doInFork(ExtensionModuleHelperForTests.groovy:75)
        at org.codehaus.groovy.runtime.m12n.ExtensionModuleHelperForTests.doInFork(ExtensionModuleHelperForTests.groovy:26)
        at org.codehaus.groovy.runtime.m12n.ExtensionModuleHelperForTests$doInFork.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
        at org.codehaus.groovy.runtime.m12n.ExtensionModuleTest.testExtensionModuleUsingGrabAndClosure(ExtensionModuleTest.groovy:98)

org.codehaus.groovy.runtime.m12n.ExtensionModuleTest > testExtensionModuleUsingGrabAndMap FAILED
    java.lang.RuntimeException: JUnit version 4.12
    .E
    Time: 2.328
    There was 1 failure:
    1) testCode(TempTest)
    org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
    General error during conversion: Error grabbing Grapes -- [download failed: module-test#module-test;1.3!module-test.jar]

    java.lang.RuntimeException: Error grabbing Grapes -- [download failed: module-test#module-test;1.3!module-test.jar]
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
        at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:83)
        at org.codehaus.groovy.reflection.CachedConstructor.doConstructorInvoke(CachedConstructor.java:77)
        at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrap.callConstructor(ConstructorSite.java:84)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:60)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:235)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:247)
        at groovy.grape.GrapeIvy.getDependencies(GrapeIvy.groovy:427)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:169)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
        at groovy.grape.GrapeIvy.resolve(GrapeIvy.groovy:574)
        at groovy.grape.GrapeIvy$resolve$1.callCurrent(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:190)
        at groovy.grape.GrapeIvy.resolve(GrapeIvy.groovy:541)
        at groovy.grape.GrapeIvy$resolve$0.callCurrent(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:182)
        at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:259)
        at groovy.grape.Grape.grab(Grape.java:167)
        at groovy.grape.GrabAnnotationTransformation.visit(GrabAnnotationTransformation.java:377)
        at org.codehaus.groovy.transform.ASTTransformationVisitor$3.call(ASTTransformationVisitor.java:321)
        at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:948)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:615)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:591)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:568)
        at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
        at groovy.lang.GroovyShell.parseClass(GroovyShell.java:688)
        at groovy.lang.GroovyShell.parse(GroovyShell.java:700)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:584)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:623)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:604)
        at groovy.test.GroovyAssert.assertScript(GroovyAssert.java:83)
        at groovy.util.GroovyTestCase.assertScript(GroovyTestCase.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrap.invoke(PogoMetaMethodSite.java:190)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:166)
        at TempTest.testCode(Temp.groovy:15)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at junit.framework.TestCase.runTest(TestCase.java:176)
        at junit.framework.TestCase.runBare(TestCase.java:141)
        at junit.framework.TestResult$1.protect(TestResult.java:122)
        at junit.framework.TestResult.runProtected(TestResult.java:142)
        at junit.framework.TestResult.run(TestResult.java:125)
        at junit.framework.TestCase.run(TestCase.java:129)
        at junit.framework.TestSuite.runTest(TestSuite.java:252)
        at junit.framework.TestSuite.run(TestSuite.java:247)
        at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)
        at org.junit.runners.Suite.runChild(Suite.java:128)
        at org.junit.runners.Suite.runChild(Suite.java:27)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
        at org.junit.runner.JUnitCore.runMain(JUnitCore.java:77)
        at org.junit.runner.JUnitCore.main(JUnitCore.java:36)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.invoke(StaticMetaMethodSite.java:46)
        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.call(StaticMetaMethodSite.java:91)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
        at Temp.run(Temp.groovy:26)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1212)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1021)
        at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:923)
        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:906)
        at org.codehaus.groovy.runtime.InvokerHelper.runScript(InvokerHelper.java:410)
        at org.codehaus.groovy.runtime.InvokerHelper$runScript.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
        at Temp.main(Temp.groovy)

    1 error

        at org.codehaus.groovy.control.ErrorCollector.failIfErrors(ErrorCollector.java:310)
        at org.codehaus.groovy.control.ErrorCollector.addException(ErrorCollector.java:156)
        at org.codehaus.groovy.control.SourceUnit.addException(SourceUnit.java:335)
        at groovy.grape.GrabAnnotationTransformation.visit(GrabAnnotationTransformation.java:386)
        at org.codehaus.groovy.transform.ASTTransformationVisitor$3.call(ASTTransformationVisitor.java:321)
        at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:948)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:615)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:591)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:568)
        at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
        at groovy.lang.GroovyShell.parseClass(GroovyShell.java:688)
        at groovy.lang.GroovyShell.parse(GroovyShell.java:700)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:584)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:623)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:604)
        at groovy.test.GroovyAssert.assertScript(GroovyAssert.java:83)
        at groovy.util.GroovyTestCase.assertScript(GroovyTestCase.java:203)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrap.invoke(PogoMetaMethodSite.java:190)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:166)
        at TempTest.testCode(Temp.groovy:15)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at junit.framework.TestCase.runTest(TestCase.java:176)
        at junit.framework.TestCase.runBare(TestCase.java:141)
        at junit.framework.TestResult$1.protect(TestResult.java:122)
        at junit.framework.TestResult.runProtected(TestResult.java:142)
        at junit.framework.TestResult.run(TestResult.java:125)
        at junit.framework.TestCase.run(TestCase.java:129)
        at junit.framework.TestSuite.runTest(TestSuite.java:252)
        at junit.framework.TestSuite.run(TestSuite.java:247)
        at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)
        at org.junit.runners.Suite.runChild(Suite.java:128)
        at org.junit.runners.Suite.runChild(Suite.java:27)
        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
        at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
        at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
        at org.junit.runner.JUnitCore.runMain(JUnitCore.java:77)
        at org.junit.runner.JUnitCore.main(JUnitCore.java:36)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.invoke(StaticMetaMethodSite.java:46)
        at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.call(StaticMetaMethodSite.java:91)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
        at Temp.run(Temp.groovy:26)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1212)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1021)
        at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:923)
        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:906)
        at org.codehaus.groovy.runtime.InvokerHelper.runScript(InvokerHelper.java:410)
        at org.codehaus.groovy.runtime.InvokerHelper$runScript.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
        at Temp.main(Temp.groovy)

    FAILURES!!!
    Tests run: 1,  Failures: 1

    Classpath: /Users/sean/.gradle/caches/modules-2/files-2.1/org.slf4j/jcl-over-slf4j/1.7.21/331b564a3a42f002a0004b039c1c430da89062cd/jcl-over-slf4j-1.7.21.jar
;;;","26/Jul/16 10:20;paulk;That looks a little weird but vaguely familiar from some time ago. Does cleaning the gradle caches help? Are you on Java 9?;;;","26/Jul/16 10:34;msgilligan;java -version
java version ""1.8.0_91""
Java(TM) SE Runtime Environment (build 1.8.0_91-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)

Cleaning caches doesn't seem to help.
;;;","26/Jul/16 11:34;paulk;Fixed by GROOVY-7636;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Intersect returns an empty list when the contents of the compared Collections are Maps,GROOVY-7602,12895938,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jguertin-gls,jguertin-gls,23/Sep/15 22:46,12/Jun/16 08:45,14/Jul/23 06:01,03/Mar/16 12:27,2.3.11,2.4.5,,,,,,,,,,,,,,,,2.4.7,,,,groovy-jdk,,,,0,,,,,,,"When I compare two lists with intersect and both lists contain maps I do not get any results, even if the contents are equivalent. The test fails in Groovy 2.3.11, but passes in 2.3.7.

{code}
import org.junit.Test

class IntersectTest {
    @Test
    void testIntersect() {
        def list1 = [[language: 'Java'], [language: 'Groovy'], [language: 'Scala']]
        def list2 = [[language: 'Groovy'], [language: 'JRuby'], [language: 'Java']]
        def intersection = list1.intersect(list2)

        assert list1[0] == list2[2] // proves that there should be intersecting values
        println ""Intersection: $intersection""
        assert intersection == [[language: 'Groovy'], [language: 'Java']]
    }
}
{code}

The intersect call returns an empty list in 2.3.11, resulting in the following output:
{code}
Intersection: []

Assertion failed: 

assert intersection == [[language: 'Groovy'], [language: 'Java']]
       |            |
       []           false
{code}","Mac OS X 10.9.5
Oracle Java 1.8.0_60",jguertin-gls,lari.hotari@sagire.fi,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7530,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,https://github.com/grails/grails-core/issues/9281,,,,,,,,,,,9223372036854775807,,,Thu Mar 03 12:27:27 UTC 2016,,,,,,,,,,"0|i2lhhr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Sep/15 20:23;lari.hotari@sagire.fi;problem might be caused by https://github.com/apache/incubator-groovy/commit/4a5bb22d change (GROOVY-7267).;;;","02/Mar/16 08:23;paulk;possibly related to disjoint issue;;;","02/Mar/16 11:43;paulk;Should be fixed as part of GROOVY-7530 (PR#276);;;","03/Mar/16 12:27;paulk;merged above mentioned PR;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
type checking with generics,GROOVY-7598,12895503,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,jechlin,jechlin,22/Sep/15 16:24,23/Feb/16 16:29,14/Jul/23 06:01,07/Oct/15 19:23,2.4.4,,,,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,,,,,,,"The following compiles without error... I don't think it should:

{code}
import groovy.transform.TypeChecked

@TypeChecked
class C extends Script {

    @Override
    List<String> run() {
        [11, 12]
    }
}
{code}

What I would expect to see is:
Cannot return ArrayList<Integer> from method returning List<String>",,githubbot,jechlin,keegan,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7753,GROOVY-7763,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 07 19:17:09 UTC 2015,,,,,,,,,,"0|i2lesv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Oct/15 16:45;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/133

    GROOVY-7598 Generic types are not checked for return statements (STC)

    Though this is something I had assumed was already in place, it could be a breaking change given that I had to slightly modify a unit test.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7598

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/133.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #133
    
----
commit 64f7c59b8b2b45cd855831502b858850638049ea
Author: Shil S <shil.sinha@gmail.com>
Date:   2015-10-06T16:31:32Z

    GROOVY-7598 Generic types are not checked for return statements (STC)

----
;;;","07/Oct/15 19:17;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/133
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static Compiler tries to cast delegate to target type of property accessor,GROOVY-7597,12895218,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,gillius,gillius,21/Sep/15 18:54,22/Feb/16 20:48,14/Jul/23 06:01,07/Oct/15 19:23,2.4.3,2.4.4,,,,,,,,,,,,,,,,2.4.6,,,,Static compilation,Static Type Checker,,,1,,,,,,,"I've been able to finally isolate a static compiler issue with accessing properties on delegates that occur within our projects:

{code}
class Calculation {
  boolean isValid() { true }
}

class Entity {
  Calculation getCalculation(String name) { new Calculation() }
}

class Feature extends Entity {
}

void DoWithFeature(@DelegatesTo(Feature) Closure c) {
  new Feature().with(c)
}

@groovy.transform.CompileStatic
void doIt() {
  DoWithFeature() {
    println getCalculation(""whatever"").valid
  }
}

doIt()
{code}

The result is {{java.lang.ClassCastException: Feature cannot be cast to Calculation}}

Workarounds:
* change the property access into a method access ""valid"" -> ""isValid()""
* Remove CompileStatic annotation

As seen in the following bytecode, the static compiler tries to cast the delegate to Calculation (which always fails), then tries to call ScriptBytecodeAdapter.castToType to try to cast the ""Calculation"" back to an Entity to properly call getCalculation("""").isValid() on it.

{code}
  // access flags 0x1
  public doCall(Ljava/lang/Object;)Ljava/lang/Object;
   L0
    LINENUMBER 19 L0
    ALOAD 0
    CHECKCAST script1442861431462$_doIt_closure1
    INVOKEVIRTUAL script1442861431462$_doIt_closure1.getThisObject ()Ljava/lang/Object;
    LDC Lgroovy/lang/Script;.class
    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType (Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;
    CHECKCAST groovy/lang/Script
    ALOAD 0
    CHECKCAST script1442861431462$_doIt_closure1
    INVOKEVIRTUAL script1442861431462$_doIt_closure1.getDelegate ()Ljava/lang/Object;
    CHECKCAST Calculation
    LDC LEntity;.class
    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType (Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;
    CHECKCAST Entity
    LDC ""whatever""
    INVOKEVIRTUAL Entity.getCalculation (Ljava/lang/String;)LCalculation;
    INVOKEVIRTUAL Calculation.isValid ()Z
    INVOKESTATIC java/lang/Boolean.valueOf (Z)Ljava/lang/Boolean;
    INVOKEVIRTUAL groovy/lang/Script.println (Ljava/lang/Object;)V
    ACONST_NULL
    ARETURN
   L1
    ACONST_NULL
    ARETURN
    LOCALVARIABLE this Lscript1442861431462$_doIt_closure1; L0 L1 0
    LOCALVARIABLE it Ljava/lang/Object; L0 L1 1
    MAXSTACK = 3
    MAXLOCALS = 2
{code}
",,gillius,githubbot,shils,tkent,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7376,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 07 19:39:53 UTC 2015,,,,,,,,,,"0|i2ld1j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Oct/15 01:24;tkent;We just got hit with this bug moving a project from groovy 2.3.8 to 2.4.5. I think this ought to be a critical issue since it only shows up at runtime and the workarounds are not practical in many cases. 

Searching through Jira, it appears that both GROOVY-7558 and GROOVY-7376 are duplicate reports of this. Since the title of this issue covers the problem very succinctly, I vote for this being the reference issue.

If there is any interest in a unit test being added, I have one and I'm happy to send a pull request.;;;","04/Oct/15 04:24;shils;The problem seems to be in StaticInvocationWriter.tryImplicitReceiver, where the receiver of the {{getCalculation(""whatever"")}} call, implicitly {{this.delegate}}, has its INFERRED_TYPE metadata set to the PROPERTY_OWNER metadata of the getCalculation call. However, that metadata is set to {{Calculation}} earlier in StaticCompilationVisitor.existsProperty while visiting the .valid property expression. 

None of this causes the direct method call target to change, so the only strangeness that appears in the bytecode is the checkcast Calculation and the runtime cast to Entity (which should really be Feature) as you mentioned.

Another temporary workaround is to explicitly call delegate.getCalculation, in which case the checkcasts are for Feature and there are no runtime casts.;;;","04/Oct/15 21:16;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/126

    GROOVY-7597 Static compiler tries to cast delegate to target type of …

    …property accessor
    
    * Remove setting of INFERRED_TYPE metadata on synthetic property expression for implicit receiver

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7597

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/126.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #126
    
----
commit 8fed562b40c71881f2e0b145aa5a611c0fd37b9b
Author: Shil S <shil.sinha@gmail.com>
Date:   2015-10-04T19:11:40Z

    GROOVY-7597 Static compiler tries to cast delegate to target type of property accessor
    * Remove setting of INFERRED_TYPE metadata on synthetic property expression for implicit receiver

----
;;;","07/Oct/15 19:17;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/126
;;;","07/Oct/15 19:39;tkent;That's fantastic, thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
src/test/org/codehaus/groovy/ast/LineColumnCheck.txt file missing header in source release,GROOVY-7596,12895039,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,blackdrag,blackdrag,21/Sep/15 05:39,22/Feb/16 20:48,14/Jul/23 06:01,11/Oct/15 18:40,2.4.5,,,,,,,,,,,,,,,,,2.4.6,,,,release,,,,0,,,,,,,"The file src/test/org/codehaus/groovy/ast/LineColumnCheck.txt contains a header information in the repository, but not in the source distribution zip. Something is stripping the header",,blackdrag,pascalschumacher,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Oct 11 18:41:37 UTC 2015,,,,,,,,,,"0|i2lby7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Sep/15 01:59;paulk;So this was just the 2_4_X branch vs master difference and we can close? Or should we change to find out whether we need to delete the header in master?;;;","22/Sep/15 06:39;blackdrag;imho, if we can add the header in 2.4.x it would be better.;;;","11/Oct/15 18:41;pascalschumacher;added header in 2.4.x branch: [https://github.com/apache/incubator-groovy/commit/d496c069a2d36c1f9bd9351c95acda6b4093e2c0];;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
.@ continues to call setter inside closure,GROOVY-7595,12888561,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,tgsoverly,tgsoverly,18/Sep/15 13:53,08/Mar/22 12:16,14/Jul/23 06:01,19/Dec/21 16:09,2.4.4,2.4.5,,,,,,,,,,,,,,,,,,,,groovy-runtime,,,,0,StackOverflowError,,,,,,"I have a closure that wraps updates to an object:

{code:java}
setFoo(Foo foo){
   doUpdate {
	this.@foo = foo
   }
}
{code}

This causes a stack overflow because it keeps recursively calling setFoo.

I have tried:
1. making foo private/public
2. owner.@foo
3. delegate.@foo

Notes:
1. This does not cause this overflow in 2.3.x
2. The setFoo is part of an interface
3. Class is @CompileStatic
4. It being in a closure may/may not affect it",@CompileStatic,tgsoverly,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-09-18 13:53:13.0,,,,,,,,,,"0|i2l4cv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy 2.2 and 2.4 all fail to execute almost any script with Java 9 JIGSAW preview builds,GROOVY-7587,12863103,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,uschindler,uschindler,10/Sep/15 16:16,22/Feb/16 20:48,14/Jul/23 06:01,02/Nov/15 12:44,2.2.2,2.4.4,,,,,,,,,,,,,,,,2.4.6,,,,groovy-runtime,,,,1,Java9,,,,,,"The Lucene project successfully made their code running with the recently announced preview builds of Java 9. Unfortunately some parts of Lucene's build script and also the build of the Policeman's ForbiddenAPI checker (https://github.com/policeman-tools/forbidden-apis/) use groovy to execute some stuff that does not work with plain Ant. Similar issues are seen by Elasticsearch's scripting support plugin.

Unfortunately even simple scripts fail quite often. The issue always looks like this:

{code:java}
def temp = ClassLoader.getSystemClassLoader()
temp.toString()
{code}

{noformat}
java.lang.reflect.InaccessibleObjectException: Unable to make member of class jdk.internal.misc.ClassLoaders$AppClassLoader accessible:  module java.base does not export jdk.internal.misc to <unnamed module @1a6f5124>
        at sun.reflect.Reflection.throwInaccessibleObjectException(java.base@9.0/Reflection.java:462)
        at java.lang.reflect.AccessibleObject.checkCanSetAccessible(java.base@9.0/AccessibleObject.java:194)
        at java.lang.reflect.AccessibleObject.setAccessible(java.base@9.0/AccessibleObject.java:157)
        at org.codehaus.groovy.reflection.CachedConstructor$1.run(CachedConstructor.java:44)
        at java.security.AccessController.doPrivileged(java.base@9.0/Native Method)
        at org.codehaus.groovy.reflection.CachedConstructor.<init>(CachedConstructor.java:42)
        at org.codehaus.groovy.reflection.CachedClass$2.initValue(CachedClass.java:79)
        at org.codehaus.groovy.reflection.CachedClass$2.initValue(CachedClass.java:69)
        at org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:49)
        at org.codehaus.groovy.util.LazyReference.get(LazyReference.java:36)
        at org.codehaus.groovy.reflection.CachedClass.getConstructors(CachedClass.java:268)
        at groovy.lang.MetaClassImpl.<init>(MetaClassImpl.java:218)
        at groovy.lang.MetaClassImpl.<init>(MetaClassImpl.java:228)
        at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createNormalMetaClass(MetaClassRegistry.java:171)
        at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createWithCustomLookup(MetaClassRegistry.java:161)
        at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.create(MetaClassRegistry.java:144)
        at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:253)
        at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:285)
        at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:295)
        at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:261)
        at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:871)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.createPojoSite(CallSiteArray.java:125)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:166)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
        at generate-deprecated.run(generate-deprecated.groovy:20)
        at org.codehaus.groovy.ant.Groovy.parseAndRunScript(Groovy.java:501)
        at org.codehaus.groovy.ant.Groovy.execGroovy(Groovy.java:448)
        at org.codehaus.groovy.ant.Groovy.execute(Groovy.java:313)
{noformat}

This always happens under the following circumstances. You have a public Object accessible from everywhere in the JDK. This object is working like a factory and creates an implementation of an abstract class. In the above example this is a classloader (abstract class). This returned instance is of course some JDK-internal class and the user code is intended to only call the visible methods on it.

Unfortunately groovy tries in the second line to create a metaclass to get ""full insight"" of this internal class. For that it tries to make everything accessible. And with Java 9 including JIGSAW this is no longer possible. You can use the APIs provided by the internal implementation, but you are not allowed to do any non-public stuff. This is disallowed by the Java module system and there is no way around (unless you disable the module system completely, which will not work in all cases in Java 9 once it is released).","java version ""1.9.0-ea""
Java(TM) SE Runtime Environment (build 1.9.0-ea-jigsaw-nightly-h3337-20150908-b80)
Java HotSpot(TM) 64-Bit Server VM (build 1.9.0-ea-jigsaw-nightly-h3337-20150908-b80, mixed mode)",bclozel,blackdrag,Don-vip,mandy.chung@oracle.com,rjernst,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 02 12:49:49 UTC 2015,,,,,,,,,,"0|i2k07b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Sep/15 16:43;uschindler;Other simple examples:

{code:java}
import java.nio.file.*;

def test = Paths.get('test.txt')
print test.toString()
{code}

Fails because the return value of Paths.get() is some internal class which cannot be reflected on:
java.lang.reflect.InaccessibleObjectException: Unable to make member of class sun.nio.fs.WindowsPath accessible:  module java.base does not export sun.nio.fs to <unnamed module @1a6f5124>

Same happens on Charset.defaultCharset(), Locale.getDefault(),... But also for non-static stuff, it just needs to be some factory-like method that returns an internal implementation of a public interface/class/....;;;","02/Nov/15 12:44;blackdrag;I added a work around that catches RuntimeException and then checks for the class jigsaw uses. This allows the provided scripts to run, though no test was added. ;;;","02/Nov/15 12:49;uschindler;Hi,
many thanks. Looks like the ideal workaround to fix this for now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovysh does not print the exception class,GROOVY-7586,12862449,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,tkruse,tkruse,08/Sep/15 15:23,19/Oct/15 16:05,14/Jul/23 06:01,08/Sep/15 18:15,2.4.4,,,,,,,,,,,,,,,,,2.4.5,,,,Groovysh,,,,0,,,,,,,"Caused by missing parentheses after ! in:
if (log.debug || ! cause instanceof CompilationFailedException) {",,githubbot,pascalschumacher,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 08 18:15:13 UTC 2015,,,,,,,,,,"0|i2jw87:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Sep/15 15:25;githubbot;GitHub user tkruse opened a pull request:

    https://github.com/apache/incubator-groovy/pull/116

    GROOVY-7586: Groovysh: print Exception class for normal Exceptions

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/tkruse/incubator-groovy groovy-7586

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/116.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #116
    
----
commit 32b2108f98e1424d8dd7bd949be9acd1eed3babc
Author: Thibault Kruse <thibault.kruse@gmx.de>
Date:   2015-09-08T15:24:07Z

    GROOVY-7586: Groovysh: print Exception class for normal Exceptions

----
;;;","08/Sep/15 18:12;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/116
;;;","08/Sep/15 18:15;pascalschumacher;Pull request merged! Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ObjectRange strange semantics for mismatched arguments,GROOVY-7585,12862419,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,tkruse,tkruse,08/Sep/15 14:01,02/May/17 02:03,14/Jul/23 06:01,28/Jun/16 07:08,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,"in Object Range, String is a special case considered:
{code}
if (from instanceof String || to instanceof String) {
           String start = from.toString();
           String end = to.toString();
           if (start.length() > end.length()) {
                throw new IllegalArgumentException(""Incompatible Strings for Range: starting String is longer than ending string"");
            }
int length = Math.min(start.length(), end.length());
            int i;
            for (i = 0; i < length; i++) {
                if (start.charAt(i) != end.charAt(i)) break;
            }
            if (i < length - 1) {
                throw new IllegalArgumentException(""Incompatible Strings for Range: String#next() will not reach the expected value"");
            }
            ...
{code}

There are two semantic problems with that implementation. On the one hand this is plain buggy when the length of 'to' is larger than the length of 'from', and two strings are passed:
{code}
groovy:000> x = 'aa'..'aaa'
===> [aa]
{code}
This is because stepping through the strings begins with ""ab"", which is larger than 'aaa' in the comparison of DefaultGroovyMethods.numberAwareCompareTo().
I assume from the rest of the code that the general assumption was that aa..aaa == [aa, ab, ac, ... <something> ..., aaa]

Next, the check would not be meaningful even if the comparison worked as intended:
{code}
'aa'..'aaa' is an infinite sequence. Assuming '_' represents Character.MAX_VALUE and ^ represents Character.MIN_VALUE:
 aa, ab, ac, ..., a_, a_^, ..., a_a, a_b, ... a__, a__^, ... 
{code}
so 'aaa' is never reached. So this could only possibly work it a longer 'to' argument consisted of from[:-1] + Character.MAX_VALUE <n-times> + [a-z]. I don't think that is a relevant case any Groovy user relies on.

So there are two ""bugs"" cancelling each other out somehow, preventing infinite String creation.

There are more problems when mixing Types (via the unsafe constructor):
{code}
groovy:000> x = new ObjectRange('11', 11, true)
===> []
groovy:000> x = new ObjectRange(11, '11', false)
===> [11, 12, 13, 14, 15 ..., 1567]
{code}

There is some code almost handling this nicely
{code}
        if (from.getClass() == to.getClass()) {
            this.from = from;
            this.to = to;
        } else {
            this.from = normaliseStringType(from);
            this.to = normaliseStringType(to);
        }
{code}
But this merely turns Characters and single-char Strings into ints. I believe it would be nice here if after normalization (inside the else case!), if classes do not match, then this should throw an exception. Because when some non-Number, non-String Comparable is passed along with a single-char String ( new MyComparable()..'1') then that string is normalized into it's int value, which IMO is not sane behavior. It's not documented anywhere that single-char Strings will be turned into ints for a range, this can be a convenience transformation when combined with numbers for scripting, but other than that it should just fail, instead of leading to unpredictable behavior anytime later in a system.

It seems this has been like it is since the method was written/copied in 2005. So I suggest
- changing the entry condition to AND: ( if (from instanceof String && to instanceof String) {) 
- to throw an exception if the length of the strings is different
- to throw an exception if after normalization 'from' is a Number or String, but the class of 'to' is not similar to that of 'from'",,pascalschumacher,paulk,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 28 07:08:44 UTC 2016,,,,,,,,,,"0|i2jw1j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Sep/15 15:53;tkruse;Also, I noticed that the size() method is used in several methods within ObjectRange, forcing to iterate once over the whole range. This can be a drag on runtime efficiency when the invoking code just wants to iterate from start to end. It's probably not a significant use-case though, so I did not do anything about it, just thought I'd mention it here.;;;","10/Sep/15 12:56;tkruse;Fixes are part of https://github.com/apache/incubator-groovy/pull/109;;;","13/Oct/15 10:52;paulk;I was hoping to have reviewed/applied this by now but haven't had enough free time lately, so I'll start comments on a few of the pieces.

Firstly, re the comments around ""... semantic problems ..."" and ""... plain buggy ..."". Both the old code and your proposed code reject different length strings such as:
{code}
try {
  'cat'..'banana'
} catch(ex) { println ex.message }
try {
  'cat'..'dingo'
} catch(ex) { println ex.message }
{code}
So, not really a bug with the current code but certainly an inconsistency. The current code gives different error messages:
{noformat}
Incompatible Strings for Range: starting String is longer than ending string
Incompatible Strings for Range: String#next() will not reach the expected value
{noformat}
Yours gives these more consistent variants instead:
{noformat}
Incompatible Strings for Range: different length
Incompatible Strings for Range: different length
{noformat}
So, a breaking change if people were relying on the exact error message format, and not really fixing a bug, but an improvement in consistency, and I think we can go forward with this. Improved error messages should be something we care highly about.;;;","13/Oct/15 11:11;paulk;Existing code handles:
{code}
println '7'..59  // [55, 56, 57, 58, 59]
{code}
but not
{code}
println 51..'7' // IllegalArgumentException
{code}
but yours handles this second case:
{code}
println 51..'7' // [51, 52, 53, 54, 55]
{code}
but existing code handles this differently to yours:
{code}
println '7'..59.5 // [55, 56, 57, 58, 59]
{code}
yours does:
{code}
[7, 8, 9, :, ;, <, =, >, ?, @, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, [, \, ], ^, _, `, a, b, c, d, e, f, g, h, i, j, k]
{code}
Existing code doesn't handle this:
{code}
println 5.5..'7' // IllegalArgumentException
{code}
Yours gives:
{code}
println 5.5..'7' // [5.5, 6.5]
{code}
I am still thinking about what we actually want here - but just listing the results for now, so we can examine and discuss and understand where the important breaking changes (might be)/are.;;;","13/Oct/15 11:51;tkruse;The existing code has special semantics for strings having common prefixes. See my example 'aa'..'aaa', or 'cat'..'catastrophe'. Else I agree.;;;","13/Oct/15 12:52;tkruse;the new result of '7'..59.5 is a special kind of ""bug""/quirk in ObjectRange.size(), which interprets '7' as the number 7, as opposed to the number 55 (ascii code of char '7'). I added a commit to fix that. Also iterator() should probably not use size() to iterate, as ranges can be infinite (brute force computation in size()). I will also fix that.;;;","13/Oct/15 16:04;pascalschumacher;After reading your comment about iterator() and size() I remembered two bugs related to this ""[GROOVY-2972]: groovy.lang.ObjectRange.size() disobeys its contract for large ranges of Long values"" and ""[GROOVY-5426]: ObjectRange.iterator() is reliant on size()"".;;;","13/Oct/15 21:22;tkruse;I started working a unified inner class for both step() and iterator that does not use size(). I will consider those other issues for that. But it is independent of this issue and the PR.;;;","14/Oct/15 04:51;pascalschumacher;Sure, it's better to not to mix multiple issues in a single pull request. Thanks for taking the issues into consideration. :);;;","14/Oct/15 10:49;paulk;Your latest additions look nice. Just summarizing a couple of differences (edge cases) I noticed below. I wasn't trying to be exhaustive

Currently:
{code}
def x = '5'..60.5
assert x.toString() == '53..60.5'
assert x.toList() == [53, 54, 55, 56, 57, 58, 59, 60]
assert x.toList().toString() == '[53, 54, 55, 56, 57, 58, 59, 60]'
{code}
after the PR, we have this breaking change (albeit as already commented an edge case):
{code}
def x = '5'..60.5
assert x.toString() == '5..60.5'
assert x.toList() == [53, 54, 55, 56, 57, 58, 59, 60]
assert x.toList().toString() == '[5, 6, 7, 8, 9, :, ;, <]'
{code}
Also currently:
{code}
println 5.5..'7' // IllegalArgumentException
{code}
but with the PR we have:
{code}
def x = 5.5..'7'
assert x.toString() == '5.5..7'
assert x.toList()[0, 1, 2, /* ... */ -3, -2, -1] == [5.5, 6.5, 7.5, /* ... */ 52.5, 53.5, 54.5]
assert x.toList().toString()[0..15] == '[5.5, 6.5, 7.5, '
{code}
So, an additional case covered (if we agree the new result is valid).;;;","14/Oct/15 13:05;tkruse;Yes. Your output makes another great case for the pretty-printing of output, as the result of toString() here hides the type information in 5.5..7, as opposed to 5.5..'7'. But that is another issue (GROOVY-7568, GROOVY-7569);;;","14/Oct/15 13:19;tkruse;I created PR #142 for only this issue, as #109 tried to solve multiple issues.;;;","15/Oct/15 08:19;tkruse;I modified PR #142 to make the code a bit more clear (added a commit so you can trace change). That also changed behavior a bit, so the first edge case should not be same as before:
assert x.toList().toString() == '[53, 54, 55, 56, 57, 58, 59, 60]'

Basically when normalizing String '7' to int 55 is successful in making the range sane, then the code now uses 55 instead of '7' as starting point.;;;","15/Oct/15 09:22;tkruse;Actually, this is linked to the fact that direction may be computed by ScriptBytecodeAdapter.compareGreaterThan(from, to), which on cases of non-matching types falls back to DefaultTypeTransformation.compareToWithEqualityCheck(). And since that one uses some heuristics to compare Strings with numerics, ObjectRange has to follow those semantics (e.g. avoid interpreting '7' as int 7 in the context when DefaultTypeTransformation.compareToWithEqualityCheck decided that it has the value of 55 when compared to a number).

An ideal solution would make the contract between ObjectRange and DefaultTypeTransformation.compareToWithEqualityCheck() explicit, so that both always agree on how to interpret 2 values in the context of comparing them.

I changed the PR adding a large comment to ObjectRange to discuss that rationale for why ObjectRange should behave the way it does.;;;","28/Jun/16 07:08;paulk;Latest PR merged. In summary: numerous inconsistencies with various edge cases have been made consistent.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
transient fields in trait are not transient in implementing class,GROOVY-7584,12862413,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,steinar.haugen,steinar.haugen,08/Sep/15 13:41,01/Feb/17 23:19,14/Jul/23 06:01,28/Nov/16 19:47,2.4.3,,,,,,,,,,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"Fields with the transient modifier in a trait will not have the transient modifier in the implementing class. 

Example:

{code:java}
trait User {
    String name
    transient boolean loggedIn
}

class Person implements User {
}

def loggedInField = Person.getDeclaredFields().find { 
    it.name.contains('loggedIn') 
}
assert java.lang.reflect.Modifier.isTransient(loggedInField.modifiers)
{code}

Output:
{noformat}
Assertion failed: 
assert java.lang.reflect.Modifier.isTransient(loggedInField.modifiers)
                                  |           |             |
                                  false       |             2
                                              private boolean Person.User__loggedIn
{noformat}

Looks like it might be related to GROOVY-7514, which looks to me like the same bug, but with the final modifier.
",,githubbot,jwagenleitner,paulk,steinar.haugen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 28 19:47:45 UTC 2016,,,,,,,,,,"0|i2jw07:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Nov/16 18:49;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/463

    GROOVY-7584: transient fields in trait are not transient in implement…

    …ing class

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7584

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/463.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #463
    
----
commit 59697fc8cda6de7275498e479b879834d7d0363f
Author: paulk <paulk@asert.com.au>
Date:   2016-11-23T18:42:29Z

    GROOVY-7584: transient fields in trait are not transient in implementing class

----
;;;","28/Nov/16 19:24;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/463
;;;","28/Nov/16 19:47;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closure to SAM coercion doesn't handle overloads with different SAM signatures,GROOVY-7582,12862290,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,ldaley,ldaley,08/Sep/15 01:28,03/Feb/22 22:43,14/Jul/23 06:01,26/Sep/21 20:34,2.4.4,,,,,,,,,,,,,,,,,4.0.0-alpha-3,,,,,,,,2,,,,,,,"The following…

{code}
interface Action<T> {
  void exec(T thing)
}

interface Block {
  void exec()
}

class Container {
  void m(Action<?> action) {}
  void m(Block block) {} 
}

def c = new Container()

c.m { -> 1 }
{code}

Yields…

{code}
groovy.lang.GroovyRuntimeException: Ambiguous method overloading for method Container#m.
Cannot resolve which method to invoke for [class ConsoleScript0$_run_closure1] due to overlapping prototypes between:
	[interface Action]
	[interface Block]
	at ConsoleScript0.run(ConsoleScript0:16)
{code}

It seems that Groovy should be able to deal with the case where the SAM parameter signatures are different. Java does this with lambda expressions. That is, the following works in Java…

{code}
Container c = new Container();
c.m(() -> {});
c.m(arg -> {});
{code}",,bitsnaps,daniilo,emilles,jwagenleitner,ldaley,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 26 20:34:08 UTC 2021,,,,,,,,,,"0|i2jv9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Sep/15 06:39;melix;Agreed. That was out of the scope of the initial implementation (and documented) but we have it in mind (actually we were waiting for such reports to see if it is much trouble).;;;","08/Sep/15 07:21;ldaley;FWIW, I've hit this in Ratpack. The Groovy API is based around closure coercion for the most part, so my basic strategy is to design for Java 8 which means that it works nice with Groovy. Unfortunately, I didn't know about this issue when I added some API.;;;","25/Jul/18 22:46;bitsnaps;I thought groovy is smart enough to figure out which interface should be used if the signatures are different, so even if Action has different method like so:
{code:java}
interface Action<T>
{ void exec(T thing, T thing2) }
//...
 c.m{ a,b -> 1 }
{code}
the same error would be thrown, unless explicit coercion is applied:
{code:java}
c.m ({ a,b -> 1 } as Action){code}
I had the same experience with Ratpack as well.;;;","26/Sep/21 20:34;emilles;See GROOVY-9881;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ExpandoMetaClass append method does not throw an exception as per docs,GROOVY-7580,12861929,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,anshbansal,anshbansal,04/Sep/15 20:00,12/Jun/16 08:45,14/Jul/23 06:01,06/Apr/16 01:30,,,,,,,,,,,,,,,,,,2.4.7,,,,,,,,0,,,,,,,"I was reading the docs when I came across ""Note that the left shift operator is used to append a new method. If the method already exists an exception will be thrown.""

I decided to try it via the below program. There was no exception. I am using groovy 2.3.8

{noformat}
class A {
}
A.metaClass.hello = {
  ""hello superclass""
}

class B extends A {
}
B.metaClass.hello << {
  ""hello subclass""
}

B.metaClass.hello << {
  ""hello subclass""
}

new B().hello()
{noformat}",,anshbansal,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 06 01:30:00 UTC 2016,,,,,,,,,,"0|i2jt2f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Apr/16 01:30;jwagenleitner;Thanks for reporting.  I have updated the docs to try to clarify that only existing declared methods on the class/interface will cause an exception and not methods added at runtime.

Updated wording is:

{quote}
Note that the left shift operator is used to append a new method. If a public method with the same name and parameter types is declared by the class or interface, including those inherited from superclasses and superinterfaces but excluding those added to the metaClass at runtime, an exception will be thrown. If you want to replace a method declared by the class or interface you can use the = operator.
{quote}

Commit https://github.com/apache/groovy/commit/1065954aafcb93da8258bbac6a0c9ce2397d99d9;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovyc ant task does not release file handles,GROOVY-7573,12861045,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,jigawot,jigawot,01/Sep/15 15:33,14/Sep/17 02:06,14/Jul/23 06:01,14/Sep/17 00:31,2.4.4,,,,,,,,,,,,,,,,,2.5.0-beta-2,2.6.0-alpha-2,3.0.0-alpha-1,,Ant integration,,,,0,,,,,,,"Jars used by the classpath in the groovyc ant task are not released during the ant execution.  The following build.xml demonstrates this problem.  Please have a copy of the groovy library (groovy-all-2.x.x.jar) in the same directory of the build.xml file in order to work.  (See comments within xml for more details.)  

Running {{ant}} results in a failure, but running {{ant update_java}} succeeds.  I would presume that running {{ant}} _should_ behave more like {{ant update_java}} and succeed every time.

{code:xml}
<project name=""GroovycFailure"" default=""build"">
    <path id=""groovy.classpath"">
        <fileset dir=""."" includes=""groovy*.jar"" />
    </path>

    <taskdef name=""groovyc""
             classname=""org.codehaus.groovy.ant.Groovyc""
             classpathref=""groovy.classpath"" />

    <target name=""build"" description=""Cleans, inits, builds, then updates the jar"">
        <antcall target=""clean"" />
        <antcall target=""init"" />
        <antcall target=""update_groovy"" />
    </target>

    <target name=""clean"" description=""Deletes source, classes, and jar files"">
        <delete dir=""src"" />
        <delete dir=""java_classes"" />
        <delete dir=""groovy_classes"" />
        <delete>
            <fileset dir=""."" includes=""java_files.jar"" />
        </delete>
    </target>

    <target name=""init"" description=""Create the source folders and some Java and Groovy source files"">
        <mkdir dir=""src"" />
        <mkdir dir=""src/example"" />

        <echo file=""src/example/JavaFile.java"">package example;
public class JavaFile {
    public static void main(String[] args) {
        System.out.println(""Hello, Java."");
    }
}
        </echo>
        <echo file=""src/example/GroovyFile.groovy"">package example;
class GroovyFile {
    static def main() {
        JavaFile jf = new JavaFile()
        println ""Hello, Groovy.""
    }
}
        </echo>
    </target>

    <target name=""compile_java"" description=""Compiles the first generated Java file"">
        <mkdir dir=""java_classes"" />
        <javac srcdir=""src"" destdir=""java_classes"" />
    </target>

    <target name=""compile_groovy"" depends=""jar"" description=""Compiles the Groovy file using the generated jar file"">
        <mkdir dir=""groovy_classes"" />
        <!--
        ******************************************************************************************
          This is where the problem is: when the groovyc task compiles, it puts the jar on the classpath
          but never releases the file handle for the remainder of this ant execution.
        ******************************************************************************************
        -->
        <groovyc srcdir=""src"" destdir=""groovy_classes"" classpath=""java_files.jar"" />
    </target>

    <target name=""jar"" depends=""compile_java"">
        <jar jarfile=""java_files.jar"">
            <fileset dir=""java_classes"">
                <include name=""**/*.class"" />
            </fileset>
        </jar>
    </target>

    <target name=""update_groovy"" depends=""compile_groovy"">
        <!-- Since this depends on compile_groovy, it will run the groovyc task -->
        <!-- Unfortunately, the groovyc is still holding onto the java_files.jar
             file handle, so this fails on the first attempt.  If you re-run this
             ant task all by itself, it succeeds because the compiler skips the
             compilation because it detects there are no new files to compile. -->
        <jar update=""true"" jarfile=""java_files.jar"">
            <fileset dir=""groovy_classes"">
                <include name=""**/*.class"" />
            </fileset>
        </jar>
    </target>

    <target name=""update_java"" depends=""jar"">
        <!-- Add another plain Java file that requires the java_files.jar on the classpath -->
        <echo file=""src/example/AnotherJavaFile.java"">package example;
public class AnotherJavaFile {
    public static void main(String[] args) {
        JavaFile jf = new JavaFile();
        System.out.println(""Hello, Another Java"");
    }
}
        </echo>

        <!-- Compile and update the jar with this new file -->
        <javac srcdir=""src"" destdir=""java_classes"" classpath=""java_files.jar"" />

        <!-- The javac task compiles, just like the groovyc task, except it releases the
             file handle for java_files.jar after it completes, which allows us to update
             the jar. -->
        <jar update=""true"" jarfile=""java_files.jar"">
            <fileset dir=""java_classes"">
                <include name=""**/*.class"" />
            </fileset>
        </jar>
    </target>
</project>
{code}",Windows 7 64-bit,antoaravinth,daniel_sun,githubbot,jigawot,jwagenleitner,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 14 00:46:51 UTC 2017,,,,,,,,,,"0|i2jnon:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Sep/15 15:34;jigawot;I've watched the process using procexp.exe and verified that the file handles are not released by the groovyc ant task.  (Unlike javac, which releases the same file handles upon completion.);;;","10/Sep/15 08:41;antoaravinth;[~jigawot] I used your build.xml, but running ant works fine with groovy 2.4.4 version. Your seeing the error? ;;;","10/Sep/15 09:35;melix;What version of Java are you using? I wouldn't be surprised that is it the same issue as the one I've been fighting with lately: there's a bug in the JVM with ClassValue not being released, which prevents the classloaders from being garbage collected.;;;","10/Sep/15 10:55;paulk;I can replicate your issue on Windows using Java 8 and master build of Groovy. I think it is how Groovy defaults to using the Ant classloader as the parent classloader. That's often not what you want.

I can avoid your problem using:
{code:xml}
<groovyc srcdir=""src"" destdir=""groovy_classes"" includeAntRuntime='false' fork='true'>
  <classpath>
    <path location='java_files.jar'/>
    <path refid='groovy.classpath'/>
  </classpath>
</groovyc>
{code}
;;;","14/Sep/17 00:16;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/595
;;;","14/Sep/17 00:46;daniel_sun;Fixed by: 
https://github.com/apache/groovy/commit/77e6d138adfaf9cc6dba5a95b99a824611e8189d
https://github.com/apache/groovy/commit/da1d02ce668ebcbdb0cb3e4576736a42d79ab789;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovysh File completion with hyphens broken,GROOVY-7567,12859893,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,tkruse,tkruse,28/Aug/15 11:10,02/May/17 02:03,14/Jul/23 06:01,01/Sep/15 18:25,2.4.0,2.4.4,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,Groovysh,,,,0,,,,,,,"To reproduce ('|' is cursor, <tab> means hitting tab):

{code}
$ touch foo.groovy
$ touch 'foo bar'
groovy:000> :load ""foo|<tab>
groovy:000> :load ""'foo.groovy ' // invalid double hyphens and trailing blank
{code}

I suggest handling whitespaces in filenames via escaped blanks, not hyphens.

See https://github.com/apache/incubator-groovy/pull/92",,pascalschumacher,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 01 18:25:26 UTC 2015,,,,,,,,,,"0|i2jhuv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Sep/15 18:25;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovysh command arguments parser does not handle escaped blanks,GROOVY-7566,12859892,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,tkruse,tkruse,28/Aug/15 11:06,02/May/17 02:03,14/Jul/23 06:01,01/Sep/15 18:24,2.4.0,2.4.4,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,Groovysh,,,,0,,,,,,,"To reproduce:
{code}
groovy:000> import org.codehaus.groovy.tools.shell.util.CommandArgumentParser 
===> org.codehaus.groovy.tools.shell.util.CommandArgumentParser
groovy:000> CommandArgumentParser.parseLine('foo \\""')
Missing closing "" in foo \"" -- [foo, \]
// should single argument escaped hyphen

groovy:000> CommandArgumentParser.parseLine('\'\\\\ \\\' bar\'')
===> [\ ' bar]

// should be single (quoted) argument [\\ \' bar]

{code}

See https://github.com/apache/incubator-groovy/pull/92",,pascalschumacher,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 01 18:24:04 UTC 2015,,,,,,,,,,"0|i2jhun:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Sep/15 18:24;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
InvokerHelper verbose printing wrongly escapes backslashes ,GROOVY-7564,12859886,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,tkruse,tkruse,28/Aug/15 10:41,19/Oct/15 16:05,14/Jul/23 06:01,08/Sep/15 10:00,,,,,,,,,,,,,,,,,,2.4.5,,,,,,,,0,,,,,,,"Tor reproduce:
{code}
groovy:000> InvokerHelper.format('a\\b', true, -1)
===> 'a\b'
{code}
Should be 
{code}'a\\b'{code}


[See https://github.com/apache/incubator-groovy/pull/96]
EDIT:
See: https://github.com/apache/incubator-groovy/pull/110
",,githubbot,paulk,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 08 10:00:48 UTC 2015,,,,,,,,,,"0|i2jhtb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Aug/15 00:08;paulk;With my pedantic hat on, I would say I would expect
{code}InvokerHelper.inspect('a\\b'){code} to return {code}'a\\b'{code}

The formatXXX methods are to some degree ""general purpose"" formatting methods that Groovy might use to display objects in a variety of ways. I am not sure we have ever guaranteed that they would always align with what ""inspect"" should produce. I know that currently one directly calls the other and only uses the verbose flag to half convey the intentions. It might be time to make the intention a bit clearer.

BTW, I am very much in favor of your refactoring efforts. We never finished pushing the safe and maxSize params throughout all of the code and we still do not handle a bunch of edge cases properly as you've no doubt discovered. I would also suggest perhaps making a FormatHelper class and moving all of the formatting related methods into it - leaving deprecated stubs in InvokerHelper for b/w compatibility. I was going to do this at one stage earlier on but we ran out of time to finished the refactoring during a release cycle and backed away.

My comments here are very general but I am happy to work with you to progress some specific parts if that makes sense.;;;","01/Sep/15 09:30;tkruse;So what I report is a bug, not a request for a feature. 
I am not sure now if you agree or disagree with me on this bug, but it reads a bit like you disagree.

Note I do not want to change the output of any of:
{code}
InvokerHelper.format('a\\b')
InvokerHelper.format('a\\b', false)
InvokerHelper.format('a\\b', false, -1)
{code}
It's just the output used with verbose=true that has a bug when dealing with backslashes. 

Inspect does the same call I showed in the example, passing verbose=true.
{code}
public static String inspect(Object self) {
        return format(self, true); // 2nd arg is verbose
    }
{code}

So the bug affects both inspect(...) and format(..., verbose: true).

Also see the Pull request code.;;;","01/Sep/15 12:54;paulk;I agree there is a bug with inspect but I guess I am saying I disagree with you about format ... but only a little bit. And please take my comments as simply a means to impart my incomplete knowledge of the history of some of the methods you are proposing to change. Here is what I believe the situation is:
* I think we have a good handle of Groovy's default representation for objects
* I think we have a good handle of what Groovy's inspect method does (even though we don't claim it works perfectly for all objects)
* We also have a verbose flag on some of the format methods within InvokerHelper the behavior of which we haven't clearly defined

We happen to use the verbose flag for inspect but other users of Groovy might also use that method and not expect the ""inspect"" behavior; they just don't want some of the minimalization which you get with Groovy's default representation. As it turns out, I don't think we can justify having three different formatting options, so I am keen to push our APIs towards just two variants which is where your PR is heading. I am just noting that we should be treading carefully. I am not too concerned since we are talking about methods which most users of Groovy won't be calling directly but if Spock or GPars or Grails are making direct calls, we might cause some unintended indirect pain.
So, I wouldn't be against your change so long as we mark it as a breaking change, release note it as such and ensure all of the appropriate methods become clearly documented in the process. But even better, I'd prefer most of the methods to be moved into a FormatHelper class which would let us leave some old behaviors in place if we want - unchanged but deprecated.;;;","01/Sep/15 14:53;tkruse;I think we still don't understand each other.

InvokerHelper has this line, in the snippet to escape Strings for displaying hyphenated strings:
{code}
arg = arg.replaceAll(""\\\\"", ""\\\\"");      // backslash
{code}

But this line does not escape backslashes. This line does effectively nothing, it replaces any single slash with a single slash:
{code}
        String source = ""a\\b"";
        // the replaceAll call does not change the original string. It replaces any one slash with one slash.
        assertEquals(source, source.replaceAll(""\\\\"", ""\\\\""));
{code}

This is a pecularity of replaceAll that the second argument, though not being a regex, still has special backslash semantics in the replacement code (see http://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#replaceAll%28java.lang.String%29 : ""Note that backslashes (\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string."" )

So the code of InvokerHelper contains a line that has no effect. Can we agree on this first, maybe?

You can check this with a unit test:
{code}
    @Test
    public void testEscaping() {
        String source = ""a\\b"";
        assertEquals(source, source.replaceAll(""\\\\"", ""\\\\""));
    }
{code}

Once we agree that this line in InvokerHelper does nothing, we can maybe look further if we should:
- keep that line
- remove that line
- exchange it with a line that actually does something;;;","01/Sep/15 21:46;tkruse;Maybe the confusion stems from the Pull Request containing fixes for multiple issues, GROOVY-7563 and GROOVY-7564. 

GROOVY-7563 deals with several refactorings and inconsistencies of the formatting methods.
GROOVY-7564 (this one here) deals with a solid bug.

These are completely independent, and only part of the same PR because they both touch the formatting methods in InvokerHelper. I can make separate PRs to clarify further.;;;","01/Sep/15 22:32;githubbot;GitHub user tkruse opened a pull request:

    https://github.com/apache/incubator-groovy/pull/110

    GROOVY-7564: InvokerHelper: Fix invalid escaping of backslashes

    (replaceAll() line was noop, must be before other replacements)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/tkruse/incubator-groovy groovy-5764

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/110.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #110
    
----
commit e5feced2da8d193b5b96a4debdaf47683f79dd67
Author: Thibault Kruse <thibault.kruse@gmx.de>
Date:   2015-09-01T22:04:17Z

    GROOVY-7564: InvokerHelper: Fix invalid escaping of backslashes
    (replaceAll() line was noop, must be before other replacements)

----
;;;","01/Sep/15 22:33;tkruse;New PR just for 7564: https://github.com/apache/incubator-groovy/pull/110;;;","02/Sep/15 08:51;githubbot;Github user tkruse closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/110
;;;","02/Sep/15 11:54;githubbot;GitHub user tkruse reopened a pull request:

    https://github.com/apache/incubator-groovy/pull/110

    GROOVY-7564: InvokerHelper: Fix invalid escaping of backslashes

    (replaceAll() line was noop, must be before other replacements)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/tkruse/incubator-groovy groovy-5764

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/110.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #110
    
----
commit e5feced2da8d193b5b96a4debdaf47683f79dd67
Author: Thibault Kruse <thibault.kruse@gmx.de>
Date:   2015-09-01T22:04:17Z

    GROOVY-7564: InvokerHelper: Fix invalid escaping of backslashes
    (replaceAll() line was noop, must be before other replacements)

----
;;;","02/Sep/15 12:34;paulk;Thanks Thibault, yes the split PRs should go a long way to allow us to progress the easy things. I wasn't saying that no bugs existed - the backslash thing definitely looks wrong and there's definitely some holes that will be non-controversial to close. There were just a few changes previously which seemed to fall into areas which might break backwards compatibility without an obvious bug being in play.;;;","08/Sep/15 09:39;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/110
;;;","08/Sep/15 10:00;paulk;Applied. Thanks for the additional work. I think it will make it much clearer on what was changed and why. Nice work.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
imports and custom class defs not working in Groovysh Interpreter Mode,GROOVY-7562,12859884,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,tkruse,tkruse,28/Aug/15 10:25,15/Aug/17 02:06,14/Jul/23 06:01,01/Sep/15 18:39,2.4.0,2.4.1,2.4.2,2.4.3,2.4.4,,,,,,,,,,,,,2.5.0-alpha-1,,,,Groovysh,,,,0,,,,,,,"To reproduce

{code}
groovy:000> :set interpreterMode true
groovy:000> class Me { String name }
===> true
groovy:000> m = new Me()
script14405523893121089774169.groovy: 2: unable to resolve class Me 

groovy:000> import java.rmi.Remote
===> java.rmi.Remote
groovy:000> Remote x
script1440757530265448239810.groovy: 1: unable to resolve class Remote 
 @ line 1, column 8.
   Remote x
{code}

See https://github.com/apache/incubator-groovy/pull/100 for fix",,pascalschumacher,pluradj,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8278,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 07 19:56:44 UTC 2016,,,,,,,,,,"0|i2jhsv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Sep/15 18:39;pascalschumacher;Pull request merged. Thanks!;;;","07/Mar/16 19:50;pluradj;Was there a particular reason why the fix wasn't targetted for Groovy 2.4.x?;;;","07/Mar/16 19:56;pascalschumacher;The pull request contains some changes which are binary incompatible. Groovysh classes are not really an api, but it's better to be careful with changes like this, especially in a bugfix release. Therefore the change is 2.5 only.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error when referencing private member variables from within a closure,GROOVY-7558,12858737,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,jkeys089,jkeys089,25/Aug/15 20:00,01/Feb/17 23:18,14/Jul/23 06:01,02/Jul/16 17:01,2.4.4,,,,,,,,,,,,,,,,,2.4.8,,,,Static compilation,,,,0,,,,,,,"Originally posted on SO here: http://stackoverflow.com/questions/32212260/in-groovy-is-it-legal-to-reference-private-member-variables-from-within-a-closur

The code below fails with {{java.lang.ClassCastException: Test$_doStuff_closure1 cannot be cast to Test}}.  Interestingly, if I remove the {{@CompileStatic}} annotation or make the member variable non-private it works as expected.

{code:java}
class Test {
    private String str = ""hi""
    @groovy.transform.CompileStatic
    public void doStuff() {
        Closure c = {
            println str
        }
        c()        
    }
}

new Test().doStuff()
{code}

It also works when {{@CompileStatic}} is moved up to the class level

{code:java}
@groovy.transform.CompileStatic
class Test {
    private String str = ""hi""
    public void doStuff() {
        Closure c = {
            println str
        }
        c()        
    }
}

new Test().doStuff()
{code}",Linux x86-64 / java 1.8.0_60,githubbot,jkeys089,keegan,pascalschumacher,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 02 16:56:51 UTC 2016,,,,,,,,,,"0|i2jczb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Aug/15 20:09;keegan;I simplified the example a bit and added some formatting.  Hope you don't mind :);;;","05/Oct/15 21:49;shils;This seems to happen because private field accessors aren't generated for classes that aren't statically compiled, even if they have statically compiled methods. I also don't think this should be considered a duplicate of [GROOVY-7597|https://issues.apache.org/jira/browse/GROOVY-7597]. In this case the class being checked for (Test) is correct (in the sense that it would be used to access the property) and the reference on the stack (the closure) is incorrect. In 7597, the class being checked for (Calculation) is incorrect and the reference (the closure's delegate) is correct.  The underlying causes of both issues at the AST level are also different.;;;","10/Oct/15 18:33;pascalschumacher;As Shil Sinha said it is not a duplicate of [GROOVY-7597]. It still fails even after [GROOVY-7597] was fixed.;;;","11/Oct/15 22:11;shils;A simple but sub-optimal fix is here: https://github.com/apache/incubator-groovy/compare/master...shils:GROOVY-7558;;;","16/Jan/16 19:37;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/242

    GROOVY-7558 Add private field accessors and bridge methods to dynamic…

    … classes with statically compiled inner classes

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7558

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/242.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #242
    
----
commit 5cb6368ed7c5755c62a76431e96b944e3dee796e
Author: Shil S <shil.sinha@gmail.com>
Date:   2015-10-11T19:58:52Z

    GROOVY-7558 Add private field accessors and bridge methods to dynamic classes with statically compiled inner classes

----
;;;","19/Jan/16 22:41;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/242#discussion_r50188030
  
    --- Diff: src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java ---
    @@ -123,9 +123,20 @@ public void visitClass(final ClassNode node) {
             }
             super.visitClass(node);
             addPrivateFieldAndMethodAccessors(node);
    +        if (isStaticallyCompiled(node)) {
    +            ClassNode outer = node.getOuterClass();
    +            if (outer != null && !isStaticallyCompiled(outer)) {
    +                outer.putNodeMetaData(StaticCompilationMetadataKeys.DYNAMIC_OUTER_NODE, true);
    +            }
    +        }
             classNode = oldCN;
         }
     
    +    public void visitDynamicOuterClass(ClassNode node) {
    --- End diff --
    
    adding a public method here is not ideal, though it seems like the alternative would be to create a separate class responsible for adding bridge methods, which would be used by StaticCompilationVisitor as well as the phase operation added for dynamic outer classes.
;;;","02/Jul/16 16:56;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/242
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Path.write() appends when encoding parameter present,GROOVY-7553,12857207,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,keegan,keegan,keegan,19/Aug/15 13:13,19/Oct/15 16:05,14/Jul/23 06:01,20/Aug/15 01:24,,,,,,,,,,,,,,,,,,2.4.5,,,,,,,,0,,,,,,,"{{Path.write()}} is expected to overwrite and not append, which it does, except in when the encoding parameter is passed, as demonstrated here

{code:java}
def p = java.nio.file.Paths.get(""foo.txt"")
p.write(""1"")
p.write(""2"")
assert p.text == ""2""  // passes
java.nio.file.Files.delete(p)
p.write(""1"", ""UTF-8"")
p.write(""2"", ""UTF-8"")
assert p.text == ""2""  // fails, is '12'
java.nio.file.Files.delete(p)
{code}",,githubbot,keegan,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 20 01:10:38 UTC 2015,,,,,,,,,,"0|i2j3pz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Aug/15 15:19;githubbot;GitHub user keeganwitt opened a pull request:

    https://github.com/apache/incubator-groovy/pull/89

    GROOVY-7553: Path.write() appends when encoding parameter present

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/keeganwitt/incubator-groovy GROOVY-7553

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/89.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #89
    
----
commit 559dc32396b6f2b01b04d0924ca45928ad436309
Author: Keegan Witt <keeganwitt@gmail.com>
Date:   2015-08-19T15:17:31Z

    GROOVY-7553: Path.write() appends when encoding parameter present

----
;;;","20/Aug/15 01:10;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/89
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy-all has a dependency on com.googlecode:openbeans that is not available on Maven Central,GROOVY-7551,12856889,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,robertpanzer,robertpanzer,18/Aug/15 11:12,19/Oct/15 16:05,14/Jul/23 06:01,20/Aug/15 11:52,2.4.4,,,,,,,,,,,,,,,,,2.4.5,,,,,,,,0,,,,,,,"The pom.xml contains an optional dependency on com.googlecode:openbeans.
But this module is not available on Maven central, only on jcenter.

Therefore resolving a dependency on groovy-all 2.4.4 via Ivy fails.
This dependency is new since 2.4.4 and was not present in 2.4.3.",,githubbot,melix,paulk,robertpanzer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 20 11:52:30 UTC 2015,,,,,,,,,,"0|i2j1sf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Aug/15 11:21;melix;To be clear, {{openbeans}} should not even appear as an optional dependency: it's only a dependency of the {{grooid}} jars, but even in that case, it's a bundled dependency, hence it should not appear in the various pom files we generate.;;;","20/Aug/15 04:01;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/91

    GROOVY-7551: groovy-all has a dependency on com.googlecode:openbeans …

    …that is not available on Maven Central

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7551

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/91.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #91
    
----
commit d414f0c3dc912e81f018fbb7c85e1c56c6f8f3d3
Author: paulk <paulk@asert.com.au>
Date:   2015-08-20T03:58:03Z

    GROOVY-7551: groovy-all has a dependency on com.googlecode:openbeans that is not available on Maven Central

----
;;;","20/Aug/15 04:08;paulk;Yes, one fix would be to mention jcenter within a <repositories> tag which you could do as a workaround or you could remove openbeans from the cached pom (again, just as a workaround).

As Cédric already mentioned, we embed that particular jar in the grooid artifacts, so it really shouldn't be mentioned at all in the pom. We'll do that in the next release as per the proposed PR mentioned above. ;;;","20/Aug/15 11:51;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/91
;;;","20/Aug/15 11:52;paulk;merged;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Ecosystem page points to dead Codehaus links,GROOVY-7550,12856869,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,glaforge,aalmiray,aalmiray,18/Aug/15 09:39,16/Jan/16 05:08,14/Jul/23 06:01,20/Aug/15 13:36,2.4.4,,,,,,,,,,,,,,,,,,,,,Documentation,,,,0,,,,,,,"The page http://www.groovy-lang.org/ecosystem.html points to dead links at Codehaus. GPars and Griffon are affected.

Griffon is now found at http://griffon-framework.org/
GPars is found at http://gpars.org/ 

Unfortunately GPars has not migrated its content to the new site :'(",,aalmiray,glaforge,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 20 13:36:33 UTC 2015,,,,,,,,,,"0|i2j1o7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Aug/15 13:36;glaforge;Should be fixed for the next automatic redeployment of the site.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.IllegalAccessError occurs when attempting to run code built with CompileStatic,GROOVY-7549,12856719,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,steven.walters@icidigital.com,steven.walters@icidigital.com,17/Aug/15 20:11,07/Dec/20 13:46,14/Jul/23 06:01,13/Jun/20 13:31,2.4.4,,,,,,,,,,,,,,,,,2.4.20,2.5.13,3.0.5,4.0.0-alpha-1,,,,,0,,,,,,,"Given a small code setup such as the following, where there exists a
# A publicly declared interface
# A package private implementation of the interface
# A static factory class that returns an instance of the implementation *as the implementation class*

{code:title=packa.TheInterface.groovy|borderStyle=solid}
package packa
public interface TheInterface {
    public void doStuff()
}
{code}
{code:title=packb.TheImplementation.groovy|borderStyle=solid}
package packb
import packa.TheInterface
@groovy.transform.CompileStatic
@groovy.transform.PackageScope
class TheImplementation implements TheInterface {
    public void doStuff() {
        System.out.println(""Do some stuff"")
    }
}
{code}
{code:title=packb.TheFactory.groovy|borderStyle=solid}
package packb
public class TheFactory {
    static TheImplementation getAnInstance() {
        return new TheImplementation()
    }
}
{code}

With CompileStatic, calling the factory method successfully works, but calling any method on the returned object fails with {{java.lang.IllegalAccessError}}.
When CompileStatic is removed, the code runs without issue.
Such as the following.
{code:title=packa.TheMain.groovy|borderStyle=solid}
package packa
import packb.TheFactory
@groovy.transform.CompileStatic
public class TheMain {
    public static void main(String[] args) {
        TheInterface if1 = TheFactory.anInstance
        /* the following only fails when CompileStatic is enabled with the following error:
         * Exception in thread ""main"" java.lang.IllegalAccessError: tried to access class packb.TheImplementation from class packa.TheMain */
        if1.doStuff()
    }
}
{code}

There seem to be some interesting factors here, as changing the {{TheFactory}} to return {{TheInterface}} instead of {{TheImplemenation}} also seems to resolve the issue.

However, changing the return of the {{TheFactory}} is not desirable, as in the actual production the above sample was formulated from, there are other classes in the {{packb}} package that utilize {{TheFactory}} and should not require class casts from {{TheInterface}} to {{TheImplementation}}",,jwagenleitner,shils,steven.walters@icidigital.com,,,,,,,,,,,,,"eric-milles opened a new pull request #1273:
URL: https://github.com/apache/groovy/pull/1273


   https://issues.apache.org/jira/browse/GROOVY-7549


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jun/20 17:24;githubbot;600","danielsun1106 merged pull request #1273:
URL: https://github.com/apache/groovy/pull/1273


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;13/Jun/20 13:31;githubbot;600","danielsun1106 commented on pull request #1273:
URL: https://github.com/apache/groovy/pull/1273#issuecomment-643624277


   Merged. Thanks


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;13/Jun/20 13:31;githubbot;600","eric-milles opened a new pull request #1439:
URL: https://github.com/apache/groovy/pull/1439


   https://issues.apache.org/jira/browse/GROOVY-9847
   https://issues.apache.org/jira/browse/GROOVY-7549


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Dec/20 19:10;githubbot;600","paulk-asert commented on pull request #1439:
URL: https://github.com/apache/groovy/pull/1439#issuecomment-739645978


   Merged into GROOVY_2_5_X. Please feel free to close.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Dec/20 03:49;githubbot;600","eric-milles closed pull request #1439:
URL: https://github.com/apache/groovy/pull/1439


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Dec/20 13:46;githubbot;600",,,,,,0,3600,,,0,3600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 15 03:47:39 UTC 2015,,,,,,,,,,"0|i2j0tz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Sep/15 03:47;shils;The underlying issue, I think, is that `if1.doStuff()` results in an invokeVirtual instruction when compiled with @CompileStatic, rather than an invokeInterface instruction (which is what the equivalent java code would yield). This appears to be the result of the way direct method call targets are chosen; the inferred type of a receiver is 'preferred' to the declared type of the accessed variable, causing TheImplementation.doStuff() to be chosen over TheInterface.doStuff().

Edit:
Looking back at this now, the invokevirtual vs. invokeinterface difference isn't really the issue; the error in general is with inaccessible direct method call targets, so this bug also occurs when TheInterface is a class which TheImplementation extends.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Grab should provide a way to set system properties,GROOVY-7548,12856080,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,14/Aug/15 06:43,19/Oct/15 16:11,14/Jul/23 06:01,30/Aug/15 10:05,,,,,,,,,,,,,,,,,,2.4.5,,,,,,,,0,,,,,,,"@Grab provides no mechanism for setting system properties which might be required for downloading dependencies via SSL or a proxy. With an increasing number of services moving to the cloud, this greatly reduces the usefulness of scripts to enterprise organizations. Such a mechanism could easily be added by adding an extra attribute, e.g. {{systemProperties}} to @GrabConfig and supplying a constant list of property name, property value pairs.",,githubbot,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 30 10:09:28 UTC 2015,,,,,,,,,,"0|i2iwxj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Aug/15 06:59;melix;Before we merge this, it might be worth asking on the ML security experts what implications this can have. I suspect it's not more harm than the script itself, but who knows.;;;","15/Aug/15 07:22;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/83

    GROOVY-7548: @Grab should provide a way to set system properties

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7548

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/83.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #83
    
----
commit 4c0d2d2bf4a701ea7d2c12f82f763fe5be50e02c
Author: paulk <paulk@asert.com.au>
Date:   2015-08-15T06:53:19Z

    GROOVY-7548: @Grab should provide a way to set system properties

----
;;;","15/Aug/15 07:26;paulk;You're referring to security@apache.org or potential security folk on the Groovy MLs?;;;","30/Aug/15 10:04;paulk;Based on feedback from the mailing list, I have put in a conservative patch to enable this feature. The system properties are only set if grapes are enabled. Also, the system properties are set within the context of the script or class containing the @Grab, so if there is a security manager in play, the same rules apply as if the system properties were set explicitly in the script. The consequence of these decisions is that at least for now, if using a proxy or tweaking SSL networking properties, you have to set them in both the script and on the command line. If this proves to be too restrictive we can explore removing this restriction in the future.;;;","30/Aug/15 10:06;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/83
;;;","30/Aug/15 10:09;melix;+1;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
null values break AssertionRenderer.valueToString,GROOVY-7547,12855559,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,jkemnade,jkemnade,12/Aug/15 14:08,08/Mar/22 12:16,14/Jul/23 06:01,19/Dec/21 17:06,2.4.4,,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,,"While trying to write a test for GROOVY-6958, I got the following trace:
{noformat}
    java.lang.NullPointerException
        at org.codehaus.groovy.runtime.powerassert.AssertionRenderer.javaLangObjectToString(AssertionRenderer.java:179)
        at org.codehaus.groovy.runtime.powerassert.AssertionRenderer.valueToString(AssertionRenderer.java:166)
        at org.codehaus.groovy.runtime.powerassert.AssertionRenderer.renderValues(AssertionRenderer.java:100)
        at org.codehaus.groovy.runtime.powerassert.AssertionRenderer.render(AssertionRenderer.java:60)
        at org.codehaus.groovy.runtime.powerassert.AssertionRenderer.render(AssertionRenderer.java:54)
        at org.codehaus.groovy.runtime.NullObjectTest$_testCategory_closure2.doCall(NullObjectTest.groovy:62)
        at org.codehaus.groovy.runtime.NullObjectTest$_testCategory_closure2.doCall(NullObjectTest.groovy)
{noformat}
",,jkemnade,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 12 14:09:26 UTC 2015,,,,,,,,,,"0|i2itqn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Aug/15 14:09;jkemnade;Proposed fix:
{code}
diff --git a/src/main/org/codehaus/groovy/runtime/powerassert/AssertionRenderer.java b/src/main/org/codehaus/groovy/runtime/powerassert/AssertionRenderer.java
index 8fa14cc..ab78ded 100644
--- a/src/main/org/codehaus/groovy/runtime/powerassert/AssertionRenderer.java
+++ b/src/main/org/codehaus/groovy/runtime/powerassert/AssertionRenderer.java
@@ -148,6 +148,7 @@ public final class AssertionRenderer {
      * @return a string representation of the given value
      */
     private static String valueToString(Object value) {
+        if (value == null) return ""null"";
         String toString;
 
         try {
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"CompileStatic class generation bug ""register with message: rightShiftUnsigned and arguments X""",GROOVY-7542,12852611,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mbjarland,mbjarland,06/Aug/15 15:49,01/Feb/17 23:18,14/Jul/23 06:01,09/Aug/16 08:06,2.4.4,,,,,,,,,,,,,,,,,2.4.8,,,,Static compilation,,,,0,,,,,,,"Error caused by the following code snippet (was in the process of coding a crc64 algorithm): 

{code:language=groovy}
import groovy.transform.CompileStatic 

test()

@CompileStatic
def test() {
  long register = 0xfac432b10cd5e44aL  
  
  [1,2,3].each { int element -> 
    int t = (int) (register >>> 56 ^ (long) element) & 0xff
  }  
}
{code}

execution example: 

{code}
$ groovy test.groovy 

Caught: BUG! exception in phase 'class generation' in source unit '/home/mbjarland/test.groovy' At line 11 column 20

On receiver: register with message: rightShiftUnsigned and arguments: 56
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at https://issues.apache.org/jira/browse/GROOVY

BUG! exception in phase 'class generation' in source unit '/home/mbjarland/projects/kohler.project/projects/full-publish/test.groovy' At line 11 column 20

On receiver: register with message: rightShiftUnsigned and arguments: 56
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at https://issues.apache.org/jira/browse/GROOVY
{code}
","Groovy Version: 2.4.4 JVM: 1.7.0_55 Vendor: Oracle Corporation OS: Linux
",githubbot,mbjarland,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7787,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 09 08:06:20 UTC 2016,,,,,,,,,,"0|i2ifcf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Aug/15 11:37;mbjarland;An additional nugget of information on this issue. Pasting in my original (non simplified...kind of...left out the lengthy 'table' def) code: 

{code:language=groovy}
@CompileStatic
long crc64(File file) {
  long register = 0xfac432b10cd5e44aL
  def table = []

  int KB = 1024
  int MB = 1024*KB

  file.eachByte(MB) { byte[] buf, int bytesRead ->
    buf[0..(bytesRead-1)].each { long element -> 
      long tmp = register

      int t = (int) (tmp >>> 56 ^ element)
      tmp <<= 8
      tmp ^= table[t]    

      register = tmp
    } 
  }

  register
}
{code}

assigning the variable 'register' to  'tmp' and then performing the shift operations on 'tmp' resolves the issue. Performing the operations directly on 'register' above causes the same error as in the issue description. ;;;","16/Aug/15 13:00;githubbot;GitHub user antoaravinth opened a pull request:

    https://github.com/apache/incubator-groovy/pull/85

    Fix for the issue GROOVY-7542

    Hi @melix,
     
         I guess I have understood the problem. Looks like there is no method to handle `rightShiftUnsigned` operation. Actually there is no method for `leftShift` as well; After this fix, I have tested the code with and without `@CompileStatic`. Then did `groovyc`, could able to see the the difference in the generated byte code. 
    
    Sample I have used, same as given in the exception:
    
    ```
    import groovy.transform.CompileStatic 
    
    test()
    
    @CompileStatic
    def test() {
      long register = 0xfac432b10cd5e44aL  
      
      [1,2,3].each { int element -> 
        int t = (int) (register >>> 56 ^ (long) element) & 0xff
        println t
      }  
    }
    ```
    
    doing `javap` on the compiled groovy class, I could able to get 
    
    ```
      public java.lang.Object test();
        Code:
           0: getstatic     #59                 // Field $const$0:J
           3: invokestatic  #65                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;
           6: new           #67                 // class groovy/lang/Reference
           9: dup_x1        
          10: swap          
          11: invokespecial #70                 // Method groovy/lang/Reference.""<init>"":(Ljava/lang/Object;)V
          14: astore_1      
          15: aload_1       
          16: pop           
          17: iconst_3      
          18: anewarray     #72                 // class java/lang/Object
          21: dup           
          22: iconst_0      
          23: iconst_1      
          24: invokestatic  #77                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
          27: aastore       
          28: dup           
          29: iconst_1      
          30: iconst_2      
          31: invokestatic  #77                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
          34: aastore       
          35: dup           
          36: iconst_2      
          37: iconst_3      
          38: invokestatic  #77                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
          41: aastore       
          42: invokestatic  #83                 // Method org/codehaus/groovy/runtime/ScriptBytecodeAdapter.createList:([Ljava/lang/Object;)Ljava/util/List;
          45: new           #85                 // class ""GROOVY-7542$_test_closure1""
          48: dup           
          49: aload_0       
          50: aload_0       
          51: aload_1       
          52: invokespecial #88                 // Method ""GROOVY-7542$_test_closure1"".""<init>"":(Ljava/lang/Object;Ljava/lang/Object;Lgroovy/lang/Reference;)V
          55: invokestatic  #94                 // Method org/codehaus/groovy/runtime/DefaultGroovyMethods.each:(Ljava/util/List;Lgroovy/lang/Closure;)Ljava/util/List;
          58: areturn       
          59: aconst_null   
          60: areturn      
    ```
    
    (only for `test` method)
    
    where as removing the `@CompileStatic` does gives the following bytecode:
    
    ```
    public java.lang.Object test();
        Code:
           0: invokestatic  #19                 // Method $getCallSiteArray:()[Lorg/codehaus/groovy/runtime/callsite/CallSite;
           3: astore_1      
           4: getstatic     #59                 // Field $const$0:J
           7: invokestatic  #65                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;
          10: new           #67                 // class groovy/lang/Reference
          13: dup_x1        
          14: swap          
          15: invokespecial #70                 // Method groovy/lang/Reference.""<init>"":(Ljava/lang/Object;)V
          18: astore_2      
          19: aload_2       
          20: pop           
          21: aload_1       
          22: ldc           #71                 // int 2
          24: aaload        
          25: iconst_3      
          26: anewarray     #73                 // class java/lang/Object
          29: dup           
          30: iconst_0      
          31: iconst_1      
          32: invokestatic  #78                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
          35: aastore       
          36: dup           
          37: iconst_1      
          38: iconst_2      
          39: invokestatic  #78                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
          42: aastore       
          43: dup           
          44: iconst_2      
          45: iconst_3      
          46: invokestatic  #78                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
          49: aastore       
          50: invokestatic  #84                 // Method org/codehaus/groovy/runtime/ScriptBytecodeAdapter.createList:([Ljava/lang/Object;)Ljava/util/List;
          53: new           #86                 // class ""GROOVY-7542$_test_closure1""
          56: dup           
          57: aload_0       
          58: aload_0       
          59: aload_2       
          60: invokespecial #89                 // Method ""GROOVY-7542$_test_closure1"".""<init>"":(Ljava/lang/Object;Ljava/lang/Object;Lgroovy/lang/Reference;)V
          63: invokeinterface #92,  3           // InterfaceMethod org/codehaus/groovy/runtime/callsite/CallSite.call:(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
          68: areturn       
          69: aconst_null   
          70: areturn       
    ```
    
    I guess I'm in right path; I'm no-where an byte code engineer, so in case if I have missed any of the cases, let me know. 
    
    So that I can write some generic method for handling the bit-wise operator on the compile static mode!
    
    Thanks for your response. 

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/antoaravinth/incubator-groovy GROOVY-7542

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/85.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #85
    
----
commit 85904b51e21eb964ac0c3f22ac3dc3ad057d4440
Author: antoaravinth <anto.aravinth.cse@gmail.com>
Date:   2015-08-16T12:54:47Z

    GROOVY-7542: CompileStatic class generation bug 'register with message: rightShiftUnsigned and arguments X'

----
;;;","09/Aug/16 07:55;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/85
;;;","09/Aug/16 08:06;paulk;PR merged (thanks) and test case added.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler crash in the static type checker with self-referencing generic type,GROOVY-7538,12850810,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,fpavageau,fpavageau,01/Aug/15 21:35,22/Feb/16 20:48,14/Jul/23 06:01,28/Nov/15 20:00,2.4.4,,,,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,test,,,,,,"I'm writing unit tests in Groovy combined with AssertJ, and I got a compiler crash with the following code:
{code}
Assertions.assertThat(""true"").isNotEmpty().isNotEqualTo(""false"")
{code}
The matching stacktrace is
{noformat}
java.lang.ArrayIndexOutOfBoundsException: 1
    	at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:167)
    	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.extractPlaceHolders(StaticTypeCheckingVisitor.java:4455)
    	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.resolvePlaceHoldersFromDeclaration(StaticTypeCheckingVisitor.java:4416)
    	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnTypeGenerics(StaticTypeCheckingVisitor.java:4206)
    	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2924)
    	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:297)
    	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
    	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:71)
    	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:196)
    	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:42)
    	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:37)
    	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:166)
    	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
    	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:104)
    	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:115)
    	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1773)
    	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:126)
    	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2106)
    	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2065)
    	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:163)
    	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1086)
    	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:53)
    	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:249)
    	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:122)
    	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:63)
    	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    	at java.lang.reflect.Method.invoke(Method.java:606)
    	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoCachedMethodSite.invoke(PojoMetaMethodSite.java:192)
    	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:56)
    	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
    	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
    	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
    	at org.codehaus.groovy.control.customizers.ASTTransformationCustomizer.call(ASTTransformationCustomizer.groovy:294)
    	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1055)
    	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
    	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
    	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
    	...
{noformat}

Also interesting is that if I swap the 2 assertions, the compiler doesn't crash anymore, but I still get a compilation error from the static type checker:
{code}
Assertions.assertThat(""true"").isNotEqualTo(""false"").isNotEmpty()
{code}
The error is then:
{noformat}
[Static type checking] - Cannot find matching method org.assertj.core.api.AbstractAssert#isNotEmpty(). Please check if the declared type is right and if the method exists.
{noformat}

Of course, both lines compile in Java.

I've created a test to reproduce the bugs, I'll create a pull request on github right afterwards.",,fpavageau,githubbot,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Nov 28 20:00:16 UTC 2015,,,,,,,,,,"0|i2i7uf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Aug/15 21:44;githubbot;GitHub user fpavageau opened a pull request:

    https://github.com/apache/incubator-groovy/pull/79

    GROOVY-7538 Add a failing test

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fpavageau/incubator-groovy GROOVY-7538

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/79.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #79
    
----
commit 73dec2343ee865bec2176aff8e2bda52aa7b3296
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-08-01T21:40:57Z

    GROOVY-7538 Add a failing test

----
;;;","01/Sep/15 04:59;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/79
;;;","08/Nov/15 22:22;fpavageau;For the record, I've been working on a fix, the temporary result of which can be seen [here|https://github.com/fpavageau/incubator-groovy/compare/GROOVY_2_4_X...fpavageau:GROOVY-7538].

I'm not really satisfied with the current form (especially the second commit), but it does fix both test cases. It fails the Groovy build, however, so it's obviously not ready yet.;;;","25/Nov/15 21:07;githubbot;GitHub user fpavageau opened a pull request:

    https://github.com/apache/incubator-groovy/pull/196

    GROOVY-7538 Resolve placeholder return types correctly

    This solves the first half of [GROOVY-7538](https://issues.apache.org/jira/browse/GROOVY-7538).
    
    I've tried to replace the test in `Groovy7538Bug` by a new one in `GenericsSTCTest`, but ran into another issue while trying to implement the test purely in Groovy (I'll open a new ticket on https://issues.apache.org/).

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fpavageau/incubator-groovy GROOVY-7538-sub-type-to-super-type

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/196.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #196
    
----
commit 0c83e7e389bff6e964d11154eb558a9eb1ccae3a
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-11-01T21:14:41Z

    GROOVY-7538 Resolve placeholder return types correctly

----
;;;","25/Nov/15 22:52;githubbot;Github user fpavageau closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/196
;;;","26/Nov/15 15:26;githubbot;GitHub user fpavageau opened a pull request:

    https://github.com/apache/incubator-groovy/pull/197

    GROOVY-7538 Bound unbounded wildcards using the type declaration

    If there is a type declared with bounds, for example
    
        class NumberList<T extends Number> implements List<T>
    
    but used with an unbounded wildcard
    
        NumberList<?> getList()
    
    the bounds are actually implicit and need to be taken into account for the
    static type checks, to be able to use the type of the parameter directly:
    
        getList()[0].longValue()
    
    The type of the element is known to be `Number`, not `Object`.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fpavageau/incubator-groovy GROOVY-7538

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/197.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #197
    
----
commit 0f9fca72cefc9372ea9c3b33eef5b80f3cf7585f
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-11-26T15:12:09Z

    GROOVY-7538 Bound unbounded wildcards using the type declaration
    
    If there is a type declared with bounds, for example
    
        class NumberList<T extends Number> implements List<T>
    
    but used with an unbounded wildcard
    
        NumberList<?> getList()
    
    the bounds are actually implicit and need to be taken into account for the
    static type checks, to be able to use the type of the parameter directly:
    
        getList()[0].longValue()
    
    The type of the element is known to be Number, not Object.

----
;;;","28/Nov/15 19:58;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/197
;;;","28/Nov/15 20:00;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy category throwing MissingMethodException and MissingPropertyException when using multiple threads,GROOVY-7535,12850632,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,joswald,joswald,31/Jul/15 15:55,06/Mar/18 23:14,14/Jul/23 06:01,26/May/17 00:07,2.3.11,2.4.4,,,,,,,,,,,,,,,,2.4.12,,,,,,,,0,,,,,,,"When using groovy use block, we randomly get groovy.lang.MissingPropertyException when trying to access a property off a category.  (Attached is an example)



{quote}
index 76
Exception in thread ""Thread-77"" groovy.lang.MissingPropertyException: No such property: millisecond for class: java.lang.Integer
		at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:51)
		at org.codehaus.groovy.runtime.callsite.PojoMetaClassGetPropertySite.callGetProperty(PojoMetaClassGetPropertySite.java:43)
		at TimeCategoryTest$__spock_initializeFields_closure1$_closure4$_closure5.doCall(TimeCategoryTest.groovy:23)
		at TimeCategoryTest$__spock_initializeFields_closure1$_closure4$_closure5.doCall(TimeCategoryTest.groovy)
		at sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
		at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.lang.reflect.Method.invoke(Method.java:497)
		at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
		at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
		at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
		at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1016)
		at groovy.lang.Closure.call(Closure.java:423)
		at groovy.lang.Closure.call(Closure.java:417)
		at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.use(GroovyCategorySupport.java:109)
		at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.access$400(GroovyCategorySupport.java:65)
		at org.codehaus.groovy.runtime.GroovyCategorySupport.use(GroovyCategorySupport.java:249)
		at org.codehaus.groovy.runtime.DefaultGroovyMethods.use(DefaultGroovyMethods.java:403)
{quote}
or groovy.lang.MissingMethodException when trying to access a method from a category.
{quote}
index 82
Exception in thread ""Thread-207"" groovy.lang.MissingMethodException: No signature of method: java.lang.String.test() is applicable for argument types: (java.lang.String) values: [ bar]
Possible solutions: next(), toSet(), getAt(java.lang.String), wait(). trim(), toList()
		at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:56)
		at org.codehaus.groovy.runtime.callsite.PojoMetaClassSite.call(PojoMetaClassSite.java:46)
		at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:122)
		at CategoryTest$__spock_initializeFields_closure1$_closure5.doCall(CategoryTest.groovy:24)
		at CategoryTest$__spock_initializeFields_closure1$_closure5.doCall(CategoryTest.groovy)
		at sun.reflect.GeneratedMethodAccessor12.invoke(Unknown Source)
		at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.lang.reflect.Method.invoke(Method.java:497)
		at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
		at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
		at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
		at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1016)
		at groovy.lang.Closure.call(Closure.java:423)
		at groovy.lang.Closure.call(Closure.java:417)
		at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.use(GroovyCategorySupport.java:109)
		at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.access$400(GroovyCategorySupport.java:65)
		at org.codehaus.groovy.runtime.GroovyCategorySupport.use(GroovyCategorySupport.java:249)
		at org.codehaus.groovy.runtime.DefaultGroovyMethods.use(DefaultGroovyMethods.java:403)
{quote}
On the server, either one of these exceptions to appear every few days or weeks.

I found a similar issue GROOVY-2105 which contains a test that reproduces this problem on Linux.  Looking back the fix that was implemented for this ticket was to add synchronized to 3 methods.  These changes were late removed in a refactor of GroovyCategorySupport.

I have attached 3 test cases that reproduce the threading issue.  

NOTE: problem does not happen 100% of the time as it is a threading and timing issue, so you may have to play with the number of threads to generate the exception.  What I have attached generates the exception on my linux box most of the time.","I have been able to reproduce this issue on a Cent O/S version 6.4 with Java 64 Bit JDK 1.8 and groovy 2.4.4.
",blackdrag,githubbot,jkemnade,joswald,jwagenleitner,pascalschumacher,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"15/May/17 06:53;jkemnade;0001-GROOVY-7535-fix-race-condition-between-the-modificat.patch;https://issues.apache.org/jira/secure/attachment/12868010/0001-GROOVY-7535-fix-race-condition-between-the-modificat.patch","31/Jul/15 15:56;joswald;CategoryTest.groovy;https://issues.apache.org/jira/secure/attachment/12748190/CategoryTest.groovy","31/Jul/15 15:56;joswald;Test.groovy;https://issues.apache.org/jira/secure/attachment/12748193/Test.groovy","31/Jul/15 15:56;joswald;TimeCategoryTest.groovy;https://issues.apache.org/jira/secure/attachment/12748194/TimeCategoryTest.groovy","31/Jul/15 15:56;joswald;exceptionForCategoryTest.txt;https://issues.apache.org/jira/secure/attachment/12748191/exceptionForCategoryTest.txt","31/Jul/15 15:56;joswald;exceptionForTimeCategoryTest.txt;https://issues.apache.org/jira/secure/attachment/12748192/exceptionForTimeCategoryTest.txt","19/May/17 07:32;jkemnade;locking.png;https://issues.apache.org/jira/secure/attachment/12868898/locking.png",,7.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Important,,,,,,,,,9223372036854775807,,,Fri May 26 06:43:51 UTC 2017,,,,,,,,,,"0|i2i6qv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Oct/15 21:49;joswald;From GROOVY-2105: 
The methods in question are org.codehaus.groovy.runtime.GroovyCategorySupport#newScope, org.codehaus.groovy.runtime.GroovyCategorySupport#endScope and org.codehaus.groovy.runtime.GroovyCategorySupport#hasCategoryInAnyThread

https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/runtime/GroovyCategorySupport.java#L82;;;","28/Oct/15 19:05;pascalschumacher;Hi James,

thanks for reporting this. :)

Sadly I could not replicate the problem with groovy 2.4.5 (on windows) and your testcase (tried different times and different amounts of threads).

I guess that's just caused by platform differences as I do not remember any changes in 2.4.5 related to this problem and [GroovyCategorySupport.java|https://github.com/apache/incubator-groovy/blob/d3bc07e5c2af7f5fbd344a961d549772de0680c7/src/main/org/codehaus/groovy/runtime/GroovyCategorySupport.java] looks like it could have concurrency issues.
;;;","29/Oct/15 07:18;blackdrag;sorry, first had answered on dev, because I thought it was a normal thread :) What kind of cpu are you using James?

As for the change, the explicit synchronization was removed by a logic using an AtomicInteger and an int to allow unsychronized checks for category usage. The idea is the following: A category is only visible in the same thread that it is used, so updates to categoriesInUse from the same thread are visible and hasCategoryInCurrentThread will return true. For the actual counting of the number of active categories overall we use the AtomicInteger atomicCategoryUsageCounter, which will also be used to update categoriesInUse. hasCategoryInAnyThread should always return true if any category is active. The actual building of the category methods list happens in a thread local and is read in a thread local. I would love to learn where this all fails.;;;","29/Oct/15 13:34;joswald;My dev box has 4 Xeon(R) CPU E5-1607 0 @ 3.00GHz with 16Gigs of ram.  
(Not sure if its cores or separate CPUs.  Linux reports them to me as 4 CPUs.)

The servers I've seen this on were VMs with 8 Cores and 16 Gigs of Ram. 

Both systems were running Cent O/S.;;;","31/Oct/15 19:39;githubbot;GitHub user ksuderman opened a pull request:

    https://github.com/apache/incubator-groovy/pull/169

    Non-atomic use of atomicCategoryUsageCounter

    The atomicCategoryUsageCounter was Incremented/decremented on one line and and then read on the next line leaving a small window for race conditions to happen.  This is a possible fix for https://issues.apache.org/jira/browse/GROOVY-7535


You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/ksuderman/incubator-groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/169.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #169
    
----
commit 919e90a15bd2ec6de2e015eee8e2e77a8f5f1bd5
Author: Keith Suderman <suderman@cs.vassar.edu>
Date:   2015-10-31T19:11:33Z

    Fixed non-atomic use of atomicCategoryUsageCounter.

commit 3025ed2cd7a80cf49403fe1205f22cb815f5f78b
Author: Keith Suderman <suderman@cs.vassar.edu>
Date:   2015-10-31T19:14:16Z

    Merge branch 'master' of https://github.com/apache/incubator-groovy

----
;;;","31/Oct/15 22:12;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/169
;;;","31/Oct/15 23:22;pascalschumacher;[~joswald] I merged the pull request. It would be nice if you could use a snapshoot version (e.g. [http://ci.groovy-lang.org/repository/download/Groovy_Jdk7Build/29066:id/target/distributions/apache-groovy-binary-2.5.0-SNAPSHOT.zip]) to test if this fixes the issue. Thanks!;;;","01/Nov/15 13:40;pascalschumacher;[~joswald] I'm resolving this for now. Please reopen if the fix does not solve the issue completely. Thanks!;;;","11/May/17 14:30;jkemnade;I can actually reproduce this issue with Groovy 2.4.11 on Debian with OpenJDK Runtime Environment (build 1.8.0_131-8u131-b11-1-b11). I'm using
{code}
class TestCategory {
    def static String test(String self, String foo) {
        return self + foo
    }
}

def test = {
    1000000.times {
        sleep(10)
        use(TestCategory) {
            assert ""foo"".test(' bar') == 'foo bar'
            assert ""foo"".test(' bar') == 'foo bar'
            assert ""foo"".test(' bar') == 'foo bar'
            assert ""foo"".test(' bar') == 'foo bar'
        }
        sleep(50)
        
    }
}


1000.times {
    Thread.start test
}
{code};;;","11/May/17 14:36;jkemnade;I can also reproduce it with 2.5.0-alpha-1. Can we please reopen this?;;;","11/May/17 15:22;paulk;I haven't had time to explore this issue, but just a meta-comment. Do we believe the applied PR fixed something or nothing? If nothing, I'd re-open and remove the fix version; otherwise, I'd leave this one as is so that the fix version for whatever was fixed is tracked and I'd clone the issue and describe what remains to be fixed (if not exactly as per the current description).;;;","12/May/17 07:28;jkemnade;The first part of the PR should not have changed anything. {{categoriesInUse}} is merely used as a flag, so if another thread increments the value to n+1, it will still be {{!=0}} in {{hasCategoryInCurrentThread}}.
I'm unsure about the second part, but I think it didn't have any effect either for about the same reason as above. The error happens when {{categoriesInUse}} is {{0}}. This can only happen if there is only 1 thread running, so there is no race condition. I might be overlooking something here though.
However, I think the race condition happens somewhere else:
{{DefaultMetaClassInfo.setCategoryUsed(false)}} is called in {{endScope}} if {{atomicCategoryUsageCounter}} was {{0}} further above. But another thread might have entered {{newScope}} in between, incrementing {{atomicCategoryUsageCounter}} again. So I think, we need some synchronization around {{atomicCategoryUsageCounter.get}} and {{DefaultMetaClassInfo.setCategoryUsed(false)}}.;;;","12/May/17 07:51;jkemnade;Patch attached, I'm currently testing it.;;;","12/May/17 08:13;jkemnade;Unfortunately, the patch doesn't fix it.;;;","12/May/17 09:01;blackdrag;[~jkemnade] your change synchronizes the categoriesInUse == 0 case, but with what? you need to also synchronize the increment place;;;","12/May/17 09:14;jkemnade;I don't think so. I'm not synchronizing the decrement but the call of the {{DefaultMetaClassInfo.setCategoryUsed(false)}}. I thought that the bug (or MME) is caused by the state in {{DefaultMetaClassInfo}}, but apparently that isn't the case. Even if i remove {{DefaultMetaClassInfo.setCategoryUsed(false)}} altogether, the issue persists.;;;","12/May/17 10:24;blackdrag;Since the removal of setting it to false did not do it, it is probably a different issue, yes.;;;","12/May/17 12:03;jkemnade;I can reproduce the error with 1.8.0 but not with 1.7.x (so far). I tried to do a bisect earlier, but those old versions are pretty hard to build.;;;","12/May/17 12:27;jkemnade;Alright, I can reproduce it with 1.8.0-beta-3 but not with 1.8.0-beta-2. Could it be https://github.com/apache/groovy/commit/8e489ce9da4ebf21b6717b656e2ffff225244ca6?;;;","12/May/17 12:53;jkemnade;A quick git bisect session also leads to that commit.;;;","14/May/17 05:15;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/540

    GROOVY-7535: Groovy category throwing MissingMethodException and Miss…

    …ingPropertyException when using multiple threads

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy groovy7535

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/540.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #540
    
----
commit 1c2ca41491fd919ddc1c543ec92a8ab7ca3b860b
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-05-14T01:51:47Z

    GROOVY-7535: Groovy category throwing MissingMethodException and MissingPropertyException when using multiple threads

----
;;;","15/May/17 06:52;jkemnade;Oh, the race condition occurs between the modification of the {{AtomicInteger}} and the assignment of the return value to the {{int}} field.
I created a minimalistic patch that fixes it. But the PR LGTM too.;;;","15/May/17 06:55;jkemnade;I think that this issue should be reopened as it seems to affect all versions since 1.8.0.;;;","15/May/17 15:07;jwagenleitner;The updated patch looks good, though it does seem to me that if the counters are going to be synchronized that the {{DefaultMetaClassInfo.setCategoryUsed}} calls should be included in the block as well.  Otherwise it could be called with {{false}} just after another thread got done calling with {{true}}.

The updated attached patch keeps the two counters, it seems like the {{int}} counter was kept for performance for the method {{hasCategoryInCurrentThread}} since that's called frequently from the callsite logic.;;;","15/May/17 18:25;blackdrag;I don´t get the patch... isn´t the sole purpose of AtomicInteger to make those operations like incrementAndGet and decrementAndGet atomic enough to share it between threads? Isn´t it likely the race condition is actually something else and if this fixes the problem it does so by chance (maybe piggybacking synchronization)?;;;","15/May/17 21:11;jwagenleitner;[~blackdrag] - as [~jkemnade] pointed out, there is a race condition between threads when writing to the {{private static int categoriesInUse}} counter as there is no guarantee that the values returned from calls to the Atomic will be written in the same order.  The scenario is:

1.  T1 in {{endScope}} calls {{atomicCategoryUsageCounter.decrementAndGet()}} and receives {{0}}
2.  T2 in {{newScope}} calls {{atomicCategoryUsageCounter.incrementAndGet()}} and receives {{1}}
3.  T2 assigns {{categoriesInUse}} a value of {{1}}
4.  T1 assigns {{categoriesInUse}} a value of {{0}}
5.  Callsite called from T2 calls {{hasCategoryInCurrentThread}} and return is {{false}}

The patch and PR both fix this by introducing ordering to the {{atomicCategoryUsageCounter}} return value and the write to {{categoriesInUse}}.  Another way to fix without synchronizing would be to remove the int counter and just use the AtomicInteger.  However, my hunch is that the int counter was retained because {{hasCategoryInCurrentThread}} is probably called frequently so there might have been some performance concern over requiring a method call and a volatile read that the AtomicInteger would incur in order to implement the quick exit check for that method {{if (categoriesInUse == 0) return false}}.

There is also a race between scopes in calls to {{DefaultMetaClassInfo.setCategoryUsed}}, so I think it would also be good to add those calls to the synchronized blocks if they are added.;;;","16/May/17 06:43;jkemnade;Great explanation John. It took me a while to figure that out. ;-)
By the way, since the PR synchronizes the modification of {{categoriesInUse}}, the {{AtomicInteger}} could be removed altogether.;;;","16/May/17 08:09;blackdrag;[~jwagenleitner] and [~jkemnade] maybe I am now looking stupid, but I still do not get it. If categoriesInUse is the problem, then why do you not have to synchronize all reads and writes to it? I am especially thinking here about hasCategoryInCurrentThread. Even if endScope and newScope are synchronized, since hasCategoryInCurrentThread is not, it can lead to T1 and T2 still having different values for it. 

The reason categoriesInUse even exists is for performance. reaplace it by directly using the AtomicInteger and see what happens. Or by synchronizing the read in hasCategoryInCurrentThread. And do not forget, that is a cost we basically pay on each method invocation during callsite caching. Indy is using the dEfaultMetaClassInfo logic, but I assume it has the same synchronizationn problem;;;","16/May/17 08:38;jkemnade;With the PR, all writes are synchronized. Here's why I think that the reads are fine without synchronization/{{volatile}} (correct me if I'm wrong):
Even if each thread uses its working copy of the {{categoriesInUse}} field , the copy may have the wrong value, but it can not be ""significantly wrong"".
The other thread may have incremented the value, but not from 0 to 1 as the current thread will already have set it to a value {{>0}}, so it won't change the value of {{categoriesInUse == 0}}, which is the only thing that matters for the early exit in {{hasCategoryInCurrentThread}}.
The other thread may also have decremented the value, but it cannot have set it to 0 if the current thread incremented it in {{newScope}}, so it would not have effected {{categoriesInUse == 0}} either.;;;","16/May/17 08:56;jkemnade;Why don't we just use a {{ThreadLocal<Boolean>}} for {{hasCategoryInCurrentThread}}?
{code}
        private void newScope () {
            synchronized (lock) {
                categoriesInUse++;
                DefaultMetaClassInfo.setCategoryUsed(true);
            }
            hasCategoryInCurrentThread.set(Boolean.TRUE);
            VMPluginFactory.getPlugin().invalidateCallSites();
            level++;
        }
{code}
and
{code}
        private void endScope () {
            ...
            synchronized (lock) {
                categoriesInUse--;
                if (categoriesInUse == 0) {
                    DefaultMetaClassInfo.setCategoryUsed(false);
                }
                hasCategoryInCurrentThread.remove();
            }
           ...
        }
{code}
and
{code}
    public static boolean hasCategoryInCurrentThread() {
        if (hasCategoryInCurrentThread.get() != Boolean.TRUE) return false;
        ThreadCategoryInfo infoNullable = THREAD_INFO.getInfoNullable();
        return infoNullable != null && infoNullable.level != 0;
    }
{code};;;","16/May/17 14:30;blackdrag;You said ""The other thread may have incremented the value, but not from 0 to 1 as the current thread will already have set it to a value >0"". Why is that not the case for the AtomicInteger alone and without synchronized? For me that should have been the same. Explain me this difference and I may be able to understand why it is a solution ;)

As for The ThreadLocal... well.. try it out. The speed was horrible last time I tried

;;;","16/May/17 14:46;jwagenleitner;I agree that synchronizing the read in {{hasCategoryInCurrentThread()}} is not required because of the nature of how it's used.  At worst stale non-zero values will cause it to fall back to checking the ThreadLocal with will result in the correct return value.  And when in a Category the same thread would have incremented the counter so whatever version of the value it sees should be non-zero.

{quote}By the way, since the PR synchronizes the modification of categoriesInUse, the AtomicInteger could be removed altogether.{quote}

If that were done then {{hasCategoryInAnyThread()}} would need to synchronize on the same lock when reading the value of the counter.

{quote}Why don't we just use a ThreadLocal<Boolean> for hasCategoryInCurrentThread{quote}

I think the {{THREAD_INFO.getInfoNullable()}} retrieves a ThreadLocal value if within a category and so that alone should be enough (i.e., no reason to add another ThreadLocal).  The int counter is a performance optimization to quicky exit since this method is called from each callsite.


;;;","16/May/17 15:07;jkemnade;It's the other case that makes the difference and that leads to the error, the one where the other thread sets the value to 0 even though the current thread is still using a category.
I think John's explanation shows the problem pretty well, so I'll rather show you another possible way to fix the issue:
{code}
diff --git a/src/main/org/codehaus/groovy/runtime/GroovyCategorySupport.java b/src/main/org/codehaus/groovy/runtime/GroovyCategorySupport.java
index 4c36935df..42533a5f7 100644
--- a/src/main/org/codehaus/groovy/runtime/GroovyCategorySupport.java
+++ b/src/main/org/codehaus/groovy/runtime/GroovyCategorySupport.java
@@ -72,7 +72,9 @@ public class GroovyCategorySupport {
         private Map<String, String> propertySetterMap;
 
         private void newScope () {
+            synchronized(atomicCategoryUsageCounter){
               categoriesInUse = atomicCategoryUsageCounter.incrementAndGet();
+            }
             DefaultMetaClassInfo.setCategoryUsed(true);
             VMPluginFactory.getPlugin().invalidateCallSites();
             level++;
@@ -95,7 +97,9 @@ public class GroovyCategorySupport {
                 }
             }
             level--;
+            synchronized(atomicCategoryUsageCounter){
               categoriesInUse = atomicCategoryUsageCounter.decrementAndGet();
+            }
             VMPluginFactory.getPlugin().invalidateCallSites();
             if (categoriesInUse==0) DefaultMetaClassInfo.setCategoryUsed(false);
             if (level == 0) {
{code}
This would also fix the problem that the modification of the {{AtomicInteger}} and the assignment of its current value to the {{int}} field are two separate steps.
The problem is not that the other thread will have changed the {{AtomicInteger}} incorrectly but that it will have assigned an outdated value to the {{int}} field.

bq. As for The ThreadLocal... well.. try it out. The speed was horrible last time I tried
yes, I guessed so. Well, if we remove the {{AtomicInteger}} from the PR version, the code will effectively have the same semantics as if we were using a {{ThreadLocal}}.;;;","16/May/17 15:12;jkemnade;bq. If that were done then hasCategoryInAnyThread() would need to synchronize on the same lock when reading the value of the counter.
I think we can do that without causing much trouble, {{hasCategoryInAnyThread()}} is unused anyway.;;;","16/May/17 15:17;jkemnade;bq.  At worst stale non-zero values will cause it to fall back to checking the ThreadLocal with will result in the correct return value.
I don't think that we will get relevant stale values. That's what I meant with ""significantly wrong"". A stale value would only lead to different behavior if it was 0 where the real value was != 0 or vice versa. And AFAICT, neither of that can happen.;;;","18/May/17 06:13;jkemnade;The updated PR looks good to me.;;;","18/May/17 19:47;blackdrag;ok, let me propose an alternative fix... remove categoriesInUse and use atomicCategoryUsageCounter directly instead;;;","18/May/17 20:22;jwagenleitner;I updated the PR, my assumption still being that it is important that {{DefaultMetaClassInfo.setCategoryUsed(true)}} is set any time a thread is in a Category so that is why there is still a need to synchronize the atomic increment/decrement and the calls to {{DefaultMetaClassInfo.setCategoryUsed}}.;;;","18/May/17 20:38;blackdrag;John, I thought this information is not used in the test;;;","18/May/17 20:45;jwagenleitner;That is true, I have not been able to find a problem that is caused by the race condition if the flags set by {{setCategoryUsed}} called with {{false}} when another thread enters a Category.  But without the sync it's very possible for one thread to set it to false just after another thread set it to true.;;;","18/May/17 21:37;blackdrag;I think I am ok with the change in total now. ;;;","19/May/17 06:52;jkemnade;I actually liked the previous version better. Synchronizing the write access to the AtomicInteger feels awkward. It shouldn't have a negative effect on the performance though, because the lock inside the AtomicInteger should always be available right away.
But using an AtomicInteger instead of an int in hasCategoryInCurrentThread will add the potential for a lock congestion where no locking is actually required.
I'll try to perform some benchmarks and try out another version that uses a ReentrantReadWriteLock.;;;","19/May/17 07:24;jkemnade;It doesn't make much of a difference. Pretty much all of the locking happens in {{IndyInterface.invalidateSwitchPoints}}.;;;","19/May/17 08:02;jkemnade;Oh, that's GROOVY-7811;;;","19/May/17 15:34;jwagenleitner;The {{AtomicInteger#get}} shouldn't lock but would be a {{volatile}} read (and other methods use CAS and not locks).  While I don't think having that volatile read in {{hasCategoryInCurrentThread}} will cause too much of a performance issue, I do agree that it's awkward to be using the {{AtomicInteger}} in the synchronized blocks.  Given that there is only a need to observe 0 or non-Zero for {{categoriesInUse}} and a precise number does not matter, except when decrementing which is synchronized. I also think the {{int}} counter version is better as long as there's a [some comment|https://github.com/apache/groovy/pull/540/commits/6fddddb2a39741d68358701230a929728338e7aa] to explain why there is no synchronized read in {{hasCategoryInCurrentThread}}.  In either case, I think one additional change should be to deprecate the {{hasCategoryInAnyThread}} method.

I think the original fix that was put into 2.4.6 did not fix the issue and may have just reduced the number of instructions that the threads could interleave on in order to reproduce.  I'd like to see what others think, if in agreement then as [~paulk] mentioned this should be re-opened.;;;","19/May/17 20:14;blackdrag;In that case my suggestion would be to do the synchronization as is, but use int instead of AtomicInteger;;;","23/May/17 09:47;jkemnade;Agreed. The current PR looks good to me again/still.

bq. I think the original fix that was put into 2.4.6 did not fix the issue.
Also agreed. ;-);;;","25/May/17 23:38;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/540
;;;","26/May/17 00:05;jwagenleitner;Since there is agreement that the original fix [PR 169|https://github.com/apache/incubator-groovy/pull/169] did not resolve the issue, re-opening in order to update the fix version to 2.4.12.;;;","26/May/17 00:07;jwagenleitner;Thanks for reporting the issue and thanks to [~jkemnade] for investigating the fix and patch.;;;","26/May/17 00:13;paulk;Nice work everyone!;;;","26/May/17 06:43;jkemnade;Thanks guys, I learned some interesting things from this.;;;"
disjoint() does not work correctly if objects don't implement Comparable,GROOVY-7530,12850207,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,tahlers,tahlers,30/Jul/15 10:16,12/Jun/16 08:45,14/Jul/23 06:01,03/Mar/16 12:27,2.4.4,,,,,,,,,,,,,,,,,2.4.7,,,,groovy-runtime,,,,5,,,,,,,"{code:java}
class Foo {

    private String name

    Foo(String name) {
        this.name = name
    }

    public boolean equals(Object o) {
        if (this == o) return true
        if (o == null || getClass() != o.getClass()) return false
        Foo that = (Foo) o
        return Objects.equals(name, that.name)
    }

    public int hashCode() {
        return Objects.hash(name)
    }

}

def a = [new Foo(""foo"")]
def b = [new Foo(""foo"")]    
assert !a.disjoint(b)
{code}

If disjoint() is used on a list with objects not implementing Comparable the wrong result is returned.
intersect() shows the same wrong behavior.

It's looks like the NumberAwareComparator not implementing the equals case as of commit 286532c is the problem.",,apreston,blackdrag,githubbot,jeegar12,kekekevin,paulk,sascha,tahlers,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7602,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 17 09:19:39 UTC 2016,,,,,,,,,,"0|i2i45z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Sep/15 06:38;jeegar12;Please would you make this Fix ASAP, as this is causing vulnerability issues in our project.;;;","03/Sep/15 06:56;blackdrag;If it is non-static Groovy code calling the method, you can provide your own extension module to provide this method by yourself and overwrite the version in the runtime as at quick fix. As for the vulnerability, it would be nice to have explained how. Because otherwise a fix of this (if done), may not fix your problem.;;;","03/Sep/15 19:52;kekekevin;{code:title=compare.groovy}
class Foo {

    private String name

    Foo(String name) {
        this.name = name
    }

    boolean equals(o) {
        if (this.is(o)) return true
        if (getClass() != o.class) return false

        Foo that = (Foo) o

        if (name != that.name) return false

        return true
    }

    int hashCode() {
        return Objects.hash(name)
    }

}


def a = [new Foo(""foo"")]
def b = [new Foo(""foo"")] as Object[]

a.removeAll(b)
assert !a

def c = [new Foo(""foo"")]
def d = [new Foo(""foo"")] as Object[]

c.retainAll(d)
assert c
{code}

Seems like this will also fail for certain implementations of removeAll and retainAll.  Since NumberAwareComparator seems to be the root cause of this issue, there could be quite a few extension methods required to workaround this issue.  Would you happen to know if there are additional instances where NumberAwareComparator is the only source of comparison?

Also, while it may be possible to implement Comparable on objects in which I control the source, any objects that are imported are beyond my control.;;;","13/Oct/15 06:04;jeegar12;I agree with Kevin on this! 
Can we get this fixed at the base class level?;;;","04/Jan/16 21:36;apreston;Hi Tobias - would you be able to raise this fix for priority?  We need to remediate vulnerability issues asap.;;;","04/Jan/16 23:58;paulk;I'm still keen to understand if there is a vulnerability issue. Jeegar can you elaborate further? Do you mean security vulnerability? Or just that it doesn't behave as you expected?;;;","05/Jan/16 12:46;blackdrag;if there is an issue about talking about the security problem per se, then I suggest mailing either us directly by mail or to use the apache security infrastructure through http://www.apache.org/security/;;;","05/Jan/16 17:37;apreston;Paul/Jochen - apologies for the lack of clarity.  In order to mitigate a security vulernability with Groovy 1.7.0 through 2.4.3 (CVE-2015-3253) we attempted to upgrade to 2.4.4 where we are running into this disjoint not working properly.  I will defer to Jeegar to clarify his comment.;;;","06/Jan/16 09:39;blackdrag;Ok, thanks for the clarification. We had been very very much irritated by this code causing a vulnerability issue. It is not out of question, since the example exploit for CVE-2015-3253 you mentioned actually does misuse a sorting structure in Java for the exploit. so I could not totally exclude such a possibility.

Anyway... back to the problem.
{code:Java}
def a = [new Foo(""foo"")]
def b = [new Foo(""foo"")]    
assert !a.disjoint(b)
{code}
The basic problem is as follows.. if the objects are somehow comparable, then you can do disjoint in O(nlogn), by first sorting one and then checking against the other. If the objects are not comparable and if I can only check for equality, then I am required to use an O(n*n) approach, by checking each elements of one list, against each of the other.. well it is more like n*n/2, but that does not matter when looking at the complexity. So in older versions we first did check both lists if all elements are Comparable, to then later decide on the strategy and go with the nlogn of the n*n variant. But this approach did also not get the desired results, as can be seen in the test in 286532c 

But I am wondering now... maybe the better approach is to add one more check like {code:java}
if (o1.getClass()==o2.getClass() && (o1.equals(o2)) return 0;
{code}
But I wonder what we are supposed to return if equals gives false. If we say we return only 0, we could also think about removing the class check. or we keep the class check and return -1 in case of equals returning false.;;;","08/Jan/16 22:22;kekekevin;The additional check you have outlined makes sense to me, but I think you might be able to drop the class check and defer that responsibility to equals().  If equals() returns false then return -1 would seem safe.;;;","08/Jan/16 22:35;kekekevin;Hm another consideration would be for the scenario in which the equals() is an expensive operation is that this additional check might only be warranted if the hashCodes are equal.;;;","10/Jan/16 09:47;blackdrag;yes, also a good idea... I do like this more, because it preserves that hashcode order in case of unrelated objects;;;","01/Mar/16 23:58;apreston;All - I see the fix version was removed.  Is there a future release date targeted for this fix? ;;;","02/Mar/16 02:16;paulk;We use the fix date to record the actual version in which it was fixed not the target one - unless it is a blocker when the two should coincide.;;;","02/Mar/16 11:40;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/276

    GROOVY-7530 and GROOVY-7602: intersect and disjoint broken for non-Co…

    …mparable objects (closes #276)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7530

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/276.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #276
    
----
commit d3692554fc6792b6e59dc9691dfbc1add168c86c
Author: paulk <paulk@asert.com.au>
Date:   2016-03-02T11:37:07Z

    GROOVY-7530 and GROOVY-7602: intersect and disjoint broken for non-Comparable objects (closes #276)

----
;;;","02/Mar/16 11:42;paulk;If I understood all the earlier comments, PR#276 should be what we require.;;;","03/Mar/16 12:13;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/276
;;;","03/Mar/16 12:27;paulk;merged PR;;;","16/May/16 16:02;apreston;Hi All - 

I see this is merged to fix version 2.4.7 - can you confirm when this will be released and available for download?

Thanks
Andre;;;","17/May/16 09:19;paulk;There is no date set at this stage. There are over twenty bug fixes already, so it would be good if we can do another release not too far down the track. You can grab snapshot artifacts in the meantime if you want.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Fix up transforms (apart from TupleConstructor) which are affected by empty includes default,GROOVY-7529,12850204,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,keegan,paulk,30/Jul/15 09:52,02/May/17 02:03,14/Jul/23 06:01,06/Aug/15 03:16,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,xforms,,,,0,breaking_change,,,,,,"I know this is a bit of an edge case, but I find the behavior doesn't follow what one would expect

{code:java}
assert Cat.class.declaredConstructors.size() == 1  // fails

@groovy.transform.TupleConstructor(includes=[])
class Cat {
  String name
  int age
}
{code}

This is a CLONE to cover the other transforms. TupleConstructor was fixed in GROOVY-7523.",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7523,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 06 03:28:47 UTC 2015,,,,,,,,,,"0|i2i45b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Jul/15 12:46;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/77

    GROOVY-7529: Fix up transforms (apart from TupleConstructor) which ar…

    …e affected by empty includes default

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7529

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/77.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #77
    
----
commit d6f398b344a6cda38f319e061d0ab1257361c1c7
Author: paulk <paulk@asert.com.au>
Date:   2015-07-30T12:44:57Z

    GROOVY-7529: Fix up transforms (apart from TupleConstructor) which are affected by empty includes default

----
;;;","31/Jul/15 16:12;githubbot;Github user keeganwitt commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/77#discussion_r35988461
  
    --- Diff: src/spec/doc/core-metaprogramming.adoc ---
    @@ -966,6 +966,25 @@ include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=
     ----
     |=======================================================================
     
    +[[xform-MapConstructor]]
    +===== @groovy.transform.MapConstructor
    +
    +The `@MapConstructor` annotation aims at eliminating boilerplate code by generating a map constructor for you. A map
    --- End diff --
    
    Should this also have an attribute table like the other transformations?
;;;","01/Aug/15 02:28;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/77#discussion_r36029568
  
    --- Diff: src/spec/doc/core-metaprogramming.adoc ---
    @@ -966,6 +966,25 @@ include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=
     ----
     |=======================================================================
     
    +[[xform-MapConstructor]]
    +===== @groovy.transform.MapConstructor
    +
    +The `@MapConstructor` annotation aims at eliminating boilerplate code by generating a map constructor for you. A map
    --- End diff --
    
    Yes, MapConstructor was missing from the documentation altogether. I added at least a placeholder but I'll probably try to add the doco in a separate commit and then rework this PR accordingly.
;;;","06/Aug/15 03:16;paulk;This is a breaking change for the specific edge case of explicitly providing an empty includes. If affected by this change, remove the explicit includes or use the marker value as per the respective annotation definitions.;;;","06/Aug/15 03:28;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/77
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Safe navigation broken on java fields with indy and @CompileStatic,GROOVY-7526,12849413,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,SparkyBluefang,SparkyBluefang,27/Jul/15 20:03,02/May/17 02:03,14/Jul/23 06:01,01/Aug/15 20:45,2.4.3,,,,,,,,,,,,,,,,,,,,,Static compilation,,,,0,,,,,,,"Trying to directly access a native Java object field, from a Groovy class compiled with invokedynamic and @CompileStatic, causes a ""java.lang.VerifyError: Bad type on operand stack"" error.

I have reproduced this on Linux with Groovy 2.4.3/2.4.4 and Java 1.7.0_80 (64bit).

{noformat}
~ $ cd /tmp/groovy_test/
/tmp/groovy_test $ rm -f com/*.class
/tmp/groovy_test $ javac com/*.java
/tmp/groovy_test $ /opt/groovy-2.4.4/bin/groovyc --indy --configscript config.groovyc com/*.groovy
/tmp/groovy_test $ java -cp .:/opt/groovy-2.4.4/lib/groovy-2.4.4.jar com.Test
{noformat}
{noformat}
Exception in thread ""main"" java.lang.VerifyError: Bad type on operand stack
Exception Details:
  Location:
    com/Controller.run()V @55: invokedynamic
  Reason:
    Type 'java/lang/Object' (current frame, stack[0]) is not assignable to 'java/lang/String'
  Current Frame:
    bci: @55
    flags: { }
    locals: { 'com/Controller', 'com/GroovyTool$Data', 'com/GroovyTool$Data', 'com/JavaTool$Data' }
    stack: { 'java/lang/Object' }
  Bytecode:
    0000000: b800 224c 2b57 2b59 4dc6 000a 2cb6 0028
    0000010: a700 0401 ba00 3600 0099 000d b200 3c12
    0000020: 3eb6 0044 0157 b800 494e 2d57 2d59 c700
    0000030: 06a7 0006 b400 4fba 0036 0000 9900 0db2
    0000040: 003c 1251 b600 4401 57b1               
  Stackmap Table:
    append_frame(@19,Object[#36],Object[#36])
    same_locals_1_stack_item_frame(@20,Object[#87])
    same_frame(@38)
    full_frame(@52,{Object[#2],Object[#36],Object[#36],Object[#75]},{Object[#75]})
    same_locals_1_stack_item_frame(@55,Object[#4])
    same_frame(@73)

	at java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2595)
	at java.lang.Class.getConstructor0(Class.java:2895)
	at java.lang.Class.newInstance(Class.java:354)
	at com.Test.loadController(Test.java:20)
	at com.Test.test(Test.java:30)
	at com.Test.main(Test.java:10)
{noformat}

Work arounds that I found:
* Remove @CompileStatic
* Disable --indy
* Cast the safely navigated field to it's object type i.e. (String)data?.field
* Define a getter method to use in lieu of the field.",,blackdrag,keegan,pascalschumacher,SparkyBluefang,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Jul/15 20:04;SparkyBluefang;groovy_test.tar.gz;https://issues.apache.org/jira/secure/attachment/12747406/groovy_test.tar.gz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 01 10:33:11 UTC 2015,,,,,,,,,,"0|i2hzfb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jul/15 20:04;SparkyBluefang;Test case;;;","29/Jul/15 18:59;keegan;I was able to reproduce this in both Gradle and Maven with GMavenPlus.  I'm not sure yet if this is helpful, but the bytecode for {{Controller.run()}} is
{noformat}
 0 invokestatic #34 <com/GroovyTool.getData>
 3 astore_1
 4 aload_1
 5 pop
 6 aload_1
 7 dup
 8 astore_2
 9 ifnull 19 (+10)
12 aload_2
13 invokevirtual #40 <com/GroovyTool$Data.getFieldData>
16 goto 20 (+4)
19 aconst_null
20 invokedynamic #54 <cast, BootstrapMethods #0>
25 ifeq 38 (+13)
28 getstatic #60 <java/lang/System.out>
31 ldc #62 <HAS JAVA TOOL DATA>
33 invokevirtual #68 <java/io/PrintStream.println>
36 aconst_null
37 pop
38 invokestatic #73 <com/JavaTool.getData>
41 astore_3
42 aload_3
43 pop
44 aload_3
45 dup
46 ifnonnull 52 (+6)
49 goto 55 (+6)
52 getfield #79 <com/JavaTool$Data.fieldData>
55 invokedynamic #54 <cast, BootstrapMethods #0>
60 ifeq 73 (+13)
63 getstatic #60 <java/lang/System.out>
66 ldc #81 <HAS GROOVY TOOL DATA>
68 invokevirtual #68 <java/io/PrintStream.println>
71 aconst_null
72 pop
73 return
{noformat}

Without indy, but with CompileStatic:
{noformat}
 0 invokestatic #34 <com/GroovyTool.getData>
 3 astore_1
 4 aload_1
 5 pop
 6 aload_1
 7 dup
 8 astore_2
 9 ifnull 19 (+10)
12 aload_2
13 invokevirtual #40 <com/GroovyTool$Data.getFieldData>
16 goto 20 (+4)
19 aconst_null
20 invokestatic #46 <org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox>
23 ifeq 36 (+13)
26 getstatic #52 <java/lang/System.out>
29 ldc #54 <HAS JAVA TOOL DATA>
31 invokevirtual #60 <java/io/PrintStream.println>
34 aconst_null
35 pop
36 invokestatic #65 <com/JavaTool.getData>
39 astore_3
40 aload_3
41 pop
42 aload_3
43 dup
44 ifnonnull 50 (+6)
47 goto 53 (+6)
50 getfield #71 <com/JavaTool$Data.fieldData>
53 invokestatic #46 <org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox>
56 ifeq 69 (+13)
59 getstatic #52 <java/lang/System.out>
62 ldc #73 <HAS GROOVY TOOL DATA>
64 invokevirtual #60 <java/io/PrintStream.println>
67 aconst_null
68 pop
69 return
{noformat}

Without CompileStatic, but with indy
{noformat}
 0 ldc #30 <com/GroovyTool>
 2 invokedynamic #44 <invoke, BootstrapMethods #0>
 7 invokedynamic #50 <cast, BootstrapMethods #1>
12 astore_1
13 aload_1
14 pop
15 aload_1
16 invokedynamic #57 <getProperty, BootstrapMethods #2>
21 invokedynamic #60 <cast, BootstrapMethods #1>
26 ifeq 44 (+18)
29 ldc #62 <java/lang/System>
31 invokedynamic #66 <getProperty, BootstrapMethods #3>
36 ldc #68 <HAS JAVA TOOL DATA>
38 invokedynamic #73 <invoke, BootstrapMethods #4>
43 pop
44 ldc #75 <com/JavaTool>
46 invokedynamic #44 <invoke, BootstrapMethods #0>
51 invokedynamic #78 <cast, BootstrapMethods #1>
56 astore_2
57 aload_2
58 pop
59 aload_2
60 invokedynamic #81 <getProperty, BootstrapMethods #2>
65 invokedynamic #60 <cast, BootstrapMethods #1>
70 ifeq 88 (+18)
73 ldc #62 <java/lang/System>
75 invokedynamic #66 <getProperty, BootstrapMethods #3>
80 ldc #83 <HAS GROOVY TOOL DATA>
82 invokedynamic #73 <invoke, BootstrapMethods #4>
87 pop
88 return
{noformat}

Neither CompileStatic or indy:
{noformat}
  0 invokestatic #23 <com/Controller.$getCallSiteArray>
  3 astore_1
  4 aload_1
  5 ldc #33 <0>
  7 aaload
  8 ldc #35 <com/GroovyTool>
 10 invokeinterface #41 <org/codehaus/groovy/runtime/callsite/CallSite.call> count 2
 15 ldc #43 <com/GroovyTool$Data>
 17 invokestatic #49 <org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType>
 20 checkcast #43 <com/GroovyTool$Data>
 23 astore_2
 24 aload_2
 25 pop
 26 aload_1
 27 ldc #50 <1>
 29 aaload
 30 aload_2
 31 invokeinterface #53 <org/codehaus/groovy/runtime/callsite/CallSite.callGetPropertySafe> count 2
 36 invokestatic #59 <org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox>
 39 ifeq 65 (+26)
 42 aload_1
 43 ldc #60 <2>
 45 aaload
 46 aload_1
 47 ldc #61 <3>
 49 aaload
 50 ldc #63 <java/lang/System>
 52 invokeinterface #66 <org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty> count 2
 57 ldc #68 <HAS JAVA TOOL DATA>
 59 invokeinterface #71 <org/codehaus/groovy/runtime/callsite/CallSite.call> count 3
 64 pop
 65 aload_1
 66 ldc #72 <4>
 68 aaload
 69 ldc #74 <com/JavaTool>
 71 invokeinterface #41 <org/codehaus/groovy/runtime/callsite/CallSite.call> count 2
 76 ldc #76 <com/JavaTool$Data>
 78 invokestatic #49 <org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType>
 81 checkcast #76 <com/JavaTool$Data>
 84 astore_3
 85 aload_3
 86 pop
 87 aload_1
 88 ldc #77 <5>
 90 aaload
 91 aload_3
 92 invokeinterface #53 <org/codehaus/groovy/runtime/callsite/CallSite.callGetPropertySafe> count 2
 97 invokestatic #59 <org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox>
100 ifeq 126 (+26)
103 aload_1
104 ldc #78 <6>
106 aaload
107 aload_1
108 ldc #79 <7>
110 aaload
111 ldc #63 <java/lang/System>
113 invokeinterface #66 <org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty> count 2
118 ldc #81 <HAS GROOVY TOOL DATA>
120 invokeinterface #71 <org/codehaus/groovy/runtime/callsite/CallSite.call> count 3
125 pop
126 return
{noformat};;;","30/Jul/15 08:02;blackdrag;A reduced example:{code:Java}
public class JavaTool {
    public static Data getData() {
        return new Data(""fieldDataString"")
    }

    public static class Data {
        public String fieldData;

        public Data(String fieldData) {
            this.fieldData = fieldData
        }
    }
}

@CompileStatic
def foo() {
    JavaTool.Data jdata = JavaTool.getData()
    if ( jdata?.fieldData ) {
        System.out.println(""HAS GROOVY TOOL DATA"")
    }
}
foo()
{code}
If run with indy enabled it will produce the exception noted in the issue;;;","30/Jul/15 08:20;blackdrag;The reduced bytecode of this is the following (using asm){code}
  // access flags 0x1
  public foo()Ljava/lang/Object;
   L0
    INVOKESTATIC JavaTool.getData ()LJavaTool$Data;
    ASTORE 1
   L2
    ALOAD 1
    DUP
    IFNONNULL L3
    GOTO L4
   L3
   FRAME FULL [test JavaTool$Data] [JavaTool$Data]
    GETFIELD JavaTool$Data.fieldData : Ljava/lang/String;
   L4
   FRAME SAME1 java/lang/Object
    INVOKEDYNAMIC cast(Ljava/lang/String;)Z [...]
    IFEQ L5
   L6
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    LDC ""HAS GROOVY TOOL DATA""
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
    ACONST_NULL
    ARETURN
{code}
The actual error is then to be found in the invokedynamic call for cast. The call expects a String on the stack, but the frame claims the stack element is of type Object. The @CompileStatic version does not have this problem since it will call booleanUnbox(Object)Z, then there is no type mismatch. But simulating this method call, will provoke the same error:{code:Java}
public class JavaTool {
    public static Data getData() {
        return new Data(""fieldDataString"")
    }

    public static class Data {
        public String fieldData;

        public Data(String fieldData) {
            this.fieldData = fieldData
        }
    }
}
boolean bar(String s){true}

@CompileStatic
def foo() {
    JavaTool.Data jdata = JavaTool.getData()
    if ( bar(jdata?.fieldData) ) {
        System.out.println(""HAS GROOVY TOOL DATA"")
    }
}
foo(){code}
now the method bar will make the boolean conversion and expect a String.  Without frame information this will then lead to ""java.lang.VerifyError: (class: test, method: foo signature: ()Ljava/lang/Object;\) Incompatible argument to function"" and forcing higher bytecodes, by for example using groovy.target.bytecode=1.7, will produce ""java.lang.VerifyError: Bad type on operand stack"". Since this is without indy I can identify this as a static compilation problem.
;;;","30/Jul/15 08:22;blackdrag;I have to add, that this problem might not be originally in compilestatic. It may be a general type propagation problem, that simply did not appear before;;;","30/Jul/15 09:09;blackdrag;seems like the bytecode comes directly from StaticCallSiteWriter#makeGetField. So no type propagation problem
Looking at the bytecode in more detail, the part of interest is actually {code}
    ALOAD 1                                                                                   // load jdata on stack
    DUP                                                                                          // have 2 jdata on stack
    IFNONNULL L3                                                                        // if top jdata==null goto L3 else goto L4. stack=jdata 
    GOTO L4
   L3
    GETFIELD JavaTool$Data.fieldData : Ljava/lang/String;         // get field value, stack=String
   L4
    INVOKEDYNAMIC cast(Ljava/lang/String;)Z [...]                     
{code}
so following the L3 branch we get to L4 with a String on the stack. Jumping directly to L4 we will have a jdata there instead.  We know that this jdata is null, but the type information the verifier has is not interested in that. Doing either a CHECKCAST, or simply poping the value and loading null, before GOTO L4 should solve the problem;;;","01/Aug/15 10:33;pascalschumacher;I guess you fixed the issue: [https://github.com/apache/incubator-groovy/commit/b573d5ce4f44a70598c343db15db0278efbbe17d]?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TupleConstructor with empty includes includes all,GROOVY-7523,12848735,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,keegan,keegan,23/Jul/15 23:26,02/May/17 02:03,14/Jul/23 06:01,06/Aug/15 03:17,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,xforms,,,,0,breaking_change,,,,,,"I know this is a bit of an edge case, but I find the behavior doesn't follow what one would expect

{code:java}
assert Cat.class.declaredConstructors.size() == 1  // fails

@groovy.transform.TupleConstructor(includes=[])
class Cat {
  String name
  int age
}
{code}",,githubbot,keegan,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7529,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 06 03:18:43 UTC 2015,,,,,,,,,,"0|i2hvaf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jul/15 23:57;keegan;It's probably not terribly likely, but it's worth mentioning this change could theoretically break existing code.;;;","24/Jul/15 01:33;keegan;Actually, as I'm reading this more, it might be fairly involved to change (even if only we only changed {{TupleConstructorASTTransformation}} and not {{AbstractASTTransformation.shouldSkip()}}) because {{AbstractASTTransformation.tokenize()}} defaults to an empty list, there's no way to tell the difference between passing an empty list and not passing anything by just inspecting the {{includes}} list alone.;;;","25/Jul/15 11:55;paulk;This slightly weird behavior reflects Java's slightly weird default annotation attribute behavior. In our case, we have:
{code}
String[] includes() default {};
{code}
So you are kind of forced to handle the empty list in the way we do. But we have improved the approach in more recent transforms, e.g. in {{Builder}} we have:
{code}
String builderMethodName() default Undefined.STRING;
{code}
We could introduce an undefined list and then make our code a bit cleaner and handle the empty case more appropriately.;;;","26/Jul/15 08:39;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/72

    GROOVY-7523: TupleConstructor with empty includes includes all

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7523

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/72.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #72
    
----
commit 03c99e456245c5d1866cae8c8b7b89b2d20a6d4a
Author: paulk <paulk@asert.com.au>
Date:   2015-07-26T08:37:19Z

    GROOVY-7523: TupleConstructor with empty includes includes all

----
;;;","26/Jul/15 08:52;paulk;PR#72 outlines what I meant by using the undefined list approach. We'd ultimately want to extend that approach to all of the affected transforms (just under 10 of them I think).;;;","30/Jul/15 06:35;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/72
;;;","06/Aug/15 03:18;paulk;This is a breaking change for the specific edge case of explicitly providing an empty includes. If affected by this change, remove the explicit includes or use the marker value as per the respective annotation definitions.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TupleConstructor overwrites declared constructors,GROOVY-7522,12848730,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,keegan,keegan,23/Jul/15 23:11,21/Nov/22 17:16,14/Jul/23 06:01,06/Aug/15 03:12,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,xforms,,,,0,breaking_change,,,,,,"{{@TupleConstructor}} should not overwrite existing empty default constructors.  For example, this should work, but doesn't currently

{code:java}
assert new Cat(""Mr. Bigglesworth"").name == null  // fails

@groovy.transform.TupleConstructor
class Cat {
  String name
  int age
  Cat(String name) {}
}
{code}

Granted, this is an edge case.  But unexpected behavior, nonetheless.",,githubbot,keegan,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10790,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 06 03:28:03 UTC 2015,,,,,,,,,,"0|i2hv9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jul/15 23:55;keegan;In theory, this could break someone's existing code if they were relying on the overwriting happening.  This could be avoided by adding a Boolean to control this behavior.;;;","24/Jul/15 01:46;keegan;This seems to be happening because {{TupleConstructorASTTransformation.createConstructor()}} has
{code:java}
if (constructors.size() > 1 && !force) return;
boolean foundEmpty = constructors.size() == 1 && constructors.get(0).getFirstStatement() == null;
if (constructors.size() == 1 && !foundEmpty && !force) return;
{code}

So, actually my example is an edge condition.  You only run into the problem if you provided 1 constructor and it was empty.  Unless I'm misunderstanding.;;;","24/Jul/15 02:19;keegan;So I guess the questions are
# Do we want to write just the missing constructors instead of having a no-op when existing constructors are encountered?
# If not, could we safely change to {{> 0}} instead of {{> 1}}?  Or is that unavoidable because of the possibility of stubs bringing in an extraneous constructor?

If we decide to leave as-is, maybe we'll re-purpose this Jira for documenting this edge case.;;;","25/Jul/15 10:48;paulk;Your understanding is correct that this is an edge case; the problem occurs because you are providing one empty constructor. You are also correct in your assessment that we can't change from {{> 1}} to {{> 0}} because of stubs.

In theory, we could make it smarter to write as you say ""just the missing constructors"". But it turns out to be a little more complex than you might expect. The tuple constructor generated makes use of Groovy's optional args. Then, in later compilation phases such constructors are replaced by the multiple equivalent Java constructors. E.g.:
{code}
@TupleConstructor
class Person { String first, last; int age }
{code}
would get this chain of generated constructors:
{code}
Person(String first, String last, int age)
Person(String first, String last)
Person(String first)
Person()
{code}
To work out what the missing ones are, you'd have to pre-calculate all of the final list of generated constructors for not only the @TupleConstructor generated one but any existing explicit ones using default parameters. Then there is the added complication of when there is a chain with an explicit duplicate in the middle. It's not clear whether the code generated for the missing variant(s) should call the code within the explicitly provided variant(s) or behave more like what the original tuple generated version would behave? Often, using {{force}} can help in some of the edge cases but not yours - it does the opposite of what you'd want.

This annotation was written prior to annotation aliases. Another potential solution to making such transforms smarter is to split it into two parts which run in different phases of the compiler. TupleConstructor would then become the alias to the other two parts. Having said that, I can't think of an obvious split that would help here.

So my recommendation is to take up your ""re-purpose"" option and improve the documentation for this edge case.;;;","26/Jul/15 05:14;keegan;Okie dokie.  Any other edge cases you can think of that I missed?;;;","26/Jul/15 05:44;paulk;Actually, thinking about it a bit more, perhaps we could change the stub code to use node metadata to indicate that it added an empty default constructor. That could allow a better workaround.;;;","26/Jul/15 15:08;keegan;Sorry for the spam of multiple edits, was having browser issues.;;;","28/Jul/15 13:47;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/75

    GROOVY-7522: TupleConstructor overwrites empty default constructors

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7522

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/75.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #75
    
----
commit 891aaa2f7f11afc4a62f0501ccae550f23c4ff05
Author: Paul King <paulk@asert.com.au>
Date:   2015-07-28T13:45:14Z

    GROOVY-7522: TupleConstructor overwrites empty default constructors

----
;;;","29/Jul/15 15:07;keegan;I updated the Jira, based on our conversation.;;;","06/Aug/15 03:13;paulk;Since this is a breaking change - only for the very specific edge case of an explicit empty includes - I am leaving in just the 2.5 stream.;;;","06/Aug/15 03:28;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/75
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Improve unimplemented message for abstract methods,GROOVY-7520,12848614,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,keegan,keegan,keegan,23/Jul/15 15:49,19/Oct/15 16:05,14/Jul/23 06:01,01/Aug/15 10:37,2.4.4,,,,,,,,,,,,,,,,,2.4.5,,,,Compiler,,,,0,,,,,,,"GROOVY-7081 caused the message to change for scenarios like
{code:java}
abstract class Module {
    abstract String getModuleName()
}
class Master extends Module {
    String title
    String track
}    
def master = new Master(title: ""Hello"", track: ""1"")
println master.title
{code}

The message went from
{quote}Can't have an abstract method in a non-abstract class. The class 'Master' must be declared abstract or the method 'java.lang.String getModuleName()' must be implemented.{quote}
to
{quote}Abstract method 'java.lang.String getModuleName()' is not implemented but a method of the same name but different return type is defined: method 'java.lang.String getModuleName()'{quote}",,githubbot,keegan,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7081,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 30 22:34:26 UTC 2015,,,,,,,,,,"0|i2hujz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jul/15 16:06;githubbot;GitHub user keeganwitt opened a pull request:

    https://github.com/apache/incubator-groovy/pull/71

    GROOVY-7520

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/keeganwitt/incubator-groovy GROOVY-7520

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/71.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #71
    
----
commit 21526ba7998b4c3588e2d03145a0dd12b4b29dbd
Author: Keegan Witt <keeganwitt@gmail.com>
Date:   2015-07-23T16:04:54Z

    GROOVY-7520

----
;;;","30/Jul/15 19:36;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/71
;;;","30/Jul/15 20:34;githubbot;GitHub user keeganwitt opened a pull request:

    https://github.com/apache/incubator-groovy/pull/78

    GROOVY-7520: Improve unimplemented message for abstract methods

    c3a802fe13a6fc7267130db805940bd2be41b4f8 accidentally included #71 instead of #68 in it's commit message.  I'm opening this PR to re-request the pull.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/keeganwitt/incubator-groovy GROOVY-7520

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/78.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #78
    
----
commit a4fba4baf019661e3a011bbaa9f1da8e506f9989
Author: Keegan Witt <keeganwitt@gmail.com>
Date:   2015-07-23T16:04:54Z

    GROOVY-7520: Improve unimplemented message for abstract methods

----
;;;","30/Jul/15 22:34;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/78
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonOuput.toJson() leads to StackOverflowException,GROOVY-7519,12848492,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,dariusan,dariusan,23/Jul/15 09:02,04/Jan/22 20:58,14/Jul/23 06:01,08/Sep/15 18:57,2.4.4,,,,,,,,,,,,,,,,,2.4.5,,,,JSON,,,,0,StackOverflowError,,,,,,"If one wants to generate JSON with groovy.json.JsonOutpout that contains a java.io.File object as property in the object hierarchy a StackOverflowException is thrown

{code}
groovy.json.JsonOutput.toJson(new File('.'))


java.lang.StackOverflowError
	at groovy.json.internal.CharBuf.addLong(CharBuf.java:788)
	at groovy.json.JsonOutput.writeNumber(JsonOutput.java:216)
	at groovy.json.JsonOutput.writeObject(JsonOutput.java:264)
{code}",,dariusan,githubbot,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 08 18:57:03 UTC 2015,,,,,,,,,,"0|i2httj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Aug/15 06:31;githubbot;GitHub user eginez opened a pull request:

    https://github.com/apache/incubator-groovy/pull/105

    GROOVY-7519: Fixes JsonOuput.toJson() leads to StackOverflowException

    JsonOutput overflows when serializing a File due to recursive references to File objects. Namely getAbsoluteFile(), getCanonicalFile(), and getParentFile(). These properties will be properly serialized by their counterpart methods getAbsolutePath(), getCanonicalPath() and getParent().

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/eginez/incubator-groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/105.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #105
    
----
commit 60ffaef99ec9ec48797188d3586cebdcffe8aea5
Author: Esteban <eginez@gmail.com>
Date:   2015-08-30T06:20:07Z

    GROOVY-7519: Fixes JsonOuput.toJson() leads to StackOverflowException

----
;;;","08/Sep/15 18:55;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/105
;;;","08/Sep/15 18:57;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
hashCode() throws NPE when using @CompileStatic with @EqualsAndHashCode,GROOVY-7518,12846910,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,riggs,riggs,22/Jul/15 14:42,19/Oct/15 16:11,14/Jul/23 06:01,30/Aug/15 11:13,2.4.4,,,,,,,,,,,,,,,,,2.4.5,,,,,,,,0,,,,,,,"Given the following class

{code:title=Person.groovy}
import groovy.transform.CompileStatic
import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode
@CompileStatic
class Person {
	Long someLong
}
{code}

and the test

{code:title=PersonTest.groovy}
import static org.junit.Assert.*

import org.junit.Test

class PersonTest {

	@Test
	void hashcodeWithoutLongValue() {
		def person = new Person()
		assert person.hashCode()
	}
}
{code}

and the gradle configuration:

{code:title=build.gradle}
buildscript {
    repositories {
        mavenCentral()
    }
}

apply plugin: 'groovy'
apply plugin: 'eclipse'

jar {
    baseName = 'HashCodeNPE'
    version = '0.0.1-SNAPSHOT'
}
sourceCompatibility = 1.8
targetCompatibility = 1.8

repositories {
    mavenCentral()
}


dependencies {
    compile(""org.codehaus.groovy:groovy:2.4.4"")
	testCompile(""junit:junit:4.12"")
}


eclipse {
    classpath {
         containers.remove('org.eclipse.jdt.launching.JRE_CONTAINER')
         containers 'org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8'
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.4'
}
{code}

when I run {code}gradle clean build{code}

then the test fails with the following message.

{code}
PersonTest > hashcodeWithoutLongValue FAILED
    java.lang.NullPointerException at PersonTest.groovy:10

1 test completed, 1 failed
:test FAILED
{code}

With Groovy 2.4.3 the test passes.",,blackdrag,githubbot,paulk,riggs,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 30 11:13:08 UTC 2015,,,,,,,,,,"0|i2hk3b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jul/15 05:07;paulk;I haven't checked 2.4.4 but in master we removed the use of the ""dynamic"" behavior of using InvokerHelper.getProperty. So the AST transform used to produce this:
{code}
public int hashCode() {
     java.lang.Object _result = HashCodeHelper.initHash()
    if (!(InvokerHelper.getProperty(this, 'someLong').is(this))) {
        _result = HashCodeHelper.updateHash(_result, InvokerHelper.getProperty(this, 'someLong'))
    }
    return _result 
}
{code}
but now produces this:
{code}
public int hashCode() {
    java.lang.Object _result = HashCodeHelper.initHash()
    if (!(this.getSomeLong() == this )) {
          _result = HashCodeHelper.updateHash(_result, this.getSomeLong())
    }
    return _result 
}
{code}
Though it's not immediately obvious to me why that would produce the NPE.

Standalone script to produce the error:
{code}
import groovy.transform.*

@EqualsAndHashCode
@CompileStatic
class Person {
    Long someLong
}

println new Person().hashCode()
{code};;;","23/Jul/15 05:39;blackdrag;to clarify, in Pauls example the NPE comes from unboxing this.getSomeLong(). SomeLong is a Long, and the HashCodeHelper method called here takes a long in that position, thus unboxing happens and is causing the NPE. The NPE would not happen with normal Groovy, because there would be no unboxing at this position, thus the Object taking variant will be called instead. Possible solution would be to move the null-check into the generated code and open the shift method, or to add the object variants of the primitives to HashCodeHelper, or one of the other 1000 possible solutions;;;","23/Jul/15 08:42;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/70

    GROOVY-7518: hashCode() throws NPE when using @CompileStatic with @Eq…

    …ualsAndHashCode

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7518

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/70.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #70
    
----
commit f4c2a91e81ea239303e1e7541d1a350b7fb80cff
Author: paulk <paulk@asert.com.au>
Date:   2015-07-23T08:41:15Z

    GROOVY-7518: hashCode() throws NPE when using @CompileStatic with @EqualsAndHashCode

----
;;;","30/Aug/15 10:29;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/70
;;;","30/Aug/15 11:13;paulk;merged a tweaked version of the PR to account for nulls as per Jochen's comment;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static final fields on trait aren't final,GROOVY-7514,12846627,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,chrylis,chrylis,21/Jul/15 18:11,01/Feb/17 23:18,14/Jul/23 06:01,28/Nov/16 19:48,2.4.4,,,,,,,,,,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"In order to work around the fact that {{@Slf4j}} doesn't work on traits, I declared an slf4j logger the traditional way:

{code}
private static final Logger slf4j = LoggerFactory.getLogger(Auditing)
{code}

However, the {{final}} keyword is ignored when the trait is applied to a class. From {{javap}}:

{code}
  private static org.slf4j.Logger com_artsquare_studio_audit_api_Auditing__slf4j;
  public static org.slf4j.Logger com_artsquare_studio_audit_api_Auditing__slf4j$get();
  public static org.slf4j.Logger com_artsquare_studio_audit_api_Auditing__slf4j$set(org.slf4j.Logger);
{code}",,chrylis,msgilligan,paulk,steinar.haugen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 28 19:48:39 UTC 2016,,,,,,,,,,"0|i2hidr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Nov/16 18:53;paulk;See the fix for GROOVY-7584 which covers this one too:
https://github.com/apache/groovy/pull/463

The test script I was using for testing purposes:
{code}
@Grab('org.slf4j:slf4j-simple:1.7.21')
import org.slf4j.LoggerFactory
import org.slf4j.Logger

trait Auditing {
    private static final Logger slf4j = LoggerFactory.getLogger(Auditing)
    def info(message) { slf4j.info(message) }
}

class Person implements Auditing {
  def foo() {
    info('hello')
  }
}

new Person().foo()
{code};;;","28/Nov/16 19:48;paulk;Fixed as per GROOVY-7584. I haven't done VOLATILE at this stage.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot call Trait method from Closure when using static compilation,GROOVY-7512,12846278,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,cesarizu,cesarizu,20/Jul/15 14:30,22/Feb/22 19:29,14/Jul/23 06:01,13/Jun/20 13:29,2.4.4,,,,,,,,,,,,,,,,,2.5.16,3.0.5,4.0.0-alpha-1,,Compiler,Static compilation,Static Type Checker,,0,,,,,,,"When running:

{code:title=test.groovy|borderStyle=solid}
class X {
    Closure action = {}
}

trait T {

    void say(String text) {
        println text
    }

    @groovy.transform.CompileStatic
    X getX() {
        new X(action: {
            say ""Hello!""
        })
    }

}

class A implements T {
}

new A().x.action()
{code}

The following exception is thrown:

{code}
Caught: java.lang.ClassCastException: java.lang.Class cannot be cast to T
java.lang.ClassCastException: java.lang.Class cannot be cast to T
	at T$Trait$Helper$_getX_closure1.doCall(test.groovy:14)
	at T$Trait$Helper$_getX_closure1.doCall(test.groovy)
	at test.run(test.groovy:23)
{code}

This is only happening on groovy 2.4.4. Removing the static compilation annotation or reverting to groovy version 2.4.3 makes the code work. 

The commit that is causing this problem seems to be: 1bbed25aa3a08bc0cb7e14e49a1e7c2b82f21a26",,cesarizu,emilles,,,,,,,,,,,,,,"eric-milles opened a new pull request #1274:
URL: https://github.com/apache/groovy/pull/1274


   - allow PostTypeCheckingExpressionReplacer to replace closure literals
   
   https://issues.apache.org/jira/browse/GROOVY-7512


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;11/Jun/20 22:15;githubbot;600","danielsun1106 merged pull request #1274:
URL: https://github.com/apache/groovy/pull/1274


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;13/Jun/20 13:28;githubbot;600","danielsun1106 commented on pull request #1274:
URL: https://github.com/apache/groovy/pull/1274#issuecomment-643623989


   Merged. Thanks.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;13/Jun/20 13:28;githubbot;600",,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 11 21:37:43 UTC 2020,,,,,,,,,,"0|i2hga7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jun/20 21:37;emilles;@CompileStatic replaces the map-style constructor call ""new X(action: ...)"" with an instance of org.codehaus.groovy.transform.sc.transformers.ConstructorCallTransformer.MapStyleConstructorCall.  This type does not apply ExpressionTransformer and so the post-type-checking replacement of closure expressions by org.codehaus.groovy.transform.trait.TraitASTTransformation.PostTypeCheckingExpressionReplacer is missed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static import of a static property causes joint compilation to fail,GROOVY-7510,12846180,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,shils,shils,19/Jul/15 20:34,03/Feb/22 22:32,14/Jul/23 06:01,25/Oct/21 23:03,2.4.4,,,,,,,,,,,,,,,,,4.0.0-beta-2,,,,Stub generator / Joint compiler,,,,0,,,,,,,"Due to the addition of static imports in generated stubs (per https://issues.apache.org/jira/browse/GROOVY-7366), the following test now fails:

{code}
package org.codehaus.groovy.tools.stubgenerator


class ImportStaticPropertyTest extends StringSourcesStubTestCase {

  @Override
  Map<String, String> provideSources() {
      [
              'A.groovy': '''
                  package test
                  class A {
                      static String aString
                  }
              ''',

              'B.groovy': '''
                  package test
                  import static test.A.aString
                  class B {
                      String returnAString(){
                          return aString
                      }
                  }
              ''',

              'C.java': '''
                  package test;
                  public class C {
                      public static void main(String[] args) {
                          B b;
                      }
                  }
              '''
      ]
  }

  @Override
  void verifyStubs() {

  }
}
{code}

The error produced is:
{code}
error: cannot find symbol
import static test.A.aString;
^
  symbol:   static aString
  location: class
{code}

Adding a {{public}} modifier to aString will cause aString to be included in the generated stub for A, in which case the test will pass.




",JDK 1.8.0_25,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-07-19 20:34:05.0,,,,,,,,,,"0|i2hfov:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Stub Generator And Static Import Aliases,GROOVY-7509,12846134,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,keegan,jeffscottbrown,jeffscottbrown,19/Jul/15 03:21,19/Oct/15 16:05,14/Jul/23 06:01,21/Aug/15 14:30,2.4.4,,,,,,,,,,,,,,,,,2.4.5,,,,Stub generator / Joint compiler,,,,0,regression,,,,,,"The attached staticimportalias.zip contains the following:

{code:borderStyle=solid|title=src/main/groovy/demo/helper/SomeHelper.java}
package demo.helper;

public class SomeHelper {
    public static final int ANSWER = 42;
}
{code}

{code:borderStyle=solid|title=src/main/groovy/demo/SomeClass.groovy}
package demo

import static demo.helper.SomeHelper.ANSWER as MAGIC_NUMBER

class SomeClass {

    static int getMagicNumber() {
        MAGIC_NUMBER
    }
}
{code}

{code:borderStyle=solid|title=src/main/groovy/demo/SomeJavaClass.java}
package demo;

public class SomeJavaClass {
    SomeClass sc;
}
{code}

The code will not compile with Groovy 2.4.4:

{noformat}
$ ./gradlew clean cG
:clean
:compileJava UP-TO-DATE
:compileGroovy
/Users/jeff/staticimportalias/build/tmp/groovy-java-stubs/demo/SomeClass.java:9: error: cannot find symbol
import static demo.helper.SomeHelper.MAGIC_NUMBER;
^
  symbol:   static MAGIC_NUMBER
  location: class
1 error
startup failed:
Compilation failed; see the compiler error output for details.

1 error

:compileGroovy FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileGroovy'.
> Compilation failed; see the compiler error output for details.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 4.467 secs
{noformat}

If I edit the top level build.gradle to use Groovy 2.4.3, the code compiles.
",,githubbot,jeffscottbrown,keegan,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7531,,,,GROOVY-7366,,,,,,,,,,,,,,,,,"19/Jul/15 03:21;jeffscottbrown;staticimportalias.zip;https://issues.apache.org/jira/secure/attachment/12745989/staticimportalias.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 21 14:28:15 UTC 2015,,,,,,,,,,"0|i2hfen:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jul/15 20:56;shils;As with GROOVY-7510, this seems to be the result of static imports being added to generated stubs.;;;","20/Jul/15 13:02;jeffscottbrown;Note that the stub here is trying to import the aliased name (demo.helper.SomeHelper.MAGIC_NUMBER) not the actual member name (demo.helper.SomeHelper.ANSWER).;;;","20/Jul/15 14:14;shils;I think the underlying issue is the same - the compiler encounters a static import of something that is not present in the stub for the class it's being imported from.;;;","20/Jul/15 14:16;jeffscottbrown;{quote}
I think the underlying issue is the same - the compiler encounters a static import of something that is not present in the stub for the class it's being imported from.
{quote}

In the example I posted, there should not even be a stub for the class it's being imported from.  That class is a Java class.  Am I misunderstanding that?;;;","20/Jul/15 14:18;jeffscottbrown;I intentionally made SomeHelper a Java class to try and clarify that.  It may be that I am confused about what you are saying.;;;","20/Jul/15 15:07;shils;What I mean is that the stub for SomeClass contains {{import static demo.helper.SomeHelper.MAGIC_NUMBER}}, but MAGIC_NUMBER is not present in SomeHelper.;;;","20/Jul/15 15:09;jeffscottbrown;Right.  I think we are saying the same thing.  That is what I meant by ""...the stub here is trying to import the aliased name..."" above.

Thanks for the clarification.;;;","29/Jul/15 16:15;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/76

    GROOVY-7509 removed import static alias statements from stubs, replac…

    …ed usages with fqn

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7509

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/76.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #76
    
----
commit c682210cf2f117690a865fae46d456367d4a245b
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2015-07-29T15:58:36Z

    GROOVY-7509 removed import static alias statements from stubs, replaced usages with fqn

----
;;;","30/Jul/15 14:09;githubbot;Github user keeganwitt commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/76#discussion_r35873566
  
    --- Diff: src/test/org/codehaus/groovy/tools/stubgenerator/ImportStaticAliasTest.groovy ---
    @@ -0,0 +1,63 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.codehaus.groovy.tools.stubgenerator
    +
    +class ImportStaticAliasTest extends StringSourcesStubTestCase {
    +
    +    Map<String, String> provideSources() {
    +        [
    +                'Constants.java': '''
    +                    package test;
    +                    public class Constants {
    +                        public static final String C1 = ""c1"";
    +                    }
    +                ''',
    +
    +                'MyAnnotation.java': '''
    --- End diff --
    
    Could we simplify the test a little and just refer to the constant directly rather than through an annotation?
;;;","30/Jul/15 14:21;githubbot;Github user keeganwitt commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/76#discussion_r35874858
  
    --- Diff: src/test/org/codehaus/groovy/tools/stubgenerator/ImportStaticAliasTest.groovy ---
    @@ -0,0 +1,63 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.codehaus.groovy.tools.stubgenerator
    +
    +class ImportStaticAliasTest extends StringSourcesStubTestCase {
    +
    +    Map<String, String> provideSources() {
    +        [
    +                'Constants.java': '''
    +                    package test;
    +                    public class Constants {
    +                        public static final String C1 = ""c1"";
    +                    }
    +                ''',
    +
    +                'MyAnnotation.java': '''
    +                    package test;
    +                    public @interface MyAnnotation {
    +                        String value();
    +                    }
    +                ''',
    +
    +                'Test.groovy': '''
    +                    package test
    +                    import static test.Constants.C1 as C2
    +                    @MyAnnotation(C2)
    +                    class Test {
    +                        def test
    +                        Test(test) {
    +                            this.test = test
    +                        }
    +                    }
    +                ''',
    +
    +                'SomeJavaClass.java': '''
    +                    package test;
    +                    public class SomeJavaClass {
    +                        Test test;
    +                    }
    +                '''
    +        ]
    +    }
    +
    +    void verifyStubs() {
    +
    --- End diff --
    
    I think you forgot to add your assertions.
;;;","30/Jul/15 14:40;keegan;As a followup to my assertions comment on PR, it might be overkill, but I was thinking about something like this for the test

{code:java|title=ImportStaticAliasTest.groovy}
package org.codehaus.groovy.tools.stubgenerator

class ImportStaticAliasTest extends StringSourcesStubTestCase {

    Map<String, String> provideSources() {
        [
                'Constants.java': '''
                    package test;
                    public class Constants {
                        public static final String C1 = ""c1"";
                    }
                ''',

                'Methods.groovy': '''
                    package test
                    class Methods {
                        static void m1() {}
                    }
                ''',

                'Enums.groovy': '''
                    package test
                    enum Enums {
                        E1
                    }
                ''',

                'Test.groovy': '''
                    package test
                    import static Constants.C1 as C2
                    import static Methods.m1 as m2
                    import static Enums.E1 as E2
                    public class Test {}
                '''
        ]
    }

    void verifyStubs() {
        def stubSource = stubJavaSourceFor('test.Test')
        assert stubSource.contains('import static Constants.C1;')
        assert stubSource.contains('import static test.Methods.m1;')
        assert stubSource.contains('import static test.Enums.E1;')
    }
}
{code};;;","30/Jul/15 14:46;githubbot;Github user keeganwitt commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/76#discussion_r35878035
  
    --- Diff: src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java ---
    @@ -925,7 +931,8 @@ private void printImports(PrintWriter out, ClassNode classNode) {
             imports.addAll(Arrays.asList(ResolveVisitor.DEFAULT_IMPORTS));
     
             for (Map.Entry<String, ImportNode> entry : moduleNode.getStaticImports().entrySet()) {
    -            imports.add(""static ""+entry.getValue().getType().getName()+"".""+entry.getKey());
    +            if (entry.getKey().equals(entry.getValue().getFieldName()))
    --- End diff --
    
    Could this just be
    ```java
    imports.add(""static "" + entry.getValue().getType().getName() + ""."" + entry.getValue().getFieldName());
    ```
    without the conditional?
;;;","30/Jul/15 20:02;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/76#discussion_r35913731
  
    --- Diff: src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java ---
    @@ -925,7 +931,8 @@ private void printImports(PrintWriter out, ClassNode classNode) {
             imports.addAll(Arrays.asList(ResolveVisitor.DEFAULT_IMPORTS));
     
             for (Map.Entry<String, ImportNode> entry : moduleNode.getStaticImports().entrySet()) {
    -            imports.add(""static ""+entry.getValue().getType().getName()+"".""+entry.getKey());
    +            if (entry.getKey().equals(entry.getValue().getFieldName()))
    --- End diff --
    
    I'm using a strategy similar to the one used for regular imports - excluding aliased static imports, and replacing their occurrences with their fully qualified names.  
;;;","30/Jul/15 20:03;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/76#discussion_r35913738
  
    --- Diff: src/test/org/codehaus/groovy/tools/stubgenerator/ImportStaticAliasTest.groovy ---
    @@ -0,0 +1,63 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.codehaus.groovy.tools.stubgenerator
    +
    +class ImportStaticAliasTest extends StringSourcesStubTestCase {
    +
    +    Map<String, String> provideSources() {
    +        [
    +                'Constants.java': '''
    +                    package test;
    +                    public class Constants {
    +                        public static final String C1 = ""c1"";
    +                    }
    +                ''',
    +
    +                'MyAnnotation.java': '''
    +                    package test;
    +                    public @interface MyAnnotation {
    +                        String value();
    +                    }
    +                ''',
    +
    +                'Test.groovy': '''
    +                    package test
    +                    import static test.Constants.C1 as C2
    +                    @MyAnnotation(C2)
    +                    class Test {
    +                        def test
    +                        Test(test) {
    +                            this.test = test
    +                        }
    +                    }
    +                ''',
    +
    +                'SomeJavaClass.java': '''
    +                    package test;
    +                    public class SomeJavaClass {
    +                        Test test;
    +                    }
    +                '''
    +        ]
    +    }
    +
    +    void verifyStubs() {
    +
    --- End diff --
    
    I'm just testing for successful compilation here - this test is a variant of the one in Groovy7366Bug.groovy.
;;;","31/Jul/15 15:56;githubbot;Github user keeganwitt commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/76#discussion_r35987069
  
    --- Diff: src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java ---
    @@ -925,7 +931,8 @@ private void printImports(PrintWriter out, ClassNode classNode) {
             imports.addAll(Arrays.asList(ResolveVisitor.DEFAULT_IMPORTS));
     
             for (Map.Entry<String, ImportNode> entry : moduleNode.getStaticImports().entrySet()) {
    -            imports.add(""static ""+entry.getValue().getType().getName()+"".""+entry.getKey());
    +            if (entry.getKey().equals(entry.getValue().getFieldName()))
    --- End diff --
    
    I'm rethinking my comment now.  I thought it'd be better to include the non-aliased name, but that could cause a problem if it was aliased to work around a name conflict.  I'm thinking now what you did is the right thing.
;;;","31/Jul/15 15:57;githubbot;Github user keeganwitt commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/76#discussion_r35987130
  
    --- Diff: src/test/org/codehaus/groovy/tools/stubgenerator/ImportStaticAliasTest.groovy ---
    @@ -0,0 +1,63 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.codehaus.groovy.tools.stubgenerator
    +
    +class ImportStaticAliasTest extends StringSourcesStubTestCase {
    +
    +    Map<String, String> provideSources() {
    +        [
    +                'Constants.java': '''
    +                    package test;
    +                    public class Constants {
    +                        public static final String C1 = ""c1"";
    +                    }
    +                ''',
    +
    +                'MyAnnotation.java': '''
    +                    package test;
    +                    public @interface MyAnnotation {
    +                        String value();
    +                    }
    +                ''',
    +
    +                'Test.groovy': '''
    +                    package test
    +                    import static test.Constants.C1 as C2
    +                    @MyAnnotation(C2)
    +                    class Test {
    +                        def test
    +                        Test(test) {
    +                            this.test = test
    +                        }
    +                    }
    +                ''',
    +
    +                'SomeJavaClass.java': '''
    +                    package test;
    +                    public class SomeJavaClass {
    +                        Test test;
    +                    }
    +                '''
    +        ]
    +    }
    +
    +    void verifyStubs() {
    +
    --- End diff --
    
    I know you just copied what was done previously, but I think we can do better.  If we exclude aliased static imports (which I'm now thinking is right to do), then I'd like us to use the assertions I made in Jira comment, but negate them.  As the test is now, it passes both with and without your changes.  That's not very useful.
;;;","31/Jul/15 17:50;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/76#discussion_r35997632
  
    --- Diff: src/test/org/codehaus/groovy/tools/stubgenerator/ImportStaticAliasTest.groovy ---
    @@ -0,0 +1,63 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.codehaus.groovy.tools.stubgenerator
    +
    +class ImportStaticAliasTest extends StringSourcesStubTestCase {
    +
    +    Map<String, String> provideSources() {
    +        [
    +                'Constants.java': '''
    +                    package test;
    +                    public class Constants {
    +                        public static final String C1 = ""c1"";
    +                    }
    +                ''',
    +
    +                'MyAnnotation.java': '''
    +                    package test;
    +                    public @interface MyAnnotation {
    +                        String value();
    +                    }
    +                ''',
    +
    +                'Test.groovy': '''
    +                    package test
    +                    import static test.Constants.C1 as C2
    +                    @MyAnnotation(C2)
    +                    class Test {
    +                        def test
    +                        Test(test) {
    +                            this.test = test
    +                        }
    +                    }
    +                ''',
    +
    +                'SomeJavaClass.java': '''
    +                    package test;
    +                    public class SomeJavaClass {
    +                        Test test;
    +                    }
    +                '''
    +        ]
    +    }
    +
    +    void verifyStubs() {
    +
    --- End diff --
    
    If I remember correctly, the test shouldn't pass without my changes. I can't verify right now (don't have access to a computer at the moment), but that's something I specifically tested for. In any case, making those assertions explicit might clear things up so I'll make those changes when I can.
;;;","31/Jul/15 20:58;githubbot;Github user keeganwitt commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/76#discussion_r36015780
  
    --- Diff: src/test/org/codehaus/groovy/tools/stubgenerator/ImportStaticAliasTest.groovy ---
    @@ -0,0 +1,63 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.codehaus.groovy.tools.stubgenerator
    +
    +class ImportStaticAliasTest extends StringSourcesStubTestCase {
    +
    +    Map<String, String> provideSources() {
    +        [
    +                'Constants.java': '''
    +                    package test;
    +                    public class Constants {
    +                        public static final String C1 = ""c1"";
    +                    }
    +                ''',
    +
    +                'MyAnnotation.java': '''
    +                    package test;
    +                    public @interface MyAnnotation {
    +                        String value();
    +                    }
    +                ''',
    +
    +                'Test.groovy': '''
    +                    package test
    +                    import static test.Constants.C1 as C2
    +                    @MyAnnotation(C2)
    +                    class Test {
    +                        def test
    +                        Test(test) {
    +                            this.test = test
    +                        }
    +                    }
    +                ''',
    +
    +                'SomeJavaClass.java': '''
    +                    package test;
    +                    public class SomeJavaClass {
    +                        Test test;
    +                    }
    +                '''
    +        ]
    +    }
    +
    +    void verifyStubs() {
    +
    --- End diff --
    
    OK.  If it does, let me know.  Maybe something's goofed up in my environment.
;;;","04/Aug/15 15:31;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/76#discussion_r36202258
  
    --- Diff: src/test/org/codehaus/groovy/tools/stubgenerator/ImportStaticAliasTest.groovy ---
    @@ -0,0 +1,63 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.codehaus.groovy.tools.stubgenerator
    +
    +class ImportStaticAliasTest extends StringSourcesStubTestCase {
    +
    +    Map<String, String> provideSources() {
    +        [
    +                'Constants.java': '''
    +                    package test;
    +                    public class Constants {
    +                        public static final String C1 = ""c1"";
    +                    }
    +                ''',
    +
    +                'MyAnnotation.java': '''
    +                    package test;
    +                    public @interface MyAnnotation {
    +                        String value();
    +                    }
    +                ''',
    +
    +                'Test.groovy': '''
    +                    package test
    +                    import static test.Constants.C1 as C2
    +                    @MyAnnotation(C2)
    +                    class Test {
    +                        def test
    +                        Test(test) {
    +                            this.test = test
    +                        }
    +                    }
    +                ''',
    +
    +                'SomeJavaClass.java': '''
    +                    package test;
    +                    public class SomeJavaClass {
    +                        Test test;
    +                    }
    +                '''
    +        ]
    +    }
    +
    +    void verifyStubs() {
    +
    --- End diff --
    
    I just ran the test on Master and it failed.
;;;","04/Aug/15 17:07;githubbot;Github user keeganwitt commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/76#discussion_r36213864
  
    --- Diff: src/test/org/codehaus/groovy/tools/stubgenerator/ImportStaticAliasTest.groovy ---
    @@ -0,0 +1,63 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.codehaus.groovy.tools.stubgenerator
    +
    +class ImportStaticAliasTest extends StringSourcesStubTestCase {
    +
    +    Map<String, String> provideSources() {
    +        [
    +                'Constants.java': '''
    +                    package test;
    +                    public class Constants {
    +                        public static final String C1 = ""c1"";
    +                    }
    +                ''',
    +
    +                'MyAnnotation.java': '''
    +                    package test;
    +                    public @interface MyAnnotation {
    +                        String value();
    +                    }
    +                ''',
    +
    +                'Test.groovy': '''
    +                    package test
    +                    import static test.Constants.C1 as C2
    +                    @MyAnnotation(C2)
    +                    class Test {
    +                        def test
    +                        Test(test) {
    +                            this.test = test
    +                        }
    +                    }
    +                ''',
    +
    +                'SomeJavaClass.java': '''
    +                    package test;
    +                    public class SomeJavaClass {
    +                        Test test;
    +                    }
    +                '''
    +        ]
    +    }
    +
    +    void verifyStubs() {
    +
    --- End diff --
    
    You're right.  I'm not sure what test report I was reading.  Maybe I had tested without your annotation or something.  Sorry for the false alarm.
;;;","20/Aug/15 23:05;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/76#discussion_r37591308
  
    --- Diff: src/test/org/codehaus/groovy/tools/stubgenerator/ImportStaticAliasTest.groovy ---
    @@ -0,0 +1,63 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.codehaus.groovy.tools.stubgenerator
    +
    +class ImportStaticAliasTest extends StringSourcesStubTestCase {
    +
    +    Map<String, String> provideSources() {
    +        [
    +                'Constants.java': '''
    +                    package test;
    +                    public class Constants {
    +                        public static final String C1 = ""c1"";
    +                    }
    +                ''',
    +
    +                'MyAnnotation.java': '''
    --- End diff --
    
    Never addressed this - the constant is referred to through an annotation so that its usage appears in stubs.
;;;","21/Aug/15 14:28;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/76
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot assign value of type java.lang.Object in ternary operator with null,GROOVY-7507,12845813,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mauromol,mauromol,17/Jul/15 07:13,10/Feb/23 21:40,14/Jul/23 06:01,03/Sep/22 00:36,2.4.3,2.4.4,,,,,,,,,,,,,,,,2.5.19,3.0.11,4.0.0-alpha-3,,Static Type Checker,,,,0,,,,,,,"This seems to be something like a regression of GROOVY-5734.

The following fails in Groovy 2.4.3/2.4.4, while it didn't fail in Groovy 2.3.11:

{code:title=Bar.java}
package test2;

public class Bar {
}
{code}

{code:title=Foo.java}
package test2;

public class Foo {
	private Bar bar;
	
	public void setBar(Bar bar) {
		this.bar = bar;
	}
	
	public Bar getBar() {
		return bar;
	}
}
{code}

{code:title=Test.groovy}
package test2

import groovy.transform.CompileStatic;

@CompileStatic
public class Test {
	void test() {
		boolean check = true
		Foo foo = new Foo()
		foo.bar = check? new Bar(): null
	}
}
{code}

The assignment to {{foo.bar}} fails with:{{Cannot assign value of type java.lang.Object to variable of type test2.Bar}}.

The same heppens if {{Foo}} is written in Groovy instead of Java.",,emilles,jwagenleitner,mauromol,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-9972,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Sep 03 00:36:51 UTC 2022,,,,,,,,,,"0|i2hdhj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Sep/22 00:36;emilles;https://github.com/apache/groovy/commit/cf08b38c9e7e5a6d42a73f96ae242f0566ee3e5c;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot assign value of type java.util.List<java.lang.String> to variable of type java.lang.String[],GROOVY-7506,12845596,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mauromol,mauromol,16/Jul/15 13:54,15/Feb/23 14:38,14/Jul/23 06:01,10/Aug/22 17:10,2.4.3,2.4.4,,,,,,,,,,,,,,,,4.0.5,,,,Static Type Checker,,,,0,,,,,,,"Usually the static type checker is smart enough to accept a {{List<String>}} to be assigned to a {{String[]}} variable, however in this particular case it is not:

{code:title=Wrapper.java}
package test;

public class Wrapper {
	String[] wrapped;
	
	public Wrapper(String[] wrapped) {
		this.wrapped = wrapped;
	}
}
{code}

{code:title=Other.java}
package test;

public class Other {
	private Wrapper foo;
	
	public void setFoo(String... args) {
		this.foo = new Wrapper(args);
	}
}
{code}

{code:title=Test.groovy}
package test

import groovy.transform.CompileStatic

@CompileStatic
class Test {
	
	static test() {
		Other o = new Other()
		o.foo = ['foo', 'bar']
	}
}
{code}

The assignment to {{o.foo}} unexpectedly fails. However, if I declare the {{foo}} field and {{setFoo}} method directly in {{Test}}, and change the code to assign to {{t.foo}} (where {{t}} is of type {{Test}}), the type checking passes.

Please note that with Groovy 2.3.11 the assignment to {{o.foo}} was passing (no error produced by the static type checker!).",,emilles,mauromol,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8983,GROOVY-10938,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 10 17:10:41 UTC 2022,,,,,,,,,,"0|i2hc7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Aug/22 17:10;emilles;https://github.com/apache/groovy/commit/c341e2c44a64c25b8f8305dfe224cf795349c853;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[CVE-2015-3253] Potential remote code execution,GROOVY-7504,12845538,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,16/Jul/15 10:08,21/Jul/15 10:30,14/Jul/23 06:01,16/Jul/15 10:11,1.8.9,2.0.8,2.1.9,2.2.2,2.3.11,2.4.3,,,,,,,,,,,,2.4.4,,,,,,,,0,,,,,,,"Details are on http://groovy-lang.org/security.html

Fix: https://github.com/apache/incubator-groovy/commit/09e9778e8a33052d8c27105aee5310649637233d",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-07-16 10:08:48.0,,,,,,,,,,"0|i2hbvb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Builder with Initializer strategy and no properties results in ClassFormatError,GROOVY-7503,12845464,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,16/Jul/15 02:39,19/Oct/15 16:05,14/Jul/23 06:01,16/Jul/15 11:07,2.4.3,,,,,,,,,,,,,,,,,2.4.5,,,,,,,,0,,,,,,,"This script:
{code}
import groovy.transform.builder.*
@Builder(builderStrategy=InitializerStrategy) class Foo { }
assert Foo.createInitializer().class.name == 'Foo$FooInitializer'
{code}
gives this error during compilation:
{noformat}
java.lang.ClassFormatError: Duplicate method name&signature in class file Foo$FooInitializer
{noformat}
Creating a builder for a class with no properties using this strategy doesn't really make sense; however, we should give a sensible error message in this case.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 16 04:39:16 UTC 2015,,,,,,,,,,"0|i2hbev:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jul/15 02:42;paulk;Similarly, we get the same error for this class declaration:
{code}
@Builder(builderStrategy=InitializerStrategy, excludes='bar') class Foo { String bar }
{code};;;","16/Jul/15 02:48;paulk;The error also occurs when annotating a constructor or static method with no parameters:
{code}
class Foo {
  @Builder(builderStrategy=InitializerStrategy)
  Foo() {
  }
}
{code}
;;;","16/Jul/15 03:02;paulk;Test would be:
{code}
class BuilderEmptyTest extends GroovyTestCase {
    void test() {
        def message = shouldFail '''
            import groovy.transform.builder.*
            @Builder(builderStrategy=InitializerStrategy) class Foo { }
        '''
        assert message.contains('at least one property is required for this strategy')
        message = shouldFail '''
            import groovy.transform.builder.*
            @Builder(builderStrategy=InitializerStrategy, excludes='bar') class Foo { String bar }
        '''
        assert message.contains('at least one property is required for this strategy')
        message = shouldFail '''
            import groovy.transform.builder.*
            class Foo {
              @Builder(builderStrategy=InitializerStrategy)
              Foo() {
              }
            }
        '''
        assert message.contains('at least one parameter is required for this strategy')
    }
}
{code};;;","16/Jul/15 04:39;paulk;Fix added to 2_4_X and master branches.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Builder class name should not contain package name,GROOVY-7501,12844480,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,controlix,controlix,12/Jul/15 20:09,19/Oct/15 16:05,14/Jul/23 06:01,16/Jul/15 11:06,2.4.3,,,,,,,,,,,,,,,,,2.4.5,,,,ast builder,,,,1,,,,,,,"When creating a builder for a class not in the default package, the builder class name includes the package name. This makes the builder unsusable from java code.

Example:
{code:title=Person.groovy}
package alfa.beta

import groovy.transform.ToString
import groovy.transform.builder.Builder

@ToString
@Builder // (builderClassName='PersonBuilder')
class Person {
	String name
	String firstName
	Date birthDate
}
{code}
{code:title=Show.java}
package alfa.beta;

public class Show {
	public static void main(String[] args) {
		Person lance = new Person();
		lance.setFirstName(""Lance"");
		lance.setName(""Von Trier"");
		System.out.println(""Hello from "" + lance);

		Person rick = Person.builder().name(""Ashley"").firstName(""Rick"").build();
		System.out.println(""Hello from "" + rick + "" too"");
	}
}
{code}
When trying to comilpile the java class I get a 'class not found' error:
{noformat}
:compileJava
/home/marc/dev/workspace-groovy/java-package/src/main/java/Show.java:10: error: cannot access alfa.beta.PersonBuilder
		Person rick = Person.builder().name(""Ashley"").firstName(""Rick"").build();
		                            ^
  class file for alfa.beta.Person$alfa.beta.PersonBuilder not found
1 error
:compileJava FAILED
{noformat}
If I uncomment the (builderClassName='PersonBuilder') then the java code compiles fine.
{noformat}
:compileJava
:processResources UP-TO-DATE
:classes
:run
Hello from alfa.beta.Person(Von Trier, Lance, null)
Hello from alfa.beta.Person(Ashley, Rick, null) too

BUILD SUCCESSFUL
{noformat}

The problem boils down to the creation of the builder class name in groovy.transform.builder.DefaultStrategy and groovy.transform.builder.InitializerStrategy. Replacing the code buildee.getName() to buildee.getNameWithoutPackage() solves the problem.",,controlix,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 16 11:06:57 UTC 2015,,,,,,,,,,"0|i2h5lj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Jul/15 20:31;githubbot;GitHub user Controlix opened a pull request:

    https://github.com/apache/incubator-groovy/pull/60

    GROOVY-7501: omit package name from builder class name

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/Controlix/incubator-groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/60.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #60
    
----
commit 91c4d5a033f600f8b584811affeaf012df7bcc60
Author: Marc Bogaerts <marcbogaerts@telenet.be>
Date:   2015-07-12T20:28:58Z

    GROOVY-7501: omit package name from builder class name

----
;;;","16/Jul/15 03:10;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/60
;;;","16/Jul/15 04:39;paulk;Fix added to 2_4_X and master branches.;;;","16/Jul/15 11:06;paulk;fixed, thanks for spotting the issue and the PR;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Runtime Metaprogramming Over A Trait Method,GROOVY-7500,12844389,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,jeffscottbrown,jeffscottbrown,11/Jul/15 19:35,03/Feb/22 22:29,14/Jul/23 06:01,19/Dec/21 19:06,2.4.3,,,,,,,,,,,,,,,,,4.0.0-rc-2,,,,,,,,2,,,,,,,"It looks like I cannot runtime metaprogram over a trait method.  

The attached metaprogramovertrait.zip file contains the following:

{code:title=src/main/groovy/demo/SomeClass.groovy}
package demo

class SomeClass implements SomeTrait {}
{code}

{code:title=src/main/groovy/demo/SomeTrait.groovy}
package demo

trait SomeTrait {
    void someMethod() {
    }
}
{code}

{code:title=src/test/groovy/demo/SomeClassSpec.groovy}
package demo

import spock.lang.Specification
class SomeClassSpec extends Specification {

    void 'test something'() {
        given:
        SomeClass.metaClass.someMethod = { ->
            throw new UnsupportedOperationException()
        }

        when:
        new SomeClass().someMethod()

        then:
        UnsupportedOperationException ex = thrown()
    }
}
{code}

If I remove the method from the trait, the test passes.",,blackdrag,emilles,jeffscottbrown,rlovtangen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Jul/15 19:35;jeffscottbrown;metaprogramovertrait.zip;https://issues.apache.org/jira/secure/attachment/12744902/metaprogramovertrait.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 19 19:06:15 UTC 2021,,,,,,,,,,"0|i2h52f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Feb/16 22:02;jeffscottbrown;Is it agreed that this behavior is a bug?;;;","09/Feb/16 16:37;blackdrag;yes;;;","19/Dec/21 19:06;emilles;https://github.com/apache/groovy/commit/55fb428c4f6dfad37be5f752282a97089cb1b5ad;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyDoc reports only last method of a script,GROOVY-7497,12843546,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,armin.heinzer,armin.heinzer,08/Jul/15 15:34,01/Feb/17 23:18,14/Jul/23 06:01,01/Sep/16 01:41,2.4.3,,,,,,,,,,,,,,,,,2.4.8,,,,GroovyDoc,,,,2,,,,,,,"If a script contains several methods, only the last one is reported.

In the following example, the sayGoodbye() is reported by GroovyDoc but the sayHello() method is missing:

{code}
C:\Users\ah\test>groovy -version
Groovy Version: 2.4.3 JVM: 1.8.0_40 Vendor: Oracle Corporation OS: Windows 7

C:\Users\ah\test>type testscript.groovy
sayHello()
sayGoodbye()

void sayHello() {
  println 'hello'
}

void sayGoodbye() {
  println 'goodbye'
}

C:\Users\ah\test>groovy testscript.groovy
hello
goodbye

C:\Users\ah\test>groovydoc testscript.groovy
Jul 08, 2015 5:29:10 PM java.util.prefs.WindowsPreferences <init>
WARNUNG: Could not open/create prefs root node Software\JavaSoft\Prefs at root 0x80000002. Windows RegCreateKeyEx(...) returned error code 5.
{code}

Screenshot of GroovyDoc, see https://www.dropbox.com/s/1jhko1yz9tw5hc6/groovydoc-screenshot.png?dl=0","Groovy Version: 2.4.3 JVM: 1.8.0_40 Vendor: Oracle Corporation OS: Windows 7
",armin.heinzer,cscutcher,githubbot,jwagenleitner,LGeson,paulk,smeedy,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 01 01:41:56 UTC 2016,,,,,,,,,,"0|i2gzz3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Jan/16 10:12;LGeson;I've encountered this problem as well using:
Groovy Version: 2.4.5 JVM: 1.8.0_66 Vendor: Oracle Corporation OS: Windows 7
and
Groovy Version: 2.4.5 JVM: 1.7.0_79 Vendor: Oracle Corporation OS: Windows 7

Installed Groovy using the Windows installer. Used the same testscript.groovy example as reporter and ran 
groovydoc testscript.groovy;;;","30/Aug/16 16:41;smeedy;I have the same problem on Mac OS X Yosemite
Groovy Versions: 2.4.6 and  2.4.7 
and 
JVMs: 1.8.0_91 and 1.8.0_101

I get no error message;;;","30/Aug/16 21:05;cscutcher;I also have this issue.
Groovy Version: 2.4.7 JVM: 1.8.0_102 Vendor: Oracle Corporation OS: Linux on Arch Linux.;;;","31/Aug/16 14:42;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/405

    GROOVY-7497: GroovyDoc reports only last method of a script

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7497

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/405.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #405
    
----
commit a9f2d7c387cefcfa2634f764ae49081476cd4c86
Author: paulk <paulk@asert.com.au>
Date:   2016-08-31T13:41:29Z

    GROOVY-7497: GroovyDoc reports only last method of a script

----
;;;","01/Sep/16 01:31;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/405
;;;","01/Sep/16 01:41;paulk;Proposed PR merged. Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Diamond inheritance of interfaces makes method return type incompatible,GROOVY-7495,12843151,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,lptr,lptr,07/Jul/15 10:28,19/Oct/15 16:11,14/Jul/23 06:01,09/Jul/15 16:43,2.3.10,2.4.3,,,,,,,,,,,,,,,,2.4.4,,,,Compiler,,,,0,,,,,,,"While working on Gradle, I bumped into a failure with the Groovy compiler that works fine in Java.

Example code that fails with both Groovy compiler 2.3.10 and 2.4.3:

{code:title=Groovy}
interface Item {}
interface DerivedItem extends Item {}

interface Base {
  Item getItem()
}
class BaseImpl implements Base {
  Item getItem() { null }
}

interface First extends Base {
  DerivedItem getItem()
}

class FirstImpl extends BaseImpl implements First {
  DerivedItem getItem() { null }
}

interface Second extends First {}
class SecondImpl extends FirstImpl implements Second {}
{code}

The error message is:

{code}
Script1.groovy: 8: The return type of Item getItem() in BaseImpl is incompatible with DerivedItem in First. At [8:3]  @ line 8, column 3.
     Item getItem() { null }
     ^
{code}

However, changing the implementation of {{SecondImpl}} like this fixes the compile error:

{code:title=Fixed Groovy}
class SecondImpl extends FirstImpl implements Second {
  DerivedItem getItem() { super.item }
}
{code}

The equivalent code compiles fine in Java:

{code:title=Java}
public class CompileJava {
    interface Item {}
    interface DerivedItem extends Item {}
    
    interface Base {
      Item getItem();
    }
    class BaseImpl implements Base {
      public Item getItem() { return null; }
    }
    
    interface First extends Base {
      DerivedItem getItem();
    }
    
    class FirstImpl extends BaseImpl implements First {
      public DerivedItem getItem() { return null; }
    }
    
    interface Second extends First {}
    class SecondImpl extends FirstImpl implements Second {}
}
{code}",,blackdrag,githubbot,lptr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 09 23:59:56 UTC 2015,,,,,,,,,,"0|i2gxkf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jul/15 07:42;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/58

    GROOVY-7495: Diamond inheritance of interfaces makes method return ty…

    …pe incompatible

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7495

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/58.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #58
    
----
commit bdec939be79c133dc4e26837ad9a6b2c7ecd5dda
Author: paulk <paulk@asert.com.au>
Date:   2015-07-09T07:41:18Z

    GROOVY-7495: Diamond inheritance of interfaces makes method return type incompatible

----
;;;","09/Jul/15 16:43;blackdrag;should be fixed now;;;","09/Jul/15 23:59;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/58
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ArrayStoreException assigning GStringImpl to String[] when using Indy,GROOVY-7494,12843014,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,kenscoggins,kenscoggins,06/Jul/15 22:55,07/Dec/20 22:09,14/Jul/23 06:01,18/Oct/20 11:29,2.4.3,,,,,,,,,,,,,,,,,2.5.14,3.0.7,4.0.0-alpha-2,,groovy-runtime,,,,1,indy,,,,,,"While upgrading a software baseline from Java 7/Groovy 2.0.2 to Java 8/Groovy 2.4, it appears that assigning a GString with an embedded variable reference to a String array is broken when using Indy. The following example demonstrates this issue:

{code}
int a = 1
String[] fubar = new String[1]
fubar[0] = ""Item $a""
println fubar
{code}

Without Indy, it works just fine:
{panel}
/c/test$ groovy GroovyIndyBug.groovy
[Item 1]
{panel}

With Indy, we get the ArrayStoreException
{panel}
/c/test$ groovy -indy GroovyIndyBug.groovy
Caught: java.lang.ArrayStoreException: org.codehaus.groovy.runtime.GStringImpl
java.lang.ArrayStoreException: org.codehaus.groovy.runtime.GStringImpl
        at GroovyIndyBug.run(GroovyIndyBug.groovy:3)
{panel}

I tried various other assignment methods and this appears to be the only one with the issue.  Oddly, even doing the same assignment, but at creation time instead of after, works just fine.  Some of the other related scenarios I tried are:

{code}
int a = 1

String[] foo = [""Assigned At Creation $a""]
println foo

foo[0] = ""No Embedded Variable""
println foo

foo[0] = ""as String $a"" as String
println foo

foo[0] = ""BROKEN $a""
println foo
{code}

With Indy:
{panel}
/c/test $ groovy -indy GroovyIndyBug.groovy
[Assigned At Creation 1]
[No Embedded Variable]
[as String 1]
Caught: java.lang.ArrayStoreException: org.codehaus.groovy.runtime.GStringImpl
java.lang.ArrayStoreException: org.codehaus.groovy.runtime.GStringImpl
        at GroovyIndyBug.run(GroovyIndyBug.groovy:12){panel}","Windows 7; Java 8",daniel_sun,javiermv,jwagenleitner,kenscoggins,,,,,,,,,,,,"paulk-asert opened a new pull request #1404:
URL: https://github.com/apache/groovy/pull/1404


   …en using Indy


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;14/Oct/20 10:24;githubbot;600","danielsun1106 merged pull request #1404:
URL: https://github.com/apache/groovy/pull/1404


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Oct/20 23:15;githubbot;600","danielsun1106 commented on pull request #1404:
URL: https://github.com/apache/groovy/pull/1404#issuecomment-710692566


   Merged. Thanks!


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Oct/20 23:15;githubbot;600",,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Oct 18 11:29:45 UTC 2020,,,,,,,,,,"0|i2gwpb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Oct/20 05:06;javiermv;Still a problem in groovy-3.0.6-indy with java 11 and Ubuntu 18.04;;;","18/Oct/20 11:29;daniel_sun;The proposed PR has been merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic confuses statically importing an instance and statically importing a method,GROOVY-7490,12842470,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mahoney,mahoney,02/Jul/15 23:38,16/May/23 13:31,14/Jul/23 06:01,25/Oct/21 16:49,2.4.3,,,,,,,,,,,,,,,,,2.5.22,3.0.16,4.0.0-beta-2,,Static compilation,,,,0,,,,,,,"When statically importing a field and immediately calling a call() method on it, the static compiler gets confused and looks for a static method with the name of the field that takes the arguments passed to the call() method.

See below - comment out @CompileStatic and it will run as expected.

{code:java}
import groovy.transform.CompileStatic

class WithCall {

    static final WithCall staticallyImported = new WithCall()

    String call(String input) {
        return input;
    }
}

class CompileStaticImport {

    @CompileStatic
    public static void main(String[] args) {
        assert WithCall.staticallyImported(""to print"") == ""to print""
    }
}
{code}

Error:(16, 16) Groovyc: [Static type checking] - Cannot find matching method WithCall#staticallyImported(java.lang.String). Please check if the declared type is right and if the method exists.",,blackdrag,emilles,mahoney,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8389,,,,GROOVY-11056,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 25 16:49:17 UTC 2021,,,,,,,,,,"0|i2gtfj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jul/15 04:55;blackdrag;I think the static compiler supports these semantics only for Closure;;;","03/Jul/15 05:56;mahoney;To me that's very unintuitive - in the example above if you pull out WithCall.staticallyImported into a variable it all compiles.  Inline it and it stops compiling. Surely a compiler shouldn't care whether a reference is inlined or not. 

(It's also stopping me producing a type safe DSL without resorting to the evils of delegate backed closures.);;;","25/Oct/21 16:49;emilles;https://github.com/apache/groovy/commit/56fd1b05eaf9ee7d53ce743ded0afa4677d1810b

{code:groovy}
import static WithCall.callable_property

class WithCall {
  static final WithCall callable_property = new WithCall()
  String call(String input) {
    return input
  }
}

@groovy.transform.CompileStatic
void test7490() {
  print callable_property('works')
}

test7490()
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BUG! exception in phase 'semantic analysis'... when trying to call instance method as default for a constructor parameter,GROOVY-7485,12842130,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,jflinchbaugh,jflinchbaugh,01/Jul/15 22:22,21/Jul/15 10:29,14/Jul/23 06:01,04/Jul/15 01:26,2.4.3,,,,,,,,,,,,,,,,,2.4.4,,,,Compiler,,,,0,,,,,,,"% groovyc StaticDefault.groovy # the code below

{code}
class StaticDefault {
    def name 
    StaticDefault(name = getName()) {
        this.name = name
    }
    private getName() {
        'name'
    }
}
{code}


And see this stacktrace:
{code}
>>> a serious error occurred: BUG! exception in phase 'semantic analysis' in source unit 'StaticDefault.groovy' unexpected NullpointerException
>>> stacktrace:
BUG! exception in phase 'semantic analysis' in source unit 'StaticDefault.groovy' unexpected NullpointerException
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1057)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:588)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:566)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:543)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:522)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:59)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:215)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:148)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:178)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:162)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.control.StaticVerifier$1.visitVariableExpression(StaticVerifier.java:84)
	at org.codehaus.groovy.ast.expr.VariableExpression.visit(VariableExpression.java:70)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitMethodCallExpression(CodeVisitorSupport.java:129)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.control.StaticVerifier.visitConstructorOrMethod(StaticVerifier.java:79)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:119)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1079)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.control.StaticVerifier.visitClass(StaticVerifier.java:42)
	at org.codehaus.groovy.control.CompilationUnit$6.call(CompilationUnit.java:209)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1052)
	... 15 more
{code}

Switching the method used for the default to a static method (private static getName()...)fixes the problem, but I'm guessing you likely wanted to give a better message out of the compiler.","Java(TM) SE Runtime Environment (build 1.8.0_25-b17)
Java HotSpot(TM) 64-Bit Server VM (build 25.25-b02, mixed mode)
Seen in java 7 too.",githubbot,jflinchbaugh,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 04 01:26:28 UTC 2015,,,,,,,,,,"0|i2gren:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jul/15 10:38;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/50

    GROOVY-7485: BUG! exception in phase 'semantic analysis'... when tryi…

    …ng to call instance method as default for a constructor parameter

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7485

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/50.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #50
    
----
commit f53eb3411a4f9ffa574e8dd094ab5f65c3d7833e
Author: paulk <paulk@asert.com.au>
Date:   2015-07-02T10:35:16Z

    GROOVY-7485: BUG! exception in phase 'semantic analysis'... when trying to call instance method as default for a constructor parameter

----
;;;","04/Jul/15 01:22;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/50
;;;","04/Jul/15 01:26;paulk;merged proposed fix;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stub compile fails for Groovy class extending Java class with private getProperty method,GROOVY-7482,12841774,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emosesSfdc,emosesSfdc,30/Jun/15 19:15,08/Mar/22 12:16,14/Jul/23 06:01,26/Dec/21 18:51,2.3.11,2.4.3,,,,,,,,,,,,,,,,,,,,Stub generator / Joint compiler,,,,0,,,,,,,"See this Gradle project: https://github.com/emosesSfdc/groovyBugReproCase.  

LibraryTestBase is a Java class with  a private method 
String getProperty(String)

LibraryTest is a Groovy test that extends LibraryTestBase.  

When a Java stub is generated for LibraryTest, it doesn't have an implmentation of getProperty (from the GroovyObject interface), so java compilation of the stub fails.  

I first saw this when I updated a project from Gradle 2.3 to Gradle 2.4; I have a test class which extends org.glassfish.jersey.test.JerseyTest (in jersey-test-framework-core:2.12), which has a private getProperty method.  There was a change which made in Gradle is so that now, Java stubs are generated in circumstances where they weren't before, and my compilation fails.  ","OSX 10.8.5, JDK 1.8.0_40-b25",emilles,emosesSfdc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,https://github.com/emosesSfdc/groovyBugReproCase,,,,,,,,,,,9223372036854775807,,,Sun Dec 26 18:51:34 UTC 2021,,,,,,,,,,"0|i2gp9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Dec/21 18:51;emilles;Groovy 2.5+ does not write GroovyObject into the implements clause.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"CompileStatic-related ""BUG! exception in phase 'instruction selection'""",GROOVY-7477,12840873,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,huxi,huxi,26/Jun/15 14:51,21/Jul/15 10:30,14/Jul/23 06:01,28/Jun/15 11:33,2.4.3,,,,,,,,,,,,,,,,,2.4.4,,,,Compiler,,,,0,,,,,,,"Compile the file at [CompilerBug.groovy|http://pastebin.com/23gcFyjs].

{{groovyc CompilerBug.groovy}}

h3. Result
{noformat}
>>> a serious error occurred: BUG! exception in phase 'instruction selection' in source unit 'CompilerBug.groovy' unexpected NullpointerException
>>> stacktrace:
BUG! exception in phase 'instruction selection' in source unit 'CompilerBug.groovy' unexpected NullpointerException
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1057)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:588)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:566)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:543)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:522)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:59)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:215)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:148)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:178)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:162)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1601)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1642)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1608)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.inferenceCheck(StaticTypeCheckingSupport.java:1408)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1378)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1323)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.typeCheckMethodsWithGenericsOrFail(StaticTypeCheckingVisitor.java:4476)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2926)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:294)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1770)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2103)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2062)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:160)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1083)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:247)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:119)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:60)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1052)
	... 15 more
{noformat}

h3. Additional info
The problem is the {{Predicate<?>}} in combination with {{@CompileStatic}} and {{List<String>}}.

* If {{@CompileStatic}} is removed, the code compiles fine.
* If {{[]}} is used instead of {{([] as List<String>)}}, the code compiles fine.
* If {{Predicate}} is used instead of {{Predicate<?>}}, the code compiles fine.",Groovy Version: 2.4.3 JVM: 1.8.0_45 Vendor: Oracle Corporation OS: Mac OS X,blackdrag,githubbot,huxi,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 28 21:11:32 UTC 2015,,,,,,,,,,"0|i2gjpb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jun/15 00:18;paulk;Seems to be fixed by adding a null guard for {{type}} into {{StaticTypeCheckingSupport#extractGenericsConnections}}
I used this test file:
{code}
import java.util.function.Predicate
List<String> list = ['foo', null, 'bar']
assert list.removeIf({it == null} as Predicate<?>)
println list

@groovy.transform.CompileStatic
void minimalBroken(List list) {
//    list.removeIf({it == null} as Predicate) // already works
//    list.removeIf{it == null}                // already works
    list.removeIf({it == null} as Predicate<?>) // was: BUG! exception in phase 'instruction selection'
    println list
}

minimalBroken([null, 'baz'])
{code};;;","27/Jun/15 01:03;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/47

    GROOVY-7477: CompileStatic-related ""BUG! exception in phase 'instruct…

    …ion selection'""

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7477

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/47.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #47
    
----
commit d7b8727e20acd75a2876534841075d528d991d2b
Author: Paul King <paulk@asert.com.au>
Date:   2015-06-27T01:01:35Z

    GROOVY-7477: CompileStatic-related ""BUG! exception in phase 'instruction selection'""

----
;;;","28/Jun/15 06:15;blackdrag;seems to come from type.getGenericsTypes(), which can legally return null.  +1 from me ;;;","28/Jun/15 21:11;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/47
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper sometimes does not parse escaped double quotes on parsing with JsonParsingUsingCharacterSource,GROOVY-7476,12840638,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pascalschumacher,gvaneyck,gvaneyck,25/Jun/15 20:24,19/Oct/15 16:12,14/Jul/23 06:01,28/Jun/15 09:03,2.3.11,2.4.3,,,,,,,,,,,,,,,,2.4.4,,,,JSON,,,,0,contributers-welcome,,,,,,"This came up when parsing a JSON string that had escaped JSON in it.
E.g. {noformat}{""string"": ""{\""key\"": \""value\""}""}{noformat}

If the escape character used for ReaderCharacterSource.findNextChar is the last character in the buffer, then ""foundEscape"" is ignored for the first character in the recursion call (ReaderCharacterSource:229) and the match character is not added to the result.

{code}
import groovy.json.internal.ReaderCharacterSource

def testString = '""double\\""quote""'
def expectedString = testString.substring(1, testString.length() - 1)
def escapedQuotePos = testString.indexOf('""', 1)

int quoteChar = (int)'""'.charAt(0)
int backslashChar = (int)'\\'.charAt(0)

ReaderCharacterSource rcs
char[] result

rcs = new ReaderCharacterSource(new StringReader(testString), escapedQuotePos - 1)
result = rcs.findNextChar(quoteChar, backslashChar)
assert(expectedString == new String(result))

rcs = new ReaderCharacterSource(new StringReader(testString), escapedQuotePos + 1)
result = rcs.findNextChar(quoteChar, backslashChar)
assert(expectedString == new String(result))

// This one fails due to the backslash being the last character in the buffer
rcs = new ReaderCharacterSource(new StringReader(testString), escapedQuotePos)
result = rcs.findNextChar(quoteChar, backslashChar)
assert(expectedString == new String(result))
{code}",,githubbot,gvaneyck,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 28 09:01:26 UTC 2015,,,,,,,,,,"0|i2giav:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jun/15 22:20;githubbot;GitHub user gvaneyck opened a pull request:

    https://github.com/apache/incubator-groovy/pull/46

    GROOVY-7476 - Fix JSON parsing error when escape character is read at…

    … the end of the buffer

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/gvaneyck/incubator-groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/46.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #46
    
----
commit 5fc4cb6d527cd73578ca2f24572eb95eefde6623
Author: Gvaneyck <gvaneyck@riotgames.com>
Date:   2015-06-26T22:17:49Z

    GROOVY-7476 - Fix JSON parsing error when escape character is read at the end of the buffer

----
;;;","28/Jun/15 09:01;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/46
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Difference between junit3 and junit 4 shouldFail {...} not described in docs,GROOVY-7474,12839574,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,and.dmitry,and.dmitry,22/Jun/15 14:57,21/Jul/15 10:30,14/Jul/23 06:01,07/Jul/15 10:16,,,,,,,,,,,,,,,,,,2.4.4,,,,Documentation,,,,0,contributers-welcome,,,,,,"Groovy language documentation chapter on junit4 ([http://docs.groovy-lang.org/latest/html/documentation/#_junit_4]) states that ""shouldFail can be used the same way it can be used in a GroovyTestCase"". In fact junit4 version returns exception while junit3 returns message.

I've spent quite a lot of time trying to figure out why shouldFail in my code returns an exception while documentation and tests say that it returns message. It turned out that I was reading documentation for a wrong shouldFail. But I've never thought that methods in GroovyTestCase and GroovyAssert may have different signature or semantic. A small notice in documentation might help others avoid this confusion. An example for junit 4 version would be nice too.",,and.dmitry,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 07 10:35:01 UTC 2015,,,,,,,,,,"0|i2gcaf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jul/15 20:24;githubbot;GitHub user and-dmitry opened a pull request:

    https://github.com/apache/incubator-groovy/pull/55

    GROOVY-7474: Difference between junit3 and junit 4 shouldFail {...} not described in docs

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/and-dmitry/incubator-groovy shouldfail4-doc

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/55.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #55
    
----
commit b436eab366b6a0d6bd75500f94633c97e86d4154
Author: Dmitry Andreychuk <and.dmitry@gmail.com>
Date:   2015-07-06T19:55:01Z

    GROOVY-7474: Difference between junit3 and junit 4 shouldFail {...} not described in docs

----
;;;","07/Jul/15 10:16;paulk;Applied, thanks!;;;","07/Jul/15 10:35;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/55
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
inefficient code generation,GROOVY-7473,12839479,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,l.tontsch,l.tontsch,22/Jun/15 08:18,24/Jan/23 18:32,14/Jul/23 06:01,19/Nov/21 22:30,2.4.3,,,,,,,,,,,,,,,,,4.0.0-rc-1,,,,bytecode,Compiler,Static compilation,,0,bytecode,,,,,,"Groovy 2.4.3 generates not the most efficient byte code of a simple statement like ""in"".

e.g. The following statement:
{code:groovy}
if object.stringProperty in [""State1"", ""State2"", ""State3""]
{code}
gets complied in:
{code:java}
if (DefaultTypeTransformation.booleanUnbox((ScriptBytecodeAdapter.createList(new Object[] { ""State1"", ""State2"", ""State3"" }) == null ? 1 : 0) != 0 ? Boolean.valueOf(object.getStringProperty() == null) : Boolean.valueOf(DefaultGroovyMethods.isCase(ScriptBytecodeAdapter.createList(new Object[] { ""State1"", ""State2 "", ""State3"" }), object. getStringProperty ()))))
{code}
instead of this a more efficient construct would be the usage of an static list
e.g.
{code:java}
static List<String> l1;
static {
        l1 = new LinkedList<String>();
        l1.add(""State1"");
        l1.add(""State2"");
        l1.add(""State3"");
}

if (DefaultTypeTransformation.booleanUnbox((l1 == null ? 1 : 0) != 0 ? Boolean.valueOf(object.getStringProperty() == null) : Boolean.valueOf(DefaultGroovyMethods.isCase(l1, object. getStringProperty ()))))
{code}",,blackdrag,emilles,han.hu,l.tontsch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6137,,,,GROOVY-10909,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 19 22:30:39 UTC 2021,,,,,,,,,,"0|i2gbpj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jun/15 09:06;blackdrag;I was about to rant about the disassembler you used and that it does translate to very strange Java, but then I had the idea, that your code is maybe meant to be static compiled. And there it shows indeed the double creation of the list. Normal Groovy creates the list only once. 

As for putting the list in a static field... I could ask why for example Java doesn't do that for arrays. I am not sure it is always legal to do so.
;;;","16/Jul/15 13:27;han.hu;Hi Jochen,

thanks for your reply.

Yes, indeed. The code above is generated from static compilation.

Can you please elaborate a bit more on ""I could ask why for example Java doesn't do that for arrays.""

Thanks and regards;;;","16/Jul/15 13:45;blackdrag;Because an array is a mutable structure, even if it is handled slightly different than other mutable structures. That means I cannot see an array as constant and give it for example as argument to some method and expect I can reuse it later, because the method may change array elements. Lists are no better and we don't have the semantics that support the usage of constant lists in this case. So how can we be sure the method backing ""in"" will not mutate the list?;;;","31/Jul/15 12:54;han.hu;In general we agree with your statement that the list could be mutated by a method and thus we cannot expect to just reuse it later. However in this case, Groovy is creating a list just temporarily for its own purposes and has full control over what its methods (e.g. DefaultGroovyMethods.isCase() or DefaultTypeTransformation.booleanUnbox()) are doing with the list.

How about Collections. unmodifiableList(), would that help?

Another possible option may be to use switch-case as optimized implementation for the case when all values inside the list of the ""in""-construct are of primitive types or type String (probably quite often)? ;;;","01/Aug/15 05:56;blackdrag;Ok, I kind of forgot we are talking about static compilation and not standard Groovy. Because in standard Groovy you can do something like this:{code:Java}def bool1 = ""s"" in [""State1"", ""State2"", ""State3""]
ArrayList.metaClass.isCase = {Object o -> true}
def bool2 = ""s"" in [""State1"", ""State2"", ""State3""]
assert bool1 != bool2{code}
In such a case we would not be able to ensure the list is not modified. Now in static compilation runtime meta programming is of course not a deciding factor, but you can still have a different isCase method being applied, if you provide an extension method with fitting signature at compile time.

How is the compiler supposed to know it can make the list literal into something like a constant? So far your suggestion would mean a special case for list and isCase;;;","19/Nov/21 17:47;emilles;{{BinaryExpressionTransformer#convertInOperatorToTernary}} changes ""o.p in ['x','y','z']"" to ""['x','y','z'] == null ? o.p == null : ['x','y','z'].isCase(o.p)"". This could be made simpler for the times where right expression cannot be null.  And if {{isCase}} is overridden for {{{}NullObject{}}}, it could be ""['x','y','z']?.isCase(o.p)"" instead of a ternary.;;;","19/Nov/21 22:30;emilles;https://github.com/apache/groovy/commit/51749380ff43d1cdfb3164c3a9e858c9d5573b9d;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
type checker should use superclass bound when expected by generics,GROOVY-7468,12837638,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,chrylis,chrylis,14/Jun/15 00:55,03/Feb/22 22:42,14/Jul/23 06:01,11/Oct/21 17:17,2.4.3,,,,,,,,,,,,,,,,,4.0.0-alpha-3,,,,Static Type Checker,,,,0,,,,,,,"I believe this is a special case of a general problem with generics and the type checker.

When I attempt to call a method {{doSomething(Map<String,Object> params)}} with a Groovy inline map, the type checker constructs the map's types as the immediate greatest-common-superclass of the values provided. For example, this map:

{code}
[ val1: 3, val2: 5 ]
{code}

is always considered to be a {{LinkedHashMap<String,Integer>}}, which can't be passed to the above method. In *some*, but not all, cases using an explicit {{as Map<String,Object>}} will work.

In the circumstance where an inline map or other generic collection is  assigned to a variable or used as a method parameter, the type checker should be able to relax the inferred generic type bound to match the expected bound.",,chrylis,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 11 17:17:55 UTC 2021,,,,,,,,,,"0|i2g0in:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Apr/21 17:37;emilles;This should work now in Groovy 4:
{code:groovy}
def m(Map<String,Object> map) {
  // ...
}
@groovy.transform.TypeChecked
void test() {
  m([k: 0])
  m(k: 0)
}
{code}

Is there more you are looking for?;;;","11/Oct/21 17:17;emilles;https://github.com/apache/groovy/commit/c5fd01adbfe3f97c1defd12a18bf2096f970ecff

See GROOVY-7106, GROOVY-7274, GROOVY-8909, GROOVY-9844;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ResourceGroovyMethods/NioGroovyMethods BOM behavior is inconsistent,GROOVY-7465,12837134,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,keegan,keegan,keegan,11/Jun/15 13:18,02/May/17 02:03,14/Jul/23 06:01,09/Dec/15 22:45,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,groovy-jdk,,,,0,breaking_change,,,,,,"Most users would expect {{withPrintWriter}} to be a convenience method that behaves the same as if they had called {{new PrintWriter}} themselves, but this is not the current behavior:

{code:java}
File file = new File(""tmp.txt"")
try {
    String text = "" ""
    String charset = ""UTF-16LE""

    file.withPrintWriter(charset) { it << text }
    println ""withPrintWriter""
    file.getBytes().each { System.out.format(""%02x "", it) }

    PrintWriter w = new PrintWriter(file, charset)
    w.print(text)
    w.close()
    println ""\n\nnew PrintWriter""
    file.getBytes().each { System.out.format(""%02x "", it) }
} finally {
    file.delete()
}
{code}

Outputs
{noformat}
withPrintWriter
ff fe 20 00 

new PrintWriter
20 00
{noformat}

Additionally most users would expect that there's no difference in behavior between NIO and traditional methods, but this is also not the case

{code:java}
import java.nio.file.Files
import java.nio.file.FileSystems
import java.nio.file.Path

File file = new File(""tmp1.txt"")
Path path = FileSystems.getDefault().getPath(""tmp2.txt"")
try {
    String text = "" ""
    String charset = ""UTF-16LE""

    file.withPrintWriter(charset) { it << text }
    println ""withPrintWriter""
    file.getBytes().each { System.out.format(""%02x "", it) }

    path.withPrintWriter(charset) { it << text }
    println ""\n\nnio withPrintWriter""
    path.getBytes().each { System.out.format(""%02x "", it) }
} finally {
    file.delete()
    Files.delete(path)
}
{code}

outputs
{noformat}
withPrintWriter
ff fe 20 00

nio withPrintWriter
20 00
{noformat}

This is because {{ResourceGroovyMethods}} have a {{writeUTF16BomIfRequired}} method that {{NioGroovyMethods}} don't.

Most likely we'd want to change {{ResourceGroovyMethods}} to not add the BOM by default, or at least allow the user to opt out of that behavior by doing something like adding a boolean argument to the existing methods that would control that behavior.  The other option would be to make the NIO methods consistent by having them also use {{writeUTF16BomIfRequired}}.

This began as a [discussion|http://mail-archives.apache.org/mod_mbox/incubator-groovy-users/201506.mbox/browser] on the user mailing list.",,githubbot,keegan,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7661,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 08 04:41:24 UTC 2015,,,,,,,,,,"0|i2fxhj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jun/15 13:36;keegan;If we're good with the approach, I'm willing to take a crack at a PR if you wish.;;;","05/Jul/15 18:00;keegan;What should I put in the {{@Since}} tag?  {{1.4.5}}?;;;","05/Jul/15 21:53;paulk;I forget where discussions got to wrt breaking changes, If there is a risk of breaking change I'd push to 2.5 only, so {{@since 2.5.0}}.;;;","05/Jul/15 22:10;keegan;We last talked about changing the default behavior, so that would be a breaking change, yes.  I'll mark for 2.5.0.  Thanks [~paulk].;;;","05/Jul/15 22:10;keegan;And actually it just occurred to me that we should add a boolean for whether to write the BOM even when not specifying a charset, since the system default charset might be UTF-16.;;;","18/Aug/15 04:49;keegan;I'm thinking it doesn't make sense to give the option to write the BOM when writing using an InputStream or byte array.  Does that seem reasonable?;;;","03/Nov/15 01:29;githubbot;GitHub user keeganwitt opened a pull request:

    https://github.com/apache/incubator-groovy/pull/176

    GROOVY-7465: ResourceGroovyMethods/NioGroovyMethods BOM behavior is inconsistent

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/keeganwitt/incubator-groovy GROOVY-7465

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/176.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #176
    
----
commit 1a900a6758805c998cfa867e9964900abcb4ebef
Author: Keegan Witt <keeganwitt@gmail.com>
Date:   2015-07-22T13:08:46Z

    GROOVY-7465: ResourceGroovyMethods/NioGroovyMethods BOM behavior is inconsistent

----
;;;","08/Nov/15 07:44;githubbot;Github user PascalSchumacher commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/176#discussion_r44221781
  
    --- Diff: src/main/org/codehaus/groovy/runtime/ResourceGroovyMethods.java ---
    @@ -831,9 +836,8 @@ public static File leftShift(File file, InputStream data) throws IOException {
         }
     
         /**
    -     * Write the text to the File, using the specified encoding.  If the given
    -     * charset is ""UTF-16BE"" or ""UTF-16LE"" (or an equivalent alias), the
    -     * requisite byte order mark is written to the file before the text.
    +     * Write the text without a BOM to the File without writing a BOM, using
    --- End diff --
    
    This sentence seems a bit confusing to me.
;;;","08/Nov/15 07:45;githubbot;Github user PascalSchumacher commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/176#discussion_r44221782
  
    --- Diff: src/main/org/codehaus/groovy/runtime/ResourceGroovyMethods.java ---
    @@ -1800,6 +1925,20 @@ public static BufferedWriter newWriter(File file, boolean append) throws IOExcep
         }
     
         /**
    +     * Helper method to create a buffered writer for a file without writing a BOM.
    +     *
    +     * @param file    a File
    +     * @param charset the name of the encoding used to write in this file
    +     * @param append  true if in append mode
    +     * @return a BufferedWriter
    +     * @throws IOException if an IOException occurs.
    +     * @since 1.0
    --- End diff --
    
    should be 2.5.0
;;;","08/Nov/15 09:00;githubbot;Github user PascalSchumacher commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/176#discussion_r44222515
  
    --- Diff: src/main/org/codehaus/groovy/runtime/ResourceGroovyMethods.java ---
    @@ -974,11 +1021,30 @@ public static void append(File self, InputStream stream) throws IOException {
          * @since 1.0
          */
         public static void append(File file, Object text, String charset) throws IOException {
    +        append(file, text, charset, false);
    +    }
    +
    +    /**
    +     * Append the text at the end of the File, using a specified encoding.  If
    +     * the given charset is ""UTF-16BE"" or ""UTF-16LE"" (or an equivalent alias),
    +     * <code>writeBom</code> is <code>true</code>, and the file doesn't already
    +     * exist, the requisite byte order mark is written to the file before the
    +     * text is appended.
    +     *
    +     * @param file     a File
    +     * @param text     the text to append at the end of the File
    +     * @param charset  the charset used
    +     * @param writeBom whether to write a BOM
    +     * @throws IOException if an IOException occurs.
    +     * @since 2.5.0
    +     */
    +    public static void append(File file, Object text, String charset, boolean writeBom) throws IOException {
             Writer writer = null;
             try {
    +            boolean shouldWriteBom = writeBom && !file.exists();
                 FileOutputStream out = new FileOutputStream(file, true);
    -            if (!file.exists()) {
    -                writeUTF16BomIfRequired(charset, out);
    +            if (shouldWriteBom) {
    --- End diff --
    
    Shouldn't we keep the `!file.exists()` check?
;;;","08/Nov/15 10:15;githubbot;Github user PascalSchumacher commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/176#discussion_r44223209
  
    --- Diff: subprojects/groovy-nio/src/main/java/org/codehaus/groovy/runtime/NioGroovyMethods.java ---
    @@ -1540,12 +1709,33 @@ public static BufferedWriter newWriter(Path self, String charset) throws IOExcep
          * @since 2.3.0
          */
         public static <T> T withWriterAppend(Path self, String charset, @ClosureParams(value = SimpleType.class, options = ""java.io.Writer"") Closure<T> closure) throws IOException {
    -        return IOGroovyMethods.withWriter(newWriter(self, charset, true), closure);
    +        return withWriterAppend(self, charset, false, closure);
    +    }
    +
    +    /**
    +     * Create a new BufferedWriter which will append to this
    +     * file.  The writer is passed to the closure and will be closed before
    +     * this method returns.  The writer will use the given charset encoding.
    +     * If the given charset is ""UTF-16BE"" or ""UTF-16LE"" (or an equivalent alias),
    +     * <code>writeBom</code> is <code>true</code>, and the file doesn't already exist,
    +     * the requisite byte order mark is written to the stream when the writer is created.
    +     *
    +     * @param self    a Path
    +     * @param charset the charset used
    +     * @param writeBom whether to write the BOM
    +     * @param closure a closure
    +     * @return the value returned by the closure
    +     * @throws java.io.IOException if an IOException occurs.
    +     * @since 2.3.0
    --- End diff --
    
    should be 2.5.0
;;;","10/Nov/15 01:34;githubbot;Github user keeganwitt commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/176#discussion_r44360244
  
    --- Diff: src/main/org/codehaus/groovy/runtime/ResourceGroovyMethods.java ---
    @@ -831,9 +836,8 @@ public static File leftShift(File file, InputStream data) throws IOException {
         }
     
         /**
    -     * Write the text to the File, using the specified encoding.  If the given
    -     * charset is ""UTF-16BE"" or ""UTF-16LE"" (or an equivalent alias), the
    -     * requisite byte order mark is written to the file before the text.
    +     * Write the text without a BOM to the File without writing a BOM, using
    --- End diff --
    
    Oops, copy/paste error.  Good catch.
;;;","10/Nov/15 01:44;githubbot;Github user keeganwitt commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/176#discussion_r44361018
  
    --- Diff: src/main/org/codehaus/groovy/runtime/ResourceGroovyMethods.java ---
    @@ -974,11 +1021,30 @@ public static void append(File self, InputStream stream) throws IOException {
          * @since 1.0
          */
         public static void append(File file, Object text, String charset) throws IOException {
    +        append(file, text, charset, false);
    +    }
    +
    +    /**
    +     * Append the text at the end of the File, using a specified encoding.  If
    +     * the given charset is ""UTF-16BE"" or ""UTF-16LE"" (or an equivalent alias),
    +     * <code>writeBom</code> is <code>true</code>, and the file doesn't already
    +     * exist, the requisite byte order mark is written to the file before the
    +     * text is appended.
    +     *
    +     * @param file     a File
    +     * @param text     the text to append at the end of the File
    +     * @param charset  the charset used
    +     * @param writeBom whether to write a BOM
    +     * @throws IOException if an IOException occurs.
    +     * @since 2.5.0
    +     */
    +    public static void append(File file, Object text, String charset, boolean writeBom) throws IOException {
             Writer writer = null;
             try {
    +            boolean shouldWriteBom = writeBom && !file.exists();
                 FileOutputStream out = new FileOutputStream(file, true);
    -            if (!file.exists()) {
    -                writeUTF16BomIfRequired(charset, out);
    +            if (shouldWriteBom) {
    --- End diff --
    
    The check is still there, I just pulled it out into a separate variable (`shouldWriteBom`).  I could do it without a variable, I only use it once so it's not really necessary.
;;;","10/Nov/15 01:45;githubbot;Github user keeganwitt commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/176#discussion_r44361127
  
    --- Diff: subprojects/groovy-nio/src/main/java/org/codehaus/groovy/runtime/NioGroovyMethods.java ---
    @@ -1540,12 +1709,33 @@ public static BufferedWriter newWriter(Path self, String charset) throws IOExcep
          * @since 2.3.0
          */
         public static <T> T withWriterAppend(Path self, String charset, @ClosureParams(value = SimpleType.class, options = ""java.io.Writer"") Closure<T> closure) throws IOException {
    -        return IOGroovyMethods.withWriter(newWriter(self, charset, true), closure);
    +        return withWriterAppend(self, charset, false, closure);
    +    }
    +
    +    /**
    +     * Create a new BufferedWriter which will append to this
    +     * file.  The writer is passed to the closure and will be closed before
    +     * this method returns.  The writer will use the given charset encoding.
    +     * If the given charset is ""UTF-16BE"" or ""UTF-16LE"" (or an equivalent alias),
    +     * <code>writeBom</code> is <code>true</code>, and the file doesn't already exist,
    +     * the requisite byte order mark is written to the stream when the writer is created.
    +     *
    +     * @param self    a Path
    +     * @param charset the charset used
    +     * @param writeBom whether to write the BOM
    +     * @param closure a closure
    +     * @return the value returned by the closure
    +     * @throws java.io.IOException if an IOException occurs.
    +     * @since 2.3.0
    --- End diff --
    
    Yep, you're right.
;;;","10/Nov/15 06:46;githubbot;Github user PascalSchumacher commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/176#discussion_r44374647
  
    --- Diff: src/main/org/codehaus/groovy/runtime/ResourceGroovyMethods.java ---
    @@ -974,11 +1021,30 @@ public static void append(File self, InputStream stream) throws IOException {
          * @since 1.0
          */
         public static void append(File file, Object text, String charset) throws IOException {
    +        append(file, text, charset, false);
    +    }
    +
    +    /**
    +     * Append the text at the end of the File, using a specified encoding.  If
    +     * the given charset is ""UTF-16BE"" or ""UTF-16LE"" (or an equivalent alias),
    +     * <code>writeBom</code> is <code>true</code>, and the file doesn't already
    +     * exist, the requisite byte order mark is written to the file before the
    +     * text is appended.
    +     *
    +     * @param file     a File
    +     * @param text     the text to append at the end of the File
    +     * @param charset  the charset used
    +     * @param writeBom whether to write a BOM
    +     * @throws IOException if an IOException occurs.
    +     * @since 2.5.0
    +     */
    +    public static void append(File file, Object text, String charset, boolean writeBom) throws IOException {
             Writer writer = null;
             try {
    +            boolean shouldWriteBom = writeBom && !file.exists();
                 FileOutputStream out = new FileOutputStream(file, true);
    -            if (!file.exists()) {
    -                writeUTF16BomIfRequired(charset, out);
    +            if (shouldWriteBom) {
    --- End diff --
    
    I misread that. :( Sorry. 
;;;","08/Dec/15 04:41;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/176
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.json.internal.Dates instantiates objects without explicitly specifying the miliseconds parameter,GROOVY-7462,12836589,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,pascalschumacher,pascalschumacher,09/Jun/15 16:41,19/Oct/15 16:11,14/Jul/23 06:01,11/Jun/15 17:14,2.4.3,,,,,,,,,,,,,,,,,2.4.4,,,,JSON,,,,0,,,,,,,"groovy.json.internal.Dates instantiates objects without explicitly specifying the miliseconds parameter. By omission, it ends up using the value provided by Calendar.getInstance(), which is copied over from System.currentTimeMillis(). This is a problem when comparing dates.

Source: [https://mail-archives.apache.org/mod_mbox/incubator-groovy-dev/201506.mbox/%3CCAJ_y_NCp4EKX11DCd%3D%3D7pkoS-16Y2JBnB6xpy%2BDQenYTaOV9Ew%40mail.gmail.com%3E]",,githubbot,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 11 17:12:17 UTC 2015,,,,,,,,,,"0|i2fu7r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Jun/15 18:43;githubbot;GitHub user fmatosqg opened a pull request:

    https://github.com/apache/incubator-groovy/pull/39

    GROOVY-7462: Dates factory fix when initializing miliseconds field

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fmatosqg/incubator-groovy GROOVY-7462_fix_dates

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/39.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #39
    
----
commit 21d92d4d43df57ef2186b908f63c3e0de8035e54
Author: Fabio de Matos <fdematos@despegar.com>
Date:   2015-06-10T15:18:10Z

    GROOVY-7462: Dates factory fix when initializing miliseconds field

----
;;;","11/Jun/15 17:12;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/39
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy doesn't write BOM if UTF-16 alias is used,GROOVY-7461,12836528,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,glaforge,keegan,keegan,09/Jun/15 12:26,19/Oct/15 16:12,14/Jul/23 06:01,09/Jun/15 16:01,2.4.3,,,,,,,,,,,,,,,,,2.4.4,,,,groovy-jdk,,,,0,,,,,,,"The {{newWriter(charset, append)}}, {{File.append(text, charset)}}, {{File.write(text, charset)}} methods all don't write the UTF-16 BOM if an alias for UTF-16 is used.  For example, if the ""UTF_16LE"" alias for ""UTF-16LE"" is used, no BOM is written even though a BOM is written for the canonical name.  This is because {{writeUTF16BomIfRequired(charset, stream)}} only checks for the canonical name, and not any aliases.",,githubbot,keegan,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 09 17:42:49 UTC 2015,,,,,,,,,,"0|i2ftu7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jun/15 12:56;githubbot;GitHub user keeganwitt opened a pull request:

    https://github.com/apache/incubator-groovy/pull/36

    fix for GROOVY-7461

    I didn't see any unit tests for this method.  Feel free to point them out if I've missed it.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/keeganwitt/incubator-groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/36.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #36
    
----
commit cb623e5038f1478933afe35645a75f93ed1322a9
Author: Keegan Witt <keeganwitt@gmail.com>
Date:   2015-06-09T12:53:07Z

    fix for GROOVY-7461

----
;;;","09/Jun/15 12:56;keegan;PR: https://github.com/apache/incubator-groovy/pull/36;;;","09/Jun/15 13:05;keegan;Oh cool!  Didn't know we had automated PR linking.;;;","09/Jun/15 15:59;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/36
;;;","09/Jun/15 17:42;pascalschumacher;We gained the automated PR linking when we moved to Apache. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot static import inherited interface members,GROOVY-7460,12836208,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,gillius,gillius,08/Jun/15 16:51,08/Mar/22 12:16,14/Jul/23 06:01,25/Oct/21 17:29,2.4.3,,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,,"{code}
interface X {
  static final int CONST = 123
}

interface Y extends X {}

import static Y.*

println CONST
{code}

Expected 123 to printed, but instead get ""groovy.lang.MissingPropertyException: No such property: CONST for class: ConsoleScript4""

Code works if I static import X or if classes are used instead of interfaces. Same error occurs even with @CompileStatic code.",,gillius,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-06-08 16:51:27.0,,,,,,,,,,"0|i2frtb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE exception on ManagedLinkedList,GROOVY-7457,12835395,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,pablo72,pablo72,04/Jun/15 13:32,19/Oct/15 16:05,14/Jul/23 06:01,15/Oct/15 07:29,2.4.3,,,,,,,,,,,,,,,,,2.4.5,,,,groovy-runtime,,,,0,usertask,,,,,,"From time to time I'm getting the following exception. Unfortunately I was unable to replicate it in a test case.

{code}
java.lang.NullPointerException: null
	at org.codehaus.groovy.util.ManagedLinkedList$Element.finalizeReference(ManagedLinkedList.java:44) ~[groovy-2.4.3.jar:2.4.3]
	at org.codehaus.groovy.util.ReferenceManager$1.removeStallEntries(ReferenceManager.java:83) ~[groovy-2.4.3.jar:2.4.3]
	at org.codehaus.groovy.util.ReferenceManager$1.afterReferenceCreation(ReferenceManager.java:91) ~[groovy-2.4.3.jar:2.4.3]
	at org.codehaus.groovy.util.ReferenceManager$2.afterReferenceCreation(ReferenceManager.java:108) ~[groovy-2.4.3.jar:2.4.3]
	at org.codehaus.groovy.util.ManagedReference.<init>(ManagedReference.java:33) ~[groovy-2.4.3.jar:2.4.3]
	at org.codehaus.groovy.util.ManagedReference.<init>(ManagedReference.java:37) ~[groovy-2.4.3.jar:2.4.3]
	at org.codehaus.groovy.reflection.ClassInfo$ClassInfoCleanup.<init>(ClassInfo.java:514) ~[groovy-2.4.3.jar:2.4.3]
	at org.codehaus.groovy.reflection.ClassInfo.<init>(ClassInfo.java:75) ~[groovy-2.4.3.jar:2.4.3]
	at org.codehaus.groovy.reflection.ClassInfo$1.computeValue(ClassInfo.java:62) ~[groovy-2.4.3.jar:2.4.3]
	at org.codehaus.groovy.reflection.ClassInfo$1.computeValue(ClassInfo.java:59) ~[groovy-2.4.3.jar:2.4.3]
	at org.codehaus.groovy.reflection.v7.GroovyClassValueJava7.computeValue(GroovyClassValueJava7.java:18) ~[groovy-2.4.3.jar:2.4.3]
	at java.lang.ClassValue.getFromHashMap(ClassValue.java:227) ~[na:1.8.0_40]
	at java.lang.ClassValue.getFromBackup(ClassValue.java:209) ~[na:1.8.0_40]
	at java.lang.ClassValue.get(ClassValue.java:115) ~[na:1.8.0_40]
	at org.codehaus.groovy.reflection.ClassInfo.getClassInfo(ClassInfo.java:118) ~[groovy-2.4.3.jar:2.4.3]
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:255) ~[groovy-2.4.3.jar:2.4.3]
	at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:872) ~[groovy-2.4.3.jar:2.4.3]
	at groovy.lang.GroovyObjectSupport.<init>(GroovyObjectSupport.java:32) ~[groovy-2.4.3.jar:2.4.3]
	at groovy.lang.Closure.<init>(Closure.java:219) ~[groovy-2.4.3.jar:2.4.3]
	at nextflow.processor.TaskRun$_memoizedMethodPriv_getOutputFilesNames_closure10.<init>(TaskRun.groovy) ~[nextflow-0.14.0-SNAPSHOT.jar:na]
	at nextflow.processor.TaskRun.memoizedMethodPriv$getOutputFilesNames(TaskRun.groovy:378) ~[nextflow-0.14.0-SNAPSHOT.jar:na]

{code}","java version ""1.8.0_40""
Java(TM) SE Runtime Environment (build 1.8.0_40-b25)
Java HotSpot(TM) 64-Bit Server VM (build 25.40-b25, mixed mode)",candrews,pablo72,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7591,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 15 07:29:08 UTC 2015,,,,,,,,,,"0|i2fmsv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Oct/15 06:43;pascalschumacher;[~pablo72] if I remember correctly you wrote on the mailing list, that some other recent bugfix may also fix this problem? Does the NPE still occur with Groovy 2.4.5?;;;","14/Oct/15 06:57;pablo72;It seems that this problem was a side effect of using the ClassValue metadata introduced by this change [GROOVY-6704|https://issues.apache.org/jira/browse/GROOVY-6704]. 

Look also to this thread http://www.groovy-lang.org/mailing-lists.html#nabble-td5723731

As you are mentioning that change has been rolled back by [GROOVY-7591|https://issues.apache.org/jira/browse/GROOVY-7591]. I'm testing the latest version of Groovy and so far I haven't experienced any more the above exeption. 
;;;","15/Oct/15 07:29;pascalschumacher;@Paolo Thanks for the feedback. I'm closing this issue for now. You can reopen it later if the problem still exists. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Builders don't work in Traits,GROOVY-7456,12835339,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher1,graemerocher1,04/Jun/15 09:15,21/Jul/15 10:29,14/Jul/23 06:01,05/Jun/15 11:53,2.4.3,,,,,,,,,,,,,,,,,2.4.4,,,,,,,,0,,,,,,,"Traits don't take into account closure delegates, this completely breaks any builder or dynamic behaviour. The following example:

{code}
import groovy.xml.*

trait MyBuilder {
    def build2() {
        def mkp = new MarkupBuilder()
        
        mkp.foo {
            bar()
        }
    }
}

class Foo implements MyBuilder {

    def build1() {
        def mkp = new MarkupBuilder()
        
        mkp.foo {
            bar()
        }
    }
}

foo = new Foo()

foo.build1()
foo.build2()
{code}

Fails with:

{code}
roovy.lang.MissingMethodException: No signature of method: Foo.bar() is applicable for argument types: () values: []
Possible solutions: wait(), any(), wait(long), use([Ljava.lang.Object;), any(groovy.lang.Closure), is(java.lang.Object)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:56)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:51)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:110)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:114)
	at MyBuilder$Trait$Helper$_build2_closure1.doCall(ConsoleScript1:8)
	at MyBuilder$Trait$Helper$_build2_closure1.doCall(ConsoleScript1)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1016)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure.call(Closure.java:417)
	at groovy.util.BuilderSupport.doInvokeMethod(BuilderSupport.java:143)
	at groovy.util.BuilderSupport.invokeMethod(BuilderSupport.java:64)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:45)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:110)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:122)
	at MyBuilder$Trait$Helper.build2(ConsoleScript1:7)
{code}",,graemerocher1,nlancaster,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 01 20:04:23 UTC 2015,,,,,,,,,,"0|i2fmgf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jun/15 12:42;graemerocher1;Thanks!;;;","01/Jul/15 19:50;nlancaster;Does this fix also resolve [GROOVY-7373]?;;;","01/Jul/15 20:04;pascalschumacher;Sadly it does not, your example from [GROOVY-7373] still fails with ""groovy.lang.MissingPropertyException: No such property: delegate for class: TestClass"".;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic annotation should not support package target,GROOVY-7453,12835131,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,keegan,keegan,03/Jun/15 18:08,19/Oct/15 16:12,14/Jul/23 06:01,04/Jun/15 00:26,,,,,,,,,,,,,,,,,,2.4.4,,,,Static compilation,,,,0,,,,,,,"According to [this discussion|http://groovy.329449.n5.nabble.com/CompileStatic-at-package-level-td5717463.html], the CompileStatic annotation should have had the package target removed, but I didn't see that a Jira was ever opened to address this.",,keegan,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 04 00:51:14 UTC 2015,,,,,,,,,,"0|i2fl9r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jun/15 19:00;keegan;This came up in an SO [question|http://stackoverflow.com/questions/30627245/compilestatic-an-entire-package].;;;","04/Jun/15 00:26;paulk;removed as per Cédric's comments in the link;;;","04/Jun/15 00:27;paulk;Thanks for reporting the issue Keegan.;;;","04/Jun/15 00:39;keegan;Although Groovy-Eclipse happens to do the right thing, IntelliJ doesn't.  I opened [IDEA-141075|https://youtrack.jetbrains.com/issue/IDEA-141075] to make any adjustments they need to on their end.;;;","04/Jun/15 00:51;paulk;Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot reference inner classes of super classes by short name,GROOVY-7452,12835004,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,gromopetr,gromopetr,03/Jun/15 10:59,11/Nov/20 02:01,14/Jul/23 06:01,31/Oct/19 18:52,,,,,,,,,,,,,,,,,,2.5.8,,,,Compiler,,,,0,,,,,,,"e.g. paste this in Groovy web console:

{code}
​import java.nio.channels.*

abstract class Foo extends FileChannel {
  MapMode foo() { null }
}
print ""hi""​​​
{code}

startup failed:
Script1.groovy: 5: unable to resolve class MapMode 
 @ line 5, column 3.
     MapMode foo() { null }
     ^

1 error


If one qualifies the name: FileChannel.MapMode, the compilation succeeds

From https://youtrack.jetbrains.com/issue/IDEA-140769",,gromopetr,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 03 11:28:16 UTC 2015,,,,,,,,,,"0|i2fkjj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jun/15 11:26;paulk;Possibly related to: GROOVY-6301;;;","03/Jun/15 11:28;gromopetr;Looks like a duplicate actually. Couldn't find it myself, sorry.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractConcurrentMap performing rehash() on every insert,GROOVY-7448,12834553,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,glaforge,barti,barti,02/Jun/15 11:39,19/Oct/15 16:12,14/Jul/23 06:01,09/Jun/15 18:28,2.1.2,2.4.3,,,,,,,,,,,,,,,,2.4.4,,,,groovy-jdk,,,,0,,,,,,,"The problem happens in inner class org.codehaus.groovy.util.AbstractConcurrentMap.Segment.put() method (line 105):

When the current count is greater then map's threshold a rehash() happens. Now the tricky part is, that the Map holds soft references to objects and rehash() validates those references. So when GC discards soft references (e.isValid() == false), the resulting segment doesn't expand (as it is assumed in the put() method).

in the last line of rehash() the Segmen't internal counter is updated count = newCount (which is the number of undiscarded (e.isValid() == true) references and can be smaller than previous count as described above)

after rehash() is done, the put() method continues, however the buggy part is, that it disregards the previous setting of the internal count and it sets the previous count+1 value in every case on lines 124, 143 and 159 of AbstractConcurrentMapBase class.
Since the rehash() is called only from put() method, the internal counter is not synchronized with real elements count contained in underlying array and rehash() is called on all subsequent calls of put() method.

The following steps are happening:

1) Map state: threshold = 786432; count=786432
2) New element is inserted into the map: count = 786433; threshold = 786432
3) since new count would be greater than threshold rehash() happens
rehash() finds out, that most of the objects were garbage collected, thus it doesn't increase the size of the Segment, however anyway it copies all the objects from one table to another (System.arrayCopy()). (question: why this is done, in this case the old array with repaired invalid elements whould be sufficient ...? )
4) rehash() sets the internal count to new value, which is smaller, because many objects were garbage collected (soft references), lets say: count = 486 000
5) The put() continues, disregards the count = 486 000 and sets the count to count = 786433
6) When another element is inserted, the count is still greater than threshold so the rehash happens again
From now on every element added to map will trigger a rehash(), which has a huge performance impact.

When this happens in multithreaded environment, all the other threads are waiting (parked) for lock() until the rehash() and put() is done (and then the next one is doing the rehash() again and so on). You can imagine what performance impact this is.

Proposed solution:

Update the c variable after rehash is done. Between lines 105 and 106 of org.codehaus.groovy.util.AbstractConcurrentMap  add:
104: if (c++ > threshold) {

105:                rehash();

106:                c = count + 1

107:}",,barti,blackdrag,githubbot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,http://stackoverflow.com/questions/30593191/bug-in-groovy-abstractconcurrentmap?noredirect=1,,Important,Patch,,,,,,,,9223372036854775807,,,Tue Jun 09 18:26:51 UTC 2015,,,,,,,,,,"0|i2fia7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jun/15 13:17;blackdrag;congrats, a good find you made there! (and a nice bug report as well)

If you want to make a pull request for this and get your name into the codebase you are very welcome to do so. If not, then tell me and I do the change with setting c to count+1.

As for ""question: why this is done, in this case the old array with repaired invalid elements whould be sufficient ...? ""
That is a good question... looking at AbstractConcurrentMapBase#rehash, I actually see two loops that invalidate entries. The first one mutates the old table. The second loop will validate the entries again, before copying them into the new table. Those two together don't make sense to me. I could have said, that without mutating the old table, avoiding side effects for the get method was the goal... though I don't see those. In my opinion, the second loop can be skipped, if entries haven been invalidated, just as you said. But also the second loop does not need to do a revalidation.
;;;","02/Jun/15 15:29;barti;Thx, I've described my original problem [here|http://stackoverflow.com/questions/30598302/huge-performance-drop-in-cassandra-orm-after-million-records]. There is a dirty workaround howto invoke rehash() on its own. I'll be glad to make the pull request.;;;","04/Jun/15 13:16;githubbot;GitHub user tomasbartalos opened a pull request:

    https://github.com/apache/incubator-groovy/pull/33

    GROOVY-7448 fixed bug for permanent rehashing of AbstractConcurrentMap

    fixed bug https://issues.apache.org/jira/browse/GROOVY-7448

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/tomasbartalos/incubator-groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/33.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #33
    
----
commit a7e205694dc50e37720d87299fe211b5402ecdce
Author: tomasbartalos <tomas.bartalos+github@gmail.com>
Date:   2015-06-04T13:10:29Z

    GROOVY-7448 fixed bug for permanent rehashing of AbstractConcurrentMap

----
;;;","09/Jun/15 18:26;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/33
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
instantiating a class withTraits does not use the classloader of the trait,GROOVY-7443,12834077,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mchadfield,mchadfield,31/May/15 16:14,18/Oct/21 00:26,14/Jul/23 06:01,03/Aug/16 01:58,2.3.7,2.4.3,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,groovy-runtime,,,,0,class-generation,trait,traits,,,,"this fails:
def aWithB = new ClassA().withTraits(traitB)
when traitB is not from the classloader of class A.

full example code:
{code:Java}
package groovy.lang.traits

import org.codehaus.groovy.control.CompilerConfiguration;

class GroovyTraitsClassloaderTest {

	static class ClassA {
		
	}
	
	static trait TraitA {
		
		def aMethod() {
			println ""traitA method""
		}
		
	}
	
	static main(args) {
	
		
		def aWithA = new ClassA().withTraits(TraitA)
		
		aWithA.aMethod()
		
		
		GroovyClassLoader gcl = new GroovyClassLoader(Thread.currentThread().getContextClassLoader());
		
		Class classB = gcl.parseClass(""""""\
class ClassB {}
"""""")
		
		Class traitB = gcl.parseClass(""""""\
trait TraitB {
	
	def bMethod() {
		println ""traitB method""
	}
	
}
"""""")
		
		//ok
		def bWithA = classB.newInstance().withTraits(TraitA)

		//ok
		def bWithB = classB.newInstance().withTraits(traitB)
		bWithB.bMethod()
		
		//fails
		def aWithB = new ClassA().withTraits(traitB)
		
		aWithB.bMethod()
		
		
	}

}
{code}","jvm 1.7, MaxOSX",blackdrag,githubbot,mchadfield,paulk,siaroslaw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"31/May/15 16:19;mchadfield;GroovyTraitsClassloaderTest.groovy;https://issues.apache.org/jira/secure/attachment/12736436/GroovyTraitsClassloaderTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 03 01:58:15 UTC 2016,,,,,,,,,,"0|i2ffhb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jun/15 21:02;mchadfield;an example fix is here:
https://github.com/vital-ai/incubator-groovy/blob/d9e7110ebeda2194177303e536b0d3a220566103/src/main/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java

essentially the Traits are iterated over to find their classloader(s), and a delegating classloader is used for the class definition/loading.
;;;","03/Jun/15 06:32;blackdrag;fancy to make this into a pull request? You would have to change the tabs to 4 spaces though. As for the fix I have a question... why don't you try the parent loader first? You could catch the exception and safe it to rethrow it later, if the interfaces class loaders are not successful. At least if the loader is supposed to be well behaving and complying to the classloading constraints.

Also, technically you could avoid adding classloaders to the interface classloader set, if they are a parent of the parent loader... Though that is assuming well behaving class loaders - of classloaders we don't know, so I am not sure that should be really done. Just mentioning it for documentation actually.;;;","03/Jun/15 16:37;mchadfield;Yes, we can try to make this into a pull request.

We were trying a quick fix, but yes, the more general solution would be to check the parent first before the children.  This will be in the PR.

I'm not sure about identifying cases where the trait classloader happens to be a parent of the ""current"" classloader.  We could document then as something to consider going ahead in order to construct the minimal combined classloader.
;;;","05/Jun/15 15:43;githubbot;GitHub user dkobylarz opened a pull request:

    https://github.com/apache/incubator-groovy/pull/34

    GROOVY-7443: traits classloaders support

    GROOVY-7443: traits classloaders support

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/vital-ai/incubator-groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/34.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #34
    
----
commit 2328a026ead10203d988a85dda444b147db553d0
Author: hadfield <marc@vital.ai>
Date:   2015-06-02T13:11:23Z

    crude classloader test

commit d9e7110ebeda2194177303e536b0d3a220566103
Author: Dariusz Kobylarz <darek.kobylarz@gmail.com>
Date:   2015-06-02T14:17:43Z

    clean dynamic trait classloader code

commit 460bbe9bdc5bb45e7ec31b220abbd7870e79da51
Author: Dariusz Kobylarz <darek.kobylarz@gmail.com>
Date:   2015-06-05T14:22:40Z

    Merge remote-tracking branch 'upstream/master'

commit 499fd92b36e0207689eec28b20497876ddf228aa
Author: Dariusz Kobylarz <darek.kobylarz@gmail.com>
Date:   2015-06-05T15:39:54Z

    GROOVY-7443: traits classloaders support

----
;;;","05/Jun/15 15:50;siaroslaw;Jochen, thanks for the quality comments. We have just created a PR and the bot caught that fact.;;;","21/Jun/15 05:14;mchadfield;as per request, this was smooshed into a single commit, with updated PR.

;;;","02/Aug/16 11:30;paulk;I am wondering about the behavior we expect from the context class loader. The following code works prior to the change:
{code}
class GroovyTraitsClassloaderTest extends GroovyTestCase {
    static class ClassA {}
    static trait Trait1 { def method1() { 'Trait1 method' } }
    
    void testTraitsWithClassloading() {
        def aWith1 = new ClassA().withTraits(Trait1)        
        assert aWith1.method1() == 'Trait1 method'
        GroovyClassLoader gcl = getClass().classLoader // **
        Class classB = gcl.parseClass('class ClassB {}')
        Class trait2 = gcl.parseClass('trait Trait2 { def method2() { ""Trait2 method"" } }')
        def bWith1 = classB.newInstance().withTraits(Trait1)
        def bWith2 = classB.newInstance().withTraits(trait2)
        assert bWith2.method2() == 'Trait2 method'
        def aWith2 = new ClassA().withTraits(trait2)
        assert aWith2.method2() == 'Trait2 method'
    }
}
{code}
And the following currently fails but passes after the proposed change:
{code}
class GroovyTraitsClassloaderTest extends GroovyTestCase {
    static class ClassA {}
    static trait Trait1 { def method1() { 'Trait1 method' } }
    
    void testTraitsWithClassloading() {
        def aWith1 = new ClassA().withTraits(Trait1)        
        assert aWith1.method1() == 'Trait1 method'
        GroovyClassLoader gcl = new GroovyClassLoader(Thread.currentThread().contextClassLoader) // **
        Class classB = gcl.parseClass('class ClassB {}')
        Class trait2 = gcl.parseClass('trait Trait2 { def method2() { ""Trait2 method"" } }')
        def bWith1 = classB.newInstance().withTraits(Trait1)
        def bWith2 = classB.newInstance().withTraits(trait2)
        assert bWith2.method2() == 'Trait2 method'
        def aWith2 = new ClassA().withTraits(trait2)
        assert aWith2.method2() == 'Trait2 method'
    }
}
{code}
The only line different is the one marked with the ** comment.;;;","02/Aug/16 11:51;blackdrag;ClassA and Trait1 is known to getClass().classLoader, gcl has this loader as parent and knows Trait2, ClassB as well as ClassA and Trait1. Thus if you want to use withTraits for Trait1 the gcl must be selected as the loader (or a loader with gcl as parent) used for the proxy. And if the traits come from independent interfaces and loaders, a new loader must be used, that has multiple parents. So while the PR cannot be accepted as is, it goes in the right direction imho. I would not start on the context loader here;;;","02/Aug/16 12:55;paulk;The context loader is from the OP supplied example. I guess we need to rephrase then what problem we are trying to solve.;;;","02/Aug/16 17:20;blackdrag;what seems to happens is that we use the loader of ClassA or ClassB to create the proxy. This loader may not know the trait class and then it would fail loading the proxy class. I think the OP was trying to create such a situation using the context loader. And I would say, that this is supposed to work regardless of the loader the interface comes from;;;","03/Aug/16 01:56;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/34
;;;","03/Aug/16 01:58;paulk;Okay, I used the context class loader test as the test case to be fixed and merged the relevant commit from the PR.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
spread-dot operator within assert isn't expected with @CompileStatic,GROOVY-7442,12834061,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,paulk,paulk,31/May/15 10:55,22/Feb/16 20:48,14/Jul/23 06:01,17/Nov/15 05:04,2.4.3,,,,,,,,,,,,,,,,,2.4.6,,,,Static compilation,,,,0,,,,,,,"This source:
{code}
@groovy.transform.CompileStatic
def myMethod(String a, String b) {
  assert [a, b]*.size() == [5, 5]
}

myMethod('hello', 'world')
{code}
Results in this compile error:
{noformat}
BUG! exception in phase 'class generation' in source unit 'ConsoleScript1' In method public java.lang.Object MyMethod(java.lang.String a, java.lang.String b)  { ... }, CompileStack#removeVar: tried to remove a temporary variable with index 3 in wrong order. Current temporary variables=[iterator(index=6,type=java.util.Iterator <E extends java.lang.Object -> java.lang.Object>,holder=false), recorder(index=3,type=java.lang.Object,holder=false)]
    at org.codehaus.groovy.classgen.asm.CompileStack.removeVar(CompileStack.java:226)
    at org.codehaus.groovy.classgen.asm.AssertionWriter.writeAssertStatement(AssertionWriter.java:136)
    at org.codehaus.groovy.classgen.asm.StatementWriter.writeAssert(StatementWriter.java:550)
    at org.codehaus.groovy.classgen.AsmClassGenerator.visitAssertStatement(AsmClassGenerator.java:587)
*/
{noformat}
but this compiles and runs fine:
{code}
@groovy.transform.CompileStatic
def myMethod(String a, String b) {
  def result = [a, b]*.size()
  assert result == [5, 5]
}

myMethod('hello', 'world')
{code}",,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 17 05:04:03 UTC 2015,,,,,,,,,,"0|i2ffdz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Nov/15 16:52;shils;Note: this appears to be fixed as a side effect of my proposed fix for GROOVY-7656. This issue should be revisited if/when my changes for GROOVY-7656 have been merged (unless this issue has already been resolved at that point).;;;","17/Nov/15 05:04;shils;Fixed as a side effect of the changes for GROOVY-7656. Test from issue description added.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Improve ClosureParam type hints for various splitEachLine GroovyMethod methods,GROOVY-7440,12833929,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,30/May/15 01:23,02/May/17 02:03,14/Jul/23 06:01,31/May/15 11:37,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,"Currently, the {{splitEachLine}} extension methods in different files have slightly different type hints:
{code}
NioGroovyMethods:        @ClosureParams(value = FromString.class, options = ""List<String>"")
StringGroovyMethods:     @ClosureParams(value = FromString.class, options = ""List<String>"")
IOGroovyMethods:         @ClosureParams(value = FromString.class, options = ""List<String>"")
ResourceGroovyMethods:   @ClosureParams(value=SimpleType.class, options=""java.lang.String[]"")
{code}
The {{List<String>}} variant is the best match but the type checker is smart enough to handle some vararg cases too, so the following is actually better:
{code}
@ClosureParams(value=FromString.class,options={""List<String>"",""String[]""},conflictResolutionStrategy=PickFirstResolver.class)
{code}
",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 31 11:37:30 UTC 2015,,,,,,,,,,"0|i2fekv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/May/15 02:36;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/27

    GROOVY-7440: Improve ClosureParam type hints for various splitEachLin…

    …e GroovyMethod methods

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7440

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/27.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #27
    
----
commit 01d4a7afd33863dbd88bbe15e2ab01345a55b502
Author: Paul King <paulk@asert.com.au>
Date:   2015-05-30T01:34:10Z

    GROOVY-7440: Improve ClosureParam type hints for various splitEachLine GroovyMethod methods

----
;;;","31/May/15 11:11;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/27
;;;","31/May/15 11:37;paulk;pull request merged;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy should support resolving ambiguous signatures when using ClosureParams,GROOVY-7434,12832491,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,25/May/15 09:54,02/May/17 02:02,14/Jul/23 06:01,26/May/15 12:10,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,Static Type Checker,,,,0,,,,,,,"When using @ClosureParams annotated methods with @TC or @CS, if after applying type hints and built-in resolution based on number of parameters, generics analysis etc., more than one candidate signature is found, the usage will be flagged as ambiguous with a warning. It would be nice if instead a mechanism existed to resolve the ambiguity.",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7433,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 26 11:43:00 UTC 2015,,,,,,,,,,"0|i2f5u7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/May/15 11:51;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/24

    GROOVY-7434: Groovy should support resolving ambiguous signatures whe…

    …n using ClosureParams

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7434

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/24.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #24
    
----
commit 343282d2faa471d79615d1af50aeba09d81cc841
Author: Paul King <paulk@asert.com.au>
Date:   2015-05-25T11:49:08Z

    GROOVY-7434: Groovy should support resolving ambiguous signatures when using ClosureParams

----
;;;","26/May/15 11:43;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/24
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"API inconsistency between takeWhile, dropWhile and collectReplacements for CharSequences",GROOVY-7433,12832401,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,24/May/15 07:22,02/May/17 02:03,14/Jul/23 06:01,26/May/15 12:11,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,groovy-jdk,,,,0,breaking,,,,,,"When treating Strings as an iterable collection of characters, Groovy provides each character as a String of size 1, e.g.:
{code}
assert ""hello"".toList() == ['h', 'e', 'l', 'l', 'o']
assert ""hello"".toList()[0].class.name == 'java.lang.String'
""hello"".each {
  assert it instanceof String
}
{code}
There are just 3 methods where this isn't the case:
takeWhile, dropWhile and collectReplacements.
These methods supply a Character instead, e.g.:
{code}
assert ""he"" == ""hello"".takeWhile {
  assert it instanceof Character
  it != 'l'
}
{code}
This issue is to fix this inconsistency. This is a breaking change but of low impact:
* Most expressions within the closure such as {{it != 'A'}} or {{it < 'B'}} will produce the same results regardless of whether a String or character is passed in.
* Expressions using methods from the String class would have needed an ""as String"" or "".toString()"" coercion/conversion. These will still work unchanged but the coercion will no longer be required.(Which aligns them with the expressions for all other String iteration methods.)
* Closures with an explicit String arg currently don't work but would work after the change.
* Closures making use of instance methods from the Character class are breaking but those methods are ""charValue()"" and ""compareTo(Character anotherCharacter)"" and are likely rarely used (there use would be non-idiomatic Groovy).

In any case, I propose supporting the detection of supplied Closures having a char or Character argument in which case the char would be passed in as now. This would make fixing the break trivial for those cases.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7432,,,,,,,,,,,,GROOVY-7434,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-05-24 07:22:04.0,,,,,,,,,,"0|i2f5an:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE in SecureASTCustomizer for interface method declarations,GROOVY-7424,12829532,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,cmjartan,cmjartan,13/May/15 11:59,19/Oct/15 16:12,14/Jul/23 06:01,04/Jun/15 09:49,2.3.11,2.3.4,2.4.3,,,,,,,,,,,,,,,2.4.4,,,,Compiler,,,,0,,,,,,,"if you apply the SecureASTCustomizer to code that contains an interface method declaration, you get a NullPointerException at SecureASTCustomizer, Row 558 (Groovy 2.4.3)

{code:java}
        final SecuringCodeVisitor visitor = new SecuringCodeVisitor();
        ast.getStatementBlock().visit(visitor);
        for (ClassNode clNode : ast.getClasses()) {
            if (clNode!=classNode) {
                checkMethodDefinitionAllowed(clNode);
                for (MethodNode methodNode : clNode.getMethods()) {
                    if (!methodNode.isSynthetic()) {
=>                      methodNode.getCode().visit(visitor);
                    }
                }
            }
        }
{code}

",,cmjartan,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 04 09:49:40 UTC 2015,,,,,,,,,,"0|i2eodz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Jun/15 09:49;paulk;Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot choose between primitive and object variants of an overloaded method,GROOVY-7420,12828693,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,fpavageau,fpavageau,10/May/15 21:52,22/Feb/16 20:48,14/Jul/23 06:01,16/Dec/15 21:55,2.4.3,,,,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,test,,,,,,"The static type checked cannot choose which variant of a overloaded method with both primitive and object parameters (e.g. {{long}} and {{Long}}) to use when the actual type of the parameter is the object type (e.g. {{Long}}):

{code}
class A {
    static String m(long p) {
        ""primitive""
    }

    static String m(Long p) {
        ""object""
    }
}

Long l = 42L
A.m(l)
{code}
yields the following compilation error:
{noformat}
[Static type checking] - Reference to method is ambiguous. Cannot choose between [java.lang.String A#m(java.lang.Long), java.lang.String A#m(long)]
{noformat}

The problem can be worked around by explicitely calling {{.longValue()}} on the {{Long}}.",,fpavageau,githubbot,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7454,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 16 21:55:41 UTC 2015,,,,,,,,,,"0|i2ejbr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/May/15 21:59;githubbot;GitHub user fpavageau opened a pull request:

    https://github.com/apache/incubator-groovy/pull/10

    GROOVY-7420 Add a failing test

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fpavageau/incubator-groovy GROOVY-7420

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/10.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #10
    
----
commit 78eefd25b6a544940423f1fe270ff026fced721c
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-05-10T20:40:17Z

    GROOVY-7420 Add a failing test

----
;;;","10/May/15 22:01;fpavageau;I've created a [pull request on github|https://github.com/apache/incubator-groovy/pull/10] with the failing test. ;;;","21/May/15 17:13;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/10
;;;","03/Dec/15 21:47;githubbot;GitHub user fpavageau opened a pull request:

    https://github.com/apache/groovy/pull/204

    GROOVY-7420 Prefer a method signature without boxing or unboxing

    The method resolution mechanism is closer to what is done when following the
    Java Language Specification ([JLS 15.2.2](http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2)), and removes the ambiguity when
    calling a method having both primitive and object overloads with an object.


You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fpavageau/groovy GROOVY-7420

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/204.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #204
    
----
commit 2dca7ab130a016dd3bf9a98bd7233c5928a148bc
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-12-02T14:23:42Z

    GROOVY-7420 Remove some noise from the best method resolution

commit 3583d6d95d664dcfc91402ec324905cf731cd1bd
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-12-03T13:33:38Z

    GROOVY-7420 Prefer a method signature without boxing or unboxing
    
    The method resolution mechanism is closer to what is done when following the
    Java Language Specification (JLS 15.2.2), and removes the ambiguity when
    calling a method having both primitive and object overloads with an object.

----
;;;","16/Dec/15 21:54;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/204
;;;","16/Dec/15 21:55;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static Compilation with Diamond of local EnumMap<> ,GROOVY-7419,12828472,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,dsheehan,dsheehan,08/May/15 19:58,16/May/22 19:32,14/Jul/23 06:01,18/Mar/21 13:54,2.4.3,,,,,,,,,,,,,,,,,3.0.11,4.0.0-alpha-3,,,Static compilation,Static Type Checker,,,1,,,,,,,"{code:title=Foo.groovy}
import groovy.transform.CompileStatic

@CompileStatic
class Foo
{
    enum Blah {
        ONE, TWO
    }

    void broken()
    {
        Map<Blah,Object> foo = new EnumMap<>(Blah.class);
        assert foo.size() == 0;
    }

    void works()
    {
        Map<Blah,Object> foo = new HashMap<>();
        assert foo.size() == 0;
    }
}
{code}

{noformat}
""c:\Program Files (x86)\Groovy\Groovy-2.4.3\bin\groovyc"" Foo.groovy
{noformat}

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during instruction selection: 1

java.lang.ArrayIndexOutOfBoundsException: 1
        at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:164)
        at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:136)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1342)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1323)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.typeCheckMethodsWithGenericsOrFail(StaticTypeCheckingVisitor.java:4476)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2926)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:294)
        at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:548)
        at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBooleanExpression(CodeVisitorSupport.java:166)
        at org.codehaus.groovy.ast.expr.BooleanExpression.visit(BooleanExpression.java:40)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitAssertStatement(CodeVisitorSupport.java:77)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitAssertStatement(ClassCodeVisitorSupport.java:158)
        at org.codehaus.groovy.ast.stmt.AssertStatement.visit(AssertStatement.java:47)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1770)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2103)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2062)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:160)
        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1083)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:247)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:119)
        at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:60)
        at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
        at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1052)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:588)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:566)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:543)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:522)
        at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:59)
        at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:215)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:148)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:178)
        at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:162)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)

1 error
{noformat}","Groovy Version: 2.4.3 
JVM: 1.7.0_25 
Vendor: Oracle Corporation 
OS: Windows 7",dsheehan,mjjustin,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 26 04:13:03 UTC 2018,,,,,,,,,,"0|i2ehyv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/May/15 04:19;shils;This appears to happen as a result of the static type checker using the generic types of the type of the first argument to the constructor (Class<Blah>) instead of the generic types of the left hand type (Map<Blah, Object>) when inferring the diamond type.;;;","26/Aug/18 04:13;paulk;Current error message:
{noformat}
BUG! exception in phase 'instruction selection' in source unit 'ConsoleScript2' Expected earlier checking to detect generics parameter arity mismatch
Expected: java.util.EnumMap<K extends java.lang.Enum<K>,V> 
Supplied: java.util.EnumMap<Foo.Blah> 
{noformat};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@EqualsAndHashCode inconsistent when using boolean properties for classes with explicit getters,GROOVY-7417,12828248,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,chrylis,paulk,08/May/15 04:01,02/May/17 02:03,14/Jul/23 06:01,08/May/15 04:10,2.4.3,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,xforms,,,,0,,,,,,,The code within the generated @EAHC methods was sometimes using isProp and other times getProp for boolean properties for the case of having a field but also having an explicit getter override. This is an error related to but different from the non-field property case (GROOVY-7390).,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-05-08 04:01:16.0,,,,,,,,,,"0|i2eglr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With CompileStatic And Interface Methods In Abstract Subclass,GROOVY-7416,12828143,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jeffscottbrown,jeffscottbrown,07/May/15 21:45,21/Jul/15 10:29,14/Jul/23 06:01,04/Jul/15 01:31,2.4.3,,,,,,,,,,,,,,,,,2.4.4,,,,Compiler,,,,1,,,,,,,"The attached abstractcompilestatic.zip contains the following:

{code:borderStyle=solid|title=src/main/groovy/demo/SomeInterface.groovy}
package demo

interface SomeInterface {
    void someInterfaceMethod()
}
{code}

{code:borderStyle=solid|title=src/main/groovy/demo/AbstractSuperClass.groovy}
package demo

abstract class AbstractSuperClass implements SomeInterface {}
{code}

{code:borderStyle=solid|title=src/main/groovy/demo/AbstractSubClass.groovy}
package demo

import groovy.transform.CompileStatic

@CompileStatic
abstract class AbstractSubClass extends AbstractSuperClass {

    void someMethod() {
        someInterfaceMethod()
    }
}
{code}

The code will not compile.

{noformat}
 $ ./gradlew clean compileGroovy
:clean
:compileJava UP-TO-DATE
:compileGroovy
startup failed:
/Users/jeff/abstractcompilestatic/src/main/groovy/demo/AbstractSubClass.groovy: 9: [Static type checking] - Cannot find matching method demo.AbstractSubClass#someInterfaceMethod(). Please check if the declared type is right and if the method exists.
 @ line 9, column 9.
           someInterfaceMethod()
           ^

1 error

:compileGroovy FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileGroovy'.
> Compilation failed; see the compiler error output for details.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 4.045 secs
{noformat}

If the AbstractSubClass is modified to implement the interface as shown below the code will compile:


{code:borderStyle=solid|title=src/main/groovy/demo/AbstractSubClass.groovy}
package demo

import groovy.transform.CompileStatic

@CompileStatic
abstract class AbstractSubClass extends AbstractSuperClass implements SomeInterface {

    void someMethod() {
        someInterfaceMethod()
    }
}
{code}
",,githubbot,ikakara,jeffscottbrown,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7441,,,,,,,,,,,,,,,,,,,,,"30/May/15 02:55;ikakara;abstractcompilestatic.zip;https://issues.apache.org/jira/secure/attachment/12736310/abstractcompilestatic.zip","07/May/15 21:45;jeffscottbrown;abstractcompilestatic.zip;https://issues.apache.org/jira/secure/attachment/12731286/abstractcompilestatic.zip",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 04 01:31:43 UTC 2015,,,,,,,,,,"0|i2efzj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/May/15 21:46;jeffscottbrown;This was reported as a Grails issue at https://github.com/grails/grails-core/issues/694.;;;","22/May/15 20:13;shils;This seems to be caused by the static type checker not considering methods of interfaces declared but not implemented by the super class when attempting to find a given method. Specifically, {{findMethod(ClassNode, String, ClassNode...)}} in StaticTypeCheckingVisitor looks for unimplemented interface methods by calling {{collectAllInterfaceMethodsByName(ClassNode, String, List<MethodNode>)}} which only collects methods from interfaces declared by the given class. ;;;","23/May/15 04:28;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/23

    GROOVY-7416: Problem With CompileStatic And Interface Methods In Abst…

    …ract Subclass

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7416

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/23.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #23
    
----
commit 2dfddc67affc26727f9f09b1f1eda8c4b4df3c09
Author: Paul King <paulk@asert.com.au>
Date:   2015-05-23T04:27:44Z

    GROOVY-7416: Problem With CompileStatic And Interface Methods In Abstract Subclass

----
;;;","29/May/15 17:10;ikakara;When you fix this, can you be sure to make it work w/ traits (in place of interface) too?

Thanks!;;;","30/May/15 00:23;paulk;Allen, a PR with a trait test for this issue that fails now but you think should pass would be great.;;;","30/May/15 02:52;ikakara;I've created all the cases that I think should work for interfaces/traits:

{code}
abstract class ABaseClass implements SomeInterface, SomeTrait, TraitWithSomeOtherInterface {

}
abstract class ASubClass extends ABaseClass {
  void someMethod() { 
    someInterfaceMethod() 
    someTraitMethod() 
    someOtherInterfaceMethod() 
  }
}
interface SomeInterface { 
  void someInterfaceMethod() 
}
interface SomeOtherInterface { 
  void someOtherInterfaceMethod() 
}
trait SomeTrait { 
  abstract void someTraitMethod() 
}
trait TraitWithSomeOtherInterface implements SomeOtherInterface {

}
{code};;;","30/May/15 02:58;ikakara;For some reason I could not attach the files to this bug, so I created another bug: https://issues.apache.org/jira/browse/GROOVY-7441;;;","30/May/15 03:52;ikakara;I just noticed that I did attach the file ... JIRA sucks at feedback!  LOL ... feel free to close/cleanup the other issue;;;","18/Jun/15 19:09;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/23#discussion_r32766889
  
    --- Diff: src/test/groovy/transform/stc/BugsSTCTest.groovy ---
    @@ -650,4 +650,42 @@ Printer
                 List tmp = (List) m.get(""some_key_here"")     // <---  actually groovy crashes here!!
             '''
         }
    +
    +    // GROOVY-7416
    +    void testMethodsFromInterfacesOfSuperClassesShouldBeVisible() {
    +        assertScript '''
    +            import groovy.transform.CompileStatic
    +
    +            interface SomeInterface {
    +                void someInterfaceMethod()
    +            }
    +
    +            abstract class AbstractSuperClass implements SomeInterface {}
    +
    +            @CompileStatic
    --- End diff --
    
    Are the CompileStatic annotations here and in the following test necessary? BugsSTCTest extends StaticTypeCheckingTestCase.
;;;","04/Jul/15 01:16;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/23
;;;","04/Jul/15 01:31;paulk;proposed PR applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Map-to-interface cast: map method definition does not override the default method,GROOVY-7412,12826950,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,dmovchinn,dmovchinn,04/May/15 15:52,10/Aug/22 19:14,14/Jul/23 06:01,10/Aug/22 19:14,2.4.3,,,,,,,,,,,,,,,,,2.5.3,,,,groovy-runtime,,,,0,,,,,,,"The following code

{code:java}

import groovy.lang.GroovyShell;
import org.codehaus.groovy.control.CompilerConfiguration;

public class InterfaceDefaultMethods {

    public static void main(String... args) throws Exception {
        final CompilerConfiguration cc = new CompilerConfiguration();
        cc.setTargetBytecode(CompilerConfiguration.JDK8);
        final GroovyShell shell = new GroovyShell(cc);
        final X x = (X) shell.evaluate(""[x : {-> 3}, z: {-> 19}] as "" + X.class.getCanonicalName());
        System.out.format(""x = %d, y = %d, z = %d%n"", x.x(), x.y(), x.z());
    }

    public interface X {

        default int x() {
            return 1;
        }

        default int y() {
            return 2;
        }

        int z();
    }
}
{code}

produces

{noformat}
x = 1, y = 2, z = 19
{noformat}

but x must be 3.","JDK 1.8u45
Ubuntu 15.04 x86_64
Groovy 2.4.3",dmovchinn,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7330,,,,,,,GROOVY-10717,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Important,,,,,,,,,9223372036854775807,,,2015-05-04 15:52:16.0,,,,,,,,,,"0|i2e90f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler NPE Related To AST Transformations And Traits,GROOVY-7402,12823965,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jeffscottbrown,jeffscottbrown,25/Apr/15 06:08,18/Mar/17 09:56,14/Jul/23 06:01,01/Mar/17 13:14,2.4.3,,,,,,,,,,,,,,,,,2.4.10,,,,Compiler,,,,1,,,,,,,"Related to https://github.com/grails/grails-core/issues/663.

The attached traitannotation.zip includes the following:

{code:title=src/main/groovy/demo/SomeTrait.groovy|borderStyle=solid}
package demo

import groovy.transform.*

@Immutable
trait SomeTrait {
    String name
}
{code}

{code:title=src/main/groovy/demo/SomeClass.groovy|borderStyle=solid}
package demo

class SomeClass implements SomeTrait {}
{code}

Compilation raises an NPE:

{noformat}
$ ./gradlew clean cG
:clean
:compileJava UP-TO-DATE
:compileGroovy FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileGroovy'.
> BUG! exception in phase 'instruction selection' in source unit '/Users/jeff/traitannotation/src/main/groovy/demo/SomeTrait.groovy' unexpected NullpointerException

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED
{noformat}",,daniel_sun,digitarts,githubbot,graemerocher1,jeffscottbrown,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"25/Apr/15 06:11;jeffscottbrown;traitannotation.zip;https://issues.apache.org/jira/secure/attachment/12728134/traitannotation.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 01 13:14:31 UTC 2017,,,,,,,,,,"0|i2dr53:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jun/15 07:29;graemerocher1;For some reason via Gradle it is not possible to get the root cause stack trace, I attached a debugger to the Gradle process and was able to get a reference to the original exception and trace which is:

{code}
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.transform.trait.TraitASTTransformation$PostTypeCheckingExpressionReplacer.transform(TraitASTTransformation.java:554)
	at org.codehaus.groovy.ast.ClassCodeExpressionTransformer.visitField(ClassCodeExpressionTransformer.java:65)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1075)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.trait.TraitASTTransformation$1.call(TraitASTTransformation.java:264)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1052)
	... 84 more

{code};;;","01/Jun/15 07:33;melix;Is is still not recommended to use AST xforms in combination with traits, unless they are explicitly listed as compatible (like {{@CompileStatic}}. There are several reasons for this, both technical and logical: would an AST xform be applied on the trait itself, or on the class which implements the trait? Should the annotation still be visible? ... There are lots of unanswered questions here which are not so easy to answer.;;;","01/Jun/15 07:39;graemerocher1;Understood, I guess the confusion here from the user perspective is it works in a previous version of Groovy. If it isn't going to be allowed I would suggest a better compilation error;;;","01/Jun/15 07:42;melix;It's interesting to know it worked in a previous version of Groovy. I'm not sure we can improve the error message in a short timeframe (because errors thrown from AST xforms are hard to catch), but if it used to work, there's certainly something we can do.;;;","18/Jan/17 07:17;digitarts;Hi, guys, after upgrading from 2.4.7 to 2.4.8, I got an NPE during gradle compilation.

The most important is I did not use AST xforms on the trait, so I think it should be a new bug but similar to this one.

Please see my [sample project|https://github.com/zhanghuabin/groovy248-npe] to reproduce the problem.;;;","19/Jan/17 10:32;paulk;[~digitarts], I haven't yet investigated your sample project but please raise a new issue. If you look at the Trait documentation, it says, ""Traits only support public and private methods. Neither protected nor package private scopes are supported."" I guess we should clarify what that means for the protected property that you have used. I suspect that 2.4.7 and 2.4.8 might have slightly different assumptions in that case. It might end up being a duplicate of GROOVY-8048 but I think it is worth investigating separately.;;;","19/Jan/17 11:44;digitarts;Thanks, Paul, your solution works well: change protected to public.;;;","27/Jan/17 03:02;paulk;[~digitarts] I created this issue to track producing a better error message for protected fields: GROOVY-8066. Previously, they weren't really supported but the modifier was being ignored and treated as private. Whereas protected methods gave the correct error message.;;;","17/Feb/17 10:44;paulk;This turns out to be separate from GROOVY-8066 and GROOVY-8048. It is triggered by having @Immutable on the trait and we don't support most AST transforms (including @Immutable) in conjunction with traits. We can step around the NPE fairly easily but then the current behavior for annotations on traits kicks in which is to copy any annotations from the trait to the trait helper class. The issue then is that in this case, the abstract helper class is made final by @Immutable and a class can't be both abstract and final. The compiler has checks for such illegal modifier combinations but they aren't currently run on generated classes.

We could re-jig the annotation copying behavior to make this case work but it would probably break other cases.

We can in the short-term catch some of these errors and produce compiler warnings.

A more general solution would be to have a mechanism to specify where annotations on the trait might be targeted: on the trait itself, a class implementing a trait, the helper or field helper etc. but that is a bigger piece of work.;;;","18/Feb/17 06:35;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/499

    GROOVY-7402: Compiler NPE Related To AST Transformations And Traits

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7402

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/499.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #499
    
----
commit 9851c82a2b3cb2ae4d914daa523b9adc11faff0c
Author: paulk <paulk@asert.com.au>
Date:   2017-02-18T06:17:49Z

    GROOVY-7402: Compiler NPE Related To AST Transformations And Traits

----
;;;","18/Feb/17 06:42;paulk;I checked Groovy 2.3.0, the first release to contain traits, and combining @Immutable and traits (using the above example) resulted in the following error:
{code}
java.lang.ClassFormatError: Illegal class modifiers in class SomeTrait: 0x1419
{code}
The problem is the {{SomeTrait$Trait$Helper}} inner class within {{SomeTrait}} is both abstract and final.

The proposed PR removes the NPE and changes the above error to:
{code}
Error during @Immutable processing: annotation found on inappropriate class SomeTrait$Trait$Helper
{code}
I guess this could be improved a bit further but I think is an incremental improvement over what we have had in the past.
;;;","01/Mar/17 13:07;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/499
;;;","01/Mar/17 13:14;paulk;Proposed PR merged. Instead of a ClassFormatError or NPE in earlier versions of Groovy, there is now at least an error message. As we continue to  look at ways to better support combining traits and AST transformations, we can work out the semantics would be for @Immutable or improve the error message. I'll mark as resolved for now. Please reopen if you disagree.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Method ""with()"" fails to call on the object reference in Trait",GROOVY-7399,12823308,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,twongter,twongter,23/Apr/15 06:19,11/Nov/20 02:00,14/Jul/23 06:01,10/Aug/20 13:52,,,,,,,,,,,,,,,,,,3.0.6,4.0.0-alpha-1,,,groovy-runtime,,,,1,,,,,,,"{code}
class Bar implements FooTrait {
    def whoAmI() { ""It's Bar"" }
}

class Foo {
    def whoAmI() { ""It's Foo"" }
}

trait FooTrait {
    Foo f = new Foo()
    def hiFoo() {
        f.with {
            whoAmI() // it's Foo or Bar?!
        }
    }
}

Bar b = new Bar()
assert b.hiFoo() == b.f.whoAmI()
{code}

I would expect the {{assert}} on last line will pass, but it failed with
{noformat}
Assertion failed: 

assert b.hiFoo() == b.f.whoAmI()
       | |       |  | | |
       | It's Bar|  | | It's Foo
       |         |  | Foo@72967906
       |         |  Bar@5b8dfcc1
       |         false
       Bar@5b8dfcc1
{noformat}",,blackdrag,emilles,GeoffreyOnWheels,markhu,twongter,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 08 19:19:07 UTC 2020,,,,,,,,,,"0|i2dn5j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Apr/15 22:19;GeoffreyOnWheels;I've been away from Java for more than a few years, but let me see if I can tackle this.

First off, I wouldn't expect the *{{assert}}* to pass. Here's why.

Let's take a look at the last two lines of your code.

{code:JAVA|borderStyle=solid}
Bar b = new Bar()
assert b.hiFoo() == b.f.whoAmI()
{code}

At this point, b.hiFoo() should return ""It's Bar"" because in your Bar class, you defined whoAmI() to return this value. Thus, that's what gets assigned to the whoAmI() in your FooTrait, that is, f.with the Bar definition of whoAmI() as found in the Bar class instead of in the Foo class. 

On the other hand, b.f.whoAmI() bypasses the Bar class, so to speak. Thus, the definition of whoAmI() that returns ""It's Foo"" sticks because you are looking at the whoAmI() defined inside your f object. 

I don't think this is necessarily a bug, unless of course it conflicts with how we want traits to work when conflicting definitions pop up. To me, it makes sense to be able to bypass the Bar class' definition of whoAmI() to access how it's defined in the trait, FooTrait. So, to answer the question posed by your code...

{code:JAVA|borderStyle=solid}
trait FooTrait {
    Foo f = new Foo()
    def hiFoo() {
        f.with {
            whoAmI() // it's Foo or Bar?!
        }
    }
}
{code}

...whoAmI() is ""It's Bar"" when accessed as a trait of the class Bar and ""It's Foo"" when accessed as a definition within the object f created from the Foo class. Does that make sense?;;;","24/Apr/15 06:17;twongter;I'm not sure if my understand on {{with()}} is correct
i would expect
{code}
sth.with {
  prop=12
  fn()
}
{code}
be the same as
{code}
sth.prop = 12
sth.fn()
{code}

thanks;;;","24/Apr/15 06:21;twongter;I have created the example in [groovy web console|http://groovyconsole.appspot.com/script/5700305828184064]
it works fine in _2.3.x_;;;","24/Apr/15 08:52;blackdrag;""with"" sets a delegate for the open block, with the resolve strategy DELEGATE_FIRST, which means the delegate is tried first. ""f.with {"" means then a delegate with the value of f, thus ""whoAmI()"" should result in something equal to ""f.whoAmI()"". This is clearly a bug;;;","24/Apr/15 10:57;GeoffreyOnWheels;Yes, in that case, it seems that it's not following the resolve strategy *{{DELEGATE_FIRST}}*.;;;","01/Jun/17 04:21;markhu;Here's another variation --see line 8/9 which seems to ignore the {{.with}}

https://groovyconsole.appspot.com/script/5170505841639424;;;","08/Aug/20 19:19;emilles;Fixed by GROOVY-9386;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Broken links on index,GROOVY-7397,12822432,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,keegan,keegan,20/Apr/15 19:49,29/Jul/15 15:15,14/Jul/23 06:01,20/Apr/15 20:19,2.4.3,,,,,,,,,,,,,,,,,,,,,Documentation,,,,0,,,,,,,"The links below are broken on the [index|http://groovy-lang.org/documentation.html] page.
* Servlet support (http://groovy-lang.org/servlet.html)
* Creating Swing UIs (http://groovy-lang.org/swing.html)",,keegan,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Mon Apr 20 20:19:58 UTC 2015,,,,,,,,,,"0|i2dhwv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Apr/15 20:03;keegan;PR: https://github.com/groovy/groovy-website/pull/60;;;","20/Apr/15 20:19;keegan;Was reopening to change assignee, but I don't have the right permissions.  Not important.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@ToString could support non-field properties,GROOVY-7394,12821513,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,chrylis,paulk,16/Apr/15 12:25,02/May/17 02:03,14/Jul/23 06:01,29/Apr/15 06:21,2.4.3,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,xforms,,,,0,breaking,,,,,,"Cloned from the @EqualsAndHashCode issue to handle the same problem with @ToString as an independent issue.

I have the following class representing a location in Amazon S3. Depending on some inner business logic, I often need to split the object key into a prefix and a file name, so I access them all through the {{getKey()}} method; with S3, the only thing that matters is the final concatenated string.

The generated {{toString}} method doesn't display properties following the JavaBean conventions, e.g. with explicit getXxx() or isYyy() methods but no field as per normal Groovy conventions for properties with auto getters/setters.

{code}
import groovy.transform.*

@ToString(includes = ['bucket', 'key'], includeNames = true)
class S3ImageLocation {
    final String bucket
    final String prefix
    final String subKey

    S3ImageLocation(String bucket, String prefix, String subKey) {
        this.bucket = bucket
        this.prefix = prefix
        this.subKey = subKey
    }

    S3ImageLocation(String bucket, String subKey) {
        this(bucket, null, subKey)
    }

    String getKey() { prefix ? ""$prefix/$subKey"" : subKey }
}

// expected below (current is 'S3ImageLocation(bucket:foo)')
assert new S3ImageLocation('foo', 'bar', 'baz').toString() == 'S3ImageLocation(bucket:foo, key:bar/baz)'
{code}
",,githubbot,hubbitus,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7390,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 29 05:57:26 UTC 2015,,,,,,,,,,"0|i2dcdz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Apr/15 12:50;paulk;Added 'breaking' change label to signify that the toString() might change for objects containing pseudo properties.;;;","16/Apr/15 13:05;paulk;There is a pull request with a potential fix for discussion here:
https://github.com/groovy/groovy-core/pull/658;;;","20/Apr/15 10:54;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/2

    GROOVY-7394: @ToString could support non-field properties

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7394

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/2.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #2
    
----
commit 9c70fd45857e563e5fd9fc77bcaac2a8f46dc16a
Author: Paul King <paulk@asert.com.au>
Date:   2015-04-20T10:52:34Z

    GROOVY-7394: @ToString could support non-field properties

----
;;;","29/Apr/15 05:57;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/2
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper Fails on Valid JSON,GROOVY-7392,12820959,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,sgentry,sgentry,14/Apr/15 20:57,31/May/17 10:04,14/Jul/23 06:01,05/Jul/15 13:47,2.3.6,2.4.3,,,,,,,,,,,,,,,,2.4.4,,,,JSON,,,,0,,,,,,,"We are generating a har file (JSON representation of network traffic) to verify some information surrounding playback.

I am generating this har file, and regardless of the JsonParserType I use, I am getting the following error:

{code}
There was 1 error:
1) testEntries(Test)groovy.json.JsonException: Unable to parse JSON object

The current character read is '""' with an int value of 34
Unable to parse JSON object
line number 1
index number 1
"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 19,\n            \""defaultHeight\"": 20\n         }\n      },\n      \""IconLink_big\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""hover\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigHover\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 19,\n            \""defaultHeight\"": 20\n         }\n      },\n      \""IconLock\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""hover\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockHover\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 7,\n            \""defaultHeight\"": 9\n         }\n      },\n      \""IconMail\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconMail_bigNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n
.^
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeJsonObject(JsonParserUsingCharacterSource.java:100)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeValue(JsonParserUsingCharacterSource.java:137)
	at groovy.json.internal.JsonParserUsingCharacterSource.parse(JsonParserUsingCharacterSource.java:291)
	at groovy.json.internal.BaseJsonParser.parse(BaseJsonParser.java:149)
	at groovy.json.JsonSlurper.parseFile(JsonSlurper.java:364)
	at groovy.json.JsonSlurper.parse(JsonSlurper.java:345)
	at groovy.json.JsonSlurper$parse.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:110)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:122)
	at Test.testEntries(Test.groovy:7)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1440)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:940)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:78)
	at groovy.lang.GroovyShell.runJUnit3Test(GroovyShell.java:373)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:293)
	at groovy.lang.GroovyShell.run(GroovyShell.java:522)
	at groovy.lang.GroovyShell.run(GroovyShell.java:511)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:650)
	at groovy.ui.GroovyMain.run(GroovyMain.java:381)
	at groovy.ui.GroovyMain.process(GroovyMain.java:367)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:126)
	at groovy.ui.GroovyMain.main(GroovyMain.java:106)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
Caused by: groovy.json.JsonException: Unable to parse JSON object

The current character read is '""' with an int value of 34
Unable to parse JSON object
line number 1
index number 1
"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 19,\n            \""defaultHeight\"": 20\n         }\n      },\n      \""IconLink_big\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""hover\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigHover\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 19,\n            \""defaultHeight\"": 20\n         }\n      },\n      \""IconLock\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""hover\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockHover\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 7,\n            \""defaultHeight\"": 9\n         }\n      },\n      \""IconMail\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconMail_bigNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n
.^
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeJsonObject(JsonParserUsingCharacterSource.java:100)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeValue(JsonParserUsingCharacterSource.java:137)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeJsonObject(JsonParserUsingCharacterSource.java:78)
	... 49 more
Caused by: groovy.json.JsonException: Unexpected issue

The current character read is '""' with an int value of 34
Unexpected issue
line number 1
index number 1
"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 19,\n            \""defaultHeight\"": 20\n         }\n      },\n      \""IconLink_big\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""hover\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigHover\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 19,\n            \""defaultHeight\"": 20\n         }\n      },\n      \""IconLock\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""hover\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockHover\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 7,\n            \""defaultHeight\"": 9\n         }\n      },\n      \""IconMail\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconMail_bigNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n
.^
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeJsonArray(JsonParserUsingCharacterSource.java:280)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeValue(JsonParserUsingCharacterSource.java:133)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeJsonObject(JsonParserUsingCharacterSource.java:78)
	... 51 more
Caused by: groovy.json.JsonException: Unable to parse JSON object

The current character read is '""' with an int value of 34
Unable to parse JSON object
line number 1
index number 1
"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 19,\n            \""defaultHeight\"": 20\n         }\n      },\n      \""IconLink_big\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""hover\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigHover\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 19,\n            \""defaultHeight\"": 20\n         }\n      },\n      \""IconLock\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""hover\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockHover\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 7,\n            \""defaultHeight\"": 9\n         }\n      },\n      \""IconMail\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconMail_bigNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n
.^
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeJsonObject(JsonParserUsingCharacterSource.java:100)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeValue(JsonParserUsingCharacterSource.java:137)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeJsonArray(JsonParserUsingCharacterSource.java:253)
	... 53 more
Caused by: groovy.json.JsonException: Unable to parse JSON object

The current character read is '""' with an int value of 34
Unable to parse JSON object
line number 1
index number 1
"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 19,\n            \""defaultHeight\"": 20\n         }\n      },\n      \""IconLink_big\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""hover\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigHover\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 19,\n            \""defaultHeight\"": 20\n         }\n      },\n      \""IconLock\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""hover\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockHover\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 7,\n            \""defaultHeight\"": 9\n         }\n      },\n      \""IconMail\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconMail_bigNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n
.^
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeJsonObject(JsonParserUsingCharacterSource.java:100)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeValue(JsonParserUsingCharacterSource.java:137)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeJsonObject(JsonParserUsingCharacterSource.java:78)
	... 55 more
Caused by: groovy.json.JsonException: Unable to parse JSON object

The current character read is '""' with an int value of 34
Unable to parse JSON object
line number 1
index number 1
"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 19,\n            \""defaultHeight\"": 20\n         }\n      },\n      \""IconLink_big\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""hover\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigHover\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLink_bigDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 110,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 19,\n                     \""cropHeight\"": 20,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 19,\n            \""defaultHeight\"": 20\n         }\n      },\n      \""IconLock\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""hover\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockHover\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlHoverColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""selected\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockSelected\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""controlSelectedColor\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            },\n            \""disabled\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconLockDisabled\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n                     \""top\"": 0,\n                     \""right\"": 0,\n                     \""bottom\"": 0,\n                     \""left\"": 0,\n                     \""cropX\"": 534,\n                     \""cropY\"": 1,\n                     \""cropWidth\"": 7,\n                     \""cropHeight\"": 9,\n                     \""scale9Top\"": 0,\n                     \""scale9Right\"": 0,\n                     \""scale9Bottom\"": 0,\n                     \""scale9Left\"": 0\n                  }\n               ]\n            }\n         },\n         \""properties\"": {\n            \""defaultWidth\"": 7,\n            \""defaultHeight\"": 9\n         }\n      },\n      \""IconMail\"": {\n         \""states\"": {\n            \""normal\"": {\n               \""layers\"": [\n                  {\n                     \""name\"": \""IconMail_bigNormal\"",\n                     \""type\"": \""image\"",\n                     \""color\"": \""#b3b3b3\"",\n                     \""alpha\"": 1,\n                     \""url\"": \""library:GlassFormsAssets\"",\n
.^
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeJsonObject(JsonParserUsingCharacterSource.java:100)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeValue(JsonParserUsingCharacterSource.java:137)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeJsonObject(JsonParserUsingCharacterSource.java:78)
	... 57 more
Caused by: java.lang.ArrayIndexOutOfBoundsException: 73494
	at groovy.json.internal.CharBuf.decodeJsonString(CharBuf.java:765)
	at groovy.json.internal.CharBuf.decodeJsonString(CharBuf.java:746)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeString(JsonParserUsingCharacterSource.java:220)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeValue(JsonParserUsingCharacterSource.java:117)
	at groovy.json.internal.JsonParserUsingCharacterSource.decodeJsonObject(JsonParserUsingCharacterSource.java:78)
	... 59 more

FAILURES!!!
Tests run: 1,  Failures: 0,  Errors: 1
{code}

I have run the attached Test Case in 2.3.6 and 2.4.3. In addition I have used three separate tools to verify that the json is in fact valid.",Mac Yosemite,gareth@logicalpractice.com,pascalschumacher,sgentry,sschuberth,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"14/Apr/15 20:58;sgentry;Test.groovy;https://issues.apache.org/jira/secure/attachment/12725380/Test.groovy","14/Apr/15 20:58;sgentry;video-playthrough.har;https://issues.apache.org/jira/secure/attachment/12725381/video-playthrough.har",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jul 05 13:47:47 UTC 2015,,,,,,,,,,"0|i2d8zr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Apr/15 02:41;sgentry;I was able to test this against 2.2.2 and the test is able to slurp the json.;;;","05/Jul/15 13:47;pascalschumacher;Test works with current master. I guess the fix for [GROOVY-7476] or some other bugfix solved this too.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Indy ignores custom invoker in meta class,GROOVY-7391,12820803,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,14/Apr/15 12:50,19/Oct/15 16:11,14/Jul/23 06:01,14/Apr/15 18:53,,,,,,,,,,,,,,,,,,2.4.4,,,,groovy-runtime,,,,0,,,,,,,"{code}
import groovy.xml.Entity

class InterceptionThroughMetaClassTest extends GroovyTestCase {
    void testPOJOMetaClassInterception() {
        String invoking = 'ha'
        invoking.metaClass.invokeMethod = {String name, Object args ->
            'invoked'
        }
        assert invoking.length() == 'invoked'
        assert invoking.someMethod() == 'invoked'
    }
    void testPOGOMetaClassInterception() {
        Entity entity = new Entity('Hello')
        entity.metaClass.invokeMethod = {String name, Object args ->
            'invoked'
        }
        assert entity.build(new X()) == 'invoked'
        assert entity.someMethod() == 'invoked'
    }
}

class X {}{code}
This program is based on https://github.com/groovy/groovy-core/pull/651.

The test works fine for normal Groovy but fails with indy, because indy ignores the custom invoker given through invokeMethod.",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 14 18:53:38 UTC 2015,,,,,,,,,,"0|i2d84v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Apr/15 18:53;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@EqualsAndHashCode incorrect when using non-field properties,GROOVY-7390,12820718,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,chrylis,chrylis,14/Apr/15 05:39,06/Mar/18 23:25,14/Jul/23 06:01,02/Feb/18 01:25,2.4.3,,,,,,,,,,,,,,,,,2.5.0-beta-3,,,,,,,,0,,,,,,,"I have the following class representing a location in Amazon S3. Depending on some inner business logic, I often need to split the object key into a prefix and a file name, so I access them all through the {{getKey()}} method; with S3, the only thing that matters is the final concatenated string.

The generated {{equals}} method incorrectly returns true for any two objects with the same bucket, ignoring the key property. (I discovered this when I got some interesting results out of a JSR-330 cache.) I have marked this issue critical because it is likely to cause immediate security vulnerabilities and data loss when unequal objects are found equal.

{code}
@CompileStatic
@EqualsAndHashCode(includes = ['bucket', 'key'])
final class S3ImageLocation implements ImageLocation {
    @NotNull
    final String bucket

    final String prefix

    @NotNull
    final String subKey

    @PersistenceConstructor
    S3ImageLocation(String bucket, String prefix, String subKey) {
        this.bucket = bucket
        this.prefix = prefix
        this.subKey = subKey
    }

    S3ImageLocation(String bucket, String subKey) {
        this(bucket, null, subKey)
    }

    @JsonIgnore
    String getKey() {
        prefix ? ""$prefix/$subKey"" : subKey
    }

    @Override
    String toString() {
        ""s3://$bucket/$key""
    }

    S3Location toBlitlineLocation() {
        new S3Location(bucket, key)
    }
}
{code}

Both of the generated methods appear to be including {{bucket}} twice instead of including {{bucket}} and {{key}}.

see :7 and :29
{code}
  public int hashCode();
    Code:
       0: invokestatic  #93                 // Method org/codehaus/groovy/util/HashCodeHelper.initHash:()I
       3: istore_1
       4: iload_1
       5: pop
       6: aload_0
       7: ldc           #94                 // String bucket
       9: invokestatic  #100                // Method org/codehaus/groovy/runtime/InvokerHelper.getProperty:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;
      12: aload_0
      13: invokestatic  #106                // Method org/codehaus/groovy/runtime/DefaultGroovyMethods.is:(Ljava/lang/Object;Ljava/lang/Object;)Z
      16: ifne          23
      19: iconst_1
      20: goto          24
      23: iconst_0
      24: ifeq          42
      27: iload_1
      28: aload_0
      29: ldc           #94                 // String bucket
      31: invokestatic  #100                // Method org/codehaus/groovy/runtime/InvokerHelper.getProperty:(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;
      34: invokestatic  #110                // Method org/codehaus/groovy/util/HashCodeHelper.updateHash:(ILjava/lang/Object;)I
      37: istore_2
      38: iload_2
      39: istore_1
      40: iload_2
      41: pop
      42: iload_1
      43: ireturn
      44: ldc           #113                // int 0
      46: ireturn
{code}

see :152/:171 and :208/:219
{code}
  public boolean equals(java.lang.Object);
    Code:
       0: aload_1
       1: ifnonnull     8
       4: iconst_1
       5: goto          9
       8: iconst_0
       9: ifeq          19
      12: getstatic     #129                // Field java/lang/Boolean.FALSE:Ljava/lang/Boolean;
      15: invokestatic  #58                 // Method org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox:(Ljava/lang/Object;)Z
      18: ireturn
      19: aload_0
      20: aload_1
      21: invokestatic  #106                // Method org/codehaus/groovy/runtime/DefaultGroovyMethods.is:(Ljava/lang/Object;Ljava/lang/Object;)Z
      24: ifeq          34
      27: getstatic     #132                // Field java/lang/Boolean.TRUE:Ljava/lang/Boolean;
      30: invokestatic  #58                 // Method org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox:(Ljava/lang/Object;)Z
      33: ireturn
      34: aload_1
      35: instanceof    #2                  // class com/artsquare/studio/img/s3/S3ImageLocation
      38: ifne          45
      41: iconst_1
      42: goto          46
      45: iconst_0
      46: ifeq          56
      49: getstatic     #129                // Field java/lang/Boolean.FALSE:Ljava/lang/Boolean;
      52: invokestatic  #58                 // Method org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox:(Ljava/lang/Object;)Z
      55: ireturn
      56: aload_1
      57: ldc           #2                  // class com/artsquare/studio/img/s3/S3ImageLocation
      59: invokestatic  #138                // Method org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType:(Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;
      62: checkcast     #2                  // class com/artsquare/studio/img/s3/S3ImageLocation
      65: astore_2
      66: aload_2
      67: pop
      68: aload_2
      69: aload_0
      70: invokevirtual #140                // Method canEqual:(Ljava/lang/Object;)Z
      73: ifne          80
      76: iconst_1
      77: goto          81
      80: iconst_0
      81: ifeq          91
      84: getstatic     #129                // Field java/lang/Boolean.FALSE:Ljava/lang/Boolean;
      87: invokestatic  #58                 // Method org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox:(Ljava/lang/Object;)Z
      90: ireturn
      91: aload_0
      92: invokevirtual #143                // Method getBucket:()Ljava/lang/String;
      95: aload_2
      96: invokevirtual #143                // Method getBucket:()Ljava/lang/String;
      99: invokestatic  #106                // Method org/codehaus/groovy/runtime/DefaultGroovyMethods.is:(Ljava/lang/Object;Ljava/lang/Object;)Z
     102: ifne          109
     105: iconst_1
     106: goto          110
     109: iconst_0
     110: ifeq          274
     113: aload_0
     114: invokevirtual #143                // Method getBucket:()Ljava/lang/String;
     117: aload_0
     118: invokestatic  #106                // Method org/codehaus/groovy/runtime/DefaultGroovyMethods.is:(Ljava/lang/Object;Ljava/lang/Object;)Z
     121: ifeq          147
     124: aload_2
     125: invokevirtual #143                // Method getBucket:()Ljava/lang/String;
     128: aload_2
     129: invokestatic  #106                // Method org/codehaus/groovy/runtime/DefaultGroovyMethods.is:(Ljava/lang/Object;Ljava/lang/Object;)Z
     132: ifne          139
     135: iconst_1
     136: goto          140
     139: iconst_0
     140: ifeq          147
     143: iconst_1
     144: goto          148
     147: iconst_0
     148: ifne          189
     151: aload_0
     152: invokevirtual #143                // Method getBucket:()Ljava/lang/String;
     155: aload_0
     156: invokestatic  #106                // Method org/codehaus/groovy/runtime/DefaultGroovyMethods.is:(Ljava/lang/Object;Ljava/lang/Object;)Z
     159: ifne          166
     162: iconst_1
     163: goto          167
     166: iconst_0
     167: ifeq          185
     170: aload_2
     171: invokevirtual #143                // Method getBucket:()Ljava/lang/String;
     174: aload_2
     175: invokestatic  #106                // Method org/codehaus/groovy/runtime/DefaultGroovyMethods.is:(Ljava/lang/Object;Ljava/lang/Object;)Z
     178: ifeq          185
     181: iconst_1
     182: goto          186
     185: iconst_0
     186: ifeq          193
     189: iconst_1
     190: goto          194
     193: iconst_0
     194: ifeq          207
     197: getstatic     #129                // Field java/lang/Boolean.FALSE:Ljava/lang/Boolean;
     200: invokestatic  #58                 // Method org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox:(Ljava/lang/Object;)Z
     203: ireturn
     204: goto          274
     207: aload_0
     208: invokevirtual #143                // Method getBucket:()Ljava/lang/String;
     211: aload_0
     212: invokestatic  #106                // Method org/codehaus/groovy/runtime/DefaultGroovyMethods.is:(Ljava/lang/Object;Ljava/lang/Object;)Z
     215: ifeq          233
     218: aload_2
     219: invokevirtual #143                // Method getBucket:()Ljava/lang/String;
     222: aload_2
     223: invokestatic  #106                // Method org/codehaus/groovy/runtime/DefaultGroovyMethods.is:(Ljava/lang/Object;Ljava/lang/Object;)Z
     226: ifeq          233
     229: iconst_1
     230: goto          234
     233: iconst_0
     234: ifne          241
     237: iconst_1
     238: goto          242
     241: iconst_0
     242: ifeq          274
     245: aload_0
     246: invokevirtual #143                // Method getBucket:()Ljava/lang/String;
     249: aload_2
     250: invokevirtual #143                // Method getBucket:()Ljava/lang/String;
     253: invokestatic  #146                // Method org/codehaus/groovy/runtime/ScriptBytecodeAdapter.compareEqual:(Ljava/lang/Object;Ljava/lang/Object;)Z
     256: ifne          263
     259: iconst_1
     260: goto          264
     263: iconst_0
     264: ifeq          274
     267: getstatic     #129                // Field java/lang/Boolean.FALSE:Ljava/lang/Boolean;
     270: invokestatic  #58                 // Method org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox:(Ljava/lang/Object;)Z
     273: ireturn
     274: getstatic     #132                // Field java/lang/Boolean.TRUE:Ljava/lang/Boolean;
     277: invokestatic  #58                 // Method org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox:(Ljava/lang/Object;)Z
     280: ireturn
     281: ldc           #113                // int 0
     283: invokestatic  #122                // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
     286: invokestatic  #58                 // Method org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox:(Ljava/lang/Object;)Z
     289: ireturn
{code}",,chrylis,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7394,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 02 01:25:00 UTC 2018,,,,,,,,,,"0|i2d7mf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Apr/15 05:46;chrylis;This bug is independent of {{@CompileStatic}}. It appears to be triggered by using either {{includes}} or {{excludes}} with a non-field property in the candidate set. Using only field-backed properties produces correct but repetitive bytecode (apparently checking each of the candidate properties multiple times).;;;","15/Apr/15 11:05;paulk;The ""duplicate"" code is some code that checks for recursive self-references. Such checking is only needed when property types are compatible. On the latest master branch, there is an optimization so that the duplicate code isn't added for cases when it isn't needed. So it shouldn't appear for your case above anymore.

With respect to non-field properties, you are correct that they aren't supported by the current transform. You could argue that we should improve the doco and/or produce an error since we do nothing with 'key'. There is an outstanding PR https://github.com/groovy/groovy-core/pull/569 that would flag such usage as errors.;;;","08/May/15 04:13;paulk;Just an update. I have a patch that fixes the issue for standard cases. It just doesn't handle tricky generics cases yet. I am hoping to have time to get the generics cases working before submitting the changes,;;;","02/Feb/18 01:25;paulk;You can now add the {{allProperties}} annotation attribute for JavaBean properties to be automatically handled.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Trait compilation error: IllegalArgumentException: Comparison method violates its general contract!,GROOVY-7387,12820526,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,andy722,andy722,13/Apr/15 12:39,19/Oct/15 16:05,14/Jul/23 06:01,13/Sep/15 09:49,2.3.6,2.4.3,,,,,,,,,,,,,,,,2.4.5,,,,Compiler,,,,1,,,,,,,"The smallest sample I could create is the following. 
We've got two Groovy classes, one of which is a trait and another implements that trait.

{code:title=TestTrait.groovy}
package test

trait TestTrait {
  Object userRepository
  Object respondentRepository
  Object surveyStatsRepository
  Object surveyRepository
  Object questionRepository
  Object questionOptionRepository
  Object answerRepository
  Object surveyInvitationRepository
  Object invitationDeliveryRepository
  Object surveyPatternRepository
  Object accessNumberRepository
  Object deliverySubscriberRepository
}
{code}

{code:title=TestClass.groovy}
package test

class TestClass implements TestTrait {
}
{code}

Then let's compile those using the command line:

{code}
$ JAVA_HOME/bin/java -cp ../lib/groovy-all-2.4.3.jar  org.codehaus.groovy.tools.FileSystemCompiler -cp ../lib/groovy-all-2.4.3.jar test/*
{code}

This results in the following compiler error:
{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during canonicalization: Comparison method violates its general contract!

java.lang.IllegalArgumentException: Comparison method violates its general contract!
	at java.util.TimSort.mergeLo(TimSort.java:747)
	at java.util.TimSort.mergeAt(TimSort.java:483)
	at java.util.TimSort.mergeCollapse(TimSort.java:410)
	at java.util.TimSort.sort(TimSort.java:214)
	at java.util.TimSort.sort(TimSort.java:173)
	at java.util.Arrays.sort(Arrays.java:659)
	at java.util.Collections.sort(Collections.java:217)
	at org.codehaus.groovy.transform.trait.TraitComposer.applyTrait(TraitComposer.java:202)
	at org.codehaus.groovy.transform.trait.TraitComposer.doExtendTraits(TraitComposer.java:111)
	at org.codehaus.groovy.control.CompilationUnit$4.call(CompilationUnit.java:188)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1052)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:588)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:566)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:543)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:522)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:59)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:215)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:148)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:178)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:162)

1 error
{code}","Using 32-bit Oracle JDK 1.7.0_45, Groovy 2.4.3 with InvokeDynamic enabled (also reproducible using 2.3.6)",andy722,ivku,melix,renatoathaydes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"13/Apr/15 12:42;andy722;sample-7387.tgz;https://issues.apache.org/jira/secure/attachment/12724928/sample-7387.tgz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 19 12:15:25 UTC 2015,,,,,,,,,,"0|i2d6gf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Apr/15 12:42;andy722;Attached is a sample Intellij IDEA project reproducing the issue.;;;","13/Apr/15 15:02;andy722;A bit of info:

1. The trouble seems to be in the implementation of Comparator interface, see org.codehaus.groovy.transform.trait.TraitComposer#GETTER_FIRST_COMPARATOR.

2. There's a workaround: make JRE Collections API use the Merge sort algorithm by default by setting the following system property:

    -Djava.util.Arrays.useLegacyMergeSort=true
;;;","02/Sep/15 16:48;ivku;Could reproduce with goovy 2.4.4 on command line.

Workaround with -Djava.util.Arrays.useLegacyMergeSort=true seems not to work.

Don't think that is a minor issue. It seems that it is depends on an internal implementation detail of JDK whether or not traits are working - some kind of coincidence.;;;","02/Sep/15 17:25;melix;I am pretty sure the problem comes from those lines: https://github.com/apache/incubator-groovy/blob/master/src/main/org/codehaus/groovy/transform/trait/TraitComposer.java#L87-L92;;;","19/Oct/15 12:09;renatoathaydes;This problem is currently affecting my company. To make matters much worse, the error message does not inform us which trait/class fails to compile, so it's really difficult to diagnose. We're using Groovy 2.4.4.

Stack-trace:

```
[ERROR] General error during canonicalization: Comparison method violates its general contract!
[ERROR] 
[ERROR] java.lang.IllegalArgumentException: Comparison method violates its general contract!
[ERROR] at java.util.TimSort.mergeLo(TimSort.java:777)
[ERROR] at java.util.TimSort.mergeAt(TimSort.java:514)
[ERROR] at java.util.TimSort.mergeCollapse(TimSort.java:441)
[ERROR] at java.util.TimSort.sort(TimSort.java:245)
[ERROR] at java.util.Arrays.sort(Arrays.java:1512)
[ERROR] at java.util.ArrayList.sort(ArrayList.java:1454)
[ERROR] at java.util.Collections.sort(Collections.java:175)
[ERROR] at org.codehaus.groovy.transform.trait.TraitComposer.applyTrait(TraitComposer.java:205)
[ERROR] at org.codehaus.groovy.transform.trait.TraitComposer.doExtendTraits(TraitComposer.java:114)
[ERROR] at org.codehaus.groovy.control.CompilationUnit$4.call(CompilationUnit.java:191)
[ERROR] at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1055)
[ERROR] at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
[ERROR] at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
[ERROR] at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
[ERROR] at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:525)
[ERROR] at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:61)
[ERROR] at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:217)
[ERROR] at org.codehaus.groovy.ant.Groovyc.runCompiler(Groovyc.java:1165)
.......
``` 

Java version: 1.8.0_60, vendor: Oracle Corporation
Groovy 2.4.4 and 2.4.1 present the error.;;;","19/Oct/15 12:15;renatoathaydes;Sorry, wasn't aware Groovy 2.4.5 was released. After upgrading we got a nice error message showing the cause of the problem (final String declared in different traits imported by the same class).

Great work, Groovy team! Love Groovy!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Packed Maven pom.xml reference commons-cli instead of groovy-all,GROOVY-7386,12820379,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,lgoldstein,lgoldstein,12/Apr/15 09:06,21/Jul/15 10:30,14/Jul/23 06:01,02/May/15 00:45,,,,,,,,,,,,,,,,,,2.4.4,,,,,,,,0,,,,,,,The _groovy-all_ JAR (all 2.4.x for sure) does not contain a _pom.xml_ for the artifact - instead it contains the _pom.xml_ for _commons-cli_ (see attached screen capture). It should contain the POM for the artifact instead.,,blackdrag,lgoldstein,melix,pascalschumacher,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/Apr/15 09:06;lgoldstein;Capture.PNG;https://issues.apache.org/jira/secure/attachment/12724811/Capture.PNG",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 03 08:04:00 UTC 2015,,,,,,,,,,"0|i2d5jz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Apr/15 18:42;melix;Thanks. Actually it should not contain any pom.xml I think. The fact it contains the pom.xml of commons-cli is a side effect of jarjar'ing (repackaging). We don't use Maven to build Groovy, pom.xml shouldn't be needed at all.;;;","22/Apr/15 07:45;paulk;Yes, from memory there was some minor issue when I tried to get gradle to remove that directory. Possibly an error happened on the CI server or possibly it removed too much. I never had time to investigate further.;;;","30/Apr/15 10:07;blackdrag;so what to do? Won't fix?;;;","30/Apr/15 10:26;paulk;We should fix the gradle build to exclude the commons-cli files. Hopefully whatever the problem was last time won't reoccur.;;;","01/May/15 11:10;paulk;The last couple of snapshot releases no longer have the erroneous commons-cli info:

https://oss.jfrog.org/oss-snapshot-local/org/codehaus/groovy/groovy-all/2.5.0-SNAPSHOT/

I propose we resolve this issue and if anyone wants the informational pom.xml/pom.properties files we can create an enhancement request to put those files into the groovy artifacts. Whether to have that info is relevant to all produced artifacts not just the groovy-all artifact.

Any objections?;;;","01/May/15 13:11;pascalschumacher;I agree. Also I not see why anyone would want to have a pom included in a jar.;;;","02/May/15 00:45;paulk;Well, there are some reasons given in maven doco/forums: makes jars self-describing, potentially allows validation when jars are stored in repos, etc. but all optional things which I suspect aren't used much in practice. So, I'll resolve this one and if anyone needs the extra files they can open an enhancement request.;;;","03/May/15 04:27;lgoldstein;{quote}makes jars self-describing, potentially allows validation when jars are stored in repos, etc.{quote} - exactly. How else can one have a validation script that goes over the artifacts and makes sure they are of the correct version ? Certainly the name cannot be trusted... Also, how else can one run an automatic script that checks whether a newer version is available ?

{quote}optional things which I suspect aren't used much in practice.{quote} - may be, but doesn't the minority have any rights ...?

{quote}they can open an enhancement request{quote} - why is this an enhancement ? The de-facto standard of Maven built artifacts is to have these files and at the correct structure. Therefore an artifact that does not have them is a bug (IMO);;;","03/May/15 07:39;paulk;All Groovy users have rights! :-)

But we tend not to like having issues that span across multiple aspects. I felt that fixing the incorrectly copied meta info was highest priority, which is why I resolved and stated that a new issue could be created which I see that you have done.

I'd call it an enhancement request because the Groovy project has never offered the extra info in any previous releases (apart from the obviously accidentally copied version from a dependency). Thanks again for raising that issue.;;;","03/May/15 08:04;lgoldstein;{quote}All Groovy users have rights!{quote} - just wanted to make sure that even though this is admittedly not widespread, it is still out there and has useful applications.

{quote}I'd call it an enhancement request because...{quote} - I am fine with that - that's why I opened a separate improvement request (see GROOVY-7410);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Invalid Integer & Long literals compile when they shouldn't,GROOVY-7385,12820357,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,msgilligan,msgilligan,12/Apr/15 02:05,13/Jun/17 04:09,14/Jul/23 06:01,07/Aug/16 07:22,2.4.3,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,syntax,,,,0,,,,,,,"2147483648I should be an invalid Integer literal.
9223372036854775808L should be an invalid Long literal.

Both currently compile (and produce an unexpected value -- well, it would be the expected value in 2's complement math)

I created some unit tests to show the problem -- not sure if I put them in the right place, but they do fail as I expect them to.

The Github PR is here: 
https://github.com/groovy/groovy-core/pull/657

The build output is here:
http://ci.groovy-lang.org/viewLog.html?buildId=16410&buildTypeId=Groovy_Jdk7Build",Mac OS X,blackdrag,githubbot,jwagenleitner,msgilligan,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,https://github.com/groovy/groovy-core/pull/657,,,,,,,,,,,9223372036854775807,,,Sun Aug 07 07:22:14 UTC 2016,,,,,,,,,,"0|i2d5f3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Apr/15 02:07;msgilligan;p.s. In the Github PR, I referenced the Java Language Specification section that is being violated.
;;;","13/Apr/15 08:50;blackdrag;Won't fix, since Groovy is not Java and Groovy does this on purpose;;;","13/Apr/15 14:23;msgilligan;One of the major selling points of Groovy is that is Java-like (and almost a pure superset of Java) where possible. Why would Groovy do this on purpose?

It results in undesirable behavior like:
{noformat}
    assert 2147483648I == -2147483648I
{noformat}

being satisfied

and
{noformat}
    assert 9223372036854775808L == -9223372036854775808L
{noformat}
results in:
{noformat}
Caught: java.lang.NoSuchFieldError: $const$0
java.lang.NoSuchFieldError: $const$0
	at test.run(test.groovy:2)
{noformat}

which could be a different problem altogether, but seems related.
;;;","13/Apr/15 17:38;msgilligan;I didn't realize that I could re-open the issue, but I posted a comment 3 hours ago providing more information and asking for clarification.
;;;","22/Apr/15 09:10;blackdrag;ok, makes sense;;;","22/Apr/15 12:26;blackdrag;it looks like there is an overlap of this issue with GROOVY-5583. Simply checking if the given number fits in int or long is getting difficult if the number is not given as a base 10 literal. For example 0x8000_0000_0000_0000L is supposed to be a valid long, but it will be an overflow case. Same for 010_0000_0000_0000_0000_0000L, and 0b1000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000L;;;","22/Apr/15 23:30;msgilligan;I haven't looked at the source code for the parser, but it seems the values could be parsed into a {{BigInteger}} and then range checked for any explicit literal type. Similar logic should probably use for floating point: parse into {{BigDecimal}} then try to convert to {{Double}} or {{Float}} if explicit type is specified.

If a literal value with an explicit type won't fit in that type, it should be a compile time error.

Then there's also the above {{java.lang.NoSuchFieldError: $const$0}} error which only seems to happen for that exact value.

;;;","23/Apr/15 00:25;blackdrag;0x8000_0000_0000_0000L is legal in Java. But if I do a range check with the BigInteger based logic, then the resulting number is bigger than the long max value. 0x7FFF_FFFF_FFFF_FFFFL is the long max value and 0xFFFF_FFFF_FFFF_FFFFL is -1 and 0x8000_0000_0000_0000L is the smalles negative long value. So is a hex value >0x7FFF_FFFF_FFFF_FFFFL supposed to be legal? If yes, then it cannot be simply done using BigInteger. I currently have it, that only the base 10 version is checked.

As for floating point numbers... I think that can't be done. when it comes to float or double, then their range varies not only in the maximum numbers, but also in the precision. Something like 0.2 can already not be represented exactly by those types. ;;;","23/Apr/15 01:25;msgilligan;Good, point -- I read that in the Java Language Spec, but forgot about it in my last comment. What Java is doing makes sense -- when specifying numbers in hex, programmers are treating them as unsigned and would expect 0x8000_0000_0000_0000L to be negative. So yes, the checking needs to be different for Base 10 vs the other bases.

It looks like {{Numbers.java}} throws {{NumberFormatException}} when floating point literals are out of range. It would be friendly, I think, to not allow something like {{0.100000001f}} to compile (i.e. the user has explicitly specified precision greater than supported), but (my understanding of) [3.10.2. Floating-Point Literals|http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.2] says that this is allowed:

bq. A compile-time error does not occur if a non-zero floating-point literal has a small value that, on rounded conversion to its internal representation, becomes a non-zero denormalized number.

However a compile time error is required if a number rounds to zero:

bq. It is a compile-time error if a non-zero floating-point literal is too small, so that, on rounded conversion to its internal representation, it becomes a zero.

The nice thing about Groovy is that you can use {{BigDecimal}} literals just by removing the type suffix from the end. But it seems that anything with a type suffix that won't compile in Java should not compile in Groovy, as well.

;;;","23/Apr/15 01:33;msgilligan;I'm doing work with (digital) currency and am seeking to avoid any rounding or truncation, so am looking at everything with an eagle eye. Note that JSR-354 (Java Money) include a subclass of {{Number}} called [NumberValue|https://github.com/JavaMoney/jsr354-api/blob/master/src/main/java/javax/money/NumberValue.java] that adds methods named {{longValueExact()}}, {{doubleValueExact()}}, etc. that throw {{ArithmeticException}} if truncation would have occurred.;;;","26/Jul/16 08:14;githubbot;GitHub user msgilligan opened a pull request:

    https://github.com/apache/groovy/pull/373

    Add tests for valid and invalid integer literals (shouldCompile/shouldNotCompile)

    Add tests for integer literals that `shouldCompile` and `shouldNotCompile`.
    
    Some of these tests currently fail because of [GROOVY-7385](https://issues.apache.org/jira/browse/GROOVY-7385).
    
    I'm not sure what the right way is to submit failing tests, so please let me know if I should change things up. This PR was submitted earlier, but was lost when GROOVY-7385 was closed -- before it was reopened.
    


You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/msgilligan/groovy msgilligan-integer-literal-tests-take2

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/373.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #373
    
----

----
;;;","07/Aug/16 07:17;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/373
;;;","07/Aug/16 07:19;jwagenleitner;Merged PR with the tests. Thanks.

Looks like this was fixed by commit https://github.com/apache/groovy/commit/a258a3d026ebefc411797b2f69915fe1860262db.  Fix should be in 2.5 once released.;;;","07/Aug/16 07:22;jwagenleitner;I'm going to go ahead and mark as resolved for 2.5 since tests all pass on master.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Setters with non-void return type fail at runtime when statically compiled,GROOVY-7381,12818633,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,shils,shils,06/Apr/15 16:43,21/Jul/15 10:30,14/Jul/23 06:01,18/May/15 19:40,2.4.3,,,,,,,,,,,,,,,,,2.4.4,,,,Static compilation,,,,0,,,,,,,"Calling a statically compiled, non-void setter for a property will result in a NoSuchMethodError being thrown at runtime. There is no error if the setter corresponds to a field. 
Example:
{code}
import groovy.transform.CompileStatic

@CompileStatic
class A {
  int prop
  private int field

  A setProp(int prop) {
    this.prop = prop
    this
  }

  A setField(int field) {
    this.field = field
    this
  }

  static void main(String[] args) {
    A a = new A()
    a.setField(1) // ok
    a.setProp(1) //throws NoSuchMethodError at runtime
  }
}

A a = new A()
a.setField(1) //ok
a.setProp(1) //throws NoSuchMethodError
{code}

The problem appears to be in the `makeSetProperty` method of `StaticTypesBinaryExpressionMultiTypeDispatcher`, where only void setter methods of a ClassNode are looked up.

The most recent version of Groovy where this isn't an issue is 2.3.3.
","OSX Yosemite, JDK 1.8.0_25",githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon May 18 19:38:24 UTC 2015,,,,,,,,,,"0|i2cuxb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/May/15 15:20;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/17

    GROOVY-7381: Setters with non-void return type fail at runtime when s…

    …tatically compiled

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7381-non-void-setters-sc

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/17.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #17
    
----
commit e097135d690ad85546209557c67e2b2f687cfabb
Author: Shil S <shil.sinha@gmail.com>
Date:   2015-05-16T15:17:05Z

    GROOVY-7381: Setters with non-void return type fail at runtime when statically compiled

----
;;;","18/May/15 19:38;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/17
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Spaces in JAVA_OPTS env var  prevent launching of groovy,GROOVY-7378,12814578,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,jwadamson,jwadamson,03/Apr/15 10:11,22/Feb/16 20:48,14/Jul/23 06:01,16/Jan/16 12:33,2.4.3,,,,,,,,,,,,,,,,,2.4.6,,,,,,,,0,,,,,,,"Set environment variable JAVA_OPTS to have a system property including spaces/quotes/double-quotes.

$ export JAVA_OPTS=""-Dfoo='bar\"" baz\""'""
$ groovy -e 'println System.getProperty(""foo""); println args' 'arg space' ""space quote' "" ""\""""

Expected output would be:
'bar"" baz""'
[arg space, space quote' , ""]

Actual output is:
Error: Could not find or load main class baz""'


I can not comment on proper way to fix startGroovy.bat (assuming it suffers similarly), but included is diff that fixes startGroovy unix script to handle JAVA_OPTS such that quoted arguments are preserved as expected.

I modeled the attached change which seems to resolve the issue for *nix on the tomcat `catalina.sh run` script block. 

p.s. A concrete use case that bit me was trying to pass java.io.tmpdir to a groovy script to a path that included a space. There are outside reasons that modifying the script to read the desired value and set the system property is not a practical solution.",Linux,githubbot,jwadamson,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4910,,,,,,,,,,,,,"03/Apr/15 10:11;jwadamson;startGroovy.patch;https://issues.apache.org/jira/secure/attachment/12723159/startGroovy.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Sat Jan 16 12:33:33 UTC 2016,,,,,,,,,,"0|i2bom7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Apr/15 13:42;jwadamson;Related in that both concern JAVA_OPTS handling of whitespace;;;","09/Apr/15 13:43;jwadamson;The JAVA_OPTS handling of whitespace seemed to have been previously fixed for groovy.bat in GROOVY-4910;;;","22/Apr/15 12:56;githubbot;GitHub user jwadamson opened a pull request:

    https://github.com/apache/incubator-groovy/pull/5

    GROOVY-7378: Support JAVA_OPTS containing quoted arguments on *nix

    Apply the previously provided patch for GROOVY-7378.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwadamson/incubator-groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/5.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #5
    
----
commit b9c907a5a5b453eca6aeea1b73d3d950e20ad3e4
Author: Jeffrey Adamson <jwadamson@us.ibm.com>
Date:   2015-04-22T12:44:13Z

    GROOVY-7378: Support JAVA_OPTS containing quoted arguments on *nix

----
;;;","15/Jan/16 19:00;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/5#discussion_r49890958
  
    --- Diff: src/bin/startGroovy ---
    @@ -261,18 +261,18 @@ startGroovy ( ) {
         if $useprofiler ; then
             runProfiler
         else
    -        exec ""$JAVACMD"" $JAVA_OPTS \
    -            -classpath ""$STARTER_CLASSPATH"" \
    -            -Dscript.name=""$SCRIPT_PATH"" \
    -            -Dprogram.name=""$PROGNAME"" \
    -            -Dgroovy.starter.conf=""$GROOVY_CONF"" \
    -            -Dgroovy.home=""$GROOVY_HOME"" \
    -            -Dtools.jar=""$TOOLS_JAR"" \
    +        eval exec ""\""\$JAVACMD\"""" $JAVA_OPTS \
    +            -classpath ""\""\$STARTER_CLASSPATH\"""" \
    +            -Dscript.name=""\""\$SCRIPT_PATH\"""" \
    +            -Dprogram.name=""\""\$PROGNAME\"""" \
    +            -Dgroovy.starter.conf=""\""\$GROOVY_CONF\"""" \
    +            -Dgroovy.home=""\""\$GROOVY_HOME\"""" \
    +            -Dtools.jar=""\""\$TOOLS_JAR\"""" \
    --- End diff --
    
    Looks like there is an extra backslash before the environment variable that will cause it to not interpolate.  For example, think change should just be:
    
    `""\""$VAR\""""` (no slash before `$`)
    
    For reference I checked [Tomcat's catalina.sh] (https://github.com/apache/tomcat/blob/86b1281a190ec2f17fd1ac5ae3d3889166dcd360/bin/catalina.sh#L325-L339) to see how they handled it.
;;;","16/Jan/16 12:33;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Interpolated variable followed by asterisk in slashy-string causes compiler error,GROOVY-7377,12811571,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,nealm,nealm,02/Apr/15 18:00,21/Jul/15 10:30,14/Jul/23 06:01,25/Jun/15 11:28,2.4.3,,,,,,,,,,,,,,,,,2.4.4,,,,Compiler,,,,0,,,,,,,"{code}
@Test
void slashyStringWithInterpolatedVariableFollowedByAsterisk() {
        // currently throws org.codehaus.groovy.control.MultipleCompilationErrorsException
    assert Eval.me('''def foo='bar'; /$foo*baz/''') == 'bar*baz'
    assert Eval.me('''def foo='bar'; /${foo}*baz/''') == 'bar*baz'
    assert Eval.me('''def foo='bar'; /$foo\u002abaz/''') == 'bar*baz'
    assert Eval.me('''def foo='bar'; /${foo}\u002abaz/''') == 'bar*baz'
}
{code}","Windows 7 via gvm
Java 1.8_40",githubbot,nealm,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 25 10:55:12 UTC 2015,,,,,,,,,,"0|i2c16n:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"02/Apr/15 18:56;paulk;We'll have to double check the grammar. In the meantime, as a workaround, the non-slashy GString and the dollar slashy string both don't seem to have this problem.
{code}
assert Eval.me('''def foo='bar'; ""$foo*baz""''') == 'bar*baz'
assert Eval.me('''def foo='bar'; $/$foo*baz/$''') == 'bar*baz'
{code};;;","02/Apr/15 19:20;paulk;Looking at the grammar, it does look like a bug to me unless there is some history I am unaware of. There is a guard in the grammar ({{atValidDollarEscape}}) that looks like it steps over an optional '*' but then the rules which use this guard don't seem to know about this possibility. Perhaps, a long time ago, there was someone trying to support some kind of spread within a GString placeholder, e.g. {{$*someList}} but it was never finished or was removed but not fully.;;;","17/Apr/15 02:01;paulk;OK, found out what the '\*' handling was all about. If you have {{/\* some comment \*/}} or an empty comment {{/\*\*/}}, they will be treated as comments not GStrings. So in your case, the '\*' isn't part of a comment but is being matched by the rules sniffing for comments. We should no doubt tweak the grammar to handle that case correctly.;;;","18/May/15 10:50;paulk;Another interesting snippet from here:
http://marc.info/?l=groovy-scm&m=118311049022736

Relevant piece:
{noformat}
o Spread argument directly in GStrings removed
        def bar = [1,2,3]
        def g = ""foo$*bar""
{noformat}
So indeed, '$*' was supported pre June 2007;;;","11/Jun/15 10:27;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/40

    GROOVY-7377: Interpolated variable followed by asterisk in slashy-str…

    …ing causes compiler error

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7377

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/40.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #40
    
----
commit ff6917d65ec726119addca93ae8602e86039527f
Author: Paul King <paulk@asert.com.au>
Date:   2015-06-11T10:26:00Z

    GROOVY-7377: Interpolated variable followed by asterisk in slashy-string causes compiler error

----
;;;","25/Jun/15 10:55;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/40
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Interact Closures withing Groovy Trait methods are not recognized by the implementing class,GROOVY-7373,12817487,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,ldavis,ldavis,30/Mar/15 17:55,11/Nov/20 02:00,14/Jul/23 06:01,10/Aug/20 13:52,2.4.0,2.4.1,2.4.2,2.4.3,,,,,,,,,,,,,,3.0.6,4.0.0-alpha-1,,,groovy-runtime,,,,9,closure,geb,groovy,interact,spock,traits,"Since moving to grails 2.5.0 (groovy 2.4.x) our functional tests (geb/spock) are failing when we try to run interact closures inside of a trait.  I'm not entirely sure who owns this one as there are three or four players groovy, grails, geb/spock, but groovy seemed like the most logical culprit.

{code:Java|title=Example Usage}
trait DoStuff {
   def clickItemOnPage() {
      interact {
         moveToElement($('.myDiv'))
         click()
      }
   }
}
class MySpec extends GebReportingSpec  implements DoStuff {
   def clickItemOnPage2() {
      interact {
         moveToElement($('.myDiv'))
         click()
      }
   }
   def 'Test some stuff' { 
      clickItemOnPage2() //Passes
      clickItemOnPage() //Fails
   }
}
{code}
Error: groovy.lang.MissingMethodException: No signature of method: geb.navigator.NonEmptyNavigator.moveToElement()
It really doesn't matter what you have in the interact closure anything fails...","Win 7x64
Ubuntu 14.04 (Gnome)
Ubuntu 12.04

Java: 1.8.0_40-b26",emilles,ldavis,longwa_uk,MayGo,melix,nlancaster,paulk,tchamberlain,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 08 19:21:01 UTC 2020,,,,,,,,,,"0|i2ce2f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Apr/15 19:14;nlancaster;I ran into the same issue when upgrading to Grails 2.5.0. After some testing in the Groovy Console I'm pretty sure it's a Groovy issue.  It seems there is no delegate variable present for closures that originate in traits.  The following example should fail on the println:

{code}
trait Traitable {
  Closure getClosure() {
    { it ->
      println delegate
    }
  }
}

class TestClass implements Traitable {
 
  void runClosure() {
    getClosure().call()
  }
}

new TestClass().runClosure()
{code}

I ran this script in the console in several groovy versions and it looks like the problem originated in 2.4.2.;;;","02/Jul/15 06:41;MayGo;Have same problem when upgrading to grails 2.5.0;;;","02/Jul/15 06:51;melix;In the example from the comment, {{delegate}} will fail, but {{getDelegate}} works. Would you mind testing the original example with a snapshot of 2.4.4?

Thanks!;;;","29/Oct/15 19:43;longwa_uk;delegate still fails in 2.4.5, getDelegate() works but it still seems like something that should work either way.;;;","06/Aug/18 09:55;paulk;The example below works, so it isn't necessarily just Groovy here - we'd need to look at all the layers:
{code}
class MySpec extends GebLike implements DoStuff {
   def clickItemOnPage2() {
      interact {
         moveToElement('.myDiv')
         click()
      }
   }
   void testSomeStuff() {
      clickItemOnPage2()
      clickItemOnPage()
   }
}
class GebLike extends GroovyTestCase {
  def interact(Closure c) {
    c.delegate = this
    c.call()
  }
  def moveToElement(s) { println s }
  def click() { println 'clicking' }
}
trait DoStuff {
   def clickItemOnPage() {
      interact {
         moveToElement('.myDiv')
         click()
      }
   }
}
{code};;;","08/Aug/20 19:21;emilles;Probably resolved by GROOVY-9386;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Varargs in constructor are not treated correctly when creating instances of anonymous class,GROOVY-7370,12811588,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,artyushov,artyushov,27/Mar/15 05:13,10/Feb/23 21:40,14/Jul/23 06:01,10/Aug/22 23:06,,,,,,,,,,,,,,,,,,4.0.5,,,,,,,,0,varargs,,,,,,"Code snippet to reproduce the bug:

{code}
class Test {

    public Test(String... args) {
        println args
    }

    public static void main(String[] args) {
        new Test('oneWord')
        new Test('manyLetters') {
            @Override
            int hashCode() {
                return 1;
            }
        }
    }
}
{code}

expected output:
{code}
[oneWord]
[manyLetters]
{code}

actual:
{code}
[oneWord]
[m, a, n, y, L, e, t, t, e, r, s]
{code}",,artyushov,emilles,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6618,,,,GROOVY-10722,GROOVY-10840,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 10 23:06:38 UTC 2022,,,,,,,,,,"0|i2ch7j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Oct/15 15:23;shils;This appears to happen because the parameters of synthetic constructors of anonymous classes which correspond to super parameters (i.e. not the super class or local variable references) have their types set as Object. When calling the super constructor, arguments are cast to the appropriate type; in this case 'manyLetters' is cast to String[] via ScriptBytecodeAdapter.castToType.;;;","10/Aug/22 23:06;emilles;https://github.com/apache/groovy/commit/aa5722424db835b07a02b291bf9d887215211e96;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static imports are missing in generated stubs,GROOVY-7366,12811554,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,gromopetr,gromopetr,25/Mar/15 08:48,15/Oct/15 18:21,14/Jul/23 06:01,25/Mar/15 09:37,2.4.0,,,,,,,,,,,,,,,,,2.4.4,,,,Stub generator / Joint compiler,,,,0,,,,,,,"The title says it all. For the code to reproduce, please refer to https://youtrack.jetbrains.com/issue/IDEA-138174",,gromopetr,keegan,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7531,GROOVY-7509,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 03 12:57:01 UTC 2015,,,,,,,,,,"0|i2carj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Mar/15 09:43;gromopetr;That was fast! Thanks!;;;","25/Mar/15 09:45;melix;Hehe, but having a new release is going to take time now that we're in the Apache Incubator!;;;","02/Aug/15 22:50;paulk;Sorry for the late reply. Yes, the original design explicitly tried not to include the static imports on the basis that everything could be fully qualified by that time - obviously we hadn't fully qualified annotation constants. And I think attempting to do more qualification would be the preferred solution if possible since then alias imports wouldn't be a problem.;;;","03/Aug/15 12:57;keegan;I'm not sure if that'd be tricky, but I like the idea.  Is there a Jira for fully qualified names?  GROOVY-4374?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler crash in the static type checker,GROOVY-7365,12811526,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,fpavageau,fpavageau,23/Mar/15 17:31,21/Jul/15 10:30,14/Jul/23 06:01,25/Mar/15 07:55,2.4.2,2.4.3,,,,,,,,,,,,,,,,2.4.4,,,,Static Type Checker,,,,0,,,,,,,"My project doesn't build when upgrading from 2.4.1 to 2.4.2 or 2.4.3, crashing in the static type checker with:
{noformat}
java.lang.ArrayIndexOutOfBoundsException: 1
at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:164)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnTypeGenerics(StaticTypeCheckingVisitor.java:4152)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.existsProperty(StaticTypeCheckingVisitor.java:1238)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.existsProperty(StaticCompilationVisitor.java:419)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.existsProperty(StaticTypeCheckingVisitor.java:1132)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitPropertyExpressionSilent(StaticTypeCheckingVisitor.java:494)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitPropertyExpression(StaticTypeCheckingVisitor.java:499)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitPropertyExpression(StaticCompilationVisitor.java:433)
at org.codehaus.groovy.ast.expr.PropertyExpression.visit(PropertyExpression.java:55)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:545)
at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1756)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2089)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2048)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:160)
at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1083)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:244)
at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:119)
at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:60)
at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1052)
at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:588)
at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:566)
at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:543)
at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:522)
...
{noformat}

I'll try to run the compiler in the debugger to find the class triggering the error, so I can extract a proper test case.",,fpavageau,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 24 18:02:23 UTC 2015,,,,,,,,,,"0|i2cndr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Mar/15 07:15;melix;Thanks, indeed a test file would help. Also please make sure you paste a trace with Groovy 2.4.3 so that line numbers match. Thanks a lot!;;;","24/Mar/15 08:22;fpavageau;I've already identified the method triggering the crash by running the compiler with the debugger, I'll isolate a test case later (today, hopefully) by removing all the non essential code.

It's got something to do with a method declared like
{code}protected <T extends U> T m(T value){code}
with U being itself a parameterized class
{code}class U<S, E>{code}
It seems to be iterating for the numbers of generic parameters of the class (2) on the generic parameters of the method (1), hence the {{ArrayIndexOutOfBoundsException}}.

But it'll be easier with the test case anyway.;;;","24/Mar/15 17:20;fpavageau;I've put the isolated test case on [Github|https://github.com/fpavageau/generic-generic-type]. The stack trace with 2.4.3 is:
{noformat}
java.lang.ArrayIndexOutOfBoundsException: 1
at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:164)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnTypeGenerics(StaticTypeCheckingVisitor.java:4190)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnTypeGenerics(StaticTypeCheckingVisitor.java:4147)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.existsProperty(StaticTypeCheckingVisitor.java:1241)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.existsProperty(StaticTypeCheckingVisitor.java:1135)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitPropertyExpressionSilent(StaticTypeCheckingVisitor.java:497)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitPropertyExpression(StaticTypeCheckingVisitor.java:502)
at org.codehaus.groovy.ast.expr.PropertyExpression.visit(PropertyExpression.java:55)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:548)
at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1770)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2103)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2062)
at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1083)
at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:247)
at org.codehaus.groovy.transform.StaticTypesTransformation.visit(StaticTypesTransformation.java:63)
at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1052)
at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:588)
at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:566)
at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:543)
at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:522)
{noformat};;;","24/Mar/15 18:02;fpavageau;I've also created a [PR|https://github.com/groovy/groovy-core/pull/649] to add a failing test.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Invalid type inference with a generic method / return type and optional parameter,GROOVY-7364,12811567,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,fpavageau,fpavageau,23/Mar/15 06:07,31/Mar/15 06:08,14/Jul/23 06:01,23/Mar/15 06:44,2.4.2,,,,,,,,,,,,,,,,,2.4.3,,,,Static Type Checker,,,,0,,,,,,,"The following class fails to compile:
{code}
@TypeChecked
class A {
    public <T> T f(T value, int param = 0) {
        value
    }

    void run() {
        def s = f('42')
        s.length()
    }
}
{code}

The compilation error is:
{noformat}
[ERROR] /Users/fpavageau/devs/bugs/generic-method-optional-param/src/main/groovy/A.groovy: 26: [Static type checking] - Cannot find matching method java.lang.Object#length(). Please check if the declared type is right and if the method exists.
[ERROR] @ line 26, column 9.
[ERROR] s.length()
[ERROR] ^
[ERROR] 
[ERROR] 1 error
{noformat}

The same code will compile if the optional parameter is removed from {{f}}, or if {{s}} is explicitely declared as a {{String}} instead of using {{def}}.

It seems to be related to GROOVY-7211, but this bug is definitely not fixed in 2.4.2.

I'm attaching a test case, which is also available on [Github|https://github.com/fpavageau/generic-method-default-param].","MacOS X
Oracle JDK 1.7u75 / 18u40
Maven 3.0.5",fpavageau,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/Mar/15 06:09;fpavageau;generic-method-optional-param.tar.gz;https://issues.apache.org/jira/secure/attachment/12723248/generic-method-optional-param.tar.gz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-03-23 06:07:37.0,,,,,,,,,,"0|i2bsjj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Frequent compilation error on cascading generic types,GROOVY-7363,12811568,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,fpavageau,fpavageau,23/Mar/15 05:35,22/Feb/16 20:48,14/Jul/23 06:01,03/Nov/15 18:07,2.4.2,,,,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,test,,,,,,"Most of the time, I get the following compilation error:
{noformat}
[ERROR] /Users/fpavageau/devs/bugs/lost-cascading-types/src/main/groovy/BadType.groovy: 22: [Static type checking] - No such property: start for class: T
[ERROR] @ line 22, column 22.
[ERROR] println("""" + rel.currentState.state.start)
[ERROR] ^
[ERROR] 
[ERROR] 1 error
{noformat}
where {{rel}} is an instance of a non-parameterized (Java) class implementing a generic interface with the {{currentState}} generic property. So the type of the property should actually be known, but it's lost and I get a compilation error because the {{start}} property is not part of the lower-bound type of {{currentState}}.

When I say ""most of the time"", it's because the compilation error is not always triggered (so lots of debugging fun!). I've tried with Oracle JDK 1.7u75 and 1.8u40, and I get around 87% of failures:
{code:title=JDK 1.7}
$ failures=0; for i in {1..100}; do mvn clean package > /dev/null 2>&1 || ((failures++)); done; echo $failures
87
{code}
{code:title=JDK 1.8}
$ failures=0; for i in {1..100}; do mvn clean package > /dev/null 2>&1 || ((failures++)); done; echo $failures
88
{code}

I'm attaching a test case, which is also available on [Github|https://github.com/fpavageau/lost-cascading-types].","MacOS X
Oracle JDK 1.7u75 / 1.8u40
Maven 3.0.5",fpavageau,githubbot,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/Mar/15 05:38;fpavageau;lost-cascading-types.tar.gz;https://issues.apache.org/jira/secure/attachment/12723266/lost-cascading-types.tar.gz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 03 18:07:35 UTC 2015,,,,,,,,,,"0|i2c1h3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"03/Aug/15 15:45;fpavageau;I've been trying to create a test case for this bug, but it has proven difficult due to the fact that it's not 100% reproducible. I've tried running the body of the test in a loop (using {{100.times}} for example) but it either fails immediately or never, so it's probably related to an initialization. With the minimal test case I eventually created, the static type check fails 46% of the time.

However, while building this minimal test case and removing as much stuff as I could, I noticed that some modifications removed the bug, and it led me to an interesting discovery. The test case runs the following script:
{code}
assertScript """"""import org.codehaus.groovy.classgen.asm.sc.bugs.support.Groovy7363Support
    Groovy7363Support.ABC a = new Groovy7363Support.ABC()
    println('' + a.b.object.value)
""""""
{code}
which fails, as in my original report, with:
{noformat}
TestScripttestCascadingGenericTypes0.groovy: 3: [Static type checking] - No such property: value for class: T
@ line 3, column 26.
               println('' + a.b.object.value)
                            ^
{noformat}
The support Java code started with:
{code}
public class Groovy7363Support {
    public interface A<T, U extends B<T>> {
        U getB();

        void setB(U b);
    }

    public static class ABC implements A<C, BC> {
        @Override
        public BC getB() {
            return new BC();
        }

        @Override
        public void setB(BC b) {}
    }

    // ...
}
{code}


The setter did not seem necessary in the interface so I removed it, along with its implementation, and then the check passed. I then added the setter back, but only in the implementation, and the check failed again (46% of the time):
{code}
public class Groovy7363Support {
    public interface A<T, U extends B<T>> {
        U getB();
    }

    public static class ABC implements A<C, BC> {
        @Override
        public BC getB() {
            return new BC();
        }

        public void setB(BC b) {}
    }

    // ...
}
{code}


And then I remembered that classes implementing generics have synthetic bridge methods generated by the compilation, so I wondered if changing the order of the methods might influence the output. And indeed, moving the setter first in front of the getter makes the check fail reliably _on my machine_ (MacOS X 10.10.4, 64-bit Oracle JDK 1.7.0u75):
{code}
public class Groovy7363Support {
    public interface A<T, U extends B<T>> {
        U getB();
    }

    public static class ABC implements A<C, BC> {
        public void setB(BC b) {}

        @Override
        public BC getB() {
            return new BC();
        }
    }

    // ...
}
{code}


Still, I'm reluctant to actually create a pull request from [my branch|https://github.com/apache/incubator-groovy/compare/GROOVY_2_4_X...fpavageau:GROOVY-7363?expand=1] because the test could actually be flaky in other environments. But [the code is there|https://github.com/fpavageau/incubator-groovy/tree/GROOVY-7363], and I might try and debug it myself, to find where the analysis of the {{ABC}} class takes place and incorrectly initializes the context.;;;","22/Oct/15 21:42;fpavageau;I've been running the {{StaticTypeCheckingVisitor}} on my test under the debugger, to understand how it works and where the problem might come from, and I think I've pinpointed the origin.

The reflection finds 2 methods {{getB()}} in {{ABC}}:
- the implemented method {{BC getB()}}
- a bridge method {{B getB()}}, with the original return type as declared in the {{A}} interface

As always with reflection, the order of the methods returned by {{Class.getDeclaredMethods()}} is undefined, which is why the failure can be flaky, even if my test reproduces it reliably on my machine. When the {{ClassNode}} for {{ABC}} is initialized (in {{lazyClassInit()}}), the bridge method is returned first, the implemented method second, and both are registered in {{ClassNode.methodsList}} and {{ClassNode.methods}}.

Then, when resolving the type of the {{a.b}} expression in {{StaticTypeCheckingVisitor.existsProperty()}}, the {{ClassNode}} returns the first getter matching the name and parameters of {{getB()}} ({{MethodNode getter = current.getGetterMethod(""get"" + capName)}}): the bridge method with a broader return type ({{B}}) than the actual, implemented method ({{BC}}).

So the question is: is there a point in keeping the bridge methods in the {{ClassNode}}? Are they ever needed? And even if they are, shouldn't the implemented methods have precedence in {{ClassNode.methods}} by being sorted first, so the exact types are always used? Because {{Class.getDeclaredMethods()}} returns an array with an undefined order, I think it's a bad idea to simply store them in the same order.

I'll try both scenarios and see if any existing test breaks (and if it fixes mine), but it's probably better if someone has a opinion on the best route.;;;","23/Oct/15 13:58;githubbot;GitHub user fpavageau opened a pull request:

    https://github.com/apache/incubator-groovy/pull/158

    GROOVY-7363 Reliable type resolution in the static type checker with covariant getters

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fpavageau/incubator-groovy GROOVY-7363

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/158.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #158
    
----
commit ff027adbd073b9d65971bf01252611cc2b9fb245
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-08-03T13:04:37Z

    GROOVY-7363 Add a failing test

commit c5326d43ea155816d336f5d51d93f27980122926
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-08-03T15:12:00Z

    GROOVY-7363 Change the order of methods so the check fails reliably
    
    It probably depends on the environment (MacOS X 10.10.4, Oracle JDK
    1.7.0u75 here), but at least here the static type checking always fails.
    
    So, moving the setter first creates a reliable failure, and removing it
    makes the check always pass! It makes me think the problem is related to the
    synthetic bridge method generated for ABC.getB() and the order in which the
    methods are returned by the reflection API.

commit a20410f4e0b7d4d482ef87feabecb9f6e83d57ee
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-10-23T12:31:28Z

    GROOVY-7363 Configure the ClassNode with sorted methods
    
    Because reflection on methods doesn't return them sorted or in any
    particular order, sorting is necessary to get a stable ClassNode definition.
    
    In particular, sorting bridge methods last ensures that the type resolution
    of expressions in the static type checker always uses the covariant return
    type of getters (due to generics, for example) and doesn't lose accuracy,
    resulting in spurious type checking errors.

----
;;;","23/Oct/15 14:06;fpavageau;As commented by the GitHub Bot, I've created a pull request with a simple fix.

The only viable solution was to sort methods, as ignoring bridge methods triggered other failures in the build. It's also easier and less intrusive to sort during the {{ClassNode}} configuration than inside {{ClassNode.MapOfLists.put()}}, as that's called by {{ClassNode.addMethod()}} which is itself called in a lot more places than just the configuration.;;;","03/Nov/15 18:06;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/158
;;;","03/Nov/15 18:07;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Can't compile Java class extending Groovy abstract class with explicit GroovyObject interface,GROOVY-7362,12811558,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,gromopetr,gromopetr,23/Mar/15 03:12,16/Jan/19 12:08,14/Jul/23 06:01,15/Sep/18 03:07,2.4.0,,,,,,,,,,,,,,,,,3.0.0-alpha-4,,,,Compiler,,,,2,,,,,,,"That's a more advanced version of GROOVY-3877

Compile classes.groovy:
{code}
abstract class AbstractClass extends ConcreteClass implements GroovyObject {}

class ConcreteClass {}
{code}

Then compile JavaClass.java:
{code}
public class JavaClass extends AbstractClass {}
{code}

You get:
{quote}
JavaClass.java:1: error: JavaClass is not abstract and does not override abstract method setMetaClass(MetaClass) in GroovyObject
public class JavaClass extends AbstractClass {
       ^
1 error
{quote}

That's likely because setMetaClass is added as a synthetic method in ConcreteClass and not overridden in AbstractClass.

This also happens without explicit GroovyObject interface when using joint compilation (https://youtrack.jetbrains.com/issue/IDEA-137722#comment=27-952814). Before generating stubs, ""implements GroovyObject"" is added to Groovy classes, and if it so happens that AbstractClass is visited before ConcreteClass, then ""implements GroovyObject"" will be added to both Groovy classes, but the (synthetic) implementations somehow end up being only in ConcreteClass.",,daniilo,gillius,gillius2,gromopetr,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8495,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 11 04:01:54 UTC 2018,,,,,,,,,,"0|i2csfz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Mar/15 10:05;gillius;I can confirm that if in the abstract class I override every method of GroovyObject (in my case I just called super in each), the compiler errors from javac go away.;;;","23/Apr/15 13:12;gillius;I thought this worked for me before, but now I just tried to put it into actual use, and while it compiled I got a stack overflow when running getMetaClass. In dynamic mode, the call is delgated to ScriptBytecodeAdapter to call invokeMethodOnSuperN, but the first thing this does is call getMetaClass so it can call invokeMethod with isCallToSuper true. This actually sort of makes sense, since every function call in Groovy goes through the Metaclass.

I annotated all of the GroovyObject override methods with @CompileStatic and it worked, since it generates in bytecode a call directly to parent class.;;;","23/Apr/15 14:33;gillius;I have to report that the override method and @CompileStatic doesn't work consistently. Depending on how the project is built (whether clean build or not) and what system you are on, I get different results. Any of the following might happen:

# It works
# Class fails to load because a bytecode verifier error about an illegal invokeVirtual call in one of the overridden methods
# Class compiles and loads, but compiler generated call to GroovyDefaultMethods.getMetaClass instead of the super's method, which causes a stack overflow

In my case I had an abstract class extending a concrete one, and since the concrete base class was never instantiated, I could make it abstract. Making both the classes abstract so far has been working for me and is less intrusive than overriding all GroovyObject methods.;;;","15/Sep/18 03:07;paulk;The given example seems to have been fixed by other issues - I imagine related issues as per comments are covered by GROOVY-8495.;;;","11/Oct/18 04:01;paulk;Removing 2_5_X fix version for now since GROOVY-8495 was removed for now from 2_5_X. We can add a 2.5.x fix version if/when we backport GROOVY-8495 to 2_5_X.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError when private variable is used in synchronized block,GROOVY-7361,12817561,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,20/Mar/15 10:22,31/Mar/15 06:08,14/Jul/23 06:01,20/Mar/15 16:39,2.4.2,,,,,,,,,,,,,,,,,2.4.3,,,,Static compilation,,,,0,,,,,,,"In the following code, synchronizing on the *private* final field map inside a closure causes a {{VerifyError}}. Synchronizing on a protected or public field fixes the problem.

{code}
class TaskManager {
    private final Map<Long, String> map = [1L:'a',2L:'b']
    void doh() {
        def list = [1L]
        list.each {
            synchronized (map) {
                map.remove(it)
            }
        }
    }
}
new TaskManager().doh()
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-03-20 10:22:39.0,,,,,,,,,,"0|i2bplj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Optimized foreach loops should handle ""continue"" properly",GROOVY-7358,12811525,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lhotari,lhotari,19/Mar/15 13:15,31/Mar/15 06:08,14/Jul/23 06:01,19/Mar/15 14:59,2.4.2,,,,,,,,,,,,,,,,,2.4.3,,,,Static compilation,,,,0,,,,,,,"This code shows a regression in the foreach loop optimization (GROOVY-7349) introduced in 2.4.2 
{code}
@groovy.transform.CompileStatic
private int foo(String[] arr) {
   int counter=0
   for (String s in arr) {
      if(counter++ > 100) break
      println(s)
      if(s == 'b') continue
   }
   counter
}

assert foo(['a','b','c'] as String[])==3
{code}",,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-03-19 13:15:59.0,,,,,,,,,,"0|i2clvb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Optimized foreach loops should perform a null check,GROOVY-7357,12817559,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,19/Mar/15 11:02,31/Mar/15 06:08,14/Jul/23 06:01,19/Mar/15 11:12,2.4.2,,,,,,,,,,,,,,,,,2.4.3,,,,Static compilation,,,,0,,,,,,,"The following code is a regression, because previously the code used an iterator, which in case of {{null}} returned an empty iterator. With the optimized path, the loop will fail.

{code}
@CompileStatic
private void foo(String[] arr) {
   for (String s in arr) {
      println(s)
   }
}

foo(null)
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-03-19 11:02:58.0,,,,,,,,,,"0|i2cr7b:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler internal error if inside an optimized foreach loop and the body contains a try/catch block,GROOVY-7356,12811556,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,19/Mar/15 08:30,31/Mar/15 06:08,14/Jul/23 06:01,19/Mar/15 08:44,2.4.2,,,,,,,,,,,,,,,,,2.4.3,,,,Static compilation,,,,0,,,,,,,"The following code will trigger a compiler error, because of the try{} block used inside a statically compiled, optimized foreach loop:

{code}
@CompileStatc
private void foo(String[] arr) {
   for (String s in arr) {
      try {
         println(s)
      } catch (e) {}
   }
}

{code}",,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-03-19 08:30:24.0,,,,,,,,,,"0|i2cpb3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError if a closure shared variable of a foreach style loop is used with @CompileStatic,GROOVY-7355,12818005,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,19/Mar/15 08:01,31/Mar/15 06:08,14/Jul/23 06:01,19/Mar/15 08:44,2.4.2,,,,,,,,,,,,,,,,,2.4.3,,,,Static compilation,,,,0,,,,,,,"There is a regression due to GROOVY-7349. The following code will fail with a VerifyError:

{code}
@CompileStatic
private void foo(String[] arr) {
    for (String s in arr) {
        { -> println(s)}.call() // make s closure shared
    }
}
{code}

A workaround is to use an intermediate variable:

{code}
@CompileStatic
private void foo(String[] arr) {
    for (String s in arr) {
        def v = s;
        { -> println(v)}.call()
    }
}
{code}
",,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-03-19 08:01:51.0,,,,,,,,,,"0|i2bss7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MissingMethodException: No signature of method: com.sun.org.apache.xerces.internal.dom.DeferredElementNSImpl.xpath() is applicable,GROOVY-7346,12811560,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,pschumacher,pschumacher,15/Mar/15 14:25,24/Mar/15 13:24,14/Jul/23 06:01,24/Mar/15 13:24,,,,,,,,,,,,,,,,,,,,,,XML Processing,,,,0,,,,,,,"When running the test of the groovy-xml subproject, I get this failure on master:

{quote}groovy.xml.dom.DOMCategoryTest > testXPathWithDomCategory FAILED
    groovy.lang.MissingMethodException: No signature of method: com.sun.org.apache.xerces.internal.dom.DeferredElementNSImpl.xpath() is applicable for
 argument types: (java.lang.String, java.lang.Class) values: [c, class groovy.util.Node]
    Possible solutions: wait(), any(), getAt(java.lang.String), each(groovy.lang.Closure), with(groovy.lang.Closure), putAt(java.lang.String, java.lang.Object)
        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:56)
        at org.codehaus.groovy.runtime.callsite.PojoMetaClassSite.call(PojoMetaClassSite.java:46)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:110)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:130)
        at groovy.xml.dom.DOMCategoryTest$_testXPathWithDomCategory_closure11.doCall(DOMCategoryTest.groovy:158)
        at groovy.xml.dom.DOMCategoryTest$_testXPathWithDomCategory_closure11.doCall(DOMCategoryTest.groovy)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
        at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1013)
        at groovy.lang.Closure.call(Closure.java:423)
        at groovy.lang.Closure.call(Closure.java:417)
        at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.use(GroovyCategorySupport.java:109)
        at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.access$400(GroovyCategorySupport.java:65)
        at org.codehaus.groovy.runtime.GroovyCategorySupport.use(GroovyCategorySupport.java:249)
        at org.codehaus.groovy.runtime.DefaultGroovyMethods.use(DefaultGroovyMethods.java:403)
        at org.codehaus.groovy.runtime.dgm$755.invoke(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoMetaMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:248)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:56)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:151)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:171)
        at groovy.xml.dom.DOMCategoryTest.testXPathWithDomCategory(DOMCategoryTest.groovy:155){quote}

Seems to be caused by recent changes, on the GROOVY_2_4_X branch the test still works.","Windows 7, 64-Bit JDK 1.7.0_72",melix,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 24 13:24:03 UTC 2015,,,,,,,,,,"0|i2cj53:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Mar/15 21:11;paulk;I tried doing git bisect and it seemed to point me to the commits related to PR#552 but it wasn't definitive since some of those commits broke the build and were fixed by later commits and I haven't had time to rectify the build issues manually yet.;;;","18/Mar/15 02:34;melix;I pushed a workaround, see my comment on https://github.com/groovy/groovy-core/pull/552;;;","24/Mar/15 13:24;pschumacher;Workaround works fine. Closed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper parses badly formatted numbers.,GROOVY-7344,12811547,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,calmbandicoot,calmbandicoot,13/Mar/15 10:49,21/Mar/15 07:11,14/Jul/23 06:01,13/Mar/15 17:08,,,,,,,,,,,,,,,,,,2.4.2,,,,,,,,0,,,,,,,"JsonSlurper parses badly formatted numbers : e.g. 0.42.41

def s = new JsonSlurper()
s.parseText('{""badNumber"": 0.42.41}')

Does not throw an exception.",,calmbandicoot,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 13 17:08:11 UTC 2015,,,,,,,,,,"0|i2coxr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Mar/15 17:08;melix;Merged https://github.com/groovy/groovy-core/pull/638;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Access to java.lang.Object is forbidden,GROOVY-7343,12817548,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,haimat,haimat,13/Mar/15 05:36,21/Mar/15 07:11,14/Jul/23 06:01,13/Mar/15 10:34,2.4.1,,,,,,,,,,,,,,,,,2.3.11,2.4.2,,,,,,,0,,,,,,,"I have the following code:

{code}
import groovy.transform.CompileStatic

@CompileStatic
class Test {
    static private String str = ""My String""

    static void test() {
        println myStr
    }
   
    static String getMyStr() {
        return ""${str.replace("" "", """")}""
    }
}

Test.test()
{code}

However, running this code via Groovy 2.4.1 throws the following error:

{{Access to java.lang.Object#myStr is forbidden at line: -1, column: -1}}",,haimat,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 13 10:34:20 UTC 2015,,,,,,,,,,"0|i2cb73:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Mar/15 10:34;melix;Thanks for reporting this!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
last enum value is hidden if annotated,GROOVY-7342,12817451,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,shils,marshals,marshals,13/Mar/15 05:32,22/Feb/16 20:48,14/Jul/23 06:01,25/Nov/15 05:56,2.3.10,2.4.1,,,,,,,,,,,,,,,,2.4.6,,,,,,,,0,,,,,,,"When I annotate the final enum value in an enum, the enum value is no longer part of the enum, eg, running this via GroovyShell throws MissingPropertyException on the last line:

{code}
@Target([ElementType.FIELD])
@interface Fooann {
}

enum Foonum {
    @Fooann
    X,
    @Fooann // all is well if either (a) this annotation is removed,
    Y       // or (b) this value has a trailing comma
}

class Bar {
    Foonum foonum
}

println Foonum.X
println Foonum.Y
{code}","Windows 7 
First seen in Eclipse Luna (which also doesn't syntax highlight it well)",githubbot,marshals,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6634,,,,,,,,,,,,,"13/Mar/15 05:32;marshals;bug1.groovy;https://issues.apache.org/jira/secure/attachment/12723245/bug1.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 25 05:55:33 UTC 2015,,,,,,,,,,"0|i2btwv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"24/Nov/15 17:08;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/194

    GROOVY-7342 Last enum value is hidden if annotated

    * Try syntactic predicate for enum constant before predicate for end of enum constants

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7342

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/194.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #194
    
----
commit eae120621bb1769ad315faf89d6bde8fec94d2bf
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2015-11-24T17:00:39Z

    GROOVY-7342 Last enum value is hidden if annotated
    * Try syntactic predicate for enum constant before predicate for end of enum constants

----
;;;","24/Nov/15 17:14;shils;The annotation causes Y to be parsed as a classField rather than as an enumConstant. Another temporary work around is to include {{@Fooann Y}} on the same line as X e.g.

{code}
@Fooann
X, @Fooann Y
{code}
;;;","25/Nov/15 05:42;paulk;PR looks good to me;;;","25/Nov/15 05:53;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/194
;;;","25/Nov/15 05:55;shils;Merged, thanks for reviewing.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyDoc doesn't understand method type parameters,GROOVY-7340,12811996,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,12/Mar/15 02:31,01/Feb/17 23:19,14/Jul/23 06:01,01/Sep/16 06:06,2.4.2,,,,,,,,,,,,,,,,,2.4.8,,,,GroovyDoc,,,,0,,,,,,,"GroovyDoc doesn't understand generics placeholders, e.g.: as part of GROOVY-7281, the type signature of a DGM withStream method changed  from:
{code}
public static <T> T withStream(InputStream stream, @ClosureParams(value=SimpleType.class, options=""java.io.InputStream"") Closure<T> closure) throws IOException {
{code}
to:
{code}
public static <T, U extends InputStream> T withStream(U stream, @ClosureParams(value=FirstParam.class) Closure<T> closure) throws IOException {
{code}
As a  result, the gapi documentation shown for the method summary changed from this:
{code}
static T withStream(InputStream stream, Closure<T> closure)
{code}
to this:
{code}
static T withStream(U stream, Closure<T> closure)
{code}
Similarly, the method detail has the same error.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 01 06:06:35 UTC 2016,,,,,,,,,,"0|i2bvb3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Sep/16 06:06;paulk;MethodDoc now stores type parameters;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DocGenerator doesn't understand generics placeholders,GROOVY-7339,12811540,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,12/Mar/15 02:27,07/Apr/15 19:06,14/Jul/23 06:01,12/Mar/15 20:08,2.4.2,,,,,,,,,,,,,,,,,2.4.2,,,,,,,,0,,,,,,,"DocGenerator doesn't understand generics placeholders, e.g.: as part of GROOVY-7281, the type signature of a DGM withStream method changed  from:
{code}
public static <T> T withStream(InputStream stream, @ClosureParams(value=SimpleType.class, options=""java.io.InputStream"") Closure<T> closure) throws IOException {
{code}
to:
{code}
public static <T, U extends InputStream> T withStream(U stream, @ClosureParams(value=FirstParam.class) Closure<T> closure) throws IOException {
{code}
DocGenerator doesn't know about ""extends"" and currently maps all placeholders onto java.lang.Object. Hence they show up as extensions on java.lang.Object and in fact the InputStream version clobbers the OutputStream version since they will have the same signature once incorrectly mapped to Object.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 12 20:08:17 UTC 2015,,,,,,,,,,"0|i2c77r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Mar/15 20:08;paulk;hopefully handled now - certainly the recently added methods show up correctly;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
URL getText(requestProperties) Map doesn't accept a GString ,GROOVY-7338,12811551,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,erichelgeson,erichelgeson,11/Mar/15 13:24,21/Jul/15 10:30,14/Jul/23 06:01,19/May/15 13:34,,,,,,,,,,,,,,,,,,2.4.4,,,,,,,,0,,,,,,,"Many times you construct a header with multiple values then pass it to requestProperties map. It would be more groovy if it accepted a GString instead of having to cast it to a String

{code}
# Less Groovy - 
url.getText(requestProperties:[Authentication:""Basic $auth"".toString()]) == 'Groovy a:b'
# More Groovy - 
 url.getText(requestProperties:[Authentication:""Basic $auth""]) == 'Groovy a:b'
{code}

Exception - 
{code}
:test

org.codehaus.groovy.runtime.URLGetTextTest > testGetTextFromURLWithParameters FAILED
    java.lang.ClassCastException: org.codehaus.groovy.runtime.GStringImpl cannot be cast to java.lang.String
        at org.codehaus.groovy.runtime.ResourceGroovyMethods.configuredInputStream(ResourceGroovyMethods.java:2026)
        at org.codehaus.groovy.runtime.ResourceGroovyMethods.newReader(ResourceGroovyMethods.java:2132)
        at org.codehaus.groovy.runtime.ResourceGroovyMethods.getText(ResourceGroovyMethods.java:665)
        at org.codehaus.groovy.runtime.ResourceGroovyMethods.getText(ResourceGroovyMethods.java:633)
        at org.codehaus.groovy.runtime.dgm$965.invoke(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:271)
        at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:53)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:110)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:122)
        at org.codehaus.groovy.runtime.URLGetTextTest.testGetTextFromURLWithParameters(URLGetTextTest.groovy:57)

1 test completed, 1 failed
:test FAILED
{code}

Test - 
{code}
diff --git a/src/test/org/codehaus/groovy/runtime/URLGetTextTest.groovy b/src/test/org/codehaus/groovy/runtime/URLGetTextTest.groovy
index 8a037e5..29a5f59 100644
--- a/src/test/org/codehaus/groovy/runtime/URLGetTextTest.groovy
+++ b/src/test/org/codehaus/groovy/runtime/URLGetTextTest.groovy
@@ -53,6 +53,9 @@ class URLGetTextTest extends GroovyTestCase {
 
         assert url.getText(requestProperties:[a:'b']) == 'Groovy a:b'
 
+        def b = ""b""
+        assert url.getText(requestProperties:[a:""$b""]) == 'Groovy a:b'
+
         assert url.getText(useCaches:true, requestProperties:[a:'b']) == 'Groovy cached a:b'
 
         assert url.getText() == url.getText()
{code}",,erichelgeson,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 19 13:34:19 UTC 2015,,,,,,,,,,"0|i2cpt3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/May/15 06:19;githubbot;GitHub user eginez opened a pull request:

    https://github.com/apache/incubator-groovy/pull/19

    GROOVY-7338: URL getText(requestProperties) Map now accepts a GString

    What do you guys think about this change for http://jira.codehaus.org/browse/GROOVY-7338, is in a similar location as my previous PR

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/eginez/incubator-groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/19.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #19
    
----
commit d1f1e120c95d69faecb058267bee2fea206d0eff
Author: Esteban <eginez@gmail.com>
Date:   2015-05-19T06:15:49Z

    GROOVY-7338: URL getText(requestProperties) Map now accepts a GString

----
;;;","19/May/15 10:54;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/19
;;;","19/May/15 13:34;paulk;Applied, thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Not so helpful error message shown by ClassNodeResolver, after eating up the real exception",GROOVY-7336,12811565,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,roshandawrani,roshandawrani,10/Mar/15 22:36,11/Mar/15 13:42,14/Jul/23 06:01,11/Mar/15 13:42,2.3.6,,,,,,,,,,,,,,,,,2.4.1,,,,Compiler,,,,0,,,,,,,"Attaching a zip that contains the example to reproduce the issue.

The scenario is this: From my Ant script, I am executing a groovy script (One.groovy), which depends on another script, Two.groovy (which has a compilation error - it refers to a non-existing class FFile).

The problem is that instead of telling me anything about FFile class's non-existence, the groovy compiler gives a not-so-useful error message that looks like below:

{code}
...\bug_report\build.xml:11: 

BUG! exception in phase 'semantic analysis' in source unit '...\bug_report\src\One.groovy' 

The lookup for Two caused a failed compilaton. There should not have been any compilation from this call.

        at org.codehaus.groovy.control.ClassNodeResolver.tryAsLoaderClassOrScript(ClassNodeResolver.java:188)
        at org.codehaus.groovy.control.ClassNodeResolver.findClassNode(ClassNodeResolver.java:168)
        at org.codehaus.groovy.control.ClassNodeResolver.resolveName(ClassNodeResolver.java:124)
        at org.codehaus.groovy.control.ResolveVisitor.resolveToOuter(ResolveVisitor.java:617)
        at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:269)
        at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:237)
        at org.codehaus.groovy.control.ResolveVisitor.resolveOrFail(ResolveVisitor.java:221)
        at org.codehaus.groovy.control.ResolveVisitor.resolveOrFail(ResolveVisitor.java:233)
        at org.codehaus.groovy.control.ResolveVisitor.transformConstructorCallExpression(ResolveVisitor.java:988)
...
...
{code}

It'll do better to include some information about the underlying exception.

""BUG! exception in phase 'semantic analysis' in source unit '...\One.groovy'"" is not much use.",,blackdrag,roshandawrani,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Mar/15 22:36;roshandawrani;bug_report.zip;https://issues.apache.org/jira/secure/attachment/12723279/bug_report.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 11 05:27:17 UTC 2015,,,,,,,,,,"0|i2cmwv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Mar/15 04:22;blackdrag;Hi Roshan, nice to hear of you again. The issue sounds like something I worked on recently because of another report. Is it possible for you to try a newer version of Groovy? ;;;","11/Mar/15 05:27;roshandawrani;Hello Jochen. Just tried with groovy-all-2.4.1.jar and seems to work fine there. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect inferred type in instanceof check of array,GROOVY-7333,12811523,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,09/Mar/15 06:12,21/Mar/15 07:11,14/Jul/23 06:01,09/Mar/15 08:16,2.3.10,2.4.1,,,,,,,,,,,,,,,,2.3.11,2.4.2,,,Static Type Checker,,,,0,,,,,,,"The following code fails with a weird type checking error:

{code}
import groovy.transform.TypeChecked

int len(byte[] arr) { arr.length }
@TypeChecked
def foo(arg) {
   if (arg instanceof byte[]) {
      len(arg)
   }
}
foo(new byte[3])
{code}

Error:

[Static type checking] - Cannot call ConsoleScript0#len(byte[]) with arguments [<UnionTypejava.lang.Object+[B>] 
 at line: 7, column: 7
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-03-09 06:12:54.0,,,,,,,,,,"0|i2c9hj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovysh help and doc commands should use groovy-lang.org instead of groovy.codehaus.org,GROOVY-7332,12817492,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,pschumacher,pschumacher,08/Mar/15 13:25,21/Mar/15 07:11,14/Jul/23 06:01,08/Mar/15 14:43,2.3.10,2.4.1,,,,,,,,,,,,,,,,2.3.11,2.4.2,,,Groovysh,,,,0,,,,,,,,,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-03-08 13:25:42.0,,,,,,,,,,"0|i2cjbr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect dynamic proxy creation from map when there are default methods,GROOVY-7330,12818010,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,dmovchinn,dmovchinn,04/Mar/15 11:21,10/Aug/22 19:12,14/Jul/23 06:01,19/Aug/18 07:02,2.4.1,,,,,,,,,,,,,,,,,2.5.3,3.0.0-alpha-4,,,groovy-runtime,,,,0,default-methods,Java_8,,,,,"{code:java}
package org.dimitrovchi.groovybugs;

import groovy.lang.GroovyShell;
import org.codehaus.groovy.control.CompilerConfiguration;
import org.codehaus.groovy.runtime.DefaultGroovyMethods;
import org.junit.Assert;
import org.junit.Test;

import java.util.Map;

/**
 * @author Dmitry Ovchinnikov
 */
public class MapToProxyTest {

    private final GroovyShell shell;

    public MapToProxyTest() {
        final CompilerConfiguration cc = new CompilerConfiguration();
        cc.setTargetBytecode(CompilerConfiguration.JDK8);
        shell = new GroovyShell(cc);
    }

    @Test
    public void testMapToProxy() {
        final Map map = (Map) shell.evaluate(""[x: {10}, y: {20}]"");
        final SomeInterface si = DefaultGroovyMethods.asType(map, SomeInterface.class);
        Assert.assertEquals(20, si.y());
        Assert.assertEquals(10, si.x()); // assertion error: si.x() == 1
    }

    public interface SomeInterface {

        default int x() {
            return 1;
        }

        int y();
    }
}
{code}

JDK 1.8u31",,dmovchinn,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7412,,,,,,,,GROOVY-10717,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 19 07:02:33 UTC 2018,,,,,,,,,,"0|i2bw1z:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"04/Mar/15 11:29;dmovchinn;Also, you can see that
{code:java}
package org.dimitrovchi.groovybugs;

import groovy.lang.GroovyShell;
import org.codehaus.groovy.control.CompilerConfiguration;
import org.codehaus.groovy.control.customizers.ImportCustomizer;
import org.junit.Assert;
import org.junit.Test;

/**
 * @author Dmitry Ovchinnikov
 */
public class MapToProxyTest {

    private final GroovyShell shell;

    public MapToProxyTest() {
        final CompilerConfiguration cc = new CompilerConfiguration();
        cc.setTargetBytecode(CompilerConfiguration.JDK8);
        cc.addCompilationCustomizers(new ImportCustomizer().addStarImports(MapToProxyTest.class.getPackage().getName()));
        shell = new GroovyShell(cc);
    }

    @Test
    public void testMapToProxy() {
        final SomeInterface si = (SomeInterface) shell.evaluate(""[x: {10}, y: {20}] as MapToProxyTest.SomeInterface"");
        Assert.assertEquals(20, si.y());
        Assert.assertEquals(10, si.x()); // assertion error: si.x() == 1
    }

    public interface SomeInterface {

        default int x() {
            return 1;
        }

        int y();
    }
}
{code}

produces the same result.;;;","17/Aug/18 08:09;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/785

    GROOVY-7330: Incorrect dynamic proxy creation from map when there are…

    … default methods

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7330

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/785.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #785
    
----
commit 2c526ef1d53f8e8a5ef00f660b885a20378fc5a8
Author: Paul King <paulk@...>
Date:   2018-08-17T07:49:50Z

    GROOVY-7330: Incorrect dynamic proxy creation from map when there are default methods

----
;;;","19/Aug/18 06:57;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/785
;;;","19/Aug/18 07:02;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TypeChecking Error when combining generic method and Java Enum,GROOVY-7327,12811539,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tkruse,tkruse,02/Mar/15 10:16,15/Oct/15 18:15,14/Jul/23 06:01,06/Mar/15 09:04,2.4.0,2.4.1,,,,,,,,,,,,,,,,2.4.2,,,,Static Type Checker,,,,0,,,,,,,"To reproduce:
{code}
import groovy.transform.TypeChecked

import java.nio.file.StandardCopyOption

enum TestEnum {
    A, B, C
}

@TypeChecked
class TestGenerics {
    public static <T> List<T> randomSample(T[] sequence) {
        return Arrays.asList(sequence)[0..1]
    }

    def test1 = randomSample(TestEnum.values())
    def test2 = randomSample(StandardCopyOption.values())
}
{code}


/tmp/TestGenerics.groovy: 16: [Static type checking] - Cannot call <T> TestGenerics#randomSample(T[]) with arguments [java.nio.file.StandardCopyOption[]]
 @ line 16, column 17.
       def test2 = randomSample(StandardCopyOption.values())

Same for Collections with Generics instead of arrays.
Note this fails only with Java enums, not Groovy enums.

Could be related to patches for:
https://jira.codehaus.org/browse/GROOVY-5981",,melix,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 03 04:13:32 UTC 2015,,,,,,,,,,"0|i2btef:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Mar/15 10:25;tkruse;Note: As a workaround, it is possible to do an (unnecessary) cast:

def test2 = randomSample(StandardCopyOption.values() as StandardCopyOption[])

for whatever reason...;;;","03/Mar/15 02:43;melix;Thanks for reporting. It is unrelated but be aware that using ""as"" is not strictly equivalent to using a cast. A cast is almost a no-op while ""as"" will always involve a runtime call, being slower.;;;","03/Mar/15 04:13;tkruse;thanks, so proper workaround should be

def test2 = randomSample((StandardCopyOption[]) StandardCopyOption.values());;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Verify error cloning a HashSet under CompileStatic conditions,GROOVY-7325,12811545,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,27/Feb/15 08:11,02/May/17 02:03,14/Jul/23 06:01,02/Mar/15 08:58,2.4.1,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,Static compilation,,,,1,,,,,,,"Taken from:

http://stackoverflow.com/questions/28761736/java-lang-verifyerror-bad-access-to-protected-data

The code:

{code}
import groovy.transform.CompileStatic

@CompileStatic
class Test {
  final Set<String> HISTORY = [] as HashSet

  Set<String> getHistory() {
    return HISTORY.clone() as HashSet<String>
  }
}

Test test = new Test()
println test.history
{code}

Results in the VerifyError:

{code}
java.lang.VerifyError: (class: Test, method: getHistory signature: ()Ljava/util/Set;) Bad access to protected data
	at java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2663)
	at java.lang.Class.getDeclaredConstructors(Class.java:2012)
	at org.codehaus.groovy.reflection.CachedClass$2$1.run(CachedClass.java:71)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.codehaus.groovy.reflection.CachedClass$2.initValue(CachedClass.java:68)
	at org.codehaus.groovy.reflection.CachedClass$2.initValue(CachedClass.java:66)
	at org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:46)
	at org.codehaus.groovy.util.LazyReference.get(LazyReference.java:33)
	at org.codehaus.groovy.reflection.CachedClass.getConstructors(CachedClass.java:265)
	at groovy.lang.MetaClassImpl.<init>(MetaClassImpl.java:215)
	at groovy.lang.MetaClassImpl.<init>(MetaClassImpl.java:225)
	at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createNormalMetaClass(MetaClassRegistry.java:168)
	at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createWithCustomLookup(MetaClassRegistry.java:158)
	at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.create(MetaClassRegistry.java:141)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:250)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:282)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:255)
	at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:872)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallConstructorSite(CallSiteArray.java:84)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:232)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:236)
	at ConsoleScript0.run(ConsoleScript0:12)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:261)
	at groovy.lang.GroovyShell.run(GroovyShell.java:522)
	at groovy.lang.GroovyShell.run(GroovyShell.java:501)
	at groovy.lang.GroovyShell.run(GroovyShell.java:168)
	at groovy.lang.GroovyShell$run$1.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:110)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:138)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:977)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:292)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1016)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure.call(Closure.java:417)
	at groovy.lang.Closure.run(Closure.java:504)
	at java.lang.Thread.run(Thread.java:745)
{code}

A workaround is to change the line:

{code}
  final Set<String> HISTORY = [] as HashSet
{code}

To

{code}
  final HashSet<String> HISTORY = [] as HashSet
{code}

Then you get expected behaviour",,haimat,melix,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6656,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 02 08:58:27 UTC 2015,,,,,,,,,,"0|i2briv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Mar/15 08:58;melix;I have fixed it on master. Basically it will be a compile time error if you use {{@CompileStatic}} to call a protected method from a wrong context, like the {{clone}} method here.

I am only setting this to be fixed in 2.5 for now because I am unsure if there's not a regression somewhere so I'd like to give people chances to report it.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incomplete generic type inference for list.property notation,GROOVY-7324,12817449,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,26/Feb/15 02:53,21/Mar/15 07:11,14/Jul/23 06:01,26/Feb/15 04:16,2.4.1,,,,,,,,,,,,,,,,,2.3.11,2.4.2,,,,,,,0,,,,,,,"The following code will not compile:

{code}
class Account {
   String id
}
class GCAccount {
   List<Account> sfAccounts
}
class User {
   List<GCAccount> gcAccounts
}

@groovy.transform.CompileStatic
void foo() {
def accounts = (1..10).collect { new Account(id:""Id $it"") }
def user = new User(gcAccounts:[new GCAccount(sfAccounts:accounts[0..2]),new GCAccount(sfAccounts:accounts[3..4])])
def ids = user.gcAccounts.sfAccounts.id.flatten()
println ids
}
foo()
{code}

The error is:
{noformat}
No such property: id for class: java.util.List <java.util.List>
{noformat}

indicating that the generic type inference is incomplete.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-02-26 02:53:08.0,,,,,,,,,,"0|i2ctcf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Static Trait Methods ,GROOVY-7322,12811538,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,25/Feb/15 20:55,21/Mar/15 07:11,14/Jul/23 06:01,06/Mar/15 07:45,2.4.1,,,,,,,,,,,,,,,,,2.4.2,,,,,,,,0,,,,,,,"The attached statictraitmethods.zip contains the following:

{code:title=src/main/groovy/demo/SomeTrait.groovy|borderStyle=solid}
package demo

import groovy.transform.CompileStatic

@CompileStatic
trait SomeTrait {

    static someMethod() {
        List theNames = getNames()
        theNames
    }

    static List getNames() {
        ['Jeff', 'Betsy', 'Jake', 'Zack']
    }
}
{code}

The code will not compile:

{noformat}
$ ./gradlew clean test
:clean UP-TO-DATE
:compileJava UP-TO-DATE
:compileGroovy
startup failed:
/Users/jeff/statictraitmethods/src/main/groovy/demo/SomeTrait.groovy: 9: [Static type checking] - Cannot find matching method demo.SomeTrait#getNames(). Please check if the declared type is right and if the method exists.
 @ line 9, column 25.
           List theNames = getNames()
                           ^

1 error

:compileGroovy FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileGroovy'.
> Compilation failed; see the compiler error output for details.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 5.148 secs
{noformat}

This may be the same problem as that described in GROOVY-7191.  That issue describes the problem as relating to calling static methods from an instance method.  The example above suggests that the problem is more general than that.",,brownj,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7191,,,,,,"25/Feb/15 20:55;brownj;statictraitmethods.zip;https://issues.apache.org/jira/secure/attachment/12723075/statictraitmethods.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 06 07:45:43 UTC 2015,,,,,,,,,,"0|i2cb1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Mar/15 07:45;melix;Fixed by detecting the error in the trait type checking extension, then converting it into a dynamic method call.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic cannot infer generic return type,GROOVY-7316,12811515,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,gillius,gillius,20/Feb/15 15:38,18/May/22 19:55,14/Jul/23 06:01,20/Mar/15 08:59,2.4.1,,,,,,,,,,,,,,,,,2.4.3,,,,Static Type Checker,,,,0,,,,,,,"{code}
public <T> T getSomething() { null }

@groovy.transform.CompileStatic
public List getList() { getSomething() }
{code}

Error:
{noformat}
[Static type checking] - Cannot return value of type T on method returning type java.util.List
{noformat}",,blackdrag,gillius2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10342,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 23 12:03:37 UTC 2015,,,,,,,,,,"0|i2cnen:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"20/Feb/15 15:42;gillius;For some reason I can't understand, if I replace getSomething() with java.util.Collections.emptyList(), it works. It appears that the key is that the emptyList returns List<T> which is assignable to List.;;;","23/Feb/15 02:48;blackdrag;Either both should work or not. I am for the later.;;;","23/Feb/15 09:00;gillius;Well, in Java, this works:

{code}
public class Blah {
	public static <T> T getSomething() { return null; }

	public static void main(String[] args) {
		String x = getSomething();
		System.out.println(x);
	}
}
{code}

Since Groovy tends to follow Java, I would think this should work. Such a method does not normally have a great use, but it can have a use in DSLs or for example take a Mockito example {{mock.doCall(anyObject())}} where anyObject is a method like my getSomething, but Mockito uses it to record a matcher against the upcoming doCall on the mock.

In my case, my ""getSomething"" actually took a Closure that implements a predicate that finds an object that I expect to be of type T. In this sense it is similar to Groovy find method, which could be seen as returning generic T instead of Object (such that {{Integer x = \[1,2,3].find\{it==2}}} becomes valid without casting).;;;","23/Feb/15 12:03;blackdrag;it is kind of funny to implement something in the typechecker to basically disable typechecking completely. But I guess it should pass;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic/TypeChecked cannot create non-static nested inner class using named-arg short-hand syntax,GROOVY-7315,12811530,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,gillius,gillius,20/Feb/15 15:34,06/Mar/18 23:12,14/Jul/23 06:01,13/Nov/17 02:53,2.3.9,2.4.1,,,,,,,,,,,,,,,,2.4.13,,,,Static Type Checker,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
class X {
  Y makeY() {
    new Y(a:1)
  }
  
  private class Y {
    int a
  }
}

println new X().makeY()
{code}

Error:
{noformat}
[Static type checking] - Cannot find matching method X$Y#<init>(X, java.util.LinkedHashMap <java.lang.String, java.lang.Integer>). Please check if the declared type is right and if the method exists.
{noformat}",,gillius2,githubbot,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7379,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 13 02:53:10 UTC 2017,,,,,,,,,,"0|i2ccg7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"09/Nov/17 11:54;paulk;Workaround:
{code}
  Y makeY() {
//    new Y(a:1)
    def y = new Y()
    y.a = 1
    y
  }
{code};;;","12/Nov/17 13:09;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/634

    GROOVY-7315: CompileStatic/TypeChecked cannot create non-static neste…

    …d inner class using named-arg short-hand syntax

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7315

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/634.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #634
    
----
commit bbe86ea52512803d155ed0c085f8b0cce0299b13
Author: paulk <paulk@asert.com.au>
Date:   2017-11-12T13:07:27Z

    GROOVY-7315: CompileStatic/TypeChecked cannot create non-static nested inner class using named-arg short-hand syntax

----
;;;","12/Nov/17 22:25;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/634
;;;","13/Nov/17 02:53;paulk;Proposed PR merged.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler generates invalid inner class constructor,GROOVY-7312,12811543,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,shils,alewando,alewando,19/Feb/15 21:38,03/Jan/17 23:07,14/Jul/23 06:01,25/Feb/16 05:51,2.4.0,,,,,,,,,,,,,,,,,2.4.7,,,,class generator,Compiler,,,1,,,,,,,"replacement description:
{code:title=Intf.groovy|borderStyle=solid}
interface Intf {
  def foo = { ""bar"" }
}
{code}
Will create an inner class that lacks the static modifier for the inner class table. Compare with
{code:title=JavaInterface.java}
public interface JavaInterface {
  class NestedInInterface {}
}
{code}for reference


Original description:
The JLS specifies that an implicitly-declared constructor of a non-private inner class ""implicitly declares one formal parameter representing the immediately enclosing instance of the class"" ([Section 8.8.9|http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.8.9], see also [8.8.1|http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.8.1]). 

{code:title=Intf.groovy|borderStyle=solid}
interface Intf {
  def foo = { ""bar"" }
}
{code}

The above code creates an inner class (Intf$1, not exactly sure what it's for) with a default constructor that has no parameters:

{noformat}
$ javap -p -classpath classes 'Intf$1'
Compiled from ""Intf.groovy""
class Intf$1 implements groovy.lang.GroovyObject {
  ...
  public Intf$1();
  ...
}
{noformat}

While not a major issue, this non-conformance can break interoperability with anything that expects to work with Java classes. This particular example came up while trying to use a similarly-declared Groovy class from a Scala class, where the Scala compiler was unable to parse the generated inner class.

For reference, here is an example Java Inner class and it's compiled representation. Note the constructor parameter on the inner class.
{code:title=JavaObj.java|borderStyle=solid}
public class JavaObj {
  public class Inner {}
}
{code}

{noformat}
$ javap -p -classpath classes 'JavaObj$Inner'
public class JavaObj$Inner {
  final JavaObj this$0;
  public JavaObj$Inner(JavaObj);
}
{noformat}",,alewando,blackdrag,githubbot,mchadfield,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8032,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 09 23:04:23 UTC 2016,,,,,,,,,,"0|i2ce6n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Feb/15 21:59;blackdrag;I think there is a misunderstanding. The Java spec differentiates between nested classes and inner classes. A nested class basically is a static inner class. But it has the consequence, that for example this informal first parameter will not appear. Since an interface is no full class in the sense of the JLS, it cannot have inner classes, only nested classes. The open block you used in Intf usually generates an inner class, but that is optional. If the open block has no references to the surrounding class, then it can be a nested class instead. In case of Intf the nest class is the only possible case, using an open block in a static method would be another case. So if Scala had a problem with this class, then for other reasons. It is of course possible that some flags are set wrong or such. But of course you are not supposed to directly use that class either.;;;","20/Feb/15 06:58;alewando;I see, thanks for the explanation, which makes sense. Backing up what you said, I constructed a nested class inside of a java interface:
{code:title=JavaInterface.java}
public interface JavaInterface {
  class NestedInInterface {}
}
{code}

And it also creates a similar no-arg constructor for the nested class:
{noformat}
$ javap -p  -classpath classes 'JavaInterface$NestedInInterface'
public class JavaInterface$NestedInInterface {
  public JavaInterface$NestedInInterface();
}
{noformat}

Scala, incidentally, wasn't trying to use the class, just parse it. I will raise this issue there. Thanks for your help.;;;","20/Feb/15 08:33;alewando;Looking closer, I do think there is something wrong with the generated inner class, or at least inconsistent w/ the way javac handles this case. Javac marks this inner class as static in the InnerClasses attribute of it's class file, but groovy does not.

Using the same example classes as above, for the JavaInterface$NestedInInterface class:
{panel}
$ javap -p -v  -classpath classes 'JavaInterface$NestedInInterface'
Classfile .../JavaInterface$NestedInInterface.class
public class JavaInterface$NestedInInterface
  *InnerClasses:*
       *public static* #14= #3 of #12; //NestedInInterface=class JavaInterface$NestedInInterface of class JavaInterface
  minor version: 0
  major version: 51
  flags: ACC_PUBLIC, ACC_SUPER
{panel}

And for the groovy Intf$1 class:
{panel}
$ javap -p -v  -classpath classes 'Intf$1'
Classfile .../Intf$1.class
class Intf$1 implements groovy.lang.GroovyObject
  *InnerClasses:*
       *#107*= #2 of #75; //1=class Intf$1 of class Intf
  minor version: 0
  major version: 49
  flags: ACC_SUPER, ACC_SYNTHETIC
{panel}

It is the lack of the 'static' indicator that causes scalac problems. Without that, I don't think it can tell that this is a nested class and treats it as an inner class instead. ;;;","20/Feb/15 09:44;blackdrag;adding static should not be a problem;;;","09/Feb/16 23:01;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/257

    GROOVY-7312 Add ACC_STATIC flag to inner classes of interfaces

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7312

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/257.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #257
    
----
commit 0012b17aa72e7f4ee6acaef93ea59d74c9559fc1
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2016-02-09T23:00:16Z

    GROOVY-7312 Add ACC_STATIC flag to inner classes of interfaces

----
;;;","09/Feb/16 23:04;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/257#discussion_r52389570
  
    --- Diff: src/main/org/codehaus/groovy/classgen/asm/ClosureWriter.java ---
    @@ -80,7 +80,11 @@ public void writeClosure(ClosureExpression expression) {
     
             // generate closure as public class to make sure it can be properly invoked by classes of the
             // Groovy runtime without circumventing JVM access checks (see CachedMethod for example).
    -        ClassNode closureClass = getOrAddClosureClass(expression, ACC_PUBLIC);
    +        int mods = ACC_PUBLIC;
    +        if (classNode.isInterface()) {
    --- End diff --
    
    Classes for closures defined in static methods could (should?) also be flagged as static, but I left that case as is since it wasn't mentioned in GROOVY-7312.
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
getGeneratedMethods is missing from the type checking DSL,GROOVY-7310,12811518,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,19/Feb/15 07:58,21/Mar/15 07:11,14/Jul/23 06:01,20/Feb/15 06:51,2.3.10,2.4.1,,,,,,,,,,,,,,,,2.3.11,2.4.2,,,,,,,0,,,,,,,"The ""generatedMethods"" property should be accessible from the type checking extensions, as stated in the documentation, however it is a private field from a superclass.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-02-19 07:58:51.0,,,,,,,,,,"0|i2cilz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Incorrect args processing in GroovyShell.run(Reader, String, List)",GROOVY-7309,12811517,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,dmovchinn,dmovchinn,18/Feb/15 12:27,23/Feb/15 01:12,14/Jul/23 06:01,18/Feb/15 14:14,2.4.1,,,,,,,,,,,,,,,,,2.4.2,,,,groovy-runtime,,,,0,,,,,,,"https://github.com/groovy/groovy-core/blob/master/src/main/groovy/lang/GroovyShell.java#L553

{code:java}
public Object run(final Reader in, final String fileName, List list) throws CompilationFailedException {
return run(in, fileName, new String[list.size()]);
}
{code}

but must be something like

{code:java}
list.toArray(new String[list.size()])
{code}",,dmovchinn,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 18 14:14:18 UTC 2015,,,,,,,,,,"0|i2bnzr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Feb/15 14:14;pschumacher;Fixed. Thanks for reporting! :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Change In MetaClass Behavior,GROOVY-7308,12811510,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,18/Feb/15 08:53,21/Mar/15 07:11,14/Jul/23 06:01,25/Feb/15 09:14,2.3.10,,,,,,,,,,,,,,,,,2.3.11,2.4.2,,,,,,,0,,,,,,,"The attached propertyaccess.zip contains the following:

{code:borderStyle=solid|title=src/main/groovy/Widget.groovy}
package demo

class Widget {

    static Integer someNumber = 42
}
{code}

{code:borderStyle=solid|title=src/test/groovy/WidgetSpec.groovy}
package demo

class WidgetSpec extends spock.lang.Specification {

    void 'test property access'() {
        given:
        Widget.metaClass.getSomeNumber = {
            2112
        }

        when:
        def widget = new Widget()

        then:
        widget.someNumber == 2112
    }
}
{code}

That test fails because widget.someNumber is 42.  If I edit build.gradle and use Groovy 2.3.9 instead of 2.3.10, the test passes.  Is this change in behavior intentional?

Lari thinks that maybe https://github.com/groovy/groovy-core/commit/5e446eca2bae406619d8a6b115af6e4521bed2e4 is relevant.",,brownj,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7269,,,,"18/Feb/15 08:53;brownj;propertyaccess.zip;https://issues.apache.org/jira/secure/attachment/12723271/propertyaccess.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 18 09:14:06 UTC 2015,,,,,,,,,,"0|i2cn5b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Feb/15 08:55;brownj;FYI... The test passes with 2.4.0 and fails with 2.4.1.;;;","18/Feb/15 09:14;melix;Affects both Grails 2 and Grails 3. The problem is the mix of static and non static properties of the same name in ExpandoMetaClass.

My bet would be that this line: https://github.com/groovy/groovy-core/blob/master/src/main/groovy/lang/ExpandoMetaClass.java#L957-957 needs a guard on `isStatic` based on the static flag of the meta bean property.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Narrower generic type not taken into account when calling another generic method,GROOVY-7307,12811521,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,fpavageau,fpavageau,18/Feb/15 07:16,31/Mar/15 06:08,14/Jul/23 06:01,20/Mar/15 07:17,2.4.0,2.4.1,,,,,,,,,,,,,,,,2.4.3,,,,Static Type Checker,,,,0,,,,,,,"Given the following class:
{code}
@TypeChecked
class A { 
    static <T extends Number> T id(T value) {
        value
    }   

    // Narrower generic type: doesn't compile
    static <T extends Integer> T id2(T value) {
        id(value)
    }   

    // Narrower generic type: doesn't compile either
    static <T extends Integer> T id3(T value) {
        A.<T>id(value)
    }   

    // Fixed type: compiles
    static Integer id4(Integer value) {
        id(value)
    }   
}
{code}
{{id2}} and {{id3}} generate compilation errors by the static type checker:
{noformat}
[ERROR] Failed to execute goal org.codehaus.gmavenplus:gmavenplus-plugin:1.3:compile (default) on project generic-return-type: Error occurred while calling a method on a Groovy class from classpath. InvocationTargetException: startup failed: 
[ERROR] /Users/fpavageau/devs/bugs/generic-return-type/src/main/groovy/A.groovy: 26: [Static type checking] - Cannot return value of type T on method returning type T
[ERROR] @ line 26, column 9.
[ERROR] id(value)
[ERROR] ^
[ERROR] 
[ERROR] /Users/fpavageau/devs/bugs/generic-return-type/src/main/groovy/A.groovy: 31: [Static type checking] - Cannot return value of type T on method returning type T
[ERROR] @ line 31, column 9.
[ERROR] A.<T>id(value)
[ERROR] ^
[ERROR] 
[ERROR] 2 errors
{noformat}

I've attached a test case, which is also available on [Github|https://github.com/fpavageau/generic-return-type]. It also contains a Java class ({{B}}) doing the same things, but without error.",,fpavageau,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6757,,,,"18/Feb/15 07:16;fpavageau;generic-return-type.tar.gz;https://issues.apache.org/jira/secure/attachment/12723269/generic-return-type.tar.gz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 20 07:17:49 UTC 2015,,,,,,,,,,"0|i2c71z:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"19/Mar/15 09:41;melix;Regarding {code}A.<T>{code}, while Groovy supports the syntax, the information is lost during compilation so the type checker doesn't have access to it : see GROOVY-6757

;;;","20/Mar/15 07:17;melix;I fixed the problem, but not for the explicit type hint, which must be solved as part of GROOVY-6757;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Invalid stub generated for a constructor using a generic bounded parameter,GROOVY-7306,12818001,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,fpavageau,fpavageau,18/Feb/15 05:25,18/Jan/23 00:03,14/Jul/23 06:01,21/Mar/21 14:37,2.4.0,2.4.1,,,,,,,,,,,,,,,,2.5.21,3.0.8,4.0.0-alpha-3,,Stub generator / Joint compiler,,,,0,,,,,,,"Given the 2 following classes:
{code}
class A<T extends Number> {
    final T value

    A(T value) {
        this.value = value
    }
}
{code}
and
{code}
class B extends A<Integer> {
    B(Integer value) {
        super(value)
    }
}
{code}
the generated stub for B does not compile, as the constructor parameter is cast to the bounded type instead of the actual type:
{code}
public class B
  extends A<java.lang.Integer> {
;
public B
(java.lang.Integer value) {
super ((java.lang.Number)null);
}
// ...
}
{code}

The error returned by the compiler is:
{noformat}
target/generated-sources/groovy-stubs/main/B.java:[13,1] constructor A in class A<T> cannot be applied to given types;
  required: java.lang.Integer
  found: java.lang.Number
  reason: actual argument java.lang.Number cannot be converted to java.lang.Integer by method invocation conversion
{noformat}

I've attached a test case, which is also available on [Github|https://github.com/fpavageau/generic-superclass-stub].",,fpavageau,keegan,,,,,,,,,,,,,,"eric-milles opened a new pull request #1527:
URL: https://github.com/apache/groovy/pull/1527


   https://issues.apache.org/jira/browse/GROOVY-7306


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Mar/21 15:51;githubbot;600","danielsun1106 commented on a change in pull request #1527:
URL: https://github.com/apache/groovy/pull/1527#discussion_r598082214



##########
File path: src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
##########
@@ -576,25 +576,31 @@ private void printConstructor(PrintWriter out, ClassNode clazz, ConstructorNode
         }
     }
 
-    private static Parameter[] selectAccessibleConstructorFromSuper(ConstructorNode node) {
-        ClassNode type = node.getDeclaringClass();
-        ClassNode superType = type.getUnresolvedSuperClass();
+    private static Parameter[] selectAccessibleConstructorFromSuper(final ConstructorNode source) {
+        ClassNode superType = source.getDeclaringClass().getUnresolvedSuperClass();
+        Map<String, ClassNode> superTypeGenerics = createGenericsSpec(superType);
 
         Parameter[] bestMatch = null;
-        for (ConstructorNode c : superType.getDeclaredConstructors()) {
-            // Only look at things we can actually call
-            if (!c.isPublic() && !c.isProtected()) continue;
-            Parameter[] parameters = c.getParameters();
-            // workaround for GROOVY-5859: remove generic type info
-            Parameter[] copy = new Parameter[parameters.length];
-            for (int i = 0; i < copy.length; i++) {
-                Parameter orig = parameters[i];
-                copy[i] = new Parameter(orig.getOriginType().getPlainNodeReference(), orig.getName());
-            }
-            if (noExceptionToAvoid(node,c)) return copy;
-            if (bestMatch==null) bestMatch = copy;
+        for (ConstructorNode target : superType.getDeclaredConstructors()) {
+            // only look at things we can actually call
+            // TODO: package-private and types are peers

Review comment:
       more  tweak planned?




-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Mar/21 08:28;githubbot;600","eric-milles commented on a change in pull request #1527:
URL: https://github.com/apache/groovy/pull/1527#discussion_r598137121



##########
File path: src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
##########
@@ -576,25 +576,31 @@ private void printConstructor(PrintWriter out, ClassNode clazz, ConstructorNode
         }
     }
 
-    private static Parameter[] selectAccessibleConstructorFromSuper(ConstructorNode node) {
-        ClassNode type = node.getDeclaringClass();
-        ClassNode superType = type.getUnresolvedSuperClass();
+    private static Parameter[] selectAccessibleConstructorFromSuper(final ConstructorNode source) {
+        ClassNode superType = source.getDeclaringClass().getUnresolvedSuperClass();
+        Map<String, ClassNode> superTypeGenerics = createGenericsSpec(superType);
 
         Parameter[] bestMatch = null;
-        for (ConstructorNode c : superType.getDeclaredConstructors()) {
-            // Only look at things we can actually call
-            if (!c.isPublic() && !c.isProtected()) continue;
-            Parameter[] parameters = c.getParameters();
-            // workaround for GROOVY-5859: remove generic type info
-            Parameter[] copy = new Parameter[parameters.length];
-            for (int i = 0; i < copy.length; i++) {
-                Parameter orig = parameters[i];
-                copy[i] = new Parameter(orig.getOriginType().getPlainNodeReference(), orig.getName());
-            }
-            if (noExceptionToAvoid(node,c)) return copy;
-            if (bestMatch==null) bestMatch = copy;
+        for (ConstructorNode target : superType.getDeclaredConstructors()) {
+            // only look at things we can actually call
+            // TODO: package-private and types are peers

Review comment:
       No, just a note that there is a latent issue here.




-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Mar/21 17:24;githubbot;600","eric-milles merged pull request #1527:
URL: https://github.com/apache/groovy/pull/1527


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;21/Mar/21 14:36;githubbot;600",,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/Feb/15 05:25;fpavageau;generic-superclass-stub.tar.gz;https://issues.apache.org/jira/secure/attachment/12723196/generic-superclass-stub.tar.gz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-02-18 05:25:57.0,,,,,,,,,,"0|i2bur3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot mutate private field from within an AIC or a closure,GROOVY-7304,12811527,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,blackdrag,blackdrag,17/Feb/15 09:16,24/Feb/22 19:38,14/Jul/23 06:01,01/Aug/20 11:36,,,,,,,,,,,,,,,,,,2.5.16,3.0.6,4.0.0-alpha-1,,Static compilation,,,,0,,,,,,,"{code:Java}
class Foo {
    private int i = 1
    @groovy.transform.CompileStatic
    def m() { new String().with {++i}}
}
assert new Foo().m() == 2
class Bar extends Foo {}
assert new Bar().m() == 2{code}

The static compiler is unable to generate code which handles the mutation of a private field like in the example above.",,emilles,melix,,,,,,,,,,,,,,"eric-milles opened a new pull request #1299:
URL: https://github.com/apache/groovy/pull/1299


   https://issues.apache.org/jira/browse/GROOVY-7304


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;05/Jul/20 01:54;githubbot;600","eric-milles commented on pull request #1299:
URL: https://github.com/apache/groovy/pull/1299#issuecomment-653972404


   To merge into Groovy 2.5, you would also need: https://github.com/apache/groovy/commit/8c0c5b018805fcab7217f5cdc784fc88354cfb15, https://github.com/apache/groovy/commit/543c97b6e6bbb67cd6c9c71cac1ca37ac8bd39f4, and https://github.com/apache/groovy/commit/77a11e89b70b4e785fab36b9c3e93c11913288a2


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;06/Jul/20 01:35;githubbot;600","paulk-asert commented on pull request #1299:
URL: https://github.com/apache/groovy/pull/1299#issuecomment-654559298


   This looks close to me. When I have @CS just on the method like in Jochen's example it still fails, but @CS on the class and it works.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Jul/20 02:22;githubbot;600","eric-milles commented on pull request #1299:
URL: https://github.com/apache/groovy/pull/1299#issuecomment-654564905


   I'll have a look


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Jul/20 02:43;githubbot;600","eric-milles edited a comment on pull request #1299:
URL: https://github.com/apache/groovy/pull/1299#issuecomment-654564905


   I'll have a look.  I think the closure class is not having static compilation applied when the containing method is annotated.  This is a bit like [GROOVY-9327](https://github.com/apache/groovy/commit/44893abc65656fa45f468e970da2964fd181a0ef).


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Jul/20 03:52;githubbot;600","eric-milles edited a comment on pull request #1299:
URL: https://github.com/apache/groovy/pull/1299#issuecomment-654564905


   I'll have a look.  I think the closure class is not having static compilation applied when the containing method is annotated.  This is a bit like [GROOVY-9327](https://github.com/apache/groovy/commit/44893abc65656fa45f468e970da2964fd181a0ef).
   
   Do you want to consider that part of this issue or a separate one?


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Jul/20 03:52;githubbot;600","paulk-asert commented on pull request #1299:
URL: https://github.com/apache/groovy/pull/1299#issuecomment-654662391


   Yes, it is not uncommon. I'll just have to refresh my memory. I'll take a look in parallel if I get time and if I spot something obvious I'll report back here. If we find an obvious fix we can add it here (since that was the original case in the issue) but otherwise we can just clone the issue and fix separately.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Jul/20 07:42;githubbot;600","eric-milles commented on pull request #1299:
URL: https://github.com/apache/groovy/pull/1299#issuecomment-654866505


   I think I found the culprit.  I will amend the pull request if testing bears out.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Jul/20 13:38;githubbot;600","eric-milles commented on pull request #1299:
URL: https://github.com/apache/groovy/pull/1299#issuecomment-654934658


   There still seems to be a problem when static compilation is applied using compiler configuration, like is done in the Groovy7276 test.  When I added a test case there with `@CompileDynamic` on the class to cancel out the config and `@CompileStatic` on the method, the generated methods did not get static compilation.  But I think that is a more general issue with mixing compiler config with annotations and generated methods.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Jul/20 15:16;githubbot;600","eric-milles commented on pull request #1299:
URL: https://github.com/apache/groovy/pull/1299#issuecomment-654954174


   Also, there is some room for improvement in `org.codehaus.groovy.transform.sc.StaticCompilationVisitor#isStaticallyCompiled` and `org.codehaus.groovy.classgen.asm.sc.StaticTypesWriterController#updateStaticCompileFlag`.  An inner class may have an enclosing method that should take precedence over the outer class.  And the update method appears to repeat some logic that is or could be encompassed in the isser or the SC visitor.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Jul/20 15:47;githubbot;600",,0,6000,,,0,6000,,,,,,,,,,,,GROOVY-9892,,,,,,,,,,,,,GROOVY-7276,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 13 21:03:00 UTC 2020,,,,,,,,,,"0|i2ce1r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Feb/15 09:45;melix;A test case for this is already written: https://github.com/melix/groovy-core/blob/d54da475cec801114f40bf516c7a3a846b4dce01/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7276Bug.groovy#L79-79;;;","13/Feb/20 21:03;emilles;Similar to GROOVY-8707, the prefix expression ""++i"" performs a standard visit for the LHS, which results in a ScriptBytecodeAdapter#setProperty (via {{visitAttributeOrProperty}} -> {{controller.getCallSiteWriter().fallbackAttributeOrPropertySite(...)}}).

The special handling in StaticTypesBinaryExpressionMultiTypeDispatcher that converts an expression into a setter call is not easily adaptable to a situation where the RHS expression has already been visited and is on the operand stack.  If it was, it could be applied within BinaryExpressionHelper#execMethodAndStoreForSubscriptOperator.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
LazyMap size returns incorrect result for un-built maps if same key set more than once,GROOVY-7302,12811524,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,bastamper,bastamper,14/Feb/15 17:04,23/Feb/15 01:12,14/Jul/23 06:01,18/Feb/15 02:39,2.3.8,2.3.9,2.4.0,,,,,,,,,,,,,,,2.3.10,2.4.1,,,JSON,,,,1,,,,,,,"{code}
import groovy.json.internal.LazyMap

def map = new LazyMap()
map.someProperty = ""1""
map.someProperty = ""2""
map.someProperty = ""3""
println ""M: ${map.size()}""  // prints 3  // buildIfNeeded hasn't been called
println map.someProperty  // access map property, buildIfNeeded is called
println ""M: ${map.size()}"" // prints 1
{code}

LazyMap's put() adds values to it's internal array even if it's a redundant key, which leads to size() returning an incorrect result if the LazyMap hasn't been built yet. One fix would be to have size call buildIfNeeded() before returning the size.

I ran into this after modifying json that was loaded via JsonSlurper.
",,bastamper,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-02-14 17:04:14.0,,,,,,,,,,"0|i2ckbr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic doesn't call property accessors on super classes correctly,GROOVY-7300,12817986,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,kyleboon,kyleboon,10/Feb/15 07:34,28/Jul/22 15:21,14/Jul/23 06:01,10/Feb/15 09:01,2.4.0,,,,,,,,,,,,,,,,,2.4.1,,,,Static compilation,,,,0,,,,,,,"Overloading a getter from a super class and then delegating to that parent class requires using the actual method and not the property accessor when using static compilation in groovy 2.4.0. This is something we do to add hibernate validators to a subclass of generated code.  Not using static compilation on the subclass or switching to groovy 2.3.x resolves the issue.

{code}
import groovy.transform.CompileStatic
 
class A {
    private String field1 = 'test'
    
    String getField1() {
        return this.field1
   } 
}
 
@CompileStatic
class B extends A {
    @Override
    String getField1() {
        super.field1
    }
}
 
B b = new B() 
 
println b.field1
{code}

>>> 2.4.0 output 
 Exception thrown
{noformat}
java.lang.StackOverflowError
	at B.getField1(ConsoleScript1:15)
	at B.getField1(ConsoleScript1:15)
	at B.getField1(ConsoleScript1:15)
{noformat}

>>> 2.3.6 output
{noformat}
test
{noformat}",OSX Yosemite,kyleboon,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10708,GROOVY-10707,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-02-10 07:34:44.0,,,,,,,,,,"0|i2bwzj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot create two lists of length 1000,GROOVY-7299,12811516,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,aaudibert,aaudibert,10/Feb/15 04:48,22/May/22 16:05,14/Jul/23 06:01,18/Feb/15 07:34,2.3.7,,,,,,,,,,,,,,,,,2.4.2,,,,Compiler,,,,0,ClassFormatError,,,,,,"When I create two lists with length >= 1000, I get ClassFormatError.

Repro:
{code}
aaudibert-mbp% python -c 'print ""def a = "" + str([0]*1000) + ""\n"" + ""def b = "" + str(range(-1, 999)) + ""\n""' > t.groovy
aaudibert-mbp% groovy t.groovy
Caught: java.lang.ClassFormatError: Duplicate method name&signature in class file t
java.lang.ClassFormatError: Duplicate method name&signature in class file t
zsh: exit 1     groovy t.groovy
aaudibert-mbp% groovy -version
Groovy Version: 2.3.7 JVM: 1.7.0_67 Vendor: Oracle Corporation OS: Mac OS X
{code}

ClassFormatError? o.O

If either list has length less than 1000, this doesn't happen. Is Groovy doing something weird when lists have length >= 1000?
",,aaudibert,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-02-10 04:48:40.0,,,,,,,,,,"0|i2bmun:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"NPE in TypeResolver using <T>, Closure<T> and @CompileStatic",GROOVY-7298,12811505,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,szpak,szpak,09/Feb/15 17:08,23/Feb/15 01:12,14/Jul/23 06:01,10/Feb/15 06:44,2.4.0,,,,,,,,,,,,,,,,,2.3.10,2.4.1,,,Static compilation,,,,0,,,,,,,"@CompileStatic with in the following code causes NPE in TypeResolver.

{code}
@CompileStatic
class ClosureInEachWithCompileStaticIssue {

    <T> T tryToExecuteWithFreePort(Closure<T> closure) {
        [1].each {
            return executeLogicForAvailablePort(closure)
        }
    }

    private <T> T executeLogicForAvailablePort(Closure<T> closure) {
        return closure.call()
    }

    static void main(String[] args) {
        new ClosureInEachWithCompileStaticIssue().executeLogicForAvailablePort { }
    }
}
{code}

{code}
Exception in thread ""main"" java.lang.NullPointerException
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:203)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:218)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:169)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:218)
	at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:96)
	at java.beans.FeatureDescriptor.getParameterTypes(FeatureDescriptor.java:387)
	at java.beans.MethodDescriptor.setMethod(MethodDescriptor.java:116)
	at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:72)
	at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:56)
	at java.beans.Introspector.getTargetMethodInfo(Introspector.java:1163)
	at java.beans.Introspector.getBeanInfo(Introspector.java:426)
	at java.beans.Introspector.getBeanInfo(Introspector.java:173)
	at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:3290)
	at java.security.AccessController.doPrivileged(Native Method)
	at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:3288)
	at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:3264)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:251)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:282)
	at info.solidsoft.rnd.issue.ClosureInEachWithCompileStaticIssue.$getStaticMetaClass(ClosureInEachWithCompileStaticIssue.groovy)
	at info.solidsoft.rnd.issue.ClosureInEachWithCompileStaticIssue.<init>(ClosureInEachWithCompileStaticIssue.groovy)
	at info.solidsoft.rnd.issue.ClosureInEachWithCompileStaticIssue.main(ClosureInEachWithCompileStaticIssue.groovy:19)
{code}

It works fine with @TypeChecked. I will provide a failing test case.",,szpak,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 09 17:16:52 UTC 2015,,,,,,,,,,"0|i2cirr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"09/Feb/15 17:16;szpak;A failing test case: https://github.com/groovy/groovy-core/pull/605

This issue is somehow similar to https://jira.codehaus.org/browse/GROOVY-6556, but it should be already fixed in 2.4.0.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StackOverflowError Related To Trait Generics,GROOVY-7297,12811504,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,brownj,brownj,09/Feb/15 11:46,23/Feb/15 01:12,14/Jul/23 06:01,10/Feb/15 10:07,,,,,,,,,,,,,,,,,,2.4.1,,,,,,,,0,,,,,,,"With the latest Groovy 2.4.1-SNAPSHOT the following code (attached as traitgenerics.zip) is problematic:

{code:title=src/main/groovy/demo/SomeTrait.groovy|borderStyle=solid}
package demo

trait SomeTrait {
    String title
    
    public <T> List<T> someMethod(T data) {}
}
{code}

This test will fail:

{code:title=src/test/groovy/demo/SomeTraitSpec.groovy|borderStyle=solid}
package demo

class SomeTraitSpec extends spock.lang.Specification {

    void 'test something'() {
        when:
        def sc = new Foo(title: 'some title')

        then:
        'some title' == sc.title
    }
}

class Foo implements SomeTrait {}
{code}

The test fails because the call to the Foo constructor results in a StackOverflowError.

{noformat}
java.lang.StackOverflowError
    at com.sun.beans.TypeResolver.erase(TypeResolver.java:242)
    at com.sun.beans.TypeResolver.erase(TypeResolver.java:243)
    at com.sun.beans.TypeResolver.erase(TypeResolver.java:243)
    at com.sun.beans.TypeResolver.erase(TypeResolver.java:243)

    ...

    at com.sun.beans.TypeResolver.erase(TypeResolver.java:243)
    at com.sun.beans.TypeResolver.erase(TypeResolver.java:243)
    at com.sun.beans.TypeResolver.erase(TypeResolver.java:274)
    at java.beans.FeatureDescriptor.getParameterTypes(FeatureDescriptor.java:387)
    at java.beans.MethodDescriptor.setMethod(MethodDescriptor.java:114)
    at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:72)
    at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:56)
    at java.beans.Introspector.getTargetMethodInfo(Introspector.java:1149)
    at java.beans.Introspector.getBeanInfo(Introspector.java:416)
    at java.beans.Introspector.getBeanInfo(Introspector.java:163)
    at demo.SomeTraitSpec.test something(SomeTraitSpec.groovy:7)
{noformat}

I noticed that if the class which implements the trait (Foo in the example above) is defined under src/main/groovy along with the trait, everything seems to work.  The problem only occurs if Foo is defined elsewhere.  In the example above is defined under src/test/groovy.",,blackdrag,brownj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"09/Feb/15 11:46;brownj;traitgenerics.zip;https://issues.apache.org/jira/secure/attachment/12723073/traitgenerics.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 10 10:07:40 UTC 2015,,,,,,,,,,"0|i2bzof:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Feb/15 10:07;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Memoized ignored in trait methods,GROOVY-7293,12813342,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,hubbitus,hubbitus,07/Feb/15 13:32,02/May/21 09:18,14/Jul/23 06:01,21/Mar/21 15:16,2.4.0,,,,,,,,,,,,,,,,,4.0.0-alpha-3,,,,groovy-runtime,,,,0,,,,,,,"{code}
import groovy.transform.Memoized

trait Mem{
    @Memoized
    long traitLongComputation(int seed) {
        System.nanoTime()
    }
}

class CMem{
    @Memoized
    long classLongComputation(int seed) {
        System.nanoTime()
    }   
}

def m = new CMem() as Mem

assert m.classLongComputation(1) == m.classLongComputation(1)
assert m.traitLongComputation(1) == m.traitLongComputation(1)
{code}
{noformat}
Assertion failed: 

assert m.traitLongComputation(1) == m.traitLongComputation(1)
       | |                       |  | |
       | 277756345937226         |  | 277756346056532
       CMem9_groovyProxy@3ef440d5|  CMem9_groovyProxy@3ef440d5
                                 false
{noformat}",,hubbitus,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-02-07 13:32:24.0,,,,,,,,,,"0|i2c2k7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Primitive variables with no initial value expression not given default value when referenced within a closure,GROOVY-7291,12811513,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,d.richter,d.richter,06/Feb/15 01:34,06/Feb/18 04:14,14/Jul/23 06:01,06/Feb/18 04:14,1.8.6,2.2.1,2.4.0,,,,,,,,,,,,,,,2.4.8,,,,,,,,1,,,,,,,"I have problem with following code:
{code}
double a;
def b = {
   a = a + 1;
}
b();
{code}
I tried to compile it with groovy 1.8.6 and it worked 
variable 'a' was instantiated with value 0.0

but after upgrade to groovy 2.2.1
it throws NullPointerException because variable 'a' is instantiated to null

I tried to decompile class files and declaration of 'a' looked like this:
version 1.8.6
{noformat}
CallSite[] var1 = $getCallSiteArray();
        final Reference a = new Reference((Double)DefaultTypeTransformation.box(0.0D));
        DefaultTypeTransformation.doubleUnbox(a.get());
...
{noformat}

version 2.2.1
{noformat}
CallSite[] var1 = $getCallSiteArray();
final Reference a = new Reference((Object)null);
Double var10000 = (Double)a.get();
...
{noformat}

I tried it also with version 2.4.0 but it has same result as 2.2.1
In attachment are groovy classes, compiled classes and consoleOutputs for versions 1.8.6 and 2.2.1","Windows 8.1, JDK 1.7_71 and 1.8_25",blackdrag,d.richter,githubbot,hookluk@gmail.com,jwagenleitner,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/Feb/15 01:34;d.richter;groovyBug.zip;https://issues.apache.org/jira/secure/attachment/12723071/groovyBug.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Oct 22 06:02:29 UTC 2016,,,,,,,,,,"0|i2cp13:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jan/16 11:44;hookluk@gmail.com;what is the status of it?;;;","05/Jan/16 12:57;blackdrag;I did set the fix version for the next release, because I think that is a more than usual bug. But I have only very little time these days to actually do the change. So either someone else does, or you have to wait and see - sorry. Well... another option would actually be, that you guys pay the company employing me to spend time on fixing this - but I don't expect that to be an option;;;","05/Jan/16 14:48;hookluk@gmail.com;thank you for quick response Jochen, 
it's ok to wait for next fixed release. ;;;","03/May/16 10:46;hookluk@gmail.com;Hi guys,

is there any new info about this fix, pls?;;;","08/May/16 17:47;jwagenleitner;Using git bisect looks like the following commit caused the change

https://github.com/apache/groovy/commit/e08c389d67809a421f4f33c27012c54294f98259;;;","09/May/16 19:01;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/331

    GROOVY-7291 - Declaration of double variable without value assignment referrenced in closure

    Commit e08c389d67809a421f4f33c27012c54294f98259 made the change that broke this by resolving the type (Double) whereas the original method call resolved to `getOriginType` (double).  This change tries to preserve the call to the type resolver where the origin is not a primitive.  It should also be noted that fully reverting the call back to the original (`compileStack.defineVariable(ve, false)`) version prior to commit e08c389d67809a421f4f33c27012c54294f98259  also passes all tests.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7291

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/331.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #331
    
----
commit a50582bfb6ed015d700bd8899a2fb1c4e7387d6e
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-05-08T18:56:45Z

    GROOVY-7291 - Declaration of double variable without value assignment referrenced in closure

----
;;;","26/Jul/16 02:01;githubbot;Github user jwagenleitner closed the pull request at:

    https://github.com/apache/groovy/pull/331
;;;","26/Jul/16 02:02;jwagenleitner;Based on feedback in the PR I closed it, since it didn't seem to be the right fix.;;;","10/Oct/16 10:05;githubbot;GitHub user blindpirate opened a pull request:

    https://github.com/apache/groovy/pull/446

    GROOVY-7291 Declaration of double variable without value assignment referrenced in closure

    According to [GROOVY-5570](https://issues.apache.org/jira/browse/GROOVY-5570), a variable referenced by closure must be non-primitive type, and it results in [GROOVY-7291](https://issues.apache.org/jira/browse/GROOVY-7291). In this case, I replace the EmptyExpression to a ConstantExpression with value 0.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/blindpirate/groovy groovy7291

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/446.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #446
    
----
commit f8cb9b233ec1cfa4594f4d544ab12f9311cd4165
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-10-10T09:53:36Z

    fix groovy 7291 bug

----
;;;","16/Oct/16 06:14;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/446
;;;","16/Oct/16 06:35;jwagenleitner;Thanks for reporting the issue, PR 446 merged.;;;","16/Oct/16 07:03;jwagenleitner;Problem still exists for indy.;;;","16/Oct/16 07:13;blackdrag;If the problem exists for indy as well, then the change should be moved to ACG or Verifier;;;","16/Oct/16 07:58;melix;Merging the PR caused the {{master}} to fail. Also please don't reopen fixed bugs. It is better to clone and create a separate issue, or it will mess up release notes.;;;","16/Oct/16 08:55;blackdrag;in this case it was ok, since the bug is not fixed and the version is not released yes;;;","16/Oct/16 09:45;paulk;Yes, in general we don't like reopening an issue after the version it was (initially) fixed in has been released. False alarm in this case.;;;","16/Oct/16 14:07;blackdrag;I hope d319b8a18a53555308286719a6fdb890a5a7dd30 fixes the problems;;;","20/Oct/16 23:51;jwagenleitner;Thanks [~blackdrag], the new commit has fixed it for indy and non-indy.  Any concerns about resolving this now so it gets in the 2.4.8 release notes?;;;","21/Oct/16 00:26;paulk;+1 to resolve. Just wondering whether we can improve the summary. It applies to all primitives not just doubles? I guess we could test some others too?;;;","21/Oct/16 01:17;jwagenleitner;Great point, this did affect all primitives so a summary change would be good.  Maybe something such as {{Declared primitive not set to default value if referenced in a closure}}?

Also agree that including the other types in the test would be good, maybe the following would help cover it?

{code}
class Groovy7291Bug extends GroovyTestCase {
    void testPrimitiveDeclarationHasDefaultValueInClosure() {
        assertScript '''
            boolean z
            byte b
            char c
            short s
            int i
            long j
            float f
            double d
            def cl = {
                assert z == false && z.class == Boolean
                assert b == 0 && b.class == Byte
                assert c == '\u0000' && c.class == Character
                assert s == 0 && s.class == Short
                assert i == 0 && i.class == Integer
                assert j == 0L && j.class == Long
                assert f == 0.0f && f.class == Float
                assert d == 0.0d && d.class == Double
            }
            cl()
        '''
    }

    void testWrapperDeclarationIsNullInClosure() {
        assertScript '''
            Boolean z
            Byte b
            Character c
            Short s
            Integer i
            Long j
            Float f
            Double d
            def cl = {
                assert z == null
                assert b == null
                assert c == null
                assert s == null
                assert i == null
                assert j == null
                assert f == null
                assert d == null
            }
            cl()
        '''
    }
}
{code};;;","21/Oct/16 09:12;blackdrag;resolved as per suggestion and because it is fixed ;);;;","21/Oct/16 09:12;blackdrag;Paul, yes it was all primitives;;;","21/Oct/16 12:00;paulk;@John, I changed the summary along the lines you suggested but haven't added your extra test. Would you like to do that?;;;","21/Oct/16 15:30;jwagenleitner;I added the test cases to cover all the primitives (and wrappers).;;;","22/Oct/16 06:02;paulk;Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,
Shell Does Not Accept Triple Double Quote,GROOVY-7290,12811507,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,spmallette,spmallette,05/Feb/15 14:20,21/Mar/15 07:11,14/Jul/23 06:01,23/Feb/15 06:57,2.4.0,,,,,,,,,,,,,,,,,2.4.2,,,,Groovysh,,,,0,,,,,,,"A string defined via the triple double quote (not assigned to a variable) in the groovysh generates an error:

{code}
$ bin/groovysh
Groovy Shell (2.4.0, JVM: 1.8.0_31)
Type ':help' or ':h' for help.
-------------------------------------------------------------------------------
groovy:000> ""test""
===> test
groovy:000> 'test'
===> test
groovy:000> """"""test""""""
assert name
       |
       """"
        at java_lang_Runnable$run.call (Unknown Source)
groovy:000> """"""test
{code}

The above was possible in previous versions.  My guess is that this problem introduced itself given the new method for parsing code lines given to groovysh (but i'm not 100% sure):

https://github.com/groovy/groovy-core/blob/GROOVY_2_4_X/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/util/CommandArgumentParser.groovy",,melix,spmallette,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 23 06:57:26 UTC 2015,,,,,,,,,,"0|i2cdrz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Feb/15 11:48;tkruse;Thanks for the report. Created a pull request to fix it here https://github.com/groovy/groovy-core/pull/614;;;","23/Feb/15 06:57;melix;Thanks, I just merged the PR.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Delegate to object by Class which implementing trait with fields complains 'abstract method in a non-abstract class',GROOVY-7288,12817999,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,hubbitus,hubbitus,03/Feb/15 17:07,23/Jul/22 16:18,14/Jul/23 06:01,21/Mar/22 00:44,2.3.6,,,,,,,,,,,,,,,,,3.0.11,4.0.2,,,Compiler,,,,0,trait,traits,,,,,"Please look at short reproduce:
{code}
import groovy.transform.TupleConstructor

trait Some{
    String STATIC = 'static data' // Commenting it out make it work (it have no difference static it or not)

    String so(){
        println ('STATIC=' + STATIC)
    }
}

class Delegator implements Some{
    String delegated(){
        println 'delegated work'
    }
}

class SomeClass{
    @Delegate Delegator delegator = new Delegator();
}

def s = new SomeClass()
s.delegated()
{code}
Running it I have:
{noformat}
2 compilation errors:

Can't have an abstract method in a non-abstract class. The class 'SomeClass' must be declared abstract or the method 'java.lang.String Some__STATIC$get()' must be implemented.
 at line: 17, column: 1

Can't have an abstract method in a non-abstract class. The class 'SomeClass' must be declared abstract or the method 'void Some__STATIC$set(java.lang.String)' must be implemented.
 at line: 17, column: 1
{noformat}",,emilles,hubbitus,paulk,,,,,,,,,,,,,"eric-milles opened a new pull request #1703:
URL: https://github.com/apache/groovy/pull/1703


   Don't transfer synthetic interfaces like `T$Trait$FieldHelper` to owner class.
   
   https://issues.apache.org/jira/browse/GROOVY-7288


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Mar/22 15:50;githubbot;600","paulk-asert merged pull request #1703:
URL: https://github.com/apache/groovy/pull/1703


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Mar/22 22:51;githubbot;600",,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 21 00:45:16 UTC 2022,,,,,,,,,,"0|i2bqtz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Mar/22 15:46;emilles;interface {{Some$Trait$FieldHelper}} is being added to {{{}SomeClass{}}}, which is the source of the abstract methods {{Some__STATIC$get()}} and {{{}Some__STATIC$set(java.lang.String){}}}.;;;","18/Mar/22 16:38;emilles;https://github.com/apache/groovy/pull/1703;;;","21/Mar/22 00:45;paulk;Proposed PR merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Trait Generics With Conflicting Names,GROOVY-7287,12811503,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,brownj,brownj,03/Feb/15 09:33,23/Feb/15 01:12,14/Jul/23 06:01,06/Feb/15 08:23,2.4.0,,,,,,,,,,,,,,,,,2.4.1,,,,,,,,0,,,,,,,"The attached traitgenerics.zip contains the following code:

{code:title=src/main/groovy/demo/SomeTrait.groovy|borderStyle=solid}
package demo

trait SomeTrait<T> {
}
{code}

{code:title=src/main/groovy/demo/SomeOtherTrait.groovy|borderStyle=solid}
package demo

trait SomeOtherTrait {
    def <T> T someOtherMethod() {
    }
}
{code}

{code:title=src/main/groovy/demo/TopClass.groovy|borderStyle=solid}
package demo

class TopClass<T> implements SomeTrait<T>, SomeOtherTrait {}
{code}

{code:title=src/main/groovy/demo/MiddleClass.groovy|borderStyle=solid}
package demo

class MiddleClass<T> extends TopClass<T> implements SomeTrait<T>, SomeOtherTrait {}
{code}

{code:title=src/main/groovy/demo/BottomClass.groovy|borderStyle=solid}
package demo

class BottomClass extends MiddleClass<String> implements SomeTrait<String>, SomeOtherTrait {}
{code}

The code will not compile:

{noformat}
$ ./gradlew clean cG
:clean
:compileJava UP-TO-DATE
:compileGroovy
startup failed:
/Users/jeff/traitgenerics/src/main/groovy/demo/BottomClass.groovy: -1: The return type of java.lang.Object someOtherMethod() in demo.BottomClass is incompatible with java.lang.String in demo.MiddleClass
. At [-1:-1]  @ line -1, column -1.
1 error

:compileGroovy FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileGroovy'.
> Compilation failed; see the compiler error output for details.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 4.054 secs
{noformat}

If I change the type parameter name in SomeOtherTrait to anyting other than T, it compiles...

{code:title=src/main/groovy/demo/SomeOtherTrait.groovy|borderStyle=solid}
package demo

trait SomeOtherTrait {
    def <SOM> SOM someOtherMethod() {
    }
}
{code}
",,blackdrag,brownj,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/Feb/15 09:33;brownj;traitgenerics.zip;https://issues.apache.org/jira/secure/attachment/12723277/traitgenerics.zip","04/Feb/15 09:00;brownj;traitgenerics2.zip;https://issues.apache.org/jira/secure/attachment/12723119/traitgenerics2.zip",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 06 08:23:03 UTC 2015,,,,,,,,,,"0|i2c1lr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Feb/15 09:33;brownj;FYI... I think this behavior is the cause of https://jira.grails.org/browse/GRAILS-11958.;;;","03/Feb/15 10:07;brownj;I was able to simplify the scenario by removing one of the traits.  The following will still demonstrate the problem:


{code:title=src/main/groovy/demo/SomeOtherTrait.groovy|borderStyle=solid}
package demo

trait SomeOtherTrait {
    def <T> T someOtherMethod() {
    }
}
{code}

{code:title=src/main/groovy/demo/TopClass.groovy|borderStyle=solid}
package demo

class TopClass<T> implements SomeOtherTrait {}
{code}

{code:title=src/main/groovy/demo/MiddleClass.groovy|borderStyle=solid}
package demo

class MiddleClass<T> extends TopClass<T> implements SomeOtherTrait {}
{code}

{code:title=src/main/groovy/demo/BottomClass.groovy|borderStyle=solid}
package demo

class BottomClass extends MiddleClass<String> implements SomeOtherTrait {}
{code}
;;;","04/Feb/15 09:00;brownj;I am attaching traitgenerics2.zip which contains a much more simple example which demonstrates the problem.  The original example is unnecessarily complicated and obfuscates the real problem.  Apologies.

The new code:

{code:title=src/main/groovy/demo/SomeTrait.groovy|borderStyle=solid}
package demo

trait SomeTrait {
    def <T> T someOtherMethod() {
    }
}
{code}

{code:title=src/main/groovy/demo/SuperClass.groovy|borderStyle=solid}
package demo

class SuperClass<T> implements SomeTrait {}
{code}

{code:title=src/main/groovy/demo/SubClass.groovy|borderStyle=solid}
package demo

class SubClass extends SuperClass<String> implements SomeTrait {}
{code}

I hope that helps.
;;;","06/Feb/15 08:23;blackdrag;fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stackable Traits at runtime don't honor definition order,GROOVY-7285,12811519,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,hadfield,hadfield,31/Jan/15 09:24,23/Feb/15 01:12,14/Jul/23 06:01,13/Feb/15 06:59,2.3.7,2.4.0,,,,,,,,,,,,,,,,2.3.10,2.4.1,,,groovy-runtime,,,,0,,,,,,,"when defined at runtime, stackable traits don't honor the order in withTraits(), whereas when defined statically they do.  see example code:

{code}
trait D { 
        void methodA() { print ""D""; super.methodA() } 
} 
trait C { 
        void methodA() { print ""C""; super.methodA() } 
} 
trait B { 
        void methodA() { print ""B""; super.methodA() } 
} 
trait A { 
        void methodA() { print ""A"" } 
} 

class M implements A, D, C, B { } 
class Q {} 

class MyDelegationTest { 

        static main(args) { 
                
                println """" ;
                
                def m = new M() ;

                print ""Static: "" ;

                m.methodA() ;

                println """" ;
                
                def q = new Q().withTraits(A,D,C,B) ;

                print ""Dynamic: "" ;

                q.methodA() ;

                println """" ;

        } 
} 
{code}

With output: 

(Correct Order) Static: BCDA 

(Incorrect Order) Dynamic: DCBA 
",,hadfield,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-01-31 09:24:42.0,,,,,,,,,,"0|i2bv3r:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DefaultGroovyMethods methods should include type information,GROOVY-7283,12811483,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,candrews,candrews,28/Jan/15 12:11,02/May/17 02:03,14/Jul/23 06:01,11/Aug/16 12:28,2.4.0,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,"Some of the methods in DefaultGroovyMethods have type information - some do not. They all should have full type information.
For example, collectMany looks good:
{code}
public static <T,E> List<T> collectMany(Iterable<E> self, @ClosureParams(FirstParam.FirstGenericType.class) Closure<Collection<? extends T>> projection) {
{code}

sum is lacking all information:
{code}
public static Object sum(Iterable self) {
{code}

The signature for sum should probably be:
{code}
public static <T> T sum(Iterable<T> self) {
{code}

min, max, and count also have this issue.",,biafab,candrews,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 11 12:28:35 UTC 2016,,,,,,,,,,"0|i2c9un:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Feb/15 17:31;candrews;Pull Request: https://github.com/groovy/groovy-core/pull/610;;;","11/Aug/16 12:28;paulk;I merged most of the remaining changes into master, so I'll close this. There are no doubt more methods still that could be improved but we can create specific issues for further work if needed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"IOGroovyMethods.withStream should use the stream type as the ClosureParam, not simply InputStream",GROOVY-7281,12816590,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,candrews,candrews,27/Jan/15 21:41,05/Apr/15 14:44,14/Jul/23 06:01,11/Mar/15 13:27,2.4.0,,,,,,,,,,,,,,,,,2.4.2,,,,groovy-jdk,,,,0,,,,,,,"IOGroovyMethods.withStream currently defines the closure parameter as InputStream. If withStream is used on a subclass of InputStream, then that type information isn't available.

Here's an example that should compile, but does not:
{code}
new ByteArrayInputStream(new byte[5]) .withStream{ final ByteArrayInputStream stream  ->
}
{code}

In IOGroovyMethods, I suggest changing the method declaration from:
{code}
public static <T> T withStream(InputStream stream, @ClosureParams(value=SimpleType.class, options=""java.io.InputStream"") Closure<T> closure) throws IOException {
{code}
to:
{code}
public static <T, U extends InputStream> T withStream(U stream, @ClosureParams(value=FirstParam.class) Closure<T> closure) throws IOException {
{code}",,candrews,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Thu Mar 12 02:41:36 UTC 2015,,,,,,,,,,"0|i2cktr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"27/Jan/15 21:55;candrews;Submitted pull request: https://github.com/groovy/groovy-core/pull/599;;;","27/Jan/15 22:45;paulk;We need to do this with a whole bunch of the DGM methods actually.

Last time we looked at it there were minor bugs with our tooling in terms of how groovydoc and entries in the groovy-jdk displayed DGM methods with such generics information. Have you had a chance to run any of the doc related gradle tasks after your change? I don't know if improvements have been made since last we checked.

It might be time to get the DGM methods fixed in any case and have the doc tool fixes follow but it would be interesting to at least know the current situation.;;;","27/Jan/15 23:58;candrews;I noticed that many of the methods in DefaultGroovyMethods are lacking generics information, and most that take closures are lacking the @ClosureParams annotations. It would be cool to fix that up, too.

I haven't run the docs - but there are other methods which do have @ClosureParams which seem to be documented correctly, such as withObjectOutputStream - so shouldn't the changes to withStream also work?;;;","28/Jan/15 01:19;melix;I think in this case it is ok, but in general we should be careful with updating methods to add generic type information because it can lead to binary breaking changes.;;;","28/Jan/15 12:12;candrews;Reported the lack of type information I saw in DefaultGroovyMethods at GROOVY-7283;;;","11/Mar/15 13:27;melix;Merged https://github.com/groovy/groovy-core/pull/599, thanks. For other updates, I think creating separate issues is better so that we can easily track them.;;;","12/Mar/15 02:41;paulk;I created some issues to track the doco tooling short-comings I mentioned above. See here: GROOVY-7339 GROOVY-7340

(I thought we might have had these covered in an existing issue but a search didn't reveal one and since it is now live in our doco, we should fix with higher importance in any case.);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
typo: 'possible loose of precision' should be 'possible loss of precision',GROOVY-7280,12811497,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,27/Jan/15 18:14,07/Apr/15 19:07,14/Jul/23 06:01,03/Feb/15 02:51,2.4.0,,,,,,,,,,,,,,,,,2.4.1,,,,,,,,0,,,,,,,,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 03 02:51:53 UTC 2015,,,,,,,,,,"0|i2bt0n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Feb/15 02:51;paulk;Proposed change: https://github.com/groovy/groovy-core/pull/598;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error caused by @CompileStatic,GROOVY-7278,12817922,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,david@carr.name,david@carr.name,27/Jan/15 14:49,23/Feb/15 01:12,14/Jul/23 06:01,17/Feb/15 14:02,2.4.0,,,,,,,,,,,,,,,,,2.4.1,,,,Static compilation,,,,0,,,,,,,"In the ratpack team, we recently upgraded from Groovy 2.3.6 to Groovy 2.4.0.  After the upgrade, we've identified a couple applications that had previously been working that now fail at runtime.  In both cases, removing @CompileStatic from a Guice module appears to work around the problem.

In one case (private application, source cannot be shared), the resulting exception was:

{code}
java.lang.NullPointerException
    at com.sun.beans.TypeResolver.resolve(TypeResolver.java:203)
    at com.sun.beans.TypeResolver.resolve(TypeResolver.java:218)
    at com.sun.beans.TypeResolver.resolve(TypeResolver.java:169)
    at com.sun.beans.TypeResolver.resolve(TypeResolver.java:218)
    at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:96)
    at java.beans.FeatureDescriptor.getParameterTypes(FeatureDescriptor.java:387)
    at java.beans.MethodDescriptor.setMethod(MethodDescriptor.java:116)
    at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:72)
    at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:56)
    at java.beans.Introspector.getTargetMethodInfo(Introspector.java:1163)
    at java.beans.Introspector.getBeanInfo(Introspector.java:426)
    at java.beans.Introspector.getBeanInfo(Introspector.java:173)
    at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:3290)
    at java.security.AccessController.doPrivileged(Native Method)
    at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:3288)
    at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:3264)
    at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:251)
    at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:282)
    at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:255)
    at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:872)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallConstructorSite(CallSiteArray.java:84)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:230)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:234)
...
{code}

In the other case, (https://github.com/ratpack/example-ratpack-gradle-groovy-app/tree/latest) the exception is:

{code}
BUG! exception in phase 'instruction selection' in source unit 'Ratpack.groovy' Type is null. Most probably you let a transform reuse existing ClassNodes with generics information, that is now used in a wrong context.
    at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:122)
    at org.codehaus.groovy.vmplugin.v5.Java5.configureTypeArguments(Java5.java:183)
    at org.codehaus.groovy.vmplugin.v5.Java5.configureParameterizedType(Java5.java:163)
    at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:114)
    at org.codehaus.groovy.vmplugin.v5.Java5.makeClassNode(Java5.java:429)
    at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:362)
    at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:262)
    at org.codehaus.groovy.ast.ClassNode.getDeclaredConstructors(ClassNode.java:483)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.findMethod(StaticTypeCheckingVisitor.java:3695)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.findMethodOrFail(StaticTypeCheckingVisitor.java:3547)
    at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.findMethodOrFail(StaticCompilationVisitor.java:316)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorCallExpression(StaticTypeCheckingVisitor.java:1848)
    at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitConstructorCallExpression(StaticCompilationVisitor.java:278)
    at org.codehaus.groovy.ast.expr.ConstructorCallExpression.visit(ConstructorCallExpression.java:44)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallArguments(StaticTypeCheckingVisitor.java:2246)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2731)
    at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:262)
    at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
    at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
    at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
    at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
    at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
    at org.codehaus.groovy.ast.CodeVisitorSupport.visitClosureExpression(CodeVisitorSupport.java:174)
{code}

To reproduce this result:

* comment out the line for the springloaded dependency in build.gradle
* run ./gradlew run
* Open a browser to http://localhost:5050
* Check the console for the stacktrace

While this appears to be a similar problem to GROOVY-7264, testing 2.4.1-SNAPSHOT and 2.5.0-SNAPSHOT seem to still have the problem.

Based on testing with ""git bisect"", it appears that the problem was first introduced in commit cd4a75c21ed44ada2b741bd822c1be5b8f4801b9 (GROOVY-7063: IllegalAccessError when calling a protected method from a closure in a sub-class).",,candrews,davidmc24,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 17 14:02:41 UTC 2015,,,,,,,,,,"0|i2ct1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jan/15 15:18;david@carr.name;To enable testing example-ratpack-gradle-groovy-app with different versions of Groovy I added a ""mavenLocal()"" repository definition and the following to the end of build.gradle:

{code}
configurations.all {
  resolutionStrategy {
    eachDependency { DependencyResolveDetails details ->
      if (details.requested.group == 'org.codehaus.groovy') {
          details.useVersion '2.4.1-SNAPSHOT'
      }
    }
  }
}
{code};;;","06/Feb/15 12:25;david@carr.name;Somewhat to my surprise, I found today that I wasn't able to reproduce this bug on the latest version of example-ratpack-gradle-groovy-app.  It's still reproducible on commit a7c0dcdc06330beec3e2d21c606b172319184152 using the steps listed above.  Not sure what the key difference is.;;;","10/Feb/15 06:54;melix;I tried to checkout a7c0dcdc06330beec3e2d21c606b172319184152 but it says fatal: reference is not a tree: a7c0dcdc06330beec3e2d21c606b172319184152

Can you point me at a commit that would highlight the problem? Thanks!;;;","17/Feb/15 13:20;david@carr.name;Okay, try here?  https://github.com/davidmc24/example-ratpack-gradle-groovy-app/tree/groovy-7278

Confirmed that for me, that particular app fails with Groovy 2.4.0.  It now appears to work with Groovy 2.4.1-SNAPSHOT.;;;","17/Feb/15 13:50;melix;Ok thanks. I suspect I already fixed the issue through GROOVY-7298 but needed to confirm it. Will try.;;;","17/Feb/15 14:02;melix;So I could confirm that this has been fixed as part of GROOVY-7298 (commit https://github.com/groovy/groovy-core/commit/2b96f4f0e48491c94e0eae17a558b712458b3c71);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TemplateResource.parse handles paths containing multiple dots incorrectly,GROOVY-7277,12812128,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,awilkinson,awilkinson,27/Jan/15 11:49,23/Feb/15 01:12,14/Jul/23 06:01,28/Jan/15 12:31,2.3.9,,,,,,,,,,,,,,,,,2.3.10,2.4.1,,,Templating,,,,0,,,,,,,"When {{TemplateResource.parse}} is passed a path that contains multiple dots the resulting resource drops the second dot and everything that follows it from the path. For example: {{foo.html.tpl}} becomes {{foo.html}}. This truncation is the cause of this bug in Spring Boot: https://github.com/spring-projects/spring-boot/issues/2212

I believe the problem can be solved by updating the regex declared in {{MarkupTemplateEngine}} to anchor the final group to the end of the string, i.e. I believe it could be a one character fix to add a {{$}} to the end of the pattern:

{noformat}
(.+?)(?:_([a-z]{2}(?:_[A-Z]{2,3})))?\\.(\\p{Alnum}+)$
{noformat}",,melix,wilkinsona,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 28 12:31:57 UTC 2015,,,,,,,,,,"0|i2cm87:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jan/15 11:52;awilkinson;I forgot to mention a couple of things. We'd like to fix this in Spring Boot 1.2.x which is using Groovy 2.3.x so a fix in that line would be greatly appreciated. I also should have said that I'd be happy to contribute a PR to fix this but would need a pointer to the tests for the current pattern so that I can add to them and check that my proposed change doesn't break anything.;;;","27/Jan/15 12:18;melix;The current resolver is covered by tests, but not directly tested (it's a shame I know...). The closest test can be found here: https://github.com/melix/groovy-core/blob/master/subprojects/groovy-templates/src/test/groovy/groovy/text/MarkupTemplateEngineTest.groovy#L868-868

But it would deserve a dedicated test. From my understanding just adding a $ to the end of the pattern will not be enough because we need the full extension (.html.tpl) and Alnum will not include the dot.;;;","28/Jan/15 10:39;awilkinson;You're right, of course. I've opened a PR with a change to the regex and a handful of tests: https://github.com/groovy/groovy-core/pull/600;;;","28/Jan/15 12:31;melix;Merged and backported to {{master}} and {{2.4.x}}. Thank you very much!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static compiler fails to eliminate dynamic property lookup,GROOVY-7276,12811491,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,blackdrag,blackdrag,26/Jan/15 08:10,23/Feb/15 01:12,14/Jul/23 06:01,17/Feb/15 09:25,,,,,,,,,,,,,,,,,,2.4.1,,,,Static compilation,,,,0,,,,,,,"{code:Java}
class Foo {
    private i = 1
    @groovy.transform.CompileStatic
    def m() { new String().with {i}}
}
assert new Foo().m() == 1
class Bar extends Foo {}
assert new Bar().m() == 1{code}
For this code the static compiler is supposed to create a bridge method in Foo and provide access to the private field ""i"" through that, as well as calling the method directly from within the with-block.  Instead the compiler works using dynamic property access, which will cause the property not being found in the second assert because of MOP limitations",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7304,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-01-26 08:10:27.0,,,,,,,,,,"0|i2cp9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"SelfType class ""was not matched with found receiver"" trait",GROOVY-7275,12811498,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,msgilligan,msgilligan,25/Jan/15 02:04,23/Feb/15 01:12,14/Jul/23 06:01,10/Feb/15 09:52,2.4.0,,,,,,,,,,,,,,,,,2.4.1,,,,Compiler,Static compilation,,,0,,,,,,,"I'm trying to compile a Trait that uses:
{code}
@SelfType(BitcoinClient)
@CompileStatic
trait BitcoinCLIAPI {
}
{code}
And getting the error message: 
{code}
BUG! exception in phase 'instruction selection' in source unit '/Users/sean/git/bitcoin-spock/src/main/groovy/com/msgilligan/bitcoin/rpc/BitcoinCLIAPI.groovy' Declaring class for method call to 'java.util.Map getTransaction(com.google.bitcoin.core.Sha256Hash)' declared in com.msgilligan.bitcoin.rpc.BitcoinClient was not matched with found receiver <UnionTypecom.msgilligan.bitcoin.rpc.BitcoinClient+com.msgilligan.bitcoin.rpc.BitcoinCLIAPI>. This should not have happened!
{code}
The source code is available in this Github commit:
https://github.com/msgilligan/bitcoin-spock/commit/7426210641e6a33bf9a4ad38b1dcd6fa00142cfd

You'll need to uncomment lines 18 & 19 of BitcoinCLIAPI.groovy to reproduce the bug.

Compile with Gradle: gradle compileGroovy 

Full error output is attached.

","Mac OS X, JDK 1.7 or 1.8
",msgilligan,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"25/Jan/15 02:04;msgilligan;build_err.out;https://issues.apache.org/jira/secure/attachment/12723224/build_err.out",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-01-25 02:04:59.0,,,,,,,,,,"0|i2bqk7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
:doc command checks wrong api urls,GROOVY-7273,12813338,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,mage,mage,23/Jan/15 11:40,23/Feb/15 01:12,14/Jul/23 06:01,23/Jan/15 16:15,2.3.9,2.4.0,,,,,,,,,,,,,,,,2.3.10,2.4.1,,,Groovysh,,,,0,,,,,,,"To identify url for class documentation :doc command sends HEAD request to http://docs.oracle.com/javase/1.8.0/docs/api/. Wich results in 404 cause simpleVersion() evaluates to 1.8.0 on jdk 8. However, current urls for jdk documentation starts with http://docs.oracle.com/javase/8/docs/api/. Unit tests missed that completely, because they aren't issueing actual HTTP request.",Windows 8 JDK 8,mage,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jan 24 13:15:43 UTC 2015,,,,,,,,,,"0|i2cgen:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jan/15 16:15;pschumacher;Thanks for reporting.;;;","24/Jan/15 00:58;mage;Welcome, wanted to fix that myself, but you beat me to it;;;","24/Jan/15 03:45;pschumacher;Sorry about that :(. Next time just mention in the issue that you will fix it.;;;","24/Jan/15 13:15;mage;Just checked it today on master branch, yay, it finally works! Thanks a lot!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With MetaMethods and replacing MetaProperty,GROOVY-7269,12811495,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,23/Jan/15 09:52,23/Feb/15 01:12,14/Jul/23 06:01,13/Feb/15 04:26,2.3.9,2.4.0,,,,,,,,,,,,,,,,2.3.10,2.4.1,,,,,,,0,,,,,,,"The attached readonlyproperty.zip contains the following:

{code:borderStyle=solid|title=src/main/groovy/demo/SomeTrait.groovy}
package demo

trait SomeTrait {
    String title
}
{code}

{code:borderStyle=solid|title=src/test/groovy/demo/SomeTraitSpec.groovy}
package demo

import spock.lang.Specification

class SomeTraitSpec extends Specification {

    void 'test property access'() {
        given:
        Widget.metaClass.getTitle = {
            'Some Default Title'
        }
        def w = new Widget()

        when:
        w.title = 'Some New Title'

        then:
        w.title == 'Some Default Title'
    }
}

class Widget implements SomeTrait {}
{code}

That test will fail with the following:

{noformat}
groovy.lang.ReadOnlyPropertyException: Cannot set readonly property: title for class: demo.Widget
    at demo.SomeTraitSpec.test property access(SomeTraitSpec.groovy:15)
{noformat}

If the trait is removed from the equation and the title property is declared directly in the Widget class then the test passes.
",,brownj,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7308,,,,,,"23/Jan/15 09:52;brownj;readonlyproperty.zip;https://issues.apache.org/jira/secure/attachment/12723258/readonlyproperty.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 11 08:54:47 UTC 2015,,,,,,,,,,"0|i2bzn3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Feb/15 04:34;melix;The problem is actually not on traits. The following code has the very same issue and doesn't involve any trait:

{code}
interface SomeIntf {
    String getTitle()
    void setTitle(String title)
}

class Widget implements SomeIntf {
    private String _title;
    String getTitle() { _title }
    void setTitle(String title) {_title=title}
}

Widget.metaClass.getTitle = {
    'Some Default Title'
}
def w = new Widget()
w.title = 'Some New Title'
assert w.title == 'Some Default Title'
{code}

Will fail with:

{noformat}
groovy.lang.ReadOnlyPropertyException: Cannot set readonly property: title for class: Widget
	at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:2715)
{noformat}

If you change the name of the backing field from {{_title}} to {{title}}, then the test passes, hinting at a bug in the way the metaclass resolves meta properties.;;;","11/Feb/15 08:54;melix;I have submitted a PR: https://github.com/groovy/groovy-core/pull/606

Not 100% sure this is the best way to fix this, but it does the trick.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
avoid hashcode based equality check without equals,GROOVY-7267,12817960,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,23/Jan/15 05:40,24/Sep/15 20:23,14/Jul/23 06:01,23/Jan/15 06:37,,,,,,,,,,,,,,,,,,2.3.10,2.4.1,,,groovy-jdk,,,,0,,,,,,,"This is a follow-up issue on GROOVY-4101  and GROOVY-4124. I think there was a misunderstanding back then. Basically this code{code:Java}assert ([[1:2],[2:3]]-[[""b"":""a""]]) == [[1:2],[2:3]]{code} can fail, because of the path that is taken with NumberAwareComperator. The hashcodes of the minus element first list entry and the hashcode of the source list first element are equal. Since they are both lists DefaultTypeTransformation.compareTo will fail and the hashcode equality is then used to decide that [1:2] is to be removed. This makes not really sense, thus the issue is for the removal of the equality case",,blackdrag,lari.hotari@sagire.fi,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 24 20:23:49 UTC 2015,,,,,,,,,,"0|i2c3u7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jan/15 06:37;blackdrag;fixed;;;","24/Sep/15 20:23;lari.hotari@sagire.fi;this change might have caused GROOVY-7602;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompilationFailedException can be swallowed,GROOVY-7266,12811484,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,23/Jan/15 03:56,23/Feb/15 01:12,14/Jul/23 06:01,23/Jan/15 03:59,2.3.9,2.4.0,,,,,,,,,,,,,,,,2.3.10,2.4.1,,,Compiler,,,,0,,,,,,,See https://github.com/groovy/groovy-core/pull/593,,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 23 03:59:14 UTC 2015,,,,,,,,,,"0|i2caan:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jan/15 03:59;melix;I have merged the PR and backported it in 2.3.10 and 2.4.1. However, the thing is that should not happen, so even if it gives a bit more information, this should really never happen so it would be nice to have some test case that triggers this exception.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE in TypeResolver when access$XXX method generated for a method with generic types,GROOVY-7264,12811480,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,22/Jan/15 03:06,23/Feb/15 01:12,14/Jul/23 06:01,22/Jan/15 03:14,2.3.9,2.4.0,,,,,,,,,,,,,,,,2.3.10,2.4.1,,,Static compilation,,,,0,,,,,,,"If a bridge method is generated for a method that uses generic types defined in a super class or interface, then the compilation will succeed, but trying to use the generated class will fail with a NPE in TypeResover.

For example:

{code}
public class BaseGeneric<T> {
        protected boolean foo(T t) {
            true
        }
}

// ...

@groovy.transform.CompileStatic
class Ext extends BaseGeneric<Integer> {

    int doSomething() {
        def c = {
            foo(123) // a bridge method is generated (access$...)
        }
        c.call()?1:0
    }
}
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-01-22 03:06:13.0,,,,,,,,,,"0|i2bns7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Static Imports,GROOVY-7263,12811494,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,brownj,brownj,21/Jan/15 20:13,23/Feb/15 01:12,14/Jul/23 06:01,31/Jan/15 03:51,2.4.0,2.4.0-rc-1,2.4.0-rc-2,,,,,,,,,,,,,,,2.4.1,,,,Compiler,,,,0,,,,,,,"The attached staticimport.zip contains the following:

{code:borderStyle=solid|title=src/main/groovy/demo/util/Helper.java}
package demo.util;

public abstract class Helper {
    public static class Foo {}
}
{code}

{code:borderStyle=solid|title=src/main/groovy/demo/Demo.groovy}
package demo

import demo.util.Helper
import static demo.util.Helper.*

class Demo extends Helper {
    Foo foo
}
{code}

The code will not compile with Groovy 2.4.0-rc-1, 2.4.0-rc-2 or 2.4.0.

{noformat}
$ ./gradlew clean cG
:clean
:compileJava UP-TO-DATE
:compileGroovy
startup failed:
/Users/jeff/staticimport/src/main/groovy/demo/Demo.groovy: 7: unable to resolve class Foo 
 @ line 7, column 5.
       Foo foo
       ^

1 error

:compileGroovy FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileGroovy'.
> Compilation failed; see the compiler error output for details.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 4.257 secs
staticimport master $
{noformat}

If I edit build.gradle and change the Groovy version to 2.3.9 then the code will compile.  Also, the problem doesn't appear to happen if Demo does not extend Helper.
",,brownj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/Jan/15 20:13;brownj;staticimport.zip;https://issues.apache.org/jira/secure/attachment/12723195/staticimport.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-01-21 20:13:27.0,,,,,,,,,,"0|i2c0dr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
There should be a TimeZone variant of the Date#parse method in DGSM,GROOVY-7262,12817984,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,21/Jan/15 05:54,07/Apr/15 19:07,14/Jul/23 06:01,24/Jan/15 19:30,,,,,,,,,,,,,,,,,,2.4.1,,,,,,,,0,,,,,,,,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-01-21 05:54:48.0,,,,,,,,,,"0|i2c7dj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Lazy should work in combination with @Delegate,GROOVY-7261,12818321,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,21/Jan/15 02:24,07/Apr/15 19:06,14/Jul/23 06:01,21/Jan/15 05:51,,,,,,,,,,,,,,,,,,2.4.1,,,,,,,,0,,,,,,,"@Delegate uses the delegate field directly but that won't have been set if also using @Lazy. We might eventually allow this to be customizable, e.g. with a flag like 'direct = false' or 'forceDirect' or 'useDelegateField', but for now we should at least just fix the common case.

Expected behavior:
{code}
class Foo {
  private @Delegate @Lazy ArrayList list = ['bar', 'baz']
  // fragile: $list is an internal implementation detail that may change
  def getInternalDelegate() { $list }
}

def f = new Foo()
assert f.internalDelegate == null
assert f.size() == 2
assert f.internalDelegate == ['bar', 'baz']
{code}",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 21 05:52:18 UTC 2015,,,,,,,,,,"0|i2c1s7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jan/15 05:51;paulk;proposed fix:
https://github.com/groovy/groovy-core/pull/590;;;","21/Jan/15 05:52;paulk;fix applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc only considers package level fields as properties even if you have a get and set methods declared,GROOVY-7259,12811481,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,pascalschumacher,tygerpatch,tygerpatch,17/Jan/15 08:57,02/May/17 02:03,14/Jul/23 06:01,15/Jan/16 20:45,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,GroovyDoc,,,,0,,,,,,,"You can declare a property in Groovy using get and set methods.

{code:title=Klass.groovy|borderStyle=solid}
public class Klass {
  public String getStr() {
      System.out.println(""called getName( )"");
      return """";
  }

  public void setStr(String str) {
      System.out.println(""called setStr(String str = ${str})"");
  }

  public static void main(String... args) {
    Klass klass = new Klass();

    // called setStr(String str = Salut le monde)
    klass.str = ""Salut le monde"";
 
    println(klass.str); // called getName( )
  }
}
{code}
groovydoc, however, only considers package level fields as properties",,githubbot,pascalschumacher,tygerpatch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 15 20:45:07 UTC 2016,,,,,,,,,,"0|i2bwlj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Apr/15 13:59;githubbot;GitHub user antoaravinth opened a pull request:

    https://github.com/apache/incubator-groovy/pull/3

    Bug Fix for GROOVY-7259

    Bug fix for the issue:
    
    https://jira.codehaus.org/browse/GROOVY-7259?jql=project%20%3D%20GROOVY%20AND%20resolution%20%3D%20Unresolved%20AND%20priority%20%3D%20Trivial%20ORDER%20BY%20key%20DESC
    
    And my first PR in incubator-groovy :)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/antoaravinth/incubator-groovy GROOVY-7259

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/3.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #3
    
----
commit 64432162251aaa31122fe95d56416fec53efc7b7
Author: Anto <anto.aravinth.cse@gmail.com>
Date:   2015-04-20T13:57:38Z

    Bug Fix for GROOVY-7259

----
;;;","15/Jan/16 20:42;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/3
;;;","15/Jan/16 20:45;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With @CompileStatic And Static Trait Members,GROOVY-7255,12811502,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,14/Jan/15 18:12,23/Feb/15 01:12,14/Jul/23 06:01,15/Jan/15 06:01,2.4.0-rc-2,,,,,,,,,,,,,,,,,2.4.1,,,,,,,,0,,,,,,,"{code:title=SomeTrait.groovy|borderStyle=solid}
@groovy.transform.CompileStatic
trait SomeTrait {
    static List stuff

    static void initStuff(List l) {
        stuff = l
    }
}
{code}

{noformat}
$ groovy -version
Groovy Version: 2.4.0-rc-2 JVM: 1.7.0_45 Vendor: Oracle Corporation OS: Mac OS X
$ 
grv $ groovyc SomeTrait.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
SomeTrait.groovy: 6: [Static type checking] - Cannot find matching method SomeTrait#SomeTrait__stuff$set(java.util.List). Please check if the declared type is right and if the method exists.
 @ line 6, column 9.
           stuff = l
           ^

1 error

$
{noformat}

If I remove the @CompileStatic the code runs and does what I expect it to do.",,brownj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7191,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2015-01-14 18:12:40.0,,,,,,,,,,"0|i2ck2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Integer literal not accepted for primitive short annotation attribute,GROOVY-7252,12811522,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,wavyx,wavyx,14/Jan/15 05:43,23/Jul/22 21:05,14/Jul/23 06:01,06/Jul/22 22:51,2.3.9,,,,,,,,,,,,,,,,,4.0.4,,,,Compiler,,,,1,annotations,,,,,,"This is a follow-up of GROOVY-6019

Regarding this PR https://github.com/groovy/groovy-core/pull/143
I'm trying to use spring-data-elasticsearch annotations
{code:title=Document.java}
@Persistent
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface Document {
	String indexName();
	String type() default """";
	short shards() default 5;
	short replicas() default 1;
	String refreshInterval() default ""1s"";
	String indexStoreType() default ""fs"";
}
{code}

Using groovy 2.3.9 and java 1.8.0_25 with this annotation:
{code}
@Document(indexName = ""articles"", type = ""article"", shards = 1, replicas = 0, refreshInterval = ""-1"", indexStoreType = ""memory"")
{code}
I get the following errors:
Error:(13, 62) Groovyc: Attribute 'shards' should have type 'java.lang.Short'; but found type 'int' in @org.springframework.data.elasticsearch.annotations.Document
Error:(13, 76) Groovyc: Attribute 'replicas' should have type 'java.lang.Short'; but found type 'int' in @org.springframework.data.elasticsearch.annotations.Document

Could this be a regression?",,blackdrag,emilles,wavyx,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-9206,GROOVY-9205,GROOVY-9366,,GROOVY-6025,GROOVY-10068,GROOVY-6019,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 06 22:51:38 UTC 2022,,,,,,,,,,"0|i2cjcf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jul/22 22:51;emilles;https://github.com/apache/groovy/commit/5fe6fbc7dfef4df52fff6cf96a95b6d46d4fbf3c;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MissingPropertyException: No such property in finally block,GROOVY-7248,12817937,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,neeme,neeme,12/Jan/15 06:35,15/Jun/17 14:23,14/Jul/23 06:01,09/Mar/17 13:54,2.3.9,2.4.1,,,,,,,,,,,,,,,,2.4.10,,,,,,,,0,,,,,,,"Given the following Groovy program:
{code}
class Test {
  void run() {
    long start = 0;
    try {
      throw new Exception(""fail!"");
    }
    finally {
      long end = 0;
      long time = end - start;
    }
  }
}
new Test().run();
{code}

I would expect to see the following output:
{code}
java.lang.Exception: fail!
	at Test.run(ConsoleScript1:5)
	at Test$run.call(Unknown Source)
	at ConsoleScript1.run(ConsoleScript1:13)
{code}

However, instead, I see:
{code}
groovy.lang.MissingPropertyException: No such property: time for class: Test
	at Test.run(ConsoleScript1:9)
	at Test$run.call(Unknown Source)
	at ConsoleScript1.run(ConsoleScript1:13)
{code}

If I change the script to the following:
{code}
class Test {
  void run() {
    long start = 0;
    try {
      throw new Exception(""fail!"");
    }
    finally {
      def end = 0;
      long time = end - start;
    }
  }
}
new Test().run();
{code}

I get the expected output. Seems like a bug.","Groovy Version: 2.3.9
JVM: 1.8.0_20 Vendor: Oracle Corporation
OS: Mac OS X",githubbot,jwagenleitner,neeme,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/Jan/15 09:33;neeme;Groovy7248Bug.groovy;https://issues.apache.org/jira/secure/attachment/12723276/Groovy7248Bug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 09 13:54:06 UTC 2017,,,,,,,,,,"0|i2c0zz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"12/Jan/15 13:16;shils;Adding the @CompileStatic annotation to the Test class also results in the expected output, i.e.
{code}
Caught: java.lang.Exception: fail!
java.lang.Exception: fail!
	at Test.run(ATest.groovy:8)
	at Test$run.call(Unknown Source)
	at ATest.run(ATest.groovy:16)
{code}

Here I've run the original code (with the additional annotation) in a script named ATest.groovy.
;;;","20/Feb/17 20:24;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/501

    GROOVY-7248: MissingPropertyException: No such property in finally block

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy groovy7248

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/501.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #501
    
----
commit 52e6a5b435651050d978260381496530b79eab1d
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-02-20T15:52:13Z

    GROOVY-7248: MissingPropertyException: No such property in finally block

----
;;;","09/Mar/17 13:20;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/501
;;;","09/Mar/17 13:54;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
spreadMap type inference is incorrect and STC reports on valid code,GROOVY-7247,12811472,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,uehaj,uehaj,12/Jan/15 03:32,10/Feb/23 21:40,14/Jul/23 06:01,18/Aug/22 19:18,,,,,,,,,,,,,,,,,,2.5.19,3.0.13,4.0.5,,Static Type Checker,,,,1,,,,,,,"STC reports false error on spreadMap operation:
{code}
@groovy.transform.TypeChecked
def f() {
    Map<String, Integer> map1 = [ *:[A:1], *:[B:2]] // [Static type checking] - Incompatible generic argument types. Cannot assign java.util.LinkedHashMap <java.util.Map, java.util.LinkedHashMap> to: java.util.Map <String, Integer>
    assert map1  == [A:1, B:2]
    println map1

    Map<String, Integer> submap1 = [A: 1]
    Map<String, Integer> submap2 = [B: 2]
    Map<String, Integer> map2 = [*:submap1, *:submap2] // [Static type checking] - Incompatible generic argument types. Cannot assign java.util.LinkedHashMap <java.util.Map, java.util.LinkedHashMap> to: java.util.Map <String, Integer>
    assert map2  == [A:1, B:2]
    println map2
}

f()

{code}
",,emilles,uehaj,werickson,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 18 19:18:56 UTC 2022,,,,,,,,,,"0|i2c8zb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Aug/22 19:18;emilles;https://github.com/apache/groovy/commit/437bf26c8e9ba9861aed6bd57cf1f0f6dd70b6c5;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Access modifiers behave differently in Groovy when compared to Java.,GROOVY-7246,12811488,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,tygerpatch,tygerpatch,11/Jan/15 08:30,21/Jan/15 15:26,14/Jul/23 06:01,12/Jan/15 14:18,2.3.9,,,,,,,,,,,,,,,,,2.3.9,,,,,,,,0,usertask,,,,,,"I know there's already been several JIRA tickets that have been created concerning how private fields and methods aren't really private in Groovy.

See Also: [GROOVY-3010|https://jira.codehaus.org/browse/GROOVY-3010]

But it seems like Groovy doesn't respect the access restrictions of _any_ of the access modifiers. Last year I did a blog post on [Java's access modifiers|http://toddgerspacher.blogspot.com/2014/08/java-access-modifier.html] and recently I did the same experiment but with Groovy this time. I've listed below all the classes that I used. I only changed the access modifiers for the name field and speak method of the Earthling class.

{code:title=Earthling.groovy|borderStyle}
package Earth;

// access modifiers will be changed for this class
public class Earthling {
   public String name = ""Bob"";
 
   public void speak() {
      System.out.println(""Hello."");
   }
}
{code}
{code:title=Man.groovy|borderStyle}
package Earth;

// subclass, same package
public class Man extends Earthling {
   public Man() {
      System.out.println(""name = "" + name);
      speak();
   }
 
   public static void main(String[] args) {
      new Man();
   }
}
{code}
{code:title=Dog.groovy|borderStyle}
package Earth;

// non-subclass, same package 
public class Dog {
   public Dog() {
      Earthling earthling = new Earthling();
      System.out.println(""earthling.name = "" + earthling.name);
      earthling.speak();
   }
 
   public static void main(String[] args) {
      new Dog();
   }
}
{code}
{code:title=Explorer.groovy|borderStyle}
package Mars;
 
import Earth.Earthling;

// subclass, different package
public class Explorer extends Earthling {
   public Explorer() {
      System.out.println(""name = "" + name);
      speak();
   }
 
   public static void main(String[] args) {
      new Explorer();
   }
}
{code}
{code:title=Martian.groovy|borderStyle}
package Mars;
 
import Earth.Earthling;

// non-subclass, different package
public class Martian {
   public Martian() {
      Earthling earthling = new Earthling();
      System.out.println(""earthling.name = "" + earthling.name);
      earthling.speak();
   }
 
   public static void main(String[] args) {
      new Martian();
   }
}
{code}

When I did this little experiment in Java, I got the following results. The cells marked with 'J' indicates when I was able to access Earthling's name field and speak method. 

|| ||public||protected||(no modifier)||private||
|*Subclass, Same Package*|J|J|J| |
|*Non-Subclass, Same Package*|J|J|J| |
|*Subclass, Different Package*|J|J| | |
|*Non-Subclass, Different Package*|J| | | |

When I did the same thing in Groovy, however, I got much different results. Note I've marked the cells with 'G' this time.

|| ||public||protected||(no modifier)||private||
|*Subclass, Same Package*|G|G|G|throws exception|
|*Non-Subclass, Same Package*|G|G|G|G|
|*Subclass, Different Package*|G|G|G|throws exception|
|*Non-Subclass, Different Package*|G|G|G|G|

You'll notice that pretty much every class can access everything. The only issues occur when you use the private access modifier and you try to access the field or method from a subclass. But instead of throwing a compiler error, like Java does, Groovy throws runtime exceptions. Specifically,

{code}
groovy.lang.MissingPropertyException: No such property: name
{code}

And if you comment out the statement that references the name field...

{code:title=Man.groovy|borderStyle}
package Earth;

// subclass, same package
public class Man extends Earthling {
   public Man() {
      // System.out.println(""name = "" + name);
      speak();
   }
 
   public static void main(String[] args) {
      new Man();
   }
}
{code}

...you'll get a different exception.

{code}
groovy.lang.MissingMethodException: No signature of method: Earth.Man.speak
{code}
",64-bit Windows 7,blackdrag,tygerpatch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 21 05:27:25 UTC 2015,,,,,,,,,,"0|i2c2mv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Jan/15 12:59;blackdrag;You actually forgot, that there are 4 modifiers, the forth being package private, which is initiated by not using one of public, protected or private.

The access rules as they are in Groovy atm are easy. All but private is the same as far as Groovy is concerned. They are not exactly the same, since the modifiers are still written like that, but that's a different story. 

Private means it is not visible in a subclass. For example having a class A with a private field f and a subclass B accessing that field will result in a runtime error... That you found of course already. But also a class C accessing the field f fails if the instance the access is done for is a B. If done with an instance with the runtime class A, then it works. In other words, private restricts the access to a field or method to the class it was declared in.

This is of course different than Java.

As for not giving compile time errors... If you want those, use @CompileStatic, which is more strict. Normal Groovy is a dynamic language and as such tends to fail at runtime, because it is entirely possible to dynamically add a property of that name during runtime. Besides that, since the failure for private depends on the runtime type, there is no static type checking for this possible, unless you restrict this further... which is what @CompileStatic does and which actually only makes sense with @CompileStatic;;;","12/Jan/15 07:18;tygerpatch;Thanks for replying, but I still think this is a bug. I'm not doing anything outside of normal Java code. So I shouldn't need to use the [@CompileStatic|http://beta.groovy-lang.org/docs/latest/html/gapi/groovy/transform/CompileStatic.html] annotation. (I'll make an exception for fields that aren't marked with an access modifier as Groovy turns these into properties giving them public get and set methods. It should still complain when trying to access the method though.)  It also doesn't make any sense that the only time I cannot access a field or method is when the private keyword is used and a subclass is trying to access it. I can access the item using a different class in a different package though.

I didn't forget the ""package private"" modifier. I just didn't label it as such. I think saying ""(no modifier)"" is more clear than ""package private"". You also can't actually mark a field or method as package private as the keyword package is used for something else entirely.

Here are the results when I put the @CompileStatic annotation on everything but the Earth.Earthling class.

|| |*package*|*protected*|*(no modifier)*|*private*|
|*Subclass, Same Package*|O|O|O|mix|
|*Non-Subclass, Same Package*|O|O|O|compiler error|
|*Subclass, Different Package*|O|O|O|mix|
|*Non-Subclass, Different Package*|O|throws exception|O|compiler error|

Note: The cells marked ""mix"" in the above table indicates that Groovy both issued a compiler error (for accessing the speak( ) method) and threw an exception (for accessing the name field).

Again, when no access modifier is used I shouldn't be able to access the speak( ) method.;;;","12/Jan/15 09:01;blackdrag;firstly, I am sorry I overlooked the fact that the ""no modifier"" part is not missing... Shouldn't do such comments in the middle of the night I guess ;)

But that you are not doing anything outside of normal Java code is not right... you use Groovy and Groovy is not normal Java. They behave very similar in many cases and in almost all cases that are really important, but they are not the same and have diverging semantics.

""It also doesn't make any sense that the only time I cannot access a field or method is when the private keyword is used and a subclass is trying to access it. I can access the item using a different class in a different package though.""
That's based on your Java view, which has those 4 different access ways. Groovy here is more like for example Ruby and effectively knows only private and public... but its own interpretation of it. In that anything that is not private is seen as if public. And private means the member is accessible only from the same static class using the same runtime class. So of course a subclass can access the private field from a super class, just not in its declared class and only on another instance that has the super class as runtime type. The runtime type being correct is the requirement here. And it as long as the static class is not the same as the runtime class it does not matter from what package the access comes or from what class loader. The static compiler does almost the same as dynamic Groovy here, only that it is a tad more strict about the private access.

BTW, one thing you may have is missed is, that in Groovy using no modifier results in public being used. To force the usage of package private you have to use the transform @PackageScope.


But anyway.... what exactly is your point I am wondering... That Groovy does not behave exactly as Java?;;;","12/Jan/15 14:14;tygerpatch;You're absolutely right. Saying that I wasn't doing anything outside of normal Java was a poor choice of words. Groovy is not Java. Again, my apologies as I did not see that my concerns had already been addressed in the documentation:

""Currently Groovy doesn't distinguish properly between public, private, and protected members.."" (taken from Groovy's [""Things you can do but better leave undone""|http://groovy.codehaus.org/Things+you+can+do+but+better+leave+undone])

And, as you already pointed out:

""By default, Groovy considers classes and methods 'public'."" (taken from Groovy's [""Groovy style and language feature guidelines for Java developers""|http://groovy.codehaus.org/Groovy+style+and+language+feature+guidelines+for+Java+developers])

Something else that I had missed:

""By default, Groovy automatically turns package protected fields into properties and makes package protected methods and classes public."" (taken from [API docs for @PackageScope|http://beta.groovy-lang.org/docs/latest/html/gapi/groovy/transform/PackageScope.html])

I still don't understand why a subclass can't access a private member but a non-subclass can, but I think enough people have raised concerns about this issue. (See [GROOVY-3010|https://jira.codehaus.org/browse/GROOVY-3010]) Therefore I'd like to close this ticket as most of my concerns have been answered. Thanks for taking the time to address them.;;;","12/Jan/15 14:18;tygerpatch;Just a silly misunderstanding from a Java programmer trying to transfer his knowledge over to Groovy.;;;","12/Jan/15 15:51;blackdrag;not silly, don't worry... as for the private field... maybe it becomes more clear with an example...
{code:Java}
class A { 
  private foo 
  public m() {foo}
}
class B extends A{}

def test1(x) { x.foo }
test1(new A()) // works
test1(new B()) // fails

def test2(x)  { x.m() }
test2(new A()) // works
test2(new B()) // works
{code}
There is one very ugly case that works in Java but not in Groovy:
class A { 
  private foo 
  boolean equals(o) {
    if (o instanceof A) {
      A other = o
      return other.foo==foo
    }
    return false
  }
class B extends A{}
new A().equals(new B()) // fails with exception
{code}
In Java this kind of code is quite common for an equals method, but t will fail with a MissingPropertyException in Groovy. But this can be worked around by using @CompileStatic.

As for why private is as it is... originally (before 1.0) Groovy did ignore all modifiers. This was the case for 2 reasons... (1) it makes testing code more easy to be able to access private members (2) it is difficult to do an efficient runtime check for Java like access rules. But since a minimal level of encapsulation is useful, we changed it to the current logic. Doing checks at compile time using the declared type did not make so much sense back then, since most code was written untyped and to just type to get this right seemed to be wrong. Also in the light of a meta class of a class always being able to gain a property at any time, it makes no sense to forbid here at compile time. @CompileStatic is different since code under that influence works outside of the MOP and thus ignores runtime added properties completely. 
;;;","21/Jan/15 05:27;tygerpatch;Suppose I have the following Groovy class:
{code:title=Groovy.groovy|borderStyle}
public class GKlass {
  void PackageAccessMethod() {
  }

  String PackageAccessField;
}
{code}
I then try to access that field from a Java class:
{code:title=JKlass.java|borderStyle}
public class JKlass {
   public  static void main(String... args) {
      GKlass klass = new GKlass();

      klass.PackageAccessField = """";
   }
}
{code}
Why does Java complain that the field has private access? This happens even when I annotate the field with the @PackageScope annotation. It does not happen, though, with methods that have package access (ie PackageAccessMethod( )).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"@Delegate does not honor ""includes"" on properties - all properties are delegated",GROOVY-7243,12812855,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,greg.ratliff,greg.ratliff,10/Jan/15 21:42,05/Apr/15 14:44,14/Jul/23 06:01,18/Feb/15 03:35,2.4.0-rc-2,,,,,,,,,,,,,,,,,2.4.1,,,,xforms,,,,0,,,,,,,"The @Delegate documentation states that the ""includes"" element is a

""List of method and/or property names to include when delegating.""

However, the ""includes"" does not affect the delegating of property getters and setters.  All properties from the delegate are currently delegated regardless of their inclusion in the ""includes"" element.

Expected: When the includes element is provided on the @Delegate attribute, only the properties specified are delegated.",All,greg.ratliff,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Jan/15 21:42;greg.ratliff;DelegatePropertiesTest.groovy;https://issues.apache.org/jira/secure/attachment/12723270/DelegatePropertiesTest.groovy","11/Jan/15 00:08;greg.ratliff;delegate-properties.patch;https://issues.apache.org/jira/secure/attachment/12723193/delegate-properties.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Thu Feb 12 06:46:06 UTC 2015,,,,,,,,,,"0|i2c53z:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Jan/15 00:08;greg.ratliff;A patch that fixes the problem.;;;","27/Jan/15 16:11;pschumacher;@Greg Ratliff: Thanks for the contribution. :)

It would be very nice if you could create a pull request for this. If this is to much bother just let me know and I will convert your patch to a pull request.;;;","12/Feb/15 06:46;pschumacher;I converted the patch by Greg Ratliff to a [pull request|https://github.com/groovy/groovy-core/pull/607].;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
calling trait method inside closure causes compiler error when CompileStatic is used,GROOVY-7242,12817885,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,wwwreynolds,wwwreynolds,09/Jan/15 16:19,11/Jun/20 18:55,14/Jul/23 06:01,06/Mar/15 14:35,2.3.9,2.4.1,,,,,,,,,,,,,,,,2.4.2,,,,Static compilation,,,,0,,,,,,,"Calling f2() within the each closure causes compiler error.

{code}
@groovy.transform.CompileStatic
trait MyTrait {
    def f() {
        ['a'].each {f2()}
    }

    def f2() {
        true
    }
}
{code}","JDK: 1.7, O/S: windows",wwwreynolds,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-9586,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 09 16:20:39 UTC 2015,,,,,,,,,,"0|i2bp2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jan/15 16:20;wwwreynolds;A workaround is to invoke the method as a closure:
{code}
...
        ['a'].each {this.&f2()}
...
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unable to start dollar slashy strings with an escaped dollar,GROOVY-7240,12811399,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,martiuk,martiuk,08/Jan/15 10:18,23/Feb/15 01:12,14/Jul/23 06:01,09/Jan/15 03:44,1.8.6,1.8.9,2.3.9,,,,,,,,,,,,,,,2.4.1,,,,,,,,0,,,,,,,"If a dollar slashy string starts with an escaped dollar e.g.
{code}
println($/$$VAR='Hello World'/$)
{code}
You'll receive the exception:
{code}
Caught: groovy.lang.MissingPropertyException: No such property: VAR for class: ...
{code}
The only way round this is to add a space to separate the first $ from the slash.
{code}
println($/ $$VAR='Hello World'/$)
{code}","Ubuntu via apt (1.8.6)
Built-In with Jenkins on Ubuntu (1.8.9)
Ubuntu via GVM (2.3.9)",martiuk,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 09 03:44:34 UTC 2015,,,,,,,,,,"0|i2cbbr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Jan/15 10:18;martiuk;Apologies if I've reported this the completely wrong way!;;;","08/Jan/15 17:48;paulk;I presume this is a limitation/bug in the current grammar. Having a look in the Groovy console:
{{$/ $$VAR='Hello World'/$}} is being parsed correctly but:
{{$/$$VAR='Hello World'/$}} is being incorrectly parsed into a GString with these components: constant('$'), variable(VAR), constant(""='Hello World'"")
;;;","08/Jan/15 19:59;paulk;Proposed fix:
https://github.com/groovy/groovy-core/pull/585

Well spotted. The $$ and $/ escaping was never working in the first character position of a dollar slashy string and I guess we never had a test for that edge case.;;;","09/Jan/15 03:44;paulk;PR merged.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot create a closure referencing a method of anonymous inner class.,GROOVY-7236,12811475,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,vmihaylov,vmihaylov,02/Jan/15 09:24,08/Mar/22 12:16,14/Jul/23 06:01,29/Oct/21 21:25,2.3.7,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,,"When running this code:
{code}
        http.setParserRegistry(new ParserRegistry() {
            @Override
            protected Map buildDefaultParserMap() {
                def parsers = super.buildDefaultParserMap();
                parsers.put(""application/hal+json"", new MethodClosure(this, ""parseJSON""))
                return parsers
            }
        });
{code}
I get:

{code}
java.lang.IllegalArgumentException: object is not an instance of declaring class
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1207)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1074)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1016)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure.call(Closure.java:439)
	at groovyx.net.http.HTTPBuilder.parseResponse(HTTPBuilder.java:551)
	at groovyx.net.http.HTTPBuilder$1.handleResponse(HTTPBuilder.java:480)
{code}

However if I create a separate class like this: 
{code}
class MyParserRegistry extends ParserRegistry {
    @Override
    protected Map<String, Closure> buildDefaultParserMap() {
        Map parsers = super.buildDefaultParserMap();
        parsers.put(""application/hal+json"", new MethodClosure(this, ""parseJSON""));
        return parsers;
    }
}
{code}
and then invoke:
{code}
http.setParserRegistry(new MyParserRegistry())
{code}
everything works fine.",Ubuntu linux ,emilles,pschumacher,vmihaylov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"02/Mar/15 05:52;vmihaylov;HTTPTest.groovy;https://issues.apache.org/jira/secure/attachment/12723158/HTTPTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 11 18:28:26 UTC 2019,,,,,,,,,,"0|i2cmwf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"01/Mar/15 07:43;pschumacher;Hi Vassil, thanks for reporting. Can you post a self-containted example which allows us to replicate this?;;;","02/Mar/15 05:52;vmihaylov;Run the attachement  by invoking 
groovy HTTPTest.groovy listen-port;;;","11/Sep/19 18:28;emilles;This is working for me under current Groovy 2.5 and 3.0.  Could you confirm?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Delegation inconsistent between methods and properties in nested closures,GROOVY-7232,12811490,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,farrellm,farrellm,30/Dec/14 12:53,11/Nov/20 02:00,14/Jul/23 05:59,01/Aug/20 11:35,2.3.2,2.3.7,2.4.0-rc-1,,,,,,,,,,,,,,,4.0.0-alpha-1,,,,groovy-runtime,,,,0,breaking,,,,,,"When a closure's resolveStrategy is set to DELEGATE_ONLY or DELEGATE_FIRST, resolution is different in nested closures between methods and properties of the delegate. For example, in the following, {{x}} resolves to {{f}}'s delegate (what I expect), but {{keySet()}} resolves to {{g}}'s delegate.

{code}
def g = {->
    def f = {
        {-> [x, keySet()]}()
    }

    f.resolveStrategy = Closure.DELEGATE_ONLY
    f.delegate = [x: 1, f: 0]

    f()
}      

g.delegate = [x: 0, g: 0]
g()
{code}
Result: {code}[1, ['x', 'g']]{code}

Whereas without the nested closure

{code}
def g = {->
    def f = {
        [x, keySet()]
    }

    f.resolveStrategy = Closure.DELEGATE_ONLY
    f.delegate = [x: 1, f: 0]

    f()
}      

g.delegate = [x: 0, g: 0]
g()
{code}
Result: {{[1, ['x', 'f']]}}",,emilles,farrellm,paulk,,,,,,,,,,,,,"eric-milles opened a new pull request #1302:
URL: https://github.com/apache/groovy/pull/1302


   https://issues.apache.org/jira/browse/GROOVY-7232
   
   I tried to respect the apparent design of preferring declared methods over calls to `methodMissing`.  However, there was some mixed behavior on that front as seen in ""(**) involves methodMissing since delegate methodMissing has precedence over explicit owner method"" test cases.  I stuck with it because this new design gives dynamic behavior that more closely matches the static compilation behavior.
   
   If `methodMissing` is okay to call on delegate instead of declared method on owner -- in the case of `DELEGATE_FIRST` and vice versa in the case of `OWNER_FIRST` -- I have a simpler solution that leverages `InvokerHelper.invokeMethod`.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jul/20 00:02;githubbot;600","eric-milles opened a new pull request #1328:
URL: https://github.com/apache/groovy/pull/1328


   Here is my discussed alternative that simplifies the implementation using `InvokerHelper#invokeMethod`.  If a delegate or owner implements `methodMissing` it will be called instead of trying `invokeMethod` on the next in line.  This is more consistent with the way property resolution works (see `Closure#getProperty`).
   
   `StaticTypeCheckingVisitor` will need a block similar to the one added for GROOVY-7996 in order for static compilation to line up.
   
   https://issues.apache.org/jira/browse/GROOVY-7232
   
   
   **Note:** This does not address the change in behavior discussed here: https://github.com/apache/groovy/commit/640e9304fe8950400d94adaad474c0c341209df0#commitcomment-40953759


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;29/Jul/20 07:48;githubbot;600","asfgit closed pull request #1328:
URL: https://github.com/apache/groovy/pull/1328


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Aug/20 05:19;githubbot;600","paulk-asert commented on pull request #1328:
URL: https://github.com/apache/groovy/pull/1328#issuecomment-670826498


   Merged, thanks. Agree we need to look further at static compilation cases.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Aug/20 05:21;githubbot;600",,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Dec/14 12:53;farrellm;DelegateTest.groovy;https://issues.apache.org/jira/secure/attachment/12723163/DelegateTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 06 13:51:00 UTC 2020,,,,,,,,,,"0|i2cbov:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"07/Jul/20 18:52;emilles;This is found in {{ClosureMetaClass#invokeMethod}}:
{code}
            default: // owner first
                // owner first means we start with the outer most owner that is not a generated closure
                // this owner is equal to the this object, so we check that one first.
                method = getDelegateMethod(closure, thisObject, methodName, argClasses);
{code}

I think it is supposed to use the variable ""owner"" and not ""thisObject"".  It will take some testing to figure out the impact.

For reference, {{Closure}} implements {{getProperty}} like this: https://github.com/apache/groovy/blob/master/src/main/java/groovy/lang/Closure.java#L294;;;","07/Jul/20 21:33;emilles;[~paulk] or [~blackdrag],

Could you clarify how the resolve strategies {{DELEGATE_FIRST}} and {{OWNER_FIRST}} are expected to work in terms of {{methodMissing}}?  If the strategy is {{OWNER_FIRST}} (default) I would expect the entire owner tree (including delegates for enclosing closures) to be explored out to the enclosing class before the delegate is consulted.

The test {{gls.closures.ResolveStrategyTest#testDynamicSettingOfResolveStrategy}} seems to suggest that {{methodMissing}} is not to be invoked on owner's hierarchy if delegate has the property.  And {{ClosureMetaClass}} seems to be implemented in terms of looking for existing methods on owners and delegates before getting into {{methodMissing}}.

There is no clarity on checking for existing methods vs. calling {{methodMissing}} in: https://docs.groovy-lang.org/latest/html/documentation/#_delegation_strategy_2


I have a simple solution for this ticket using the power of {{InvokerHelper#invokeMethod}} to explore owner first and then try delegate.  There is only one test that has an issue with the change.;;;","06/Aug/20 02:21;paulk;I think the behavior for {{getProperty}} looks correct. I don't think the behavior for methods looks correct.;;;","06/Aug/20 13:51;emilles;This should align method resolution with property resolution: https://github.com/apache/groovy/pull/1328;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE during compilation because of constant optimization,GROOVY-7230,12811401,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,29/Dec/14 14:30,21/Jan/15 15:26,14/Jul/23 06:01,29/Dec/14 14:38,2.4.0-rc-1,,,,,,,,,,,,,,,,,2.4.0-rc-2,,,,Static compilation,,,,0,,,,,,,"The following code produces a compile-time NPE, making it impossible to compile a project:

{code}
@groovy.transform.CompileStatic
void foo() {
  Double d = null
}

foo()
{code}
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-12-29 14:30:27.0,,,,,,,,,,"0|i2bqqf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Charset.toString() returns incompatible name for Charset.forName on Android,GROOVY-7229,12811467,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,gazer,gazer,29/Dec/14 12:05,21/Jan/15 15:26,14/Jul/23 06:01,30/Dec/14 02:45,2.4.0-beta-3,2.4.0-beta-4,,,,,,,,,,,,,,,,2.3.10,2.4.0-rc-2,,,Android,,,,0,,,,,,,"Trying to use new URL('http://google.com').text fails with :
 
Caused by: java.nio.charset.IllegalCharsetNameException: java.nio.charset.CharsetICU[UTF-8]
at java.nio.charset.Charset.checkCharsetName(Charset.java:201)
at java.nio.charset.Charset.forName(Charset.java:295)
at java.io.InputStreamReader.<init>(InputStreamReader.java:85)
            at org.codehaus.groovy.runtime.ResourceGroovyMethods.newReader(ResourceGroovyMethods.java:2064)
  
On Android, the Charset#toString prepend the class name on the returned string and thats break Charset.fromName used later to create the reader.

Log.d(""Charset"", ""toString() : "" + CharsetToolkit.getDefaultSystemCharset().toString());
Log.d(""Charset"", ""displayName() : "" + CharsetToolkit.getDefaultSystemCharset().displayName());
Log.d(""Charset"", ""name() : "" + CharsetToolkit.getDefaultSystemCharset().name()); 

Output :
 
D/Charset&#65109; toString() : java.nio.charset.CharsetICU[UTF-8]
D/Charset&#65109; displayName() : UTF-8
D/Charset&#65109; name() : UTF-8 

This was tested on Android 4.4.4.","Android 4.4.4, groovy:2.4.0-beta-4",gazer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-12-29 12:05:11.0,,,,,,,,,,"0|i2c78v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyShell/Grape cannot use Extension Modules that extend Closure,GROOVY-7225,12811474,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pickypg,pickypg,28/Dec/14 01:10,21/Jan/15 15:26,14/Jul/23 06:01,29/Dec/14 14:16,2.3.7,2.3.8,2.3.9,,,,,,,,,,,,,,,2.3.10,2.4.0-rc-2,,,Grape,Groovysh,,,0,,,,,,,"{code:title=Test.groovy}
@Grab('org.elasticsearch:elasticsearch-groovy:1.4.2')
def printClosure(Closure closure) {
  println closure.asJsonString()
}

printClosure { field = ""simple"" }
{code}

The extension method's signature is {{static String asJsonString(Closure self)}} (https://github.com/elasticsearch/elasticsearch-groovy/blob/v1.4.2/src/main/groovy/org/elasticsearch/groovy/common/xcontent/XContentBuilderExtensions.groovy#L97).

{code:title=Output}
$ groovy --indy Test.groovy
Caught: groovy.lang.MissingMethodException: No signature of method: Test.asJsonString() is applicable for argument types: () values: []
Possible solutions: toString(), toString()
groovy.lang.MissingMethodException: No signature of method: Test.asJsonString() is applicable for argument types: () values: []
Possible solutions: toString(), toString()
	at Test.printClosure(Test.groovy:3)
	at Test.run(Test.groovy:6)
{code}

Tested on both a Mac and Linux (with and without --indy does not matter):

- Groovy Version: 2.3.9 JVM: 1.8.0_25 Vendor: Oracle Corporation OS: Mac OS X
- Groovy Version 2.3.9 JVM: 1.7.0_65 Vendor: Oracle Corporation OS: Linux

However, if I don't use Grape/the GroovyShell, then the same code works with the same dependencies. I always use Gradle to build my code, so it wasn't until a user pointed this issue out that I became aware of it.

This relates to GROOVY-6557. On my Mac, I was always able to reproduce GROOVY-6447, but my core issue appears to relate to {{Closure}} extension methods across multiple platforms (https://github.com/elasticsearch/elasticsearch-groovy/issues/19).","Mac OS X 10.10 with Java 8u25
Ubuntu Server 14.04.1 with Java 7u65",pickypg,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6557,,,,"29/Dec/14 14:15;pickypg;groovy7225.zip;https://issues.apache.org/jira/secure/attachment/12723112/groovy7225.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 29 14:14:12 UTC 2014,,,,,,,,,,"0|i2ci3z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Dec/14 15:47;pickypg;I added a test to the {{ExtensionModuleTest}} that was suspiciously not failing even when specifying {{assert false}} at the top. I created a [PR|https://github.com/groovy/groovy-core/pull/574] to fix this issue by checking for errors in the output -- and now 2 of the existing 3 tests fail, plus my added test.

I realize that tends to go against the general idea of a PR (new test failures), but I figured it would make a good starting point.;;;","28/Dec/14 15:55;pickypg;Source code/gradle build for the jar used in the unit tests from the comment.;;;","29/Dec/14 14:14;pickypg;Closure extension compiled with Java 6 compatibility.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
&& operator is not handled correctly in some cases when it starts a new line,GROOVY-7218,12817881,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,csbubbles,csbubbles,19/Dec/14 19:23,06/Mar/18 23:25,14/Jul/23 06:01,09/May/17 22:08,2.3.8,,,,,,,,,,,,,,,,,2.6.0-alpha-1,,,,Compiler,,,,0,,,,,,,"h3. Repro

{code:title=A.groovy|borderStyle=solid}
def files = new File(""."").list(
    [ accept: { d, f ->
        (f ==~ "".*"") && !f.endsWith("".tmp"")
    }] as FilenameFilter
).toList()
{code}

*Result:* works fine

{code:title=B.groovy|borderStyle=solid}
def files = new File(""."").list(
    [ accept: { d, f ->
        (f ==~ "".*"")
            && !f.endsWith("".tmp"")
    }] as FilenameFilter
).toList()
{code}

*Result:*

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/home/csbubbles/B.groovy: 5: unexpected token: && @ line 5, column 3.
   		&& !f.endsWith("".tmp"")
     ^

1 error
{code}

h3. Expected results

B.groovy should get executed successfully the same way as A.groovy, as its two lines in a closure is the only expression.

PS ""return"" statement doesn't help if you put it before ""(f ==~ "".*"")"" either.",CentOS 7,csbubbles,jwagenleitner,melix,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 09 22:08:24 UTC 2017,,,,,,,,,,"0|i2ct8n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Dec/14 19:30;csbubbles;PS It might be an issue with ""return"" operator (and the last statement in a block) in fact, because the following method also fails to compile:

{code}
def a() {
    return true
        && false
        && true
}
{code}

*Result:*

{code}
/home/csbubbles/X.groovy: 4: unexpected token: && @ line 4, column 3.
   		&& false
     ^

1 error
{code}

If you move all the conditions to the only line, it will work. The failure is pretty inconvenient as when you have complex conditions, you may want to split them to multiple lines just like I showed. And some projects have code style guidelines to start a new line with an operator. In Java it works fine since the beginning as I remember.;;;","05/Jan/15 04:11;melix;I am lowering the priority because there are at leas two easy workarounds for this parsing issue:

1. put the && operator at the end of the line instead of the beginning

{code}
def files = new File(""."").list(
    [ accept: { d, f ->
        (f ==~ "".*"") &&
            !f.endsWith("".tmp"")
    }] as FilenameFilter
).toList()
{code}

2. put a \ sign at the end of the line to tell the parser that the instruction continues at the following line

{code}
def files = new File(""."").list(
    [ accept: { d, f ->
        (f ==~ "".*"") \
            && !f.endsWith("".tmp"")
    }] as FilenameFilter
).toList()
{code}
;;;","05/Jan/15 04:15;tkruse;Also additional parentheses help.;;;","05/Jan/15 12:03;csbubbles;Workarounds suggested by Cédric are no good. First, for example, we start a line with an operator in such cases to clearly show that this is an operation continuing an expression, not a new expression (so, we don't put operators at the end of lines; sort of against the code style). The backslash also shouldn't be a required part of the language to write multiline expressions that can be separated by operators. The user of Groovy shall not care about where to put ""&&"" - at the end of a line or at the beginning of a new line in a complex expression. Introducing workarounds you essentially make the language (its syntax) more complicated and worse, because you encourage its users to use something very specific or not use at all (black magic / hidden knowledge).;;;","09/May/17 22:08;jwagenleitner;I tested the repro with the antlr4 parser and verified issue is fixed and that test coverage exists:

https://github.com/apache/groovy/blob/734bff6f3336d5b2607f2749d1f986434711486b/subprojects/parser-antlr4/src/test/resources/core/Expression_23x.groovy#L94-L96;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Number initialization in traits,GROOVY-7217,12817898,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,chiquitinxx,chiquitinxx,19/Dec/14 11:20,23/Dec/14 19:45,14/Jul/23 06:01,22/Dec/14 02:34,2.3.9,,,,,,,,,,,,,,,,,2.3.10,2.4.0-rc-1,,,,,,,0,traits,,,,,,"The code of this example is not working in groovy 2.3.9 http://mrhaki.blogspot.com.es/2014/05/groovy-goodness-implementing-traits-at.html

To fix, just have to change:

{code}
trait Version {
    Long version = 0L // <- this L
}
{code}
",,chiquitinxx,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 22 02:34:00 UTC 2014,,,,,,,,,,"0|i2bqnb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Dec/14 02:34;melix;There was another related issue also fixed with https://github.com/groovy/groovy-core/commit/f59f793ab347046f7f4118d3604163a308ba26f0 : it wasn't possible anymore to use an undefined method as part of the initialization of a field in a trait.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
subMap includes keys with null value that are not in the original map,GROOVY-7216,12817933,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,bobbywarner,bobbywarner,18/Dec/14 19:05,23/Dec/14 19:45,14/Jul/23 06:01,18/Dec/14 20:19,2.3.8,,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,groovy-jdk,,,,0,,,,,,,,,bobbywarner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Dec 18 20:19:38 UTC 2014,,,,,,,,,,"0|i2cr3j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Dec/14 19:09;bobbywarner;Pull Request: https://github.com/groovy/groovy-core/pull/561;;;","18/Dec/14 20:19;paulk;PR merged - thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect stubs generated for traits if a class defines a conflicting property,GROOVY-7215,12817902,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,18/Dec/14 11:54,23/Dec/14 19:45,14/Jul/23 06:01,18/Dec/14 12:02,,,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,,,,,0,,,,,,,"In some cases, when a trait defines a getter and a setter, and that the implementing class defines a property of the same name, then if joint compilation is enabled, incorrect stubs may be generated.

Example:

{code}
trait SomeTrait {
   void setFoo(Foo a) {}
   Foo getFoo() {}
}

class SomeClass implements SomeTrait {
   Foo foo
}
{code}

The fact that stubs are incorrect or not do not seem to only depend on the contents of the classes, but also on the order of compilation.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-12-18 11:54:17.0,,,,,,,,,,"0|i2c733:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Private Methods In A Trait,GROOVY-7214,12811459,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,18/Dec/14 11:49,23/Dec/14 19:45,14/Jul/23 06:01,18/Dec/14 14:35,,,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,,,,,0,,,,,,,"The attached traitissue.zip contains the following code:

{code:title=src/main/groovy/demo/SomeTrait.groovy|borderStyle=solid}
package demo

trait SomeTrait {

    static getSomeValue() {
        someHelperMethod()
    }

    private static someHelperMethod() {
        42
    }
}
{code}

{code:title=src/test/groovy/demo/SomeTraitSpec.groovy|borderStyle=solid}
package demo

import spock.lang.Specification

class SomeTraitSpec extends Specification {

    void 'test static method'() {
        expect:
        SomeClass.getSomeValue() == 42

    }
}

class SomeClass implements SomeTrait {}
{code}

Using the current 2.4.0-SNAPSHOT that test fails with the following:

{noformat}
groovy.lang.MissingMethodException: No signature of method: static demo.SomeClass.someHelperMethod() is applicable for argument types: () values: []
    at demo.SomeTrait$Trait$Helper.getSomeValue(SomeTrait.groovy:6)
    at demo.SomeTraitSpec.test static method(SomeTraitSpec.groovy:9)
{noformat}

If the private method in SomeTrait is promoted to public, the test passes.  If build.gradle is edited to use either Groovy 2.3.7 or 2.3.8 or 2.4.0-beta-4 the test passes.
",,brownj,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7191,,,,,,"18/Dec/14 11:49;brownj;traitissue.zip;https://issues.apache.org/jira/secure/attachment/12723265/traitissue.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Dec 18 14:35:35 UTC 2014,,,,,,,,,,"0|i2bncv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Dec/14 14:35;melix;This is fixed but with the same limitation as in GROOVY-7191, that is to say that it is not possible to call another static method in the trait if the trait is statically compiled.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Private methods in traits cause compile time error if the class implementing trait is statically compiled,GROOVY-7213,12817925,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,18/Dec/14 06:12,23/Dec/14 19:45,14/Jul/23 06:01,18/Dec/14 06:29,2.3.8,,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,Compiler,,,,0,,,,,,,"The following code causes a compile-time error, just because the class implementing the trait uses `@CompileStatic`:

{code}
trait Foo {
   private int f(int x) { x }
   int foo() { f(2) }
}

@groovy.transform.CompileStatic
class A implements Foo {}
new A().foo()
{code}
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-12-18 06:12:51.0,,,,,,,,,,"0|i2c2kn:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic: A method which has default value parameter and generic return type will cause type checking error,GROOVY-7211,12817883,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,druid0523,druid0523,16/Dec/14 21:19,21/Mar/15 07:11,14/Jul/23 06:01,02/Mar/15 05:20,2.3.8,2.4.0-rc-1,2.4.1,,,,,,,,,,,,,,,2.3.11,2.4.2,,,Static Type Checker,,,,1,,,,,,,"Testcase as follow:
{code}
import groovy.transform.CompileStatic
import org.junit.Test

class Bug1Base<T> {
	T t

	T get(a, b=0) {
		return t
	}
}

class Bug1 {
	@Test
	@CompileStatic
	void test() {
		Bug1Base<Integer> bug = new Bug1Base<Integer>(t:1)
		Integer t = bug.get(1)
		println t
	}
}
{code}

It will cause type checking error as follow:
{code}
Groovyc: [Static type checking] - Cannot assign value of type T to variable of type java.lang.Integer
{code}","Windows 7 64bit
java version ""1.7.0_71""
Java(TM) SE Runtime Environment (build 1.7.0_71-b14)
Java HotSpot(TM) 64-Bit Server VM (build 24.71-b01, mixed mode)",druid0523,fpavageau,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Feb 28 17:31:12 UTC 2015,,,,,,,,,,"0|i2c88n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Feb/15 17:31;lhotari;I ran into this problem in Grails 3 work too. I hope this gets fixed for next release of 2.4.x .;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
array index variable unboxing not working,GROOVY-7210,12817913,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,blackdrag,blackdrag,16/Dec/14 09:38,23/Dec/14 19:45,14/Jul/23 06:01,16/Dec/14 10:24,2.3.8,2.4.0-beta-4,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,Static Type Checker,,,,0,,,,,,,"giving this code to the static type checker {code:Java}
    Integer i = 0
    int[] a = [0]
    a[i] = 1
{code}
fails on the array access part with {code}[Static type checking] - Cannot find matching method [I#getAt(java.lang.Integer). Please check if the declared type is right and if the method exists.{code}
this code should be legal though",,blackdrag,ngalarneau,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-12-16 09:38:47.0,,,,,,,,,,"0|i2ch87:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Script.getProperty vs Script.setProperty asymmetry,GROOVY-7208,12817910,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,neopaf,neopaf,16/Dec/14 04:39,03/Feb/22 22:34,14/Jul/23 06:01,29/Oct/21 21:24,2.3.6,,,,,,,,,,,,,,,,,4.0.0-beta-1,,,,GroovyScriptEngine,,,,0,,,,,,,"{code:java}
@groovy.transform.Field i = 5

assert getProperty(""i"") == 5 // ok
assert i == 5 // ok

setProperty(""i"", getProperty(""i"") + 1)

assert getProperty(""i"") == 6 // ok
assert i == 6 // fails, i is currently 5
{code}

Effectively
* script.getProperty did read script.i field
* while script.setProperty stored value only to Binding, not to script.i field

Please consider script.setProperty to detect that there is script.$name field, and if there is, write there and only there to match getProperty behavior.","During GROOVY-5575 came to this very strange behavior, which we feel is a bug.",neopaf,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 16 04:50:03 UTC 2014,,,,,,,,,,"0|i2c1vb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Dec/14 04:50;neopaf;ultimately, get and set must be symmetric, we feel.
what was set must be get-table.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException when assigning an unknown property in a trait,GROOVY-7206,12817895,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,11/Dec/14 09:45,23/Dec/14 19:45,14/Jul/23 06:01,11/Dec/14 09:58,2.3.8,2.4.0-beta-4,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,,,,,0,,,,,,,"The following code throws a null pointer exception *during compilation*:

{code}
trait SetUnknown {
                def setup() {
                    this.unknownProperty = 1
                }
            }
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-12-11 09:45:04.0,,,,,,,,,,"0|i2ck0f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checking and compilation fail when multiple generics in use,GROOVY-7204,12811464,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,daniel_sun,mauromol,mauromol,10/Dec/14 02:48,11/Nov/22 20:18,14/Jul/23 06:01,10/May/18 08:02,2.3.8,,,,,,,,,,,,,,,,,2.5.0-rc-3,3.0.0-alpha-3,,,Static compilation,Static Type Checker,,,2,,,,,,,"Consider the following interfaces:

{code:title=CrudRepository.java}
package f;

import java.io.Serializable;

public interface CrudRepository<T, S extends Serializable> {

	void delete(S arg);
	void delete(T arg);
}
{code}

{code:title=MyRepository.java}
package f;

public interface MyRepository extends CrudRepository<String, Long> {
}
{code}

The following implementation class:

{code:title=MyRepositoryImpl.java}
package f;

public class MyRepositoryImpl implements MyRepository {

	@Override
	public void delete(String arg) {
		System.out.println(""String"");
	}

	@Override
	public void delete(Long arg) {
		System.out.println(""Long"");
	}
}
{code}

And the following Groovy class:
{code:title=MyClass.groovy}
package f

import groovy.transform.CompileStatic;
import groovy.transform.TypeChecked;

@TypeChecked
class MyClass {

	static MyRepository factory() {
		return new MyRepositoryImpl()
	}
	
	static void main(String[] args) {
		MyRepository r = factory()
		r.delete('foo')
	}	
}
{code}

Static type checking returns the following error:
{noformat}
MyClass.groovy: 15: [Static type checking] - Cannot call f.MyRepository#delete(S) with arguments [java.lang.String]
{noformat}

The same applies if you use {{@CompileStatic}} instead of {{@TypeChecked}}.

Note that if, In the previous code, you change the method {{main}} by replacing:
{code}
MyRepository r = factory()
{code}
with: 
{code}
MyRepository r = new MyRepositoryImpl()
{code}

compilation succeeds. However in real code this might not be possible (the {{MyRepository}} instance may be injected and auto-generated, think of Spring Data for instance).

The only workaround is (yet again...) to disable static type checking and static compilation.",,daniel_sun,daniilo,davide.cavestro,emilles,eschava,githubbot,mauromol,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10820,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 11 20:10:17 UTC 2022,,,,,,,,,,"0|i2c8r3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/May/18 02:05;daniel_sun;There are many cases we should consider(See the PR#699). Here is the one of simplified cases:
 
{code:java}
import java.io.Serializable;

class Repository<T, S extends Serializable> {
    void delete(T arg) {}
    void delete(S arg) {} // compilation passes if the code is commented
}

@groovy.transform.TypeChecked
def test() {
    Repository<String, Long> r = new Repository<String, Long>()
    r.delete('foo')
}

test()
{code};;;","09/May/18 17:40;githubbot;GitHub user danielsun1106 opened a pull request:

    https://github.com/apache/groovy/pull/699

    GROOVY-7204: Static type checking and compilation fail when multiple …

    …generics in use

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/danielsun1106/groovy GROOVY-7204

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/699.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #699
    
----
commit 1adb32dc73f13f07cc61124711d3bba92dd6ec82
Author: Daniel Sun <realbluesun@...>
Date:   2018-05-09T17:38:30Z

    GROOVY-7204: Static type checking and compilation fail when multiple generics in use

----
;;;","10/May/18 07:48;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/699
;;;","10/May/18 08:02;daniel_sun;Fixed by https://github.com/apache/groovy/commit/6d5bc0db7a0e8c8c69911d7e4f064e9a27ba40a6
https://github.com/apache/groovy/commit/e7766ffad4a70377a2e80b2a797261b0cb197ed4
https://github.com/apache/groovy/commit/62f5ce6ffe8d0dad30808944201723e02d3666fd
https://github.com/apache/groovy/commit/795e2540c2b8d3d62594b5c91631427c708047f6

P.S. Feel free to revert them;;;","11/Nov/22 20:10;emilles;{code:groovy}
class Repository<T, S extends Serializable> {
  void delete(T arg) { assert true }
  void delete(S arg) { assert false : 'wrong method invoked' }
}
@groovy.transform.CompileStatic
def test() {
  def r = new Repository<String,Long>()
  r.delete('foo')
}
test()
{code}
This is a very interesting case.  I tried it in Java and it works as described: static selection of {{delete(T)}} aka {{delete(String)}}.  However the dynamic runtime selects {{delete(S)}} because the erasure {{Serializable}} is a closer match for {{String}}.  I wonder if it would be better to have consistent behavior for SC and STC or to align SC with Java.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy 2.3.8 causes Gaelyk 2.1.2's initialization to fail on the Google App Engine Production server,GROOVY-7203,12817918,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,awijasa,awijasa,08/Dec/14 10:13,23/Dec/14 19:45,14/Jul/23 06:01,09/Dec/14 03:22,2.3.8,,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,,,,,0,exception,gaelyk,Google-AppEngine,initialization,,,"I got these errors once I have published my app to App Engine (Production server). They don't occur on the dev server. Please note that the errors only appear if I use Groovy 2.3.8. Groovy 2.3.7 works fine so far. This is just a heads up, and I know that the recommended/tested version of Groovy for Gaelyk 2.1.2 is Groovy 2.3.0.

Here are the errors:

13:59:50.629
Uncaught exception from servlet
java.lang.ExceptionInInitializerError
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:526)
	at java.lang.Class.newInstance(Class.java:370)
	at org.codehaus.groovy.vmplugin.VMPluginFactory.createPlugin(VMPluginFactory.java:56)
	at org.codehaus.groovy.vmplugin.VMPluginFactory.<clinit>(VMPluginFactory.java:37)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:99)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:71)
	at groovy.lang.GroovySystem.<clinit>(GroovySystem.java:33)
	at org.codehaus.groovy.reflection.ClassInfo.isValidWeakMetaClass(ClassInfo.java:221)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassForClass(ClassInfo.java:191)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:236)
	at groovyx.gaelyk.GaelykServletContextListener.$getStaticMetaClass(GaelykServletContextListener.groovy)
	at groovyx.gaelyk.GaelykServletContextListener.<init>(GaelykServletContextListener.groovy)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:526)
	at java.lang.Class.newInstance(Class.java:370)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.newListenerInstance(WebXmlConfiguration.java:650)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.initListener(WebXmlConfiguration.java:631)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.initWebXmlElement(WebXmlConfiguration.java:368)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.initialize(WebXmlConfiguration.java:289)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.configure(WebXmlConfiguration.java:222)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.configureWebApp(WebXmlConfiguration.java:180)
	at org.mortbay.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1247)
	at org.mortbay.jetty.handler.ContextHandler.doStart(ContextHandler.java:517)
	at org.mortbay.jetty.webapp.WebAppContext.doStart(WebAppContext.java:467)
	at org.mortbay.component.AbstractLifeCycle.start(AbstractLifeCycle.java:50)
	at com.google.apphosting.runtime.jetty.AppVersionHandlerMap.createHandler(AppVersionHandlerMap.java:199)
	at com.google.apphosting.runtime.jetty.AppVersionHandlerMap.getHandler(AppVersionHandlerMap.java:174)
	at com.google.apphosting.runtime.jetty.JettyServletEngineAdapter.serviceRequest(JettyServletEngineAdapter.java:134)
	at com.google.apphosting.runtime.JavaRuntime$RequestRunnable.run(JavaRuntime.java:480)
	at com.google.tracing.TraceContext$TraceContextRunnable.runInContext(TraceContext.java:438)
	at com.google.tracing.TraceContext$TraceContextRunnable$1.run(TraceContext.java:445)
	at com.google.tracing.CurrentContext.runInContext(CurrentContext.java:220)
	at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContextNoUnref(TraceContext.java:309)
	at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContext(TraceContext.java:301)
	at com.google.tracing.TraceContext$TraceContextRunnable.run(TraceContext.java:442)
	at com.google.apphosting.runtime.ThreadGroupPool$PoolEntry.run(ThreadGroupPool.java:251)
	at java.lang.Thread.run(Thread.java:724)
Caused by: java.lang.SecurityException: java.lang.IllegalAccessException: Reflection is not allowed on private java.lang.invoke.MethodHandles$Lookup(java.lang.Class,int)
	at com.google.appengine.runtime.Request.process-8262919bfd190198(Request.java)
	at org.codehaus.groovy.vmplugin.v7.Java7$1.run(Java7.java:49)
	at java.security.AccessController.doPrivileged(AccessController.java:34)
	at org.codehaus.groovy.vmplugin.v7.Java7.<clinit>(Java7.java:46)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:526)
	at java.lang.Class.newInstance(Class.java:370)
	at org.codehaus.groovy.vmplugin.VMPluginFactory.createPlugin(VMPluginFactory.java:56)
	at org.codehaus.groovy.vmplugin.VMPluginFactory.<clinit>(VMPluginFactory.java:37)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:99)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:71)
	at groovy.lang.GroovySystem.<clinit>(GroovySystem.java:33)
	at org.codehaus.groovy.reflection.ClassInfo.isValidWeakMetaClass(ClassInfo.java:221)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassForClass(ClassInfo.java:191)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:236)
	at groovyx.gaelyk.GaelykServletContextListener.$getStaticMetaClass(GaelykServletContextListener.groovy)
	at groovyx.gaelyk.GaelykServletContextListener.<init>(GaelykServletContextListener.groovy)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:526)
	at java.lang.Class.newInstance(Class.java:370)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.newListenerInstance(WebXmlConfiguration.java:650)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.initListener(WebXmlConfiguration.java:631)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.initWebXmlElement(WebXmlConfiguration.java:368)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.initialize(WebXmlConfiguration.java:289)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.configure(WebXmlConfiguration.java:222)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.configureWebApp(WebXmlConfiguration.java:180)
	at org.mortbay.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1247)
	at org.mortbay.jetty.handler.ContextHandler.doStart(ContextHandler.java:517)
	at org.mortbay.jetty.webapp.WebAppContext.doStart(WebAppContext.java:467)
	at org.mortbay.component.AbstractLifeCycle.start(AbstractLifeCycle.java:50)
	at com.google.tracing.TraceContext$TraceContextRunnable.runInContext(TraceContext.java:438)
	at com.google.tracing.TraceContext$TraceContextRunnable$1.run(TraceContext.java:445)
	at com.google.tracing.CurrentContext.runInContext(CurrentContext.java:220)
	at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContextNoUnref(TraceContext.java:309)
	at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContext(TraceContext.java:301)
	at com.google.tracing.TraceContext$TraceContextRunnable.run(TraceContext.java:442)
	... 1 more
Caused by: java.lang.IllegalAccessException: Reflection is not allowed on private java.lang.invoke.MethodHandles$Lookup(java.lang.Class,int)
	... 40 more




Uncaught exception from servlet
java.lang.NoClassDefFoundError: Could not initialize class groovy.lang.GroovySystem
	at org.codehaus.groovy.reflection.ClassInfo.isValidWeakMetaClass(ClassInfo.java:221)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassForClass(ClassInfo.java:191)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:236)
	at groovyx.gaelyk.GaelykServletContextListener.$getStaticMetaClass(GaelykServletContextListener.groovy)
	at groovyx.gaelyk.GaelykServletContextListener.<init>(GaelykServletContextListener.groovy)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:526)
	at java.lang.Class.newInstance(Class.java:370)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.newListenerInstance(WebXmlConfiguration.java:650)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.initListener(WebXmlConfiguration.java:631)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.initWebXmlElement(WebXmlConfiguration.java:368)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.initialize(WebXmlConfiguration.java:289)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.configure(WebXmlConfiguration.java:222)
	at org.mortbay.jetty.webapp.WebXmlConfiguration.configureWebApp(WebXmlConfiguration.java:180)
	at org.mortbay.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1247)
	at org.mortbay.jetty.handler.ContextHandler.doStart(ContextHandler.java:517)
	at org.mortbay.jetty.webapp.WebAppContext.doStart(WebAppContext.java:467)
	at org.mortbay.component.AbstractLifeCycle.start(AbstractLifeCycle.java:50)
	at com.google.apphosting.runtime.jetty.AppVersionHandlerMap.createHandler(AppVersionHandlerMap.java:199)
	at com.google.apphosting.runtime.jetty.AppVersionHandlerMap.getHandler(AppVersionHandlerMap.java:174)
	at com.google.apphosting.runtime.jetty.JettyServletEngineAdapter.serviceRequest(JettyServletEngineAdapter.java:134)
	at com.google.apphosting.runtime.JavaRuntime$RequestRunnable.run(JavaRuntime.java:480)
	at com.google.tracing.TraceContext$TraceContextRunnable.runInContext(TraceContext.java:438)
	at com.google.tracing.TraceContext$TraceContextRunnable$1.run(TraceContext.java:445)
	at com.google.tracing.CurrentContext.runInContext(CurrentContext.java:220)
	at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContextNoUnref(TraceContext.java:309)
	at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContext(TraceContext.java:301)
	at com.google.tracing.TraceContext$TraceContextRunnable.run(TraceContext.java:442)
	at com.google.apphosting.runtime.ThreadGroupPool$PoolEntry.run(ThreadGroupPool.java:251)
	at java.lang.Thread.run(Thread.java:724)",Gaelyk 2.1.2 at Google App Engine's Production server,awijasa,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 09 03:22:43 UTC 2014,,,,,,,,,,"0|i2c2gv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Dec/14 03:22;blackdrag;I pushed a workaround for this issue. It is not a 100% solution, since it means you cannot call default interface methods anymore, if the security manager forbids access to the special constructor of Lookup, that allows for private access. But for now it should work on GAE, since GAE does not yet use java8;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unable to resolve nested enum of parent class when compiling against binary parent,GROOVY-7202,12818015,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,gillius,gillius,08/Dec/14 09:24,26/Jul/18 04:38,14/Jul/23 06:01,06/Apr/18 08:07,2.3.3,2.3.8,,,,,,,,,,,,,,,,2.4.16,2.5.0-rc-2,2.6.0-alpha-4,3.0.0-alpha-2,,,,,0,,,,,,,"{code:title=Base.groovy}
class Base {
  public static enum Color { Red, Green }
  
  public Color getColor() { Color.Red }
}
{code}

{code:title=Child.groovy}
class Child extends Base {
  @Override
  public Color getColor() { Color.Green }
}
{code}

Steps to reproduce:
# groovyc Base.groovy
# rm Base.groovy
# groovyc Child.groovy

Note that `groovyc *.groovy` works, as well as putting the code into the groovyconsole. It seems that this bug is triggered only when Base.groovy source is not in sourcepath.

Workaround is to put `import Base.Color` in Child.groovy. However, IDEs like IntelliJ IDEA show this as an unnecessary import and remove the import when optimizing imports (which can happen on every save depending on IDE settings). Another workaround is to put absolute qualifier on Color enum, but IDEA also provides warning for this.",Tested on JDK 1.7.0_51 32 bit Windows,daniel_sun,gillius2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"08/Dec/14 09:24;Base.groovy;https://issues.apache.org/jira/secure/attachment/12723072/Base.groovy","08/Dec/14 09:24;Child.groovy;https://issues.apache.org/jira/secure/attachment/12723273/Child.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 05 18:35:31 UTC 2018,,,,,,,,,,"0|i2cof3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Apr/18 18:35;daniel_sun;should be same with GROOVY-8531 and fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovysh parser produces error when writing methods with annotations,GROOVY-7201,12817942,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,tkruse,tkruse,06/Dec/14 13:46,23/Dec/14 19:45,14/Jul/23 06:01,07/Dec/14 04:06,,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Groovysh,,,,0,,,,,,,"To reproduce paste code with method annotations like @Override into the the shell.
 ",,pschumacher,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 07 04:06:03 UTC 2014,,,,,,,,,,"0|i2c8rz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Dec/14 04:06;pschumacher;I merged [Thibaults pull request|https://github.com/groovy/groovy-core/pull/549]. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Static Trait Properties And Test Classes,GROOVY-7196,12811463,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,03/Dec/14 10:12,23/Dec/14 19:45,14/Jul/23 06:01,05/Dec/14 05:26,2.3.8,2.4.0-beta-4,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,,,,,0,,,,,,,"The attached app contains the following code:

{code:title=src/demo/SomeTrait.groovy|borderStyle=solid}
package demo

trait SomeTrait {
    private static String someString
}
{code}

{code:title=src/demo/SomeClass.groovy|borderStyle=solid}
package demo

class SomeClass implements SomeTrait {}
{code}

{code:title=test/demo/SomeTestClass.groovy|borderStyle=solid}
package demo

class SomeTestClass implements SomeTrait {}
{code}

SomeClass.groovy will compile.  SomeTestClass.groovy will not compile.

{noformat}
$ ./gradlew clean cTG
:clean
:compileJava UP-TO-DATE
:compileGroovy
:processResources UP-TO-DATE
:classes
:compileTestJava UP-TO-DATE
:compileTestGroovy
startup failed:
/Users/jeff/t/statictraitproperty/test/demo/SomeTestClass.groovy: -1: Method 'demo_SomeTrait__someString$get' is already defined in class 'demo.SomeTestClass'. You cannot have both a static and a non static method with the same signature
 @ line -1, column -1.
/Users/jeff/t/statictraitproperty/test/demo/SomeTestClass.groovy: -1: Method 'demo_SomeTrait__someString$set' is already defined in class 'demo.SomeTestClass'. You cannot have both a static and a non static method with the same signature
 @ line -1, column -1.
2 errors

:compileTestGroovy FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileTestGroovy'.
> Compilation failed; see the compiler error output for details.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 3.841 secs
{noformat}

If I edit build.gradle and change Groovy 2.3.8 to 2.3.7 the code will compile.",,brownj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/Dec/14 10:12;brownj;statictraitproperty.zip;https://issues.apache.org/jira/secure/attachment/12723256/statictraitproperty.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 03 10:33:46 UTC 2014,,,,,,,,,,"0|i2boyf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Dec/14 10:18;brownj;It looks like 2.4.0-beta-4 also generates a compile error for that code.;;;","03/Dec/14 10:33;brownj;It appears that the problem is related to precompiled traits.  I have verified this while leaving Gradle out of the equation:

{noformat}
grv $ cat SomeTrait.groovy 
trait SomeTrait {
    static String someValue
}
grv $ 
grv $ cat SomeClass.groovy 
class SomeClass implements SomeTrait {}
grv $ 
grv $ gvm use groovy 2.3.7

Using groovy version 2.3.7 in this shell.
grv $ rm -f *.class && groovyc SomeTrait.groovy && groovyc SomeClass.groovy
grv $ 
grv $ gvm use groovy 2.3.8

Using groovy version 2.3.8 in this shell.
grv $ rm -f *.class && groovyc SomeTrait.groovy && groovyc SomeClass.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
SomeClass.groovy: -1: Method 'SomeTrait__someValue$get' is already defined in class 'SomeClass'. You cannot have both a static and a non static method with the same signature
 @ line -1, column -1.
SomeClass.groovy: -1: Method 'SomeTrait__someValue$set' is already defined in class 'SomeClass'. You cannot have both a static and a non static method with the same signature
 @ line -1, column -1.
2 errors

grv $ rm -f *.class && groovyc *.groovy
{noformat}

Note at the end there that the code compiles if I compile the trait at the same time as the class which implements the trait.  The error occurs when the trait is already compiled.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
usage of compare operators should not force fastpath,GROOVY-7195,12817906,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,03/Dec/14 06:15,23/Dec/14 19:45,14/Jul/23 06:01,03/Dec/14 06:18,,,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,primtive opts,,,,0,,,,,,,"in{code:Java}
            def fib( n ) {
                n<=2L?n:fib(n-1L)+fib(n-2L)
            }
{code}
the primitive opts will force fastpath generation because of n<=2L, regardless that this is not optimized later. This will actually slow the program down because of useless guard checks and bloated bytecode",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 03 06:18:16 UTC 2014,,,,,,,,,,"0|i2bt1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Dec/14 06:18;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Recursive calls cause unnecessary call site generation,GROOVY-7193,12817894,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,03/Dec/14 02:12,23/Dec/14 19:45,14/Jul/23 06:01,05/Dec/14 08:33,,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,groovy-runtime,,,,0,,,,,,,"In a recursive function like:

{code}
def fib(n) {
  n<=2L?n:fib(n-1L)+fib(n-2L)
}
{code}

When the `+` operation is called, an old call site is used, triggering an unnecessary call site generation.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-12-03 02:12:48.0,,,,,,,,,,"0|i2c50f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic: can't access interface implement static field from nested closures,GROOVY-7192,12817893,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,druid0523,druid0523,03/Dec/14 01:43,17/Dec/14 13:25,14/Jul/23 06:01,05/Dec/14 07:27,2.3.6,,,,,,,,,,,,,,,,,2.3.8,,,,Compiler,,,,0,,,,,,,"Code like following:
{code}
interface B {
	public static final CONST = ""a""
}

class C implements B {
}

@groovy.transform.CompileStatic
class A {

	public static final CONST = ""a""

	public static List doSomething() {
		return (0..1).collect{ int x ->
			(0..1).collect{ int y ->
				return C.CONST
			}
		}
	}
}

println A.doSomething()
{code}

fails with this compilation error:
{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
test.groovy: 16: Access to C#CONST is forbidden @ line 16, column 12.
                                return C.CONST
              ^

1 error
{code}",groovy 2.3.6,druid0523,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 05 07:27:37 UTC 2014,,,,,,,,,,"0|i2cmnr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Dec/14 07:27;melix;Closing as this was fixed in 2.3.8 (already released).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic Will Not Allow Instance Method In Trait To Call Static Method,GROOVY-7191,12817725,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,02/Dec/14 19:08,21/Mar/15 07:11,14/Jul/23 06:01,06/Mar/15 07:45,2.3.8,,,,,,,,,,,,,,,,,2.4.2,,,,Static compilation,,,,0,,,,,,,"{noformat}
grv $ groovy -version
Groovy Version: 2.3.8 JVM: 1.7.0_45 Vendor: Oracle Corporation OS: Mac OS X
grv $ 
grv $ cat SomeTrait.groovy 
@groovy.transform.CompileStatic
trait SomeTrait {
    static someStaticMethod(){}

    void someInstanceMethod() {
        someStaticMethod()
    }
}
grv $ 
grv $ groovyc SomeTrait.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
SomeTrait.groovy: 6: [Static type checking] - Cannot find matching method SomeTrait#someStaticMethod(). Please check if the declared type is right and if the method exists.
 @ line 6, column 9.
           someStaticMethod()
           ^

1 error
{noformat}",,brownj,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7255,,GROOVY-7214,GROOVY-7322,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 06 07:45:24 UTC 2015,,,,,,,,,,"0|i2bzv3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Dec/14 07:25;melix;This issue is specific to {{@CompileStatic}}. Let me explain. When you define a static method in a trait, the static method does not ""belong"" to the trait. Instead, it will be copied to the class implementing the trait. So on the trait itself, the static {{someStaticMethod}} is not defined. For this to work, you have to know the class that will be implementing the trait, like you would for a normal static method call:

{code}
SomeClassImplementingTrait.someStaticMethod() // here, someStaticMethod is defined
{code}

There is no simple way to fix this without leveraging dynamic calls for any method call on ""this"" inside a trait, static or not.;;;","06/Mar/15 07:45;melix;Fixed by detecting the error in the trait type checking extension, then converting it into a dynamic method call.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Static Fields Defined In A Trait,GROOVY-7190,12817892,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,02/Dec/14 18:44,23/Dec/14 19:45,14/Jul/23 06:01,05/Dec/14 07:08,2.3.8,,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,,,,,0,,,,,,,"
A problem occurs when a static method defined in a trait attempts to retrieve the value of a static field without using ""this"".  Note that assigning a value to the static field appears to work but retrieving the value does not.

The attached app contains the following code.

{code:title=src/demo/SomeTrait.groovy|borderStyle=solid}
package demo

trait SomeTrait {
    private static String someString

    static String getStringValue() {
        if(someString == null) {
            someString = 'Default Value'
        }
        someString
    }

    static String getStringValueUsingThis() {
        if(this.someString == null) {
            someString = 'Default Value'
        }
        this.someString
    }
}
{code}

{code:title=src/demo/SomeClass.groovy|borderStyle=solid}
package demo

class SomeClass implements SomeTrait {}
{code}

{code:title=test/demo/SomeClassTest.groovy|borderStyle=solid}
package demo

class SomeClassTest extends GroovyTestCase {

    void testStaticPropertyAccess() {
        // this fails
        assert 'Default Value' == SomeClass.stringValue
    }

    void testStaticPropertyAccessUsingThis() {
        // this passes
        assert 'Default Value' == SomeClass.stringValueUsingThis
    }
}
{code}

The test fails with the following:

{noformat}
groovy.lang.MissingMethodException: No signature of method: java.lang.Class.demo_SomeTrait__someString$get() is applicable for argument types: () values: []
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:56)
	at org.codehaus.groovy.runtime.callsite.StaticMetaClassSite.call(StaticMetaClassSite.java:52)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at demo.SomeTrait$Trait$Helper.getStringValue(SomeTrait.groovy:7)
	at demo.SomeTrait$Trait$Helper$getStringValue$0.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at demo.SomeClass.getStringValue(SomeClass.groovy)
{noformat}",,brownj,hubbitus,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"02/Dec/14 18:44;brownj;statictraitproperty.zip;https://issues.apache.org/jira/secure/attachment/12723068/statictraitproperty.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-12-02 18:44:53.0,,,,,,,,,,"0|i2ccxj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
inconsistent stack height error combining @CompileStatic and chained spread-based invocations,GROOVY-7189,12817987,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,chaves,chaves,01/Dec/14 12:47,17/Dec/14 13:25,14/Jul/23 06:01,05/Dec/14 07:29,2.3.4,,,,,,,,,,,,,,,,,2.3.7,,,,,,,,0,,,,,,,"Combining a chain of spread-based calls in a method marked as CompileStatic seems to generate that won't pass verification.

{code}
package bug

import groovy.transform.CompileStatic

class Main2 {
    @CompileStatic
    static void main(String[] args) {
        def List<File> files = []
        def urls = files*.toURI()*.toURL()
        println ""OK!""
    }
}

Main2.main()

{code}

The code above fails with:

{code}
Caught: java.lang.VerifyError: (class: bug/Main2, method: main signature: ([Ljava/lang/String;)V) Inconsistent stack hei
ght 3 != 2
java.lang.VerifyError: (class: bug/Main2, method: main signature: ([Ljava/lang/String;)V) Inconsistent stack height 3 !=
 2
	at bug.test2.run(test2.groovy:14)

{code}

Removing the second use of the spread operator, or replacing any of the occurrences with a use of collect works around the issue.",,melix,rchaves,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 05 07:29:20 UTC 2014,,,,,,,,,,"0|i2cs6f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Dec/14 07:29;melix;This was fixed in 2.3.7.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Resource Leak in GroovyScriptEngine,GROOVY-7186,12817930,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mvmsoft,mvmsoft,27/Nov/14 11:03,15/Oct/15 18:16,14/Jul/23 06:01,22/Dec/14 07:38,2.3.7,,,,,,,,,,,,,,,,,2.3.10,2.4.0-rc-1,,,GroovyScriptEngine,,,,0,,,,,,,"When recompiling dependencies in a script, in certain cases files are not closed.

In GroovyScriptEngine.createCompilationUnit getResourceConnection is called which opens a stream but will never be closed.
Discovered in 2.1.9, still there in 2.3.7.

			for (String depSourcePath : cache.get(""."")) {
				try {
					cache.get(depSourcePath);
		cu.addSource(getResourceConnection(depSourcePath).getURL());
				} catch (ResourceException e) {
					/* ignore */
				}
			}


Stack trace in our unit tests showing the problem:
sun.net.www.protocol.file.FileURLConnection.getInputStream()
groovy.util.GroovyScriptEngine.getResourceConnection(String)
groovy.util.GroovyScriptEngine$ScriptClassLoader.createCompilationUnit(CompilerConfiguration, CodeSource)
groovy.lang.GroovyClassLoader.parseClass(GroovyCodeSource, boolean)
groovy.util.GroovyScriptEngine$ScriptClassLoader.doParseClass(GroovyCodeSource)
groovy.util.GroovyScriptEngine$ScriptClassLoader.parseClass(GroovyCodeSource, boolean)
groovy.lang.GroovyClassLoader.parseClass(String, String)
groovy.util.GroovyScriptEngine.loadScriptByName(String)
groovy.util.GroovyScriptEngine.createScript(String, Binding)
groovy.util.GroovyScriptEngine.run(String, Binding)
de.metus.scripting.groovy.GroovyScriptEngineWrapper.run(URI, String, Map)",,armsargis,blackdrag,mvmsoft,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 22 07:38:53 UTC 2014,,,,,,,,,,"0|i2cn9z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Nov/14 12:18;armsargis;Hi, I sent pull request https://github.com/groovy/groovy-core/pull/540;;;","22/Dec/14 07:38;blackdrag;pull request applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Impossible to override method with generic array of Java class.,GROOVY-7185,12817875,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,abeletsky,abeletsky,27/Nov/14 03:29,01/Feb/17 23:19,14/Jul/23 06:01,04/Jun/16 20:32,2.2.2,2.3.8,2.4.6,,,,,,,,,,,,,,,2.4.8,,,,Compiler,,,,0,compiler,generics,java,,,,"Java classes:
{code}
public interface A<T> {
    T[] process();
}

public class B implements A<String> {
    @Override
    public String[] process() {
        return new String[0];
    }
}
{code}

Groovy class:
{code}
class C extends B {
    @Override
    String[] process() {
        return super.process()
    }
}
{code}

I've got following error during compilation:
{noformat}
Groovy:The return type of [Ljava.lang.String; process() in temp.C is incompatible with [Ljava.lang.Object; process() in temp.B
{noformat}

BTW, I can't convert classes A and B to Groovy because it's library's classes (not mine).","groovy 2.2.2 (tried with 2.3.8)
java openjdk 1.7.0_65

maven 3.2.2
maven-compiler-plugin 3.1
groovy-eclipse-compiler 2.8.0-01
groovy-eclipse-batch 2.1.5-03",abeletsky,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7849,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jun 04 20:32:31 UTC 2016,,,,,,,,,,"0|i2brkv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jun/16 14:38;shils;This happens in 2.4.6 as well, even if A and B are groovy classes.;;;","04/Jun/16 20:32;shils;Fixed by changes for GROOVY-7849. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Compiler Inconsistency,GROOVY-7184,12817931,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,26/Nov/14 13:42,23/Dec/14 19:45,14/Jul/23 06:01,05/Dec/14 08:32,2.4.0-beta-4,,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,Compiler,,,,0,,,,,,,"The attached compile problem.zip contains the following code:

{code:title=src/main/groovy/demo/Config.groovy|borderStyle=solid}
package demo

interface Config {}
{code}

{code:title=src/main/groovy/demo/Holders.groovy|borderStyle=solid}
package demo

class Holders {
    static setConfig(Config cfg) {}
}
{code}

{code:title=src/main/groovy/demo/Helper.groovy|borderStyle=solid}
package demo

class Helper {

    @groovy.transform.CompileStatic
    void test() {

        // with 2.4.0-beta-4 this compiles.
        Config config = new ConfigObject()

        // with 2.4.0-beta-4 this does not compile.
        Holders.config = new ConfigObject()

        // ...with 2.3.7 it all compiles
    }
}
{code}

{noformat}
$ ./gradlew cG
:compileJava UP-TO-DATE
:compileGroovy
startup failed:
/Users/jeff/t/compileproblem/src/main/groovy/demo/Helper.groovy: 12: [Static type checking] - Cannot assign value of type groovy.util.ConfigObject to variable of type demo.Config
 @ line 12, column 9.
           Holders.config = new ConfigObject()
           ^

1 error

:compileGroovy FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileGroovy'.
> Compilation failed; see the compiler error output for details.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 4.552 secs
{noformat}

If I edit build.gradle and change the Groovy version to 2.3.7 it all compiles.

I am not sure why assigning an instance of ConfigObject to a Config reference is allowed.  If it is supposed to be allowed because of some proxy generation or something like that, then I am not sure why the property assignment isn't allowed.



",,brownj,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"26/Nov/14 13:42;brownj;compileproblem.zip;https://issues.apache.org/jira/secure/attachment/12723261/compileproblem.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 05 08:09:04 UTC 2014,,,,,,,,,,"0|i2cq67:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Dec/14 08:09;melix;The reason why this passes is that {{ConfigObject}} implements {{Map}}. Obviously this is not enough to allow such an assignment.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type error when using generic methods and Closures as parameters,GROOVY-7182,12817936,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,gcadien,gcadien,25/Nov/14 11:01,29/Oct/15 18:57,14/Jul/23 06:01,02/Mar/15 06:48,2.3.7,2.4.1,,,,,,,,,,,,,,,,2.3.11,2.4.2,,,Static compilation,,,,1,,,,,,,"{code}
import groovy.transform.CompileStatic
@CompileStatic
class Test {

    static class Inner {
        private String baz
        
        void setBaz(String b) {
            this.baz = b
        }
    }
    
    static <T> T fun(T t) {
        return t
    }
 
    static void main(String[] args) {
        Test.fun({ 1 }).resolveStrategy = Closure.DELEGATE_FIRST
        ((Closure)Test.fun({ 1 })).resolveStrategy = Closure.DELEGATE_FIRST
        Test.fun(new Test.Inner()).baz = 'foo'
        Test.fun('String').contains('ing')
    }
}

Test.main()
{code}

With @CompileStatic this code produces the following error:
[Static type checking] - No such property: resolveStrategy for class: java.lang.Object

Without @CompileStatic the code runs without error.",,acourtneybrown,gcadien,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7648,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 02 05:36:51 UTC 2015,,,,,,,,,,"0|i2co33:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Mar/15 05:36;melix;I think the example can be shortened to this:

{code}
public static <T> T identity(T self) { self }
Closure c = identity {'foo'}
{code}

With type checking, it throws:

{noformat}
Cannot assign value of type java.lang.Object to variable of type groovy.lang.Closure
{noformat}

And it is worth saying that the error only occurs if the argument is a {{Closure}}. Other types work ok.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using a memoized closure with inject corrupts the memoization cache,GROOVY-7181,12811462,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,amordleq,amordleq,25/Nov/14 06:54,23/Dec/14 19:45,14/Jul/23 06:01,01/Dec/14 09:13,2.3.7,,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,,,,,0,,,,,,,"A memoized closure cannot be used in an inject call without causing problems with the memoization cache. 

Here is a contrived example that demonstrates the problem:
{code}
int maxExecutionCount = 0
Closure max = { int a, int b ->
   maxExecutionCount++
   return Math.max(a,b)
}.memoize()

int minExecutionCount = 0
Closure min = { int a, int b ->
   minExecutionCount++
   return Math.min(a,b)
}.memoize()

100.times {
   max.call(max.call(1,2), 3)
}   

100.times {
    [1,2,3].inject(min)
}

assert maxExecutionCount == 2   
assert minExecutionCount == 2
{code}

The second assert fails with an actual minExecutionCount of 101.

I believe what's happening is that inject uses a single argument array and modifies the elements of the array as it iterates over the list.  The argument array used to call a method becomes the key in the memoization cache, so modifying it after the call causes the key to change after it has been put into the cache.  Nothing can ever find this key, since its equals() is no longer consistent with the hashCode() that was used to put the key in the cache.
In case of an org.codehaus.groovy.runtime.memoize.UnlimitedConcurrentCache the cache will grow forever.  In the case of ...LRUCache the cache will be thrashed with any new inject calls.",,amordleq,armsargis,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 01 09:13:34 UTC 2014,,,,,,,,,,"0|i2cfk7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"27/Nov/14 15:35;armsargis;Hi, inject current impl. is

{code}
    public static <E,T, U extends T, V extends T> T inject(Iterator<E> self, U initialValue, @ClosureParams(value=FromString.class,options=""U,E"") Closure<V> closure) {
        T value = initialValue;
        Object[] params = new Object[2];
        while (self.hasNext()) {
            Object item = self.next();
            params[0] = value;
            params[1] = item;
            value = closure.call(params);
        }
        return value;
    }
{code}

and

for memoized used following method to generate key:

{code}
    private static Object generateKey(final Object[] args) {
        if (args == null) return Collections.emptyList();
        return asList(args);
    }
{code}

is its returning as key ArrayList for which we have

{noformat}
Compares the specified object with this list for equality. Returns true if and only if the specified object is also a list, both lists have the same size, and all corresponding pairs of elements in the two lists are equal. (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) In other words, two lists are defined to be equal if they contain the same elements in the same order.

This implementation first checks if the specified object is this list. If so, it returns true; if not, it checks if the specified object is a list. If not, it returns false; if so, it iterates over both lists, comparing corresponding pairs of elements. If any comparison returns false, this method returns false. If either iterator runs out of elements before the other it returns false (as the lists are of unequal length); otherwise it returns true when the iterations complete.
{noformat}

but actual problem in inject impl. itself for each iteration its modifying 'params', it means its modifying cache key itself for for Arrays.asList() we have:

{noformat}
return a list view of the specified array
{noformat};;;","27/Nov/14 15:35;armsargis;I sent 2 pull requests with different fix:  https://github.com/groovy/groovy-core/pull/542 or https://github.com/groovy/groovy-core/pull/541;;;","01/Dec/14 09:13;blackdrag;pull request applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Download links of http://groovy-lang.org/install.html is broken,GROOVY-7180,12817924,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,yukoba,yukoba,19/Nov/14 21:11,01/Mar/15 07:01,14/Jul/23 06:01,01/Mar/15 07:01,,,,,,,,,,,,,,,,,,2.4.1,,,,Documentation,,,,0,,,,,,,"http://groovy-lang.org/install.html

Download links of this part is broken.
{quote}
Download zip: Binary Release | Source Release
Download documentation: JavaDoc and zipped online documentation
Combined binary / source / documentation bundle: Distribution bundle
{quote}",,melix,pschumacher,yukoba,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Mar 01 07:01:02 UTC 2015,,,,,,,,,,"0|i2c6fb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Nov/14 10:11;melix;The reason is that the beta site is currently linked to the ""next"" documentation pages, instead of ""latest"". We will have to switch before making it final.;;;","01/Mar/15 07:01;pschumacher;Thanks for reporting. This is fixed now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Trait missing as a keyword in Groovy documentation,GROOVY-7176,12817870,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,mgrzejszczak,mgrzejszczak,18/Nov/14 16:50,17/Dec/14 13:25,14/Jul/23 06:01,19/Nov/14 20:38,2.3.7,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,Documentation,,,,0,,,,,,,"While looking at http://beta.groovy-lang.org/docs/latest/html/documentation/ I saw the following keywords:


Table 1. Keywords
as
assert
break
case
catch
class
const
continue
def
default
do
else
enum
extends
false
finally
for
goto
if
implements
import
in
instanceof
interface
new
null
package
return
super
switch
this
throw
throws
true
try
while

Shouldn't there be also ""trait"" ?",,mgrzejszczak,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 19 20:38:17 UTC 2014,,,,,,,,,,"0|i2c99r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Nov/14 20:38;paulk;Added 'trait'. Thanks for spotting that.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
jsonslurper does not unescape Strings (sometimes) on parsing with JsonParsingUsingCharacterSource,GROOVY-7173,12817961,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,toconex,toconex,18/Nov/14 09:33,23/Feb/15 01:12,14/Jul/23 06:01,14/Jan/15 14:50,2.3.6,2.4.0-rc-1,,,,,,,,,,,,,,,,2.3.10,2.4.1,,,JSON,,,,0,,,,,,,"Depending on the position of the escape-character JsonParsingUsingCharacterSource.class does not recognize that the string has an escape. To raise this issue the ReaderCharacterSource.findNextChar() must be invoke recursive and the escape-character is not found in last invocation.

{code}
public void findNextCharWithRecursionHadEscape() {
		char[] control = '""\\'.toCharArray()
		
		// create ReaderCharacterSource with a very small buffer, 
		// findNextChar must be invoked recursive
		// use a string where escape-character is in last invokation
		ReaderCharacterSource cs = new ReaderCharacterSource(new StringReader('""value\\u0026""'),6)
		cs.findNextChar((int)control[0],(int)control[1]) 
		// this works
		assertTrue(cs.hadEscape()) 
		
		// use a string where escape-character is in first invokation
		cs = new ReaderCharacterSource(new StringReader('""\\u0026value""'),6)
		cs.findNextChar((int)control[0],(int)control[1]) 
		// this fail
		assertTrue(""ReaderCharacterSource should have detect escape in sequence"",  cs.hadEscape())
	}
{code}

ReaderCharacterSource must keep its property foundEscape if it was true on recursive findNextChar() calls.

 {code:title=groovy.json.internal.ReaderCharacterSource.java-line 231}
 + boolean hasAlreadyFoundEscape = foundEscape;
 char results2[] = findNextChar(match, esc);

 + if(hasAlreadyFoundEscape){
 +      	foundEscape = true; //restore foundEscapeState
 + }
 {code}",,pschumacher,toconex,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/Nov/14 09:33;toconex;ReaderCharacterSourceTest.groovy;https://issues.apache.org/jira/secure/attachment/12723225/ReaderCharacterSourceTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 14 14:50:26 UTC 2015,,,,,,,,,,"0|i2btcf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"30/Dec/14 04:23;pschumacher;Thanks for reporting this and for the suggested fix. :)

I created a [pull request|https://github.com/groovy/groovy-core/pull/578] out of your test and your suggested fix.;;;","14/Jan/15 14:50;pschumacher;I merged the pull request. @Tobias Conrad: Thanks for reporting and thanks for supplying the fix.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC error If we use java.lang.Integer as Target Type with method generics,GROOVY-7170,12817869,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,uehaj,uehaj,15/Nov/14 15:26,22/Feb/16 20:48,14/Jul/23 06:01,15/Nov/15 10:34,2.4.0-beta-3,,,,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,,,,,,,"Target type inference makes an STC Error when the target is java.lang.Integer:

{code}
    static <T> T empty() {..}
    Integer i = empty(); //[Static type checking] - Cannot assign value of type T to variable of type java.lang.Integer
{code}

Even if we specify the type explicitly, STC says same error:
{code}
        Integer i2 = TargetTypeTestGroovy.<Integer>empty(); // [Static type checking] - Cannot assign value of type T to variable of type java.lang.Integer
{code}

If we use java.lang.String instead of java.lang.Integer, it's OK.
Both of cases are worked well in java.
",Groovy Version: 2.4.0-beta-3 JVM: 1.8.0_25 Vendor: Oracle Corporation OS: Mac OS X,pascalschumacher,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"15/Nov/14 15:26;uehaj;TargetTypeTestGroovy.groovy;https://issues.apache.org/jira/secure/attachment/12723189/TargetTypeTestGroovy.groovy","15/Nov/14 15:26;uehaj;TargetTypeTestJava.java;https://issues.apache.org/jira/secure/attachment/12723069/TargetTypeTestJava.java",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 15 10:34:13 UTC 2015,,,,,,,,,,"0|i2cp87:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Nov/15 10:34;pascalschumacher;TargetTypeTestGroovy passes on 2.4.6, therefore I'm closing this issue. Thanks for reporting!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot use array if it is assigned twice,GROOVY-7169,12811457,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,yukoba,yukoba,15/Nov/14 09:01,23/Dec/14 19:45,14/Jul/23 06:01,17/Dec/14 08:35,2.3.7,2.4.0-beta-3,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,Static compilation,,,,0,,,,,,,"Groovy code:
{code}
@groovy.transform.CompileStatic
void test() {
    Number[] ary
    ary = [1] as Integer[]
    ary[0] = null
    ary = [1] as Number[]
}
test()
{code}

This generates this error message.
{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
C:\Users\Yu\Desktop\test2.groovy: 5: [Static type checking] - Cannot call <T,U extends T> java.lang.Integer[]#putAt(int, U) with arguments [int, java.lang.Object]
 @ line 5, column 5.
       ary[0] = null
       ^
{code}

If I remove ""ary = \[1\] as Number\[\]"" the compile error does not happen.
I think this is a flow typing bug.

----

Also If I change this code from ""ary\[0\] = null"" to ""ary\[0\] = 2"",
{code}
@groovy.transform.CompileStatic
void test() {
    Number[] ary
    ary = [1] as Integer[]
    ary[0] = 2
    ary = [1] as Number[]
}
test()
{code}

the error message is this.
{code}
Caught: java.lang.IllegalAccessError: tried to access class org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport$ObjectArrayStaticTypesHelper from class test2
java.lang.IllegalAccessError: tried to access class org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport$ObjectArrayStaticTypesHelper from class test2
        at test2.test(test2.groovy:5)
        at test2.run(test2.groovy:8)
{code}",,yukoba,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-11-15 09:01:15.0,,,,,,,,,,"0|i2bvp3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"I am unable to instantiate objects using the ""new"" keyword",GROOVY-7168,12817907,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,itzkha,itzkha,14/Nov/14 04:17,10/Feb/18 17:32,14/Jul/23 06:01,07/Dec/14 08:43,2.4.0-beta-3,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Groovysh,,,,0,,,,,,,"I am embedding Groovysh in a java application. After some tests, I realized that the ""new"" keyword seems to not work in the last groovysh version. When I try to do:
a = new A()
I obtain: ""unable to resolve class A""

This is an example:

groovy:000> class A {
class A {
groovy:001>   public A() {
public A() {
groovy:002>     name = ""default""
name = ""default""
groovy:003>     }
}
groovy:004>   String name;
String name;
groovy:005>   }
}
===> true
groovy:000> a = new A()
a = new A()
ERROR org.codehaus.groovy.control.MultipleCompilationErrorsException:
startup failed:
script14159599676571305654112.groovy: 1: unable to resolve class A 
 @ line 1, column 5.
   a = new A()
       ^

1 error

However, if I use the newInstance method it works:
groovy:000> a = A.newInstance()
a = A.newInstance()
===> A@2154cecb

I tested the same code in the previous version (2.3.7) and it works
",Linux - Debian jessie/sid 64 bits,erlandm,itzkha,jwagenleitner,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8475,,,,,,,,,,,,,,,,,,,,,,,,,,,"14/Nov/14 04:17;itzkha;testA.groovy;https://issues.apache.org/jira/secure/attachment/12723156/testA.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 09 22:16:19 UTC 2017,,,,,,,,,,"0|i2cf6f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Dec/14 08:35;pschumacher;I changed the label to groovysh because the description says so.;;;","07/Dec/14 08:43;pschumacher;Thanks for reporting. Your example works for me with current master, so I resolve this as fixed in 2.4.0-beta-5.;;;","09/Jun/17 22:16;erlandm;The issue is not resolved. It affects groovysh 2.4.11 and 2.4.10 on GNU/Linux 3.2.0-4-686, Debian 3.2 with both, java-7-openjdk-i386 or java-8-oracle. The bug is not present in groovysh 2.3.11.

To reproduce the problem open groovysh and enter the statements:
class A{}
new A()   // works
a= new A()   // fails with 
script14970460910271311459934.groovy: 1: unable to resolve class A 
 @ line 1, column 4.
   a= new A()
       ^
A a   // also fails:
cript149704620105463554.groovy: 1: unable to resolve class A 
 @ line 1, column 3.
   A a
     ^
Below is the output demonstrating the error with the debug option set:

Groovy Shell (2.4.11, JVM: 1.8.0_131)
Type ':help' or ':h' for help.
----------------------------------------------------------------------------------------------
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[1] for command: :help
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[2] for command: ?
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[3] for command: :exit
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[4] for command: :quit
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[5] for command: import
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[6] for command: :display
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[7] for command: :clear
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[8] for command: :show
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[9] for command: :inspect
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[10] for command: :purge
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[11] for command: :edit
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[12] for command: :load
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[13] for command: .
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[14] for command: :save
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[15] for command: :record
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[16] for command: :history
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[17] for command: :alias
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[18] for command: :set
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[19] for command: :register
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Added completer[20] for command: :doc
DEBUG [org.codehaus.groovy.tools.shell.CommandsMultiCompleter] Refreshing the completer list
DEBUG [org.codehaus.groovy.tools.shell.InteractiveShellRunner] Running
groovy:000> class A{}
DEBUG [org.codehaus.groovy.tools.shell.InteractiveShellRunner] Read line: class A{}
DEBUG [org.codehaus.groovy.tools.shell.RigidParser] Parsing: 
class A{}
DEBUG [org.codehaus.groovy.tools.shell.RigidParser] Parse complete
DEBUG [org.codehaus.groovy.tools.shell.Groovysh] Evaluating buffer...
DEBUG [org.codehaus.groovy.tools.shell.Interpreter] Compiled script: groovysh_evaluate@f0a9da
DEBUG [org.codehaus.groovy.tools.shell.Interpreter] Evaluation result: true (class java.lang.Boolean)
===> true
groovy:000> new A()
DEBUG [org.codehaus.groovy.tools.shell.InteractiveShellRunner] Read line: new A()
DEBUG [org.codehaus.groovy.tools.shell.RigidParser] Parsing: 
new A()
DEBUG [org.codehaus.groovy.tools.shell.RigidParser] Parse complete
DEBUG [org.codehaus.groovy.tools.shell.Groovysh] Evaluating buffer...
DEBUG [org.codehaus.groovy.tools.shell.Interpreter] Compiled script: groovysh_evaluate@1e731e
DEBUG [org.codehaus.groovy.tools.shell.Interpreter] Evaluation result: A@1c407fd (class A)
===> A@1c407fd
groovy:000> A a
DEBUG [org.codehaus.groovy.tools.shell.InteractiveShellRunner] Read line: A a
DEBUG [org.codehaus.groovy.tools.shell.RigidParser] Parsing: 
A a
DEBUG [org.codehaus.groovy.tools.shell.RigidParser] Parse complete
DEBUG [org.codehaus.groovy.tools.shell.Groovysh] Evaluating buffer...
DEBUG [org.codehaus.groovy.tools.shell.InteractiveShellRunner] Work failed: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
script149704352028763554.groovy: 1: unable to resolve class A 
 @ line 1, column 3.
   A a
     ^

1 error

org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
script149704352028763554.groovy: 1: unable to resolve class A 
 @ line 1, column 3.
   A a
     ^

1 error

	at org.codehaus.groovy.control.ErrorCollector.failIfErrors(ErrorCollector.java:310)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:958)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:605)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:554)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:254)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:211)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:221)
	at groovy.lang.GroovyClassLoader$parseClass.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at org.codehaus.groovy.tools.shell.util.ScriptVariableAnalyzer.getBoundVars(ScriptVariableAnalyzer.groovy:110)
	at org.codehaus.groovy.tools.shell.util.ScriptVariableAnalyzer$getBoundVars.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at org.codehaus.groovy.tools.shell.Groovysh.evaluateWithStoredBoundVars(Groovysh.groovy:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:210)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:166)
	at org.codehaus.groovy.tools.shell.Groovysh.execute(Groovysh.groovy:194)
	at org.codehaus.groovy.tools.shell.Shell.leftShift(Shell.groovy:122)
	at org.codehaus.groovy.tools.shell.Shell$leftShift$0.call(Unknown Source)
	at org.codehaus.groovy.tools.shell.ShellRunner.work(ShellRunner.groovy:95)
	at org.codehaus.groovy.tools.shell.InteractiveShellRunner.super$2$work(InteractiveShellRunner.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1213)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:132)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuper0(ScriptBytecodeAdapter.java:152)
	at org.codehaus.groovy.tools.shell.InteractiveShellRunner.work(InteractiveShellRunner.groovy:124)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:210)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:158)
	at org.codehaus.groovy.tools.shell.ShellRunner.run(ShellRunner.groovy:59)
	at org.codehaus.groovy.tools.shell.InteractiveShellRunner.super$2$run(InteractiveShellRunner.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1213)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:132)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuper0(ScriptBytecodeAdapter.java:152)
	at org.codehaus.groovy.tools.shell.InteractiveShellRunner.run(InteractiveShellRunner.groovy:83)
	at java_lang_Runnable$run.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:596)
	at org.codehaus.groovy.tools.shell.Groovysh$run$0.callCurrent(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:166)
	at org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:561)
	at org.codehaus.groovy.tools.shell.Groovysh$run.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
	at org.codehaus.groovy.tools.shell.Main.startGroovysh(Main.groovy:186)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:210)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:71)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
	at org.codehaus.groovy.tools.shell.Main.main(Main.groovy:152)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131)
ERROR org.codehaus.groovy.control.MultipleCompilationErrorsException:
script149704352028763554.groovy: 1: unable to resolve class A 
 @ line 1, column 3.
   A a
     ^

groovy:000> 

;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static Compilation: private static field accessed from a Closure produces a runtime error,GROOVY-7165,12817889,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,ngalarneau,ngalarneau,12/Nov/14 10:57,11/Nov/20 02:00,14/Jul/23 06:01,27/Oct/19 15:46,2.3.7,,,,,,,,,,,,,,,,,,,,,Static compilation,,,,0,,,,,,,"The following code compiles cleanly but throws an exception at runtime.
This code doesn't have a stack trace. The code I simplified this from, did have a stack trace.

If I remove 'private' from staticfield, then it works:

{code}
@CompileStatic
class TestPrivateStaticFieldInClosure extends BaseBug
{
  public static void main(String[] args)
  {
    (new TestPrivateStaticFieldInClosure()).show()
  }
}

@CompileStatic
class BaseBug
{
  private static ArrayList<String> staticfield = new ArrayList<>()

  void show()
  {
    List<Function<List<String>, String>> runners = new ArrayList<>()
    runners.add(new Called())
    List<String> cmds = [""hello""]
    runners.each { cmds.addAll(it.apply(staticfield)) }
    println cmds.size()
  }

  class Called implements Function<List<String>, String>
  {
    @Override
    String apply(List<String> strings) {
      ""groovin""
    }
  }
}
{code}
",,daniel_sun,emilles,ngalarneau,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Oct 27 15:46:58 UTC 2019,,,,,,,,,,"0|i2byx3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Nov/14 12:00;ngalarneau;For the code above, the exception is:

Exception in thread ""main"" org.codehaus.groovy.runtime.metaclass.MissingPropertyExceptionNoStack: No such property: staticfield for class: TestPrivateStaticFieldInClosure

The exception in the original code had a stack trace.;;;","07/Sep/18 18:57;emilles;I have seen the same with static final fields.  Strangely, the implicit-this case fails but the class expression qualifier works just fine.  So it is not that Groovy says no to accessing private members.  It just is failing to resolve to super types for private static fields.

{code:groovy}

class Base {

  private static final String CONST = 'const'

}

class C extends Base {

  static main(args) {

    println Base.CONST // works

    println CONST // throws MissingPropertyException

  }

}
{code};;;","07/Sep/18 23:59;daniel_sun;We should forbidden accessing `private` members from other classes.

{code:java}
class Base {

  private static final String CONST = 'const'

}

class C extends Base {

  static main(args) {

    println Base.CONST // I expect some error here

    println CONST // throws MissingPropertyException

  }

}
{code};;;","21/Sep/18 15:01;emilles;Any chance of getting this fixed for 2.4.x and 2.5.3?  Whether or not private field access should be allowed is a topic for 3+.  As indicated, private field access does work in many cases.  And so I would expect that moving from ""Type.VALUE"" to ""import static Type.VALUE"" paired with ""VALUE"" should work as well.;;;","27/Oct/19 15:46;emilles;I'm unsure of when this was fixed, but it is fixed and tested in current master branch.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic transform gives unexpected result for default constructor,GROOVY-7164,12817909,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,damokles,damokles,12/Nov/14 03:56,19/Oct/15 16:05,14/Jul/23 06:01,13/Sep/15 09:39,2.3.7,2.4.0-rc-1,,,,,,,,,,,,,,,,2.4.5,,,,Static compilation,,,,0,,,,,,,"The following snippet reproduces a type checking error
{code:java}
import groovy.transform.CompileStatic

@CompileStatic
class Test {
    private long timestamp
    
    Date getTimestamp() {
        return timestamp ? new Date(timestamp) : null
    }
    
    void setTimestamp (Date timestamp) {
        this.timestamp = timestamp.time
    }
    
    def main() {
        new Test(timestamp: new Date())
    }
}
{code}

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
test.groovy: 16: [Static type checking] - Cannot assign value of type java.util.Date to variable of type long
 @ line 16, column 27.
           new Test(timestamp: new Date())
                             ^

1 error
{noformat}

This is quite unexpected it should use the type of the getter and setter for the validation since they are used later on to assign the value and not the type of the underlying field.",,damokles,githubbot,keegan,melix,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 13 09:39:44 UTC 2015,,,,,,,,,,"0|i2cd3j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"19/Aug/15 17:03;shils;In your case I think the behavior is expected since field assignment within the owning class isn't delegated to a setter. However, the exception you posted also occurs when invoking the constructor from an external class.

EDIT:
I was wrong; the default constructor uses setters within the declaring class as well. I've updated my pull request accordingly.;;;","19/Aug/15 20:42;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/90

    GROOVY-7164 Check constructor map args on setter parameter type when …

    …outside of declaring class

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7164

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/90.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #90
    
----
commit 2ab8214fbc7323fd79a025502e5afa7fc9ea1e8c
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2015-08-19T20:40:15Z

    GROOVY-7164 Check constructor map args on setter parameter type when outside of declaring class

----
;;;","13/Sep/15 09:39;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/90
;;;","13/Sep/15 09:39;melix;Thanks for the PR!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NoSuchMethodError for varargs when type parameter extends interface,GROOVY-7160,12817887,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,yukoba,yukoba,09/Nov/14 10:15,21/Feb/19 06:18,14/Jul/23 06:01,01/Feb/19 08:03,2.3.7,2.4.0-beta-3,,,,,,,,,,,,,,,,2.5.6,3.0.0-beta-1,,,Static compilation,,,,0,,,,,,,"Java code
{code}
public class Foo<T extends java.io.Serializable> {
    public void bar(T... args) {}
}
{code}

Groovy code
{code}
@groovy.transform.CompileStatic
void test() {
    new Foo<String>().bar(""a"")
}
test()
{code}

Error message
{code}
Caught: java.lang.NoSuchMethodError: Foo.bar([Ljava/lang/Object;)V
java.lang.NoSuchMethodError: Foo.bar([Ljava/lang/Object;)V
        at test.test(test.groovy:3)
        at test.run(test.groovy:5)
{code}

This happens for these two conditions.
1. Foo is a separate class and is not an inner class of the Groovy code
2. T extends interface",,jespersm,paulk,yukoba,,,,,,,,,,,,,"paulk-asert commented on pull request #869: GROOVY-7160: NoSuchMethodError for varargs when type parameter extend…
URL: https://github.com/apache/groovy/pull/869
 
 
   …s interface
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;31/Jan/19 10:28;githubbot;600","asfgit commented on pull request #869: GROOVY-7160: NoSuchMethodError for varargs when type parameter extend…
URL: https://github.com/apache/groovy/pull/869
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;01/Feb/19 06:52;githubbot;600",,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 01 08:03:04 UTC 2019,,,,,,,,,,"0|i2c2zr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"30/Jun/16 18:21;jespersm;Famously, this happens for EnumSet.of(...) when passing more than 5 enums.;;;","02/Jul/16 02:25;paulk;Jesper, do you have a link we can refer to? Might be nice to have that in the issue.;;;","03/Jul/16 12:08;jespersm;Mabye not really famous, but we've run into it a couple of times in our project but never got to the bottom of it...

Simple test snippet:

{code:java}
import static java.nio.file.AccessMode.*

@groovy.transform.CompileStatic
void doStatic() {
    println EnumSet.of(READ,WRITE,EXECUTE,READ,WRITE,EXECUTE)
}

doStatic()
{code};;;","01/Feb/19 08:03;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC claims non-existent Diamond in Anonymous Inner Class with Generics,GROOVY-7159,12817878,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,uehaj,uehaj,08/Nov/14 08:25,21/Jul/15 10:29,14/Jul/23 06:01,07/May/15 20:52,2.4.0-beta-3,,,,,,,,,,,,,,,,,2.4.4,,,,Static Type Checker,,,,0,,,,,,,"In following code, STC error with variable x.
{quote}
[Static type checking] - Cannot use diamond <> with anonymous inner classes
{quote}
But diamond is not used for x.

{code}
interface Cls<T> {
    void foo(T t)
}

@groovy.transform.TypeChecked
def func() {
    Cls<String> x = new Cls<String>(){ // [Static type checking] - Cannot use diamond <> with anonymous inner classes
                                       // why?
        void foo(String t){}
    }
    Cls y = new Cls<String>(){ // OK
        void foo(String t){}
    }
    Cls<String> z = new Cls<>(){ // [Static type checking] - Cannot use diamond <> with anonymous inner classes
                                 // fair enough
        public void foo(String t){}
    }
}

{code}
",Groovy Version: 2.4.0-beta-3 JVM: 1.8.0_25 Vendor: Oracle Corporation OS: Mac OS X,githubbot,shils,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"08/Nov/14 08:25;uehaj;Test.groovy;https://issues.apache.org/jira/secure/attachment/12723254/Test.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 07 20:49:33 UTC 2015,,,,,,,,,,"0|i2c65j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Apr/15 04:14;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/incubator-groovy/pull/1

    GROOVY-7159: STC claims non-existent Diamond in Anonymous Inner Class wi...

    ...th Generics. See https://issues.apache.org/jira/browse/GROOVY-7159
     

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-7159

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/1.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #1
    
----
commit 537c8696c2fff4fbe023c2cbe1fc872f7dee896f
Author: Shil S <shil.sinha@gmail.com>
Date:   2015-04-19T03:57:13Z

    GROOVY-7159: STC claims non-existent Diamond in Anonymous Inner Class with Generics

----
;;;","19/Apr/15 04:20;shils;This seems to be caused by StaticTypeCheckingVisitor not considering the interfaces of an anonymous inner class node when determining diamond usage. I have created a pull request here: https://github.com/apache/incubator-groovy/pull/1;;;","07/May/15 20:49;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/1
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"minus(List, Collection) considers different objects equal if they have equal hashCodes",GROOVY-7158,12817890,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,motto,motto,07/Nov/14 15:55,17/Jul/17 19:10,14/Jul/23 06:01,17/Jul/17 19:10,,,,,,,,,,,,,,,,,,,,,,groovy-jdk,,,,2,,,,,,,"This is essentially a duplicate of GROOVY-4101 and the related ticket GROOVY-4124.

In [org.codehaus.groovy.runtime.DefaultGroovyMethods.minus(Collection<T> self, Collection<?> removeMe)|https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java#L10048]
{noformat}
Comparator<T> numberComparator = new NumberAwareComparator<T>();
...
if (numberComparator.compare(element, (T)elt) == 0) {
  iter.remove();
  elementRemoved = true;
}
{noformat}
objects not implementing [Comparable|http://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html] and without a compareTo method are compared using the [NumberAwareComparator|https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/runtime/NumberAwareComparator.java#L37]
{noformat}
 // since the object does not have a valid compareTo method
// we compare using the hashcodes. null cases are handled by
// DefaultTypeTransformation.compareTo
int x1 = o1.hashCode();
int x2 = o2.hashCode();
if (x1 == x2) return 0;
if (x1 < x2) return -1;
return 1;
{noformat}
which incorrectly removes unequal objects from the original collection.

This is exceedingly frustrating because the results are therefore sporadic and supposedly resolved according to GROOVY-4101 and GROOVY-4124. After a fair amount of head scratching and debugging (on more than 1 occasion) I went looking at the sources on github and it appears the patch has never made it into master. Is it possible the patch was deemed unfit? Was it forgotten about? Is this something I should fix myself?",,jwagenleitner,kekekevin,motto,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 17 19:10:16 UTC 2017,,,,,,,,,,"0|i2cf7b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jul/17 19:10;jwagenleitner;This issue was fixed by the fix for GROOVY-7530 and the [code in question|https://github.com/apache/groovy/blob/6a8232a5ba4fdf89c7c3d1eddba68b909f4a732a/src/main/org/codehaus/groovy/runtime/NumberAwareComparator.java#L53] now compares using {{equals}}.
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompilationError for [[1]] as List<List<Integer>>,GROOVY-7157,12813326,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,yukoba,yukoba,06/Nov/14 14:47,10/Feb/23 21:40,14/Jul/23 06:01,11/Aug/22 20:32,2.3.7,2.4.0-beta-3,,,,,,,,,,,,,,,,3.0.0,,,,Compiler,,,,1,,,,,,,"I can run this code,
{code}
def list = ([[1]] as List<List<Integer>>)
println list
{code}

but cannot run this code.
{code}
def list = [[1]] as List<List<Integer>>
println list
{code}

Error message:
{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
C:\Users\Yu\Desktop\test.groovy: 2: expecting EOF, found 'println' @ line 2, column 1.
   println list
   ^
{code}",,melix,paulk,werickson,yukoba,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 26 11:56:02 UTC 2015,,,,,,,,,,"0|i2ci2v:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"06/Nov/14 15:25;melix;Note that {{as}} is a runtime feature, so even if it lets you define generic types at the grammar level, generics are not reified, so what {{asType}} will see is {{List}}. 
;;;","07/Nov/14 00:23;yukoba;No, what I wanted to say is not there.
I think Groovy is using ANTLR, and there is a bug around parsing this syntax ""as List<List<Integer>>"".;;;","26/Jun/15 02:52;paulk;The grammar also passes these:
{code}
def list = [[1]] as List<List<Integer> >  // note space
def list2 = [[1]] as List<List<Integer>/* */>  // note comment
def list3 = [[1]] as List<List<Integer>>;
def list4 = (List<List<Integer>>)[[1]]
{code}
The same behaviour is noted for binary assignments or declarations, e.g. this is also an error:
{code}
def list
list = [[1]] as List<List<Integer>>
42
{code}
but if the closing brackets are the last thing in the file, then it works, e.g.:
{code}
def list = [[1]] as List<List<Integer>> // passes
{code};;;","26/Jun/15 10:09;paulk;And another example which passes the current parser:
{code}
class Foo {
  def list = [[1]] as List<List<Integer>>
}

assert new Foo().list == [[1]]
{code}
Indicating that field definitions don't suffer the same problem.;;;","26/Jun/15 11:44;paulk;Another example indicating that the problem occurs also for the {{instanceof}} operator.
{code}
// passes
assert [[1]] instanceof List<List<Integer>>
{code}
and this:
{code}
// fails
assert [[1]] instanceof List<List<Integer>>
4
{code};;;","26/Jun/15 11:56;paulk;We currently allow whitespace after a {{>>}} operator, e.g.:
{code}
assert 128 >>
2 == 32
{code}
So, if anything comes after the "">>"" in {{List<List<Integer>>}} then it is matching the shift operator.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java stub generation fails on statically imported field used as annotation parameter,GROOVY-7155,12817863,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,szpak,szpak,05/Nov/14 14:47,08/Mar/22 12:16,14/Jul/23 06:01,29/Oct/21 21:17,2.3.7,,,,,,,,,,,,,,,,,,,,,Stub generator / Joint compiler,,,,0,,,,,,,"groovyc fails to generate compiling Java stub for Groovy classes which use statically imported field as an annotation parameter. E.g.

{code}
import static stub.Constants.CONST1

class GroovyToStub {
    @GroovyAnn(CONST1)  //fails
    void methodToStub() {
    }
}
{code}

{code}
/tmp/groovy-java-stubs/stub/GroovyToStub.java:21: error: cannot find symbol
@stub.GroovyAnn(value=CONST1) public  void methodToStub() { }
                      ^
  symbol:   variable CONST1
  location: class GroovyToStub
1 error
startup failed:
Compilation failed; see the compiler error output for details.

1 error
{code}

A simple workaround is to use Constants.CONST1 with normal import, but in some cases it can reduce original code readability.

Looking briefly at the code there could be missing ""printing"" static imports in JavaStubGenerator.printImports().

Sample project reproducing problem:
https://github.com/szpak/code-examples-and-poc/tree/master/groovy-joint-compilation-issue",,emilles,szpak,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 29 21:17:08 UTC 2021,,,,,,,,,,"0|i2bv0n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Oct/21 21:17;emilles;Static imports are now included in {{printImports}}: https://github.com/apache/groovy/blob/master/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java#L1029;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovyc should accept meta annotation with ElementType.TYPE,GROOVY-7151,12816637,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,szpak,szpak,04/Nov/14 16:55,02/May/17 02:03,14/Jul/23 06:01,12/Mar/15 03:51,2.4.0-beta-3,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,Compiler,,,,0,,,,,,,"groovyc fails on a try to annotate Groovy annotation with an annotation with Target set to TargetType.TYPE.

{code:java}
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Import {
    Class<?>[] value();
}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Import(CorrelationIdConfiguration.class)
public @interface EnableCorrelationId {
}

EnableCorrelationId.groovy: 12: Annotation @org.springframework.context.annotation.Import is not allowed on element ANNOTATION
 @ line 12, column 1.
   @Import(CorrelationIdConfiguration.class)
   ^
{code}

The same works for Java annotations what follows [Java Language Specification|http://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.6.4.1]:
{quote}
Type declarations: class, interface, enum, and annotation type declarations (ÃÂ§8.1.1, ÃÂ§9.1.1, ÃÂ§8.5, ÃÂ§9.5, ÃÂ§8.9, ÃÂ§9.6)

Corresponds to java.lang.annotation.ElementType.TYPE

Additionally, annotation type declarations correspond to java.lang.annotation.ElementType.ANNOTATION_TYPE
{quote}

This is very common in Spring (Boot) application when @Import annotation (which has ElementType.TYPE) is used.

I fixed that and will make a PR in a few minutes (with proper JIRA ticket ID).",,melix,szpak,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7803,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Wed Nov 05 04:51:26 UTC 2014,,,,,,,,,,"0|i2chgv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"04/Nov/14 17:09;szpak;PR: https://github.com/groovy/groovy-core/pull/532;;;","05/Nov/14 02:39;melix;In addition to the grammar changes, supporting this also raises the problem of binary compatibility. So far everything we added to Groovy is compatible on all JDKs, but this one requires special JVM support, which would mean that Groovy would have to provide a compile-time error if the target bytecode level is <8.;;;","05/Nov/14 04:49;szpak;I think that behavior haven't changed since Java 5:
http://docs.oracle.com/javase/1.5.0/docs/api/java/lang/annotation/ElementType.html#TYPE

so no additional runtime check should be required.;;;","05/Nov/14 04:51;melix;Right sorry, I thought you were mentionning the new annotation targets (basically annotations everywhere you can find a type).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Redirection of output in javax.script.ScriptEngine.invokeFunction() doesn't work,GROOVY-7150,12817847,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,shaule,shaule,04/Nov/14 10:53,01/Feb/17 23:19,14/Jul/23 06:01,29/Jun/16 00:11,2.3.6,,,,,,,,,,,,,,,,,2.4.8,,,,groovy-jdk,,,,0,,,,,,,"The Java code below should return a string ""Hello World!"". Instead of that it returns an empty string and prints ""Hello World!"" in the console the application runs. The problem exists only inside functions; texts printed outside functions are redirected properly:

{code:java}
javax.script.ScriptEngineManager manager = new ScriptEngineManager();
javax.script.ScriptEngine engine = manager.getEngineByName(""groovy"");
StringWriter stdOut = new StringWriter();
engine.getContext().setWriter(new PrintWriter(stdOut));
engine.eval(""def myFunction() { print(""Hello World!""); }"");
Invocable invoker = (Invocable) engine;
invoker.invokeFunction(""myFunction"", new Object[0]);
return stdOut.getBuffer().toString();
{code}","Java, Windows, Linux",githubbot,jwagenleitner,shaule,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 29 00:11:14 UTC 2016,,,,,,,,,,"0|i2cpwn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jan/16 00:02;jwagenleitner;added code tags;;;","01/Jan/16 21:31;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/230

    GROOVY-7150 - Redirection of output in javax.script.ScriptEngine.invokeFunction() doesn't work

    Instead of adding `context` and `out` to the engine context this change provides access to those in the `groovy.lang.Binding` to the script class.  This should allow a user to provide their own variables if they wish to override the behavior.  The problem was caused because the `out` variable was being removed from the context (for cleanup reasons), so the cached `MethodClosure` no longer had access to it since it was executed in another method after the `eval` call.
    
    I also added another commit to ensure the factory returned by the engine is the same factory that created it.  I couldn't see a reason why each engine instance should return a new factory.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7150

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/230.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #230
    
----
commit b40cdf3f86b23b6ce4765676f41e73f01d79a78b
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-01-01T20:25:37Z

    GROOVY-7150 - Redirection of output in javax.script.ScriptEngine.invokeFunction() doesn't work

commit 3515a0f5384a4abfce6811911ca0aff01bfa80e3
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-01-01T21:15:03Z

    ScriptEngineFactory returned from ScriptEngine should be same factory that created engine

----
;;;","01/Jan/16 22:13;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/230#discussion_r48680741
  
    --- Diff: subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java ---
    @@ -275,6 +238,19 @@ public Object getVariable(String name) {
                         if (scope != -1) {
                             return ctx.getAttribute(name, scope);
                         }
    +                    // Redirect script output to context writer, if out var is not already provided
    +                    if (""out"".equals(name)) {
    +                        Writer writer = ctx.getWriter();
    +                        if (writer != null) {
    +                            return (writer instanceof PrintWriter) ?
    +                                    (PrintWriter) writer :
    +                                    new PrintWriter(writer, true);
    --- End diff --
    
    This could potentially create lots of temporary `PrintWriter` objects if `ctx.getWriter()` returns a different type.  But the alternative of caching the writer may mean keeping a reference to it longer than necessary.
;;;","29/Jun/16 00:07;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/230
;;;","29/Jun/16 00:11;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic 'Access to <property> is forbidden' with abstract base class and interface,GROOVY-7149,12811461,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mbjarland,mbjarland,04/Nov/14 05:29,17/Dec/14 13:25,14/Jul/23 06:01,04/Nov/14 06:33,2.3.7,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,Static compilation,,,,0,,,,,,,"The CompileStatic annotation incorrectly reports the following error: 

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
compile_static_failure.groovy: 11: Access to Abstract#name is forbidden @ line 11, column 25.
     println ""Y is called $y.name""
                           ^
1 error
{noformat}

when executing the following coce: 

{code}
import groovy.transform.*

test() 

@CompileStatic
def test() {
  I x = new ConcreteA()
  I y = System.currentTimeMillis() % 2 ? new ConcreteA() : new ConcreteB()

  println ""X is called $x.name""
  println ""Y is called $y.name""
}

public class ConcreteA extends Abstract { 
  String name
}

public class ConcreteB extends Abstract { 
  String name
}

abstract class Abstract implements I { 
  //abstract String getName()
}

interface I { 
  String getName()
}
{code}

The same code (plus a few semicolons) compiles fine in Java and also runs fine without the CompileStatic annotation. I haven't analyzed this very deeply, but this feels like a bug in the CompileStatic implementation. 

An interesting note is that for the variable x in the above code, there are no issues when accessing x.name. It seems that the CompileStatic code does type analysis, comes to the conclusion that the concrete type of variable y is either ConcrecteA or ConcreteB, then proceeds to find the largest common deniminator for the two which is abstract class Abstract, and then proceeds to complain about the fact that Abstract does not have method/property 'name'. 

Commenting in the commented out 'abstract String getName()' method on class Abstract 'fixes' the error.","Ubuntu Linux 14.04.1 - 3.13.0-39-generic
Groovy Version: 2.3.7 JVM: 1.8.0_05 Vendor: Oracle Corporation OS: Linux
",mauromol,mbjarland,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-11-04 05:29:22.0,,,,,,,,,,"0|i2c0jr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError when coercing at runtime a method that uses double or long,GROOVY-7146,12816658,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,thejeed,thejeed,03/Nov/14 08:01,17/Dec/14 13:25,14/Jul/23 06:01,04/Nov/14 06:10,2.3.7,,,,,,,,,,,,,,,,,2.2.3,2.3.8,2.4.0-beta-4,,groovy-runtime,,,,0,runtime,traits,,,,,"The error occurs when the following code is executed.

{code:title=DoStuff.groovy|borderStyle=solid}
trait DoStuff {
    public void doStuff(){
        println ""doing stuff here""
    }
}
{code}
{code:title=GBorderPane.groovy|borderStyle=solid}
class GBorderPane extends javafx.scene.layout.BorderPane{
    public GBorderPane(){
        super()
    }
}
{code}
{code:title=TraitsMain.groovy|borderStyle=solid}
class TraitsMain {

    public static void main(String[] args) {
        println ""Java version: ""+System.getProperty(""java.version"")
        GBorderPane gp=new GBorderPane() as DoStuff // VerifyError here
    }
}
{code}

{noformat}
Exception in thread ""main"" java.lang.VerifyError: (class: GBorderPane1_groovyProxy, method: repaint signature: (JIIII)V) Stack size too large
	at java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2663)
	at java.lang.Class.getConstructor0(Class.java:3067)
	at java.lang.Class.getConstructor(Class.java:1817)
	at org.codehaus.groovy.runtime.ProxyGeneratorAdapter.<init>(ProxyGeneratorAdapter.java:192)
	at groovy.util.ProxyGenerator.instantiateDelegateWithBaseClass(ProxyGenerator.java:221)
	at groovy.util.ProxyGenerator.instantiateDelegateWithBaseClass(ProxyGenerator.java:189)
	at groovy.util.ProxyGenerator.instantiateDelegate(ProxyGenerator.java:181)
	at groovy.util.ProxyGenerator.instantiateDelegate(ProxyGenerator.java:177)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.asType(DefaultGroovyMethods.java:12557)
	at org.codehaus.groovy.runtime.dgm$48.doMethodInvoke(Unknown Source)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1207)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1016)
	at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:901)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:884)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:166)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.asType(ScriptBytecodeAdapter.java:589)
	at traits.TraitsMain.main(TraitsMain.groovy:10)
{noformat}","Occurs on 
Ubuntu 14.04.1 LTS x64
Windows 8.1 x64
both use Java 1.8.0u25",melix,thejeed,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 04 06:02:03 UTC 2014,,,,,,,,,,"0|i2cnkv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Nov/14 06:02;melix;This is actually a bug in the proxy generator. It can be reproduces outside of the context of traits with this code:

{code}
interface DoStuff {
}
class Foo {
   void foo(double a, int b) {}
}

def gp=new Foo() as DoStuff
{code}

In any case, runtime traits will generate a proxy, meaning that even if I fix (and I will) this bug, the code won't work as is, because the assignment will fail. See http://docs.groovy-lang.org/latest/html/documentation/core-traits.html#_runtime_implementation_of_traits for a detailed explanation.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Safe navigation operator does not perform null-check for field access under CompileStatic,GROOVY-7145,12817971,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,jespersm,jespersm,03/Nov/14 06:55,17/Dec/14 13:25,14/Jul/23 06:01,04/Nov/14 07:16,2.3.7,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,Static Type Checker,,,,0,,,,,,,"Given this file:

{code:title=SafeNavigation.groovy|borderStyle=solid}
@groovy.transform.CompileStatic
class SafeNavigation {

	String name1
	public String name2
	
    public static void main(String[] args) {
        SafeNavigation test
        
        println test?.name1 // 'null'
        println test?.name2 // NullPointerException
	}
}
{code}

an NPE will be thrown at the second line null safe navigation. Remove the @CompileStatic and the check works as expected.

Or see attached test case.",,jesper@selskabet.org,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/Nov/14 06:55;NullSafeFieldAccessTest.groovy;https://issues.apache.org/jira/secure/attachment/12723192/NullSafeFieldAccessTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-11-03 06:55:48.0,,,,,,,,,,"0|i2c1un:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.json.DateFormatThreadLocal creates a memory leak,GROOVY-7143,12817884,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,jkemnade,jkemnade,30/Oct/14 04:03,17/Dec/14 13:25,14/Jul/23 06:01,06/Nov/14 12:06,2.3.7,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,,,,,0,,,,,,,"A warning is created by Tomcat's memory leak protection:

{code}
30-Sep-2014 09:38:15.637 SEVERE [http-nio-9280-exec-162] org.apache.catalina.loader.WebappClassLoader.checkThreadLocalMapForLeaks The web application [/webapp] created a ThreadLocal with key of type [groovy.json.DateFormatThreadLocal] (value [groovy.json.DateFormatThreadLocal@5cc37e3c]) and a value of type [java.text.SimpleDateFormat] (value [java.text.SimpleDateFormat@faabb360]) but failed to remove it when the web application was stopped. Threads are going to be renewed over time to try and avoid a probable memory leak.
{code}
These problem usually occur when you subclass {{ThreadLocal}} (usually to implement {{initialValue}}). Those classes reference the webapp's classloader. The {{ThreadLocal}} subclass in turn is referenced by each Thread instance (that's how ThreadLocals are implemented, they have a ""helper-Map"" in each Thread instance, so the leak is actually not a tiny Random instance but the whole webapp's classloader with a bunch of class definitions and statically referenced parts of the webapp.
If you don't subclass {{ThreadLocal}} and set the value lazily instead, the problem should be solved.",,jkemnade,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 06 12:06:01 UTC 2014,,,,,,,,,,"0|i2bzbr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Oct/14 04:16;pschumacher;I created a [pull request|https://github.com/groovy/groovy-core/pull/529] with a simple solution. Discussion welcome (as usual). :);;;","31/Oct/14 04:27;jkemnade;This should definitely fix the leak. However, if you're worried about performance, you could as well use a regular (not subclassed) {{ThreadLocal}} and set its value lazily in the {{writeDate}} method.
{code}
private static void writeDate(Date date, CharBuf buffer) {
  SimpleDateFormat formatter = dateFormatter.get();
  if (formatter == null){
    formatter = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ"", Locale.US);
    formatter.setTimeZone(TimeZone.getTimeZone(""GMT""));
    dateFormatter.set(formatter);
  }
  buffer.addQuoted(formatter.format(date));
}
{code};;;","06/Nov/14 12:06;pschumacher;Merged the pull request. Thanks for reporting this issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
type inference problem with List of Interface and List of the class which implements the interface,GROOVY-7142,12817868,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,uehaj,uehaj,29/Oct/14 21:50,03/Feb/22 22:34,14/Jul/23 06:01,29/Oct/21 21:10,2.4.0-beta-3,,,,,,,,,,,,,,,,,4.0.0-beta-1,,,,Static Type Checker,,,,0,,,,,,,"following code (attached) emits [Static type checking] - Incompatible generic argument types. Cannot assign java.util.List <Func> to: java.util.List <IFunc>

{code}
import groovy.transform.TypeChecked

interface IFunc<T> {
    void apply(T t);
}

class Func<T> implements IFunc<T> {
    void apply(T t){}
}

@TypeChecked
def test(IFunc<Integer> f1) {

    List<IFunc<Integer>> list1 = [f1] // OK. type of [f1] is List<IFunc<Integer>>

    IFunc<Integer> f2 = new Func<Integer>()
    List<IFunc<Integer>> list2 = [f2] // [Static type checking] - Incompatible generic argument types. Cannot assign java.util.List <Func> to: java.util.List <IFunc>
                                      // why? type of f1 and f2 looks same.

    IFunc<Integer> f3 = new Func<Integer>() as IFunc<Integer> //with coercion
    List<IFunc<Integer>> list3 = [f3] // OK

    IFunc<Integer> f4 = null
    if (true) {
        f4 = new Func<Integer>()
    }
    List<IFunc<Integer>> list4 = [f4] // OK. but why? type of f3 looks same as type of f2.
    
}

@TypeChecked
def test2() {
    IFunc<Integer> f = new Func<Integer>()
    test(f)
}

test2()
{code}

is this a specification?
above case is for assignment but method parameter passing makes same STC error.",Groovy Version: 2.4.0-beta-1 JVM: 1.8.0_25 Vendor: Oracle Corporation OS: Mac OS X,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Oct/14 21:50;uehaj;error3.groovy;https://issues.apache.org/jira/secure/attachment/12723252/error3.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-10-29 21:50:23.0,,,,,,,,,,"0|i2cb6n:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Calling super.foo() from a closure fails if code is statically compiled,GROOVY-7138,12817843,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,29/Oct/14 04:16,17/Dec/14 13:25,14/Jul/23 06:01,29/Oct/14 05:57,2.3.7,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,,,,,0,,,,,,,"The following code will fail at runtime with a VerifyError:

{code}
class Top {
   int x() { 1 }
}

@groovy.transform.CompileStatic
class Bottom extends Top {
   int x() {
      Thread.start { println(super.x()) }
      2
   }
}

new Bottom().x()
{code}

Removing @CompileStatic fixes the issue. The problem is very likely that the static compiler interprets ""super"" as the super from the closure instead of the super from the owner. Which also means a bridge method might be needed.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-10-29 04:16:32.0,,,,,,,,,,"0|i2c0tr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"NoClassDefFoundError: [Lint;",GROOVY-7133,12817874,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,yukoba,yukoba,28/Oct/14 02:35,17/Dec/14 13:25,14/Jul/23 06:01,30/Oct/14 08:39,2.3.7,2.4.0-beta-3,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,Static compilation,,,,0,,,,,,,"Groovy code.
{code}
@groovy.transform.CompileStatic
void test() { 
    def list = Test2.test2()
    for (def ary : list) {}
}

test()
{code}

Java code.
{code}
import java.util.*;

public class Test2 {
    public static List<int[]> test2() {
        return Arrays.asList(new int[1][1]);
    }
}
{code}

Error message.
{code}
Caught: java.lang.NoClassDefFoundError: [Lint;
java.lang.NoClassDefFoundError: [Lint;
        at test.test(test.groovy:4)
        at test.run(test.groovy:7)
Caused by: java.lang.ClassNotFoundException: int
        ... 2 more
{code}",,yukoba,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-10-28 02:35:55.0,,,,,,,,,,"0|i2bw5j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper throws exception if reader does not fill complete char buffer,GROOVY-7132,12812039,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,martin_s,martin_s,27/Oct/14 17:18,05/Apr/15 14:43,14/Jul/23 06:01,05/Nov/14 05:42,2.3.7,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,JSON,,,,0,,,,,,,"The method JsonSlurper.parse(Reader) throws the following exception:
{code}
groovy.json.JsonException: expecting '}' or ',' but got current char '' with an int value of 0

The current character read is '' with an int value of 0
{code}

if the reader does not always fill the complete char buffer at the method:
{code}
public int read(char[] cbuf, int off, int len) throws IOException
{code}
but returns a {{value < len}} on certain points.

I have provided a test case at 
https://github.com/effrafax/jsonslurp

 A standard use case where this exception occurs:
if you use a http-builder with JSON contentType where the server returns the response chunked (Transfer-Encoding: chunked). The InputStreamReader of the apache http client does not fill the complete char buffer at chunk borders.
",,martin_s,melix,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7028,,,,,,,,,,,,,,,,,,,,,"29/Oct/14 02:32;martin_s;IO.diff;https://issues.apache.org/jira/secure/attachment/12723185/IO.diff","28/Oct/14 16:40;martin_s;IOTest.groovy;https://issues.apache.org/jira/secure/attachment/12723220/IOTest.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Wed Nov 05 05:42:25 UTC 2014,,,,,,,,,,"0|i2c1sv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"28/Oct/14 16:40;martin_s;Test class for groovy.json.internal.IO that reproduces the error.;;;","28/Oct/14 16:41;martin_s;Fix for the error;;;","28/Oct/14 16:42;martin_s;This error seems to be related to GROOVY-7028;;;","28/Oct/14 16:43;martin_s;I may provide a github pull request if this is more convenient.;;;","29/Oct/14 02:32;martin_s;Replaced the diff file;;;","29/Oct/14 04:47;pschumacher;Thanks for reporting this issue and for providing the patch. :)

A pull request would be more convenient. If it does not cause you to much bother to create one.  ;;;","29/Oct/14 06:46;martin_s;Pull request submitted. Please verify:
https://github.com/groovy/groovy-core/pull/528;;;","05/Nov/14 05:42;melix;Thank you. The fix has been backported to 2.3.x.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Generic method declaration should see the super class,GROOVY-7128,12817871,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,yukoba,yukoba,24/Oct/14 08:04,26/Jan/23 22:22,14/Jul/23 06:01,28/Mar/21 18:39,2.3.7,2.4.0-beta-3,,,,,,,,,,,,,,,,2.5.22,3.0.15,4.0.0-alpha-3,,Static Type Checker,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
void test() {
    List<Number> list = [1]
}
{code}

{code}
C:\Users\Yu\Desktop\test.groovy: 3: [Static type checking] - Incompatible generic argument types. Cannot assign java.util.List <java.lang.Integer> to: java.util.List <Number>
 @ line 3, column 25.
       List<Number> list = [1]
                           ^
{code}",,melix,yukoba,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 02 04:08:20 UTC 2014,,,,,,,,,,"0|i2co2f:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"24/Oct/14 08:14;melix;The code should actually be:

{code}
List<? extends Number> list = [1]
{code}

or

{code}
List<Integer> list = [1]
{code}

;;;","24/Oct/14 08:27;yukoba;Java can compile this code, but Groovy fails this code.
{code}
List<Number> list = Arrays.asList(1);
{code}




;;;","30/Oct/14 07:30;melix;Yes, Java can compile this, but it will also fail this:

{code}
List<Integer> l1 = Arrays.asList(1,2,3); // sure, I can do this!
List<Number> l2 = Arrays.asList(1,2,3); // no problem
l2 = l1; // ah, no, you can't, List<Integer> is not List<Number>
{code}

So to be honest, I find the behavior of Java a bit inconsistent.;;;","30/Oct/14 08:32;yukoba;The problem is not there. Arrays.asList() is defined as such.
{code}
public static <T> List<T> asList(T... a) {
{code}
<T> is a generic method declaration.

Therefore, 
{code}
List<Number> list = Arrays.asList(1);
{code}
means
{code}
List<Number> list = Arrays.asList((Number) 1);
{code}

There are two problems here.
1. Groovy should implement the generic method declaration <T> correctly.
2. \[\] and \[:\] should also use the generic method declaration semantics.

For example, this fails too.
{code}
@CompileStatic
class Test {
    static void test() {
        List<Number> list = test2(1)
    }

    static <T> List<T> test2(T t) {
        [t]
    }
}
{code}

Also this is OK in Java,
{code}
public class Test {
    public static void test() {
        test2(Arrays.asList(1));
    }

    public static void test2(List<Number> list) {}
}
{code}

but this fails in Groovy.
{code}
@CompileStatic
class Test {
    static void test() {
        test2([1])
    }

    static void test2(List<Number> list) {}
}
{code};;;","30/Oct/14 08:36;melix;The problem is more that List<Number> list = .... uses target typing while [xxx] is a list literal, inferred by its own.

;;;","02/Nov/14 03:38;yukoba;Theoretically, if you replace \[1, 2\] to createList(1, 2), you can infer the type.
{code}
static <T> List<T> createList(T... args) {
    return new ArrayList<>(Arrays.asList(args));
}
{code};;;","02/Nov/14 03:46;melix;It is the same problem. The type inference engine of Groovy doesn't use target typing. So consider this:

{code}
def list = [1,2] // inferred as List<Integer>
def list = [1, 2d] // inferred as List<Number+Seriaizable>
def list = Arrays.asList(1,2) // inferred as List<Integer>
def list = Arrays.asList(2, 2d)  // inferred as List<Number+Seriaizable>
{code}

This shows that Groovy does *not* rely on the declaration type, in order to provide flow typing. This is a difference from Java, which also makes it a bit stricter, but it also makes it IMHO more understandable (as shown in the example from a previous comment, it will fail in both direct and indirect assignments). I understand it behaves differently from Java, but it makes sense because of LUB inference and flow typing.;;;","02/Nov/14 04:08;yukoba;I think this problem is how to implement generic method inference at Groovy.

I also strongly agree that these should keep as such.
{code}
def list = [1,2] // inferred as List<Integer>
def list = [1, 2d] // inferred as List<Number+Seriaizable>
def list = Arrays.asList(1,2) // inferred as List<Integer>
def list = Arrays.asList(2, 2d)  // inferred as List<Number+Seriaizable>
{code}

But is it impossible to infer these order?
1. Limit the argument and return value types by generic method inference.
2. Infer the type from the object itself. Follow the original flow typing.

This means,
{code}
List<Number> list = Arrays.asList(1, 2)
{code}
first translate to 
{code}
List<Number> list = (List<Number>) Arrays.asList((Number) 1, (Number) 2)
{code}
and keep compiling as the original.
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Dates.isJsonDate only recognizes Javascript Date's toJSON() Format,GROOVY-7127,12817865,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,cy6ergn0m,cy6ergn0m,21/Oct/14 10:30,19/Oct/15 16:12,14/Jul/23 06:01,26/Jun/15 15:20,2.3.3,2.3.7,,,,,,,,,,,,,,,,2.4.4,,,,JSON,,,,1,contrib,,,,,,"groovy.json.internal.Dates#isJsonDate is always returns false for valid JSON date. This causes INDEX_OVERLAY parser to not parse dates even if checkDates was set to true

See the implementation code:
{code}
public static boolean isJsonDate(char[] charArray, int start, int to) {
        boolean valid = true;
        final int length = to - start;

        if (length != JSON_TIME_LENGTH) {
            return false;
        }

        valid &= (charArray[start + 19] == '.');

        if (!valid) {
            return false;
        }
{code}

However valid JSON date looks like:
{noformat}
2014-10-21T15:15:56+0000
{noformat}

so there is no dots in this string so this method will always return false. This consequently leads to groovy.json.internal.CharSequenceValue#doToValue returns string instead of date so parser will never actually parse dates properly


Test example:
{code}
import  groovy.json.*
def o = new JsonSlurper().
    setType(JsonParserType.INDEX_OVERLAY).
        setCheckDates(true).
            parseText(JsonOutput.toJson([a : new Date()]))

assertEquals(Date.class, o.a)
{code}",,cy6ergn0m,githubbot,mmilicevic,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 26 15:13:35 UTC 2015,,,,,,,,,,"0|i2bmd3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Oct/14 12:58;pschumacher;I'm no Json expert, but [http://www.json.org/] does not define a date type.

According to [https://stackoverflow.com/questions/10286204/the-right-json-date-format] it is a suggested practice to use the format emitted by Javascript Date's toJSON method, e.g. 2012-04-23T18:25:43.511Z

It looks like this is the format the groovy Json parser expects.

Why JsonSlurper emits a different format is another question.

I agree that the Json parser should (also) be able to parse the date format generated by JsonSlurper.;;;","21/Oct/14 14:51;cy6ergn0m;My point is that there is functionality provided by [setCheckDates|http://beta.groovy-lang.org/docs/groovy-2.3.0/html/gapi/groovy/json/JsonSlurper.html#setCheckDates%28boolean%29] that doesn't work because of bug

So if JsonOutput generates date in some format then why JsonSlurper can't parse it then even if documented feature enabled?;;;","26/Jun/15 02:49;githubbot;GitHub user bobpaulin opened a pull request:

    https://github.com/apache/incubator-groovy/pull/45

    Groovy 7127

    Patch for https://issues.apache.org/jira/browse/GROOVY-7127  With love from CJUG with help from Cosmin Stroe and Steven Hicks.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/cjug/incubator-groovy GROOVY-7127

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/45.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #45
    
----
commit 2381ccea27233994f4a336d489c1aceea65e5210
Author: bpaulin <bpaulin@bob_paulin>
Date:   2015-06-26T01:01:35Z

    GROOVY-7127 - Added Date Tests

commit b5ed3bf7610c9663a09252f8f821b672a0a8761f
Author: bpaulin <bpaulin@bob_paulin>
Date:   2015-06-26T02:36:09Z

    GROOVY-7127 Allow isJsonDate to accept a date in format
    yyyy-MM-ddThh:mm:ss+0000 since this is how the JsonOutput.toJson method
    formats a date in Groovy.  JSON does not have a standard string output
    per the ECMA spec so both may be accepted.

commit 7e9270b965a2735d87bcc7246cd087d86a27e90e
Author: bpaulin <bpaulin@bob_paulin>
Date:   2015-06-26T02:44:46Z

    GROOVY-7127 - Fixed tabs to spaces.

----
;;;","26/Jun/15 15:13;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/45
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
generic type definition with reference to other type parameter fails to compile,GROOVY-7126,12817829,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,kgeis,kgeis,20/Oct/14 19:21,26/Aug/18 03:35,14/Jul/23 06:01,26/Aug/18 03:35,2.3.6,2.4.15,2.4.5,,,,,,,,,,,,,,,2.5.2,,,,Compiler,,,,0,,,,,,,"This compiles with javac but not with groovyc:
{code:java|title=A.java}
class A<TypeA extends A<TypeA, TypeB>,
        TypeB extends B<TypeB, TypeA>> {
}
{code}
{code:java|title=B.java}
class B<TypeB extends B<TypeB, TypeA>,
        TypeA extends A<TypeA, TypeB>> {
}{code}
{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
A.java: 1: unable to resolve class TypeB 
 @ line 1, column 32.
   class A<TypeA extends A<TypeA, TypeB>,
                                  ^

B.java: 1: unable to resolve class TypeA 
 @ line 1, column 32.
   class B<TypeB extends B<TypeB, TypeA>,
                                  ^

2 errors
{noformat}
",,kgeis,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 26 03:35:05 UTC 2018,,,,,,,,,,"0|i2c8n3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Oct/14 19:34;kgeis;This could have the same root cause as GRECLIPSE-1450.;;;","21/Oct/14 14:52;kgeis;A simpler example:
{code:java|title=A.groovy}
class A<TypeA extends A<TypeA, TypeB>,
        TypeB extends B> { 
}

class B { 
}
{code}
;;;","26/Aug/18 03:35;paulk;This seems to work in 2.5.2 and master. I presume it was fixed in an earlier 2.5.x version. Please re-open if you have any further problems with the latest version of Groovy.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Issue when a the version of a class in local SDK is different from compiled one,GROOVY-7124,12811453,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,arasthel,arasthel,20/Oct/14 05:40,17/Dec/14 13:25,14/Jul/23 06:01,17/Nov/14 08:33,2.4.0-beta-3,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Android,,,,0,android,groovy,,,,,"As of Android 5.0 (API 21), Bundle (http://developer.android.com/reference/android/os/Bundle.html) class now inherits from BaseBundle (http://developer.android.com/reference/android/os/BaseBundle.html), which was added on API 21.

As now `putInt()`, `putString()`, etc. - former *Bundle* methods - are methods of *BaseBundle* which *Bundle* inherits *but not override*, for some reason on API versions lower than 21 when you try to call those methods from a *Bundle object* it will throw:

java.lang.NoClassDefFoundError: android.os.BaseBundle

If you call its constructor, which in API 21 only does:

public Bundle() {
    super();
}

It will work as Groovy still looks for the constructor on that class and while on API lower than 21 the code is different, there is no problem.

So even when the *BaseBundle* class is not there Groovy still tries to call it. If you try to use those methods on a `.java` file they will work flawlessly.",Tried using Groovy Android plugin on Android lower than 5.0 Lollipop. Seems to happen also on 'normal' Groovy code.,arasthel,blackdrag,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Oct/14 08:08;arasthel;GroovyBugTest.zip;https://issues.apache.org/jira/secure/attachment/12723111/GroovyBugTest.zip","30/Oct/14 08:11;arasthel;MainActivity.class;https://issues.apache.org/jira/secure/attachment/12723253/MainActivity.class",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 17 08:33:57 UTC 2014,,,,,,,,,,"0|i2bysn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Oct/14 05:12;melix;I need a few more details for this one:

* is the class that calls methods on Bundle statically compiled?
* can you attach the .class file of a class that calls a method on Bundle and fails?
* can you paste the full stacktrace?
* ideally, do you have a small project that would let me reproduce the issue easily?

Thanks!
;;;","30/Oct/14 08:06;arasthel;-Deleted as the file wasn't the right one-;;;","30/Oct/14 08:08;arasthel;Attached AS project of a crashing API21 project;;;","30/Oct/14 08:11;arasthel;Built crashing groovy class (on APIs lower than 21);;;","30/Oct/14 08:13;arasthel;* Yes, it only happens on @CompileStatic annotated classes, otherwise, it will work fine.
* There you have the compiled .class file of a sample class which calls 'bundle.putInt(""someint"", 1)'.
* Here is the full stack trace: https://ghostbin.com/paste/2sekf
* Also, I attached you a quick project from which that class was taken. The only thing it does is create a new bundle and try to put an in on 'onCreate'.;;;","14/Nov/14 01:51;melix;Ok, so reading the full trace I can see this:

{code}
10-30 13:03:03.649 1101-1101/com.example.arasthel.groovybugtest I/dalvikvm? Could not find method android.os.BaseBundle.putInt, referenced from method com.example.arasthel.groovybugtest.MainActivity.onCreate 10-30 13:03:03.649 1101-1101/com.example.arasthel.groovybugtest W/dalvikvm? VFY: unable to resolve virtual method 5: Landroid/os/BaseBundle;.putInt (Ljava/lang/String;I)V 1
{code}

Which is basically says that the {{onCreate}} method has an invokevirtual {{BaseBundle#putInt}} call. From what you tell me, it makes sense, and I have *no* idea why Java would behave differently on this case: the bytecode references a method which has been added, so if you run it on an older SDK, it doesn't exist and it fails. @blackdrag what do you think?

;;;","14/Nov/14 02:55;arasthel;Since Android must have backwards-compatibility it doesn't really make sense, since it could change from one version to another - as just happened. Instead of translating Bundle#putInt to BaseBundle#putInt directly, I think it should stay as it is. If the Bundle class in the device Android classes replies to the call itself, then it's good, and if it decides to reply using BaseBundle#putInt then it's good, too. 

I'm saying this as it was easy, but I really don't know how Groovy compiler works and if this is as easy as I just said, but it makes a lot more sense to me to keep the original call than to translate it to the selected API losing compatibility.;;;","14/Nov/14 03:02;melix;The problem is that it is not how the Java compiler works, nor the Groovy compiler. I am wondering if there's some post-processing done by the toolchain to retrofit that would be missing in the case of Groovy...;;;","14/Nov/14 03:51;blackdrag;some thoughts... we have Bundle extends BaseBundle and putInt in BaseBundle. And we have a missing method putInt for BaseBundle in a class using Bundle, in the slightly modified version where BaseBundle does not exist.

When doing an invokevirtual you could imho use BaseBundle as well as Bundle as class to make the method call with. It does not matter if it is a subclass, that does not define the method on its own. Java will resolve the call at runtime to the correct class. Now I strongly assume Java uses the declared type as base for the method call. In the code this would be Bundle. A short test shows, that assumption holds... Now the same code in Groovy will use the class the method was declared in, instead of the static class the method is called on by the place of the method call. In other words, Java produces an invokeVirtual for putString using Bundle and Groovy using BaseBundle.

This is not exactly wrong, but of course the Java way is more resistant to class changes. Which means a fix would need to make a change as what base class is used for the method call.;;;","17/Nov/14 06:30;melix;I have pushed a change that should fix this. I am not closing this issue because I still need to handle the case where the receiver implements an interface and that the target method is from the interface, like in the following example:

{code}
interface A{void m()}
class B implements A{void m(){}}
{code}

See https://github.com/groovy/groovy-core/commit/8e7893897e61380f56b4aaa6e828b90b35c8d63b;;;","17/Nov/14 08:33;melix;Turned out to be that the bytecode already generated an invokevirtual call for the last case so I just added a test case: https://github.com/groovy/groovy-core/commit/905b42b225c5e4a58fec2ee6f421f89db60305e6;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
In traits field assignment is not an expression,GROOVY-7123,12817853,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,dsrkoc,dsrkoc,19/Oct/14 18:27,15/Oct/15 18:15,14/Jul/23 06:01,05/Nov/14 03:50,2.3.7,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,,,,,1,traits,,,,,,"Assigning a value to a field in a trait doesn't produce a value as a result:

{code}
trait A {
    def foo
    def bar() { foo = 42 }
}
class C implements A {}

assert new C().bar() == null // should be 42
{code}

Groovy treats assignments as expressions, returning the value from the RHS, but traits break that semantics.

Using the AST Browser it can be seen that {{bar()}} calls {{A$Trait$Helper.bar(this)}}, which in turn calls {{$self.A_foo$set(42)}} which returns {{void}} ({{$self}} is an instance of C) - hence {{null}} that {{bar()}} returns.",,dsrkoc,melix,thejeed,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 20 03:38:28 UTC 2014,,,,,,,,,,"0|i2cj73:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Oct/14 03:18;melix;Thanks. This indicates that the generated $set method when implementing traits should return a value. I will try to confirm that.;;;","20/Oct/14 03:38;dsrkoc;{quote} This indicates that the generated $set method when implementing traits should return a value. {quote}

Yes, that was my idea as well.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checking error at Iterable<T> loop,GROOVY-7122,12817854,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,yukoba,yukoba,18/Oct/14 06:04,17/Dec/14 13:25,14/Jul/23 06:01,22/Oct/14 13:35,2.3.7,2.4.0-beta-3,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,Static Type Checker,,,,0,,,,,,,"I can compile this if I change Iterable to Collection.

{code}
import groovy.transform.CompileStatic

@CompileStatic
class Test {
    static void test(Iterable<Integer> list) {
        for (Integer obj : list) {}
    }
}

Test.test([0])
{code}

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Test.groovy: 6: [Static type checking] - Cannot loop with element of type java.lang.Integer with collection of type java.lang.Iterable <Integer>
 @ line 6, column 9.
           for (Integer obj : list) {}
           ^

1 error
{code}",,blackdrag,yukoba,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 22 13:35:54 UTC 2014,,,,,,,,,,"0|i2cs7j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Oct/14 13:35;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
closure class my contain invalid chars,GROOVY-7120,12817831,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,16/Oct/14 07:06,17/Dec/14 13:25,14/Jul/23 06:01,16/Oct/14 08:50,,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Compiler,,,,0,,,,,,,"{code:Java}
class X {
    def 'foo!bar'() {
        return {}
    }
}
println new X().'foo!bar'().getClass()
{code}
This code fails when creating the closure class, because the generated class name will contain a '!'",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-10-16 07:06:53.0,,,,,,,,,,"0|i2bmsf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Callsite helper class generation cannot handle some methods,GROOVY-7119,12817840,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,16/Oct/14 07:03,17/Dec/14 13:25,14/Jul/23 06:01,16/Oct/14 08:49,,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,groovy-runtime,,,,0,,,,,,,"{code:Java}
class X {
    def 'foo!bar'() {
        return {}
    }
}
println new X().'foo!bar'().getClass()
{code}
This code fails for example in the call site generation code at runtime, because of 2 problems: (a) the helper class will have a name containing ""foo!bar"", which is not valid (b) the invoke instruction will contain ! for the target method, which also seems not to be valid.",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-10-16 07:03:48.0,,,,,,,,,,"0|i2c7nb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Delegate for class that implements interface with Generic Method causes VerifyError,GROOVY-7118,12817856,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,johnrengelman,johnrengelman,15/Oct/14 10:24,21/Jan/15 15:26,14/Jul/23 06:01,05/Jan/15 05:01,2.3.7,2.4.0-beta-3,,,,,,,,,,,,,,,,2.4.0-rc-2,,,,xforms,,,,0,,,,,,,"Using the @Delegate annotation on a class that implements an interface where the interface defines a generic method causes a runtime VerifyError.
This occurs regardless of the interface being defined in Java or Groovy.

Additionally it does not occur if the @Delegate instance does not implement an interface while still defining the same method.

Attached an example project that exhibits the error when trying to run Spock tests using './gradlew test'

{code}
java.lang.VerifyError: Bad return type
Exception Details:
  Location:
    foo/FooSpec.get(Ljava/lang/Class;)Ljava/lang/Throwable; @5: areturn
  Reason:
    Type 'java/lang/Object' (current frame, stack[0]) is not assignable to 'java/lang/Throwable' (from method signature)
  Current Frame:
    bci: @5
    flags: { }
    locals: { 'foo/FooSpec', 'java/lang/Class' }
    stack: { 'java/lang/Object' }
  Bytecode:
    0000000: 2a2b b601 07b0  
{code}","JDK 1.80
JDK 1.7.0_60

Mac OS X",johnrengelman,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"15/Oct/14 10:24;johnrengelman;generic-delegate.tgz;https://issues.apache.org/jira/secure/attachment/12723222/generic-delegate.tgz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 05 05:00:44 UTC 2015,,,,,,,,,,"0|i2cblr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"15/Oct/14 22:32;paulk;Standalone script to replicate the issue:
{code}
interface FooInt {
  public <T extends Throwable> T get(Class<T> clazz) throws Exception
}

class Foo implements FooInt {
  public <T extends Throwable> T get(Class<T> clazz) throws Exception {
    clazz.newInstance()
  }
}

class FooMain {
    @Delegate Foo foo = new Foo()
}

assert new FooMain().get(Exception).class == Exception
{code};;;","15/Oct/14 22:43;paulk;Adding @CompileStatic to FooMain yields this error message:
{noformat}
[Static type checking] - Cannot call <T extends java.lang.Throwable> Foo#get(java.lang.Class <T>) with arguments [java.lang.Class <java.lang.Object>] 
{noformat}
Still thinking through whether this is a different issue or just a consequence of the original issue.;;;","05/Jan/15 05:00;paulk;There is a fix for this in master (and merging for RC2). If you get a chance to test before 2.4 final, that would be great. I'll mark as resolved for now. Let me know if you have any issues.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic: Chained assignment to delegate property broken,GROOVY-7115,12817850,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,eddelplus,eddelplus,13/Oct/14 16:15,17/Dec/14 13:25,14/Jul/23 06:01,30/Oct/14 09:09,2.3.7,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Static compilation,,,,0,,,,,,,"This script failes, unless @CompileStatic is removed:
{code}
import groovy.transform.CompileStatic

test()

@CompileStatic
void test() {

    def obj = new DelegateClass()
    obj.with {
        def locl = prop = ""XYZ""
        assert locl == prop
    }
}

class DelegateClass {
    String prop
}
{code}

Decompiling the class file shows that the inner, right-most assignment to the property of the closure delegate produces a constant null result instead of passing the right hand side result through all chained assignments.","JDK 7u55 on Win7 x64, IntellJ Idea 13.1.5",eddelplus,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-10-13 16:15:29.0,,,,,,,,,,"0|i2ch73:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Stubs Related To Class Which Implements A Trait,GROOVY-7113,12817849,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,10/Oct/14 15:06,17/Dec/14 13:25,14/Jul/23 06:01,04/Nov/14 09:25,2.3.7,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,Stub generator / Joint compiler,,,,1,,,,,,,"The attached traitinheritance.zip file contains the following code:

{code:borderStyle=solid|title=src/main/groovy/demo/DemoTrait.groovy}
package demo

trait DemoTrait {

    int getMagicNumber() {
        42
    }
}
{code}

{code:borderStyle=solid|title=src/main/groovy/demo/DemoClass.groovy}
package demo

class DemoClass implements DemoTrait {}
{code}

All of that compiles as expected.  If I add this class compilation fails:

{code:borderStyle=solid|title=src/main/groovy/demo/DemoSubClass.java}
package demo;

public class DemoSubClass extends DemoClass {}
{code}

Note that the compilation error message doesn't mention the newly created subclass.  It mentions the class that previously compiled without error.

{noformat}
$ ./gradlew clean cG
:clean
:compileJava UP-TO-DATE
:compileGroovy
/Users/jeff/traitinheritance/build/tmp/groovy-java-stubs/demo/DemoClass.java:10: error: DemoClass is not abstract and does not override abstract method getMagicNumber() in DemoTrait
public class DemoClass
       ^
1 error
startup failed:
Compilation failed; see the compiler error output for details.

1 error

:compileGroovy FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileGroovy'.
> Compilation failed; see the compiler error output for details.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 4.378 secs
{noformat}",,brownj,lhotari,thejeed,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Oct/14 15:06;brownj;traitinheritance.zip;https://issues.apache.org/jira/secure/attachment/12723272/traitinheritance.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-10-10 15:06:56.0,,,,,,,,,,"0|i2cccv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Memoized failed to apply for method with variable args,GROOVY-7112,12817837,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,hubbitus,hubbitus,10/Oct/14 09:38,23/Dec/14 19:45,14/Jul/23 06:01,01/Dec/14 09:13,,,,,,,,,,,,,,,,,,2.3.9,2.4.0-rc-1,,,,,,,0,,,,,,,"{code}
import groovy.transform.Memoized

class Test{
    @Memoized
    String some(Integer inp, ...params){
        sleep(3000)
    }
}
{code}

{noformat}
1 compilation error:

Invalid field name. Invalid character at position: 40 of value:  ; in name: memoizedMethodClosure$someIntegerObject;
. At [-1:-1]  at line: -1, column: -1
{noformat}",,armsargis,hubbitus,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 28 04:49:39 UTC 2014,,,,,,,,,,"0|i2chuv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Nov/14 04:10;armsargis;Actually class/interface array java type name generated using following encoding: 'Lclassname;', now for arrays using componentType.class + 'Array' to avoid  ';' invalid character

I sent pull request https://github.com/groovy/groovy-core/pull/543;;;","28/Nov/14 04:40;armsargis;but note that actual memoization will not work because in java 

{code}
(new String[]{""X"", ""B""}).equals(new String[]{""X"", ""B""}) 
{code}

is false, I think developer should aware that method can be memoized only for objects with correct equals() and hashCode();;;","28/Nov/14 04:49;melix;Yes the situation could be improved by leveraging a different Map than LinkedHashMap as the backing cache structure, to use {{Arrays.equals}} for example.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error while popping argument from operand stack tracker,GROOVY-7110,12811451,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,haimat,haimat,09/Oct/14 19:22,17/Dec/14 13:25,14/Jul/23 06:01,20/Oct/14 06:56,2.3.4,2.3.7,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,Static compilation,,,,0,exception,,,,,,"I have the following piece of Groovy code:

{code:title=Test.groovy|borderStyle=solid}
import groovy.transform.CompileStatic

@CompileStatic
class Test
{	
	List<Inner> inners = [new Inner(), new Inner(), new Inner()]
	
	Map test()
	{
		Map systems = [""test1"":0, ""test2"":0, ""test3"":0, ""test4"":0]

		for(i in inners)
		{
			systems[""test1""] += i.l1.size()
			systems[""test2""] += i.l2.size()
			systems[""test3""] += i.l3.size()
			systems[""test4""] += i.l4.size()
		}

		return systems
	}

	class Inner
	{
		List l1 = [1, 2, 3]
		List l2 = [1]
		List l3 = [1, 2]
		List l4 = [1, 2, 3, 4]
	}
}
{code}

Trying to compile it produces this error:

{noformat}
mfb@home:/opt/groovy/bin$ ./groovyc ~/tmp/Test.groovy 
>>> a serious error occurred: BUG! exception in phase 'class generation' in source unit '/home/mfb/tmp/Test.groovy' Error while popping argument from operand stack tracker in class Test method java.util.Map test().
>>> stacktrace:
BUG! exception in phase 'class generation' in source unit '/home/mfb/tmp/Test.groovy' Error while popping argument from operand stack tracker in class Test method java.util.Map test().
	at org.codehaus.groovy.classgen.asm.OperandStack.popWithMessage(OperandStack.java:68)
	at org.codehaus.groovy.classgen.asm.OperandStack.popDownTo(OperandStack.java:52)
	at org.codehaus.groovy.classgen.asm.OperandStack.pop(OperandStack.java:155)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateArrayAssignmentWithOperator(BinaryExpressionHelper.java:551)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateBinaryExpressionWithAssignment(BinaryExpressionHelper.java:567)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionMultiTypeDispatcher.evaluateBinaryExpressionWithAssignment(BinaryExpressionMultiTypeDispatcher.java:358)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:149)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:628)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:610)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:556)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeForInLoop(StaticTypesStatementWriter.java:102)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeForStatement(StatementWriter.java:93)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitForLoop(AsmClassGenerator.java:560)
	at org.codehaus.groovy.ast.stmt.ForStatement.visit(ForStatement.java:47)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:556)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:420)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:377)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:497)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1063)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:231)
	at org.codehaus.groovy.control.CompilationUnit$16.call(CompilationUnit.java:805)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1047)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:583)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:561)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:538)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:59)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:215)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:148)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:178)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:162)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
{noformat}","Oracle JVM 1.8.0_11
Linux 64 bit",blackdrag,haimat,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 20 06:56:04 UTC 2014,,,,,,,,,,"0|i2c6av:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Oct/14 10:59;haimat;Ok, so changing the above sample code to the following ""fixes"" the bug:

{code}
systems[""test1""] = systems[""test1""] + i.l1.size()
systems[""test2""] = systems[""test1""] + i.l2.size()
systems[""test3""] = systems[""test1""] + i.l3.size()
systems[""test4""] = systems[""test1""] + i.l4.size()
{code};;;","18/Oct/14 20:23;pyb;Your original code also works without @CompileStatic:

{noformat}
class Test
{	
	List<Inner> inners = [new Inner(), new Inner(), new Inner()]
	
	Map test()
	{
		Map systems = [""test1"":0, ""test2"":0, ""test3"":0, ""test4"":0]

		for(i in inners)
		{
			systems[""test1""] += i.l1.size()
			systems[""test2""] += i.l2.size()
			systems[""test3""] += i.l3.size()
			systems[""test4""] += i.l4.size()
		}

		return systems
	}

	class Inner
	{
		List l1 = [1, 2, 3]
		List l2 = [1]
		List l3 = [1, 2]
		List l4 = [1, 2, 3, 4]
	}
  
  static void main(String[] argv) {
    println new Test().test()
  }
}
{noformat};;;","19/Oct/14 03:11;paulk;This seems enough to trigger the bug:
{code}
@groovy.transform.CompileStatic
void test() {
    List<Integer> counts = [0]
    counts[0] += 1
}

test()
{code};;;","20/Oct/14 06:56;blackdrag;I changed the dynamic fallback to not to use callsite caching anymore. This fixes the issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Severe Memory Leak Happens when Script Executes,GROOVY-7109,12817755,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,jwagenleitner,daqingllm,daqingllm,08/Oct/14 01:48,01/Feb/17 23:18,14/Jul/23 06:01,11/Sep/16 04:05,2.3.6,,,,,,,,,,,,,,,,,2.4.8,,,,groovy-runtime,,,,1,,,,,,,"     Recently I found my website creates so many classes in permGen. In dump file I can see so many strange classes such as java_util_List$size, java_util_List$subList.

     I don't know what are these classes, so I just call them ""method classes"". The serious thing is that, each ""method class"" has many ""anonymous classes"", such as java_util_List$size$0, java_util_List$size$1, java_util_List$size$2 ... There are over 1,000 java_util_List$size, and over 60,000 class totally in permGen.

     Then I test the groovy script engine and find that when script is excuting, these strange method is created.
     Here is my test code.

{code:title=TodoJava.java|borderStyle=solid}
        ScriptEngineManager m = new ScriptEngineManager();
        ScriptEngine engine = m.getEngineByName(""groovy"");
        CompiledScript script = ((Compilable) engine).compile(new FileReader( ""test-script.groovy"" ));
{code}
     The test-script.groovy file:
{code:title=test-script.groovy|borderStyle=solid}
import cn.ming.youxi.TestClazz

Random random = new Random();
for (i in 1 .. 10) {
    random.nextInt(i);
}
TestClazz testClazz = clazz;
List list = Arrays.asList(
        testClazz.att,
        testClazz.att,
        testClazz.att,
        testClazz.att,
        testClazz.att,
        testClazz.att
);

return list.get(2);
{code}
     TestClazz is a simple class with an Integer attribute. When I call this method, the ""method classes"" is created.
{code:title=TodoJava.java|borderStyle=solid}
        public void run(CompiledScript script) {
            TestClazz testClazz = new TestClazz(new Random().nextInt());
            Map<String, Object> params = new HashMap<String, Object>();
            params.put(""clazz"", testClazz);
            Bindings bindings = engine.createBindings();
            bindings.putAll(params);
            try {
                System.out.println(script.eval(bindings));
            } catch (ScriptException e) {
                e.printStackTrace();
            }
        }
{code}

      But there is only one java_util_List$get and java_util_Random$nextInt no matter how many times I call it. Then I try to execute the script in muti-thread. Here's the code:
{code:title=TodoJava.java|borderStyle=solid}
    static class MyThread extends Thread {
        ScriptEngine engine;
        CompiledScript script;
        public MyThread(ScriptEngine engine, CompiledScript script) {
            this.engine = engine;
            this.script = script;
        }

        public void run() {
            TestClazz testClazz = new TestClazz(new Random().nextInt());
            Map<String, Object> params = new HashMap<String, Object>();
            params.put(""clazz"", testClazz);
            Bindings bindings = engine.createBindings();
            bindings.putAll(params);
            try {
                System.out.println(script.eval(bindings));
            } catch (ScriptException e) {
                e.printStackTrace();
            }
        }
    }
{code}

     And I make 10 thread every 50 ms.
{code:title=TodoJava.java|borderStyle=solid}
    public static void main(String[] args) throws Exception {
        ScriptEngineManager m = new ScriptEngineManager();
        ScriptEngine engine = m.getEngineByName(""groovy"");
        CompiledScript script = ((Compilable) engine).compile(new FileReader( ""test-script.groovy"" ));

        InputStreamReader is_reader = new InputStreamReader(System.in);
        String str = new BufferedReader(is_reader).readLine();

        while (true) {
            for (int i = 0; i < 10; ++i) {
                MyThread myThread = new MyThread(engine, script);
                myThread.start();
            }
            Thread.sleep(50);
        }
    }

{code}

     After a while, I see 90 java_util_List$iterator and 140 java_util_Random$nextInt in dump file! There are also 4  java_util_List$get but they are java_util_List$get$89 to java_util_List$get$92. I guess the rest are collected somehow. Although the ""method classes"" won't increase anymore, but those java_util_List$iterator and java_util_Random$nextInt will never be collected!

     I guess the number of those ""method classes"" is related to the number and frequency of threads excuting the groovy script. Then I try to use groovy class loader to compile a class to excute. I write a TestGroovy.groovy:
{code:title=TestGroovy.groovy|borderStyle=solid}
import cn.ming.youxi.Parent
import cn.ming.youxi.TestClazz

class TestGroovy implements Parent {
    @Override
    void run() {
        Random random = new Random();
        List list = Arrays.asList(

                random.nextInt(),
                random.nextInt(),
                random.nextInt(),
                random.nextInt(),
        )
        list.get(2);
        println(random.nextInt());
    }
}

{code}

     And the code to compile and call it:
{code:title=TodoJava.java|borderStyle=solid}
    public static void main(String[] args) throws Exception {
        GroovyClassLoader loader = new GroovyClassLoader();
        Class clazz = loader.parseClass(new File(""TestGroovy.groovy""));
        Parent parent = (Parent) clazz.newInstance();

        InputStreamReader is_reader = new InputStreamReader(System.in);
        String str = new BufferedReader(is_reader).readLine();

        while (true){
            for (int i = 0; i<10; ++i) {
                MyGroovyClassThread myGroovyClassThread = new MyGroovyClassThread(parent);
                myGroovyClassThread.run();
            }
            Thread.sleep(50);
        }

    }

    static class MyGroovyClassThread extends Thread {
        Parent parent;
        boolean interupt = false;
        public MyGroovyClassThread(Parent parent) {
            this.parent = parent;
        }
        public MyGroovyClassThread(Parent parent, boolean interupt) {
            this.parent = parent;
            this.interupt = interupt;
        }

        public void run() {
            parent.run();
        }
    }
{code}
     There are java_util_Random$nextInt and java_util_List$get all the same. However the number of each ""method class"" is only one.

     I think this is a critical bug in groovy, cause in fact I didn't compile the code many times but the script still creates large number of ""method classes"". If I use groovy script in my server, in order to prevent my website oom, I have to adjust the size of  permgen!

     Here is my all java test code:
{code:title=TodoJava.java|borderStyle=solid}
package cn.ming.youxi;

import groovy.lang.GroovyClassLoader;
import groovy.lang.Script;

import javax.script.*;
import java.io.*;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

public class TodoJava {

    public static void main2(String[] args) throws ScriptException, IOException, InterruptedException {
        ScriptEngineManager m = new ScriptEngineManager();
        ScriptEngine engine = m.getEngineByName(""groovy"");
        CompiledScript script = ((Compilable) engine).compile(new FileReader(""/Users/liming_liu/Documents/workspace/groovy-demo/test-script.groovy""));

        InputStreamReader is_reader = new InputStreamReader(System.in);
        String str = new BufferedReader(is_reader).readLine();

        while (true) {
            for (int i = 0; i < 10; ++i) {
                MyThread myThread = new MyThread(engine, script);
                myThread.start();
            }
            Thread.sleep(50);
        }
    }

    static class MyThread extends Thread {
        ScriptEngine engine;
        CompiledScript script;
        public MyThread(ScriptEngine engine, CompiledScript script) {
            this.engine = engine;
            this.script = script;
        }

        public void run() {
            TestClazz testClazz = new TestClazz(new Random().nextInt());
            Map<String, Object> params = new HashMap<String, Object>();
            params.put(""clazz"", testClazz);
            Bindings bindings = engine.createBindings();
            bindings.putAll(params);
            try {
                System.out.println(script.eval(bindings));
            } catch (ScriptException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main1(String[] args) throws ScriptException, IOException, IllegalAccessException, InstantiationException, InterruptedException {
        GroovyClassLoader loader = new GroovyClassLoader();
        Class clazz = loader.parseClass(new File(""/Users/liming_liu/Documents/workspace/groovy-demo/test-script.groovy""));
        Random random = new Random();
        Script groovyClass = (Script) clazz.newInstance();

        InputStreamReader is_reader = new InputStreamReader(System.in);
        String str = new BufferedReader(is_reader).readLine();

        while (true) {
            for (int i = 0; i < 10; ++i) {
                MyScriptClassThread myThread = new MyScriptClassThread(groovyClass);
                myThread.start();
            }
            Thread.sleep(50);
        }
    }

    static class MyScriptClassThread extends Thread {
        Script groovyClass;
        boolean interupt = false;
        public MyScriptClassThread(Script groovyClass) {
            this.groovyClass = groovyClass;
        }
        public MyScriptClassThread(Script groovyClass, boolean interupt) {
            this.groovyClass = groovyClass;
            this.interupt = interupt;
        }

        public void run() {
            TestClazz testClazz = new TestClazz(new Random().nextInt());
            Map<String, Object> params = new HashMap<String, Object>();
            params.put(""clazz"", testClazz);
            groovyClass.setProperty(""clazz"", testClazz);
            System.out.println(groovyClass.run());
        }
    }


    public static void main(String[] args) throws URISyntaxException, IOException, IllegalAccessException, InstantiationException, InterruptedException {
        GroovyClassLoader loader = new GroovyClassLoader();
        Class clazz = loader.parseClass(new File(""/Users/liming_liu/Documents/workspace/groovy-demo/TestGroovy.groovy""));
        Parent parent = (Parent) clazz.newInstance();

        InputStreamReader is_reader = new InputStreamReader(System.in);
        String str = new BufferedReader(is_reader).readLine();


        while (true){
            for (int i = 0; i<10; ++i) {
                MyGroovyClassThread myGroovyClassThread = new MyGroovyClassThread(parent);
                myGroovyClassThread.run();
            }
            Thread.sleep(50);
        }

    }

    static class MyGroovyClassThread extends Thread {
        Parent parent;
        boolean interupt = false;
        public MyGroovyClassThread(Parent parent) {
            this.parent = parent;
        }
        public MyGroovyClassThread(Parent parent, boolean interupt) {
            this.parent = parent;
            this.interupt = interupt;
        }

        public void run() {
            parent.run();
        }
    }
}

{code}",,daqingllm,jexler,jjensen,jkemnade,jwagenleitner,moshe@egis-software.com,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7683,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 11 04:05:49 UTC 2016,,,,,,,,,,"0|i2bmbz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Oct/14 17:28;pschumacher;Additional information from by Troy Liu in the [closed duplicate of this issue|GROOVY-7121]:

{quote}I've describe the issue in http://jira.codehaus.org/browse/GROOVY-7109 .
Here's the code. Run this and you will see hundreds of java_util_List$get , java_util_List$Iterator and java_util_Random$nextInt .
{code:title=TestClazz.java|borderStyle=solid}
package cn.ming.youxi;

/**
 * Created with IntelliJ IDEA.
 * User: liming_liu
 * Date: 14-9-24
 * To change this template use File | Settings | File Templates.
 */
public class TestClazz {

    private int att = 0;

    public TestClazz(int i) {
        att = i;
    }

    public int getAtt() {
        return att;
    }

}

{code}
{code:title=ScriptEngineTest.java|borderStyle=solid}
package cn.ming.youxi;

import javax.script.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;

/**
 * Created with IntelliJ IDEA.
 * User: liming_liu
 * Date: 14-10-16
 * To change this template use File | Settings | File Templates.
 */
public class ScriptEngineTest {

    private static String FILE_PATH = ""/Users/liming_liu/Documents/workspace/groovy-demo/test-script.groovy"";

    public static void main(String[] args) throws ScriptException, IOException, InterruptedException {
        ScriptEngineManager m = new ScriptEngineManager();
        ScriptEngine engine = m.getEngineByName(""groovy"");
        CompiledScript script = ((Compilable) engine).compile(new FileReader(FILE_PATH));

        InputStreamReader is_reader = new InputStreamReader(System.in);
        String str = new BufferedReader(is_reader).readLine();

        while (true) {
            for (int i = 0; i < 10; ++i) {
                MyThread myThread = new MyThread(engine, script);
                myThread.start();
            }
            Thread.sleep(50);
        }
    }

    static class MyThread extends Thread {
        ScriptEngine engine;
        CompiledScript script;
        public MyThread(ScriptEngine engine, CompiledScript script) {
            this.engine = engine;
            this.script = script;
        }

        public void run() {
            TestClazz testClazz = new TestClazz(new Random().nextInt());
            Map<String, Object> params = new HashMap<String, Object>();
            params.put(""clazz"", testClazz);
            Bindings bindings = engine.createBindings();
            bindings.putAll(params);
            try {
                System.out.println(script.eval(bindings));
            } catch (ScriptException e) {
                e.printStackTrace();
            }
        }
    }
}

{code}
{code:title=test-script.groovy|borderStyle=solid}
import cn.ming.youxi.TestClazz

Random random = new Random();
for (i in 1 .. 10) {
    random.nextInt(i);
}
TestClazz testClazz = clazz;
List list = Arrays.asList(
        testClazz.att,
        testClazz.att,
        testClazz.att,
        testClazz.att,
        testClazz.att,
        testClazz.att
);

return list.get(2);
{code}
{quote};;;","11/Sep/16 04:05;jwagenleitner;Thanks for reporting the issue.  I believe the fix for GROOVY-7683 will fix the issue of preventing OOME, but please re-open if you find that to not be the case.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TypeChecked: cannot use overloaded setters on map based constructor calls,GROOVY-7108,12811445,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,davide.cavestro,davide.cavestro,06/Oct/14 09:33,08/Mar/22 12:16,14/Jul/23 06:01,29/Oct/21 20:53,2.3.6,,,,,,,,,,,,,,,,,,,,,Static Type Checker,,,,1,,,,,,,"It seems that type checking ignores overloaded setters when validating map based constructor invocations, while they are considered valid when the related property is directly assigned.
In fact the following groovy snippet works only if type checking is disabled:

{code:title=snippet.groovy}
import groovy.transform.TypeChecked

class A {
    def data
}

class B {
    A a
    
    void setA(Map m) {//property setter overload
        this.a = m
    }
    void setA(A a) {
        this.a = a
    }
}
//@TypeChecked //newInstance2 compilation would fail
class Foo {
    Map payload
    
    def newInstance1() {
        B b = new B ()
        b.a = payload 
        return b
    }
    
    def newInstance2() {
        new B (a: payload)//[Static type checking] - Cannot assign value of type java.util.Map to variable of type A
    }
}

Map payload = [data: 123]
Foo foo = new Foo(payload: payload)

assert foo.newInstance1().a.data == payload.data
assert foo.newInstance2().a.data == payload.data
{code}",,davide.cavestro,mauromol,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 05 05:27:44 UTC 2014,,,,,,,,,,"0|i2c66n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Oct/14 10:05;melix;Overloaded setters support will come in 2.4. I keep this ticket open because I need to check that it works in this example with current {{master}}.;;;","08/Oct/14 07:38;mauromol;Also {{Object.with(Closure)}} has the same problem with overloaded setters..Actually, the problem is not really due to overloading, but rather to Groovy type checking based on field types rather than getter/setter types. Consider the following:

{code}
class MyProperty<T> {
  T getValue() { ... } 
  void setValue(T value) { ... }
}
{code}

and the following bean class:

{code}
class MyBean {
  MyProperty<String> foo = new MyProperty<String>();

  String getFoo() { return foo.getValue() }
  void setFoo(String value) { foo.setValue(value) }
}
{code}

now, the following client code will fail to pass static type checking, while it works at runtime without {{@TypeChecked}}:

{code}
new MyBean().with { foo = 'hello' }
{code}

The error message says that {{String}} cannot be assigned to a property of type {{MyProperty<String>}}.

This works instead, even if {{@TypeChecked}} is used:
{code}
new MyBean().foo = 'hello'
{code};;;","05/Nov/14 05:27;melix;{{master}} still has the problem, despite the improvements regarding overloaded setters.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Oracle Thin Driver Fails with an Exception in Groovy 2.3.x,GROOVY-7105,12811447,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,,chubbard,chubbard,05/Oct/14 21:58,22/Feb/16 20:48,14/Jul/23 06:01,15/Jan/16 18:18,2.3.0,,,,,,,,,,,,,,,,,2.4.6,,,,groovy-jdk,SQL processing,,,1,,,,,,,"Trying to load the Oracle driver in Groovy fails with the following error:

java.lang.NoClassDefFoundError: oracle/xdb/XMLType
	at java_sql_Connection$getMetaData.call(Unknown Source)
	at db_test.printMetaData(db_test.groovy:9)
	at db_test.printMetaData(db_test.groovy)
	at db_test$printMetaData$0.callCurrent(Unknown Source)
	at db_test.run(db_test.groovy:45)
Caused by: java.lang.ClassNotFoundException: oracle.xdb.XMLType
	... 5 more

This works in Groovy 2.1.x.  This is loading the thin driver which doesn't require extra libraries.  It appears that Groovy loads Oracle's OCI driver which requires these additional jar files and fails.

{code}
import groovy.sql.Sql
import java.sql.ResultSet
import java.sql.DatabaseMetaData

void printMetaData( Sql sql, catalog = null, schema = null ) {
    try {
        DatabaseMetaData metadata = sql.connection.getMetaData()
        
        ResultSet rs = metadata.getCatalogs()
        while( rs.next() ) {
           String catalogName = rs.getString(""TABLE_CAT"")
           println(""${catalogName}"")
        }
        rs.close()
        
        rs = metadata.getSchemas()
        while( rs.next() ) {
           String catalogName = rs.getString(""TABLE_CAT"")
           String schemaName = rs.getString(""TABLE_SCHEM"")
           
           println(""${catalogName}.${schemaName}"")
        }
        rs.close()
        
        def types = [ ""TABLE"" ]
        rs = metadata.getTables( catalog, schema, null, types.toArray( new String[types.size()]) )
        while( rs.next() ) {
           String catalogName = rs.getString(""TABLE_CAT"")
           String schemaName = rs.getString(""TABLE_SCHEM"")
           String tableName = rs.getString(""TABLE_NAME"")
           println(""${catalogName}.${schemaName}.${tableName}"")
        }
        rs.close()
    } finally {
        sql.close()
    }
}

oracle = Sql.newInstance(""jdbc:oracle:thin:@//localhost:1521/PDB1"", ""someUser"", ""somePassword"", ""oracle.jdbc.driver.OracleDriver"")

printMetaData( oracle )
{code}",,belkaram,blackdrag,chubbard,githubbot,guillaume,guindous,jwagenleitner,pascalschumacher,rchaves,vinov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6703,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 15 18:18:28 UTC 2016,,,,,,,,,,"0|i2bvqn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Oct/14 02:01;guillaume;Might be a problem of classloader.
It's often a problem with SQL drivers, hence why (for instance with Grape) we advise using the system classloader:
http://groovy.codehaus.org/Grape;;;","06/Oct/14 09:01;chubbard;But this same program in Java works no problem.  So this is a difference in classloading that groovy has, and it has changed since 2.1 because this same program in Groovy 2.1 works.;;;","20/Nov/14 09:54;guindous;I had the same problem wiht Oracle Driver but when I tried to set sql connection autocommit to false. Ie:
{code}
sql = Sql.newInstance( __jdbcURL, __jdbcUser, __jdbcPassword, __jdbcDriver)
sql.connection.setAutoCommit(false)
{code}

Doing some google search I got the solution from this forum post: https://groups.google.com/d/msg/groovy-user/_w7qoAkKERM/tsOXq0861woJ . Basically using Static Compilation work around this bug. Now, this code work as expected:
{code}
@groovy.transform.CompileStatic
void autoCommitOff(java.sql.Connection conn) {
    conn.setAutoCommit(false)
}

sql = Sql.newInstance( __jdbcURL, __jdbcUser, __jdbcPassword, __jdbcDriver)
autoCommitOff(sql.connection)
{code}

Maybe Guillaume could give a correct explanation why this happens.;;;","01/Dec/14 12:04;chaves;I just found the same issue - the connection is created but any attempt to use it fails with the NoClassDefFoundError mentioned. I tried Java code and Groovy code that do the exact same thing. The Groovy version fails with the error above, the Java version works just fine. Thought it may be related to me creating my own URLClassLoaders, but the test case above does not do that and can reproduce it.

I cannot use the system classloader because I need to be able to load the driver using a dynamically built classpath.;;;","01/Dec/14 12:58;jwagenleitner;Just wanted to note that I worked around this issue by adding Oracle's {{xdb6.jar}} file to my library path.;;;","09/Oct/15 22:08;jwagenleitner;Took another look at this and thought I'd post my findings, hopefully they will help.  This is way over my head, but I suspect it's not a bug and just a consequence of dynamic metaclass processing and SAM conversion.

The type returned from {{getConnection}} is {{oracle.jdbc.driver.T4CConnection}} and ine of it's super class methods is 

{code}public void oracle.jdbc.OracleConnectionWrapper.enqueue(String var1, AQEnqueueOptions var2, AQMessage var3) throws SQLException{code}

During the process of filling the metaclass indexes it passes {{oracle.jdbc.aq.AQMessage}} to the method {{CachedSAMClass#getSAMMethod(Class)}}.  The {{AQMessage}} class is an interface that imports a class that is not contained in the ojdbc6.jar (or ojdbc7.jar) and that exists in the xdb6.jar.  When {{getSAMMethod}} calls {{#getMethods()}} on the {{AQMessage}} class this is when the {{ClassNotFoundException}} is thrown.


;;;","15/Oct/15 15:56;pascalschumacher;I'm closing this after Johns analysis. Thanks!;;;","12/Jan/16 13:31;vinov;I don't think that this should by closed as a *Not A Problem* at all. We encountered simillar issue with a code (parsing excel with poi) that worked in older versions:
{code}
@Grab('org.apache.poi:poi:3.11')
@Grab('org.apache.poi:poi-ooxml:3.11')

stream = new FileInputStream(new File('Any non empty xlsx file path'))
workbook = new org.apache.poi.xssf.usermodel.XSSFWorkbook(stream)
sheet = workbook.getSheetAt(0)
rowIterator = sheet.rowIterator()
println rowIterator.next().getCell(0).toString()
{code}

This results in {{NoClassDefFoundError: org/openxmlformats/schemas/spreadsheetml/x2006/main/CTExtensionList}}, please note this is just an example and we cannot simply add another {{@Grab}}.

*Problem is*, that there are lots of groovy scripts out there between customers, and with a new version of groovy lots of them will stop working. *Modyfing the classpath* is not always simple and it *should not be necessary*, since the extra dependencies are not used and even the *java version* works without them:
{code}
InputStream stream = new FileInputStream(new File(""Any non empty xlsx file path""));
XSSFWorkbook workbook = new org.apache.poi.xssf.usermodel.XSSFWorkbook(stream);
XSSFSheet sheet = workbook.getSheetAt(0);
Iterator<Row> rowIterator = sheet.rowIterator();
rowIterator = sheet.rowIterator();
System.out.println(rowIterator.next().getCell(0).toString());
{code}

Another workaround, {{@CompileStatic}} means modifying lots of old scripts, maybe loosing some functionality and complicating scripts due to some obscure classpath issues. Simply Groovy becoming not so much groovy anymore.

Above all, both _solutions_ are just workarounds, there should be *real fix* to this, so why was this issue closed?;;;","14/Jan/16 08:38;githubbot;GitHub user belkaram opened a pull request:

    https://github.com/apache/groovy/pull/239

    GROOVY-7105 Add try/catch for NoClassDefFoundError

    SAM method resolution can cause loading of classes used in method
    arguments (or as a return type).
    When such a class is not present on a CLASSPATH, it causes a
    NoClassDefFoundError even though the class may actually not be needed
    for program execution.
    
    This is the naive sollution, but I think it may work. It suppresses the NoClassDefFoundError when resolving SAM method, but in the case when the class is really needed for execution, it will throw the exception then.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/belkaram/groovy GROOVY_2_3_X

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/239.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #239
    
----
commit 030b54c8b2151ea21a0505dfe860475ed49835fa
Author: belkaram <ramunas.belkauskas@gmail.com>
Date:   2016-01-13T16:03:45Z

    GROOVY-7105 Add try/catch for NoClassDefFoundError
    
    SAM method resolution can cause loading of classes used in method
    arguments (or as a return type).
    When such a class is not present on a CLASSPATH, it causes a
    NoClassDefFoundError even though the class may actually not be needed
    for program execution.

----
;;;","14/Jan/16 08:48;belkaram;Hi, I also think that this change in class loading semantics should be avoided.
Maybe it would be enough just to wrap the query for class methods (in *CachedSAMClass.getSAMMethod(Class<?> c)*) in simple try/catch and in the case of NoClassDefFoundError return just *null*.

Also GROOVY-6703 seems to be a duplicate.;;;","14/Jan/16 10:45;blackdrag;The problem is that there is a jar, with classes, requiring other classes and those classes are not there. In Java this might not be a problem, because there the order in which classes are loaded is well known enough to be sure, that those missing classes are never requested, unless certain features are used. Well... groovy has to do things different. I am perfectly fine with the try-catch PR, but it is not the case that Groovy does wrong classloading or anything like that here. There are many scenarios in which a construct like that can blow up;;;","14/Jan/16 13:46;chubbard;I have a problem with that logic given that Groovy 2.1 could execute the code WITHOUT exception.  So if Groovy worked in 2.1 then something related to how classes were loaded changed between 2.1 and 2.3 which seems like it's probably more of a bug than a feature given the version number it worked with.  This wasn't prior to 2.0.

Just simply doing a try-catch seems like a potential disguise on top of the originating issue.  Try-catch sounds fine isolated to this incident, but it could result in swallowing legit exceptions without telling you something failed.  Java is so solid in that department.  I've never encountered a time when an exceptions was squelched by the system and there be something wrong.  Debugging through those situations are NOT fun.

Has anyone tried to isolate the differences between 2.1 and 2.3 to track back to the change that was made that introduced this problem?  I think progress can only be made by doing that so we can all understand the change that introduced this, then we can have a productive discussion about if this by design or accidental side effect of fixing other defects, etc.;;;","14/Jan/16 18:30;pascalschumacher;I guess this issue is an unintended side-effect of [implicit closure coercion|http://docs.groovy-lang.org/latest/html/documentation/core-semantics.html#closure-coercion] introduced with [Groovy 2.2|http://groovy-lang.org/releasenotes/groovy-2.2.html].;;;","15/Jan/16 18:18;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Default methods on closures coerced to interfaces don't work,GROOVY-7104,12817754,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,ldaley,ldaley,05/Oct/14 18:59,17/Dec/14 13:25,14/Jul/23 06:01,14/Oct/14 08:20,2.3.7,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,,,,,0,,,,,,,"Seems like the default method doesn't get called, and a stub noop impl is used.

{code}
import java.util.function.Consumer

def consume(Consumer<String> consumer) {
  consumer
    .andThen({ println ""2"" })
    .accept(""foo"")
}

// Works
consume(new Consumer<String>() { void accept(String s) { println ""1"" } })
 
// Fails, andThen() returns null
consume({ println ""1"" })
{code}",,blackdrag,ldaley,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 14 08:20:45 UTC 2014,,,,,,,,,,"0|i2bqy7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Oct/14 07:01;melix;Raising the priority to blocker as it's a blocking problem for Ratpack.;;;","14/Oct/14 08:20;blackdrag;This should work now. It is actually quite difficult to call an interface default method properly from a proxy;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
looping of java.lang.Iterable or java.lang.Iterator objects in CompileStatic mode,GROOVY-7098,12817825,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lhotari,lhotari,04/Oct/14 04:13,17/Dec/14 13:25,14/Jul/23 06:01,08/Oct/14 05:04,,,,,,,,,,,,,,,,,,2.3.8,,,,Static compilation,,,,0,,,,,,,"There are problems in looping of Iterable or Iterator objects in CompileStatic mode. The behaviour is different from dynamic mode.

better example:
{code}
@groovy.transform.CompileStatic
class Iterables {
    Iterable<Object> toIterable(List list) {
        return new Iterable<Object>() {
            Iterator iterator() {
                list.iterator()
            }
        }
    } 
    
    void loopIterable(List list) {
        for(Object o : toIterable(list)) {
            println o
        }
    }
    
    void loopIterator(List list) {
        for(Object o : toIterable(list).iterator()) {
            println o
        }
    }
    
    public static void main(String[] args) {
        new Iterables().loopIterable([1, 2, 3])
        new Iterables().loopIterator([4, 5, 6])
    }
}
{code}

prints
{code}
Iterables$1@6f4d33
java.util.ArrayList$Itr@90ff2a1
{code}

prints in dynamic mode
{code}
1
2
3
4
5
6
{code}

---

EDITED: original example: 

I was able to reproduce the problem with this code example (runnable in GroovyConsole):

{code}
@Grab(""org.yaml:snakeyaml:1.14"")
import org.yaml.snakeyaml.Yaml

@groovy.transform.CompileStatic
class YmlLoader {
    Map map

    @groovy.transform.CompileDynamic
    public void loadYmlDynamic(InputStream input) {
        Yaml yaml = new Yaml()
        for(Object yamlObject : yaml.loadAll(input)) {
            if(yamlObject instanceof Map) {
                map = (Map)yamlObject
            }
        }
    }

    public void loadYmlStatic(InputStream input) {
        Yaml yaml = new Yaml()
        for(Object yamlObject : yaml.loadAll(input)) {
            if(yamlObject instanceof Map) { // problem here with CompileStatic
                map = (Map)yamlObject
            }
        }
    }
}

YmlLoader a = new YmlLoader()
a.loadYmlDynamic new ByteArrayInputStream(""a: 1"".getBytes())
a.map

YmlLoader b = new YmlLoader()
b.loadYmlDynamic new ByteArrayInputStream(""a: 1"".getBytes())
assert a.map == b.map

YmlLoader c = new YmlLoader()
c.loadYmlStatic new ByteArrayInputStream(""a: 1"".getBytes())
assert a.map == c.map
{code}
",,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 08 05:04:56 UTC 2014,,,,,,,,,,"0|i2ccuv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Oct/14 02:28;lhotari;This might not have anything to do with instanceof.

Decompiled code for static method:
{code}
  public void loadYmlStatic(InputStream input) {
    Yaml yaml = new Yaml();
    Object yamlObject = null; for (Iterator localIterator = DefaultGroovyMethods.iterator(yaml.loadAll(input)); localIterator.hasNext(); ) { yamlObject = localIterator.next();
      if ((yamlObject instanceof Map)) {
        localMap = (Map)ScriptBytecodeAdapter.castToType(yamlObject, Map.class); this.map = localMap;
      }
    }
    Map localMap;
  }
{code}

There isn't a method DGM.iterator(Iterable) which seems to be causing the problem.
{code}
    public static Iterator iterator(Object o) {
        return DefaultTypeTransformation.asCollection(o).iterator();
    }
{code}

this method gets selected, and it's obviously the wrong choice.

;;;","08/Oct/14 03:07;lhotari;better example:
{code}
@groovy.transform.CompileStatic
class Iterables {
    Iterable<Object> toIterable(List list) {
        return new Iterable<Object>() {
            Iterator iterator() {
                list.iterator()
            }
        }
    } 
    
    void loopIterable(List list) {
        for(Object o : toIterable(list)) {
            println o
        }
    }
    
    void loopIterator(List list) {
        for(Object o : toIterable(list).iterator()) {
            println o
        }
    }
    
    public static void main(String[] args) {
        new Iterables().loopIterable([1, 2, 3])
        new Iterables().loopIterator([4, 5, 6])
    }
}
{code}

prints
{code}
Iterables$1@6f4d33
java.util.ArrayList$Itr@90ff2a1
{code}

prints in dynamic mode
{code}
1
2
3
4
5
6
{code};;;","08/Oct/14 05:04;melix;I fixed the iterable version, which was indeed a bug, but for the iterator version, @CompileStatic groovy follows the semantics of Java there, which is that you cannot use an Iterator as the collection type. It will therefore call DGM#asIterable on an Iterator, which will return a single element list containing the iterator.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ScriptBase class can't be resolved if not in current directory even if CompilerConf classpath is set,GROOVY-7097,12811444,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,barteczko,barteczko,03/Oct/14 05:40,21/Jul/15 10:30,14/Jul/23 06:01,05/Jul/15 15:10,2.3.0,2.3.1,2.3.2,2.3.3,2.3.5,2.3.6,2.3.7,,,,,,,,,,,2.4.4,,,,Compiler,,,,0,,,,,,,"I have following sample DSLScriptBase,groovy file:
{code}
abstract class DSLScriptBase extends Script {
  def login() {
    println 'login'
  }
}
{code}
and following script test.groovy:

{code}
def conf =  new org.codehaus.groovy.control.CompilerConfiguration()
conf.setScriptBaseClass('DSLScriptBase')
def shell = new GroovyShell (conf)
shell.evaluate('login()')
{code}

It works if DSLScriptBase.groovy is in the same directory as test.groovy.

But if I move DSLScriptBase.groovy to another directory (for example D:/Test) and modify test.groovy adding setClasspath:

{code}
 def conf =  new org.codehaus.groovy.control.CompilerConfiguration()
 def scriptDir = 'd:/Temp'
 conf.setClasspath(scriptDir)
 conf.setScriptBaseClass('DSLScriptBase')
 def shell = new GroovyShell(conf)
 shell.evaluate('login()')
{code}

I've got error: 'unable to resolve class DSLScriptBase'

It works fine in Grovy 2.1.9, but in 2.3.6  I can't figure any way to define script base classes on comp conf classpath (tried to create shell with ClassLoader,  moving scriptbase into some package-subdir, precompile scriptbase - nothing works for me).
Please help :-)
","Windows 7 64 bit, Groovy 2.3.6",barteczko,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7018,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jul 05 15:10:07 UTC 2015,,,,,,,,,,"0|i2cfpb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Oct/14 07:28;barteczko;Updated - this is rather compiler problem and affects all versions started from 2.3.0.;;;","05/Jul/15 15:10;pascalschumacher;The example works for me on current master. I guess the fix for [  GROOVY-7018] also fixed this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovydoc needlessly initialises classes,GROOVY-7096,12817756,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,ldaley,ldaley,ldaley,03/Oct/14 00:58,17/Dec/14 13:25,14/Jul/23 06:01,04/Oct/14 04:08,2.4.0-beta-3,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,,,,,0,,,,,,,,,ldaley,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Oct 04 04:09:53 UTC 2014,,,,,,,,,,"0|i2c85r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Oct/14 01:07;ldaley;PR @ https://github.com/groovy/groovy-core/pull/523;;;","03/Oct/14 19:28;melix;Very good catch. I'm curious how you found this. By accident?;;;","04/Oct/14 04:09;ldaley;I made some changes to the classloading of Groovydoc execution in Gradle to prevent Gradle classes being bled through. We Groovydoc the Gradle codebase with just the compile dependencies. This started failing because we had static initializers that used runtime dependencies.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Semantic of access super fields is not consistent: super.@field == super.field,GROOVY-7094,12817841,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,hubbitus,hubbitus,01/Oct/14 11:20,23/Jul/20 14:16,14/Jul/23 06:01,02/Jul/20 23:37,,,,,,,,,,,,,,,,,,2.5.13,3.0.5,4.0.0-alpha-1,,,,,,0,,,,,,,"Hello.

Operators page describe [Javafield(.@) operator|http://groovy.codehaus.org/Operators#Operators-Javafield(.@)].

Super.@ has been found in experiments and then in comments: http://jira.codehaus.org/browse/GROOVY-5949?focusedCommentId=328216&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-328216 and does not reflected in documentation.

[Groovy beans|http://groovy.codehaus.org/Groovy+Beans] make also differences by accessing fields within or outside class:
{quote}If you access a property from within the class the property is defined in at compile time with implicit or explicit this (for example this.foo, or simply foo), Groovy will access the field directly instead of going though the getter and setter.{quote}

Let's try that code:
{code}
class A{
    def some = '_A.some field direct_';

    def getSome(){
        '-A.getSome()-'
    }
    
    def test(){
        println ""this=$this""
        println ""super=$super""
        println ""this.some: ${this.some}""
        println ""this.@some: ${this.@some}""
    }
}

class B extends A{
    def getSome(){
        '-B.getSome()-'
    }
    
    def test(){
        println ""this=$this""
        println ""super=$super""
        println ""this.some: ${this.some}""
//        println ""this.@some: ${this.@some}"" //groovy.lang.MissingFieldException: No such field: some for class: B
        println ""super.some: ${super.some}""
        println ""super.@some: ${super.@some}""
        println ""super.getSome(): ${super.getSome()}""
    }
}

A a = new A();
B b = new B();

println 'From A:'
a.test()
println ""outside class: a.some: ${a.some}""
println ""outside class: a.@some: ${a.@some}""

println 'From B:'
b.test()
println ""outside class: b.some: ${b.some}""
//println ""outside class: b.@some: ${b.@some}"" // groovy.lang.MissingFieldException: No such field: some for class: B
{code}

Give next output:
{noformat}
From A:
this=A@3179e3cb
super=A@3179e3cb
this.some: _A.some field direct_
this.@some: _A.some field direct_
outside class: a.some: -A.getSome()-
outside class: a.@some: _A.some field direct_
From B:
this=B@538f7b25
super=B@538f7b25
this.some: -B.getSome()-
super.some: -A.getSome()-
super.@some: -A.getSome()-
super.getSome(): -A.getSome()-
outside class: b.some: -B.getSome()-
{noformat}

Some observations:
* this and super refer to one object in base and child class.
* Refer this.@some in child class (and outside class: b.@some) throw ""MissingFieldException: No such field"" as seems correct because B has not field some, but A.
* ""super.@some"" does not throw exception in child class but goes through A setter getSome() exactly as ""super.some"".

My expectation what ""super.@some"" should refer parent class field directly.
But at least documentations needs to be updated for more clear describe that for case of inheritance and access rules with/within parent/childs classes.

Also questionable but may be b.@some should work too? Off course java does not inherit fields and properties, only methods, but in case of generated public getters inherited it is really assumed in groovy, is not?",,emilles,hubbitus,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 01 21:50:24 UTC 2020,,,,,,,,,,"0|i2cckv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jul/20 21:50;emilles;https://github.com/apache/groovy/pull/1291;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError at CompileStatic,GROOVY-7093,12817842,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,yukoba,yukoba,30/Sep/14 10:00,17/Dec/14 13:25,14/Jul/23 06:01,06/Oct/14 06:43,2.3.6,2.4.0-beta-3,,,,,,,,,,,,,,,,2.3.8,,,,Static compilation,,,,0,,,,,,,"{code}
import groovy.transform.CompileStatic

@CompileStatic
class Test {
    static void test() {
        def map = [:]
        println(map[0] ?: (map[0] = 1))
    }
}

Test.test()
{code}

{code}
Caught: java.lang.VerifyError: (class: Test, method: test signature: ()V) Inconsistent stack height 3 != 2
java.lang.VerifyError: (class: Test, method: test signature: ()V) Inconsistent stack height 3 != 2
        at test.run(test.groovy:11)
{code}
",,yukoba,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6984,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-09-30 10:00:37.0,,,,,,,,,,"0|i2ctmv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cloning with AutoClone results in Null Pointer Exception,GROOVY-7091,12811440,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,sukrit007,sukrit007,27/Sep/14 20:31,17/Dec/14 13:25,14/Jul/23 06:01,29/Sep/14 04:41,2.3.5,2.3.6,2.3.7,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,,,,,0,,,,,,,"*Given*:  Two  groovy classes that uses @AutoClone and loaded in order shown below:
{code:title=AutoCloneBug.groovy|borderStyle=solid}
import groovy.transform.AutoClone

@AutoClone
class B {
  String name='B'
}

@AutoClone
class A {
  B b
  String name='A'
}



public static void main(String ... args) {
  B b = new B().clone()

  //Works
  A a1 = new A(b:b).clone()

  //Null Pointer Exception
  A a2 = new A().clone()

}
{code}

*When*: I run this program using Groovy 2.3.5 - 2.3.7
{noformat}
groovy AutoCloneBug.groovy
{noformat}

*Then*: It results in Null Pointer Exception.
{noformat}
Caught: java.lang.NullPointerException: Cannot invoke method clone() on null object
java.lang.NullPointerException: Cannot invoke method clone() on null object
	at com.meltmedia.cdp.orch.B$clone.call(Unknown Source)
	at com.meltmedia.cdp.orch.A.clone(AutoCloneBug.groovy)
	at com.meltmedia.cdp.orch.A$clone.call(Unknown Source)
	at AutoCloneBug.run(AutoCloneBug.groovy:25)
{noformat}

*Note*:
The issue seems to be in 
[https://github.com/groovy/groovy-core/blob/GROOVY_2_3_7/src/main/org/codehaus/groovy/transform/AutoCloneASTTransformation.java#L241]

We possibly need to check for null using [ifS|https://github.com/groovy/groovy-core/blob/GROOVY_2_3_7/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java#L488] .

Also if we reverse the order of A and B, the issue goes away. Possible because AutoClone transformation thinks at that point that B [does not implement Cloneable| https://github.com/groovy/groovy-core/blob/GROOVY_2_3_7/src/main/org/codehaus/groovy/transform/AutoCloneASTTransformation.java#L246] .","Java: Oracle 1.8.0_20
Linux: Ubuntu 14.04",hubbitus,paulk,sukrit007,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 29 04:41:11 UTC 2014,,,,,,,,,,"0|i2c8hr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Sep/14 04:41;paulk;Thanks for spotting that. Should be fixed in the next release.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@TupleConstructor and @Builder should be able to use defined setters rather than the field directly,GROOVY-7087,12817817,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,hubbitus,hubbitus,24/Sep/14 04:45,03/Dec/17 19:19,14/Jul/23 06:01,12/Mar/15 18:43,2.3.6,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,xforms,,,,0,,,,,,,"{code}
import groovy.transform.TupleConstructor
import groovy.transform.ToString
import groovy.transform.InheritConstructors
import groovy.transform.builder.Builder
import groovy.transform.builder.SimpleStrategy

@Builder(builderStrategy=SimpleStrategy, prefix='with')
@TupleConstructor
@ToString
class Person{
    String name;

    void setName(String n){
        println ""Called setName(n=$n)""
        name = n;
    }
}

println Person.constructors

println  ( [ new Person(name: 'Map style'), new Person('@TupleConsructor'), new Person().with{ name = 'With style'; it }, new Person().withName('@Builder') ] )
{code}
In output we get:
{noformat}
Called setName(n=Map style)
Called setName(n=With style)
[Person(Map style), Person(@TupleConsructor), Person(With style), Person(@Builder)]
{noformat}

So, all forms of new object instatiation like Map-style, With block became different with new methods, defined by AST transformations.",,hubbitus,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 03 19:19:43 UTC 2017,,,,,,,,,,"0|i2bv9r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Sep/14 04:54;hubbitus;Sorry for bug editing.

I think it is similary to GROOVY-4844.;;;","27/Dec/14 00:23;paulk;Proposed pull request here:
https://github.com/groovy/groovy-core/pull/566

Setters containing business logic have their place but in some circumstances can be a bit of a code smell. See for example, comments here:
http://stackoverflow.com/questions/8501735/using-setter-methods-in-constructor-bad-practice
http://stackoverflow.com/questions/4893558/calling-setters-from-a-constructor

The PR allows setter logic to be enabled. It is up to the user of this feature to avoid some of the bad style pitfalls.;;;","12/Mar/15 18:43;paulk;PR merged. There is now an optional ""useSetters"" boolean to achieve the behavior you desire. Thanks for the suggestion.;;;","13/Mar/15 04:49;hubbitus;Thank you very much.;;;","03/Dec/17 19:19;hubbitus;Thank you, [~paulk]!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ShortTypeHandling: java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.String,GROOVY-7086,12817830,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,kasten,kasten,23/Sep/14 10:12,01/Feb/17 23:19,14/Jul/23 06:01,28/Aug/16 21:00,2.3.0,,,,,,,,,,,,,,,,,2.4.8,,,,groovy-runtime,,,,0,,,,,,,"I'm getting this error using groovy and JasperReports, when I use a field with a bean property that is a java.lang.Class.

It seams that the implementation is not compatible:

/** NOW IT IS LIKE THIS */
{code}
    public static Class castToClass(Object object) {
        if (object==null) return null;
        if (object instanceof Class) return (Class) object;
        try {
            return Class.forName(object.toString());
        } catch (Exception e) {
            throw new GroovyCastException(object, Class.class, e);
        }
    }

    public static String castToString(Object object) {
        if (object==null) return null;
        if (object instanceof Class) return (String) object; // CLASS CAST IS HERE!
        return object.toString();
    }
{code}


/** I THINK IT SHOULD BE */
{code}
    public static String castToString(Object object) {
        if (object==null) return null;
        if (object instanceof Class) return ((Class)object).getName(); 
/* 
to be compatible with the reverse operation (castToClass) thats do Class.forName(), right? 
*/
        return object.toString();
    }
{code}

thanks, in advance!","Tomcat 7.0.x, jdk 1.6",blackdrag,kasten,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 28 21:00:59 UTC 2016,,,,,,,,,,"0|i2bscf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Sep/14 16:36;blackdrag;I must say, I have no idea where this came from. Maybe it was supposed to check for String instead of Class.;;;","07/Dec/14 08:46;pschumacher;@blackdrag: So should we do something about this?;;;","28/Aug/16 21:00;paulk;Should be fixed as part of:
https://github.com/apache/groovy/commit/4f328a1
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Minor typos in section ""GroovyDoc comment""",GROOVY-7084,12817820,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,dkarr,dkarr,22/Sep/14 12:34,25/Jun/15 09:17,14/Jul/23 06:01,22/Oct/14 12:38,2.3.1,,,,,,,,,,,,,,,,,2.3.7,,,,Documentation,,,,0,,,,,,,"(I'm probably going to do a scan through the entire ""Groovy Language Documentation"" page, at http://beta.groovy-lang.org/docs/groovy-2.3.1/html/documentation/ . This is just the first comment. I did the same for the Gradle User Guide, but I was able to submit all of my recommendations in a single PR. If you want me to do this, and you'd like me to do it in a more efficient way, please tell me.)

In the ""GroovyDoc comment"" section, there are two minor typos.

The section starts with:
""Similarly to multiline comments, GroovyDoc comments are multiline, but start with /** and end with \*/. Lines following the first GroovyDoc comment line can optionally start with a star \*. Those comments are associated with:""

The two occurrences of ""\"" (backslash) in ""\*/"" and ""\*"" should be removed.
",,dkarr,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 25 09:17:29 UTC 2015,,,,,,,,,,"0|i2bnpz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Sep/14 11:46;dkarr;I'm starting to work through the steps required to fork and branch the repo, and editing the ""adoc"" files. I've barely gotten into chapter one and found quite a few typos and somewhat unclear statements.  If I submit an entire pass on the existing doc in a single PR, it will be quite large.  Should I break this up into multiple PRs, or what?;;;","30/Sep/14 16:31;paulk;Sorry no one responded earlier. Smaller PRs are usually easier to handle. If a large PR has one or two contentious changes it might be delayed.;;;","30/Sep/14 18:07;dkarr;No problem.  I already concluded that.  My first set of small comments on a single chapter have already been merged.;;;","22/Oct/14 12:38;pschumacher;I'm closing this, as David provided a pull request which fixed the issues. Thanks!

@David: Further pull request are welcome of course. :);;;","25/Jun/15 09:17;paulk;Also David, please see: GROOVY-7470
It would be great if you could action. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"PermGen memory leak in ConfigSlurper.parse(Script script, URL location)",GROOVY-7083,12817798,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,daniel_sun,erdi,erdi,21/Sep/14 06:35,10/Apr/18 13:02,14/Jul/23 06:01,23/Mar/18 01:25,2.3.6,2.4.1,,,,,,,,,,,,,,,,2.5.0-rc-1,2.6.0-alpha-4,3.0.0-alpha-2,,groovy-jdk,,,,0,,,,,,,"The following will quite quickly result in a java.lang.OutOfMemoryError: PermGen space:
{code}
while(true) {
    new ConfigSlurper().parse("""")
}
{code}

This is due to ConfigSlurper.parse(Script script, URL location) modifying meta class of the compiled config script class and not clearing it afterwards which means that there is reference to that class in meta class registry and it never gets garbage collected.

The exception does not occur for the following:
{code}
while (true) {
    new ConfigSlurper() {
        ConfigObject parse(Script script, URL location) {
            def config = super.parse(script, location)
            GroovySystem.metaClassRegistry.removeMetaClass(script.class)
            config
        }
    }.parse("""")
}
{code}",,daniel_sun,erdi,jkemnade,jwagenleitner,lari.hotari@sagire.fi,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/Mar/18 10:53;daniel_sun;GROOVY-7083.png;https://issues.apache.org/jira/secure/attachment/12915875/GROOVY-7083.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 23 10:54:37 UTC 2018,,,,,,,,,,"0|i2bpan:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Dec/14 03:30;pschumacher;I created a [pull request|https://github.com/groovy/groovy-core/pull/564] containing Marcins solution.;;;","08/Mar/15 01:04;pschumacher;I closed the pull request, because of Cedrics comment:

{quote}The fix looks suspicious to me. The metaclass should not be a strong metaclass, hence collectible by the GC. Rather than explicitly removing it from the registry, we need to investigate why it is not collected.{quote};;;","10/May/17 06:31;jkemnade;I can reproduce this with 2.4.11.;;;","15/May/17 07:14;jkemnade;I let the script run with 1000 iterations and took a heap dump. It contains about 180k instances of {{MetaMethodIndex$Entry}}.
They look like this:
{noformat}
this     - value: org.codehaus.groovy.runtime.metaclass.MetaMethodIndex$Entry #177145
 <- [251]     - class: org.codehaus.groovy.runtime.metaclass.MetaMethodIndex$Entry[], value: org.codehaus.groovy.runtime.metaclass.MetaMethodIndex$Entry #177145
  <- table     - class: org.codehaus.groovy.runtime.metaclass.MetaMethodIndex, value: org.codehaus.groovy.runtime.metaclass.MetaMethodIndex$Entry[] #1009
   <- metaMethodIndex     - class: groovy.lang.ExpandoMetaClass, value: org.codehaus.groovy.runtime.metaclass.MetaMethodIndex #1009
    <- strongMetaClass     - class: org.codehaus.groovy.reflection.ClassInfo, value: groovy.lang.ExpandoMetaClass #987
     <- value     - class: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$EntryWithValue, value: org.codehaus.groovy.reflection.ClassInfo #1239
      <- [0]     - class: java.lang.Object[], value: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$EntryWithValue #1239
       <- [65]     - class: java.lang.Object[], value: java.lang.Object[] #139278
        <- table     - class: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Segment, value: java.lang.Object[] #111688
         <- [14]     - class: org.codehaus.groovy.util.AbstractConcurrentMapBase$Segment[], value: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Segment #15
          <- segments     - class: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Map, value: org.codehaus.groovy.util.AbstractConcurrentMapBase$Segment[] #1
           <- map     - class: org.codehaus.groovy.reflection.GroovyClassValuePreJava7, value: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Map #1
            <- globalClassValue     - class: org.codehaus.groovy.reflection.ClassInfo, value: org.codehaus.groovy.reflection.GroovyClassValuePreJava7 #1
{noformat}
;;;","15/May/17 16:37;jwagenleitner;I think the original [pull request|https://github.com/groovy/groovy-core/pull/564] should be reconsidered since {{ExpandoMetaClasses}} are strong metaclasses.;;;","23/Mar/18 01:25;daniel_sun;Fixed by: https://github.com/apache/groovy/commit/8cb3793498199d9fcff32484e5208f311f94cad4;;;","23/Mar/18 10:54;daniel_sun;*Here is the snapshot of heap dump when OOME ocurred:*

!GROOVY-7083.png!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Compiler Error Message And Conflicting Trait Methods,GROOVY-7081,12817747,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,19/Sep/14 10:26,23/Jul/15 15:50,14/Jul/23 06:01,08/Oct/14 03:54,2.3.3,,,,,,,,,,,,,,,,,2.3.8,,,,Compiler,,,,0,,,,,,,"{code:title=SomeTrait.groovy|borderStyle=solid}
trait SomeTrait {
    int getMagicNumber() {
        42
    }
}
{code}

{code:title=SomeClass.groovy|borderStyle=solid}
class SomeClass implements SomeTrait {
    static magicNumber = 'Forty Two'
}
{code}

{noformat}
$ groovyc SomeClass.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
SomeClass.groovy: 1: Can't have an abstract method in a non-abstract class. The class 'SomeClass' must be declared abstract or the method 'int getMagicNumber()' must be implemented.
 @ line 1, column 1.
   class SomeClass implements SomeTrait {
   ^

1 error

trait $ groovy -version
Groovy Version: 2.3.3 JVM: 1.7.0_45 Vendor: Oracle Corporation OS: Mac OS X
{noformat}

If the code that adds the trait method figures out that it can't or won't add the method, it seems like the system should have enough context at that point to report why and give the user better feedback.
",,brownj,keegan,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7520,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-09-19 10:26:15.0,,,,,,,,,,"0|i2cixb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException compiling fully qualified reference to 'this' of outer class inside inner class,GROOVY-7077,12817822,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,denis_murashev,denis_murashev,18/Sep/14 02:55,02/May/17 02:03,14/Jul/23 06:01,13/Dec/15 01:32,2.3.4,2.3.6,,,,,,,,,,,,,,,,2.3.11,2.4.0,,,Compiler,,,,1,,,,,,,"Compiling a class with inner class,  using the ClassName.this syntax causes an error in the compiler.

The problem can be reproduced with following simple code fragment:

{code}
class BrokenGroovy {

  def user = new Object() {
    def field = BrokenGroovy.this
  }
}
{code}
",,denis_murashev,jwagenleitner,mauromol,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 13 01:32:15 UTC 2015,,,,,,,,,,"0|i2bnpr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Sep/14 03:00;denis_murashev;The possible fix is here: https://github.com/DenisMurashev/groovy-core/compare/GROOVY-7077;;;","18/Sep/14 03:09;melix;Double checked on 2.3.6, still occurs:

{code}
Exception thrown

BUG! exception in phase 'semantic analysis' in source unit 'ConsoleScript0' null
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:927)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:585)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:534)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:286)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:259)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:674)
	at groovy.lang.GroovyShell.run(GroovyShell.java:501)
	at groovy.lang.GroovyShell.run(GroovyShell.java:481)
	at groovy.lang.GroovyShell.run(GroovyShell.java:164)
	at groovy.lang.GroovyShell$run$0.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:977)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:278)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1016)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure.call(Closure.java:417)
	at groovy.lang.Closure.run(Closure.java:504)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.control.ResolveVisitor.checkThisAndSuperAsPropertyAccess(ResolveVisitor.java:821)
	at org.codehaus.groovy.control.ResolveVisitor.transformPropertyExpression(ResolveVisitor.java:791)
	at org.codehaus.groovy.control.ResolveVisitor.transform(ResolveVisitor.java:637)
	at org.codehaus.groovy.ast.ClassCodeExpressionTransformer.visitField(ClassCodeExpressionTransformer.java:65)
	at org.codehaus.groovy.control.ResolveVisitor.visitField(ResolveVisitor.java:179)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.control.ResolveVisitor.visitClass(ResolveVisitor.java:1202)
	at org.codehaus.groovy.control.ResolveVisitor.startResolving(ResolveVisitor.java:142)
	at org.codehaus.groovy.control.CompilationUnit$11.call(CompilationUnit.java:643)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:923)
	... 26 more
{code};;;","13/Dec/15 01:32;jwagenleitner;Tested with version 2.3.7-11 and confirmed fixed in 2.3.11.  Also verified it's fixed in 2.4.0-5.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Safe Navigation operator does not perform null check with @CompileStatic on interface type not declaring getter,GROOVY-7075,12811964,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,gillius,gillius,17/Sep/14 09:21,19/Oct/15 16:53,14/Jul/23 06:01,24/Sep/14 08:14,2.3.6,,,,,,,,,,,,,,,,,2.3.7,,,,Static compilation,,,,0,,,,,,,"The following code produces NullPointerException when compiled static, but operates as expected when running in dynamic groovy:

{code}
import groovy.transform.CompileStatic
@Grapes(
  @Grab(group='org.springframework.security', module='spring-security-core', version='3.2.5.RELEASE')
)
import org.springframework.security.core.context.SecurityContextHolder

@CompileStatic
def checkSafeNavi() {
  println SecurityContextHolder
  //class org.springframework.security.core.context.SecurityContextHolder
  println SecurityContextHolder.context
  //org.springframework.security.core.context.SecurityContextImpl@ffffffff: Null authentication
  println SecurityContextHolder.context?.authentication
  //null
  println SecurityContextHolder.context?.authentication?.name
  //NullPointerException
}

checkSafeNavi()
{code}

Thanks to Thibault Kruse for producing a minimal reproducible version.

Here is another test case that doesn't use Spring Security or any other dependency. This hopefully should be able to be transformed directly into a unit test for Groovy:

{code}
//If Y was a class implementing YParent, it works
//If Y had the getValue method directly, it works
//If Y redeclares (overrides) getValue, it works
interface Y extends YParent {
}

interface YParent {
 int getValue()
}

@groovy.transform.CompileStatic
def check() {
  Y y = null
  println y?.value
}

check()
{code}",,aaronzirbes,gillius2,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 19 16:53:01 UTC 2015,,,,,,,,,,"0|i2c3dr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Sep/14 09:24;melix;Raised priority to critical.;;;","19/Oct/15 16:53;aaronzirbes;This appears to still be an issue.  I ran into it when using a Retrofit interface that returned an in with @CompileStatic in Groovy 2.4.5;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DelegatingScript does not work with Builder as delegate,GROOVY-7074,12817801,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,tschulte,tschulte,16/Sep/14 14:55,22/Feb/16 20:48,14/Jul/23 06:01,28/Dec/15 07:26,2.4.0-beta-3,,,,,,,,,,,,,,,,,2.4.6,,,,GroovyScriptEngine,,,,2,patch-available,,,,,,"DelegatingScript does not work, if the delegate is e.g. a MarkupBuilder instance.

    import org.codehaus.groovy.control.CompilerConfiguration
    import groovy.xml.MarkupBuilder

    def cc = new CompilerConfiguration()
    cc.scriptBaseClass = DelegatingScript.class.name
    def sh = new GroovyShell(new Binding(), cc)
    def script = sh.parse('''
    foo {
        bar()
    }
    ''')
    def markupBuilder = new MarkupBuilder()
    script.setDelegate(markupBuilder)
    script.run()

does throw a groovy.lang.MissingMethodException. If I change the script to

    delegate.foo {
        bar()
    }

it works.","Windows 7, Linux Mint 16 Petra",bgoetzmann,blackdrag,githubbot,jkemnade,pascalschumacher,shils,tschulte,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7499,GROOVY-7689,,,,,,,,,,,,,,,,"26/Nov/15 08:46;jkemnade;0001-GROOVY-7074-fix-for-using-a-Builder-as-delegate-in-a.patch;https://issues.apache.org/jira/secure/attachment/12774486/0001-GROOVY-7074-fix-for-using-a-Builder-as-delegate-in-a.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 28 07:26:10 UTC 2015,,,,,,,,,,"0|i2c3bj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"17/Sep/14 02:09;tschulte;Workaround:

[...]
def scriptFile = [...]
def script = sh.parse(""delegate.with { $scriptFile.text }"")
[...];;;","10/Jul/15 11:51;jkemnade;Still an issue with 2.4.3. ;;;","10/Jul/15 12:31;jkemnade;What about changing {{DelegatingScript}} to call {{InvokerHelper.invokeMethod(delegate, name, args)}} instead of {{metaClass.invokeMethod(delegate,name,args)}}?;;;","23/Jul/15 11:27;jkemnade;Test and fix for {{GROOVY_2_4_X}} branch;;;","23/Jul/15 13:55;blackdrag;do you have an explanation as of why it works with InvokerHelper and not with metaClass? Because InvokerHelper is supposed to do the same in the end. The only reason I could imagine that would make a difference here is, that the meta class changed. Is that the case? And if DelegatingScript is supposed to react to that, then there are a lot more places to be fixed.;;;","23/Jul/15 14:16;jkemnade;No, the metaclass doesn't seem to change, at lest it's the same before and after the script's execution. I think the reason is that for a Builder (and any other object that overrides {{groovy.lang.GroovyObjectSupport.invokeMethod(String, Object)}}), we need to invoke the {{invokeMethod}} method on the Builder itself and not on the metaClass. {{InvokerHelper#invokePogoMethod}} does that in line 920 (2.4.4).;;;","06/Oct/15 07:43;jkemnade;still in 2.4.5;;;","06/Oct/15 09:19;githubbot;GitHub user PascalSchumacher opened a pull request:

    https://github.com/apache/incubator-groovy/pull/131

    GROOVY-7074: fix for using a Builder as delegate in a DelegatingScript

    created out of patch https://issues.apache.org/jira/browse/GROOVY-7074 submitted by Jochen Kemnade

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/PascalSchumacher/incubator-groovy GROOVY-7074

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/131.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #131
    
----
commit 646e6584642b225dfff5e19450961848326f24f3
Author: Jochen Kemnade <jochen.kemnade@eddyson.de>
Date:   2015-07-23T11:25:57Z

    GROOVY-7074: fix for using a Builder as delegate in a DelegatingScript

----
;;;","15/Oct/15 07:31;pascalschumacher;@Jochen What do you think of the patch / pull request?;;;","15/Oct/15 12:39;blackdrag;I feel uneasy about this fixing the issue, because GroovyObject#invokeMethod is normally called through the meta class path and we want to avoid using InvokerHelper... So even if this does fix the issue I am not really happy with it. But since there is probably no time to investigate further I guess I have to give my ok after all;;;","17/Nov/15 17:22;shils;If we ultimately just want a GroovyObject's invokeMethod to have precedence over its metaClass' invokeMethod, perhaps changing DelegatingScript#invokeMethod to something like this would be better? 

{code}
public Object invokeMethod(String name, Object args) {
    try {
        if (delegate instanceof GroovyObject) {
            return ((GroovyObject) delegate).invokeMethod(name, args);
        }
        return metaClass.invokeMethod(delegate, name, args);
    } catch (MissingMethodException mme) {
        return super.invokeMethod(name, args);
    }
}
{code};;;","22/Nov/15 10:34;githubbot;Github user PascalSchumacher closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/131
;;;","26/Nov/15 08:48;jkemnade;New patch based on [~shils]'s suggestions. [~blackdrag], what do you think?;;;","26/Nov/15 09:26;jkemnade;That behavior should probably be used for {{get/setProperty}} too, I'll create a new patch.;;;","26/Nov/15 10:13;jkemnade;On second thought, that is not within the scope of this issue and I don't have a valid use case for {{get/setProperty}} yet.;;;","20/Dec/15 12:48;githubbot;GitHub user PascalSchumacher opened a pull request:

    https://github.com/apache/groovy/pull/216

    GROOVY-7074: DelegatingScript does not work with Builder as delegate

    Patch supplied by Jochen Kemnade

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/PascalSchumacher/incubator-groovy GROOVY-7074

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/216.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #216
    
----
commit d2b9a05a4db922dfefcd9c1b04593758cdc02ad1
Author: PascalSchumacher <pascalschumacher@gmx.net>
Date:   2015-12-20T12:47:22Z

    GROOVY-7074: DelegatingScript does not work with Builder as delegate
    
    Patch supplied by Jochen Kemnade

----
;;;","28/Dec/15 07:24;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/216
;;;","28/Dec/15 07:26;pascalschumacher;Patch applied. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException in phase 'instruction selection' when using spread-dot operator on an array in static compilation mode,GROOVY-7072,12817809,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,erdi,erdi,13/Sep/14 03:22,17/Dec/14 13:25,14/Jul/23 06:01,24/Sep/14 11:17,2.3.6,,,,,,,,,,,,,,,,,2.3.7,,,,Static compilation,,,,0,,,,,,,"When using spread-dot operator on an array in @CompileStatic annotated method the following error is raised:

BUG! exception in phase 'instruction selection' in source unit 'ConsoleScript9' unexpected NullpointerException
Caused by: java.lang.NullPointerException

Reproducible example:
{code}
import groovy.transform.CompileStatic

@CompileStatic
def foo() {
    new File(""/"").listFiles()*.name
}

foo()
{code}

The problem doesn't occur when the operator is used on a list:
{code}
import groovy.transform.CompileStatic

@CompileStatic
def foo() {
    new File(""/"").listFiles().toList()*.name
}

foo()
{code}",,erdi,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-09-13 03:22:23.0,,,,,,,,,,"0|i2bprj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Improve StringGroovyMethods typing info for better @CompileStatic integration,GROOVY-7071,12817828,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,12/Sep/14 23:53,07/Apr/15 19:07,14/Jul/23 06:01,17/Sep/14 15:53,2.3.6,2.4.0-beta-3,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,,,,,0,,,,,,,"This code:
{code}
def foo(String a, String b) {}

@groovy.transform.CompileStatic
def bar() {
  foo(""${'foo'}"".stripIndent(), 'UTF-8')
}

bar()
{code}
fails with:
{noformat}
[Static type checking] - Cannot find matching method ConsoleScript30#foo(java.lang.CharSequence, java.lang.String)
{noformat}
",,paulk,pledbrook,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 17 15:53:40 UTC 2014,,,,,,,,,,"0|i2byon:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Sep/14 00:08;paulk;If there are any methods that return the original, they should probably be changed to use ""? extends CharSequence"" but in most cases in SGM we should just change the return type to String. Possibly also GString#subSequence should return String. In theory, after this change, it would then become a breaking change if we made some kind of ""smart"" GString which if you called "".subSequence()"" or "".capitalize()"" on it, then it would remain a GString and remember the additional calls to be evaluated lazily.;;;","13/Sep/14 00:17;paulk;Actually it isn't as simple as I first thought. For some methods, like SGM#drop(CharSequence, int) it would be a breaking change for non-GString CharSequence classes if we changed the return type. For that case, we would need to add a ""String drop(GString self, int num)"" variant and leave the CharSequence variant as is.

;;;","17/Sep/14 03:35;paulk;Proposed changes:
https://github.com/groovy/groovy-core/pull/515
;;;","17/Sep/14 15:53;paulk;There were three cases involved in the changes:
* A small number of methods, e.g. {{SGM#eachMatch(CharSequence, ...)}}, return the actual original object. They now return {{T}} where {{<T extends CharSequence>}}.
* A small number of methods, e.g. {{take(CharSequence, ...)}} and {{drop(CharSequence, ...)}}, are implemented only using methods from the {{CharSequence}} interface and still return {{CharSequence}}. There are now additional {{GString}} variants of those methods which return {{String}}.
* The bulk of the original {{CharSequence}} methods always only returned {{String}}. They now return {{String}} instead of {{CharSequence}} which is a stronger post-condition, so API compatible. The {{String}}-only equivalents have been deprecated in most cases since the {{CharSequence}} variants alone will now suffice.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ReturnAdder shouldn't add return if there's one in a finally block,GROOVY-7065,12817675,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,melix,melix,09/Sep/14 16:59,17/Dec/14 13:25,14/Jul/23 06:01,14/Oct/14 10:24,,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,,,,,0,,,,,,,"The following code was written for a ""Groovy puzzlers"" talk:

{code}
 class CountDown { int counter = 10 }

CountDown finalCountDown() {
    def countDown = new CountDown()
    try {
        countDown.counter = --countDown.counter
    } catch (ignored) {
        println ""That will never happen. ${ignored.message}""
        countDown.counter = Integer.MIN_VALUE
    } finally {
        return countDown
    }
}

println finalCountDown().counter
{code}

At execution, it goes to the catch because of a class cast exception:

""Cannot cast object '9' with class 'java.lang.Integer' to class 'CountDown'""

The reason is highlighted after returns have been added:

{code}
java.lang.Object countDown = new CountDown()
        try {
            return countDown .counter = --( countDown .counter)
        } 
        catch (java.lang.Exception ignored) {
            this.println(""That will never happen. $ignored.message"")
            return countDown .counter = java.lang.Integer.MIN_VALUE
        } 
        finally { 
            return countDown 
        } 
{code} 

A ""return"" is added to the try branch, even though there's a return in the finally block which should always be executed. Adding a single statement after the finally block solves the issue because no return would then be added to the try block...",,blackdrag,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 14 10:24:34 UTC 2014,,,,,,,,,,"0|i2cncf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Oct/14 10:24;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Runtime IllegalAccessError when accessing protected method of the owning class's superclass from a closure when using @CompileStatic,GROOVY-7063,12811441,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,mauromol,mauromol,09/Sep/14 05:43,17/Dec/14 13:25,14/Jul/23 06:01,22/Sep/14 08:46,2.3.6,2.4.0-beta-3,,,,,,,,,,,,,,,,2.3.7,,,,Static compilation,,,,0,,,,,,,"Consider the following base class:

{code}
package l
class Base {
	protected foo() {
		println 'foo'
	}
}
{code}

and the following extended class (please note it's in a different package!):

{code}
package m
import groovy.transform.CompileStatic;
import l.Base;
@CompileStatic
class Ext extends Base {

	static main(args) {
		Ext e = new Ext()
		e.doSomething()
	}

	void doSomething() {
		def c = {
			foo()
		}
		c.call()
	}
}
{code}

When you run this script, you get:
{noformat}
Caught: java.lang.IllegalAccessError: tried to access method l.Base.foo()Ljava/lang/Object; from class m.Ext$_doSomething_closure1
java.lang.IllegalAccessError: tried to access method l.Base.foo()Ljava/lang/Object; from class m.Ext$_doSomething_closure1
	at m.Ext$_doSomething_closure1.doCall(Ext.groovy:16)
	at m.Ext$_doSomething_closure1.call(Ext.groovy)
	at m.Ext.doSomething(Ext.groovy:18)
	at m.Ext.main(Ext.groovy:11)
{noformat}

If you remove the {{@CompileStatic}} from {{Ext}}, it works.

It's quite an annoying problem, because you realize about it only when you go live...
Maybe the source of the problem is similar to that of GROOVY-6468.",,mauromol,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-09-09 05:43:14.0,,,,,,,,,,"0|i2ciun:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type inference not working for Collections.sort(),GROOVY-7061,12817792,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,pledbrook,pledbrook,08/Sep/14 11:09,13/Dec/17 04:55,14/Jul/23 06:01,13/Dec/17 04:55,2.3.6,2.4.5,,,,,,,,,,,,,,,,2.4.14,2.5.0-beta-3,2.6.0-alpha-3,3.0.0-alpha-2,Static Type Checker,,,,0,,,,,,,"In this example:

{code}
import groovy.transform.TypeChecked

doIt()

@TypeChecked
void doIt() {
    List<Integer> nums = [1, 2, 3, -2, -5, 6]
//    nums.sort { a, b -> a.abs() <=> b.abs() }
    Collections.sort(nums, { a, b -> a.abs() <=> b.abs() })
}
{code}

the type checking fails on the closure arguments (no method {{abs()}} on type {{Object}}). Interestingly, it works fine for the line that's commented out.",,blackdrag,daniel_sun,pledbrook,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 13 04:55:59 UTC 2017,,,,,,,,,,"0|i2c3pr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jan/16 13:57;pledbrook;This particular issue seems to be the result of {{Comparator}} declaring the {{equals()}} method as well as {{compare()}}, so the type checker doesn't view it as a Single Abstract Method interface.

I've noticed that the same problem seems to affect the methods from the Streams API. I tried

{code}
import groovy.transform.TypeChecked

@TypeChecked
def doIt(List<String> strings) {
    return strings.
        stream().
        filter { s -> s.length() < 10 }.
        toArray()
}

final words = [""orange"", ""sit"", ""test"", ""flabbergasted"", ""honorific""] 

println doIt(words)
{code}

but the type checker can't seem to work out that {{s}} is of type {{String}}.;;;","21/Jan/16 10:13;blackdrag;I would have expected the compiler failing with a failure about the method not being found, if the interface really was not considered being a SAM class.;;;","21/Jan/16 11:02;pledbrook;To clarify, the type checker reports the following for the {{filter()}} example:

{noformat}
[Static type checking] - Cannot find matching method java.lang.Object#length(). Please check if the declared type is right and if the method exists.
 at line: 7, column: 23
{noformat}

I even tried with the {{File.list(FilenameFilter)}} method, but that wasn't able to infer the argument types either. Marcin had convinced me that this feature worked, but I can't reproduce in any examples I try.;;;","03/Feb/16 10:37;pledbrook;Something else a group of us discovered is that if you replace

{code}
filter { s -> s.length() < 10 }
{code}

with

{code}
filter { it.length() < 10 }
{code}

then the compile-time type checker is happy. So the problem only seems to occur with explicitly declared, untyped closure arguments.;;;","13/Dec/17 04:55;daniel_sun;Fixed by https://github.com/apache/groovy/commit/bd5191d9a8858945a4d83df58e261eb56bec0ab7
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE when using type parameter in trait method,GROOVY-7058,12817784,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pniederw,pniederw,05/Sep/14 14:05,17/Dec/14 13:25,14/Jul/23 06:01,25/Sep/14 07:11,2.3.6,,,,,,,,,,,,,,,,,2.3.7,,,,groovy-runtime,,,,0,,,,,,,"I'm trying to mix a trait into a Gradle plugin. This works:

{code}
trait PluginUtils {
    abstract Project getProject()
    
    public <T extends Task> T createTask(String name, Class type, Closure<?> config) {
      project.task(name, type: type, config)
    }
}

class MyPlugin implements Plugin<Project>, PluginUtils {
    Project project
    
    void apply(Project project) {
        this.project = project
        createTask(""foo"", DefaultTask) {}
    }
}

apply plugin: MyPlugin
{code}

As soon as I change {{Class}} to {{Class<T>}} in the signature of the {{createTask}} method, {{gradle foo}} blows up with:

{code}
Caused by: java.lang.NullPointerException
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:203)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:218)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:169)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:218)
	at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:96)
	at MyPlugin.<clinit>(/swd/tmp/traitplugin/build.gradle)
{code}

Tested with Gradle 2.1-rc-4/Groovy 2.3.6 and Gradle 2.0/Groovy 2.3.3.",,guillaume,melix,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 15 11:04:37 UTC 2014,,,,,,,,,,"0|i2bvu7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Sep/14 14:10;guillaume;Which version of the JDK is it?;;;","05/Sep/14 14:33;pniederw;{code}
JVM:          1.7.0_67 (Oracle Corporation 24.65-b04)
OS:           Mac OS X 10.9.4 x86_64
{code};;;","15/Sep/14 11:04;melix;Hi Peter,

Any chance you can test with the latest snapshots (available at https://oss.jfrog.org/oss-snapshot-local/org/codehaus/groovy/groovy/) and confirm to me that the issue is fixed for you?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper with type LAX throws exception on comments in arrays,GROOVY-7057,12817796,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,carstenlenz,carstenlenz,05/Sep/14 05:05,17/Dec/14 13:25,14/Jul/23 06:01,22/Nov/14 10:54,2.3.6,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,JSON,,,,0,,,,,,,"The LAX parser throws a groovy.json.JsonException when you put a comment  after the last array element but before the closing ']'

Example: 
{code:java}
import groovy.json.JsonParserType
import groovy.json.JsonSlurper

def sampleJson = '''
[
    // good comment
    {
        ""mykey"" : ""myvalue""
    }
    // bad comment
]
'''
def json = new JsonSlurper(type: JsonParserType.LAX).parseText(sampleJson)
println ""This should work""
{code}

Expected is that this comment should also be ignored",,carstenlenz,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Nov 22 10:54:48 UTC 2014,,,,,,,,,,"0|i2ct4f:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"14/Nov/14 11:33;carstenlenz;I review this bug and it is more general: Comments after array elements but before the ',' or ']' currently throw exceptions.

I updated the existing unit test and created a fix for this that ignores comments before the ',' or ']' of the current array. 
This is the pull request: https://github.com/groovy/groovy-core/pull/535;;;","22/Nov/14 10:54;melix;Thank you for the pull request!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AnnotationCollector unusable in external jar when used in stub generation,GROOVY-7056,12811951,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ilbmiller,ilbmiller,02/Sep/14 18:00,05/Sep/18 11:33,14/Jul/23 06:01,08/Sep/14 13:44,2.3.4,,,,,,,,,,,,,,,,,2.3.7,2.4.0-beta-4,,,Stub generator / Joint compiler,,,,1,,,,,,,"In the attached test case (cd mod; gradle clean build), I have a parent module with two child modules.  The first module simply defines a simple AnnotationCollector.  The second module is structured so that it will generate a java stub for a groovy file that uses the 'external' annotation collector.  When the generated java stub for ParentG is compiled, it throws the following exception:
:mod2:compileGroovyC:\sand\nca\javacommons\nca\harmonytest\mod\mod2\build\tmp\groovy-java-stubs\mod2\ParentG.java:10: error: incompatible types: ExternalAnnotationCollector cannot be converted to Annotation
@mod1.ExternalAnnotationCollector() public class ParentG

It appears that the java compilation of the groovy stub does not have the external AnnotationCollector 'in scope' of the compiler, and thus barfs.  However, if the AnnocationCollector is in the same module as where it used, the compilation works (uncomment the obvious line in ParentG and rebuild).

This seems related to https://jira.codehaus.org/browse/GRECLIPSE-1679

Added Sept. 4th:
Also related to http://jira.codehaus.org/browse/GROOVY-6635 which was closed as 'not reproducible' - believe the test case with this issue effectively reproduces the issue (and 6635's as well)","windows, java 8",blackdrag,blmiller,chrylis,ian.springer,ngalarneau,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7148,,,,"02/Sep/14 18:00;mod.zip;https://issues.apache.org/jira/secure/attachment/12723250/mod.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 05 11:33:37 UTC 2018,,,,,,,,,,"0|i2bymv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Sep/14 10:18;blackdrag;So far I can tell as much as that your test makes the problem reproducible. The meta annotation seems to be generated correctly. So the problem might be that in joint compilation mode the precompiled meta annotation is not correctly recognized as such.;;;","08/Sep/14 13:44;blackdrag;should be fixed now, at least I could execute your build without error. Of course that does not mean that transforms suddenly become visible in joint compiled code, but at least the collector will be replaced with the real annotations;;;","05/Sep/18 11:33;chrylis;I seem to be having this same issue with 2.5.2 (and formerly with the 2.4 series after this fix); is there a test in the main Groovy tree for this? I think this underlies the bug I filed against GMavenPlus, with behavior that's identical as far as I can tell. https://github.com/groovy/GMavenPlus/issues/74;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovysh: Command hyphen checker breaks sane code cases,GROOVY-7055,12817722,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,tkruse,tkruse,02/Sep/14 17:57,17/Dec/14 13:25,14/Jul/23 06:01,03/Sep/14 14:30,2.4.0-beta-3,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Groovysh,,,,0,,,,,,,"To reproduce, start groovysh

groovy:000> map = [:]
===> [:]
groovy:000> map.put('a', 77)
ERROR java.lang.IllegalArgumentException:
Missing closing '

This is due to some tiny oversight from GROOVY 6942.
PR is ready. I suggest merging into 2.4.0, as groovysh is unusable else. ",,pschumacher,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7167,,,,,,,,,,,,,,,,,GROOVY-6942,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 03 14:30:14 UTC 2014,,,,,,,,,,"0|i2ci1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Sep/14 14:30;pschumacher;[Pull request|https://github.com/groovy/groovy-core/pull/509] merged. Thanks for reporting and for the pull request.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Read Only Property not resolved correctly at runtime (w/CompileDynamic),GROOVY-7054,12811961,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ilbmiller,ilbmiller,02/Sep/14 16:29,17/Dec/14 13:25,14/Jul/23 06:01,03/Sep/14 07:33,2.3.4,,,,,,,,,,,,,,,,,2.3.7,2.4.0-beta-4,,,Compiler,,,,0,,,,,,,"I hit an issue where I was getting a MissingPropertyException if I used @CompileDynamic, but the exception went away with @CompileStatic.  Below is a simple junit test that isolates the behavior, and the underlying issue is how a read-only private property (via getter) of a parent class is resolved at runtime by @CompileDynamic versus @CompileStatic.  The CompileDynamicParentPrivateTest.testCDPrivate() test throws a runtime MissingPropertyException when a method in the parent class tries to access the the parent class's private property 'foo' (as opposed to via getFoo())

One possible explanation - it appears that the groovy 'foo' property is resolved dynamically when using @CompileDynamic, and as the property is private within the parent class the resolution on the child instance fails (however, why does getFoo() succeed then?).  When @CompileStatic is used, the normal (java) lexical scoping rules apply, and the parent private property can be resolved correctly within the parent method.

1. Is this a bug, or an expected difference in behavior for @CompileStatic / @CompileDynamic?
2. And is my explanation correct as to what is happening?
3. And how can getFoo() succeed, but 'foo' fail, when using @CompileDynamic?  Shouldn't they always behave the same?

Thanks,
Brad

-----------------------------------
Groovy 2.3.4

testCSPrivate succeeds, while second test (testCDPrivate) fails with following exception on second println statement:
groovy.lang.MissingPropertyException: No such property: foo for class: myBugReport.bug2.CDChild
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:50)
	at org.codehaus.groovy.runtime.callsite.GetEffectivePogoPropertySite.getProperty(GetEffectivePogoPropertySite.java:84)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGroovyObjectGetProperty(AbstractCallSite.java:231)
	at myBugReport.bug2.CDParent.printWhichAccessesPrivatePropOfParent(CompileDynamicParentPrivateTest.groovy:53)
	at myBugReport.bug2.CDParent$printWhichAccessesPrivatePropOfParent.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at myBugReport.bug2.CompileDynamicParentPrivateTest.testCDPrivate(CompileDynamicParentPrivateTest.groovy:22)


-----------------------------------
{code}
package myBugReport.bug2

import groovy.transform.CompileDynamic
import groovy.transform.CompileStatic
import org.junit.Test

class CompileDynamicParentPrivateTest
{
  // This test SUCCEEDS as CompileStatic parent class can access private read-only property 'foo'
  @Test
  public void testCSPrivate()
  {
    CSChild csChild = new CSChild()
    csChild.printWhichAccessesPrivatePropOfParent()
  }

  // This test FAILS as CompileDynamic parent class can NOT access private read-only property 'foo'
  @Test
  public void testCDPrivate()
  {
    CDChild cdChild = new CDChild()
    cdChild.printWhichAccessesPrivatePropOfParent()
  }
}

@CompileStatic
class CSParent
{
  // Read-only property where only the getter is defined (without a backing field)
  private String getFoo() { return ""bar"" }

  void printWhichAccessesPrivatePropOfParent()
  {
    System.out.println(""Current value of getFoo() is: "" + getFoo())    // works
    System.out.println(""Current value of foo is: "" + foo)       // works with CompileStatic only
  }
}

@CompileStatic
class CSChild extends CSParent
{
}

@CompileDynamic
class CDParent
{
  // Read-only property where only the getter is defined (without a backing field)
  private String getFoo() { return ""bar"" }

  void printWhichAccessesPrivatePropOfParent()
  {
    System.out.println(""Current value of getFoo() is: "" + getFoo())    // works
    System.out.println(""Current value of foo is: "" + foo)       // foo breaks with CompileDynamic only
  }
}

@CompileDynamic
class CDChild extends CDParent
{
}
{code}",Windows,blackdrag,blmiller,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 03 09:34:10 UTC 2014,,,,,,,,,,"0|i2cimf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"03/Sep/14 07:33;blackdrag;thanks for pointing this bug out. It is easy to be mistaken as GROOVY-2433, but it is indeed different. Fixed;;;","03/Sep/14 07:39;blackdrag;A note... while reading the property is now possible, setting it still is not. For this the current MOP is missing some parts;;;","03/Sep/14 09:32;blackdrag;Since I did not really answer your question... Groovy keeps meta information with every property request and method call, that contain for example the static origin class of the call. This is then used to make private methods visible in child classes. So if a child class calls a method from the parent class this method will see all public methods visible in the child (this is different to Java) and all private methods of the parent.

Now the Groovy MOP was done before such a meta information was added. Whenever we go through a GroovyObject method we loose the meta information. While the logic for invokeMethod is usually to be called quite late and thus allows us to largely bypass the MOP, getProperty is called early on. We can still bypass it in some cases, but many of them just do not allow it.  

In general we bypass it if the method has been added by the compiler. This is the case here, thus we it can be done. In case of a Closure for example this is not the case, hence GROOVY-2433
;;;","03/Sep/14 09:34;blackdrag;As for @CompileStatic. It uses basically the same scoping rules as Groovy, but only static scopes, no dynamic ones. And then it produces direct calls instead of runtime method selection. So as long as the compiler can see it and determines it visible for the scope, it exists.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stubs do not support traits,GROOVY-7052,12817799,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,02/Sep/14 06:25,17/Dec/14 13:25,14/Jul/23 06:01,02/Sep/14 07:24,2.3.6,,,,,,,,,,,,,,,,,2.3.7,2.4.0-beta-3,,,Stub generator / Joint compiler,,,,0,,,,,,,"If joint compilation is enabled, Java stubs contain wrong methods like `$getStaticMetaClass`.

Furthermore, if an empty trait is used as an interface, compilation fails with an error saying that the trait is not an interface (which it will be, but not when stubs are generated).",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-09-02 06:25:08.0,,,,,,,,,,"0|i2brif:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovysh: Completion should suggest field notation rather than bean accessors,GROOVY-7049,12817695,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,tkruse,tkruse,31/Aug/14 10:06,17/Dec/14 13:25,14/Jul/23 06:01,08/Sep/14 14:38,,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Groovysh,,,,0,,,,,,,"currently for bean accessors, groovysh completion will rather suggest the accessors than the field type notation:
groovy:000> class Foo {boolean foo}
groovy:000> f = new Foo()
groovy:000> f.<tab>
getFoo()   isFoo()    setFoo(    
groovy:000> f.

While this is a matter of programming taste, completion could aditionally offer foo in this case. This would also reduce visual clutter for classes with many such bean accessors.

If the user has provided a prefix, such as:
groovy:000> f.ge<tab>
the getters should still appear 

Will try to make a PR so this can be tested inpractice.",,pschumacher,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 08 14:38:24 UTC 2014,,,,,,,,,,"0|i2cmvz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Sep/14 18:40;tkruse;So what I noticed is that I had written tests that make sure when a field is private, the code completion does not offer this field. However, now I believe that as long as the accessors are not private, the fieldname notation is still valid notation for groovy. things get murky when a setter is private but a getter is not, I guess it is okay in that case if code completion offers fieldname notation.;;;","08/Sep/14 14:38;pschumacher;[Pull request|https://github.com/groovy/groovy-core/pull/512] merged. Thanks Thibault!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovysh: Missing completion for optional_dot ?. and spread-dot *.,GROOVY-7048,12817804,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,tkruse,tkruse,31/Aug/14 09:52,17/Dec/14 13:25,14/Jul/23 06:01,08/Sep/14 14:39,,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Groovysh,,,,0,,,,,,,"Currently no completion is considered for x?.| and x*.|

I suggest that for x*., completion will assume that the element found by x.find() will represent all elements in the 'collection' type. Alternatives would be to try and complete using the intersection of candidates members within the 'collection', but that may be much more complicated code to be worth the effort, IMO.",,pschumacher,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 08 14:39:01 UTC 2014,,,,,,,,,,"0|i2cemf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Sep/14 14:39;pschumacher;[Pull request|https://github.com/groovy/groovy-core/pull/512] merged. Thanks Thibault!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static inner class crashes compiler when it references parent's this,GROOVY-7047,12817679,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,kapec94,kapec94,29/Aug/14 03:14,21/Mar/15 07:11,14/Jul/23 06:01,11/Mar/15 13:22,2.3.6,,,,,,,,,,,,,,,,,2.3.11,2.4.2,,,Compiler,,,,0,,,,,,,"Consider following code:
{code}
class Foo {
    static class Bar {
        def parent = Foo.this
    }
}
{code}

Instead of printing informative error message, compiler crashes at the stage of 'semantic analysis'. I attached full stacktrace.
","Windows 7 64-bit, IntelliJ IDEA 13.1.4",kapec94,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Aug/14 03:14;kapec94;stacktrace.txt;https://issues.apache.org/jira/secure/attachment/12723061/stacktrace.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 11 13:22:08 UTC 2015,,,,,,,,,,"0|i2c8uv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Mar/15 13:22;melix;Fixed with https://github.com/groovy/groovy-core/commit/181a06bf9ed7457d8da92b9d6cdf8ed830a13c53;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
commands return value false is ignored,GROOVY-7045,12817816,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,kaserfoo,kaserfoo,27/Aug/14 13:25,21/Mar/15 07:11,14/Jul/23 06:01,23/Feb/15 06:52,2.2.2,2.4.0-beta-2,,,,,,,,,,,,,,,,2.3.11,2.4.2,,,Groovysh,,,,0,,,,,,,"Since the last result is not set for results that are either null or false, the result is also not printed to the console.

This is highly confusing if you have a command that returns a boolean value. if the return value is true, it will be shown at set as last result, if it is false it looks like it gets ignored.

This can be traced back to https://github.com/groovy/groovy-core/blob/master/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/Groovysh.groovy#L134

I don't think this is the correct behavior. I understand the null case, but false should clearly be a valid return value for a command.",,kaserfoo,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Feb 22 11:47:35 UTC 2015,,,,,,,,,,"0|i2brqf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Aug/14 15:35;kaserfoo;workaround: pull up the code into the command:

{code:java}
  Object doExecute(List<Object> args) {
    Object ret = doSomething()

    // fix groovy issue with returning false #GROOVY-7045
    if (ret == false) {
	  io.out.println(""@|bold ===>|@ ${ret}"")
	  shell.interp.context['_'] = ret //store reference to shell in the constructor of the command
	}

    return ret
  }
{code};;;","28/Aug/14 16:00;kaserfoo;This has an even bigger scope: everything that evaluates to false in an if statement (""if(result)"") is ignored. For example also 0.0;;;","22/Feb/15 06:27;tkruse;Hi Felix, 

thanks for the report.

The logic to not display untrue values (null, false, 0, etc.) has been introduced in 2007 when groovysh was started. I believe the intention is that for 'meta' commands like :help, invoking the command should neither lead to a display of ===> null
nor change the value of the special variable '_'.

However, it is possible that users create commands where the command may return null, and wants this to be displayed and override the value in '_'.

Making this possible would require a lot of api and behavior change, so I do not feel so eager to make changes here. But I believe that if only null values from commands get ignored (instead of all non-trues), that's a viable compromise for now.;;;","22/Feb/15 11:47;tkruse;https://github.com/groovy/groovy-core/pull/613;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cloned NodeBuilder created nodes share values (child nodes) with original node.,GROOVY-7044,12817789,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,shils,cvrcak,cvrcak,27/Aug/14 11:54,01/Feb/17 23:19,14/Jul/23 06:01,02/Jul/16 17:45,2.3.6,,,,,,,,,,,,,,,,,2.4.8,,,,groovy-jdk,XML Processing,,,1,,,,,,,"Cloning nodes created by NodeBuilder share child nodes with original node.
If node is added to original node or child node value is changed, the cloned node will see those changes. Same applies to cloned node, adding node or changing child node value will be seen by original node.

The problem seem to originate in NodeBuilder methods:
{code}
protected Object createNode(Object name)
protected Object createNode(Object name, Map attributes)
{code}
which use ArrayList when creating new Node instead of NodeList.

Can be easily reproduced by groovysh or use attached junit file.
{noformat}
groovy:000> x1 = new NodeBuilder().a() { b() }
===> a[attributes={}; value=[b[attributes={}; value=[]]]]
groovy:000> x2 = x1.clone()
===> a[attributes={}; value=[b[attributes={}; value=[]]]]
groovy:000> x1.appendNode('c')
===> c[attributes={}; value=[]]
groovy:000> x1
===> a[attributes={}; value=[b[attributes={}; value=[]], c[attributes={}; value=[]]]]
groovy:000> x2
===> a[attributes={}; value=[b[attributes={}; value=[]], c[attributes={}; value=[]]]]
groovy:000> x1.b[0].setValue(1)
===> null
groovy:000> x1
===> a[attributes={}; value=[b[attributes={}; value=1], c[attributes={}; value=[]]]]
groovy:000> x2
===> a[attributes={}; value=[b[attributes={}; value=1], c[attributes={}; value=[]]]]
groovy:000> x2.c[0].setValue(2)
===> null
groovy:000> x1
===> a[attributes={}; value=[b[attributes={}; value=1], c[attributes={}; value=2]]]
{noformat}
",,blackdrag,cvrcak,daniel.spilker@hamburg.de,githubbot,jwagenleitner,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Aug/14 11:54;cvrcak;NodeBuilderTest.groovy;https://issues.apache.org/jira/secure/attachment/12722205/NodeBuilderTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 02 17:36:26 UTC 2016,,,,,,,,,,"0|i2chw7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"23/Feb/16 21:35;githubbot;GitHub user daspilker opened a pull request:

    https://github.com/apache/groovy/pull/270

    GROOVY-7044: Fixed deep cloning of nodes generated by NodeBuilder

    Use default behavior when creating Nodes without value.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/daspilker/groovy GROOVY-7044

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/270.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #270
    
----
commit 7b99e656e734b14872048354731b01d9d3061af6
Author: Daniel Spilker <daniel.spilker@coremedia.com>
Date:   2016-02-23T21:34:09Z

    GROOVY-7044: Fixed deep cloning of nodes generated by NodeBuilder
    
    Use default behavior when creating Nodes without value.

----
;;;","06/Mar/16 19:12;pascalschumacher;[~paulk] What do you think? Is this a bug or a feature? Should we merge the pull request?;;;","07/Mar/16 09:08;blackdrag;This PR requires a testcase;;;","07/Mar/16 11:04;daniel.spilker@hamburg.de;I updated the PR to include a testcase.;;;","02/Jul/16 17:36;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/270
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GString concatenation break equal operator transitive property ,GROOVY-7043,12815770,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,pablo72,pablo72,27/Aug/14 11:48,23/Dec/14 19:45,14/Jul/23 06:01,22/Dec/14 07:38,2.3.6,,,,,,,,,,,,,,,,,2.3.10,2.4.0-rc-1,,,groovy-runtime,,,,0,,,,,,,"In the following script the third assertion fails 

{code}
w = 'world'
str1 = ""Hello $w""
str1 += ""!""
str2 = ""Hello $w!""
str3 = 'Hello world!'

assert str1 == str3
assert str2 == str3
assert str1 == str2 


assert str1 == str2
       |    |  |
       |    |  Hello world!
       |    false
       Hello world!

	at ConsoleScript9.run(ConsoleScript9:11)
{code}
",,armsargis,blackdrag,paolodt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 22 07:38:13 UTC 2014,,,,,,,,,,"0|i2cl1j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Dec/14 18:31;armsargis;Hi I sent pull request: https://github.com/groovy/groovy-core/pull/557;;;","13/Dec/14 01:20;pablo72;I've sent a pull request as well https://github.com/groovy/groovy-core/pull/548;;;","13/Dec/14 05:20;blackdrag;I will comment on both prs here then.

Firstly changing DefaultTypeTransformation to call toString on CharSequence for a compare... The problem is that CharSequence is an interface and might be implemented by other things. That means the change has an effect, that goes beyond the intended one. And in that case we should discuss this case and if that is the right thing to do.

Then about the GString case. I personally like that change more, since it seems to be more limited in its effect. I don't like that GStringImpl is referenced in GString. GStringImpl was at first thought as one of possibly several implementations, this logic here though would force this kind of implementation. It would have been better if plus was abstract and then implemented in GStringImpl... But this is not the case, and making it abstract would be a breaking API change. Which is why I guess I can give my OK to this. 

So... Sargis... would you too unhappy if I apply 548?;;;","13/Dec/14 05:42;armsargis;Hi, I am ok of course if decide to merge 548.

About my changes before calling method compareToWithEqualityCheck() its already checking:

{code}
if (left instanceof Comparable) {

}
{code}

and comparing with

{code}
            else if (left instanceof String && right instanceof GString) {
                return ((String) left).compareTo(right.toString());
            }
{code}

I think my solution is more generic and will help avoid other bugs in future, but of course its up to you decide I can quite happy if bug can be fixed with any pull request.;;;","13/Dec/14 05:45;armsargis;but you are right in my case impact is much more global;;;","13/Dec/14 05:49;armsargis;also code can be changed to:

{code}
            else if (left instanceof CharSequence && right instanceof CharSequence && right instanceof Comparable) {
                return ((Comparable) left).compareTo(right);
            }
{code}

also but I am not insisting on my solution );;;","22/Dec/14 07:38;blackdrag;548 applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With TraitComposer.doExtendTraits With Trait Which Contains A Property,GROOVY-7042,12811434,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,26/Aug/14 11:42,17/Dec/14 13:25,14/Jul/23 06:01,01/Oct/14 18:43,2.3.4,,,,,,,,,,,,,,,,,2.3.8,,,,,,,,0,,,,,,,"The attached app contains the following:


{code:title=transform/src/main/groovy/com/demo/MagicTrait.groovy|borderStyle=solid}
package com.demo

trait MagicTrait {
    int age
}
{code}

{code:title=transform/src/main/groovy/com/demo/MagicNumber.java|borderStyle=solid}
package com.demo;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.codehaus.groovy.transform.GroovyASTTransformationClass;

@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.TYPE)
@GroovyASTTransformationClass(""com.demo.MagicNumberTransformation"")
public @interface MagicNumber {
}
{code}

{code:title=transform/src/main/groovy/com/demo/MagicNumberTransformation.groovy|borderStyle=solid}
package com.demo

import groovy.transform.CompilationUnitAware
import org.codehaus.groovy.ast.ASTNode
import org.codehaus.groovy.ast.ClassHelper
import org.codehaus.groovy.control.CompilationUnit
import org.codehaus.groovy.control.CompilePhase
import org.codehaus.groovy.control.SourceUnit
import org.codehaus.groovy.transform.ASTTransformation
import org.codehaus.groovy.transform.GroovyASTTransformation
import org.codehaus.groovy.transform.trait.TraitComposer


@GroovyASTTransformation(phase=CompilePhase.SEMANTIC_ANALYSIS)
class MagicNumberTransformation implements ASTTransformation, CompilationUnitAware {

    private CompilationUnit unit;

    public void setCompilationUnit(CompilationUnit cu) {
        unit = cu;
    }

    @Override
    void visit(ASTNode[] nodes, SourceUnit source) {
        def classNode = nodes[1]
        def traitClassNode = ClassHelper.make(MagicTrait.class)
        if (!classNode.implementsInterface(traitClassNode)) {
            classNode.addInterface(traitClassNode)
            TraitComposer.doExtendTraits(classNode, source, unit)
        }
    }
}
{code}

{code:title=app/src/test/groovy/com/demo/MagicSpec.groovy|borderStyle=solid}
package com.demo

import spock.lang.Specification

class MagicSpec extends Specification {

    void 'Test magic transformation'() {
        expect:
        MagicTrait.isAssignableFrom Widget
    }
}

@MagicNumber
class Widget {

}
{code}


Compilation fails with the following:

{noformat}
 $ ./gradlew test
:app:compileTestGroovy
startup failed:
/Users/jeff/compiletime/app/src/test/groovy/com/demo/MagicSpec.groovy: -1: The method public int com_demo_MagicTrait__age$get()  { ... } duplicates another method of the same signature
. At [-1:-1]  @ line -1, column -1.
/Users/jeff/compiletime/app/src/test/groovy/com/demo/MagicSpec.groovy: -1: The field 'com_demo_MagicTrait__age' is declared multiple times.
 @ line -1, column -1.
/Users/jeff/compiletime/app/src/test/groovy/com/demo/MagicSpec.groovy: -1: Repetitive method name/signature for method 'int com_demo_MagicTrait__age$get()' in class 'com.demo.Widget'.
 @ line -1, column -1.
/Users/jeff/compiletime/app/src/test/groovy/com/demo/MagicSpec.groovy: -1: Repetitive method name/signature for method 'void com_demo_MagicTrait__age$set(int)' in class 'com.demo.Widget'.
 @ line -1, column -1.
/Users/jeff/compiletime/app/src/test/groovy/com/demo/MagicSpec.groovy: -1: Repetitive method name/signature for method 'int com_demo_MagicTrait__age$get()' in class 'com.demo.Widget'.
 @ line -1, column -1.
/Users/jeff/compiletime/app/src/test/groovy/com/demo/MagicSpec.groovy: -1: Repetitive method name/signature for method 'void com_demo_MagicTrait__age$set(int)' in class 'com.demo.Widget'.
 @ line -1, column -1.
6 errors

:app:compileTestGroovy FAILED

FAILURE: Build failed with an exception.
{noformat}

If the age property is removed from MagicTrait, then compilation succeeds and the test passes.

Should this work?",,brownj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"26/Aug/14 11:42;brownj;compiletime.zip;https://issues.apache.org/jira/secure/attachment/12723263/compiletime.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-08-26 11:42:35.0,,,,,,,,,,"0|i2c327:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic with a spread operator in a boolean expression causes compiler error,GROOVY-7041,12811431,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mparfianowicz,mparfianowicz,26/Aug/14 08:20,17/Dec/14 13:25,14/Jul/23 06:01,26/Sep/14 07:57,2.3.6,,,,,,,,,,,,,,,,,2.3.8,,,,Compiler,Static compilation,,,0,,,,,,,"When class is annotated with the CompileStatic and a spread operator is a leaf of a boolean expression, then compilation fails with a message:

{quote}
Error:Groovyc: BUG! exception in phase 'class generation' in source unit 'C:\A.groovy' operand stack contains 2 elements, but we expected only 0
{quote}

Code sample:

{code:java}
import groovy.transform.CompileStatic

@CompileStatic
class A {
    A() {
        List<String> myList = [ ]
        if (myList*.isEmpty().any() && true) {
            println 'hello'
        }
    }
}
{code}



{noformat}
Error:Groovyc: BUG! exception in phase 'class generation' in source unit 'C:\A.groovy' operand stack contains 2 elements, but we expected only 0
	at org.codehaus.groovy.classgen.asm.OperandStack.castToBool(OperandStack.java:110)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBooleanExpression(AsmClassGenerator.java:743)
	at org.codehaus.groovy.ast.expr.BooleanExpression.visit(BooleanExpression.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeIfElse(StatementWriter.java:279)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitIfElse(AsmClassGenerator.java:572)
	at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:41)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:556)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:420)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:377)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:119)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructor(AsmClassGenerator.java:492)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1059)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:231)
	at org.codehaus.groovy.control.CompilationUnit$16.call(CompilationUnit.java:805)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1047)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:583)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:561)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:538)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:54)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:87)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:100)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:121)
{noformat}",,mparfianowicz,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-08-26 08:20:41.0,,,,,,,,,,"0|i2ccov:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Builder annotation should provide default values for forClass, prefix, builderClassName, buildMethodName, builderMethodName",GROOVY-7040,12817782,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,25/Aug/14 16:01,07/Apr/15 19:06,14/Jul/23 06:01,26/Aug/14 22:05,2.3.6,2.4.0-beta-2,,,,,,,,,,,,,,,,2.3.7,2.4.0-beta-3,,,,,,,0,,,,,,,"Even though these are overridden with different values for different strategies, we should provide some kind of default to keep IDEs happy",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-08-25 16:01:07.0,,,,,,,,,,"0|i2c7yv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Access to constant fields in classes implementing constant interfaces erroneously forbidden in @CompileStatic code,GROOVY-7039,12817770,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,jnykiel,jnykiel,25/Aug/14 07:13,17/Dec/14 13:25,14/Jul/23 06:01,05/Nov/14 03:26,2.4.0-beta-2,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,Static compilation,,,,0,,,,,,,"Compilation of the following files:

{code:title=MyConstants.java}
public interface MyConstants  {
    public static final String CONSTANT_1 = ""this is constant 1"";
}
{code}
{code:title=MyClass.java}
public class MyClass implements MyConstants {
}
{code}
{code:title=Program.groovy}
@groovy.transform.CompileStatic
class Program {
    public static void main(String[] args) {
        println MyClass.CONSTANT_1
    }
}
{code}

ends with error:
{code}
Error:(4, 17) Groovyc: Access to MyClass#CONSTANT_1 is forbidden
{code}
For example, the error makes it difficult and counterintuitive to access [BaseColumns|http://developer.android.com/reference/android/provider/BaseColumns.html] members via any of content provider contract classes (like [ContactsContract|http://developer.android.com/reference/android/provider/ContactsContract.html]) - you need to refer to the interface directly.",,emilles,jnykiel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-08-25 07:13:58.0,,,,,,,,,,"0|i2boqf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
An interface implementation (override) with a method including a default parameter value does not compile,GROOVY-7036,12817744,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,martinahrer,martinahrer,22/Aug/14 04:18,22/Feb/16 20:48,14/Jul/23 06:01,29/Dec/15 15:23,2.3.6,,,,,,,,,,,,,,,,,2.4.6,,,,Compiler,,,,0,,,,,,,"A complete (gradle based) project to demonstrate the problem has been provided at https://github.com/MartinAhrer/bug-groovy-2.3-override.

{code}
interface TemplatedInterface<T> {
    T execute(Map argument)
}
class TemplatedInterfaceImplementation implements TemplatedInterface<String>{
    // This won't compile with groovy 2.3.x when adding a default argument value
    @Override
    String execute(Map argument = [:]) {
        return null
    }
}
{code}

This kind of relates to GROOVY-6654.",JDK 1.7.0_60,githubbot,martinahrer,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 29 14:14:20 UTC 2015,,,,,,,,,,"0|i2bzbz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"29/Dec/15 00:14;shils;The example in the description can be simplified by removing the generics e.g.

{code}
interface TemplatedInterface {
    String execute(Map argument)
}
class TemplatedInterfaceImplementation implements TemplatedInterface {
    @Override
    String execute(Map argument = [:]) {
        return null
    }
}
{code}

The issue is that the annotations on a method with default parameters are all added to the methods generated by the verifier, even if they don't apply. In this case, the generated method {{TemplatedInterfaceImplementation#execute()}} has an @Override annotation, resulting in the error described.;;;","29/Dec/15 05:50;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/228

    GROOVY-7036: An interface implementation (override) with a method inc…

    …luding a default parameter value does not compile

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7036

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/228.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #228
    
----
commit 5e114cb0e86cbaa66e50080bc5fe7dd444d98ef3
Author: Shil Sinha <shils@apache.org>
Date:   2015-12-29T05:43:50Z

    GROOVY-7036: An interface implementation (override) with a method including a default parameter value does not compile

----
;;;","29/Dec/15 14:14;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/228
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checking bug with anonymous class,GROOVY-7035,12817794,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,bsideup,bsideup,22/Aug/14 03:29,17/Dec/14 13:32,14/Jul/23 06:01,22/Aug/14 03:49,2.3.2,,,,,,,,,,,,,,,,,2.3.6,,,,Static compilation,Static Type Checker,,,0,,,,,,,"This code:
{code:java}
@groovy.transform.CompileStatic
class Foo {
    static Map test = [:].withDefault { return new Runnable() { void run() {} }}
}
{code}

Will fail with:
[Static type checking] - Cannot call Foo$1#<init>(groovy.lang.Closure) with arguments [Foo] ",,bsideup,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 22 03:49:12 UTC 2014,,,,,,,,,,"0|i2c73z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Aug/14 03:49;bsideup;Oh..... fixed in 2.3.6. Sorry.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc for package-info embeds doc within the <h2> tag -- creates malformed HTML,GROOVY-7034,12811433,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,david_costanzo,david_costanzo,21/Aug/14 13:14,21/Mar/15 07:11,14/Jul/23 06:01,13/Mar/15 06:13,2.3.1,2.4.0-beta-2,,,,,,,,,,,,,,,,2.4.2,,,,GroovyDoc,,,,0,,,,,,,"The groovydoc Ant task generates documentation for the package-info.java, but it places the generated documentation into the HTML twice, once in an illegal spot in the middle of an ""H2"" tag and once in a legal, but incorrect spot--inside the H2 tag.  I think it's supposed to go _after_ the H2 tag.

My Web browser (Firefox 20) renders this as large blocky text, but does not show it twice.

The snippet of HTML generated from the repro looks like this:

{quote}
<div class=""header"">
    <h2 title="" {color:red}<p>This is the description for a sample package named ""groovydoctest""</p>
 <p>This is the second paragraph</p>
 <pre>This is some sample code</pre>
 
{color}"" class=""title""> {color:blue}<p>This is the description for a sample package named ""groovydoctest""</p>
 <p>This is the second paragraph</p>
 <pre>This is some sample code</pre>
{color}
</h2>
</div>
{quote}

I have attached a ZIP file which contains a tiny project that you can use to reproduce the problem.  You'll have to change the location of groovy-all.jar in the build.xml.  Then you can run ""ant all"" to build both the GroovyDoc form and the JavaDoc form.

I have included the generated HTML in the .ZIP file.  I have separately attached the package-summary.html that it generates on my machine, from which the above snippet was taken.  Note that this was placed in the DefaultPackage directory, not the actual package directory.

I first noticed this in groovy-2.3.1 and confirmed that it's still reproducible with groovy-all-2.4.0-beta-2.jar.
",,david_costanzo,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/Aug/14 13:14;david_costanzo;groovydocbug.zip;https://issues.apache.org/jira/secure/attachment/12722679/groovydocbug.zip","21/Aug/14 13:14;david_costanzo;package-summary.html;https://issues.apache.org/jira/secure/attachment/12723147/package-summary.html",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 13 06:13:43 UTC 2015,,,,,,,,,,"0|i2cngn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Aug/14 19:26;paulk;It is supposed to appear within the h2 tag but it assumes (too simply) that the content won't have illegal characters, e.g. it expects something like this:

{code}
<h2 title=""Classes for the JMX Builder."" class=""title"">Classes for the JMX Builder.</h2>
{code}

The title attribute is filled in for accessibility reasons.

We should really encode any quotes and strip or encode any tags within the ""title"" attribute value.
;;;","13/Mar/15 06:13;paulk;I changed the template to have a standard title attribute and moved the H2 element after the title - as per what you were expecting and indeed how it is produced in recent versions of javadoc.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bug with annotation with closure on method of anonymous class,GROOVY-7033,12817693,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,bsideup,bsideup,20/Aug/14 14:02,03/Feb/22 22:35,14/Jul/23 06:01,20/Jan/22 22:00,2.3.6,,,,,,,,,,,,,,,,,2.5.16,3.0.10,4.0.0,,class generator,Compiler,,,0,,,,,,,"Annotations on method with Closure value can't be used with anonymous classes

Test with NotYetImplemented included:

https://github.com/groovy/groovy-core/pull/505",,bsideup,candrews,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 20 22:00:15 UTC 2022,,,,,,,,,,"0|i2c5tr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Aug/14 15:54;paulk;A second possibly unrelated (but maybe same root cause) example:
{code}
import java.lang.annotation.*

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface Bar{ Class value() }

@Bar(String)           // OK
String toString() {}

return new Object() {
  @Bar(String)         // Error!
  String toString() {}
}
// Error:
// Only classes and closures can be used for attribute 'value' in @Bar
// at line: 11, column: 8
{code};;;","20/Jan/22 22:00;emilles;https://github.com/apache/groovy/commit/92ea8d9615c174d9b113740ce3dca0a723549597;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Traits don't like generic arguments,GROOVY-7032,12817768,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,20/Aug/14 08:34,23/Dec/14 19:45,14/Jul/23 06:01,22/Dec/14 04:45,2.3.6,,,,,,,,,,,,,,,,,2.3.7,,,,Compiler,,,,1,,,,,,,"This compiles:
{code}
trait Foo { public <T> T  bar(def a) { a } }
class Bar implements Foo {}
{code}

This doesn't:
{code}
trait Foo { public <T> T  bar(T a) { a } }
class Bar implements Foo {}
{code}

But this does:
{code}
trait Foo<X> { public <T> T  bar(T a) { a } }
class Bar implements Foo {}
{code}


But this doesn't:
{code}
trait Foo<X> { public <T> T  bar(T a) { a } }
class Bar implements Foo<String> {}
{code}

This does, though it doesn't make sense:
{code}
trait Foo<X> { public <T> T  bar(X a) { a } }
class Bar implements Foo<String> {}
{code}
",,ddimitrov,melix,thejeed,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 22 04:45:45 UTC 2014,,,,,,,,,,"0|i2cc3j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Dec/14 04:45;melix;I just checked and it was actually fixed in 2.3.7.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic breaks assign in combination with dereferencing,GROOVY-7031,12817783,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,flofreud,flofreud,18/Aug/14 06:58,26/Jul/18 04:38,14/Jul/23 06:01,18/May/18 10:16,2.3.6,2.4.0-rc-1,,,,,,,,,,,,,,,,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,,Static compilation,,,,0,,,,,,,"@CompileStatic breaks assignment for code like

{code}
@groovy.transform.CompileStatic
class StaticClass {
    StringHolder holder = new StringHolder()
    String str

    StaticClass(String s) {
        str = holder.str = s
    }
}

class StringHolder {
    String str
}

def s = new StaticClass('test')
assert s.holder.str == 'test'
assert s.str != 'test'
{code}

The second assert fails because s.str == null. Without @CompileStatic it works correctly (and as java).

","java version ""1.8.0_11""",daniel_sun,flofreud,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/Aug/14 06:58;flofreud;CompileStaticAssignmentTest.groovy;https://issues.apache.org/jira/secure/attachment/12723219/CompileStaticAssignmentTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 18 10:16:12 UTC 2018,,,,,,,,,,"0|i2cr7z:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"06/Aug/16 12:03;paulk;This seems to work on 2.4.7 and master. I am assuming that the last assert is supposed to have '=='.;;;","17/May/18 05:32;daniel_sun;The last assert should be `assert s.str == 'test'`;;;","18/May/18 10:11;daniel_sun;Here is the java version. The last assert should have `==`
{code:java}
public class StaticClass {
    StringHolder holder = new StringHolder();
    String str;

    StaticClass(String s) {
        str = holder.str = s;
    }

    public static void main(String[] args) {
        StaticClass s = new StaticClass(""test"");
        assert s.holder.str.equals(""test"");
        assert s.str.equals(""test"");
    }
}

class StringHolder {
    String str;
}
{code}
;;;","18/May/18 10:16;daniel_sun;It is fixed. https://github.com/apache/groovy/commit/42aa69f7467c26edbac3fe623b13c24a6adf9a1b;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Synchronized should be disallowed on an abstract method,GROOVY-7027,12817777,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,15/Aug/14 06:17,07/Apr/15 19:07,14/Jul/23 06:01,15/Aug/14 06:40,2.3.6,2.4.0-beta-2,,,,,,,,,,,,,,,,2.3.7,2.4.0-beta-3,,,xforms,,,,0,,,,,,,"{code}
class Foo {
  @groovy.transform.Synchronized
  abstract void bar()
}
{code}
fails compilation with:
{noformat}
BUG! exception in phase 'class generation' in source unit 'ConsoleScript22' unexpected NullpointerException
{noformat}
Instead it should fail with a proper compiler error.
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 15 06:41:54 UTC 2014,,,,,,,,,,"0|i2c05r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Aug/14 06:41;paulk;Now fails compilation with:
{noformat}
Error during @Synchronized processing: annotation not allowed on abstract method 'bar'
{noformat}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"GroovyShell fails to give script constructor or setBinding a binding for ""args""",GROOVY-7026,12817767,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jimwhite,jimwhite,jimwhite,15/Aug/14 00:58,05/Apr/15 14:44,14/Jul/23 06:01,25/Sep/14 03:56,2.3.6,2.4.0-beta-2,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,,,,,0,,,,,,,"GroovyShell calls scripts in a few different places but in each case fails to have the binding for ""args"" set when calling the constructor or setBinding.  The result is that initialization code in the constructor cannot function correctly and that fallback relying on overriding setBinding fail too.

The Groovy compiler generates two constructors for every script.  A default one and one taking a Binding.  The reason for that is so that constructors can get the binding values they need.  ",,jimwhite,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Tue Sep 02 15:24:34 UTC 2014,,,,,,,,,,"0|i2bogn:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"02/Sep/14 15:18;jimwhite;Fixed in [PR#508](https://github.com/groovy/groovy-core/pull/508).  Turned out to be a little more complicated than I expected but the changes are straightforward and should be pretty safe.  The duplicated/reversed logic in the AST transform (as we've seen before) really makes one wish the compiler worked on a reactive/functional design.;;;","02/Sep/14 15:24;jimwhite;Since this fix goes a long way to making script bindings work correctly as properties, it is surely the right time to fix GROOVY-6586 (especially since the related bug GROOVY-6582 only fixed the problem for closure properties which makes the current behavior really illogical).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static member in enum class definition not initialized before enums created,GROOVY-7025,12815764,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mitsu,mitsu,14/Aug/14 13:40,10/Feb/23 21:39,14/Jul/23 06:01,03/Nov/22 17:38,2.3.0,,,,,,,,,,,,,,,,,2.5.20,3.0.14,4.0.7,,Compiler,,,,0,enum,,,,,,"I have a static member being initialized inside an enum:
{code}
class Foo {
  ...
  enum Bar {
    FIRST(""foo"")
    ...
    static final Set<String> barNames = new HashSet<String>()
    ...
    Bar(String name) {
      barNames.add(name)
      ...
    }
    ...
  }
  ...
}
{code}

However, when the code above executes, barNames is null inside the constructor, i.e., the static member of the enum class is not initialized before the enums themselves are initialized. This may not be a bug, but it seems to me there should be some documentation and/or a compiler warning if you do this.

Instead, I had to move the set outside the enum to the enclosing class.
      
",,blackdrag,chrylis,emilles,paulk,syntheticzero,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10721,,,,,,,,,,,,,"31/Mar/15 19:44;paulk;enum_in_class.png;https://issues.apache.org/jira/secure/attachment/12723247/enum_in_class.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 03 17:38:18 UTC 2022,,,,,,,,,,"0|i2bz2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Mar/15 06:32;chrylis;I'm seeing the same issue in 2.4.3, and I disagree that it's minor; lookup tables are a common idiom, and this breaks them completely. Static blocks are also run after constructors, so there's no clean workaround. The behavior is clearly incorrect.;;;","26/Mar/15 13:52;mitsu;I agree, but I don't think that anyone on the project has even seen this bug. No one has commented on it. Maybe I should up the severity.;;;","26/Mar/15 15:20;blackdrag;if you try something like {code:Java}class Foo {
    static a = []
    Foo(x){a<<x}
}
new Foo(1)
new Foo(2)
assert Foo.a == [1,2]{code}
you will see, that the problem is special to enums;;;","26/Mar/15 15:23;mitsu;Yes, it's clearly a mistake, and should be fixed, I agree. Hopefully my upping the severity will get someone's attention. I guess we could go into the source code and figure this out and submit a patch. :);;;","27/Mar/15 04:54;paulk;The static init part of the generated code for your enum above is roughly:
{code}
    static { 
        FIRST = Foo$Bar.$INIT('FIRST', 0, 'foo')
        MIN_VALUE = FIRST
        MAX_VALUE = FIRST
        $VALUES = [FIRST]
        barNames = new java.util.HashSet<String>()
    }
{code}
The barNames assignment line should come first.;;;","27/Mar/15 05:09;paulk;And expanding Jochen's example to:
{code}
class Foo {
    static { println a.size() }
    static a = []
    Foo(x){a<<x}
}
new Foo(1)
new Foo(2)
assert Foo.a == [1, 2]
{code}
we do indeed seem to reorder things for that case:
{code}
    static { 
        a = []
        this.println(a.size())
    }
{code}

;;;","27/Mar/15 06:04;paulk;OK, it looks like the ordering was changed to ""fix"" GROOVY-3161. So, perhaps we need something a little more sophisticated than the current or pre GROOVY-3161 behaviors, e.g. for this example:
{code}
class Foo {
  enum Bar {
    FIRST(""foo"")
    static final Set<Bar> specialBars = [FIRST]
    static final Set<String> barNames = new HashSet<String>()
    Bar(String name) {
      barNames.add(name)
    }
  }
}

println Foo.Bar
println Foo.Bar.specialBars
println Foo.Bar.barNames
{code}
The static init code would need to be:
{code}
static { 
    barNames = new java.util.HashSet<String>()
    FIRST = Foo$Bar.$INIT('FIRST', 0, 'foo')
    MIN_VALUE = FIRST
    MAX_VALUE = FIRST
    $VALUES = [ FIRST ]
    specialBars = [ FIRST ]
}
{code}
It would need some quite smart logic. Not even sure it is possible to detect in the general case. It's easy to see why Java prohibits access to static fields like {{barNames}} in enum constructors and instance init blocks.;;;","31/Mar/15 18:20;chrylis;bq. It's easy to see why Java prohibits access to static fields like barNames in enum constructors and instance init blocks.

Citation? I do this all the time in Java for initializing lookup maps.;;;","31/Mar/15 19:44;paulk;I was just using the supplied example and converting to Java. See attached screenshot and error below:
{noformat}
> javac Foo.java
Foo.java:10: error: illegal reference to static field from initializer
            barNames.add(name);
            ^
1 error
{noformat}
;;;","03/Nov/22 15:32;emilles;""It is a compile-time error to refer to a static field of an enum type from a constructor, instance initializer, or instance variable initializer of the enum type, unless the field is a constant variable (§4.12.4).""

https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.9.2;;;","03/Nov/22 17:38;emilles;https://github.com/apache/groovy/commit/389bb26d11be5ec3178cff7d96afafaa35b1a353;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Reference to static member of parent class in enum constructor fails at runtime,GROOVY-7024,12811438,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,mitsu,mitsu,14/Aug/14 13:35,02/May/21 09:16,14/Jul/23 06:01,19/Mar/21 19:30,2.3.0,,,,,,,,,,,,,,,,,2.5.15,3.0.8,4.0.0-alpha-3,,Compiler,,,,0,inner,scope,,,,,"I have a class with the following code:
{code}
class UnitGroupMap {
  ...
  static Map suffixPriority = ['a' : 10, 'b' : 20]
  ...
  enum UnitGroup {
    SAMPLE(""foo""),
    ...
    UnitGroup(String name) {
      ...
      suffixPriority[name] = priority
      ...
    }
  ...
  }
  ...
}
{code}

The compiler does not complain, STS doesn't complain, but at runtime, there's an exception that ""suffixPriority"" is not a member of UnitGroupMap.UnitGroup.

To make this code work, I have to precede the suffixPriority reference with the class name: UnitGroupMap.suffixPriority

Either this should work as written, or the compiler should generate an error or at least a warning. However, STS at least highlights suffixPriority in italics as though it can and does see the field should be coming from the parent class, UnitGroupMap.


",Mac OS X running STS in a Grails context,blackdrag,syntheticzero,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 18 10:15:08 UTC 2014,,,,,,,,,,"0|i2cevz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Aug/14 03:56;blackdrag;italics means the compiler did not find a local variable or field for it. It is no error in Groovy unless you use the static compiler. Groovy is a dynamic language after all and allows you to add properties at runtime through meta programming. Thus not showing this as an error is no bug. That you have to prefix is though;;;","15/Aug/14 09:42;mitsu;No, you are wrong. Come on, if you're going to comment on a ticket, at least pay attention and write something accurate. Please do not explain the obvious, especially when you are incorrect.

Italics does NOT mean the compiler did not find a local variable or field for it. Do you even use STS? Italics means the compiler DID find the field. Underline means the compiler did not find the field. The field is italicized and in blue --- which means it recognizes it as a field. Go back and actually use STS. Check before you post.;;;","15/Aug/14 09:48;mitsu;To be more clear about STS: Italics means the IDE thinks the field is a static member. Blue means the IDE thinks the field is defined (and not dynamic). Underline means the IDE did not find the field. The IDE thinks it is a valid field reference, but it fails at runtime.;;;","15/Aug/14 18:57;blackdrag;Looks like I remembered it wrong then. ;;;","18/Aug/14 10:15;blackdrag;Looking at this further it seems that the inner enum does not get the dispatcher methods for inner classes.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
invoking scripts using full path broken in cygwin,GROOVY-7022,12817773,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,schmeic,schmeic,12/Aug/14 14:39,15/Oct/15 18:15,14/Jul/23 06:01,05/Jul/15 15:28,,,,,,,,,,,,,,,,,,2.4.4,,,,GroovyScriptEngine,,,,1,,,,,,,"I installed groovy using:

# gvm install groovy 2.3.6

Then created ~/tmp/Test.groovy:

#!/usr/bin/env groovy

class Test {

    static main(args)
    {
        println(""testing"")
    }
}

If I try to run this as:

# ~/tmp/Test.groovy

I get the following error:

Caught: java.net.MalformedURLException: unknown protocol: c
java.net.MalformedURLException: unknown protocol: c

Same error if I use a full path (i.e., /cygdrive/c/...). However, I can run it from my home directory using a relative path:

# tmp/Test.groovy

This runs fine and prints ""testing"". 

I installed groovy 2.2.2 using gvm and can run the same script no problem using ~ or the full path.
","Windows 7, Cygwin 1.7.17, Java 7 and 8",aharris,pascalschumacher,schmeic,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7018,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jul 05 15:28:24 UTC 2015,,,,,,,,,,"0|i2cpe7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jul/15 15:28;pascalschumacher;Should be fixed by the fix for [GROOVY-7018]. It would be nice if you could check if it works with a recent snapshot, e.g. [https://oss.jfrog.org/oss-snapshot-local/org/codehaus/groovy/groovy-binary/2.4.4-SNAPSHOT/groovy-binary-2.4.4-20150704.030209-101.zip]. Please reopen if it still does not work. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic on templated classes with multiple template constraints,GROOVY-7021,12811956,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,ilbmiller,ilbmiller,12/Aug/14 13:10,28/Dec/14 10:52,14/Jul/23 06:01,28/Dec/14 10:52,2.3.4,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Static Type Checker,,,,0,CompileStatic,,,,,,"A @CompileStatic compilation of the below file
{code}
package myBugReport

import groovy.transform.CompileStatic

@CompileStatic
abstract class MyCompileStaticBugG<TertiaryT extends TertiaryG> {
  TertiaryT myProp

  // workaround: if @CompileDynamic this method, it compiles just fine.  But this is the bug - it should @CompileStatic...
  void load() {
      if (myProp == null)
      {
        myProp = loadProp()
      }
    }

    abstract TertiaryT loadProp()
}

@CompileStatic
abstract class PrimaryG {}

@CompileStatic
abstract class SecondaryG<PrimaryT extends PrimaryG> {}

@CompileStatic
abstract class TertiaryG<PrimaryT extends PrimaryG, SecondaryT extends SecondaryG<PrimaryT>> {}
{code}

results in the following exception:
{code}
Error:Groovyc: java.lang.ArrayIndexOutOfBoundsException: 1
	at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:143)
	at org.codehaus.groovy.ast.tools.GenericsUtils.parameterizeType(GenericsUtils.java:219)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:549)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitIfElse(StaticTypeCheckingVisitor.java:2948)
	at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:41)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1614)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1933)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1892)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:144)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1063)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:240)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:110)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:61)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1047)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:583)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:561)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:538)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:54)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:87)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:100)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:121)
{code}

Unfortunately, the exception gives no clue as to what is wrong in the code (the stacktrace does not reference where the error occurs), so it is a fairly painful bug.  I narrowed it down to the 'load' method in the above simplified version of the code: if I add the @CompileDynamic annotation to the 'load' method, the exception goes away.

Groovy should be able to @CompileStatic, as the equivalent Java code compiles just fine (equivalent java is also included in the zip file).

","Windows 7, jdk 1.8.0_20 64-bit",blmiller,ngalarneau,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/Aug/14 13:10;myBugReport.zip;https://issues.apache.org/jira/secure/attachment/12723150/myBugReport.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 10:52:15 UTC 2014,,,,,,,,,,"0|i2ctvj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Aug/14 09:37;ilbmiller;Changing to more specific component 'Static Type Checker' as resulting exception stack has 'StaticTypeCheckingVisitor' within it.;;;","28/Dec/14 10:52;pschumacher;Thanks for reporting. Your example works for me with groovy 2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Problem With ""this"" Inside Of Anonymous Inner Class",GROOVY-7020,12817742,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,brownj,brownj,12/Aug/14 08:16,07/Dec/20 22:09,14/Jul/23 06:01,21/Nov/20 00:20,2.3.3,2.4.1,,,,,,,,,,,,,,,,2.5.7,3.0.0,,,,,,,0,,,,,,,"If an anonymous inner class is defined inside of a static method, ""this"" does not reference what it should:

{code:title=Demo.groovy|borderStyle=solid}
class Demo {
    static void main(arg) {
        def r = new Runnable() {
            void run() {
                if(this instanceof Runnable) {
                    println 'Yep'
                } else {
                    println 'Nope'
                }
            }
        }
        r.run()
    }
}
{code}

{noformat}
$ groovy Demo
Nope
{noformat}

2.3.3 is the only version I have tested this with.",,brownj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-08-12 08:16:06.0,,,,,,,,,,"0|i2bovj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyClassLoader addClasspath RegexPattern issue,GROOVY-7018,12817764,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,stefan_leo,stefan_leo,11/Aug/14 06:00,21/Jul/15 10:29,14/Jul/23 06:01,02/Jul/15 19:23,2.3.6,,,,,,,,,,,,,,,,,2.4.4,,,,GroovyScriptEngine,,,,2,,,,,,,"When adding Groovy Files from the file system to the GroovyClassLoader's classpath grabbed from a default java properties file (""/"" instead of ""\""))
Then the addClasspath() method uses a simple URL instead of the File URL

This is due to a simple mistake in this mentioned method:

{code}
public void addClasspath(final String path) {
....
     if (!URI_PATTERN.matcher(path).matches()) {
          newURI = new File(path).toURI();
     } else {
          newURI = new URI(path);
     }
}

private static final Pattern URI_PATTERN = Pattern.compile(""\\p{Alpha}[-+.\\p{Alnum}]*:[^\\\\]*"");
{code}

The URI_PATTERN which should match ""URIs but not Windows filenames"" doesn't work as expected.
It matches i.e. C:/xxx/file.ext 
This is related to using forward instead of backslashes - which souldn't matter.

This was i.e. NOT the case for Groovy 2.1.3",JDK 1.7u51,githubbot,ocroquette,pascalschumacher,paulk,Persi,pschumacher,stefan_leo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7097,GROOVY-7022,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 02 19:22:23 UTC 2015,,,,,,,,,,"0|i2bx5b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jan/15 06:25;ocroquette;One of our builds was broken after we updated from Groovy 2.2.1 to 2.3.9. It looks like it's related to this issue.

There are 2 symptoms:

Symptom 1:

Script path with backslashes:

{code}
""c:\Program Files (x86)\Groovy\Groovy-2.2.1\bin\groovy"" -d C:\Users\...\PrintClassPath.groovy
""c:\Program Files (x86)\Groovy\Groovy-2.3.9\bin\groovy"" -d C:\Users\...\PrintClassPath.groovy
{code}

=> Both OK

Script path with forward slashes, Groovy 2.2.1:

{code}
""c:\Program Files (x86)\Groovy\Groovy-2.2.1\bin\groovy"" -d C:/Users/.../PrintClassPath.groovy
{code}

=> OK

Script path with forward slashes, Groovy 2.3.9:

{code}
""c:\Program Files (x86)\Groovy\Groovy-2.3.9\bin\groovy"" -d C:/Users/.../PrintClassPath.groovy
{code}

=> NOK
{code}
Caught: java.net.MalformedURLException: unknown protocol: c
java.net.MalformedURLException: unknown protocol: c
        at java.net.URL.<init>(URL.java:592)
        at java.net.URL.<init>(URL.java:482)
        at java.net.URL.<init>(URL.java:431)
        at java.net.URI.toURL(URI.java:1096)
        at groovy.lang.GroovyCodeSource.<init>(GroovyCodeSource.java:162)
        at groovy.ui.GroovyMain.getScriptSource(GroovyMain.java:450)
        at groovy.ui.GroovyMain.processOnce(GroovyMain.java:650)
        at groovy.ui.GroovyMain.run(GroovyMain.java:381)
        at groovy.ui.GroovyMain.process(GroovyMain.java:367)
        at groovy.ui.GroovyMain.processArgs(GroovyMain.java:126)
        at groovy.ui.GroovyMain.main(GroovyMain.java:106)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
{code}

This happens only if the path doesn't contain *any* backslash.

        
        
Symptom 2 (now tracked in GROOVY-7260)

Only the first component of the classpath provided on the command line is taken in consideration. I don't know if it's the same root cause.
Edit: not the same root cause, issue now tracked in GROOVY-7260

{code}
""c:\Program Files (x86)\Groovy\Groovy-2.2.1\bin\groovy"" -classpath c:\dummy\dummy-2.jar;c:\dummy\dummy.jar -d PrintClassPath.groovy | findstr dummy
- file:/c:/dummy/dummy-2.jar
- file:/c:/dummy/dummy.jar
{code}

{code}
""c:\Program Files (x86)\Groovy\Groovy-2.3.9\bin\groovy"" -classpath c:\dummy\dummy-2.jar;c:\dummy\dummy.jar -d PrintClassPath.groovy | findstr dummy
- file:/c:/dummy/dummy-2.jar
{code}

(both JAR files have to exist for the test to work)


Content of PrintClassPath.groovy:
{code}
def printClassPath(classLoader) {
  println ""From classload $classLoader""
  classLoader.getURLs().each {url->
     println ""- ${url.toString()}""
  }
  if (classLoader.parent) {
     printClassPath(classLoader.parent)
  }
}
printClassPath this.class.classLoader
{code}
;;;","19/Jan/15 06:30;ocroquette;Just an idea for the fix: reuse the functionality to parse URL's:

Before:
{code}
     if (!URI_PATTERN.matcher(path).matches()) {
          newURI = new File(path).toURI();
     } else {
          newURI = new URI(path);
     }
{code}

After:
{code}
    try {
          newURI = new URI(path);
     }
     catch (MalformedURLException e) {
          // fall back to simple path
          newURI = new File(path).toURI();
     }
{code}

This way URI_PATTERN is not required anymore.
;;;","19/Jan/15 06:31;ocroquette;Related commits:
* https://github.com/groovy/groovy-core/commit/e2ea2700fe640bbf604154fad7e553da4a630245
* https://github.com/groovy/groovy-core/commit/644ddc5f49517701cbe753e29a8f67da0ac75b66

;;;","19/Jan/15 07:47;paulk;We might need to do something like the try ... catch. If you go to Jim's original changes, you'll see he was trying to avoid that:

https://github.com/groovy/groovy-core/commit/60a7cd4637fc11766f0b394b880ac0c1b9176d84
https://github.com/groovy/groovy-core/commit/8ca9a44c93eb06a44b023c66dcbf7d2c40818621

See the wording around ""... doesn't hurt file-only classpath [entries] ..."".

My changes fixed some of the File scenarios but as you point out, obviously not all. Obviously, correct behavior is more important than efficiency but I'm wondering whether a combination approach might be best. Perhaps we could attempt to minimize the overhead associated with the extra exception by looking for backslashes or no colon. Use the file logic for those cases as well as in the catch clause.

Then again, I'm not sure what Jim had in mind with his ""... a possibly better approach ..."". That might be worth exploring also/instead.;;;","19/Jan/15 08:02;paulk;Olivier, wrt Symptom 1, what happens if you use a proper URI for your files, e.g.:
{code}
groovy -d file:C:/some/path/to/MyFile.groovy
{code};;;","19/Jan/15 08:04;paulk;Changing priority to ""Major"" since I think the workaround is to prepend file: to windows paths not using windows syntax.;;;","19/Jan/15 08:35;paulk;I believe the workaround for Symptom 2 is to set the CLASSPATH environment variable, e.g.:
{code}
set CLASSPATH=c:\dummy\dummy-2.jar;c:\dummy\dummy.jar
{code}
I believe Symptom 2 is to do with .bat file processing limitations in windows rather than the URI issue. Can you check whether you are using the .bat or .exe file when using 2.2.1? I just tried 2.1.9 and that failed for me with the same error when using the groovy.bat file.;;;","19/Jan/15 10:49;pschumacher;probably [related problem from mailing list|http://groovy.329449.n5.nabble.com/Simple-Groovy-SQL-script-fails-moving-from-2-2-2-to-2-3-8-td5722161.html];;;","20/Jan/15 05:20;ocroquette;{quote}
Olivier, wrt Symptom 1, what happens if you use a proper URI for your files, e.g.:
{code}
groovy -d file:C:/some/path/to/MyFile.groovy
{code}
{quote}
That works;;;","20/Jan/15 05:34;ocroquette;{quote}
I believe Symptom 2 is to do with .bat file processing limitations in windows rather than the URI issue. Can you check whether you are using the .bat or .exe file when using 2.2.1? I just tried 2.1.9 and that failed for me with the same error when using the groovy.bat file.
{quote}

You are right, thanks. I opened a dedicated ticket for the symptom 2: GROOVY-7260
;;;","16/Jun/15 11:16;Persi;We have got the same problem as mentioned by Oliver Croquette with Symptom 1. So I tried to create a small fix in the 2 above mentioned Groovy classes GroovyMain and GroovyClassLoader.

It looks like the following:
{code:title=GroovyMain#getScriptSource|borderStyle=solid}

protected GroovyCodeSource getScriptSource(boolean isScriptFile, String script) throws IOException, URISyntaxException {
  //check the script is currently valid before starting a server against the script
  if (isScriptFile) {
     // search for the file and if it exists don't try to use URIs ...
     File scriptFile = huntForTheScriptFile(script);
     if (!scriptFile.exists() && uriPattern.matcher(script).matches()) {
        return new GroovyCodeSource(new URI(script));
     }
        return new GroovyCodeSource(scriptFile);
  }
  return new GroovyCodeSource(script, ""script_from_command_line"", GroovyShell.DEFAULT_CODE_BASE);
}
{code}

{code:title=GroovyClassloader#addClasspath|borderStyle=solid}
final File file = new File(path);
// search for the file and if it exists don't try to use URIs ...
if ( file.exists() ) {
  newURI = file.toURI();
} else {
  newURI = new URI(path);
}
{code}

For our scripts this works for both cases Oliver mentioned above.

I'm not sure if this fits all problems, but if it does i would create a pull request.;;;","23/Jun/15 18:18;pascalschumacher;Please create a pull request, that makes reviewing easier/merging. Thanks! :);;;","24/Jun/15 12:41;githubbot;GitHub user Persi opened a pull request:

    https://github.com/apache/incubator-groovy/pull/43

    GROOVY-7018 GroovyClassLoader addClasspath RegexPattern issue

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/Persi/incubator-groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/43.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #43
    
----
commit 6cf17e1d171503b5e86f5e29098d0cb619e94959
Author: Persi <the_hammer1@freenet.de>
Date:   2015-06-24T09:09:35Z

    GROOVY-7018 GroovyClassLoader addClasspath RegexPattern issue
    
    GroovyMain and GroovyClassLoader had problems in Cygwin environments
    with finding Scripts.

commit cdcb16930bf5ef63b6c6eff9f50f644353c85d0e
Author: Persi <the_hammer1@freenet.de>
Date:   2015-06-24T09:15:53Z

    Revert ""GROOVY-7018 GroovyClassLoader addClasspath RegexPattern issue""
    
    This reverts commit 6cf17e1d171503b5e86f5e29098d0cb619e94959.

commit 6495a83e5f047719fc85d6f09a4334c8ad94eccb
Author: Persi <the_hammer1@freenet.de>
Date:   2015-06-24T09:20:16Z

    Revert ""Revert ""GROOVY-7018 GroovyClassLoader addClasspath RegexPattern issue""""
    
    This reverts commit cdcb16930bf5ef63b6c6eff9f50f644353c85d0e.

commit c86f4a54ab282b84ea9aabd67721894b93e9d093
Author: Persi <the_hammer1@freenet.de>
Date:   2015-06-24T12:40:12Z

    GROOVY-7018 GroovyClassLoader addClasspath RegexPattern issue
    
    GroovyClassLoaderTest is now running succesfully with the new
    ClassLoaderCode.

----
;;;","24/Jun/15 12:45;Persi;Hello Pascal,

I've created a pull request:
https://github.com/apache/incubator-groovy/pull/43
;;;","30/Jun/15 22:45;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/43#discussion_r33632554
  
    --- Diff: src/main/groovy/ui/GroovyMain.java ---
    @@ -391,17 +391,16 @@ public String getText(String uriOrFilename) throws IOException {
         protected GroovyCodeSource getScriptSource(boolean isScriptFile, String script) throws IOException, URISyntaxException {
             //check the script is currently valid before starting a server against the script
             if (isScriptFile) {
    -            if (uriPattern.matcher(script).matches()) {
    +            // search for the file and if it exists don't try to use URIs ...
    +            File scriptFile = huntForTheScriptFile(script);
    +            if (!scriptFile.exists() && uriPattern.matcher(script).matches()) {
                     return new GroovyCodeSource(new URI(script));
    -            } else {
    -                return new GroovyCodeSource(huntForTheScriptFile(script));
                 }
    -        } else {
    -            return new GroovyCodeSource(script, ""script_from_command_line"", GroovyShell.DEFAULT_CODE_BASE);
    +            return new GroovyCodeSource(huntForTheScriptFile(script));
    --- End diff --
    
    can't you just use ""scriptFile"" instead of the second call to ""huntForTheScriptFile""?
;;;","01/Jul/15 06:52;githubbot;Github user Persi commented on a diff in the pull request:

    https://github.com/apache/incubator-groovy/pull/43#discussion_r33652610
  
    --- Diff: src/main/groovy/ui/GroovyMain.java ---
    @@ -391,17 +391,16 @@ public String getText(String uriOrFilename) throws IOException {
         protected GroovyCodeSource getScriptSource(boolean isScriptFile, String script) throws IOException, URISyntaxException {
             //check the script is currently valid before starting a server against the script
             if (isScriptFile) {
    -            if (uriPattern.matcher(script).matches()) {
    +            // search for the file and if it exists don't try to use URIs ...
    +            File scriptFile = huntForTheScriptFile(script);
    +            if (!scriptFile.exists() && uriPattern.matcher(script).matches()) {
                     return new GroovyCodeSource(new URI(script));
    -            } else {
    -                return new GroovyCodeSource(huntForTheScriptFile(script));
                 }
    -        } else {
    -            return new GroovyCodeSource(script, ""script_from_command_line"", GroovyShell.DEFAULT_CODE_BASE);
    +            return new GroovyCodeSource(huntForTheScriptFile(script));
    --- End diff --
    
    Hello Paul,
    
    indeed I could reduce the calls to ""huntForTheScriptFile"" to one.
    
    I'll commit it.

;;;","02/Jul/15 19:22;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/43
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GStringTemplateEngine leaks classes,GROOVY-7017,12817715,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,candrews,candrews,09/Aug/14 02:12,05/Apr/15 14:44,14/Jul/23 06:01,26/Sep/14 02:40,2.3.6,,,,,,,,,,,,,,,,,2.3.8,,,,Templating,,,,0,,,,,,,"I discovered this issue while working on https://jira.grails.org/browse/GRAILS-11296

Each time GStringTemplateEngine compiles a template, it makes a new class. However, it makes all those new classes on the main (parent) class loader. Since that class loader has loaded many other classes that won't ever get GC'ed, and a class can only be GC'ed when it's class loader is GC'ed and vice versa, these GStringTemplateEngine created classes can never be GC'ed. With enough invocations, memory is exhausted. These classes show up in memory dumps as ""GStringTemplateScript"" followed by a number.",,candrews,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Fri Sep 26 02:40:47 UTC 2014,,,,,,,,,,"0|i2bsif:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Aug/14 02:15;candrews;https://github.com/groovy/groovy-core/pull/501;;;","26/Sep/14 02:40;melix;In order to avoid a breaking change, the option to reuse an existing GroovyClassLoader has been made available through a system property:

{code}
-Dgroovy.GStringTemplateEngine.reuseClassLoader=true
{code}

Thanks Craig!
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AutoClone does not check for existing copy constructor,GROOVY-7016,12811426,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,venkats,venkats,08/Aug/14 13:09,22/May/22 16:05,14/Jul/23 06:01,09/Aug/14 05:58,2.4.0-beta-2,,,,,,,,,,,,,,,,,2.3.7,2.4.0-beta-3,,,groovy-jdk,,,,0,ClassFormatError,,,,,,"@AutoClone with COPY_CONSTRUCTOR style does not check if a copy constructor already exists. There are times when the author may want to write their own copy constructor.

Please see example below:

{code}
import groovy.transform.AutoClone
import groovy.transform.AutoCloneStyle

@AutoClone(style = AutoCloneStyle.COPY_CONSTRUCTOR)
class MyClass {
  MyClass(MyClass other) {
    println 'custom copy constructor'
  }
}
{code}

If we compile and examine the generated code, we see duplication:

{noformat}
> groovyc MyClass.groovy 
> javap -c MyClass | grep ""MyClass(""
  protected MyClass(MyClass);
  protected MyClass(MyClass);
> 
{noformat}

This leads to compilation error later when MyClass.class is used in another code, like so,
{noformat}
Caught: java.lang.ClassFormatError: Duplicate method name&signature in class file MyClass
java.lang.ClassFormatError: Duplicate method name&signature in class file MyClass
{noformat}
",,paulk,venkats,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 09 05:58:18 UTC 2014,,,,,,,,,,"0|i2c3wv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Aug/14 17:28;paulk;Yes, producing the duplicate signature is a bug. The two options to fix would be to produce an error if an existing one is found or allow the custom version. I see no harm in allowing the custom version. In that case, the {{@AutoClone}} would simply add the clone method which would call the already provided this constructor. Is that your expectation too?;;;","08/Aug/14 17:43;venkats;Yes, allowing the custom version is important as there are times when the generated copy constructor is not suitable or sufficient.;;;","09/Aug/14 05:58;paulk;Should be in the next release. Thanks for the suggestion.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy static type checking doesn't solve the generic types properly (behavior is different than Java),GROOVY-7015,12817741,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,harminder,harminder,08/Aug/14 08:46,17/Dec/14 13:25,14/Jul/23 06:01,13/Nov/14 09:00,2.3.4,,,,,,,,,,,,,,,,,2.3.8,2.4.0-beta-4,,,Static Type Checker,,,,2,,,,,,,"In the following code, the type of myVar variable is of type Base instead of Derived.  This behavior is different than Java.  
{code}
class Base {}
class Derived extends Base {
  public void sayHello() {
    System.out.println(""hello"");
  }
}

class GBase<T extends Base>{
  T myVar;
}
@CompileStatic
class GDerived extends GBase<Derived>
{
  GDerived() { myVar = new Derived(); }
  public void method() {
    // Groovy compiler thinks myVar is of type base and doesn't have sayHello
    myVar.sayHello();
  }
}

public class Main
{
  public static void main(String[] args)
  {
    GDerived d = new GDerived();
    d.method();
  }
}
{code}",,blackdrag,harminder,ngalarneau,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 13 09:55:00 UTC 2014,,,,,,,,,,"0|i2bo3b:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Nov/14 09:19;ngalarneau;I think this bug is Major, not Minor.

This bug is hurting us because @CompileStatic says everything is ok, but at run time you get bad results.

We have used Generics in some of our base classes & this bug keeps biting us.

Could this bug get some attention?

Thanks,
Neil;;;","13/Nov/14 09:00;blackdrag;fixed;;;","13/Nov/14 09:55;ngalarneau;Thanks a lot blackdrag. This is great news!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
A Java compile time error results in a runtime exception in Groovy,GROOVY-7014,12817771,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,harminder,harminder,08/Aug/14 08:17,27/Aug/17 21:21,14/Jul/23 06:01,17/Aug/16 14:21,2.3.4,2.4.0-rc-1,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,Static compilation,,,,0,,,,,,,"A Groovy class with CompileStatic annotation exhibit a different behavior than Java.  The following code results in a compile time error in Java, but throws a runtime exception in Groovy.
{code}
@CompileStatic
class Base
{
  String getData() { return ""ABCD"" }
  Base() { this(getData()) } // Calling an instance method before the class is constructed

  Base(String arg) {}
}

@CompileStatic
public class GMain
{
  public static void main(String[] args)
  {
    Base b = new Base();
  }
}
{code}

Java produces:
{noformat}
Java Compiler error: Error:(11, 11) java: cannot reference this before supertype constructor has been called
{noformat}

Groovy produces:
{noformat}
Groovy Runtime Error details:
Exception in thread ""main"" java.lang.ClassCastException: java.lang.Class cannot be cast to main.groovy.Base
	at main.groovy.Base.<init>(Base.groovy:9)
	at main.groovy.Derived.<init>(Derived.groovy)
	at main.groovy.GMain.main(Base.groovy:18)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        ......
{noformat}
",Window 7,githubbot,harminder,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8303,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 17 14:21:56 UTC 2016,,,,,,,,,,"0|i2c37r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Aug/16 12:33;paulk;If you look at what is being produced with @CompileStatic it is replacing getData() with Base.getData(). It obviously shouldn't but explains why it then passes static type checking and you get the weird cast error.

Also, if you remove the @CompileStatic or change it to @TypeChecked,  you then get a VerifyError!
Changing the getData method to static of course works as expected.;;;","10/Aug/16 07:51;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/381

    GROOVY-7014: A Java compile time error results in a runtime exception…

    … in Groovy

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7014

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/381.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #381
    
----

----
;;;","13/Aug/16 19:02;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/381#discussion_r74690791
  
    --- Diff: src/main/org/codehaus/groovy/control/StaticImportVisitor.java ---
    @@ -317,6 +337,10 @@ protected Expression transformMethodCallExpression(MethodCallExpression mce) {
             return result;
         }
     
    +    private boolean isInnerClass(ClassNode currentClass) {
    --- End diff --
    
    There was an identical method added to `StaticVerifier`, how about replacing both with a static method in `ClassNodeUtils`?
;;;","13/Aug/16 19:28;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/381#discussion_r74691103
  
    --- Diff: src/main/org/codehaus/groovy/ast/tools/ClassNodeUtils.java ---
    @@ -65,4 +73,122 @@ public static void addDeclaredMethodMapsFromSuperInterfaces(ClassNode cn, Map<St
                 sn = sn.getSuperClass();
             }
         }
    +
    +    /**
    +     * Returns true if the given method has a possibly matching static method with the given name and arguments.
    +     *
    +     * @param cNode     the ClassNode of interest
    +     * @param name      the name of the method of interest
    +     * @param arguments the arguments to match against
    +     * @param trySpread whether to try to account for SpreadExpressions within the arguments
    +     * @return true if a matching method was found
    +     */
    +    public static boolean hasPossibleStaticMethod(ClassNode cNode, String name, Expression arguments, boolean trySpread) {
    +        int count = 0;
    +        boolean foundSpread = false;
    +
    +        if (arguments instanceof TupleExpression) {
    +            TupleExpression tuple = (TupleExpression) arguments;
    +            for (Expression arg : tuple.getExpressions()) {
    +                if (arg instanceof SpreadExpression) {
    +                    foundSpread = true;
    +                } else {
    +                    count++;
    +                }
    +            }
    +        } else if (arguments instanceof MapExpression) {
    +            count = 1;
    +        }
    +
    +        for (MethodNode method : cNode.getMethods(name)) {
    +            if (method.isStatic()) {
    +                Parameter[] parameters = method.getParameters();
    +                // do fuzzy match for spread case: count will be number of non-spread args
    +                if (trySpread && foundSpread && parameters.length >= count) return true;
    +
    +                if (parameters.length == count) return true;
    +
    +                // handle varargs case
    +                if (parameters.length > 0 && parameters[parameters.length - 1].getType().isArray()) {
    +                    if (count >= parameters.length - 1) return true;
    +                    // fuzzy match any spread to a varargs
    +                    if (trySpread && foundSpread) return true;
    +                }
    +
    +                // handle parameters with default values
    +                int nonDefaultParameters = 0;
    +                for (Parameter parameter : parameters) {
    +                    if (!parameter.hasInitialExpression()) {
    +                        nonDefaultParameters++;
    +                    }
    +                }
    +
    +                if (count < parameters.length && nonDefaultParameters <= count) {
    +                    return true;
    +                }
    +                // TODO handle spread with nonDefaultParams?
    +            }
    +        }
    +        return false;
    +    }
    +
    +    /**
    +     * Return true if we have a static accessor
    +     */
    +    public static boolean hasPossibleStaticProperty(ClassNode candidate, String methodName) {
    +        // assume explicit static method call checked first so we can assume a simple check here
    +        if (!methodName.startsWith(""get"") && !methodName.startsWith(""is"")) {
    +            return false;
    +        }
    +        String propName = getPropNameForAccessor(methodName);
    +        PropertyNode pNode = getStaticProperty(candidate, propName);
    +        return pNode != null && (methodName.startsWith(""get"") || boolean_TYPE.equals(pNode.getType()));
    +    }
    +
    +    /**
    +     * Returns the property name, e.g. age, given an accessor name, e.g. getAge.
    +     * Returns the original if a valid prefix cannot be removed.
    +     *
    +     * @param accessorName the accessor name of interest, e.g. getAge
    +     * @return the property name, e.g. age, or original if not a valid property accessor name
    +     */
    +    public static String getPropNameForAccessor(String accessorName) {
    +        int prefixLength = accessorName.startsWith(""is"") ? 2 : 3;
    +        if (accessorName.length() < prefixLength + 1) return accessorName;
    +        if (!isValidAccessorName(accessorName)) return accessorName;
    --- End diff --
    
    Would it make sense to move the length check to the `isValidAccessorName` method below?  That would ensure `isValidAccessorName` would not return true for methods named `get()`/`is()`/`set()`.
;;;","16/Aug/16 05:18;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/381#discussion_r74877325
  
    --- Diff: src/main/org/codehaus/groovy/ast/tools/ClassNodeUtils.java ---
    @@ -65,4 +73,122 @@ public static void addDeclaredMethodMapsFromSuperInterfaces(ClassNode cn, Map<St
                 sn = sn.getSuperClass();
             }
         }
    +
    +    /**
    +     * Returns true if the given method has a possibly matching static method with the given name and arguments.
    +     *
    +     * @param cNode     the ClassNode of interest
    +     * @param name      the name of the method of interest
    +     * @param arguments the arguments to match against
    +     * @param trySpread whether to try to account for SpreadExpressions within the arguments
    +     * @return true if a matching method was found
    +     */
    +    public static boolean hasPossibleStaticMethod(ClassNode cNode, String name, Expression arguments, boolean trySpread) {
    +        int count = 0;
    +        boolean foundSpread = false;
    +
    +        if (arguments instanceof TupleExpression) {
    +            TupleExpression tuple = (TupleExpression) arguments;
    +            for (Expression arg : tuple.getExpressions()) {
    +                if (arg instanceof SpreadExpression) {
    +                    foundSpread = true;
    +                } else {
    +                    count++;
    +                }
    +            }
    +        } else if (arguments instanceof MapExpression) {
    +            count = 1;
    +        }
    +
    +        for (MethodNode method : cNode.getMethods(name)) {
    +            if (method.isStatic()) {
    +                Parameter[] parameters = method.getParameters();
    +                // do fuzzy match for spread case: count will be number of non-spread args
    +                if (trySpread && foundSpread && parameters.length >= count) return true;
    +
    +                if (parameters.length == count) return true;
    +
    +                // handle varargs case
    +                if (parameters.length > 0 && parameters[parameters.length - 1].getType().isArray()) {
    +                    if (count >= parameters.length - 1) return true;
    +                    // fuzzy match any spread to a varargs
    +                    if (trySpread && foundSpread) return true;
    +                }
    +
    +                // handle parameters with default values
    +                int nonDefaultParameters = 0;
    +                for (Parameter parameter : parameters) {
    +                    if (!parameter.hasInitialExpression()) {
    +                        nonDefaultParameters++;
    +                    }
    +                }
    +
    +                if (count < parameters.length && nonDefaultParameters <= count) {
    +                    return true;
    +                }
    +                // TODO handle spread with nonDefaultParams?
    +            }
    +        }
    +        return false;
    +    }
    +
    +    /**
    +     * Return true if we have a static accessor
    +     */
    +    public static boolean hasPossibleStaticProperty(ClassNode candidate, String methodName) {
    +        // assume explicit static method call checked first so we can assume a simple check here
    +        if (!methodName.startsWith(""get"") && !methodName.startsWith(""is"")) {
    +            return false;
    +        }
    +        String propName = getPropNameForAccessor(methodName);
    +        PropertyNode pNode = getStaticProperty(candidate, propName);
    +        return pNode != null && (methodName.startsWith(""get"") || boolean_TYPE.equals(pNode.getType()));
    +    }
    +
    +    /**
    +     * Returns the property name, e.g. age, given an accessor name, e.g. getAge.
    +     * Returns the original if a valid prefix cannot be removed.
    +     *
    +     * @param accessorName the accessor name of interest, e.g. getAge
    +     * @return the property name, e.g. age, or original if not a valid property accessor name
    +     */
    +    public static String getPropNameForAccessor(String accessorName) {
    +        int prefixLength = accessorName.startsWith(""is"") ? 2 : 3;
    +        if (accessorName.length() < prefixLength + 1) return accessorName;
    +        if (!isValidAccessorName(accessorName)) return accessorName;
    --- End diff --
    
    I refactored to support this. It means we calculate the prefix length an extra time in one case but the code reads better which I think is more important.
;;;","16/Aug/16 05:30;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/381#discussion_r74878003
  
    --- Diff: src/main/org/codehaus/groovy/control/StaticImportVisitor.java ---
    @@ -317,6 +337,10 @@ protected Expression transformMethodCallExpression(MethodCallExpression mce) {
             return result;
         }
     
    +    private boolean isInnerClass(ClassNode currentClass) {
    --- End diff --
    
    Done
;;;","17/Aug/16 04:41;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/381
;;;","17/Aug/16 14:21;paulk;Proposed PR applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyDoc cannot parse several .java files from java 1.7 source code,GROOVY-7013,12811425,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,thanhtt,thanhtt,06/Aug/14 22:26,02/May/17 02:03,14/Jul/23 06:01,15/Mar/15 19:22,1.7.11,2.3.6,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,GroovyDoc,,,,0,,,,,,,"When I use groovydoc to parse .java files from java [1.7 source code|http://sourceforge.net/projects/jdk7src/], I am facing the error.
{noformat}
line 624:43: expecting IDENT, found '|'
ignored due to RecognitionException: ManagementFactory.java [expecting EOF, found '}']
...
line 306:40: unexpected token: >
ignored due to RecognitionException: PlatformComponent.java [expecting EOF, found 'for']
line 1498:33: expecting LCURLY, found '('
ignored due to RecognitionException: MethodHandleImpl.java [expecting EOF, found 'if']
line 87:32: unexpected token: >
ignored due to RecognitionException: ReflectAccess.java [expecting EOF, found '}']
line 241:27: unexpected token: >
line 244:20: unexpected token: Object
line 247:20: unexpected token: long
line 248:20: unexpected token: Object
line 251:20: unexpected token: Map
line 258:15: unexpected token: InvocationHandler
line 263:13: unexpected token: Proxy
line 273:15: unexpected token: Proxy
ignored due to RecognitionException: Proxy.java [expecting EOF, found 'this']
line 158:46: unexpected token: >
ignored due to RecognitionException: Constructor.java [expecting EOF, found 'res']
line 2312:52: unexpected token: >
ignored due to RecognitionException: String.java [expecting EOF, found 'while']
line 327:55: unexpected token: >
ignored due to RecognitionException: ClassValue.java [expecting EOF, found 'Version']
line 266:57: unexpected token: >
line 272:19: unexpected token: ProtectionDomain
line 278:19: unexpected token: Set
ignored due to RecognitionException: ClassLoader.java [expecting EOF, found 'void']
line 73:38: unexpected token: >
ignored due to RecognitionException: ProcessEnvironment.java [expecting EOF, found 'for']
line 79:48: unexpected token: ffffeP
line 90:25: unexpected token: float
line 99:25: unexpected token: float
line 109:25: unexpected token: int
line 118:25: unexpected token: int
line 125:25: unexpected token: int
line 133:25: unexpected token: Class
line 201:19: unexpected token: String
ignored due to RecognitionException: Float.java [expecting EOF, found '}']
line 1632:19: expecting SEMI, found ','
ignored due to RecognitionException: Thread.java [expecting EOF, found 'for']
line 1381:32: unexpected token: ?
ignored due to RecognitionException: Class.java [expecting EOF, found 'Class']
line 939:44: unexpected token: >
ignored due to RecognitionException: Throwable.java [expecting EOF, found 'for']
line 56:25: unexpected token: >
line 57:26: unexpected token: ThreadLocal
line 60:20: unexpected token: boolean
line 62:20: unexpected token: <
ignored due to RecognitionException: StringCoding.java [expecting EOF, found 'if']
ignored due to TokenStreamException: Character.java [unexpected char: 0x0]
line 85:44: unexpected token: >
ignored due to RecognitionException: CharacterName.java [expecting EOF, found '}']
line 584:13: expecting LCURLY, found '('
ignored due to RecognitionException: Package.java [expecting EOF, found 'JarInputStream']
line 50:41: unexpected token: >
ignored due to RecognitionException: ApplicationShutdownHooks.java [expecting EOF, found '}']
line 218:38: unexpected token: >
ignored due to RecognitionException: ProcessBuilder.java [expecting EOF, found 'for']
line 79:49: unexpected token: ffffffffffffP
line 90:25: unexpected token: double
line 100:25: unexpected token: double
line 110:25: unexpected token: int
line 119:25: unexpected token: int
line 126:25: unexpected token: int
line 134:25: unexpected token: Class
line 198:19: unexpected token: String
ignored due to RecognitionException: Double.java [expecting EOF, found '}']
line 670:23: unexpected token: ffffep
ignored due to RecognitionException: Math.java [expecting EOF, found 'else']
{noformat}",,paulk,thanhtt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/Jan/15 07:40;paulk;groovy7013_multicatch_java_grammar.patch;https://issues.apache.org/jira/secure/attachment/12723113/groovy7013_multicatch_java_grammar.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Mar 15 19:22:39 UTC 2015,,,,,,,,,,"0|i2c1qv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Aug/14 17:25;paulk;Yes, the {{java.g}} grammar file for Java that Groovydoc (among other things) uses needs to be updated for Java 7+.;;;","18/Jan/15 07:40;paulk;patch augments java.g to accept multi-catch

not to be applied as is: test relies on gradle tweaks for source compatibility but perhaps test isn't strictly necessary

build passes but I haven't run a complete doc generation or checked if there are any further impacts of the java.g change;;;","15/Mar/15 19:22;paulk;I changed the java grammar to handle multi-catch. Thanks for reporting the issue. If you get a chance to test a snapshot release, that would be great.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Newify with String parameter without parenthesis gives a compiler error,GROOVY-7012,12817749,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,venkats,venkats,06/Aug/14 18:02,08/Mar/22 12:16,14/Jul/23 06:01,29/Oct/21 20:36,2.4.0-beta-2,,,,,,,,,,,,,,,,,,,,,xforms,,,,0,,,,,,,"@Newify works fine with parenthesis, also without parenthesis for number parameter, but not for String. Please see the example below.
{code}
class MyClass {
  MyClass(int value) {}
  MyClass(String value) {}
}

@Newify(MyClass)
def create1() {
  MyClass(1) //OK
}

@Newify(MyClass)
def create2() {
  MyClass('hello') //OK
}

@Newify(MyClass)
def create3() {
  MyClass 1 //OK
}

@Newify(MyClass)
def create4() {
  MyClass 'hello' //ERROR
}

println create1()
println create2()
println create3()
println create4()
{code}
",,blackdrag,emilles,paulk,venkats,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 29 20:36:20 UTC 2021,,,,,,,,,,"0|i2c593:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Aug/14 00:10;paulk;Seems not related to @Newify per se. The grammar has special provisions in certain spots to deal with names that look like class names. I presume this is an unintended application of one of those grammar rules.
{code}
def myMethod(x){ println x }
def MyMethod(y){ println y }
def create5() {
  myMethod 'hello'  // OK
  MyMethod 'hello'  // error: unexpected token: hello at line: 5, column: 12
}

create5()
{code}
As with your example, this error is during parsing, i.e. rejected before it would have a chance to be manipulated by an AST transform.;;;","07/Aug/14 02:41;blackdrag;In Groovy it is legal to declare a variable like this:{code}T ""t""{code} This is also the exact same syntax for a method call using method T and a String parameter. That means the expression is ambiguous. We decided in the past, that for now we will say, that if the ""method"" starts with an uppercase letter, it is actually a class, thus the code example is a declaration and not a method call. ;;;","07/Aug/14 17:27;paulk;So I guess we need the parser to correctly parse that as a declaration then?;;;","08/Aug/14 05:02;blackdrag;first of all... you mean method call ;) Well in case of ""t 't'"" we have the same problem with a declaration. In case of the method call the workaround is easy though... ""this.T 't'"" will be recognized as method call and in case of the declaration import-as can be used. I think the import workaround is good enough. What potentially needs a fix is the method call version then. But to know here if it is a method call or a declaration, the only rule I can think of, is to check if the potential declaration type can be found or not and then make it a declaration if it can be found, or otherwise make it a method call. This would mean though many many more class lookups by the compiler.

;;;","08/Aug/14 17:08;paulk;The {{T ""t""}} syntax doesn't appear to work at the moment, so some kind of fix appears needed. We'll need to investigate further.;;;","29/Oct/21 20:36;emilles;All of these examples work under the new parser.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Trait methods with default arguments do not work correctly,GROOVY-7011,12817740,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,longwa,longwa,06/Aug/14 11:03,29/Oct/15 07:22,14/Jul/23 06:01,22/Dec/14 03:28,2.3.6,,,,,,,,,,,,,,,,,2.3.10,2.4.0-rc-1,,,,,,,0,,,,,,,"The following code:

{code}
trait HiSupport {
   def sayHi(String msg = ""hi"") {
       println msg
   }
}

class A implements HiSupport { }

new A().sayHi()
{code}

Produces incorrect results. The trait method is called without any dispatching complaints, however it just ignores the default argument.

If default arguments are not supported, it seems like it should be a compile failure or at least a failure during dispatch.

If the trait method has multiple arguments, the method dispatch does result in a failure:

{code}
trait HiSupport {
   def sayHi(String name, String msg = ""hi"") {
       println msg + name
   }
}

class A implements HiSupport { }

new A().sayHi(""Bob"")
{code}

{code}
groovy.lang.MissingMethodException: No signature of method: A.sayHi() is applicable for argument types: (java.lang.String) values: [Bob]
Possible solutions: sayHi(java.lang.String, java.lang.String), wait(), any(), each(groovy.lang.Closure), asType(java.lang.Class), wait(long)
	at ConsoleScript50.run(ConsoleScript50:9)
{code}","OSX 10.9, Java 1.7_67",blackdrag,ddimitrov,longwa,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 29 07:21:26 UTC 2015,,,,,,,,,,"0|i2byuv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Oct/15 01:54;ddimitrov;This was closed and currently the compiler issues an error.
Is there a reason why it is not possible to just generate the overloads?

i.e. being able to write this:
{code}
MessageValue await(String description='', MessageValue pattern=lastSent.get()) { 
   ... 
}
{code}

instead of:
{code}
    MessageValue await() { await '', null }
    MessageValue await(String description) { await description, null }
    MessageValue await(MessageValue<ICommand> pattern) { await '', pattern }
    MessageValue await(String description, MessageValue pattern) {
        ...(description, pattern ?: lastSent.get())
    }
{code};;;","29/Oct/15 07:20;blackdrag;what Groovy version do you use?;;;","29/Oct/15 07:21;blackdrag;btw,  >>MessageValue await(MessageValue<ICommand> pattern) { await '', pattern }<< is imho never created;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
try block with finally having nested try causes NPE during compilation,GROOVY-7009,12817669,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,borgold,borgold,05/Aug/14 16:50,28/Dec/14 11:08,14/Jul/23 06:01,28/Dec/14 11:08,1.8.6,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Compiler,,,,0,,,,,,,"This bug was not present in versions junior to 1.8.6. The code structure is as follows:
{code}
try {
    try {
    } catch(ddd) {
    }
} catch (bbb) {
} finally {
    return null
}
{code}

The second try block will cause NPE. The message will be ""NPE while processing <prog_unit_name>"".","Windows 7, JVM 6",blackdrag,borgold,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 11:08:21 UTC 2014,,,,,,,,,,"0|i2c4xj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Aug/14 01:22;paulk;add code tags;;;","06/Aug/14 01:23;paulk;Stacktrace:
{noformat}
groovy.lang.GroovyRuntimeException: NPE while processing ConsoleScript3

	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:256)

	at org.codehaus.groovy.control.CompilationUnit$16.call(CompilationUnit.java:810)

	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1052)

	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:588)

	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:566)

	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:543)

	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:295)

	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:265)

	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:678)

	at groovy.lang.GroovyShell.run(GroovyShell.java:505)

	at groovy.lang.GroovyShell.run(GroovyShell.java:485)

	at groovy.lang.GroovyShell.run(GroovyShell.java:168)

	at groovy.lang.GroovyShell$run$0.call(Unknown Source)

	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:977)

	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)

	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)

	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)

	at java.lang.reflect.Method.invoke(Method.java:606)

	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)

	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)

	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:278)

	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1017)

	at groovy.lang.Closure.call(Closure.java:423)

	at groovy.lang.Closure.call(Closure.java:417)

	at groovy.lang.Closure.run(Closure.java:504)

	at java.lang.Thread.run(Thread.java:745)

Caused by: java.lang.NullPointerException

	at groovyjarjarasm.asm.MethodWriter.visitMaxs(Unknown Source)

	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:389)

	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)

	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:505)

	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1063)

	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)

	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:231)

	... 26 more
{noformat};;;","11/Sep/14 11:27;blackdrag;just an update:
the error happens because the compiler uses end and start reversed in one entry of the exception table;;;","28/Dec/14 11:08;pschumacher;Thanks for reporting. Your example works for me with groovy 2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonOutput / Groovy JSON Builder do not escape special characters in map keys,GROOVY-7008,12811423,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,thomasritter,thomasritter,05/Aug/14 07:43,21/Mar/15 07:11,14/Jul/23 06:01,08/Mar/15 09:32,2.3.2,2.3.6,2.4.0,,,,,,,,,,,,,,,2.4.2,,,,JSON,,,,1,contrib,json,jsonBuilder,,,,"When creating JSON from maps, the keys are not properly quoted. The result ist invalid JSON.

Example code:

def o = [
    'a ""Test""': ""test1"",
    'test2': 'Test ""2""'
];

println JsonOutput.toJson(o);
println JsonOutput.prettyPrint(JsonOutput.toJson(o));

Example code output:

{""a ""Test"""":""test1"",""test2"":""Test \""2\""""}
Caught: groovy.json.JsonException: Lexing failed on line: 1, column: 6, while reading 'T', no possible valid JSON value or punctuation could be recognized.

As you see, 'Test ""2""' is being quoted correctly, but 'a ""Test""' is not. The pretty printing fails parsing the invalid JSON in the second println line.
This happens with JsonBuilder as well.","Linux, Ubuntu Trusty 64 Bit, OpenJDK 7",darxriggs,thomasritter,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7331,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-08-05 07:43:00.0,,,,,,,,,,"0|i2c9fj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Bytecode is too big, please make it smaller.",GROOVY-7007,12817691,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,bodiam,bodiam,05/Aug/14 05:30,21/Jan/15 15:26,14/Jul/23 06:01,16/Jan/15 05:18,2.3.6,2.4.0-beta-2,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,bytecode,,,,0,,,,,,,"Please make bytecode a bit smaller, so Andres can use it in his pet projects.

https://twitter.com/aalmiray/status/496603586256986112",,blackdrag,bodiam,lhotari,mauromol,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 05 07:46:15 UTC 2014,,,,,,,,,,"0|i2cdif:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Aug/14 07:43;blackdrag;If you would try current Groovy 2.4 (master branch), then you would notice that the bytecode got a lot smaller. That's because only last week Cedric and me did some changes. But I found out, I may have to undo some. The biggest pain are those super$ methods we can't 100% get rid of. They are needed for every time you do super.foo() or something like that. 

They are needed because reflection is too stupid to enable us to invoke an overridden method, without using standard method invocation rules. So if your class is overriding a foo() from the parent, there is no way to use reflection to call the parent foo() method, you will always call the child foo() method. So doing a super.foo() in the child foo() will cause an endless loop. that's why we have those super$ methods.

My current fix looks at what method you override and creates super$ method only for those. This will still allow you to have the scenario above. But, nothing prevents you from doing super.foo() without overriding foo(). And if then a child class of your child class overrides the method, you still want to get the parent method called and not the method from the child of the child. And that's where the trouble with this fix starts.

I was thinking about going through all the method calls, to try to limit the amount at least by name - but there are also inner classes.... so this is getting into a bigger piece of work and I am not sure it will lead to a satisfying solution in the end.

With indy it could work entirely without these methods, but I ill have to investigate further to see if the MOP returns the right things for that.

Would indy be a workaround?;;;","05/Aug/14 07:46;blackdrag;ah, forgot to mention... these are of course no problems for @CompileStatic, thus the recent changes make the @CompileStatic version no longer produce these helper methods in most cases;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Compile bug with @Synchronized(""lockname"") and undefined lockname",GROOVY-7005,12817765,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ysb33r,ysb33r,05/Aug/14 02:52,17/Dec/14 13:25,14/Jul/23 06:01,05/Aug/14 03:53,2.3.1,2.3.6,,,,,,,,,,,,,,,,2.3.7,2.4.0-beta-3,,,,,,,0,,,,,,,"When using {{@Synchronized('mylock')}}, but failing to declare {{mylock}} in class, compile fails with bug.

{code}
    import groovy.transform.*

    @CompileStatic
    class A {
        @Synchronized(""mylock"")
        void sync() {
        }
       
    }

    def a = new A()
{code}

Typical error :

{{BUG! exception in phase 'canonicalization' in source unit '/path/to/test.groovy' unexpected NullpointerException}}",,paulk,ysb33r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 05 03:54:37 UTC 2014,,,,,,,,,,"0|i2cn5z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Aug/14 03:15;paulk;As per the Groovydoc, you need to create the {{mylock}} field yourself if you don't go with the default ({{$lock}} or ${{$LOCK}} for static). However, in that case you shouldn't get a BUG message but a compiler error.

It looks as if we already add the appropriate error but then proceed to try to detect further errors which we can't do in this case since the field we would do extra checks on is null. And indeed, returning early (as soon as the error is detected) returns the expected behavior. Not sure when that anomaly crept in. I'll add an extra test to cover that case.

It doesn't seem to be related to @CS.;;;","05/Aug/14 03:53;paulk;Thanks for spotting the issue. Should be fixed now.;;;","05/Aug/14 03:54;paulk;For the example above, the compilation error message is:

Error during @Synchronized processing: lock field with name 'mylock' not found in class A
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot assign closure to property of functional interface type,GROOVY-7003,12811424,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mauromol,mauromol,04/Aug/14 04:38,08/Mar/22 12:16,14/Jul/23 06:01,26/Sep/21 21:09,2.3.6,2.4.5,,,,,,,,,,,,,,,,,,,,Static Type Checker,,,,0,,,,,,,"I don't know if this is on purpose, but I can't understand why it should be.

The following passes the static type checking right:
{code}
package test

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import javax.swing.JFrame;
import groovy.transform.CompileStatic;

@CompileStatic
class TestCompileStatic {

	static final void main(String[] args) {
		JFrame frame = new JFrame()
		frame.name = 'foo'
		PropertyChangeListener listener = { PropertyChangeEvent event ->
			println ""Name changed: ${event.oldValue} -> ${event.newValue}""
		}
		frame.addPropertyChangeListener('name', listener) 
		frame.name = 'bar'
	}
}
{code}

The following does not:
{code}
package test

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;

import javax.swing.JFrame;

import groovy.transform.CompileStatic;

@CompileStatic
class TestCompileStatic2 {

	static PropertyChangeListener listener = { PropertyChangeEvent event ->
		println ""Name changed: ${event.oldValue} -> ${event.newValue}""
	}
	
	static final void main(String[] args) {
		JFrame frame = new JFrame()
		frame.name = 'foo'
		
		frame.addPropertyChangeListener('name', listener) 
		frame.name = 'bar'
	}
}
{code}

The error is:
{noformat}
C:\ws\44\DCS-shop-trunk\TestGroovy\src\main\groovy\test\TestCompileStatic.groovy: 13: [Static type checking] - Cannot assign value of type groovy.lang.Closure <
java.lang.Void> to variable of type java.beans.PropertyChangeListener
 @ line 13, column 43.
   ertyChangeListener listener = { Property
{noformat}",,emilles,mauromol,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 26 21:09:47 UTC 2021,,,,,,,,,,"0|i2crlj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Sep/21 21:09;emilles;Fixed in Groovy 3;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Support MarkupTemplateEngine integration with TemplateServlet,GROOVY-7000,12817750,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,kdabir,kdabir,03/Aug/14 04:41,23/Feb/15 01:12,14/Jul/23 06:01,01/Jan/15 04:11,2.3.9,2.4.0-rc-1,,,,,,,,,,,,,,,,2.3.10,2.4.1,,,Groovlet / GSP,Templating,,,0,,,,,,,"Groovy's TemplateServlet allows init-param to swap the template engine implementation such that the following should work:

{code:xml}
     <init-param>
        <param-name>template.engine</param-name>
        <param-value>groovy.text.markup.MarkupTemplateEngine</param-value>
     </init-param>
{code}

This give's exception :
{code}
SEVERE: javax.servlet.ServletContext log: markupTemplateServlet: Could not instantiate template engine: groovy.text.markup.MarkupTemplateEngine
java.lang.InstantiationException: groovy.text.markup.MarkupTemplateEngine.<init>()
{code}

It understandably wouldn't work as MarkupTemplateEngine doesn't provide any default constructor. Even if it did, there wouldn't be a possibility to pass the desired configuration object to this servlet. ","Java 1.8, Mac 10.9.4, Groovy 2.3.x, Servlet 2.5 (Google App Engine)",kdabir,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 01 04:11:29 UTC 2015,,,,,,,,,,"0|i2crwv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jan/15 03:36;pschumacher;UEHARA Junji submitted a [pull request|https://github.com/groovy/groovy-core/pull/582] with a fix for this issue.;;;","01/Jan/15 04:11;pschumacher;I merged the pull request. Thanks for reporting and thanks for the pull request.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inconsistent method dispatch when method name conflicts with DGM method depending on interfaces implemented by class,GROOVY-6999,12815619,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,tow,tow,01/Aug/14 19:41,11/Aug/22 20:56,14/Jul/23 06:01,11/Aug/22 20:55,2.3.6,2.4.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,,"{code:borderStyle=solid}
interface IFirst { first() }
interface IFirstDef { default first() { ... } }
class A implements IFirst, List { first() { ... } }
class B implements List { first() { ... } }
class C implements IFirstDef, List { first() { ... } }

new A().first()   // calls DGM.first() unless compiled with @CompileStatic
new B().first()   // always calls B.first()
new C().first()   // calls DGM.first() with and without @CompileStatic
{code}

The attachment contains a full repro in the form of unit tests.",,emilles,towtow,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"01/Aug/14 19:41;bug.zip;https://issues.apache.org/jira/secure/attachment/12723149/bug.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 11 20:55:46 UTC 2022,,,,,,,,,,"0|i2ctzj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Aug/22 20:55;emilles;Calls the method on the concrete class for dynamic and static compilation.
{code:groovy}
@groovy.transform.CompileStatic class Groovy6999 {
  interface IFirst { def first() }
  interface IFirstDef { default first() { println 'IFirstDef' } }
  static class A implements IFirst, List    { @Delegate List x = []; def first() { println ""A"" } }
  static class B implements List            { @Delegate List x = []; def first() { println ""B"" } }
  static class C implements IFirstDef, List { @Delegate List x = []; def first() { println ""C"" } }
  static test() {
    new A().first()
    new B().first()
    new C().first()
  }
}
Groovy6999.test()
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovysh breaks terminal after exit (no chars rendered anymore),GROOVY-6998,12817737,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,stunksys,stunksys,01/Aug/14 12:08,17/Dec/14 13:25,14/Jul/23 06:01,02/Sep/14 11:59,2.4.0-beta-2,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Groovysh,,,,0,,,,,,,"After exiting groovysh, the terminal doesn't work anymore. Typed characters don't show up. Hitting enter does not give new command prompt.
Typing ""reset"" (without seeing it) fixes problem.

Steps to reproduce
1) install groovy 2.4.0-beta-2 on ubuntu 14.04, open default terminal
2) type groovysh
3) hit Ctrl+D (or Ctrl+C)

","ksc@ksc-desktop:~$ uname -a
Linux ksc-desktop 3.13.0-29-generic #53-Ubuntu SMP Wed Jun 4 21:00:20 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux
ksc@ksc-desktop:~$ java -version
java version ""1.7.0_55""
OpenJDK Runtime Environment (IcedTea 2.4.7) (7u55-2.4.7-1ubuntu1)
OpenJDK 64-Bit Server VM (build 24.51-b03, mixed mode)
ksc@ksc-desktop:~$ groovy -version
Groovy Version: 2.4.0-beta-2 JVM: 1.7.0_55 Vendor: Oracle Corporation OS: Linux",pschumacher,stunksys,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6859,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 02 11:59:18 UTC 2014,,,,,,,,,,"0|i2c347:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Sep/14 11:59;pschumacher;Thanks for reporting. [This pull request|https://github.com/groovy/groovy-core/pull/507] reverted back to Jline 2.11 until [this Jline issue|https://github.com/jline/jline2/issues/163] is fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Anonymous class field initialized with an enclosing argument results in MissingPropertyException,GROOVY-6996,12811428,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,bhelfert,bhelfert,01/Aug/14 04:10,24/Nov/19 02:45,14/Jul/23 06:01,18/Oct/19 14:08,2.3.3,2.3.4,2.3.5,2.3.6,2.4.1,,,,,,,,,,,,,2.5.9,3.0.0-rc-1,,,,,,,0,,,,,,,"Since Groovy 2.3.3 initializing a field of an anonymous class with an enclosing argument results in a MissingPropertyException:

Code:
{code}
class MissingPropertyExceptionBug {

    interface SomeType {
    }

    static main(args) {
        new SomeType() {
            def arguments = args
        }
    }
}
{code}

...results in:
{code}
Exception in thread ""main"" groovy.lang.MissingPropertyException: No such property: args for class: MissingPropertyExceptionBug
	at groovy.lang.MetaClassImpl.invokeStaticMissingProperty(MetaClassImpl.java:996)
	at groovy.lang.MetaClassImpl.getProperty(MetaClassImpl.java:1851)
	at groovy.lang.MetaClassImpl.getProperty(MetaClassImpl.java:1827)
	at groovy.lang.MetaClassImpl.getProperty(MetaClassImpl.java:3690)
	at org.codehaus.groovy.runtime.InvokerHelper.getProperty(InvokerHelper.java:171)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.getProperty(ScriptBytecodeAdapter.java:452)
	at MissingPropertyExceptionBug$1.propertyMissing(MissingPropertyExceptionBug.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaClassImpl.invokeMissingProperty(MetaClassImpl.java:874)
	at groovy.lang.MetaClassImpl$12.getProperty(MetaClassImpl.java:2018)
	at org.codehaus.groovy.runtime.callsite.GetEffectivePogoPropertySite.getProperty(GetEffectivePogoPropertySite.java:82)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGroovyObjectGetProperty(AbstractCallSite.java:231)
	at MissingPropertyExceptionBug$1.<init>(MissingPropertyExceptionBug.groovy)
	at MissingPropertyExceptionBug.main(MissingPropertyExceptionBug.groovy:7)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
{code}

Workaround:
Use a top-level class instead.",Oracle JDK 1.7.0_60 @ Mavericks,aalmiray,bhelfert,daniel_sun,emilles,,,,,,,,,,,,"eric-milles commented on pull request #1032: GROOVY-6996: adjust 6834 workaround to apply to synthetic variables only
URL: https://github.com/apache/groovy/pull/1032
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;15/Oct/19 18:33;githubbot;600","danielsun1106 commented on issue #1032: GROOVY-6996: adjust 6834 workaround to apply to synthetic variables only
URL: https://github.com/apache/groovy/pull/1032#issuecomment-542453218
 
 
   +1
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Oct/19 00:01;githubbot;600","danielsun1106 commented on pull request #1032: GROOVY-6996: adjust 6834 workaround to apply to synthetic variables only
URL: https://github.com/apache/groovy/pull/1032
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Oct/19 09:30;githubbot;600","danielsun1106 commented on issue #1032: GROOVY-6996: adjust 6834 workaround to apply to synthetic variables only
URL: https://github.com/apache/groovy/pull/1032#issuecomment-543630058
 
 
   Merged. Thanks.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Oct/19 09:30;githubbot;600",,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"01/Aug/14 04:10;bhelfert;MissingPropertyExceptionBug.groovy;https://issues.apache.org/jira/secure/attachment/12722203/MissingPropertyExceptionBug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 18 14:08:26 UTC 2019,,,,,,,,,,"0|i2bs9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Feb/17 13:25;aalmiray;It appears the problem is related to scoping of method arguments. The following script works as expected

{code}
class Outer {
    interface Inner {
    }
    
    static with_default_args(args = 'default args') {
        def my_args = args
        def inner =  new Inner() {
            def arguments = my_args
        }
        println inner.arguments
    }

    static main(args) {
        with_default_args()
        with_default_args('jfokus')
    }
}
{code}

prints the following

{code}
default args
jfokus
{code}

Notice the usage of a local variable to grab a reference to the method args. If the variable is removed and the method arguments are accessed directly then we get an MPE

{code}
groovy> class Outer { 
groovy>     interface Inner { 
groovy>     } 
groovy>      
groovy>     static with_default_args(args = 'default args') { 
groovy>         def inner =  new Inner() { 
groovy>             def arguments = args 
groovy>         } 
groovy>         println inner.arguments 
groovy>     } 
groovy>     static main(args) { 
groovy>         with_default_args() 
groovy>         with_default_args('jfokus') 
groovy>     } 
groovy> } 
 
Exception thrown

groovy.lang.MissingPropertyException: No such property: args for class: Outer
	at Outer$1.propertyMissing(ConsoleScript26)
	at Outer$1.<init>(ConsoleScript26)
	at Outer.with_default_args(ConsoleScript26:6)
	at Outer.with_default_args(ConsoleScript26)
	at Outer.main(ConsoleScript26:13)
{code}

Tested with Groovy 2.4.8;;;","15/Oct/19 17:19;emilles;{{VariableScopeVisitor}} records references to local variable and parameters. It has a check added for GROOVY-6834 that when removed causes this case to succeed.
{code:java}
    public void visitConstructorCallExpression(ConstructorCallExpression call) {
        ...
        for (FieldNode field : innerClass.getFields()) {
            final Expression expression = field.getInitialExpression();
            pushState(field.isStatic());
            if (expression != null) {
// from here
                if (expression instanceof VariableExpression) {
                    VariableExpression vexp = (VariableExpression) expression;
                    if (vexp.getAccessedVariable() instanceof Parameter) {
                        // workaround for GROOVY-6834: accessing a parameter which is not yet seen in scope
                        popState();
                        continue;
                    }
                }
// to here
                expression.visit(this);
            }
            popState();
        }
{code};;;","18/Oct/19 14:08;daniel_sun;The proposed PR was merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CliBuilder.usage() fails with SIOBE if header/footer longer than 74 chars,GROOVY-6991,12811953,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,chaves,chaves,30/Jul/14 17:12,02/May/17 02:03,14/Jul/23 06:01,21/May/15 11:48,2.4.1,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,command line processing,,,,0,,,,,,,"Have a CliBuilder, set a string longer that HelpFormatter.DEFAULT_WIDTH, and try to show usage.

{code}
		CliBuilder cli = new CliBuilder()
		cli.header = (1..cli.width).collect{'x'}.join()
		cli.usage()
		cli.header = (1..cli.width+1).collect{'x'}.join()
		cli.usage() // SIOBE
{code}

Result is:

{code}
usage: groovy
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

Exception in thread ""main"" java.lang.StringIndexOutOfBoundsException: String index out of range: 75
	at java.lang.String.charAt(String.java:658)
	at org.apache.commons.cli.HelpFormatter.findWrapPos(HelpFormatter.java:904)
	at org.apache.commons.cli.HelpFormatter.renderWrappedText(HelpFormatter.java:812)
	at org.apache.commons.cli.HelpFormatter.printWrapped(HelpFormatter.java:694)
	at org.apache.commons.cli.HelpFormatter.printWrapped(HelpFormatter.java:679)
	at org.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:486)
	at org.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:443)
	at org.apache.commons.cli.HelpFormatter$printHelp.call(Unknown Source)
	at groovy.util.CliBuilder.usage(CliBuilder.groovy:275)
	at groovy.util.CliBuilder$usage.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at com.pixeon.medical.pacs.tool.config.TestWithFiles.main(TestWithFiles.groovy:26)
{code}

Workaround is to overwrite CliBuilder.width to a large number.",,paulk,rchaves,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 21 11:48:20 UTC 2015,,,,,,,,,,"0|i2crn3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/May/15 11:48;paulk;This appears to be fixed with Commons CLI 1.3:
{code}
def cli = new CliBuilder()
cli.header = 'x' * cli.width
cli.usage()
cli.header = 'x' * (cli.width * 20)
cli.usage()  // no SIOBE and prints 20 lines of x's
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
.each{..} Closure With Parameter Typed As Object[] Makes Arguments Object[Object[]],GROOVY-6989,12811427,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,nalandial,nalandial,30/Jul/14 12:45,15/Jan/15 07:57,14/Jul/23 06:01,22/Oct/14 09:51,2.3.3,2.3.4,2.3.5,2.3.6,2.4.0-beta-1,,,,,,,,,,,,,2.4.0-beta-4,,,,,,,,1,breaking,,,,,,"When iterating over a List of Object[] in a .each closure and typing the parameter as _Object[]_, the arguments in each iteration become an Object[] of Object[]. This does not happen if the parameter is _def_.

{code}
Object[] arr = new Object[1]
arr[0] = 'test'
List list = new ArrayList()
list.add(arr)

list.each { def obj ->
    assert obj[0] == 'test'
}

list.each { Object[] obj ->
    assert obj[0] == 'test' //fails. obj[0] is Object[]{'test'} instead of just 'test'
}
{code}

This does *not* happen if the parameter is typed as _String[]_:
{code}
String[] arr = new String[1]
arr[0] = 'test'
List list = new ArrayList()
list.add(arr)

list.each { def obj ->
    assert obj[0] == 'test'
}

list.each { String[] obj ->
    assert obj[0] == 'test' // passes
}
{code}

I have included a more thorough test case that demonstrates this behavior. Note that this may also apply to .collect or various other methods.",Windows 7 x64 SP1 on JVM 1.7.0_17,blackdrag,candrews,nalandial,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7254,,,,"30/Jul/14 12:45;nalandial;test.groovy;https://issues.apache.org/jira/secure/attachment/12723244/test.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 22 09:51:01 UTC 2014,,,,,,,,,,"0|i2crdb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Oct/14 09:26;blackdrag;Giving this the label ""breaking"" because the bug is originating from a generated call(Object[]) method on the open block, which wrongly forwards the call by a direct call with wrong logic. the chance should be low to actually break code though.;;;","22/Oct/14 09:37;nalandial;It is a problem when performing a GORM query in Grails and selecting multiple properties:

{code}
List results = Foo.createCriteria().list {
    projections {
        property(""bar"")
	property(""baz"")
    }
}
{code}

Trying to do a .each{} on that will not give you the correct results because it returns a List of Object[], where each array has the requested properties. Even though the workaround is simple (use a for loop, or simply type as not Object[]), it still sucked up a significant amount of time to figure that out.;;;","22/Oct/14 09:51;blackdrag;because it is potentially breaking the change is 2.4 only;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Collecting lists loses type information for a list of lists,GROOVY-6987,12817717,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,mperry,mperry,30/Jul/14 07:11,08/Mar/22 12:16,14/Jul/23 06:01,06/Oct/21 19:47,2.3.6,,,,,,,,,,,,,,,,,,,,,Static Type Checker,,,,0,,,,,,,"The following code does not type check, but should:

{code}
  @Test
    void testCollect() {
        def list = [[1]].collect { List<Integer> list ->
            // the following line type checks
            Math.abs((Integer) list[0])
            // the following line does not type check, but should
            Math.abs(list[0])
        }
        println list
    }
{code}","Gradle 2.0, Java 1.8.0_05, Windows 7, Groovy 2.3.6",mperry,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 30 07:24:59 UTC 2014,,,,,,,,,,"0|i2cl9b:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"30/Jul/14 07:19;mperry;Tried this on 2.3.0 and fails to type check on this version as well as 2.3.6.;;;","30/Jul/14 07:24;mperry;I suspect collecting over any list with structure List<A<B>>, e.g. List<List<Integer>> or List<P1<Integer>> (where P1 is a tuple type) will have this issue.  I got this issue for List<P1<Integer>> originally.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong end position for invalid operator,GROOVY-6986,12817690,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,denis_murashev,denis_murashev,30/Jul/14 03:02,17/Dec/14 13:25,14/Jul/23 06:01,02/Sep/14 07:33,,,,,,,,,,,,,,,,,,2.3.7,2.4.0-beta-3,,,ast builder,,,,0,,,,,,,"When org.codehaus.groovy.classgen.asm.BinaryExpressionHelper encounters invalid operation (for example, ===, as mentioned in https://issuetracker.springsource.com/browse/STS-3878), it throws GroovyRuntimeException caused by SyntaxException, for which invalid operation length is always equal to 1.
It would be nice if BinaryExpressionHelper will take into account actual length of invalid operation, so it would make it easy to mark entire incorrect operation in IDE.",,blackdrag,denis_murashev,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 02 07:33:17 UTC 2014,,,,,,,,,,"0|i2c5vr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Jul/14 13:17;denis_murashev;By the way, is it normal for BinaryExpressionHelper to throw GroovyRuntimeException? It seems to me it should be more special exception, shouldn't it?;;;","02/Sep/14 07:33;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MalformedParameterizedTypeException when bounded generic attribute without visibility modifier,GROOVY-6981,12817719,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,pbetkier,pbetkier,28/Jul/14 14:34,17/Dec/14 13:25,14/Jul/23 06:01,30/Jul/14 06:03,2.3.3,,,,,,,,,,,,,,,,,2.3.7,2.4.0-beta-3,,,,,,,0,generics,,,,,,"This code fails in runtime with {{MalformedParameterizedTypeException}} - run {{main}} to try it out:

{code}
class Dependency<T> {
}

class Something<T extends Number> {
    Dependency<? super T> dependency

    static main(String[] args) {
        new Something<Integer>()
    }
}
{code}

However, it *does not fail* if a visibility modifier is added before {{dependency}} attribute - {{private}}, {{protected}}, {{public}} or {{@PackageScope}} transformation.

This also fails with {{MalformedParameterizedTypeException}} and I don't know how to make it work:
{code}
class Something<T extends Number> {
    void someMethod(Dependency<? super T> dependency) {
    }

    static main(String[] args) {
        new Something<Integer>()
    }
}
{code}

Do you know what may be the cause? Do you know of any workaround for the second case?",,blackdrag,pbetkier,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 30 06:03:44 UTC 2014,,,,,,,,,,"0|i2cg33:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Jul/14 06:03;blackdrag;For why it does not fail... I assume the verifier is more strict on method signatures, than on fields. The variant without visibility modifier produce getter and setter, that will have the signature as well

Possible workarounds... afaik none but to avoid the ""? extends T"" version.

Anyway, this is fixed in the next version;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Normal Groovy jar shouldn't include openbeans,GROOVY-6980,12817734,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,28/Jul/14 08:16,28/Jul/14 20:21,14/Jul/23 06:01,28/Jul/14 09:02,2.4.0-beta-1,,,,,,,,,,,,,,,,,2.4.0-beta-2,,,,,,,,0,,,,,,,"The normal Groovy jar includes openbeans, whether it should only be packaged with the {{grooid}} version.
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-28 08:16:34.0,,,,,,,,,,"0|i2c8m7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Method type parameter resolved to class with anonymous inner class,GROOVY-6977,12817720,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,tachatte,tachatte,27/Jul/14 09:17,11/Nov/20 02:00,14/Jul/23 06:01,18/Jul/20 16:18,2.4.18,,,,,,,,,,,,,,,,,2.5.0,,,,,,,,0,,,,,,,"compiling
{code}
class A {
  public <R> void bar() {
    List<R> a = new ArrayList<R>() { };
  }
}
{code}

fails with ""Groovy:unable to resolve class R""
",,melix,tachatte,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 28 02:23:07 UTC 2014,,,,,,,,,,"0|i2buyv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Jul/14 02:15;melix;Note that the example doesn't really make sense: a placeholder at the method level is supposed to be used in the method signature itself. Here, it's neither used in the return type nor the parameters. This means that it's useless, as the compiler cannot infer its type.;;;","28/Jul/14 02:18;tachatte;Hi CÃ©dric,

it is the simplest example I came with. My use case was more complex than that, something like:

{code}
class A {
   void bar(Callable<T> callable) { ... }
   <R> void foo() {
      bar(new Callable<R>() {
         R call() {
            ...
         }
      }
   }
}
{code};;;","28/Jul/14 02:23;melix;Ok, this time this remembers me of another bug. I'm pretty sure it's a duplicate, I'll try to find it.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
after upgrading to 2.3.5 CliBuilder doesn't work.,GROOVY-6976,12817699,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,paulk,kdabir,kdabir,26/Jul/14 00:01,28/Jul/14 20:23,14/Jul/23 06:01,28/Jul/14 05:12,2.3.5,,,,,,,,,,,,,,,,,2.3.6,2.4.0-beta-2,,,command line processing,,,,1,,,,,,,"After upgrading to 2.3.5 code depending on CliBuilder doesn't compile. It fails with ""unable to resolve class CliBuilder"".

Am attaching an example gradle project. To reproduce error, just bump groovy version in the build.gradle. The same code works just fine for 2.3.4.","Mac OSX, groovy 2.3.5, jdk 1.8, gradle 2.",hoeferh,kdabir,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"26/Jul/14 00:01;kdabir;test-cli.zip;https://issues.apache.org/jira/secure/attachment/12723151/test-cli.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 28 05:12:36 UTC 2014,,,,,,,,,,"0|i2bv8f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jul/14 12:46;hoeferh;This also prevents launching {{groovysh}} with 2.3.5:

{code}
? groovysh
java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
Caused by: java.lang.NoClassDefFoundError: groovy/util/CliBuilder
	at org.codehaus.groovy.tools.shell.Main.main(Main.groovy:48)
	... 6 more
Caused by: java.lang.ClassNotFoundException: groovy.util.CliBuilder
	at org.codehaus.groovy.tools.RootLoader.findClass(RootLoader.java:175)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:425)
	at org.codehaus.groovy.tools.RootLoader.loadClass(RootLoader.java:147)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:358)
	... 7 more
{code}

I'm on Linux, installed Groovy via GVM and use Oracle JDK 1.7.0_65 (x64).

EDIT:
And sure enough, the {{groovy/util/CliBuilder*.class}} files are missing from {{groovy-2.3.5.jar}}.;;;","26/Jul/14 21:57;paulk;This also happens on the master branch. I suspect an unforeseen (and unintended) consequence of GROOVY-6964.;;;","27/Jul/14 16:53;paulk;I applied a fix that works for me locally but I'll wait until the artifacts are built by the CI server to double check - CI is currently stalled.;;;","28/Jul/14 05:12;paulk;Should be fixed now. Thanks for spotting that so quickly.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GeneratedMetaMethod.Proxy#proxy() can cause massive waiting times,GROOVY-6971,12817665,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,24/Jul/14 05:36,26/Jul/14 01:44,14/Jul/23 06:01,24/Jul/14 05:42,2.0.8,2.1.9,2.2.2,2.3.4,,,,,,,,,,,,,,2.3.5,,,,groovy-runtime,,,,0,,,,,,,"The method is synchronized, so if multiple threads want to read, they all have to go through the full synchronization procedure. The variable is already volatile, so it would be enough to make the writing process synchronized. This can still cause massive waiting times, if for example the class loader is very slow and the proxy has not been generated yet. Unfortunately there is no solution for that",,blackdrag,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 24 05:42:37 UTC 2014,,,,,,,,,,"0|i2chd3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Jul/14 05:42;blackdrag;now only the writing of proxy is synchronized, reading is done by volatile;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker fails to choose between equivalent interface methods,GROOVY-6970,12817668,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tachatte,tachatte,23/Jul/14 09:25,17/Aug/22 18:50,14/Jul/23 06:01,23/Jul/14 11:10,2.3.4,,,,,,,,,,,,,,,,,2.3.5,,,,Static Type Checker,,,,0,,,,,,,"reproduce with
{code}
import groovy.transform.CompileStatic;
interface A { void m(); }
interface B { void m(); }
interface C extends A, B {}
@CompileStatic
class D {
 D(C c) {
   ((A)c).m();
 }
}
{code}",,melix,ngalarneau,tachatte,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8788,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 23 11:36:16 UTC 2014,,,,,,,,,,"0|i2byfz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jul/14 09:46;ngalarneau;Also, see the related GROOVY-6849.
;;;","23/Jul/14 11:10;melix;@Neil: the issues were distinct (yours was an ambiguity between an extension method and a regular method) but I fixed them both in the same commit.;;;","23/Jul/14 11:36;ngalarneau;Excellent!

Thank you Cedric.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Set.flatten() should return Set,GROOVY-6969,12817683,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,yukoba,yukoba,23/Jul/14 05:09,05/Apr/15 14:44,14/Jul/23 06:01,23/Jul/14 06:11,,,,,,,,,,,,,,,,,,2.4.0-beta-2,,,,groovy-jdk,,,,0,,,,,,,Please read https://github.com/groovy/groovy-core/pull/493,,yukoba,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,2014-07-23 05:09:52.0,,,,,,,,,,"0|i2cd5j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compilation fails with exception when trying to cast Closure to Runnable under certain conditions,GROOVY-6965,12811418,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,deffer,deffer,20/Jul/14 18:10,26/Jul/14 01:44,14/Jul/23 06:01,21/Jul/14 04:16,2.3.4,,,,,,,,,,,,,,,,,2.3.5,,,,Static compilation,,,,0,,,,,,,"When implementing interface method that returns Runnable, expecting compiler to be able to cast Closure to Runnable, but getting a compilation class cast exception. Works fine when passing the same Closure to a method accepting Runnable. 

{code}
import  groovy.transform.*

@CompileStatic
interface Job {
  Runnable getRunnable()     
}


@CompileStatic
class Printer implements Job{  

  protected void execute() {
    println ""Printing""
  }

  public void acceptsRunnable(Runnable r){ 
    r.run()
  }

  //@CompileStatic(TypeCheckingMode.SKIP)
  public Runnable getRunnable(){
     acceptsRunnable(this.&execute) // OK
     return this.&execute           // compile error
  }  
}

Printer p = new Printer()
{code}
Reproducible in any groovy console. 

Compilation Error:
{code}
ava.lang.ClassCastException: org.codehaus.groovy.ast.expr.VariableExpression cannot be cast to org.codehaus.groovy.ast.expr.ClosureExpression
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.getResultType(StaticTypeCheckingVisitor.java:3108)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:448)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:245)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitDeclarationExpression(ClassCodeVisitorSupport.java:107)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:86)
{code}",,deffer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-20 18:10:59.0,,,,,,,,,,"0|i2cfa7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Build on Windows,GROOVY-6964,12817666,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,yukoba,yukoba,20/Jul/14 11:35,05/Apr/15 14:44,14/Jul/23 06:01,21/Jul/14 01:43,,,,,,,,,,,,,,,,,,2.3.5,2.4.0-beta-2,,,,,,,0,,,,,,,"Building on Windows was not supported because JarJarTask does not release a file lock.
Please read http://groovy.329449.n5.nabble.com/Build-issue-with-groovy-core-master-td5719619.html for the detail.
I fixed this problem.
I checked this is running correctly on Windows 8.1 and Ubuntu 14.04.

The pull request is here.
https://github.com/groovy/groovy-core/pull/486",,paulk,yukoba,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Mon Jul 21 01:43:57 UTC 2014,,,,,,,,,,"0|i2bonj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jul/14 01:43;paulk;PR applied, thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
IllegalAccessError exception is raised when accessing inherited public method  ,GROOVY-6962,12812235,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pablo72,pablo72,19/Jul/14 17:27,26/Feb/21 08:18,14/Jul/23 06:01,21/Jul/14 03:44,2.3.4,,,,,,,,,,,,,,,,,2.3.5,,,,Static compilation,,,,0,,,,,,,"Accessing a public final method declared in non public super class will raise {{IllegalAccessError}} exception. For example: 

{code:title=Base.java}
package acme;
class Base {  
  public final void foo()  { 
    System.out.println(""Hello"");
  } 
}
{code}

{code:title=Test.java}
package acme;
public class Test extends Base { }
{code}

{code:title=Main.groovy}
import groovy.transform.*
import acme.*

@CompileStatic
class Main {
 
  public static void main(String[] args) {
    def x = new Test ();
    x.foo();
  }  
}
{code}

Result in the following exception
{code}
Caught: java.lang.IllegalAccessError: tried to access class acme.Base from class Main
java.lang.IllegalAccessError: tried to access class acme.Base from class Main
	at Main.main(Main.groovy:9)
{code}","Groovy Version: 2.3.4 
JVM: 1.7.0_51 Vendor: Oracle Corporation 
OS: Mac OS X",paolodt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-9955,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-19 17:27:41.0,,,,,,,,,,"0|i2bpav:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect type inference for closure parameter chained after collectMany,GROOVY-6961,12815451,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,robfletcher,robfletcher,19/Jul/14 12:33,26/Jul/14 01:44,14/Jul/23 06:01,22/Jul/14 06:54,2.3.4,,,,,,,,,,,,,,,,,2.3.5,,,,Static Type Checker,,,,1,,,,,,,"I'm experiencing a problem when I chain another iterator method closure after {{collectMany}}. The parameter type of the closure on the following method should be the element type of the list returned by {{collectMany}} and when using dynamic Groovy this works fine. The static type checker thinks the closure parameter should be {{List}} and is failing to compile.

See attached example.",,blackdrag,fletcherr,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"19/Jul/14 12:33;ReverseIntStringList.groovy;https://issues.apache.org/jira/secure/attachment/12723178/ReverseIntStringList.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 22 06:54:34 UTC 2014,,,,,,,,,,"0|i2cco7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jul/14 02:16;melix;A variant with intermediate variables which highlights the fact that the problem is the inference of the return type of {{collectMany}}:

{code}
@groovy.transform.CompileStatic
class ListCompilerAndReverser {
  static List<Integer> revlist(List<List<String>> list) {
    List<Integer> intermediate = list.collectMany { strings ->
      List<Integer> result = strings.collect {
        it.toInteger()
      }
      result
    } 
    intermediate.sort { int it ->
      -it
    }
  }
}
{code}

{noformat}
3 compilation errors:

[Static type checking] - Incompatible generic argument types. Cannot assign java.util.List <java.util.List> to: java.util.List <Integer>
 at line: 4, column: 34

Expected parameter of type java.util.List <String> but got int
 at line: 10, column: 25

[Static type checking] - Cannot find matching method java.util.List#negative(). Please check if the declared type is right and if the method exists.
 at line: 11, column: 7


{noformat};;;","22/Jul/14 06:54;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""Reference to method is ambiguous"" when calling overridden method with default values",GROOVY-6960,12817689,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,haimat,haimat,18/Jul/14 19:27,19/Jul/14 07:07,14/Jul/23 06:01,19/Jul/14 07:07,2.3.4,,,,,,,,,,,,,,,,,,,,,Static compilation,,,,0,,,,,,,"The attached groovy script/class leads to the following error during compilation:

{{/mirror/dev/Groovy/src/bug/BugCheck.groovy: 17: [Static type checking] - Reference to method is ambiguous. Cannot choose between [void bug.BugCheck$Child#method(float), void bug.BugCheck$Child#method(float)]}}","Debian Linux, running Oracle Java 1.8.0_05",haimat,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/Jul/14 19:27;haimat;BugCheck.groovy;https://issues.apache.org/jira/secure/attachment/12722201/BugCheck.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 19 07:07:44 UTC 2014,,,,,,,,,,"0|i2bub3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jul/14 19:36;haimat;I have just seen that when I add the optional parameter to the Child class method as well, then it works. So if this is not a bug then, please close this ticket.;;;","19/Jul/14 07:07;paulk;Closing as per reporter request.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
null != NullObject when using Categories,GROOVY-6958,12817706,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,shils,jkemnade,jkemnade,18/Jul/14 05:44,18/May/17 11:10,14/Jul/23 06:01,13/Dec/15 02:53,2.3.4,2.4.0-rc-2,2.4.1,2.4.4,2.5.0-beta-1,,,,,,,,,,,,,2.4.6,,,,,,,,0,,,,,,,"{code}
def val = null

class Helper {
  
  static boolean isNull(value) {
    value == null 
  }
  
}

use(Helper){
  assert val == null
  assert val.isNull()
}
{code}
The last assertion fails because value isnt {{null}} but a {{NullObject}} and inside the {{isNull}} method, those are apparently not equal.",,githubbot,jkemnade,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5769,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 13 02:52:27 UTC 2015,,,,,,,,,,"0|i2c1of:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Dec/15 05:16;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/207

    GROOVY-6958 null != NullObject when using categories

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/incubator-groovy GROOVY-6958

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/207.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #207
    
----
commit 71c92b3dcc5dcbe92cc31869ecaf63eb1aed56c0
Author: Shil Sinha <shils@apache.org>
Date:   2015-12-09T05:03:43Z

    GROOVY-6958 null != NullObject when using categories

----
;;;","13/Dec/15 02:52;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/207
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Regression if @DelegatesTo delegate to a Java class and use of property notation,GROOVY-6955,12817723,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,17/Jul/14 06:58,26/Jul/14 01:44,14/Jul/23 06:01,17/Jul/14 10:37,2.3.4,,,,,,,,,,,,,,,,,2.3.5,,,,Static compilation,,,,0,,,,,,,"If {{@DelegatesTo}} tells that the delegate is a Java class (which doesn't implement {{GroovyObject}}), then the static compiler generates wrong bytecode, like in the following example:

{code}
class MyHandlers {
              def handler(@DelegatesTo(GroovyContext) Closure<?> c) {
                def l = new GroovyContext()
                c.delegate = l
                c.call()
              }
              def execute() {
                handler {
                  request.headers.bar
                }
              }

            }
{code}

Issue highlighted in Ratpack, responsible for the joint build failure. See https://github.com/ratpack/ratpack/pull/375#issuecomment-49249705",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-17 06:58:42.0,,,,,,,,,,"0|i2bx1b:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Regression with @DelegatesTo wrt to maps,GROOVY-6953,12817678,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,17/Jul/14 04:52,26/Jul/14 01:44,14/Jul/23 06:01,17/Jul/14 05:06,2.3.4,,,,,,,,,,,,,,,,,2.3.5,,,,Static compilation,,,,0,,,,,,,"The following code now fails with Groovy 2.3.4 at runtime with an {{IncompatibleClassChangeError}}:

{code}
           @CompileStatic
            class MyHandlers  {
              Map execute() {
                againstList {
                  foo = ""bar""
                }
              }

              Map againstList(@DelegatesTo(Map) Closure<?> c) {
                def l = [:]
                c.delegate = l
                c.call()
                l
              }
            }


            def map = new MyHandlers().execute()
            assert map.foo == 'bar'
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-17 04:52:21.0,,,,,,,,,,"0|i2c8rj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NioGroovyMethods don't work under JDK6,GROOVY-6948,12817684,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pniederw,pniederw,15/Jul/14 02:12,28/Jul/14 20:21,14/Jul/23 06:01,17/Jul/14 01:37,2.3.4,,,,,,,,,,,,,,,,,2.4.0-beta-2,,,,groovy-jdk,,,,0,,,,,,,"When using Groovy 2.3.3 under (Apple) JDK 6, the following warning is printed:

{code}
Jul 15, 2014 9:05:26 AM org.codehaus.groovy.runtime.m12n.MetaInfExtensionModule newModule
WARNING: Module [groovy-all] - Unable to load extension class [org.codehaus.groovy.runtime.NioGroovyMethods]
{code}

(No reason is given why the class cannot be loaded.) Attempts to use a method from {{NioGroovyMethods}} (e.g. {{Closeable#withCloseable}}) lead to {{groovy.lang.MissingMethodException}}.

Output of {{java -version}}:

{code}
java version ""1.6.0_65""
Java(TM) SE Runtime Environment (build 1.6.0_65-b14-462-11M4609)
Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-462, mixed mode)
{code}

PS: Groovy version 2.3.3 isn't available in JIRA (i.e. 2.3.3 isn't accepted for ""Affects Version/s"").",,guillaume,melix,paulk,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 17 00:37:51 UTC 2014,,,,,,,,,,"0|i2cpx3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Jul/14 02:19;melix;This is by design, because this module is only compatible with JDK7+.;;;","15/Jul/14 02:25;pniederw;Hmm, good to know. Would be good to have this documented and printed as part of the warning. It's a bit unfortunate that a method like {{withCloseable}}, which should not require 1.7, can only be used with 1.7+.;;;","15/Jul/14 02:37;pniederw;How about moving {{withCloseable}} into {{IOGroovyMethods}}?;;;","15/Jul/14 03:09;guillaume;Closeable was introduced in JDK 6, so it could indeed be in IOGroovyMethods instead.
Do you want to do a pull request? :-);;;","15/Jul/14 03:13;melix;If we do this we should be very careful because it can either cause a binary breaking change, or make the static type checker unable to choose between two versions of the same method, one being in {{IOGroovyMethods}}, the other in {{NioGroovyMethods}}.;;;","15/Jul/14 03:40;pniederw;Is this different from all the deprecated methods in {{DefaultGroovyMethods}} that were moved somewhere else?;;;","15/Jul/14 03:43;melix;True, there's an explicit check for the {{@Deprecated}} annotation in the type checker for extension modules. Deprecated methods are ignored: https://github.com/melix/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java#L1877-1877;;;","17/Jul/14 00:30;paulk;I copied the {{withCloseable}} method to {{IOGroovyMethods}} and deprecated the one in {{NioGroovyMethods}} (just for 2.4). Peter, are you happy if we close this now?;;;","17/Jul/14 00:37;pniederw;Yes I am. Thanks Paul!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE in compilation when assigning a value to 'this',GROOVY-6947,12811417,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,rcruzjo,rcruzjo,14/Jul/14 08:49,01/Feb/17 23:18,14/Jul/23 06:01,11/Sep/16 22:40,2.3.4,,,,,,,,,,,,,,,,,2.4.8,,,,Compiler,,,,0,,,,,,,"We're using Groovy to allow users to write some scripts inside a product and one of them tried to assign a value to the variable ""this"", leading to the following exception (test case is attached):

BUG! exception in phase 'semantic analysis' in source unit 'groovyTest.groovy' null
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:927)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:585)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:534)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:286)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:259)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:674)
	at groovy.lang.GroovyShell.run(GroovyShell.java:501)
	at groovy.lang.GroovyShell.run(GroovyShell.java:481)
	at groovy.lang.GroovyShell.run(GroovyShell.java:164)
	at groovy.lang.GroovyShell$run$0.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:977)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:278)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure.call(Closure.java:417)
	at groovy.lang.Closure.run(Closure.java:504)
	at java.lang.Thread.run(Thread.java:744)
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.classgen.VariableScopeVisitor.checkForFinal(VariableScopeVisitor.java:392)
	at org.codehaus.groovy.classgen.VariableScopeVisitor.checkFinalFieldAccess(VariableScopeVisitor.java:385)
	at org.codehaus.groovy.classgen.VariableScopeVisitor.visitBinaryExpression(VariableScopeVisitor.java:369)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.classgen.VariableScopeVisitor.visitBlockStatement(VariableScopeVisitor.java:312)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.classgen.VariableScopeVisitor.visitConstructorOrMethod(VariableScopeVisitor.java:509)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1063)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.VariableScopeVisitor.visitClass(VariableScopeVisitor.java:477)
	at org.codehaus.groovy.control.CompilationUnit$11.call(CompilationUnit.java:640)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:923)
	... 23 more

I know this is an issue that won't happen very often as this is invalid code (that's the reason of the lower priority), but it would nice if you could have a look into this and handle the exception, reporting it as a compilation issue.",,paulk,rcruzjo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7921,,,,,,,,,,,,,,,,,"14/Jul/14 08:49;rcruzjo;groovyTest.groovy;https://issues.apache.org/jira/secure/attachment/12722407/groovyTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 11 22:40:27 UTC 2016,,,,,,,,,,"0|i2cnuv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"14/Jul/14 13:09;paulk;Putting a null guard before the line throwing the NPE in VariableScopeVisitor with an early return seems to ""step around"" the problem. Compilation succeeds and subsequently the attempt to change this seems to act like a NOOP. However, I suspect looking for ""this"" on the LHS of a binary assignment expression (at some earlier point) and reporting an error might be a better fix.;;;","11/Sep/16 22:40;paulk;Fixed as a consequence of GROOVY-7921 (and to some degree GROOVY-7925);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Use of a dynamic property inside a markup engine closure causes a VerifyError,GROOVY-6941,12817682,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,11/Jul/14 10:23,26/Jul/14 01:44,14/Jul/23 06:01,11/Jul/14 14:03,2.3.4,,,,,,,,,,,,,,,,,2.3.5,,,,Templating,,,,0,,,,,,,"The following template fails when {{xml}} is a variable from the model. Note that this only fails if used inside the {{div}} block. Outside of it, it runs fine.

{code}
MarkupTemplateEngine engine = new MarkupTemplateEngine(new TemplateConfiguration())
        def template = engine.createTemplate '''
        div {
            yield xml.file
        }
        '''
        def model = [xml: [file:['test']]]
        String rendered = template.make(model)
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-11 10:23:59.0,,,,,,,,,,"0|i2clcv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using subscript operator on untyped model item fails compilation,GROOVY-6940,12817662,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,11/Jul/14 09:55,26/Jul/14 01:44,14/Jul/23 06:01,14/Jul/14 09:31,2.3.4,,,,,,,,,,,,,,,,,2.3.5,,,,Templating,,,,0,,,,,,,"Using the markup template engine and an untyped ""list"" variable like the following, the template compilation fails:

{code}
      MarkupTemplateEngine engine = new MarkupTemplateEngine(new TemplateConfiguration())

        def template = engine.createTemplate '''
            yield list[0]
        '''
        def model = [list:['Item 1']]
        String rendered = template.make(model)
        assert rendered == 'Item 1'
{code}

Error is:

{noformat}
BUG! exception in phase 'class generation' in source unit 'GeneratedMarkupTemplate0' At line 2 column 19
On receiver: this.getModel().get(list) with message: getAt and arguments: 0
{noformat}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-11 09:55:22.0,,,,,,,,,,"0|i2brt3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Calling ""each"" on an untyped model variable with two arguments causes doCall error",GROOVY-6939,12811410,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,melix,melix,11/Jul/14 09:46,09/Jun/23 15:28,14/Jul/23 06:01,09/Sep/22 01:51,2.3.4,2.4.0-rc-1,,,,,,,,,,,,,,,,5.0.0-alpha-1,,,,,,,,0,,,,,,,"With the following code, the markup builder will recognize a call to the {{each}} method, but at runtime, it throws an error:

{code}
MarkupTemplateEngine engine = new MarkupTemplateEngine(new TemplateConfiguration())

        def template = engine.createTemplate '''
            groups.each { k, v -> li(k) }
        '''
        def model = [groups:[a:'Group a',b:'Group b']]
        String rendered = template.make(model)
{code}

The error is:

{noformat}
groovy.lang.MissingMethodException: No signature of method: GeneratedMarkupTemplate0$_run_closure1.doCall() is applicable for argument types: (java.util.LinkedHashMap$Entry) values: [a=Group a]
Possible solutions: doCall(java.lang.Object, java.lang.Object), findAll(), findAll(), isCase(java.lang.Object), isCase(java.lang.Object)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:270)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:910)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure.call(Closure.java:439)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1380)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1311)
	at GeneratedMarkupTemplate0.run(GeneratedMarkupTemplate0:2)
	at groovy.text.markup.BaseTemplate.writeTo(BaseTemplate.java:468)
	at groovy.lang.Writable$writeTo.call(Unknown Source)
{noformat}",,emilles,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10731,GROOVY-8499,GROOVY-8816,GROOVY-9854,GROOVY-8247,GROOVY-11089,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 09 01:51:37 UTC 2022,,,,,,,,,,"0|i2c81r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Jul/14 03:54;melix;For reference, this is not a problem specific to the template engine. The static compiler would show the same error (but it's easier to understand in that context) with this code:

{code}
import groovy.transform.CompileStatic

@CompileStatic
void m(Object o) {
    o.each { k,v -> println k }
}

m(a:'Value',b:'Value 2')

{code}

The problem here is that the {{each}} method which is chosen at compile-time is the version which accepts an {{Object}}, and calls {{asIterator}} on it. That would return an iterator of map entries in the context of a {{Map}}, leading to the error.;;;","08/Sep/22 17:57;emilles;Looks like the MME is thrown for static and non-static modes.  In addition to a new STC error, should the dynamic case succeed (and supply null) to the excess parameters -- or just stay a runtime exception?;;;","09/Sep/22 01:51;emilles;https://github.com/apache/groovy/commit/ea34146709b5f1afec9d84b00c2311f0bb5c8d89;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong error reported by @CompileStatic when overriding a method returning a parameterized value,GROOVY-6938,12817664,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,mauromol,mauromol,10/Jul/14 11:14,26/Jul/18 04:38,14/Jul/23 06:01,15/May/18 14:50,2.3.4,,,,,,,,,,,,,,,,,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,,Static compilation,,,,0,,,,,,,"Consider the following Java class:
{code:java}
package l;

public class LJava <T extends Number> {
   public T doSomething() {
	   return null;
   }
}
{code}

and the following Groovy class:
{code}
package l
import groovy.transform.CompileStatic;

@CompileStatic
class L extends LJava<Integer> {
	Integer doSomething() {
		super.doSomething()
	}
}
{code}

Static compilation fails because Groovy thinks that {{doSomething()}} for {{LJava<Integer>}} returns {{Number}} instead of {{Integer}}.",,daniel_sun,jwagenleitner,mauromol,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 15 14:50:55 UTC 2018,,,,,,,,,,"0|i2c1mv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/May/18 14:50;daniel_sun;It is fixed https://github.com/apache/groovy/commit/3dd14f618c4c3ce9588cacf535c48a0b7163c810;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JSon serialization with unicode characters fail,GROOVY-6937,12813429,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,guillaume,kha,kha,10/Jul/14 11:09,26/Jul/14 01:44,14/Jul/23 06:01,25/Jul/14 03:29,2.3.1,2.3.2,2.3.3,2.3.4,,,,,,,,,,,,,,2.3.5,2.4.0-beta-2,,,JSON,,,,0,,,,,,,"Json serialiation with Greek characters fails

To reproduce:

{code}
Object o1 = [""ÎÎ¦ÎÎ ÎÎÎÎÎÎ ÎÎ¡ÎÎ©Î ÎÎÎÎÎ Î¤ÎÎÎÎ¡ÎÎ""]
println ""o1=${new JsonBuilder(o1).toString()}""

Object o2 = [""ÎÎ¦ÎÎ ÎÎÎÎÎÎ ÎÎ¡ÎÎ©Î ÎÎÎÎÎ Î¤ÎÎÎÎ¡ÎÎ"", ""ÎÎ±Î»ÏÎ²Î¹Î± ÎÎ¿ÏÎ¹ÎºÎ¿Ï""]
println ""o2=${new JsonBuilder(o2).toString()}""
{code}

Outputs:

{code}
o1=[""\u0391\u03a6\u039f\u0399 \u039a\u039f\u039b\u039b\u0399\u0391 \u039a\u03a1\u0395\u03a9\u03a0\u039f\u039b\u0395\u0399\u039f \u03a4\u0391\u0392\u0395\u03a1\u039d\u0391""]

Exception in thread ""main"" java.lang.ArrayIndexOutOfBoundsException: 255
	at groovy.json.internal.CharBuf.doAddJsonEscapedString(CharBuf.java:533)
	at groovy.json.internal.CharBuf.addJsonEscapedString(CharBuf.java:394)
	at groovy.json.internal.CharBuf.addJsonEscapedString(CharBuf.java:357)
	at groovy.json.JsonOutput.writeCharSequence(JsonOutput.java:309)
	at groovy.json.JsonOutput.writeObject(JsonOutput.java:260)
	at groovy.json.JsonOutput.writeIterator(JsonOutput.java:446)
	at groovy.json.JsonOutput.writeObject(JsonOutput.java:272)
	at groovy.json.JsonOutput.toJson(JsonOutput.java:190)
	at groovy.json.JsonBuilder.toString(JsonBuilder.groovy:273)
	at groovy.json.JsonBuilder$toString.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at Draft.main(Draft.groovy:37)
{code}","Groovy Version: 2.3.3 JVM: 1.8.0_05 Vendor: Oracle Corporation OS: Linux
java version ""1.8.0_05""
Java(TM) SE Runtime Environment (build 1.8.0_05-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)
",kha,richardhightower,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Jul/14 11:12;kha;test.groovy;https://issues.apache.org/jira/secure/attachment/12723243/test.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 21 14:48:03 UTC 2014,,,,,,,,,,"0|i2c1zj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Jul/14 11:10;kha;It is perhaps related to issue  GROOVY-6852;;;","10/Jul/14 11:12;kha;Attched fiel containing the right code with unicode characters;;;","10/Jul/14 11:34;kha;By removing the condition for unicode chars (c > 126) I was able to output json string correctly and also without escapes.

{code}

    private static boolean hasAnyJSONControlOrUnicodeChars(int c) {
        /* Anything less than space is a control character. */
        if (c < 30) {
            return true;
        /* 34 is double quote. */
        } else if (c == 34) {
            return true;
        } else if (c == 92) {
            return true;
        } else if (c < ' ') {
            return true;
        }

        return false;
    }
{code};;;","21/Jul/14 14:35;richardhightower;So are you suggesting that as the patch?;;;","21/Jul/14 14:47;richardhightower;I tried it with Boon. Reproduce the error with boon. Tried the patch. It works. 

I am not sure that is the right thing or not. It seems that I limited Boon to encode everything that was not ASCII as /u..... In retrospect, not a great idea.

http://upload.wikimedia.org/wikipedia/commons/1/1b/ASCII-Table-wide.svg
http://www.biega.com/Special-EE.gif

Thinking about this.
;;;","21/Jul/14 14:48;kha;Not at all because I didn't run any unit test and did not check if it has some impacts elsewhere.

But it seems to work fine for us. We just wanted unicode characters to be treated like other characters and not like special ones.

Since you are the original author, I'll let you have the final word concerning whether this a good modification or not. At least if not, it would be nice to have a flag to control the serialization process and not escape unicode characters ;-)

Thanks!
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError with = instead of : in tag attribute with Markup Template Engine,GROOVY-6935,12816954,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,10/Jul/14 08:15,26/Jul/14 01:44,14/Jul/23 06:01,11/Jul/14 09:36,2.3.4,,,,,,,,,,,,,,,,,2.3.5,,,,Templating,,,,0,,,,,,,"The following code fails with a VerifyError:
{code}
import groovy.text.markup.*

def engine = new MarkupTemplateEngine(new TemplateConfiguration())
def template = engine.createTemplate '''
html {
    body {
        div(id: '132', style='color: white') {}
    }
}
'''
println template.make()
{code}

Here's the error we get:
{noformat}
Exception thrown

java.lang.VerifyError: (class: GeneratedMarkupTemplate7$_run_closure1_closure2, method: doCall signature: (Ljava/lang/Object;)Ljava/lang/Object;) Expecting to find object/array on stack
	at GeneratedMarkupTemplate7$_run_closure1.doCall(GeneratedMarkupTemplate7)
	at GeneratedMarkupTemplate7$_run_closure1.call(GeneratedMarkupTemplate7)
	at GeneratedMarkupTemplate7.run(GeneratedMarkupTemplate7)
	at ConsoleScript7.run(ConsoleScript7:12)
{noformat}

Notice how {{=}} was used instead of {{:}} to define the style attribute in the div tag.",Java 8 / Mac OS X 10.9.4,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-10 08:15:21.0,,,,,,,,,,"0|i2bttj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Add swap() to List and array,GROOVY-6933,12817618,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,yukoba,yukoba,10/Jul/14 01:46,05/Apr/15 14:43,14/Jul/23 06:01,10/Jul/14 17:09,,,,,,,,,,,,,,,,,,2.4.0-beta-2,,,,groovy-jdk,,,,0,,,,,,,"Add swap() to List and array.
Collections.swap() returns nothing, but this method returns this object.

The pull request is here.
https://github.com/groovy/groovy-core/pull/481
",,paulk,yukoba,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Thu Jul 10 17:09:12 UTC 2014,,,,,,,,,,"0|i2bys7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"10/Jul/14 17:09;paulk;Applied. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Log annotation does not check logging enablement inside closures,GROOVY-6932,12817687,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,shorn,shorn,09/Jul/14 21:08,01/Aug/22 14:06,14/Jul/23 06:01,28/Aug/16 20:47,2.2.0,2.3.3,,,,,,,,,,,,,,,,2.4.8,,,,groovy-runtime,,,,0,,,,,,,"Groovy doesn't do a check for whether the log level is enabled when the log statement is made from inside a closure.

I believe the attached script should not print ""called with 3"".

Result on my machine is:
Groovy version: 2.3.3
Java version: 1.8.0_05-b13
OS: Windows 7

called with 1
12:03:30.119 [main] INFO  TestCode - blah: 1
called with 3

Script:
{code}
@Grapes([
  @Grab(group='org.slf4j', module='slf4j-api', version='1.7+'),
  @Grab(group='ch.qos.logback', module='logback-classic', version='1.+')])
import groovy.util.logging.Slf4j

new TestCode().doSomethingThatLogs()

@Slf4j
class TestCode {
  void doSomethingThatLogs(){
    println ""Groovy version: ${GroovySystem.version}""
    println ""Java version: ${System.properties[""java.runtime.version""]}""
    println ""OS: ${System.properties[""os.name""]}""
    println """"

    log.info createLogString(1)
    log.trace createLogString(2)
    Closure c = { log.trace createLogString(3) }
    c()
  }

  String createLogString(int p){
    println ""called with $p""
    return ""blah: $p""
  }
}
{code}","Windows 7, Groovy 2.3.3, JDK 1.8.0_05",githubbot,mwkohout,paulk,shorn,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8060,,,,,,,,,,,,,,GROOVY-10713,,,,,,,,,,,,,"09/Jul/14 21:08;shorn;LogAstProblem.groovy;https://issues.apache.org/jira/secure/attachment/12723214/LogAstProblem.groovy","19/Jan/17 17:32;mwkohout;LoggingSpec.groovy;https://issues.apache.org/jira/secure/attachment/12848344/LoggingSpec.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 23 07:39:17 UTC 2017,,,,,,,,,,"0|i2bzcn:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"28/Aug/16 12:35;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/401

    GROOVY-6932: @Log annotation does not check logging enablement inside…

    … closures

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy6932

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/401.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #401
    
----
commit 3a6c2b8586ea4c377581c8a531839ce081a67718
Author: paulk <paulk@asert.com.au>
Date:   2016-08-28T12:33:49Z

    GROOVY-6932: @Log annotation does not check logging enablement inside closures

----
;;;","28/Aug/16 20:44;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/401
;;;","28/Aug/16 20:47;paulk;Proposed PR merged. Thanks for spotting the issue.;;;","19/Jan/17 17:32;mwkohout;I'm still not seeing this issue fixed-it still evaluates the strings in the levels not enabled.  Here's a Spock test that duplicates this issue.

This is with the just released Groovy 2.4.8 and slf4j 1.7.21.

Is there something I don't understand about how Groovy should build GroovyStrings?

See my attached Spec.;;;","23/Jan/17 07:39;paulk;[~mwkohout] You are correct, closures defined inline as arguments to a method call weren't being handled. I've cloned the issue to cover that case.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Undocumented breaking change in ShortTypeHandling,GROOVY-6931,12816951,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,rvowles,rvowles,09/Jul/14 18:07,26/Jul/14 01:44,14/Jul/23 06:01,25/Jul/14 09:41,2.3.3,,,,,,,,,,,,,,,,,2.3.5,,,,,,,,0,,,,,,,Code compiled with 2.3.3 no longer works under 2.2 because of a missing class in ShortTypeHandling. This should be documented in the breaking changes list.,,guillaume,melix,rvowles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 25 09:41:05 UTC 2014,,,,,,,,,,"0|i2c6yn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Jul/14 03:34;guillaume;Did you mean code compiled with 2.2 doesn't work under 2.3.3?
Or did you really mean the reverse?
If the latter, we can't have both backward and upward compatibility. 
It's like saying I've compiled annotations on JDK 5 but when I try to run on JDK 1.4 it doesn't work.;;;","15/Jul/14 16:19;rvowles;The issue is simply the breaking change not being documented.

When we have shared libraries, we have to determine whether we have to major version them - and we depend on the release notes to determine if a new version of Groovy will work with the Groovy runtime from previous versions. If I have an internal library that 2.2 and 2.3 projects need to use, and I see there are no breaking changes that can't be easily worked around (such as the List.sort(Comparator) issue), then I will release a point release with the new Groovy. 

If I know that  the new Groovy introduces new classes and code compiled under Groovy 2.3 simply won't run under Groovy 2.2, then I will make a full (major) release.

We haven't hit this problem with Groovy 2.0, 2.1 and 2.2.;;;","25/Jul/14 09:41;melix;Fixed by providing a backport jar. See GROOVY-6973;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static Compilation Deadlock ,GROOVY-6930,12817655,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,musketyr,musketyr,09/Jul/14 14:01,12/Sep/14 14:25,14/Jul/23 06:01,21/Jul/14 06:44,2.3.4,,,,,,,,,,,,,,,,,2.3.5,,,,Static compilation,,,,1,,,,,,,"I certain condition I'm not able to replicate yet the Gradle compilation using Gradle compileGroovy tasks hangs indefinitely.

So far I was able track this problem down to read-write entrant lock (fcall to lock.writeLock().lock(), should be line 1817) in StaticTypeCheckingSupport.ExtensionMethodCache.getExtensionMethods(ClassLoader). I would love to replicate this problem but I need more clues what to do.",,melix,musketyr,sdmurphy,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"09/Jul/14 14:49;musketyr;compile-deadlock.zip;https://issues.apache.org/jira/secure/attachment/12722677/compile-deadlock.zip","09/Jul/14 14:01;musketyr;threaddump.txt;https://issues.apache.org/jira/secure/attachment/12722403/threaddump.txt",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 12 14:25:58 UTC 2014,,,,,,,,,,"0|i2cibz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jul/14 14:49;musketyr;here's the minimal example to make the Gradle build fail. simply run

{code}
    ./gradleWrapper groovyCompile
{code}

from the command line;;;","09/Jul/14 14:53;musketyr;The deadlock only occurs when Gaelyk jar is on the classpath (even not used) so it will probably will have something in common with [global query DSL transformation | https://github.com/gaelyk/gaelyk/blob/master/core/src/main/groovyx/gaelyk/query/QueryDslTransformation.groovy];;;","21/Jul/14 06:44;melix;I found that the problem was an exception thrown by the Groovy ClassNode builder deeply, which was causing an incorrect flow in the locking phase. I pushed a fix for it, the compilation now fails with:

{noformat}
Caused by: java.lang.NoClassDefFoundError: Unable to load class groovy.servlet.ServletCategory due to missing dependency javax/servlet/ServletContext
	at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:389)
	at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:261)
	at org.codehaus.groovy.ast.ClassNode.getMethods(ClassNode.java:380)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport$ExtensionMethodCache.getDGMMethods(StaticTypeCheckingSupport.java:1874)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport$ExtensionMethodCache.getExtensionMethods(StaticTypeCheckingSupport.java:1833)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDGMMethodsForClassNode(StaticTypeCheckingSupport.java:180)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDGMMethodsForClassNode(StaticTypeCheckingSupport.java:166)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDGMMethodsByNameAndArguments(StaticTypeCheckingSupport.java:877)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.findMethod(StaticTypeCheckingVisitor.java:3623)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.findMethodOrFail(StaticTypeCheckingVisitor.java:3384)
{noformat}

Does it make more sense?;;;","28/Jul/14 00:51;musketyr;yes it does. let me try to put add the dependency there if it fixes the problem.;;;","28/Jul/14 01:05;musketyr;I've added 

{code}
    compile 'javax.servlet:jsp-api:2.0'
    compile 'javax.servlet:servlet-api:2.4'
{code}

to the test project but it still throws that exception. do you have any idea why the compiler wouldn't see these classes?;;;","12/Sep/14 14:25;musketyr;as this one is already closed and resolved, I've opened another one for the remaining issue https://jira.codehaus.org/browse/GROOVY-7070;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker fails with NPE if a write only property is used in a bean-style constructor call,GROOVY-6929,12817653,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,09/Jul/14 08:39,26/Jul/14 01:44,14/Jul/23 06:01,09/Jul/14 09:09,2.3.3,2.3.4,,,,,,,,,,,,,,,,2.3.5,,,,,,,,0,,,,,,,"The following code fails with a {{NullPointerException}} when the type checker is used:

{code}
          class MyBean {
                private String var
                void setFoo(String foo) {
                    var = foo
                }
                String toString() { var }
            }
            def b = new MyBean(foo: 'Test')
            assert b.toString() == 'Test'
{code}
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-09 08:39:59.0,,,,,,,,,,"0|i2cc9r:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Runtime IncompatibleClassChangeError using with() on a JavaBean if @CompileStatic is used,GROOVY-6924,12811406,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,mauromol,mauromol,08/Jul/14 02:49,26/Jul/14 01:44,14/Jul/23 06:01,16/Jul/14 05:42,2.3.3,2.4.0-beta-1,,,,,,,,,,,,,,,,2.3.4,,,,Static compilation,,,,0,,,,,,,"Consider the following Java class:

{code:java}
package i;

public class MyJavaBean {
	private String foo;
	private String bar;
	
	public String getFoo() {
		return foo;
	}
	
	public void setFoo(String foo) {
		this.foo = foo;
	}
	
	public String getBar() {
		return bar;
	}
	
	public void setBar(String bar) {
		this.bar = bar;
	}
}
{code}

and the following Groovy class:

{code}
package i

import groovy.transform.CompileStatic;

@CompileStatic
class I {
  void doSomething() {
	  MyJavaBean bean = new MyJavaBean()
	  bean.with {
		  foo = 'foo'
		  bar = 'bar'
	  }
	  println ""$bean.foo and $bean.bar""
  }
  
  static void main(String[] args) {
	  new I().doSomething()
  }
}
{code}

If you run it as a Groovy script, you get:
{noformat}
Caught: java.lang.IncompatibleClassChangeError: Class i.MyJavaBean does not implement the requested interface groovy.lang.GroovyObject
java.lang.IncompatibleClassChangeError: Class i.MyJavaBean does not implement the requested interface groovy.lang.GroovyObject
	at i.I$_doSomething_closure1.doCall(I.groovy:10)
	at i.I$_doSomething_closure1.call(I.groovy)
	at i.I.doSomething(I.groovy:9)
	at i.I.main(I.groovy:17)
{noformat}

If you remove the {{@CompileStatic}} annotation from {{I}} class, all works fine.

On another project (the real one were I caught this), I get the same exception but with a different stack trace/error message:
{noformat}
java.lang.IncompatibleClassChangeError
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.setGroovyObjectProperty(ScriptBytecodeAdapter.java:528)
	at com.example.MyClass$_myMethod_closure4.doCall(MyClass.groovy:194)
{noformat}

The location is always an assignment within a {{with()}} closure. Again, I can workaround this by removing static compilation from that method.",,mauromol,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6926,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 16 05:43:19 UTC 2014,,,,,,,,,,"0|i2cgpr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jul/14 02:39;mauromol;Unfortunately, I still have problems with this. Although the provided simple test case now works, in my real-world application I still get this exception if I don't mark the {{MyDao.placeOrder()}}:method as {{CompileStatic(TypeCheckingMode.SKIP)}}:

{noformat}
java.lang.IncompatibleClassChangeError
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.setGroovyObjectProperty(ScriptBytecodeAdapter.java:528)
	at it.dcssrl.shop.purchase.dao.MyDao$_placeOrder_closure4.doCall(MyDao.groovy:193)
	at it.dcssrl.shop.purchase.dao.MyDao$_placeOrder_closure4.call(MyDao.groovy)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.with(DefaultGroovyMethods.java:235)
	at it.dcssrl.shop.purchase.dao.MyDao.placeOrder(MyDao.groovy:192)
{noformat}

I checked twice that I'm actually using Groovy 2.3.4. Any idea?;;;","11/Jul/14 02:42;melix;Unfortunately without any self contained example, this is going to be hard to fix. Could you try to create something that reproduces this?;;;","11/Jul/14 03:11;mauromol;If I debug my real-world application, I get to this line: {{ScriptBytecodeAdapter.setGroovyObjectProperty(Object, Class, GroovyObject, String) line: 528}}
Here, the receiver is of the actual type of my Java class (for instance: MyJavaBean) which of course does not implement the {{GroovyObject}} interface. So, I don't know how I can get to this line, since {{receiver}} should be a {{GroovyObject}} but it's not actually. I guess there's some Groovy magic in there. Anyway, the call to {{receiver.setProperty(String, Object)}} fails with the {{IncompatibleClassChangeError}} message and this is somewhat expected (there's no {{setProperty}} method on my actual Java class)..

Maybe the actual difference between my real-world project and the simple use case is that the corresponding {{MyJavaBean}} class is _not_ joint compiled with the Groovy compiler, since it comes from a plain Java project my Groovy project depends on.


;;;","11/Jul/14 03:21;mauromol;Nope... I tried to create two separate Eclipse projects, a plain Java project with {{MyJavaBean}} and a Groovy project depending on the first one, containing the Groovy class. Unfortunately, running it won't produce any error. I really don't know what to try than to reproduce on a smaller test case :-(;;;","11/Jul/14 03:35;mauromol;-Further details on the debugging: if I debug my real-world application, the {{receiver}} object, as I said, is of the actual ""undecorated"" type {{MyJavaBean}} (it does not have the {{metaClass}} internal property, which is produced by Groovy I guess). Instead, in the use case, although the Eclipse debugger says the object is of type {{MyJavaBen}}, if I inspect it I see that the only property is {{metaClass}, which stores all the decorations provided by Groovy.-

Another difference that I can think of is that in my real-world project, the {{MyJavaBean}} instance is actually created by Hibernate after querying a database, hence it's not created with {{new}} by myself.

Another idea: why does my failing case throw an {{IncompatibleClassChangeError}} from {{ScriptBytecodeAdapter.setGroovyObjectProperty()}}, while the test case, before the fix, threw it directly from the {{doCall()}} method of the inner class produced for the closure?;;;","11/Jul/14 03:36;melix;""So, I don't know how I can get to this line, since receiver should be a GroovyObject but it's not actually.""

That is precisely the reason why you have an {{IncompatibleClassChangeError}}, the *bytecode* invokes a call on this method. So to determine what path of the compiler generates such a call, I actually need a reproducible example, which I fail to find.;;;","11/Jul/14 03:48;mauromol;Maybe providing you with the class files produced in my real-world application for ""MyDao"" Groovy class can help you in some way?;;;","11/Jul/14 08:35;melix;Unfortunately no, it won't help. What I need is Groovy source code that produces bad bytecode. The compiled classes won't tell me anything :(;;;","16/Jul/14 05:42;mauromol;After further investigation, it seems like the problem only happens when code is compiled with Greclipse, although the only Groovy JAR I have in my project build path is groovy-2.3.4.jar.
I opened GRECLIPSE-1760 for this, thanks CÃ©dric for your support.;;;","16/Jul/14 05:43;mauromol;Ouch, there must be some encoding problem here :-P;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper loses trailing 0's in numbers (regression in Groovy 2.3),GROOVY-6922,12816963,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,candrews,candrews,07/Jul/14 22:40,22/Feb/16 20:48,14/Jul/23 06:01,10/Nov/15 20:55,2.3.0,2.4.3,,,,,,,,,,,,,,,,2.4.6,,,,JSON,,,,0,,,,,,,"In previous versions of Grails before JsonSlurper was significantly changed, this test passed. However, it fails in Groovy 2.3.x (tested up to 2.3.3).

{code}
void testParseNumWithDecimals() {
   def i = parser.parseText('123.40')
   BigDecimal i2 = 123.40G
   assert i instanceof BigDecimal
   assert i == i2
}
{code}
This test should be added to https://github.com/groovy/groovy-core/blob/GROOVY_2_3_X/subprojects/groovy-json/src/test/groovy/groovy/json/JsonSlurperTest.groovy

In Groovy 2.3.3, the assertion fails as i = 123.4G, not 123.40G.",,candrews,githubbot,jwagenleitner,pascalschumacher,richardhightower,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7483,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 10 20:55:22 UTC 2015,,,,,,,,,,"0|i2cmgf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"21/Jul/14 14:56;richardhightower;Not sure I see an issue here. Can someone explain this to me?;;;","09/Nov/15 21:56;jwagenleitner;This is somewhat related to the changes for GROOVY-6674 and [commit 842bcd4|https://github.com/apache/incubator-groovy/commit/842bcd4e23fefdf5b5e17d8d91af50e1ce565096] that changed the decimal return types from double to BigDecimal.  The assert {{assert 123.40G == 123.4G}} passes and the numbers are equivalent.  However, the reduction in scale of the number might be unexpected and is different in pre-2.3 releases.

{code}
def num = new groovy.json.JsonSlurper().parseText('{""num"": 123.40}').num
assert num instanceof BigDecimal
assert 2 == num.scale()  // fails: scale is 1
{code}

One way to fix with the least change would be to change this [{{lvalue#divide(java.math.BigDecimal)}}|https://github.com/apache/incubator-groovy/blob/e6185f9e33d40039c2140751ade37972046b676f/subprojects/groovy-json/src/main/java/groovy/json/internal/CharScanner.java#L667] to use the [{{#divide(java.math.BigDecimal,int,java.math.RoundingMode)}}|http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#divide(java.math.BigDecimal,%20int,%20java.math.RoundingMode)] method using {{digitsPastPoint}} for the scale and {{RoundingMode.UNNECESSARY}}.

However, I think a lot of the code is left over from when it was originally parsing to a Double.  So I think a better but bigger change would be to [replace the bulk of the parseJsonNumber method|https://github.com/apache/incubator-groovy/blob/e6185f9e33d40039c2140751ade37972046b676f/subprojects/groovy-json/src/main/java/groovy/json/internal/CharScanner.java#L657-L672] with a call to {{BigDecimal}} ctor that takes a buffer, offset and length.  This would have the added benefit of eliminating the String allocations.;;;","09/Nov/15 22:58;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/incubator-groovy/pull/184

    GROOVY-6922 - JsonSlurper loses trailing 0's in numbers

    This change is dependent on the change made in commit 84467fddc64744cc05d2b91b8704c753a9fb3d04 in master to the [CharScanner#parseBigDecimal(char[],int,int)] (https://github.com/apache/incubator-groovy/commit/84467fddc64744cc05d2b91b8704c753a9fb3d04#diff-d0df59d6b1bac924a44389e6b41aac99R687) method.
    
    The code being replaced looked like it was code left over from when the method returned a double for decimal values.  This change uses the [BigDecimal(char[],int,int)] (http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#BigDecimal(char[],%20int,%20int)) constructor (available since 1.5) for parsing of the decimal string and also eliminates the new String object allocations.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/incubator-groovy GROOVY-6922

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/184.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #184
    
----
commit 75a037c9ff26265790599bfd1d010ad75c6d5b70
Author: John Wagenleitner <john.wagenleitner@gmail.com>
Date:   2015-11-07T20:50:14Z

    GROOVY-6922 - JsonSlurper loses trailing 0's in numbers

----
;;;","10/Nov/15 20:52;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/184
;;;","10/Nov/15 20:55;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC: problem with a getAt call in double nested collect call,GROOVY-6921,12817650,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,07/Jul/14 16:01,08/Jul/14 15:28,14/Jul/23 06:01,08/Jul/14 03:29,2.3.3,,,,,,,,,,,,,,,,,2.3.4,,,,Static compilation,,,,0,,,,,,,"The following code works well dynamically, properly type checks, but fails static compilation:
{code}
@groovy.transform.CompileStatic test() {
    def versionRanges = [['1.7', 11]]
    versionRanges.collect { versionRange -> versionRange[1].collect { versionRange[0] } }.flatten()
}

test()
{code}
{noformat}
Exception thrown

BUG! exception in phase 'class generation' in source unit 'ConsoleScript23' At line 3 column 45
On receiver: versionRange with message: getAt and arguments: 1
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY
{noformat}

Although it's reported on the first {{versionRange[1]}}, it's actually seems related to the second call ({{versionRange[0]}}). If you remove that second call, all is fine.",Mac OS X,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 07 16:03:32 UTC 2014,,,,,,,,,,"0|i2bzp3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Jul/14 16:03;guillaume;My initial algorithm looked like so:
{code}
def versionRanges = [
    ['1.7', 11],
    ['1.8', 9],
    ['2.0', 8],
    ['2.1', 9],
    ['2.2', 2],
    ['2.3', 2]
]

versionRanges.collect { versionRange -> (0..versionRange[1]).collect { ""${versionRange[0]}.${it}"" } }.flatten()
{code}

The idea was to generate all the versions of Groovy 1.7 onward for referencing them on the Groovy website.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compilation fails with multiple bounds generics,GROOVY-6919,12817660,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mauromol,mauromol,07/Jul/14 07:42,11/Mar/22 19:56,14/Jul/23 06:01,06/Oct/21 19:37,2.3.3,2.4.0-rc-1,,,,,,,,,,,,,,,,2.5.17,3.0.11,4.0.0-beta-2,,Static compilation,,,,0,,,,,,,"Consider the following interfaces:

{code:java}
public interface H1 {
  String getFoo();
}
{code}

{code:java}
public interface H2 {
  String getBar();
}
{code}

and the following Groovy class:
{code}
@CompileStatic
class HGroovy {
	public <T extends H1 & H2> void doSomething(T obj) {
		obj.foo
		obj.bar
	}
}
{code}

Compilation fails:
{noformat}
HGroovy.groovy: 9: [Static type checking] - No such property: bar for class: T
 @ line 9, column 3.
                obj.bar
{noformat}",,blackdrag,guillaume,jwagenleitner,mauromol,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 07 08:06:58 UTC 2014,,,,,,,,,,"0|i2brbz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Jul/14 07:44;mauromol;Please also note that if I remove the visibility modifier (""public"") from {{doSomething()}}, compilation also fails with:
{noformat}
HGroovy.groovy: 8: unexpected token: < @ line 8, column 2.
        <T extends H1 & H2> void doSomething(T obj) {
{noformat}

Is this another problem or the expected behaviour?;;;","07/Jul/14 07:49;guillaume;It's not a problem with static compilation, but a known limitation of the Groovy parser.
It's something we might be able with the ongoing rewrite of the parser for a future version of Groovy.;;;","07/Jul/14 07:55;blackdrag;I can verify the issue of the static compiler thinking T is a normal class is present on master;;;","07/Jul/14 08:06;mauromol;Yes, I'm convinced there are two problems here. The first one is the static compilation error, as reported in the original report, the second one is a limitation of the parser (regarding the second compiler error if ""public"" is missing described in my previous comment).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyDoc index-all page seems to list methods from private classes which are broken links,GROOVY-6918,12818465,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,07/Jul/14 00:20,07/Apr/15 19:07,14/Jul/23 06:01,07/Jul/14 05:52,,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,Documentation,,,,0,,,,,,,"e.g.:
{noformat}
hasNext() - Method in DefaultGroovyMethods.TakeIterator
{noformat}

The private class's methods are public. I presume private methods don't show but the fact that we are in a private class isn't accounted for.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-07 00:20:04.0,,,,,,,,,,"0|i2bt9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
additional cleanup for @Category combined with @CompileStatic,GROOVY-6917,12815444,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,04/Jul/14 16:20,07/Apr/15 19:06,14/Jul/23 06:01,04/Jul/14 17:30,2.3.3,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,,,,,0,,,,,,,generated code seems OK but numerous warnings are produced in @CS debug mode,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-04 16:20:22.0,,,,,,,,,,"0|i2bz1b:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using markup in a GString causes a stack overflow,GROOVY-6916,12817620,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,04/Jul/14 09:49,08/Jul/14 15:28,14/Jul/23 06:01,06/Jul/14 08:46,2.3.3,,,,,,,,,,,,,,,,,2.3.4,,,,Templating,,,,0,,,,,,,"In a markup template, if you write something like:

{code}
p ""This is a ${strong('bold text')}""
{code}

the user will assume that the output is:

{code}
<p>This is a <strong>bold text</strong>/</p>
{code}

However, the markup builder is a *streaming* builder, so calling a method in a GString results in a direct rendering to the output. At best, it will trigger a NPE, or a stack overflow.

I suggest to add the following notation to allow that kind of code:

{code}
p ""This is a ${$strong('bold text')}""
{code}

The inner tag is preceded with a dollar($) sign, which tells the markup engine that the call should be rendered as a string. It would be a shortcut notation for:

{code}
p ""This is a ${stringOf { strong('bold text') } }""
{code}

",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-04 09:49:02.0,,,,,,,,,,"0|i2ckbj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Performance issue with resource resolution in TemplateResolver,GROOVY-6914,12816968,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,04/Jul/14 06:39,08/Jul/14 15:28,14/Jul/23 06:01,04/Jul/14 07:02,,,,,,,,,,,,,,,,,,2.3.4,,,,Templating,,,,0,,,,,,,"The default template resolver, in the markup template engine, always delegate to the classloader. As illustrated by https://github.com/ratpack/ratpack/pull/370 and https://github.com/ratpack/ratpack/pull/363, this can lead to a performance drop.

The sitation can be fixed by adding caching of already resolved URLs.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-04 06:39:23.0,,,,,,,,,,"0|i2c8jb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
additional cleanup for @Immutable combined with @CompileStatic,GROOVY-6913,12812131,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,04/Jul/14 04:07,07/Apr/15 19:07,14/Jul/23 06:01,04/Jul/14 04:40,2.3.3,2.4.0-beta-1,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,,,,,0,,,,,,,removes warnings triggered with stc debug mode (even though current produced bytecode seems fine),,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-04 04:07:15.0,,,,,,,,,,"0|i2bsu7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic not recognising Literal list when LHS is a concrete list type,GROOVY-6912,12818481,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,paulk,,04/Jul/14 02:39,26/Jan/23 22:21,14/Jul/23 06:01,28/Mar/21 18:39,2.3.3,2.4.0-beta-1,,,,,,,,,,,,,,,,2.5.22,3.0.15,4.0.0-alpha-3,,Static Type Checker,,,,0,,,,,,,"Compiling this code:
{code}
@CompileStatic
class X {
    ArrayList list = [1,2,3]
}
{code}
or this:
{code}
@CompileStatic
def method() {
    ArrayList list = [1,2,3]
}
{code}
gives:
{noformat}
[Static type checking] - No matching constructor found: java.util.ArrayList <E extends java.lang.Object -> java.lang.Object><init>(int, int, int)
{noformat}
",,emilles,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Mar 27 04:59:34 UTC 2021,,,,,,,,,,"0|i2c4in:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Mar/21 16:01;emilles;The compiler tries to apply tuple constructor transformation. Should this case work the same as this?
{code:groovy}
ArrayList list = [1,2,3] as ArrayList
{code}

What about a more complex type that also implements {{List}}, like {{groovy.lang.Range}} or {{groovy.lang.Tuple}} or {{org.spockframework.lang.Wildcard}}?;;;","27/Mar/21 04:59;emilles;Runtime uses the list as a constructor argument when no constructor is found for the tuple of the list elements.  STC/SC does not implement this fallback.  I think {{StaticTypeCheckingVisitor#addListAssignmentConstructorErrors}} is where the extra check needs to be added.  After that, not sure if classgen needs something as well.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
createGenericsSpec java.lang.ArrayIndexOutOfBoundsException: 1,GROOVY-6911,12811414,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,chice,chice,04/Jul/14 01:40,26/Jul/14 01:44,14/Jul/23 06:01,24/Jul/14 10:50,2.3.3,,,,,,,,,,,,,,,,,2.3.5,,,,Compiler,,,,0,,,,,,,"I can only find this exception, I can not get to know which groovy file caused this problem.

{noformat}
java.lang.ArrayIndexOutOfBoundsException: 1
	at org.codehaus.groovy.ast.tools.GenericsUtils.createGenericsSpec(GenericsUtils.java:376)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1579)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.inferenceCheck(StaticTypeCheckingSupport.java:1379)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1349)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1294)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.typeCheckMethodsWithGenericsOrFail(StaticTypeCheckingVisitor.java:4059)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2648)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:245)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBooleanExpression(CodeVisitorSupport.java:166)
	at org.codehaus.groovy.ast.expr.BooleanExpression.visit(BooleanExpression.java:40)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitIfElse(StaticTypeCheckingVisitor.java:2873)
	at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:41)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1540)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1844)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1803)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:144)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1063)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:179)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:110)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:61)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1047)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:583)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:561)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:538)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.gmavenplus.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:118)
	at org.codehaus.gmavenplus.mojo.AbstractCompileMojo.doCompile(AbstractCompileMojo.java:194)
	at org.codehaus.gmavenplus.mojo.CompileMojo.execute(CompileMojo.java:50)
	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:106)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:318)
	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:153)
	at org.apache.maven.cli.MavenCli.execute(MavenCli.java:555)
	at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:214)
	at org.apache.maven.cli.MavenCli.main(MavenCli.java:158)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)
	at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:414)
	at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:357)
{noformat}",,blackdrag,chice,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 24 10:50:05 UTC 2014,,,,,,,,,,"0|i2bniv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Jul/14 02:52;chice;I think the bug is caused by:

public class MapMessage<T> extends LinkedHashMap<String, Object> { ... }
MapMessage testFunc() { ... } 
Map<String, Object> response = testFunc();  // may crash here.


I am busy on a project so haven't prepared a test case.
When I use ""MapMessage response = testFunc();"" , everything works fine.


;;;","21/Jul/14 08:09;melix;Unfortunately I am not able to reproduce with this example.;;;","22/Jul/14 03:13;chice;I have tried but I can not reproduce this bug with a simple example.

It still crashes in my project if I use ""Map<String, Object> response = testFunc();""

In groovy 2.1.x it works OK, but in 2.3.3 it crashes.
;;;","22/Jul/14 03:20;melix;Can you try with 2.3.4 and/or 2.3.5-SNAPSHOT?;;;","22/Jul/14 03:37;chice;2.3.4 crashes again:

{code}
Error:Groovyc: java.lang.ArrayIndexOutOfBoundsException: 1
	at org.codehaus.groovy.ast.tools.GenericsUtils.createGenericsSpec(GenericsUtils.java:395)
	at org.codehaus.groovy.ast.tools.GenericsUtils.createGenericsSpec(GenericsUtils.java:370)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.extractGenericsConnections(StaticTypeCheckingSupport.java:1579)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.inferenceCheck(StaticTypeCheckingSupport.java:1379)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1335)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1294)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.typeCheckMethodsWithGenericsOrFail(StaticTypeCheckingVisitor.java:4133)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2725)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:245)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitCastExpression(CodeVisitorSupport.java:232)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitCastExpression(StaticTypeCheckingVisitor.java:3024)
	at org.codehaus.groovy.ast.expr.CastExpression.visit(CastExpression.java:66)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitForLoop(StaticTypeCheckingVisitor.java:1413)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitForLoop(StaticCompilationVisitor.java:287)
	at org.codehaus.groovy.ast.stmt.ForStatement.visit(ForStatement.java:47)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1614)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1933)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1892)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:144)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1063)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:240)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:110)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:61)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1047)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:583)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:561)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:538)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:54)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:81)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:100)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:121)
{code};;;","22/Jul/14 03:39;chice;where can I get 2.3.5-SNAPSHOT ?  I try to use ""2.3.5-SNAPSHOT"" in pom.xml, but it doesn't work
;;;","22/Jul/14 09:50;blackdrag;looking at https://github.com/groovy/groovy-core/blob/GROOVY_2_3_4/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java#L385 then I see that the code assumes, that spec.length==newGts.length. Something breaking that condition should actually be caught somewhere else (but of course, that might not be the case). For the exception to happen though, newGts.length must be smaller than spec.length. That means we have for example something like ""class Foo extends LinkedHashMap<Integer,String,Bar>"". Important here is that LinkedHashMap has 2 generics parameters (newGts.length==2), but the usage will provide 3 generics arguments (spec.length==3). 

Trying this example gives two errors, one is the ArrayOutOfBoundsException (for index 2 here of course) but also a ""The class java.util.LinkedHashMap refers to the class java.util.LinkedHashMap and uses 3 parameters, but the referred class needs 2"". But this example is not reproducing the path taken in this issue.

I can only imagine MapMessage is tested against MapMessage<T> and that some transform falsely gave the return type of testFunc an empty generics type array.

So are you using any ast transforms?


;;;","22/Jul/14 22:41;chice;No, I don't use AST transforms.

And ... I CAUGHT the crash  :)

{code}
package test
import groovy.transform.CompileStatic

class MyMap<T> extends LinkedHashMap<String, Object> { }

class C {
    MyMap bar() { null }
}

@CompileStatic
class GroovyCrashTest {
    void foo() {
        Map<String, Object> m = new C().bar()
        List tmp = (List) m.get(""some_key_here"")     // <---  actually groovy crashes here!!
    }
}
{code}
;;;","24/Jul/14 10:50;melix;Fixed via https://github.com/groovy/groovy-core/commit/aa6a3c064ceb07fd26c41842aa891bf939c21413;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic in combo with @IndexProperty transform is broken,GROOVY-6910,12815445,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,04/Jul/14 00:17,07/Apr/15 19:07,14/Jul/23 06:01,04/Jul/14 03:27,,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,,,,,0,,,,,,,"This script:
{code}
import groovy.transform.*
@CompileStatic
class Demo {
    @IndexedProperty List<Integer> foo
    @IndexedProperty String[] bar
    @IndexedProperty List baz
}

def d = new Demo()
d.foo = [11, 22, 33]
d.setFoo(0, 100)
d.setFoo(1, 200)
assert d.foo == [100, 200, 33]
assert d.getFoo(1) == 200
d.bar = ['cat']
d.setBar(0, 'dog')
assert d.getBar(0) == 'dog'
d.baz = ['cat']
d.setBaz(0, 'dog')
assert d.getBaz(0) == 'dog'
{code}
gives:
{noformat}
BUG! exception in phase 'class generation' in source unit 'ConsoleScript4' At line -1 column -1
On receiver: foo with message: getAt and arguments: index
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY
  at org.codehaus.groovy.classgen.asm.sc.StaticTypesCallSiteWriter.makeSingleArgumentCall(StaticTypesCallSiteWriter.java:558)
  ...
  at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:560)
  ...
{noformat}
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-04 00:17:09.0,,,,,,,,,,"0|i2cr0n:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic in combo @WithXXXLock transform is broken,GROOVY-6909,12811928,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,03/Jul/14 19:09,07/Apr/15 19:07,14/Jul/23 06:01,03/Jul/14 20:50,,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,,,,,0,,,,,,,"This code:
{code}
import groovy.transform.*

@CompileStatic
class Counters {
    public final Map<String,Integer> map = [:].withDefault { 0 }

    @WithReadLock
    int get(String id) {
        map.get(id)
    }

    @WithWriteLock
    void add(String id, int num) {
        Thread.sleep(100) // emulate long computation
        map.put(id, map.get(id)+num)
    }
}

def counters = new Counters()
assert counters.get('a') == 0
assert counters.get('b') == 0

10.times { cpt ->
    Thread.start { counters.add('a', 1) }
    def t = Thread.start {
        Thread.sleep(20)
        assert counters.get('a') == cpt+1
    }
    t.join(250)
}
{code}
gives errors such as:
{noformat}
assert counters.get('a') == cpt+1
       |        |        |  |  |
       |        2        |  5  6
       Counters@3b871f   false
{noformat}",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-03 19:09:21.0,,,,,,,,,,"0|i2ciqv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AIC in Closure is checked for wrong constructor,GROOVY-6904,12816947,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,02/Jul/14 11:47,08/Jul/14 15:28,14/Jul/23 06:01,03/Jul/14 04:23,2.3.3,,,,,,,,,,,,,,,,,2.3.4,,,,Static Type Checker,,,,0,,,,,,,"{code:Java}
interface X {
    def m()
}

@groovy.transform.CompileStatic
class A {
    Object pm = ""pm""

    def bar(Closure<? exends X> x) {x().m()}
    def foo() {
        bar { ->
            return new X() {
                def m() {
                    print pm.getClass().getSimpleName()
                }
            }
        }
    }
}
{code}

This fails with 

Cannot call A$1#<init>(groovy.lang.Closure) with arguments [A] 

and 

Cannot find matching method A#bar(groovy.lang.Closure <A$1>). Please check if the declared type is right and if the method exists.

but it should work",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 03 04:23:14 UTC 2014,,,,,,,,,,"0|i2bu3b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jul/14 04:23;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
try catch cause a NullPointerException,GROOVY-6903,12816940,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,msdx,msdx,02/Jul/14 03:38,28/Jul/14 20:22,14/Jul/23 06:01,21/Jul/14 08:18,,,,,,,,,,,,,,,,,,2.4.0-beta-2,,,,,,,,0,,,,,,,"There will be a strange exception occured when I use groovy like the following.

{noformat}
07-01 23:26:08.853    7351-7371/com.githang.android.tucao.android E/AndroidRuntimeÃ¯Â¹â¢ FATAL EXCEPTION: Thread-23837
    java.lang.NullPointerException
            at groovy.lang.MetaClassImpl.getProperties(MetaClassImpl.java:1959)
            at org.codehaus.groovy.runtime.MethodRankHelper.getPropertySuggestionString(MethodRankHelper.java:175)
            at groovy.lang.MissingPropertyException.getMessageWithoutLocationText(MissingPropertyException.java:66)
            at groovy.lang.GroovyRuntimeException.getMessage(GroovyRuntimeException.java:62)
            at java.lang.Throwable.getLocalizedMessage(Throwable.java:187)
            at java.lang.Throwable.toString(Throwable.java:361)
            at java.lang.Throwable.printStackTrace(Throwable.java:321)
            at java.lang.Throwable.printStackTrace(Throwable.java:288)
            at java.lang.Throwable.printStackTrace(Throwable.java:236)
            at com.githang.android.crash.CrashHttpReport.sendReport(CrashHttpReport.java:92)
            at com.githang.android.crash.AbstractCrashReportHandler$1.run(AbstractCrashReportHandler.java:70)
            at java.lang.Thread.run(Thread.java:838)
07-01 23:26:08.984    7351-7351/com.githang.android.tucao.android D/GraphicBufferÃ¯Â¹â¢ create handle(0x5fb7de28) (w:720, h:1280, f:1)
07-01 23:26:08.993    7351-7351/com.githang.android.tucao.android D/GraphicBufferÃ¯Â¹â¢ close handle(0x5fb7de28) (w:720 h:1280 f:1)
07-01 23:26:09.002    7351-7351/com.githang.android.tucao.android D/GraphicBufferÃ¯Â¹â¢ create handle(0x5fb7de28) (w:720, h:1280, f:1)
{noformat}
At first , I thought it was my open source project(andriod-crash:https://github.com/msdx/android-crash) error, but the line that the log print was like the following:
{noformat}
91:        } catch (Exception e) {
92:            e.printStackTrace();
93:        }
{noformat}
How could the line of code is wrong?

And I use the project in my another project write by Java, it works, and no any exception.","jdk 1.7
groovy 2.4.0-beta1
android sdk 19",msdx,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-07-02 03:38:49.0,,,,,,,,,,"0|i2bz3z:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Grab dependencies can't be fetched,GROOVY-6901,12817659,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,rherrick,rherrick,30/Jun/14 14:07,28/Jul/14 21:54,14/Jul/23 06:01,28/Jul/14 21:53,2.3.3,,,,,,,,,,,,,,,,,2.3.5,2.4.0-beta-2,,,Grape,,,,0,grab,grape,,,,,"When I try to grab dependencies, I get an error:

{code}1:36:15 PM 0 Grape dependency jars added
           @Grab(group = 'org.codehaus.groovy.modules.http-builder', module = 'http-builder', version = '0.7.2'): 0 jars
           org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
           General error during conversion: No such property: canonicalPath for class: java.net.URL
           groovy.lang.MissingPropertyException: No such property: canonicalPath for class: java.net.URL{code}

Full error message available [my github gists|https://gist.github.com/rherrick/9553c33e98063bb6aaa3].",Running in IntelliJ IDEA on OSX,paulk,rherrick,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Jun/14 14:07;rherrick;sandbox.groovy;https://issues.apache.org/jira/secure/attachment/12722676/sandbox.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 28 21:53:52 UTC 2014,,,,,,,,,,"0|i2c7af:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Jun/14 14:37;rherrick;This is actually an issue with IntelliJ: http://youtrack.jetbrains.com/issue/IDEA-119843. If you have run into this same problem:

# Open your module settings.
# Click the Dependencies tab.
# Delete all of your dependencies except for the JDK, your module source, and the groovy compiler.
# Try to grab the artifacts again. It should work this time.

Still, it would be nice to have better reporting of the error if possible. It's worth noting that this worked when I first grabbed the dependencies, which was for http-builder 0.7. I then realized I needed 0.7.1 or later to get the HTTPBuilder.ignoreSSLIssues setting, so changed the version and that's when the error started appearing.;;;","03/Jul/14 06:38;paulk;I changed the error message building logic in GrapeIvy to only look for canonicalPath for files. This should get rid of the MissingPropertyException and I suspect will yield the real error message that is occurring in this scenario. Is this sufficient to close this issue?;;;","28/Jul/14 21:53;paulk;No further feedback provided. I am assuming as per last comment, that the issue has been fixed but please reopen (or create a new issue) if you see further problems.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException in TypeResolver when using traits with generics,GROOVY-6899,12817419,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mperry,mperry,28/Jun/14 09:50,23/Dec/14 19:45,14/Jul/23 06:01,22/Dec/14 04:56,2.3.3,,,,,,,,,,,,,,,,,2.3.7,,,,,,,,1,,,,,,,"Found an issue when using generics with traits that work when doing the same thing with classes.  This manifests with a NullPointerException in the TypeResolver.  I have isolated the issue, see https://github.com/mperry/bug-generic-grooy-traits for details and the source.",,bwolff,guillaume,melix,mperry,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 22 04:56:54 UTC 2014,,,,,,,,,,"0|i2ccbz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"28/Jun/14 14:45;guillaume;Mark, could you also please tell us which specific version of the JDK you're using?
I haven't tried running your project yet, but we've seen often NPEs in JDK's TypeResolver in the past in particular versions of the JDK;;;","29/Jun/14 07:41;mperry;Occurs on both Java 1.7.0_45-b18 and 1.8.0_05-b13 on Windows 7.
;;;","22/Dec/14 04:56;melix;I tested with 2.3.3 -> 2.3.9 and this issue was fixed in 2.3.7.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
" java.lang.NoSuchMethodError: groovy.xml.StreamingMarkupBuilder.bind(Ljava/lang/Object;)Ljava/lang/Object;",GROOVY-6897,12817629,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,kaaloo,kaaloo,26/Jun/14 16:11,08/Jul/14 15:28,14/Jul/23 06:01,27/Jun/14 02:18,2.3.3,,,,,,,,,,,,,,,,,2.3.4,,,,XML Processing,,,,0,,,,,,,"I get the following stacktrace when running some tests using either groovy http-builder 0.7.2 or the grails rest-client-builder plugin 2.0.3.  The problem goes away in grails 2.3.10.  I believe the bug is in groovy 2.3.X and is caused by the following commit in StreamingMarkupBuilder where the return type for the bind() method was changed to Writeable:

https://github.com/groovy/groovy-core/commit/77040982113e08175e0dfd19950fcb2fae177102#diff-5bfd9ab05363e18c9afd9d9076d341c8

Here is a sample stacktrace:

| Failure:  testGetLastTransactions(grails.plugins.pinpayments.PinPaymentsServiceTests)
|  java.lang.NoSuchMethodError: groovy.xml.StreamingMarkupBuilder.bind(Ljava/lang/Object;)Ljava/lang/Object;
	at grails.plugins.rest.client.RequestCustomizer.xml(RequestCustomizer.groovy:259)
	at grails.plugins.pinpayments.PinPaymentsService$_createSubscriber_closure1.doCall(PinPaymentsService.groovy:38)
	at grails.plugins.rest.client.RestBuilder.doRequestInternal(RestBuilder.groovy:269)
	at grails.plugins.rest.client.RestBuilder.doRequestInternal(RestBuilder.groovy:261)
	at grails.plugins.rest.client.RestBuilder.post(RestBuilder.groovy:147)
	at grails.plugins.pinpayments.PinPaymentsService.createSubscriber(PinPaymentsService.groovy:36)
	at grails.plugins.pinpayments.PinPaymentsServiceTests.testGetLastTransactions(PinPaymentsServiceTests.groovy:204)
	at junit.framework.TestCase.runTest(TestCase.java:176)
	at junit.framework.TestCase.runBare(TestCase.java:141)
	at junit.framework.TestResult$1.protect(TestResult.java:122)
	at junit.framework.TestResult.runProtected(TestResult.java:142)
	at junit.framework.TestResult.run(TestResult.java:125)
	at junit.framework.TestCase.run(TestCase.java:129)
	at junit.framework.TestSuite.runTest(TestSuite.java:255)
	at junit.framework.TestSuite.run(TestSuite.java:250)
","Grails 2.4.2, java 7 openjdk",kaaloo,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 27 02:25:50 UTC 2014,,,,,,,,,,"0|i2cqi7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jun/14 02:18;melix;This is indeed a breakeage of the public API. The line you pointed at is unrelated to the idea of the commit and it should probably not have been done!;;;","27/Jun/14 02:25;kaaloo;Ah cool Cédric, thanks for looking into this.  I've been pulling my hair out all day yesterday trying to figure out what was going on.  I wonder if there is a workaround by adding a bind method with the correct signature at run-time using meta programming ?  I'd really like to use grails 2.4.X.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Assignment chain fails when using @CompileStatic,GROOVY-6896,12817639,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,mauromol,mauromol,26/Jun/14 10:18,17/Dec/14 13:25,14/Jul/23 06:01,23/Sep/14 11:38,2.3.3,2.4.0-beta-1,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Static compilation,,,,1,,,,,,,"Consider the following Java class:

{code:java}
package b;

import java.util.concurrent.Callable;

public class B {
	private String name;

	public B(final String name) {
		this.name = name;
	}
	
  public void setCallable(final Callable<String> c) {
	  System.out.println(name + "": "" + String.valueOf(c));
  }
}
{code}

and the following Groovy class:
{code}
@CompileStatic
class Test {

	static main(args) {
		def clos = { 'bar' } as Callable<String>
		B b1 = new B('b1')
		B b2 = new B('b2')
		b1.callable = b2.callable = clos
	}
}
{code}

Run {{Test}} class as a Groovy script: {{b1.callable}} is assigned {{null}}, instead of the {{clos}} closure. Remove the {{@CompileStatic}} in {{Test}}, re-run and... all goes right!",,davide.cavestro,mauromol,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 24 02:58:25 UTC 2014,,,,,,,,,,"0|i2bmvb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Sep/14 02:27;mauromol;Hi Cédric, thanks for the fix. Don't you plan to backport this to 2.3.x? It's a subtle problem that arises only at runtime and leads to situations hard to diagnose...;;;","24/Sep/14 02:58;melix;I can't directly backport the fix to 2.3.x because it was made as part of the overloaded setters support. So it would have to be a different fix actually.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MarkupTemplateEngine may silently swallow errors,GROOVY-6895,12817646,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,26/Jun/14 02:24,08/Jul/14 15:28,14/Jul/23 06:01,26/Jun/14 02:25,2.3.3,,,,,,,,,,,,,,,,,2.3.4,,,,Templating,,,,0,,,,,,,"The following code in the {{BaseTemplate}} class may cause errors to be silently dropped:

{code}
public Writer writeTo(final Writer out) throws IOException {
        try {
            this.out = createWriter(out);
            run();
            return out;
        } finally {
            this.out.flush();
            this.out = null;
        }
    }
{code}

To avoid the problem, a null check should be added to the {{finally}} block.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-06-26 02:24:22.0,,,,,,,,,,"0|i2cfl3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Oddity with Min function for Collections,GROOVY-6892,12817642,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,onevim,onevim,25/Jun/14 00:36,17/Dec/14 13:25,14/Jul/23 06:01,01/Aug/14 08:39,,,,,,,,,,,,,,,,,,2.4.0-beta-3,,,,,,,,0,,,,,,,"Consider the following array:

arr = [3,null,5]

Calling min() on this array results in the value 3.  However, using min with a closure as in...

arr.min { it }

will result in the value of 5.  Groovy basically ignores everything prior to and including the null.

Someone first detected this problem a couple of years ago, but it still doesn't appear to be fixed.  Here is the original thread on this:

http://groovy.329449.n5.nabble.com/Oddity-with-Groovy-Collection-min-when-using-a-closure-td5710629.html",,onevim,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 29 16:46:02 UTC 2014,,,,,,,,,,"0|i2bq9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jun/14 06:42;paulk;Proposed solution here:
https://github.com/groovy/groovy-core/pull/464

It might be considered slightly controversial. To illustrate, consider your example above:
{code}
def arr = [3,null,5]
assert arr.min() == 3                                       // (1)
assert arr.min{ it } == null                                // (2)
assert arr.min{ it == null ? Integer.MAX_VALUE : it } == 3  // (3)
assert arr.grep().min{ it } == 3                            // (4)
{code}
As you correctly point out, the current {{min()}} function returns {{3}} (see <1>).
I have implemented the Closure variant slightly differently so that it doesn't have the same null excluding behavior. This is more in line with the standard treatment of null values with comparators (see http://stackoverflow.com/questions/2401606/comparator-with-null-values). So with this in mind, the returned result is now {{null}} (see <2>).
As per the SO reference, you normally want to handle null values in your Closure (see <3>) or remove the nulls beforehand (e.g. see <4>).;;;","27/Jun/14 06:43;paulk;Note: I would also be in favor of the normal {{min()}} function returning {{null}} for your sample numbers (and perhaps adding a {{minNonNull()}} or {{minResult()}} function as well to give the existing behavior) but that would be an even more controversial breaking change.;;;","29/Jun/14 16:46;onevim;I actually implemented the closure for my code exactly as you suggested in (3).  I looked at this as more of a work around initially, but if this is the expected way to do this, then my apologies for not knowing better! :)  I liked your suggestion, but completely understand the controversy associated with that.  Perhaps it might be better to simply explain this particular nuance in the API docs?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inconsistent setter selection dynamic and static Groovy,GROOVY-6891,12811927,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,gillius,gillius,24/Jun/14 15:34,17/Dec/14 13:25,14/Jul/23 06:01,19/Sep/14 07:10,2.3.3,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,,,,,0,,,,,,,"Tested in JDK 7, GroovyConsole 2.3.3:

{code}
class X {
  void setValue(String v) { println ""String $v"" }
  void setValue(float f) { println ""float $f"" }
}

new X().value = 12.3f //Outputs ""float 12.3""
//new X().value = ""123"" //would fail with Cannot cast object '123' with class 'java.lang.String' to class 'float'

@groovy.transform.CompileStatic
void doIt() {
new X().value = 12.3f //Outputs ""String 12.3""
new X().value = ""123"" //Outputs ""String 123""
}

doIt()
{code}

In real code, some developers report code always working/compiling, others report that it fails 25% of the time.

I expected dynamic Groovy to select method at runtime based on type, and static Groovy to select method at compile time based on inferred type.

I think this is a bug in Groovy, if for no other reason than dynamic Groovy ought to issue an ambiguous call and static Groovy should at a minimum issue compile error, if Groovy doesn't support multiple setX methods when using property notation. Or maybe at least Groovy should be consistently selecting a set method. Based on the other developer's experience, it seems that the setter selection could differ on each execution. In any case I'sd expect a compile/runtime error or consistent behavior.",,gillius2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-06-24 15:34:24.0,,,,,,,,,,"0|i2bq8n:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checking fails if I change the closure input parameter name,GROOVY-6888,12817619,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mauromol,mauromol,20/Jun/14 17:25,06/Mar/18 23:14,14/Jul/23 06:01,01/Feb/18 06:23,2.3.3,2.4.0-beta-1,2.4.0-rc-1,,,,,,,,,,,,,,,2.4.14,,,,Static Type Checker,,,,0,,,,,,,"Consider the following:

{code}
@TypeChecked
class A {
  @Bindable
  String foo
  
  static void main(String[] args) {
	  A a = new A()
	  a.foo = 'old'
	  a.addPropertyChangeListener('foo') { event ->
		  println 'foo changed: ' + event.oldValue + ' -> ' + event.newValue
	  }
	  a.foo = 'new'
  }
}
{code}

The Groovy compiler fails:
bq. [Static type checking] - No such property: oldValue for class: java.lang.Object

This is unexpected, because if I leave the {{event}} naming of the closure input parameter and use {{it.oldValue}}/{{it.newValue}} the static type checking succeeds (as it should).",,mauromol,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8317,GROOVY-8241,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 01 06:23:58 UTC 2018,,,,,,,,,,"0|i2cbd3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Oct/15 18:29;shils;Compilation fails even if there's one declared parameter with name 'it'. There appear to be a couple different issues:

1. StaticTypeCheckingVisitor.inferSAMType does not correctly infer the parameter types for the CLOSURE_ARGUMENTS metadata to be set on the closure expression; since there are a nonzero number of declared parameters, it's type is taken to be the type of the parameter, which is Object. 

2. When determining a variable parameter's type within a closure, StaticTypeCheckingVisitor.getType doesn't use the CLOSURE_ARGUMENTS metadata unless the variable's name is ""it"".;;;","01/Feb/18 06:23;paulk;Duplicate;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AutoClone issue with CompileStatic,GROOVY-6887,12815455,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,20/Jun/14 15:25,07/Apr/15 19:07,14/Jul/23 06:01,25/Jun/14 20:25,2.3.3,2.4.0-beta-1,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,,,,,0,,,,,,,"This script:
{code}
import groovy.transform.AutoClone
import groovy.transform.CompileStatic

@CompileStatic
@AutoClone
class Event {
   Long timeStamp = -1
}

println Event        // OK
println new Event()  // VerifyError
{code}
compiles OK but fails with a VerifyError when run:
{noformat}
java.lang.VerifyError: (class: Event, method: clone signature: ()Ljava/lang/Object;) Bad access to protected data

	at java.lang.Class.getDeclaredConstructors0(Native Method)

	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2493)

	at java.lang.Class.getDeclaredConstructors(Class.java:1901)

	at org.codehaus.groovy.reflection.CachedClass$2$1.run(CachedClass.java:69)

	at java.security.AccessController.doPrivileged(Native Method)

	at org.codehaus.groovy.reflection.CachedClass$2.initValue(CachedClass.java:66)

	at org.codehaus.groovy.reflection.CachedClass$2.initValue(CachedClass.java:64)

	at org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:46)

	at org.codehaus.groovy.util.LazyReference.get(LazyReference.java:33)

	at org.codehaus.groovy.reflection.CachedClass.getConstructors(CachedClass.java:263)

	at groovy.lang.MetaClassImpl.<init>(MetaClassImpl.java:190)

	at groovy.lang.MetaClassImpl.<init>(MetaClassImpl.java:194)

	at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createNormalMetaClass(MetaClassRegistry.java:158)

	at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createWithCustomLookup(MetaClassRegistry.java:148)

	at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.create(MetaClassRegistry.java:131)

	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:209)

	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:241)

	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:255)

	at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:859)

	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallConstructorSite(CallSiteArray.java:84)

	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)

	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)

	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:186)

	at ConsoleScript0.run(ConsoleScript0:13)

	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:258)

	at groovy.lang.GroovyShell.run(GroovyShell.java:502)

	at groovy.lang.GroovyShell.run(GroovyShell.java:481)

	at groovy.lang.GroovyShell.run(GroovyShell.java:164)

	at groovy.lang.GroovyShell$run$0.call(Unknown Source)

	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)

	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)

	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)

	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:977)

	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)

	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)

	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)

	at java.lang.reflect.Method.invoke(Method.java:606)

	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)

	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)

	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)

	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:910)

	at groovy.lang.Closure.call(Closure.java:423)

	at groovy.lang.Closure.call(Closure.java:417)

	at groovy.lang.Closure.run(Closure.java:504)

	at java.lang.Thread.run(Thread.java:745)
{noformat}
Without {{CompileStatic}} it runs fine.",,paulk,sirinath,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 23 08:59:23 UTC 2014,,,,,,,,,,"0|i2c9z3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jun/14 15:27;paulk;This is trying to isolate a part of the issue from http://jira.codehaus.org/browse/GROOVY-6877;;;","20/Jun/14 23:25;sirinath1978m@gmail.com;I think if you use just long vs Long it might opens up some more issues.;;;","21/Jun/14 01:22;paulk;I am specifically avoiding using {{long}} to ensure that I am covering just one issue. As a general rule for most open source projects, the likelihood and speed of fixes is inversely proportional to the complexity of the test case, so the simpler the better. Using {{long}} can be addressed subsequently (often best in a separate issue) with a view to working out whether it is also a problem when combining the two annotations or just one specifically.;;;","21/Jun/14 01:29;paulk;Some things which turning on static type checking debug mode reveals (which can be fixed easy enough with some casts etc. within the AST transform):
{noformat}
// [Static type checking] - Error in generated code [_result.timeStamp] - No such property: timeStamp for class: java.lang.Object
// [Static type checking] - Error in generated code [super.clone()] - Cannot assign value of type java.lang.Object to variable of type EventBase
// [Static type checking] - Error in generated code [timeStamp.clone()] - Cannot assign value of type java.lang.Object to variable of type java.lang.Long
{noformat}
but they still don't address the principal issue which is that CompileStatic doesn't like calling the protected super.clone().;;;","21/Jun/14 05:15;paulk;After altering the AST transform code to fix those initial errors it now gives:
{noformat}
[Static type checking] - Error in generated code [(java.lang.Cloneable) timeStamp] - Inconvertible types: cannot cast java.lang.Long to java.lang.Cloneable
{noformat}
And the generated code for the {{clone}} method is:
{code}
public java.lang.Object clone() throws java.lang.CloneNotSupportedException {
    Event _result = ((super.clone()) as Event)
       if ( timeStamp instanceof java.lang.Cloneable) {
          _result .timeStamp = (((( timeStamp ) as java.lang.Cloneable).clone()) as java.lang.Long)
    }
    return _result 
}
{code}
Doesn't seem like the {{instanceof}} guard is affecting the type checkers behavior.;;;","21/Jun/14 05:22;sirinath1978m@gmail.com;If something is not cloneable best is to mark it as an compile time error when using static compilation. Ideally use a mechanism outside Java cloning mechanism for speed and safety. (E.g. Inner object has the cloning logic wrong or is not clonable.);;;","23/Jun/14 08:59;paulk;Initial stab at a fix:
https://github.com/groovy/groovy-core/pull/458
more tests to come plus doco updates;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
.NoSuchFieldError: this$0 for member variable with Anonymous Class within Closure,GROOVY-6885,12817617,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,fgracely,fgracely,20/Jun/14 12:52,08/Jul/14 15:28,14/Jul/23 06:01,02/Jul/14 11:15,2.3.3,,,,,,,,,,,,,,,,,2.3.4,,,,groovy-jdk,,,,0,,,,,,,"In JavaFx, I create a TableCellFactory as a close that returns an anonymous instance of a TableCell. Within teh updateItem method of the TableCell implementation, I reference a member variable ""pm"" on the containing class and get the error: 
{noformat}
Exception in thread ""JavaFX Application Thread"" java.lang.NoSuchFieldError: this$0
{noformat}

Here's the relevant code:
{code}
// defined as a member variable of the class
Object pm

// invoked within a method setting up a table on the same class
    statusCol.setCellFactory({column ->
      return new TableCell<IWorkflowStepSubTask, SubTaskState>() {
        protected void updateItem(SubTaskState item, boolean empty)
        {
            // this line fails because it cannot access pm
            print pm.getClass().getSimpleName()
          }
      }
    })
{code}","Windows 7
JDK 1.8_05",blackdrag,candrews,fgracely,ngalarneau,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 02 11:15:29 UTC 2014,,,,,,,,,,"0|i2cqbb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jul/14 16:35;paulk;add code tags;;;","02/Jul/14 04:07;blackdrag;A example to reproduce the problem:
{code:Java}
interface X {
    def m()
}

class A {
    Object pm = ""pm""

    def bar(x) {x().m()}
    def foo() {
        bar { ->
            return new X() {
                def m() {
                    print pm.getClass().getSimpleName()
                }
            }
        }
    }
}
def a = new A()
a.foo()
{code}
fails with:
java.lang.NoSuchFieldError: this$0;;;","02/Jul/14 11:15;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closure in child class cannot access static method in parent class,GROOVY-6883,12811926,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,gillius,gillius,20/Jun/14 09:15,08/Jul/14 15:28,14/Jul/23 06:01,01/Jul/14 05:54,2.3.3,,,,,,,,,,,,,,,,,2.3.4,,,,,,,,0,,,,,,,"A regression affecting dynamic Groovy only (@CompileStatic code is not having this problem), a closure in a child class cannot call a static method in a parent class. This behavior was working at least as of 2.1.5.

Closures of a subclass can no longer access static methods of a super class in 2.3.3 dynamic Groovy, while they could in 2.1.5. Adding @CompileStatic to the ""fails"" method below is one possible workaround. Another workaround is to call the method explicitly as SuperClass.f.

{code}
class SuperClass {
        protected static f(String x) { x + "" is super"" }
}

class ChildClass extends SuperClass {
        public void doit() {
                println works()
                println fails()
        }

        private static def works() { f(""Groovy"") }
        private static def fails() { return {f(""Groovy"")}() }
}

new ChildClass().doit()
{code}

Result is ""groovy is super"" and then on the fails method:
groovy.lang.MissingMethodException: No signature of method: ChildClass$_fails_closure1.f() is applicable for argument types: (java.lang.String) values: [Groovy]
Possible solutions: is(java.lang.Object), is(java.lang.Object), any(), find(), any(), find()",,blackdrag,gillius2,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5261,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 01 05:54:04 UTC 2014,,,,,,,,,,"0|i2c07j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jul/14 02:52;melix;For reference, this commit introduced the regression:

{noformat}
~/DEV/PROJECTS/GITHUB/groovy-core (git::(no branch, bisect started on master)) $ git bisect good
9fd83210b9bc1bfbdd4b37d0029031052b18caa5 is the first bad commit
commit 9fd83210b9bc1bfbdd4b37d0029031052b18caa5
Author: Jochen Theodorou <blackdrag@gmx.org>
Date:   Thu Aug 15 16:42:44 2013 +0200

    GROOVY-5261: calls to static methods in closures must not be bound at compile time

:040000 040000 50e4acc163796ea9e0c42a10e6f2c916df54dc5a 3f78dd6373fe244c85f8c6c031c8038818c656ca M	src
{noformat}

https://github.com/groovy/groovy-core/commit/9fd83210b9bc1bfbdd4b37d0029031052b18caa5;;;","01/Jul/14 05:54;blackdrag;fixed (and thanks to Cedric, that found the actual problem);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC: AIC cannot resolve overridden method of outer class,GROOVY-6882,12817595,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,melix,melix,20/Jun/14 09:05,07/Dec/20 22:09,14/Jul/23 06:01,24/Nov/20 01:43,2.4.0-rc-1,,,,,,,,,,,,,,,,,2.5.14,3.0.7,4.0.0-alpha-2,,Static compilation,,,,0,,,,,,,"Originally reported on StackOverflow: http://stackoverflow.com/questions/24321109/is-threre-any-way-to-ues-override-method-in-anonymous-class-on-groovy-compilest

This fails with an ambiguous method error:

{code}
import groovy.transform.CompileStatic;
interface HelloWorld {
    public void greet();
}

class HelloWorldAnonymousClassesParents {
    public void hi() {
        println ""hi""
    }
}

@CompileStatic
public class HelloWorldAnonymousClasses extends HelloWorldAnonymousClassesParents {
    public void hi() {
        System.out.println(""hihi "");
    }
    public void sayHello() {
        HelloWorld spanishGreeting = new HelloWorld() {
            public void greet() {
                hi() //<- here [Static type checking] - Reference to method is ambiguous error
                System.out.println(""spanishGreeting"");
            }
        };
        spanishGreeting.greet();
        hi()
    }

}
def myApp = new HelloWorldAnonymousClasses();
myApp.sayHello();
{code}
",,emilles,melix,paulk,,,,,,,,,,,,,"eric-milles opened a new pull request #1428:
URL: https://github.com/apache/groovy/pull/1428


   First commit fixes `AbstractMap#put(K,V)` to have resolved generics just like `HashMap#put(K,V)`; `chooseBestMethod` rejects `HashMap#put(K,V)` but not `AbstractMap#put(K,V)` in current codebase.
   
   https://issues.apache.org/jira/browse/GROOVY-6882


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Nov/20 22:44;githubbot;600","asfgit closed pull request #1428:
URL: https://github.com/apache/groovy/pull/1428


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;23/Nov/20 22:38;githubbot;600","paulk-asert commented on pull request #1428:
URL: https://github.com/apache/groovy/pull/1428#issuecomment-732472526


   Merged, thanks.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;23/Nov/20 22:52;githubbot;600",,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 24 01:43:57 UTC 2020,,,,,,,,,,"0|i2cd9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Nov/20 16:37;emilles;{code:groovy}
class B {
  void m() {
    println 'B'
  }
}

@groovy.transform.TypeChecked
class C extends B {
  @Override
  void m() {
    println 'C'
  }

  void test() {
    def x = new Runnable() {
      @Override
      void run() {
        m() // Reference to method is ambiguous. Cannot choose between [void C#m(), void B#m()]
      }
    }
    x.run()
    m()
  }
}

new C().test()
{code}

Should print ""C"" twice.;;;","24/Nov/20 01:43;paulk;Proposed PR merged.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Setters are not properly generated for primitive variables with multiple capital letters in the name ,GROOVY-6876,12818493,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,sirinath1978m@gmail.com,sirinath1978m@gmail.com,20/Jun/14 05:54,08/Jul/14 15:28,14/Jul/23 06:01,03/Jul/14 08:52,,,,,,,,,,,,,,,,,,2.3.4,,,,,,,,0,,,,,,,"There seem to be a issue with setters generated for primitive variables with multiple capital letters in the name

E.g. See https://github.com/Susico/microTrader/blob/master/core/src/main/groovy/com/susico/event/Quote.groovy

Delete 
{code}
void setRankOrderingOrId(long rankOrderingOrId) {
      this.rankOrderingOrId = rankOrderingOrId < 0 ? -1 : rankOrderingOrId
   }
{code}
A setter is not generated for setRankOrderingOrId in some cases.",,guillaume,paulk,sirinath,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 02 19:10:20 UTC 2014,,,,,,,,,,"0|i2chj3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jun/14 06:15;sirinath1978m@gmail.com;Also there are instances where primitive types are inferred to as their boxed type.

E.g.
{noformat}
Execution failed for task ':disruptor:compileGroovy'. 
> Bad access to protected data in invokevirtual 
Exception Details: 
  Location: 
    com/susico/event/EventBase.clone()Ljava/lang/Object; @27: invokevirtual 
  Reason: 
    Type 'java/lang/Long' (current frame, stack[0]) is not assignable to 'com/susico/event/EventBase' 
  Current Frame: 
    bci: @27 
    flags: { } 
    locals: { 'com/susico/event/EventBase', 'java/lang/Object' } 
    stack: { 'java/lang/Long' } 
  Bytecode: 
    0000000: 2ab7 00dd 4c2b 572a b400 2fb8 004d c100 
    0000010: 0699 0018 2ab4 002f b800 4db6 00dd 4d2c 
    0000020: 012b 12de b800 e22c 572b b000 bf       
  Stackmap Table: 
    append_frame(@41,Object[#4]) 
    full_frame(@43,{},{Object[#65]}) 
{noformat}
I have posted the exception at:
http://groovy.329449.n5.nabble.com/Help-on-Internal-compiler-error-td5720138.html

Also see commits to which these correspond to at:
https://github.com/Susico/microTrader/commits/master
(b18021f9eee069fd1f12afd6d1f0ac35fb612ae3 to cfcad29cf916f9f5a788da2c22e1850d5f6a6c76);;;","02/Jul/14 19:07;paulk;Isolated example of the issue you are seeing:
{code}
@groovy.transform.CompileStatic class Foo {
    long bar
    def method() { setBar(-1L) }
}
{code}
Workarounds are:

* change the property type to {{Long}}
* cast, e.g. {{setBar((long)-1L)}}
* make a primitive constant, e.g. {{long MINUS_ONE = -1L}}

So the setters are being generated but with the primitive not wrapper type and inline constants are being converted to the wrapper type.
;;;","02/Jul/14 19:10;paulk;Also occurs for the other primitive types. For {{boolean}}, setBar(true) is OK but setBar(Boolean.TRUE) exhibits the same behavior.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inherit Constructors in Combination with Compile Static and Generic Parameters in the Parent Class Does not Work,GROOVY-6874,12812129,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,paulk,sirinath1978m@gmail.com,sirinath1978m@gmail.com,20/Jun/14 05:48,08/Jul/14 15:28,14/Jul/23 06:01,03/Jul/14 03:00,,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,Static compilation,,,,0,,,,,,,"Hi,

Inherit Constructors AST transform  in combination with Compile Static AST Transform on a base class with Generic Parameters gives an error.

E.g. 

https://github.com/Susico/microTrader/blob/master/Disruptor/src/main/groovy/com/susico/disruptor/events/publishers/BasePublisher.groovy

https://github.com/Susico/microTrader/blob/master/Disruptor/src/main/groovy/com/susico/disruptor/events/publishers/OrderPublisher.groovy

Suminda",,paulk,sirinath,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 03 03:00:19 UTC 2014,,,,,,,,,,"0|i2br6v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jun/14 01:56;sirinath1978m@gmail.com;E.g.
{code}
@CompileStatic
abstract class BasePublisher<T> {
   final RingBuffer<T> ringBuffer

   BasePublisher(RingBuffer<T> ringBuffer) {
      this.ringBuffer = ringBuffer
   }
}
{code}

and

{code}
@CompileStatic @InheritConstructors
class OrderPublisher extends BasePublisher<Order> {

   void OnOrder() {
      long sequence = ringBuffer.next()

      try {
         Order order = ringBuffer.<Order> get(sequence) // Error!!!
      } finally {
         ringBuffer.publish(sequence)
      }
   }
}
{code};;;","26/Jun/14 08:25;paulk;For your {{get}} call example with type hints, see:
https://jira.codehaus.org/browse/GROOVY-6757
But in any case, the generics are currently not carried over when inheriting the constructors. This AST transform was designed prior to @CS/TC but it would be nice to support this for on-going @CS/TC usage.;;;","02/Jul/14 04:07;paulk;First stab at a fix:
https://github.com/groovy/groovy-core/pull/468;;;","03/Jul/14 03:00;paulk;@InheritConstructors has been made @CS/@TC aware. This doesn't include yet supporting the type hints limitation mentioned in the earlier comments. Please create a new issue preferably with a nice self-contained example if you spot any further issues with @InheritConstructors. Thanks for raising the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Invalid compiler error: ""The current scope already contains a variable of the name xxx""",GROOVY-6873,12817615,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,pablo72,pablo72,19/Jun/14 13:13,08/Jul/14 15:28,14/Jul/23 06:01,22/Jun/14 08:30,2.3.3,,,,,,,,,,,,,,,,,2.3.4,,,,Compiler,,,,0,,,,,,,"The attached source reports the following invalid compiler errors 

{code}
/Users/pditommaso/workspace/groovy_2_3/src/main/groovy/Channel.groovy: 113: The current scope already contains a variable of the name folder
 @ line 113, column 13.
           def folder
               ^

/Users/pditommaso/workspace/groovy_2_3/src/main/groovy/Channel.groovy: 114: The current scope already contains a variable of the name pattern
 @ line 114, column 13.
           def pattern
               ^

2 errors
{code}

Removing the @Slf4j annotation the code is compiled successfully 

{code}
import java.nio.file.FileVisitOption
import java.nio.file.FileVisitResult
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.SimpleFileVisitor
import java.nio.file.attribute.BasicFileAttributes

import groovy.transform.PackageScope
import groovy.util.logging.Slf4j
import groovyx.gpars.dataflow.DataflowChannel
import groovyx.gpars.dataflow.DataflowQueue
/**
 * Channel factory object
 *
 * @author Paolo Di Tommaso <paolo.ditommaso@gmail.com>
 */
@Slf4j
class Channel {

    /**
     * Implement the logic for files matching
     *
     * @param syntax The ""syntax"" to match file names, either {@code regex} or {@code glob}
     * @param folder The parent folder
     * @param pattern The file name pattern
     * @param skipHidden Whenever skip the hidden files
     * @return A dataflow channel instance emitting the file matching the specified criteria
     */
    static private DataflowChannel<Path> pathImpl( String syntax, String folder, String pattern, Map options )  {
        assert syntax in ['regex','glob']

        // verify that the 'type' parameter has a valid value
        //CheckHelper.checkParamsMap( 'path', options, VALID_PATH_PARAMS )
        final type = options?.type ?: 'file'
        final walkOptions = options?.followLinks == false ? EnumSet.noneOf(FileVisitOption.class) : EnumSet.of(FileVisitOption.FOLLOW_LINKS)
        final int maxDepth = options?.maxDepth ? options.maxDepth as int : Integer.MAX_VALUE
        final includeHidden = options?.hidden as Boolean ?: pattern.startsWith('.')

        // now apply glob file search
        def path = folder as Path
        def rule = ""$syntax:${folder}${pattern}""
        def matcher = path.getFileSystem().getPathMatcher(rule)
        def channel = new DataflowQueue<Path>()
        boolean includeDir = type in ['dir','any']
        boolean includeFile = type in ['file','any']

        Thread.start {

            Files.walkFileTree(path, walkOptions, maxDepth, new SimpleFileVisitor<Path>() {

                @Override
                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException
                {
                    if (includeDir && matcher.matches(dir) && ( includeHidden || !Files.isHidden(dir) )) {
                        channel.bind(dir.toAbsolutePath())
                    }
                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attr) throws IOException {
                    if (includeFile && matcher.matches(file) && ( includeHidden || !Files.isHidden(file) ) && !Files.isDirectory(file)) {
                        channel.bind(file.toAbsolutePath())
                    }
                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
                    return FileVisitResult.CONTINUE;
                }
            })

        }

        return channel
    }

    @PackageScope
    static List<String> getFolderAndPattern( String filePattern ) {

        def scheme = null;
        int i = filePattern.indexOf('://')
        if( i != -1 ) {
            scheme = filePattern.substring(0, i+3)
            filePattern = filePattern.substring(i+3)
        }

        def folder
        def pattern
        int p = filePattern.indexOf('*')
        if( p != -1 ) {
            i = filePattern.substring(0,p).lastIndexOf('/')
        }
        else {
            i = filePattern.lastIndexOf('/')
        }

        if( i != -1 ) {
            folder = filePattern.substring(0,i+1)
            pattern = filePattern.substring(i+1)
        }
        else {
            folder = './'
            pattern = filePattern
        }

        if( scheme ) {
            folder = scheme + folder
        }

        return [ folder, pattern ]

    }


}
{code}


",,blackdrag,candrews,hubbitus,melix,paolodt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 22 08:01:40 UTC 2014,,,,,,,,,,"0|i2chbz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jun/14 13:52;blackdrag;This strongly suggest the variable scope of the method  before is not popped in VariableScopeVisitor;;;","22/Jun/14 07:40;melix;Reduced example:

{code}
@Grab(group='org.slf4j', module='slf4j-simple', version='1.6.1')
import groovy.util.logging.Slf4j

@Slf4j
class Channel {

    static private void someMethod(String folder)  {
      final includeHidden = false
       new Runnable() {

                @Override
                public void run() {
                    if (includeHidden) {
                    }
                }

            }
    }

    static void otherMethod() {
        def folder
    }


}
{code}
;;;","22/Jun/14 08:01;melix;I suspect this to be a regression caused by GROOVY-6373;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Running :show all command throws StackOverflowError,GROOVY-6871,12817628,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,arafalov,arafalov,18/Jun/14 02:37,23/Jul/22 21:05,14/Jul/23 06:01,04/Jul/22 04:12,2.3.2,2.4.0-beta-1,,,,,,,,,,,,,,,,4.0.4,,,,Groovysh,,,,0,StackOverflowError,,,,,,"{quote}
E:\Downloads\groovy-2.4.0-beta-1>bin\groovysh
Groovy Shell (2.4.0-beta-1, JVM: 1.7.0_25)
Type ':help' or ':h' for help.
-----------------------------------------------------------
groovy:000> :show all
No variables defined
No classes have been loaded
No custom imports have been defined
No preferences are set
===> [null, null, null, null]
groovy:000> :show all
Variables:
  _ = [null, null, null, null]
No classes have been loaded
No custom imports have been defined
No preferences are set
===> [[_:[null, null, null, null]], null, null, null]
groovy:000> :show all
Variables:
ERROR java.lang.StackOverflowError:
null
groovy:000> :show all
Variables:
ERROR java.lang.StackOverflowError:
null
groovy:000>
{quote}

Can also be triggered faster by starting a recording session.",Windows 7,arafalov,paulk,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 04 04:12:50 UTC 2022,,,,,,,,,,"0|i2c9pr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Feb/15 04:34;tkruse;Thank for the report. i can reproduce it. Will work on a fix now.;;;","22/Feb/15 08:02;tkruse;Fundamentally this is caused by the variable '_' (the last return value in the sell), eventually containing itself, and being formatted by InvokerHelper.

This can be reproduced with any variable:

groovy:000> d = [:]
===> [:]
groovy:000> d.put(1, [d])
===> null
groovy:000> d
null // or StackOverflowError displayed, depending on Groovy Version


While the InvokerHelper is capable of preventing cycles of length 1 (map containing itself as an immediate value), it is not able to handle cycles of greater lengths. Fixing the InvokerHelper should therefore solve this issue.

Asking on dev mailing list for how to proceed.;;;","04/Jul/22 04:12;paulk;We haven't progressed detecting printing mutually recursive structures yet. I implemented a workaround for this case in the meantime. It simply avoids including the '\_' value in the variables returned by {{:show all}} and substitutes a '\_' placeholder instead as shown here:

{noformat}
Groovy Shell (5.0.0-SNAPSHOT, JVM: 17.0.2)
Type ':help' or ':h' for help.
-------------------------------------------------------------------------------
groovy:000> :show all
No variables defined
No classes have been loaded
No custom imports have been defined
No preferences are set
===> [null, null, null, null]
groovy:000> :show all
Variables:
  _ = [null, null, null, null]
No classes have been loaded
No custom imports have been defined
No preferences are set
===> [[_:_], null, null, null]
groovy:000> :show all
Variables:
  _ = [[_:_], null, null, null]
No classes have been loaded
No custom imports have been defined
No preferences are set
===> [[_:_], null, null, null]
groovy:000> :show all
Variables:
  _ = [[_:_], null, null, null]
No classes have been loaded
No custom imports have been defined
No preferences are set
===> [[_:_], null, null, null]
groovy:000>
{noformat};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sortable should honor typical Java generics usage,GROOVY-6870,12817648,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,16/Jun/14 22:39,07/Apr/15 19:07,14/Jul/23 06:01,02/Jul/14 17:27,,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,,,,,0,,,,,,,{{@Sortable Person}} should implement {{Comparable<Person>}} not just {{Comparable}}. Possibly also for the generated comparators.,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 02 17:36:34 UTC 2014,,,,,,,,,,"0|i2cqrz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jul/14 17:36;paulk;So this class:
{code}
@groovy.transform.Sortable class Person {
  String first, last
}
{code}
will implement {{java.lang.Comparable<Person>}} and the {{compareTo}} method looks like:
{code}
public int compareTo(Person other) {
    if (this.is(other)) {
        return 0
    }
    java.lang.Integer value = 0
    value = this .first <=> other .first
    if ( value != 0) {
        return value 
    }
    value = this .last <=> other .last
    if ( value != 0) {
        return value 
    }
    return 0
}
{code}
And similarly, the generated comparators use generics, e.g. the generated first name comparator implements {{Comparator<Person>}} with a {{compare}} method like:
{code}
public int compare(Person arg0, Person arg1) {
    if ( arg0 == arg1 ) {
        return 0
    }
    if ( arg0 != null && arg1 == null) {
        return -1
    }
    if ( arg0 == null && arg1 != null) {
        return 1
    }
    return arg0 .first <=> arg1 .first
}
{code}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot use @CompileStatic and @Sortable together,GROOVY-6866,12817645,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ysb33r,ysb33r,13/Jun/14 11:17,08/Jul/14 15:28,14/Jul/23 06:01,02/Jul/14 17:27,2.3.0,2.3.3,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,,,,,0,,,,,,,"Without @CompileStatic this compiles,
{code}
import groovy.transform.*
import java.time.LocalDateTime

//@CompileStatic
@TupleConstructor
@EqualsAndHashCode
@ToString
@Sortable(includes = ['completed'])
class DeliveryBucket {
    LocalDate completed
    Long count
}
{code}

With @CompileStatic enabled, it fails with 'Access to java.lang.Object#completed is forbidden'",JDK8,paulk,ysb33r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 02 17:27:31 UTC 2014,,,,,,,,,,"0|i2c6zr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jun/14 17:11;paulk;add code tags;;;","14/Jun/14 00:28;paulk;See potential solution (and discussion point) here:
https://github.com/groovy/groovy-core/pull/445
;;;","02/Jul/14 17:27;paulk;Should be fixed as part of GROOVY-6870;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Traits dont allow $ in identifiers where normal classes do,GROOVY-6862,12817415,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,oc,oc,11/Jun/14 15:04,01/Feb/17 23:19,14/Jul/23 06:01,25/Nov/16 12:13,2.3.0,2.4.3,,,,,,,,,,,,,,,,2.4.8,,,,,,,,1,traits,,,,,,"looks like traits are stricter than the ""normal"" groovy when an identifier happens to contain the dollar sign:

{code}
252 /tmp> <q.groovy
trait Test {
 static foo_ok() { println 'trait non-$ OK' }
 static foo$oops() { println 'trait $ OK' }
}
class Foo implements Test {
 static foo$ok() { println 'class $ OK' }
}
Foo.foo$ok()
Foo.foo_ok()
Foo.foo$oops()
253 /tmp> groovy q
class $ OK
trait non-$ OK
Caught: groovy.lang.MissingMethodException: No signature of method: static Foo.foo$oops() is applicable for argument types: () values: []
Possible solutions: foo$ok(), foo_ok()
...
{code}",,blackdrag,githubbot,keegan,maconic,melix,oc,pascalschumacher,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7539,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 25 12:13:29 UTC 2016,,,,,,,,,,"0|i2csy7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"04/Aug/15 15:02;maconic;Any news on this one? 
Since this is really a blocker for us, we will have to change many method names if this is not getting fixed. (We are using the $ sign for reflection magic);;;","04/Aug/15 18:17;pascalschumacher;Hi Gyula, 

I assigned the issue to Cédric, but as he is on vacation for the next few weeks I guess we have to wait till then for his opinion.

Sorry,
Pascal;;;","05/Aug/15 04:35;blackdrag;was this working in an earlier version for traits?;;;","05/Aug/15 21:57;pascalschumacher;As far as I know traits did never allow $.;;;","13/Sep/15 09:50;melix;Correct, traits never allowed $ in names. I will have to see if a simple fix is possible, but might take some time.;;;","22/Sep/15 12:53;maconic;Any news from your side? I am afraid we will have to change lots of code if this is not resolved :(

THX!
;;;","22/Sep/15 12:56;melix;No update. I'd like to understand why you would have to change code, since dollar sign was never supported in traits. ;;;","23/Sep/15 08:53;maconic;We want to refactor classes to use traits and those have $ signs :(;;;","23/Nov/16 22:39;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/464

    GROOVY-6862: Traits dont allow $ in identifiers where normal classes do

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy6862

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/464.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #464
    
----
commit 54f4fef91cee9c2be3d0c7f3c88f2246fe86c2f2
Author: paulk <paulk@asert.com.au>
Date:   2016-11-23T22:38:12Z

    GROOVY-6862: Traits dont allow $ in identifiers where normal classes do

----
;;;","25/Nov/16 12:11;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/464
;;;","25/Nov/16 12:13;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper.parse with byte array throws stack overflow exception,GROOVY-6857,12817336,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,wselwood,wselwood,10/Jun/14 05:33,05/Apr/15 14:44,14/Jul/23 06:01,11/Jun/14 02:24,2.3.2,,,,,,,,,,,,,,,,,2.3.3,,,,JSON,,,,0,,,,,,,"A very simple example main shown below. Passing the same string into parseText works, parse with a byte array does not.

The problem is line 111 of BaseJsonParser is recursively calling its self. rather than converting the byte array to a char array and then calling the parse method in JsonParserCharArray as all the other parse methods call.

{code}
 public static void main(String[] args) {
      String input = ""{\""foo\"":\""bar\"", \""squiggles\"":[{\""bob\"":\""alice\""}]}"";
      JsonSlurper slurper = new JsonSlurper();
      
      try {
         System.out.println(""string parsing"");
         slurper.parseText(input);
         System.out.println(""byte parsing"");
         slurper.parse(input.getBytes(""utf-8""));
         System.out.println(""done"");
      } catch (Exception e) {
         e.printStackTrace();
      }
   }
{code}

Will send pull request when I've got it building and tested.",,wselwood,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Tue Jun 10 06:05:19 UTC 2014,,,,,,,,,,"0|i2cpvz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"10/Jun/14 06:05;wselwood;Pull request created:

https://github.com/groovy/groovy-core/pull/440;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Generics and static type checking: ""Cannot return value of type W on method returning type W""",GROOVY-6856,12817635,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,davide.cavestro,davide.cavestro,10/Jun/14 04:09,11/Jun/14 14:25,14/Jul/23 06:01,11/Jun/14 04:09,2.3.2,,,,,,,,,,,,,,,,,2.3.3,,,,Compiler,,,,0,,,,,,,"As discussed into the [mailing list|http://groovy.329449.n5.nabble.com/Static-type-checking-Cannot-return-value-of-type-W-on-method-returning-type-W-td5719954.html#a5719959] the following snippet makes the groovy compiler complain for {quote}\[Static type checking\] - Cannot return value of type W on method returning type W{quote}
even if it is valid groovy code

{code:title=snippet.groovy}
import groovy.transform.TypeChecked

class Wrapper {}

@TypeChecked
class Foo<W extends Wrapper> {
    W doIt (List<W> l) {
        l.iterator().next()//Static type check failure
    }
}

//new Foo().doIt([])//uncomment this line to run as a script on groovyConsole
{code}",OS: Debian GNU/Linux 7 (32 bit),blackdrag,davide.cavestro,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 11 04:09:42 UTC 2014,,,,,,,,,,"0|i2br4n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jun/14 04:09;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy annotations that support closures don't get stubs generated correctly,GROOVY-6855,12817340,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,rvowles,rvowles,08/Jun/14 20:12,08/Jul/14 15:28,14/Jul/23 06:01,13/Jun/14 03:52,,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,Stub generator / Joint compiler,,,,0,,,,,,,"This:
{code}
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Get {
	Class value() default {return true}
}
{code}

Generates:

{code}
@java.lang.annotation.Target(value=java.lang.annotation.ElementType.TYPE) @java.lang.annotation.Retention(value=java.lang.annotation.RetentionPolicy.RUNTIME) public @interface Get
 {
 java.lang.Class value() default { -> ... }.class;
}
{code}
",,keeganwitt,paulk,rvowles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 13 04:45:18 UTC 2014,,,,,,,,,,"0|i2crkv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jun/14 00:36;keegan;Thanks for reporting this.  I'm not sure why yet, but when I give Groovy a target bytecode when generating stubs, this problem manifests.  The fix seems to be to just not do that.  I've checked in that change and will release this week.;;;","09/Jun/14 01:29;rvowles;Thanks for the quick update :-) Really appreciate the effort you are putting into this!;;;","09/Jun/14 12:15;keegan;My pleasure.  I'm continuing to research exactly what is going on here.  It might be that my initial fix isn't always the right thing to do.  Something appears to have changed in 2.1.2.  Versions previous to this work fine.  If using 2.1.1 is an option for you, you might consider using it until I get this sorted out.  I'm still shooting for this week for a fix though.;;;","09/Jun/14 14:37;keegan;Actually, ignore last comment.  It compiles fine, but the stub is still wrong with older version.;;;","09/Jun/14 20:22;keegan;OK.  I finally got Gradle to keep the stubs and have confirmed that this issue happens there as well.  I'll roll back out my change since this is not a GMaven issue, but a Groovy issue.  Which is somewhat a relief as I was really banging my head about what could be different.  I've seen examples of closures being used in annotations, but not in conjunction with default.  It looks like that doesn't work.  I'm not sure whether that's by design or a mistake.;;;","09/Jun/14 21:00;paulk;add code tags;;;","09/Jun/14 21:17;rvowles;I feel I just got teleported :-) Thanks guys!;;;","13/Jun/14 03:52;paulk;Should be fixed. Thanks for spotting the issue.;;;","13/Jun/14 04:45;paulk;The stub now has {{Closure.class}} as the constant for {{Class}} members which have closures as their default value. Obviously, the stub is just an interim artifact so the real closure will still be available in the final class file from the Groovy artifact.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.json.JsonOutput throws ArrayIndexOutOfBoundsException when serializing some Strings that contain a high percentage of non-ASCII characters.,GROOVY-6852,12811400,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,lukasloehrer,lukasloehrer,06/Jun/14 13:32,26/Jul/14 01:44,14/Jul/23 06:01,25/Jul/14 03:29,2.3.2,2.4.0-beta-1,,,,,,,,,,,,,,,,2.3.5,2.4.0-beta-2,,,command line processing,JSON,,,2,,,,,,,"Since Groovy 2.3.0, groovy.json.JsonOutput sometimes throws
java.lang.ArrayIndexOutOfBoundsException when serializing Strings that
contain a large percentage of non-ASCII characters. The problem seems
to occur because the method
groovy.json.internal.CharBuf.doAddJsonEscapedString does not always
grow the output buffer appropriately. At the beginning, the method
ensures that there is at least 2*<input_length>+2 characters of free
space in the output buffer assuming optimistically that the majority
of characters will not have to be escaped. Therefore, it is necessary
to check if there is enough free space in the buffer before adding
each character to the buffer. There appear to be the following
problems in the current implementation:

* The code currently only checks the free space in the buffer before adding json-control characters and other special characters that must be escaped. The check should also be performed before adding ""normal"" characters. 
*  I think there is an off-by-one error in the  check for available space that is done before adding a character that must be escaped. The check ensures only for 5 available characters of free space, instead of 6.
* It is necessary to make sure there is always space for the closing double-quote character at the end.

The following Example Groovy shell session demonstrates the cases:
{noformat}
Groovy Shell (2.3.2, JVM: 1.7.0_60)
Type ':help' or ':h' for help.
-------------------------------------------------------------------------------
// Adding a ""normal"" character fails
groovy:000> groovy.json.JsonOutput.toJson('12ÃÂ¶ÃÂ¶ÃÂ¶ÃÂ¶ÃÂ¶12')
ERROR java.lang.ArrayIndexOutOfBoundsException:
33
        at groovy.json.internal.CharBuf.doAddJsonEscapedString (CharBuf.java:525)
        at groovy.json.internal.CharBuf.addJsonEscapedString (CharBuf.java:394)
        at groovy.json.internal.CharBuf.addJsonEscapedString (CharBuf.java:357)
        at groovy.json.JsonOutput.writeCharSequence (JsonOutput.java:309)
        at groovy.json.JsonOutput.toJson (JsonOutput.java:97)
        at groovy.json.JsonOutput$toJson.call (Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall (CallSiteArray.java:45)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call (AbstractCallSite.java:108)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call (AbstractCallSite.java:116)

// Exception when writing a ""special"" character to the buffer
groovy:000> groovy.json.JsonOutput.toJson('ÃÂ¶ÃÂ¶')
ERROR java.lang.ArrayIndexOutOfBoundsException:
12
        at groovy.json.internal.CharBuf.doAddJsonEscapedString (CharBuf.java:505)
        at groovy.json.internal.CharBuf.addJsonEscapedString (CharBuf.java:394)
        at groovy.json.internal.CharBuf.addJsonEscapedString (CharBuf.java:357)
        at groovy.json.JsonOutput.writeCharSequence (JsonOutput.java:309)
        at groovy.json.JsonOutput.toJson (JsonOutput.java:97)
...

// In the following example, adding the final double-quote character fails:
groovy:000> groovy.json.JsonOutput.toJson('12ÃÂ¶ÃÂ¶ÃÂ¶')
ERROR java.lang.ArrayIndexOutOfBoundsException:
21
        at groovy.json.internal.CharBuf.doAddJsonEscapedString (CharBuf.java:533)
        at groovy.json.internal.CharBuf.addJsonEscapedString (CharBuf.java:394)
        at groovy.json.internal.CharBuf.addJsonEscapedString (CharBuf.java:357)
        at groovy.json.JsonOutput.writeCharSequence (JsonOutput.java:309)
        at groovy.json.JsonOutput.toJson (JsonOutput.java:97)
...
{noformat}

",JDK 1.7.0_60,guillaume,henrik242,kha,lukasloehrer,richardhightower,samp,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 25 14:37:13 UTC 2014,,,,,,,,,,"0|i2ciif:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jun/14 14:14;lukasloehrer;The special characters in the examples got mangled. Here are the examples again:

// Adding a ""normal"" character fails
groovy:000> groovy.json.JsonOutput.toJson('12ööööö12')
// Exception when writing a ""special"" character to the buffer
groovy:000> groovy.json.JsonOutput.toJson('öö')
// In the following example, adding the final double-quote character fails:
groovy:000> groovy.json.JsonOutput.toJson('12ööö')
;;;","16/Jun/14 05:13;henrik242;[deleted comment, as it wasn't relevant];;;","17/Jul/14 16:32;samp;Are there any workarounds available for this?;;;","18/Jul/14 00:45;henrik242;My current workaround is to use Gson. You'll need to add a Gstring serializer, though.

I tried Boon as well, without success: https://github.com/RichardHightower/boon/issues/197;;;","18/Jul/14 00:48;henrik242;And another workaround is to backport Groovy 1.8's json libraries. Please tell if you want me to share it...;;;","18/Jul/14 07:01;kha;I has nearly the same issue with the CharBuffer class.

Here here my case: https://jira.codehaus.org/browse/GROOVY-6937

I fixed it by copying this class on my project classpath and redefining the method hasAnyJSONControlOrUnicodeChars to remove the condition c > 126.

This way, all unicode characters are written as is with the doAddJsonEscapedString method. The drawback is that if you use this you must make sure you also read and write using UTF-8 and put the good charset in teh content type of the response.

{code}
private static boolean hasAnyJSONControlOrUnicodeChars(int c) {
        /* Anything less than space is a control character. */
        if (c < 30) {
            return true;
        /* 34 is double quote. */
        } else if (c == 34) {
            return true;
        } else if (c == 92) {
            return true;
        } else if (c < ' ') {
            return true;
        }

        return false;
    }
{code};;;","21/Jul/14 15:02;richardhightower;I'll look into Boon #197.

https://github.com/RichardHightower/boon/issues/197

As well as this.

I am on vacation now. I was underwater at work for a while. I see some sunshine in my schedule.

I tried hasAnyJSONControlOrUnicodeChars with getting rid of c > 126, and it seemed to clear up the other issues. I solved this particular issue differently with Boon but perhaps with the c > 126 gone.. most of this goes away.

;;;","24/Jul/14 10:02;guillaume;Removing c > 126 yields at least one test failure:
{noformat}
groovy.json.CharBufTest > testUnicodeAndControl FAILED
    Assertion failed: 

    assert str.equals( ""\""\\u00ff\"""")
           |   |
           ""ÿ"" false
        at org.codehaus.groovy.runtime.InvokerHelper.assertFailed(InvokerHelper.java:398)
        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.assertFailed(ScriptBytecodeAdapter.java:646)
        at groovy.json.CharBufTest.testUnicodeAndControl(CharBufTest.groovy:15)

256 tests completed, 1 failed
{noformat};;;","25/Jul/14 14:37;kha;I think this assertion is not relevant anymore if we remove c > 126 since there is no more escaping for unicode chars.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Tenary operator with @CompileStatic in constructor results in ArrayIndexOutOfBoundsException,GROOVY-6851,12813435,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,06/Jun/14 04:45,25/May/21 19:45,14/Jul/23 06:01,10/Jun/14 12:00,2.3.2,,,,,,,,,,,,,,,,,2.2.3,2.3.3,,,,,,,0,,,,,,,"Example:

{code}
import groovy.transform.CompileStatic

@CompileStatic
class GrailsHomeWorkspaceReader {
    GrailsHomeWorkspaceReader(String grailsHome = System.getProperty('grails.home') ?: System.getenv('GRAILS_HOME')) {
    }
}
{code}

Exception:

{code}
java.lang.ArrayIndexOutOfBoundsException: size==0
	at org.codehaus.groovy.classgen.asm.OperandStack.getTopOperand(OperandStack.java:670)
	at org.codehaus.groovy.classgen.asm.OperandStack.dup(OperandStack.java:174)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateElvisOperatorExpression(BinaryExpressionHelper.java:793)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateTernary(BinaryExpressionHelper.java:864)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitTernaryExpression(AsmClassGenerator.java:572)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitShortTernaryExpression(CodeVisitorSupport.java:154)
	
{code}",,graemerocher,guillaume,melix,,,,,,,,,,,,,"eric-milles opened a new pull request #1582:
URL: https://github.com/apache/groovy/pull/1582


   Before taking on GROOVY-10094, I wanted to take a step back and tidy up a loose end from GROOVY-6851 / GROOVY-9151.
   
   https://issues.apache.org/jira/browse/GROOVY-10104
   https://issues.apache.org/jira/browse/GROOVY-10094
   https://issues.apache.org/jira/browse/GROOVY-9151
   https://issues.apache.org/jira/browse/GROOVY-6851


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;24/May/21 00:20;githubbot;600","eric-milles merged pull request #1582:
URL: https://github.com/apache/groovy/pull/1582


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;25/May/21 19:45;githubbot;600",,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 10 11:30:22 UTC 2014,,,,,,,,,,"0|i2cgkv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jun/14 04:49;melix;Most likely a duplicate of GROOVY-6342.;;;","06/Jun/14 04:54;guillaume;Reproducible in 2.3.2.;;;","10/Jun/14 11:30;melix;Actually more complicated than expected: simplifying the example to:

{code}
@CompileStatic
class GrailsHomeWorkspaceReader {
    GrailsHomeWorkspaceReader(String grailsHome = System.getProperty('grails.home')) {
    }
}
{code}

fails with:

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during class generation: Internal compiler error while compiling TestScripttestShouldNotThrowNPEIfElvisOperatorIsUsedInDefaultArgumentValue0.groovy
Constructor: null
Line 3, expecting casting to java.lang.String but operand stack is empty
{noformat}

which seems to indicate that default value in a constructor is not compiled properly.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error in @CompileStatic when method in both Interface and Superclass,GROOVY-6849,12813428,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ngalarneau,ngalarneau,05/Jun/14 07:34,17/Aug/22 18:50,14/Jul/23 06:01,23/Jul/14 11:09,2.3.2,,,,,,,,,,,,,,,,,2.3.5,,,,Static compilation,,,,0,regression,,,,,,"This seems related to GROOVY-6751.

This file:
{code}
import javafx.collections.FXCollections
import groovy.transform.CompileStatic

@CompileStatic
class DupMethod
{
  javafx.collections.ObservableList<String> tags = FXCollections.observableArrayList(""first"")

  void foo()
  {
    tags.addAll(""foo"")
  }
}
{code}
gives the compilation error:
$ groovyc dupmethod.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
dupmethod.groovy: 11: [Static type checking] - Reference to method is ambiguous. Cannot choose between [boolean java.util.Collection <T>#addAll(T[]), boolean javafx.collections.ObservableList <E extends java.lang.Object>#addAll(E[])]
 @ line 11, column 5.
       tags.addAll(""foo"")
       ^

1 error

I don't get this error when compiling with Groovy version 2.2.2.",,ngalarneau,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8788,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-06-05 07:34:02.0,,,,,,,,,,"0|i2c4t3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DGM.retainAll() has wrong generic type on Closure condition,GROOVY-6846,12817594,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,timkingman,timkingman,04/Jun/14 10:23,11/Jun/14 14:25,14/Jul/23 06:01,04/Jun/14 18:03,2.3.2,,,,,,,,,,,,,,,,,2.3.3,,,,groovy-jdk,,,,0,,,,,,,"DGM's retainAll() has this signature:
{code}
public static <T> boolean retainAll(Collection<T> self, @ClosureParams(FirstParam.FirstGenericType.class) Closure<T> condition)
{code}
The condition closure is expected to return a boolean or a boolean-ish value, but not the same type as the Collection.

removeAll() has the correct signature that doesn't specify a return type on the closure:
{code}
public static <T> boolean removeAll(Collection<T> self, @ClosureParams(FirstParam.FirstGenericType.class) Closure condition)
{code}

retainAll() still works, but IDEA's syntax highlighting complains when passing in a Closure<Boolean> to retainAll() on a List of other objects.",,paulk,timkingman,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 04 18:03:37 UTC 2014,,,,,,,,,,"0|i2c7jj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Jun/14 18:03;paulk;Thanks for spotting that. I think a cut-n-paste glitch when introducing @ClosureParams. Should be fixed now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot create AIC inside closure body,GROOVY-6842,12817301,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,ldaley,ldaley,01/Jun/14 05:40,28/Dec/14 04:21,14/Jul/23 06:01,28/Dec/14 04:21,2.3.2,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Static compilation,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
class Container {
  static void main(String... args) {
    [].each {
      new Object() {}
    }
  }
}
{code}

Yields: 

{code}
[Static type checking] - Cannot call Container$1#<init>(groovy.lang.Closure) with arguments [Container] 
 at line: 7, column: 11
{code}",,ldaley,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 04:21:05 UTC 2014,,,,,,,,,,"0|i2bt7r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Dec/14 04:21;pschumacher;Thanks for reporting. Your example runs with groovy 2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BUG! exception in phase 'semantic analysis',GROOVY-6841,12818524,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pablo72,pablo72,31/May/14 17:08,11/Jun/14 14:25,14/Jul/23 06:01,02/Jun/14 04:39,2.3.0,2.3.2,,,,,,,,,,,,,,,,2.3.3,,,,Compiler,,,,0,,,,,,,"The following code raises a compiler BUG exception 

{code}
@groovy.transform.InheritConstructors
class Tuple<E> extends ArrayList<E> {

   public ListIterator<E> listIterator(final int index) {
        return new ListIterator<E>() {
            private final ListIterator<? extends E> i = Tuple.super.listIterator(index)

            public boolean hasNext()     {return i.hasNext();}
            public E next()              {return i.next();}
            public boolean hasPrevious() {return i.hasPrevious();}
            public E previous()          {return i.previous();}
            public int nextIndex()       {return i.nextIndex();}
            public int previousIndex()   {return i.previousIndex();}

            public void remove() {
                throw new UnsupportedOperationException();
            }
            public void set(E e) {
                throw new UnsupportedOperationException();
            }
            public void add(E e) {
                throw new UnsupportedOperationException();
            }
        };
    }
}
{code}


The critical line is 

{{private final ListIterator<? extends E> i = Tuple.super.listIterator(index)}}
",,paolodt,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 01 01:22:21 UTC 2014,,,,,,,,,,"0|i2cqrb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jun/14 01:22;paulk;Seems OK in 2.2.2.

Stacktrace:
{noformat}
Exception thrown
BUG! exception in phase 'semantic analysis' in source unit 'ConsoleScript5' null
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:927)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:585)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:534)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:286)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:259)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:674)
	at groovy.lang.GroovyShell.run(GroovyShell.java:501)
	at groovy.lang.GroovyShell.run(GroovyShell.java:481)
	at groovy.lang.GroovyShell.run(GroovyShell.java:164)
	at groovy.lang.GroovyShell$run$0.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:977)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure.call(Closure.java:417)
	at groovy.lang.Closure.run(Closure.java:504)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.control.ResolveVisitor.checkThisAndSuperAsPropertyAccess(ResolveVisitor.java:821)
	at org.codehaus.groovy.control.ResolveVisitor.transformPropertyExpression(ResolveVisitor.java:791)
	at org.codehaus.groovy.control.ResolveVisitor.transform(ResolveVisitor.java:637)
	at org.codehaus.groovy.control.ResolveVisitor.transformMethodCallExpression(ResolveVisitor.java:1004)
	at org.codehaus.groovy.control.ResolveVisitor.transform(ResolveVisitor.java:643)
	at org.codehaus.groovy.ast.ClassCodeExpressionTransformer.visitField(ClassCodeExpressionTransformer.java:65)
	at org.codehaus.groovy.control.ResolveVisitor.visitField(ResolveVisitor.java:179)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.control.ResolveVisitor.visitClass(ResolveVisitor.java:1202)
	at org.codehaus.groovy.control.ResolveVisitor.startResolving(ResolveVisitor.java:142)
	at org.codehaus.groovy.control.CompilationUnit$11.call(CompilationUnit.java:643)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:923)
	... 26 more
{noformat}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
inconsistency in JsonSlurper return type,GROOVY-6840,12813427,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,jechlin,jechlin,31/May/14 15:53,08/Jul/14 15:28,14/Jul/23 06:01,16/Jun/14 03:09,2.3.1,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,JSON,,,,0,,,,,,,"{code}
new JsonSlurper().parseText(""[]"") == Collections.EMPTY_LIST
new JsonSlurper().parseText(""[1]"") instanceof ArrayList
{code}

Specifically, I parse some JSON to an object, then I add stuff to it, then serialise back to JSON. Since upgrading from 2.2.1 to 2.3.1 I've been tripped up by (what I assume is a change in) this behaviour.

Why would it not return an empty ArrayList, instead of an immutable empty set, so the calling code does not need to think about whether it's empty or not?

Guillaume Laforge said:
{quote}
The behavior isn't really specified, but it makes sense to be able to update the returned data structure for later serialization or other purposes, so I think it's worth using an empty array list instead of the empty collection
{quote}
",,guillaume,jechlin,kaendfinger,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 16 03:09:07 UTC 2014,,,,,,,,,,"0|i2cn8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jun/14 19:31;kaendfinger;See https://github.com/groovy/groovy-core/pull/434 for fix;;;","16/Jun/14 03:09;guillaume;Thanks Kenneth for the fix!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
String[] + String[] gives Object[],GROOVY-6837,12818312,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,dmovchinn,dmovchinn,29/May/14 08:06,03/Feb/22 22:35,14/Jul/23 06:01,14/Jan/22 02:38,2.3.1,,,,,,,,,,,,,,,,,4.0.0,,,,groovy-runtime,,,,1,breaking,,,,,,"{code:java}
def a1 = [""a"", ""b""] as String[], a2 = [""c"", ""d""] as String[];
def concatenated = a1 + a2;
java.nio.file.Paths.get(""parent"", concatenated)
{code}
==>
{noformat}
groovy.lang.MissingMethodException: No signature of method: static java.nio.file.Paths.get() is applicable for argument types: (java.lang.String, [Ljava.lang.Object;) values: [parent, [a, b, c, d]]
Possible solutions: get(java.lang.String, [Ljava.lang.String;), get(java.net.URI), grep(), getAt(java.lang.String), wait(), any()
	at groovy.lang.MetaClassImpl.invokeStaticMissingMethod(MetaClassImpl.java:1373)
	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1359)
	at org.codehaus.groovy.runtime.callsite.StaticMetaClassSite.call(StaticMetaClassSite.java:50)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
	at ideaGroovyConsole.run(ideaGroovyConsole.groovy:4)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:258)
	at groovy.lang.GroovyShell.run(GroovyShell.java:502)
	at groovy.lang.GroovyShell.run(GroovyShell.java:481)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:166)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:68)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
	at console.run(console.txt:25)
{noformat}",,dmovchinn,emilles,melix,paulk,,,,,,,,,,,,"eric-milles opened a new pull request #1672:
URL: https://github.com/apache/groovy/pull/1672


   Before I tackle the harder issues of `plus` and `minus`, I looked over all `T[]` returning methods in `DefaultGroovyMethods` and made minor changes to remove unchecked warnings and return the `self` array type for `reverse`.
   
   https://issues.apache.org/jira/browse/GROOVY-6837


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;06/Jan/22 20:39;githubbot;600","eric-milles merged pull request #1672:
URL: https://github.com/apache/groovy/pull/1672


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jan/22 19:00;githubbot;600","asfgit merged pull request #1675:
URL: https://github.com/apache/groovy/pull/1675


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;14/Jan/22 02:01;githubbot;600",,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/Jan/22 16:43;emilles;image-2022-01-12-10-43-14-275.png;https://issues.apache.org/jira/secure/attachment/13038687/image-2022-01-12-10-43-14-275.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 14 02:38:11 UTC 2022,,,,,,,,,,"0|i2brin:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"29/May/14 16:10;paulk;Looking at the DGM#plus code, it always returns Object[] from toArray() despite the wishful thinking cast:
{code}
public static <T> T[] plus(T[] left, T[] right) {
    return (T[]) plus(toList(left), toList(right)).toArray();
}
{code}
We could use {{Array.newInstance()}} to fix the returned type but we'd need to calculate the least upper bound types for the left and right component types (or give preference to say the left component type and potentially have a non-commutative operator). We do calculate LUB on class nodes in the static compiler but pretty sure we don't currently have that exposed as a runtime method (and we couldn't expose as rich a version as we use in the static compiler in any case).

In the meantime, you'll have to use 'as String[]' as the workaround.;;;","29/May/14 17:44;paulk;We could possibly change {{plus}} to something like this:
{code}
    public static <T> T[] plus(T[] left, T[] right) {
        return plus(toList(left), toList(right)).toArray((T[])Array.newInstance(poormansLUB(left.getClass().getComponentType(), right.getClass().getComponentType()), left.length + right.length));
    }

    private static Class poormansLUB(Class<?> leftType, Class<?> rightType) {
        if (leftType.equals(rightType)) return leftType;
        if (leftType.isAssignableFrom(rightType)) return leftType;
        if (rightType.isAssignableFrom(leftType)) return rightType;
        Comparator<Class<?>> comparator = new Comparator<Class<?>>() {
            public int compare(Class<?> o1, Class<?> o2) {
                return o1.getSuperclass().equals(o2) ? -1 : o2.getSuperclass().equals(o1) ? 1 : 0;
            }
        };
        Collection<Class<?>> commonSupers = intersect(superClasses(leftType), superClasses(rightType));
        if (!commonSupers.isEmpty()) {
            return first(sort((Iterable<Class<?>>)commonSupers, false, comparator));
        }
        Collection<Class<?>> commonInterfaces = intersect(Arrays.asList(leftType.getInterfaces()), Arrays.asList(rightType.getInterfaces()));
        if (!commonInterfaces.isEmpty()) {
            return first(sort((Iterable<Class<?>>)commonInterfaces, false, comparator));
        }
        return Object.class;
    }

    private static List<Class<?>> superClasses(Class<?> clazz) {
        List<Class<?>> results = new ArrayList<Class<?>>();
        Class<?> next = clazz.getSuperclass();
        while (!Object.class.equals(next)) {
            results.add(next);
            next = next.getSuperclass();
        }
        return results;
    }
{code}
;;;","30/May/14 10:26;melix;I expect such a change to have a significant impact on performance.;;;","30/May/14 14:58;paulk;There will be a performance hit. Array.newInstance cops a reflection hit. We could put in a check to avoid that for the common Object[] case. Searching through super classes or interfaces would also slow things down but would be fairly rare I would have thought. And I would have thought usage of array plus was much less common than List plus.

I guess it boils down to what we think is correct behavior. It seems to me we should either change the signature of the DGM method to return Object[] or do something like above.;;;","06/Jan/22 18:34;emilles;Currently, ""Class[] types = []; types += String"" creates the Object[] in plus, then a collection followed by the proper Class[] in DefaultTypeTransformation#castToType, so I'm not so sure it would be a performance hit to create the proper array type up front.;;;","06/Jan/22 18:37;emilles;Also, {{DefaultGroovyMethods#plus(T[], ...)}} is not usable from Java (or other JVM language) since it does not return the expected type (except for T is Object).;;;","12/Jan/22 12:44;paulk;I think the LUB idea is too fancy in this scenario. Our current behavior is as follows:
{code}
import static groovy.test.GroovyAssert.shouldFail

String[] words = ['ant', 'bee']
Integer[] nums = [5, 10]

def result = words + nums           // (1)
assert result.class == Object[]
assert result*.class == [String, String, Integer, Integer] // ['ant', 'bee', 5, 10]
words = words + nums                 // (2)
assert words.class == String[]
assert words*.class == [String, String, String, String] // ['ant', 'bee', '5', '10'] due to coercion

result = nums + ['cat', 'dog']         // (3)
assert result.class == Object[]
assert result*.class == [Integer, Integer, String, String]
shouldFail(ClassCastException) {
    nums = nums + ['cat', 'dog']     // (4) no auto coercion
}
{code}
I don't think it is easy to justify why (1) and (2) provide different behavior given the RHS is the same in both. Ditto for (3) and (4). I think the behavior offered in (2) and (4) should be what {{plus}} always provides.

I think we can provide an additional (set of) method(s) named {{addAll}} (or {{merge}} or {{union}} or similar) that returns {{Object[]}} and provides the current behavior shown in (1) and (3). One could imagine overloaded variants even allowing the array return type/component type to be specified, though I wouldn't go that far to start with until we see such a need.
;;;","12/Jan/22 15:59;emilles;For (1) ""words = words + nums"", there are two steps, first an Object[] is created like in case (1) then the assignment of Object[] to String[] runs through DefaultTypeTransformation#castToType. This second step is where you get strings '5' and '10' in the result. If {{DefaultGroovyMethods#plus(T[],T[])}} is altered not to produce an Object[] internally, is the expectation still that numbers are converted to strings?

I think the Java inference engine has a different type for T for a call ""String[] x; Integer[] y; plus(x,y);"". I was pondering this when looking over the plus methods. I'm not sure there is a type-safe way to provide ""def <T> T[] plus(T[] a, T[] b)"". The second array may need to be Object[] so that T remains set by the first argument (left operand in ""a+b"").

Maybe ""def <T, U extends T> T[] plus(T[] a, U[] b)"" is the way to state it...  Update: looks like java still uses both operands to determine T.

!image-2022-01-12-10-43-14-275.png!;;;","12/Jan/22 17:07;emilles; This is what I have so far.  It is efficient, but the type parameters are not true to the runtime behavior.  The simplest solution would be to have all the array plus methods return {{Object[]}}.  Another option is to have the right operand be of type {{Object[]}} and just describe the array store exception or provide inline coercion.

I looked for an example in Java and the closest I found was Arrays#fill, which is declared this way (possibly for the same reasons): {{void fill(Object[] a,Object v)}}

{code:java}
    /**
     * Create an array as a union of two arrays.
     * <pre class=""groovyTestCase"">
     * Integer[] a = [1, 2, 3]
     * Integer[] b = [4, 5, 6]
     * def result = a + b
     * assert result.class == Integer[]
     * assert result == new Integer[]{1, 2, 3, 4, 5, 6}
     *
     * Number[] c = [-1, 0.0, null]
     * result = c + a
     * assert result.class == Number[]
     * assert result == new Number[]{-1, 0.0, null, 1, 2, 3}
     * // improper type arguments; Number doesn't extend Integer
     * groovy.test.GroovyAssert.shouldFail(ArrayStoreException) { a + c }
     * </pre>
     *
     * @param left  the left Array
     * @param right the right Array
     * @return A new array containing right appended to left.
     * @since 1.8.7
     */
    public static <T> T[] plus(final T[] left, final T[] right) {
        T[] result = Arrays.copyOf(left, left.length + right.length);
        System.arraycopy(right, 0, result, left.length, right.length);
        return result;
    }

    /**
     * Create an array containing elements from an original array plus an additional appended element.
     * <pre class=""groovyTestCase"">
     * Integer[] a = [1, 2, 3]
     * def result = a + 4
     * assert result.class == Integer[]
     * assert result == new Integer[]{1, 2, 3, 4}
     *
     * // improper type arguments; Double doesn't extend Integer
     * groovy.test.GroovyAssert.shouldFail(ArrayStoreException) { a + 5d }
     * </pre>
     *
     * @param left  the array
     * @param right the value to append
     * @return A new array containing left with right appended to it.
     * @since 1.8.7
     */
    public static <T> T[] plus(final T[] left, final T right) {
        T[] result = Arrays.copyOf(left, left.length + 1);
        result[left.length] = right;
        return result;
    }

    /**
     * Create an array containing elements from an original array plus those from a Collection.
     * <pre class=""groovyTestCase"">
     * Integer[] a = [1, 2, 3]
     * def result = a + [4, 5]
     * assert result.class == Integer[]
     * assert result == new Integer[]{1, 2, 3, 4, 5}
     * </pre>
     *
     * @param left  the array
     * @param right a Collection to be appended
     * @return A new array containing left with right appended to it.
     * @since 1.8.7
     */
    public static <T> T[] plus(final T[] left, final Collection<? extends T> right) {
        T[] result = Arrays.copyOf(left, left.length + right.size());
        int i = left.length;
        for (T t : right) {
            result[i] = t;
            i += 1;
        }
        return result;
    }

    /**
     * Create an array containing elements from an original array plus those from an Iterable.
     * <pre class=""groovyTestCase"">
     * class AbcIterable implements Iterable<String> {
     *     Iterator<String> iterator() { ""abc"".iterator() }
     * }
     * String[] array = ['x', 'y', 'z']
     * def result = array + new AbcIterable()
     * assert result.class == String[]
     * assert result == new String[]{'x', 'y', 'z', 'a', 'b', 'c'}
     * </pre>
     *
     * @param left  the array
     * @param right an Iterable to be appended
     * @return A new array containing elements from left with those from right appended.
     * @since 1.8.7
     */
    public static <T> T[] plus(final T[] left, final Iterable<? extends T> right) {
        return plus(left, toList(right));
    }
{code};;;","13/Jan/22 04:12;paulk;[~emilles] I built upon your previous comment but followed the second option you mentioned of having the second param type be Object:

[https://github.com/apache/groovy/pull/1675]

 ;;;","13/Jan/22 16:31;emilles;The PR looks good -- I did not look at the union methods.  In {{plus(T[],Collection)}}, the {{left.getClass().getComponentType()}} should be performed once outside the loop.;;;","14/Jan/22 02:38;paulk;The change is breaking for those folks relying on the old behaviour. See the release notes for suggestions.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException in map argument constructor when Immutable and CompileStatic are used,GROOVY-6836,12817578,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lhotari,lhotari,29/May/14 03:25,26/Jul/14 01:44,14/Jul/23 06:01,23/Jul/14 03:54,2.3.2,,,,,,,,,,,,,,,,,2.3.5,,,,,,,,0,,,,,,,"I'm working on an unit test for Grails and it fails with a ClassCastException.

{code}
java.lang.ClassCastException: grails.test.runtime.TestPluginUsage cannot be cast to java.util.Map
	at java.util.HashMap.hash(HashMap.java:366)
	at java.util.HashMap.put(HashMap.java:496)
	at java.util.HashSet.add(HashSet.java:217)
	at java.util.AbstractCollection.addAll(AbstractCollection.java:342)
	at grails.test.runtime.TestRuntimeFactory.getRuntimeForTestClass_closure1(TestRuntimeFactory.groovy:72)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure.call(Closure.java:439)
	at grails.test.runtime.TestRuntimeFactory.getRuntimeForTestClass(TestRuntimeFactory.groovy:63)
	at grails.test.runtime.TestRuntimeFactorySpec.should instantiate correct plugins and features for #testClass.simpleName(TestRuntimeFactorySpec.groovy:20)
{code}

With a debugger I can see that the object has a reference to a wrong metaclass .

I tried to isolate the problem without success. I'll push the code to a separate branch in Grails so that you can reproduce the problem and connect a debugger to the failing test.",,lhotari,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/May/14 05:15;lhotari;TestPluginUsage.groovy.decompiled.java;https://issues.apache.org/jira/secure/attachment/12722675/TestPluginUsage.groovy.decompiled.java",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 23 03:54:26 UTC 2014,,,,,,,,,,"0|i2ccdr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/May/14 03:28;lhotari;reproducing the problem:

{code}
git clone https://github.com/grails/grails-core
cd grails-core
git checkout GROOVY-6836-ClassCastException
cd grails-plugin-testing
../gradlew test
../gradlew -Ddebug.tests=1 test    # starts a debugger listening at port 5005 when tests get run , add breakpoint for ClassCastException
{code};;;","29/May/14 04:57;lhotari;decompiling the class using @Immutable and @CompileStatic has some strange logic in it:
{code}
    MetaClass localMetaClass1;
    MetaClass localMetaClass2;
    if ((DefaultGroovyMethods.getMetaClass(args) == null ? 1 : 0) != 0)
    {
      if (($getStaticMetaClass() != null ? 1 : 0) != 0)
      {
        localMetaClass1 = $getStaticMetaClass();
        this.metaClass = localMetaClass1;
      }
    }
    else
    {
      localMetaClass2 = DefaultGroovyMethods.getMetaClass(args);
      this.metaClass = localMetaClass2;
    }
{code};;;","29/May/14 05:19;lhotari;when you pass a map object to constructor, the map object's metaclass gets cached as the metaclass of the object that's getting instantiated;;;","29/May/14 05:43;lhotari;problem in initialValueExpression of the metaClass field?
[1] https://github.com/groovy/groovy-core/blob/e9ed3ff/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java#L357
[2] https://github.com/groovy/groovy-core/blob/e9ed3ff/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java#L247

perhaps the field is shared?;;;","29/May/14 05:47;lhotari;It looks like the metaClass field is added here:
https://github.com/groovy/groovy-core/blob/e9ed3ff/src/main/org/codehaus/groovy/classgen/Verifier.java#L108-L120
;;;","29/May/14 07:19;lhotari;It looks like ""metaClass"" field should be skipped in [ImmutableASTTransformation.createConstructorMapCommon|https://github.com/groovy/groovy-core/blob/e9ed3ff/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java#L348-L360];;;","29/May/14 07:31;lhotari;it looks like the problem exists even when @CompileStatic is removed, but for some reason the problem doesn't show up.

decompiled code from constructor:
{code}
    Object localObject15;
    Object localObject16;
    if ((!BytecodeInterface8.isOrigZ()) || (BytecodeInterface8.disabledStandardMetaClass()))
    {
      MetaClass localMetaClass1;
      if (ScriptBytecodeAdapter.compareEqual(arrayOfCallSite[115].callGetProperty(args), null))
      {
        if (ScriptBytecodeAdapter.compareNotEqual($getStaticMetaClass(), null))
        {
          localMetaClass1 = $getStaticMetaClass();
          this.metaClass = ((MetaClass)ScriptBytecodeAdapter.castToType(localMetaClass1, MetaClass.class));
        }
      }
      else
      {
        localObject15 = arrayOfCallSite[116].callGetProperty(args);
        this.metaClass = ((MetaClass)ScriptBytecodeAdapter.castToType(localObject15, MetaClass.class));
      }
    }
    else
    {
      MetaClass localMetaClass2;
      if (ScriptBytecodeAdapter.compareEqual(arrayOfCallSite[117].callGetProperty(args), null))
      {
        if (ScriptBytecodeAdapter.compareNotEqual($getStaticMetaClass(), null))
        {
          localMetaClass2 = $getStaticMetaClass();
          this.metaClass = ((MetaClass)ScriptBytecodeAdapter.castToType(localMetaClass2, MetaClass.class));
        }
      }
      else
      {
        localObject16 = arrayOfCallSite[118].callGetProperty(args);
        this.metaClass = ((MetaClass)ScriptBytecodeAdapter.castToType(localObject16, MetaClass.class));
      }
    }
{code};;;","04/Jul/14 04:46;paulk;Lari, I just tweaked @Immutable to clean up some warnings that were being reported by static compile debug mode. I didn't touch anything to do with the metaClass field but if you get a chance to try a recent snapshot, that would at least narrow down some searching. Thanks.;;;","21/Jul/14 08:14;melix;Any update on this one?;;;","21/Jul/14 08:24;lhotari;It still fails with Groovy 2.3.4 so it's not fixed.

quick way to reproduce
{code}
git clone --depth 10 -b GROOVY-6836-ClassCastException https://github.com/grails/grails-core
cd grails-core/grails-plugin-testing
../gradlew test
{code}

debugging problem:
{code}
../gradlew -Ddebug.tests=1 test    # starts a debugger listening at port 5005 when tests get run , add breakpoint for ClassCastException
{code};;;","21/Jul/14 08:35;lhotari;stacktrace of ClassCastException (debugger break point for ClassCastException shows this)
{code}
Thread [Test worker] (Suspended (exception ClassCastException))	
	ExpandoMetaClass(MetaClassImpl).getProperty(Class, Object, String, boolean, boolean) line: 1643	
	ExpandoMetaClass.getProperty(Class, Object, String, boolean, boolean) line: 1140	
	ExpandoMetaClass(MetaClassImpl).getProperty(Object, String) line: 3458	
	ExpandoMetaClass.getProperty(Object, String) line: 1152	
	HandleMetaClass(DelegatingMetaClass).getProperty(Object, String) line: 128	
	TestPluginUsage.getProperty(String) line: not available	
	InvokerHelper.getProperty(Object, String) line: 168	
	TestPluginUsage.hashCode() line: not available	
	LinkedHashMap<K,V>(HashMap<K,V>).hash(Object) line: 362	
	LinkedHashMap<K,V>(HashMap<K,V>).put(K, V) line: 492	
	LinkedHashSet<E>(HashSet<E>).add(E) line: 217	
	LinkedHashSet<E>(AbstractCollection<E>).addAll(Collection<? extends E>) line: 342	
	TestRuntimeFactory$_getRuntimeForTestClass_closure1.doCall(Field) line: 71	
	GeneratedMethodAccessor4.invoke(Object, Object[]) line: not available	
	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	
	Method.invoke(Object, Object...) line: 606	
	CachedMethod.invoke(Object, Object[]) line: 90	
	CachedMethod(MetaMethod).doMethodInvoke(Object, Object[]) line: 233	
	ExpandoMetaClass(MetaClassImpl).invokeMethod(Class, Object, String, Object[], boolean, boolean) line: 1085	
	ExpandoMetaClass.invokeMethod(Class, Object, String, Object[], boolean, boolean) line: 1110	
	ExpandoMetaClass(MetaClassImpl).invokeMethod(Object, String, Object[]) line: 909	
	TestRuntimeFactory$_getRuntimeForTestClass_closure1(Closure<V>).call(Object...) line: 423	
	TestRuntimeFactory$_getRuntimeForTestClass_closure1(Closure<V>).call(Object) line: 439	
	DefaultGroovyMethods.each(Iterator<T>, Closure) line: 1379	
	DefaultGroovyMethods.each(T, Closure) line: 1310	
	TestRuntimeFactory.getRuntimeForTestClass(Class<?>) line: 62	
	TestRuntimeFactory$getRuntimeForTestClass.call(Object, Object) line: not available	
	TestRuntimeFactorySpec.$spock_feature_0_0(Object, Object, Object) line: 20	
	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 57	
	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	
	Method.invoke(Object, Object...) line: 606	
	ReflectionUtil.invokeMethod(Object, Method, Object...) line: 138	
	ParameterizedSpecRunner(BaseSpecRunner).invokeRaw(Object, MethodInfo, Object...) line: 330	
	ParameterizedSpecRunner(BaseSpecRunner).invoke(Object, MethodInfo, Object...) line: 311	
	ParameterizedSpecRunner(BaseSpecRunner).invokeFeatureMethod() line: 285	
	ParameterizedSpecRunner(BaseSpecRunner).doRunIteration() line: 256	
	GeneratedMethodAccessor34.invoke(Object, Object[]) line: not available	
	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	
	Method.invoke(Object, Object...) line: 606	
	ReflectionUtil.invokeMethod(Object, Method, Object...) line: 138	
	ParameterizedSpecRunner(BaseSpecRunner).invokeRaw(Object, MethodInfo, Object...) line: 330	
	ParameterizedSpecRunner(BaseSpecRunner).invoke(Object, MethodInfo, Object...) line: 311	
	ParameterizedSpecRunner(BaseSpecRunner).runIteration(Object[], int) line: 223	
	ParameterizedSpecRunner(BaseSpecRunner).initializeAndRunIteration(Object[], int) line: 214	
	ParameterizedSpecRunner.runIterations(Iterator[], int) line: 119	
	ParameterizedSpecRunner.runParameterizedFeature() line: 43	
	ParameterizedSpecRunner(BaseSpecRunner).doRunFeature() line: 198	
	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 57	
	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	
	Method.invoke(Object, Object...) line: 606	
	ReflectionUtil.invokeMethod(Object, Method, Object...) line: 138	
	ParameterizedSpecRunner(BaseSpecRunner).invokeRaw(Object, MethodInfo, Object...) line: 330	
	ParameterizedSpecRunner(BaseSpecRunner).invoke(Object, MethodInfo, Object...) line: 311	
	ParameterizedSpecRunner(BaseSpecRunner).runFeature() line: 175	
	ParameterizedSpecRunner(BaseSpecRunner).runFeatures() line: 152	
	ParameterizedSpecRunner(BaseSpecRunner).doRunSpec() line: 112	
	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 57	
	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	
	Method.invoke(Object, Object...) line: 606	
	ReflectionUtil.invokeMethod(Object, Method, Object...) line: 138	
	ParameterizedSpecRunner(BaseSpecRunner).invokeRaw(Object, MethodInfo, Object...) line: 330	
	ParameterizedSpecRunner(BaseSpecRunner).invoke(Object, MethodInfo, Object...) line: 311	
	ParameterizedSpecRunner(BaseSpecRunner).runSpec() line: 91	
	ParameterizedSpecRunner(BaseSpecRunner).run() line: 82	
	Sputnik.run(RunNotifier) line: 63	
	JUnitTestClassExecuter.runTestClass(String) line: 86	
	JUnitTestClassExecuter.execute(String) line: 49	
	JUnitTestClassProcessor.processTestClass(TestClassRunInfo) line: 69	
	WorkerTestClassProcessor(SuiteTestClassProcessor).processTestClass(TestClassRunInfo) line: 48	
	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 57	
	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	
	Method.invoke(Object, Object...) line: 606	
	ReflectionDispatch.dispatch(MethodInvocation) line: 35	
	ReflectionDispatch.dispatch(Object) line: 24	
	ContextClassLoaderDispatch<T>.dispatch(T) line: 32	
	ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(Object, Method, Object[]) line: 93	
	$Proxy2.processTestClass(TestClassRunInfo) line: not available	
	TestWorker.processTestClass(TestClassRunInfo) line: 105	
	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]	
	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 57	
	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43	
	Method.invoke(Object, Object...) line: 606	
	ReflectionDispatch.dispatch(MethodInvocation) line: 35	
	ReflectionDispatch.dispatch(Object) line: 24	
	MessageHub$Handler.run() line: 355	
	DefaultExecutorFactory$StoppableExecutorImpl$1.run() line: 64	
	ThreadPoolExecutor.runWorker(ThreadPoolExecutor$Worker) line: 1145	
	ThreadPoolExecutor$Worker.run() line: 615	
	Thread.run() line: 745	
{code};;;","21/Jul/14 08:38;lhotari;take a look at the build/classes/main/grails/test/runtime/TestPluginUsage.class bytecode (I use jd-cli for decompiling) . It shows that the metaClass of TestPluginUsage is set to the metaClass from HashMap in the constructor which hasn't been fixed yet.;;;","21/Jul/14 10:38;melix;So I didn't manage to reproduce the bug with your instructions, but only with this one:

{noformat}
git clone -b GROOVY-6836-ClassCastException https://github.com/grails/grails-core
cd grails-core
./gradlew clean grails-plugin-testing:test
{noformat}

If I try to compile directly from the subproject, I get tons of errors, and not always the same ones, depending on the number of times I try to run again... Weird. In anycase, the bytecode for the class that has Immutable on it looks curious. There are lots of copies of the same logic for one field:

{noformat}
        26: ldc           #39                 // class java/util/Collection
        28: invokestatic  #45                 // Method org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType:(Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;
        31: checkcast     #39                 // class java/util/Collection
        34: aload_0       
        35: swap          
        36: putfield      #47                 // Field pluginClasses:Ljava/util/Collection;
        39: aload_2       
        40: pop           
        41: goto          763
        44: aload_1       
        45: ldc           #31                 // String pluginClasses
        47: invokeinterface #37,  2           // InterfaceMethod java/util/Map.get:(Ljava/lang/Object;)Ljava/lang/Object;
        52: instanceof    #49                 // class java/lang/Cloneable
        55: ifeq          544
        58: aload_1       
        59: ldc           #31                 // String pluginClasses
        61: invokeinterface #37,  2           // InterfaceMethod java/util/Map.get:(Ljava/lang/Object;)Ljava/lang/Object;
        66: ldc           #51                 // String clone
        68: iconst_0      
        69: anewarray     #53                 // class ""[Ljava/lang/Object;""
        72: ldc           #53                 // class ""[Ljava/lang/Object;""
        74: invokestatic  #45                 // Method org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType:(Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;
        77: checkcast     #53                 // class ""[Ljava/lang/Object;""
        80: invokestatic  #59                 // Method org/codehaus/groovy/runtime/ReflectionMethodInvoker.invoke:(Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/Object;
        83: ldc           #39                 // class java/util/Collection
        85: invokestatic  #45                 // Method org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType:(Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;
        88: checkcast     #39                 // class java/util/Collection
        91: instanceof    #61                 // class java/util/SortedSet
        94: ifeq          144
        97: aload_1       
        98: ldc           #31                 // String pluginClasses
       100: invokeinterface #37,  2           // InterfaceMethod java/util/Map.get:(Ljava/lang/Object;)Ljava/lang/Object;
       105: ldc           #51                 // String clone
{noformat}

Maybe this is just ok and a consequence of an ""instanceof"" chain, looks inefficient, but in any case, I can't reproduce outside of Grails.;;;","22/Jul/14 20:10;lhotari;PR sent https://github.com/groovy/groovy-core/pull/492;;;","23/Jul/14 03:54;melix;The problem was related to joint compilation, which adds synthetic fields to class nodes before they normally appear in the compilation cycle. See https://github.com/groovy/groovy-core/commit/64106f9;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"flow typing activated by if statement doing an ""instanceof"" check  doesn't work as expected with interface types",GROOVY-6835,12817573,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,lhotari,lhotari,29/May/14 02:49,22/Feb/16 20:48,14/Jul/23 06:01,05/Jan/16 03:14,2.3.2,2.4.0-rc-1,,,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,,,,,,,"The following code example fails with this STC error in compilation:
{code}
1 compilation error:

[Static type checking] - Cannot call java.util.Set <CharSequence>#add(java.lang.CharSequence) with arguments [<UnionTypejava.lang.Object+java.lang.CharSequence>] 
 at line: 10, column: 12
{code}

{code}
@groovy.transform.CompileStatic
class ShowUnionTypeBug {
    Map<String, Object> instanceMap = (Map<String,Object>)['a': 'Hello World']
    def findInstance(String key) {
        Set<CharSequence> allInstances = [] as Set
        def instance = instanceMap.get(key)
        if(instance instanceof CharSequence) {
           allInstances.add(instance)
        }
        allInstances
    }
}
new ShowUnionTypeBug().findInstance('a')
{code}",,blackdrag,lhotari,melix,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 05 03:14:17 UTC 2016,,,,,,,,,,"0|i2chon:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/May/14 10:32;melix;This is an interesting case. Is it really a bug? If you do: {{Set<CharSequence>}}, then it's not {{Set<? extends CharSequence>}}...;;;","30/May/14 10:36;lhotari;oh yes, that's a mistake in my example.

the error message changes, but it still fails:
{code}
[Static type checking] - Cannot call java.util.Set <? extends java.lang.CharSequence>#add(java.lang.CharSequence) with arguments [<UnionTypejava.lang.Object+java.lang.CharSequence>] 
 at line: 8, column: 12
{code};;;","30/May/14 10:42;lhotari;updated example:
{code}
@groovy.transform.CompileStatic
class ShowUnionTypeBug {
    Map<String, Object> instanceMap = (Map<String,Object>)['a': 'Hello World']
    def findInstance(String key) {
        Set<? extends CharSequence> allInstances = [] as Set
        def instance = instanceMap.get(key)
        if(instance instanceof CharSequence) {
           allInstances.add(instance)
        }
        allInstances
    }
}
new ShowUnionTypeBug().findInstance('a')
{code};;;","22/Oct/15 21:31;shils;This doesn't occur in any versions since 2.4.2 (inclusive) or in Master, so it was probably fixed as a side effect.;;;","23/Oct/15 08:22;blackdrag;ideally we would add a test for this and resolve the bug then. Or less ideally just resolve it.;;;","01/Nov/15 16:29;shils;[~lhotari] Would you like to submit a pr with your test?;;;","05/Jan/16 03:14;paulk;Added Lari's test;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
False positive variable scoping error when using AIC in combination with logging AST transform,GROOVY-6834,12818528,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,paulk,,28/May/14 19:19,07/Apr/15 19:07,14/Jul/23 06:01,10/Jun/14 05:13,2.3.2,,,,,,,,,,,,,,,,,2.3.3,,,,,,,,2,,,,,,,"Compiling this code:
{code}
@Grab('ch.qos.logback:logback-classic:1.0.13')
@groovy.util.logging.Slf4j
class MyClass {
    static myMethod() {
        String message = 'hello'  // internal param name p1 from InnerClassVisitor#visitConstructorCallExpression
        String audience = 'world' // p2
        new Runnable() {
            void run() {
                println ""$message $audience""
            }
        }
    }
}
MyClass.myMethod().run()
{code}
Gives this error message:
{noformat}
2 compilation errors:

Apparent variable 'p2' was found in a static scope but doesn't refer to a local variable, static field or class. Possible causes:
You attempted to reference a variable in the binding or an instance variable from a static context.
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method 'p2' but left out brackets in a place not allowed by the grammar.
 at line: -1, column: -1

Apparent variable 'p1' was found in a static scope but doesn't refer to a local variable, static field or class. Possible causes:
You attempted to reference a variable in the binding or an instance variable from a static context.
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method 'p1' but left out brackets in a place not allowed by the grammar.
 at line: -1, column: -1
{noformat}",,paolodt,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 28 22:11:13 UTC 2014,,,,,,,,,,"0|i2cplz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/May/14 19:23;paulk;An unintended consequence of the fix for GROOVY-6373;;;","28/May/14 19:59;paulk;Simplified generated inner class for above example:
{code}
class MyClass$1 implements Runnable {
    groovy.lang.Reference audience
    groovy.lang.Reference message
    ....

    MyClass$1(Class p0, groovy.lang.Reference p1, groovy.lang.Reference p2) {
        this$0 = p0 
        super()
        audience = p2 
        message = p1
        ....
    }

    void run() {
        this.println(""$message $audience"")
    }

    ...
{code}
The problem is that there is an intermediate phase where p1, p2 etc. are set as the initial values for the audience and message Reference fields and these are now flagged as a problem because they haven't been transferred into the constructor (static context) where things would be fine. That happens at a later stage.;;;","28/May/14 22:11;paulk;Proposed fix:
https://github.com/groovy/groovy-core/pull/428;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Access to static fields/properties from within nested classes is inconsistent,GROOVY-6831,12812137,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,27/May/14 20:12,01/Feb/17 23:19,14/Jul/23 06:01,20/Sep/16 06:56,,,,,,,,,,,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"Misbehaves in the same way regardless of @CompileStatic:
{code}
import java.util.logging.Logger

//@groovy.transform.CompileStatic
class Foo {

  private static final transient Logger log = Logger.getLogger(Foo.class.getName()) 
  void method() {
    log.info('some info')
  }
  static class Bar {
    void method() {
      log.info('some inner info')
    }
    static class Baz {
       void method() {
        log.info('some inner inner info')
      }
    }
  }
}

new Foo().method() // => INFO: some info
new Foo.Bar().method() // => INFO: some inner info
new Foo.Bar.Baz().method() // => groovy.lang.MissingPropertyException: No such property: log for class: Foo$Bar
{code}",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 20 06:56:12 UTC 2016,,,,,,,,,,"0|i2bth3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/May/14 22:11;paulk;Another example without logging:
{code}
class Outer {
  void add() { items.add('Outer') }
  static List items = []
  static class Inner {
    void add() { items.add('Inner') }
    static class InnerInner {
      void add() { items.add('InnerInner') }
    }
  }
}

new Outer().add()
new Outer.Inner().add()
new Outer.Inner.InnerInner().add()
assert Outer.items == [""Outer"", ""Inner"", ""InnerInner""]
{code}
Currently when run gives:
{noformat}
groovy.lang.MissingPropertyException: No such property: items for class: Outer$Inner
{noformat}
You would think the property missing handling would cascade up the classes but instead the first layer is handled via propertyMissing and then the next layer is a static missing property which is handled differently.

Adding in a naive implementation for ""$static_propertyMissing"" (with the same implementation as propertyMissing) then gives:
{noformat}
java.lang.IllegalArgumentException: object is not an instance of declaring class
{noformat}
;;;","11/Jun/14 15:18;paulk;see:
https://github.com/groovy/groovy-core/pull/431
which basically changes the propertyMissing method in Outer$Inner$InnerInner from this:
{code}
return Outer$Inner.""$name""
{code}
to this:
{code}
try {
    return Outer$Inner.""$name""
} catch (groovy.lang.MissingPropertyException mpe) {
    return Outer.""$name""
} 
{code}
;;;","05/Sep/16 07:26;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/414

    GROOVY-6831: Access to private static fields from within inner classe…

    …s is inconsistent

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy6831

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/414.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #414
    
----
commit 9b4cd49ec23c2840d849baafe3d4e886dcb66253
Author: paulk <paulk@asert.com.au>
Date:   2016-09-05T07:25:10Z

    GROOVY-6831: Access to private static fields from within inner classes is inconsistent

----
;;;","19/Sep/16 02:55;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/groovy/pull/414
;;;","19/Sep/16 02:57;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/425

    GROOVY-6831: Access to static fields/properties from within inner cla…

    …sses is inconsistent

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy6831b

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/425.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #425
    
----
commit 6aa91bb2cb3d31a2e28a7a271f330b798047e0b9
Author: paulk <paulk@asert.com.au>
Date:   2016-09-19T02:53:15Z

    GROOVY-6831: Access to static fields/properties from within inner classes is inconsistent

----
;;;","20/Sep/16 06:54;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/425
;;;","20/Sep/16 06:56;paulk;Proposed PR merged.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Calling Closure from within inner static class fails in 2.1.7+,GROOVY-6830,12818311,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,todd.costella,todd.costella,27/May/14 09:30,08/Jul/14 15:28,14/Jul/23 06:01,12/Jun/14 04:14,2.1.7,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,,,,,0,,,,,,,"One of the fellows on my team ran into what we think is an issue with the way that closures are handled post 2.1.7.

The following test case illustrates the issue

{code}
public class Foo {
   public static class InnerFoo {
      public InnerFoo() {
            bar()
      }  
 
   public static bar() {
      (1..10).each {
            baz(it)
      }
   }
 
   public static baz(output) {
      println output
   }
 }

}
new Foo.InnerFoo ()
{code}

This code seems to be ok in 2.1.6. 

I had a quick email chat with Andres Almiray and he dug a bit further into this example. He noticed the following:

{quote}
Hi Todd,

As far as I can tell the problem appears in Groovy 2.1.7 and has not been fixed in 2.3.1.
There's indeed a compilation difference between 2.1.6 and 2.1.7 as seen here

2.1.6:
total 56
-rw-r--r--  1 aalmiray  wheel  6291 May 27 11:13 Foo$InnerFoo.class
-rw-r--r--  1 aalmiray  wheel  2571 May 27 11:13 Foo$_InnerFoo_bar_closure1.class
-rw-r--r--  1 aalmiray  wheel  4654 May 27 11:13 Foo.class
-rw-r--r--  1 aalmiray  wheel  5964 May 27 11:13 shawn.class

2.1.7:
total 56
-rw-r--r--  1 aalmiray  wheel  6291 May 27 11:13 Foo$InnerFoo.class
-rw-r--r--  1 aalmiray  wheel  2562 May 27 11:13 Foo$_InnerFoo_bar_closure1.class
-rw-r--r--  1 aalmiray  wheel  4654 May 27 11:13 Foo.class
-rw-r--r--  1 aalmiray  wheel  5964 May 27 11:13 shawn.class

There are 9 missing bytes since 2.1.7. I think it's best if you file a bug and ping @cedricchampeau as this might be related to some typing optimizations.

Cheers,
Andres
{quote}

I can appreciate this is not a typical case and likely why it hasn't been noticed yet. Our specific case where we bumped into this was in a Jenkins Test Runner that uses this idiom. 

Let me know if we can provide any further information. 
",,aalmiray,melix,paulk,todd.costella,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 12 04:14:15 UTC 2014,,,,,,,,,,"0|i2c0dz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"27/May/14 13:48;melix;Still a problem with latest sources ({{master}} and {{GROOVY_2_3_X}}. Interestingly, adding {{@CompileStatic}} fixes the problem.
;;;","28/May/14 03:48;aalmiray;FYI Groovy 2.3.2 still has the problem. Due to a newer version of ASM all generated bytecode sizes have changed

{code}
-rw-r--r--  1 aalmiray  wheel  6311 May 28 10:48 Foo$InnerFoo.class
-rw-r--r--  1 aalmiray  wheel  2619 May 28 10:48 Foo$_InnerFoo_bar_closure1.class
-rw-r--r--  1 aalmiray  wheel  4805 May 28 10:48 Foo.class
-rw-r--r--  1 aalmiray  wheel  6115 May 28 10:48 shawn.class
{code};;;","28/May/14 03:50;melix;Yup, that's what my previous comment meant :);;;","12/Jun/14 04:13;paulk;see:
https://github.com/groovy/groovy-core/pull/443;;;","12/Jun/14 04:14;paulk;Fixed. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
jarjar assembly missing classes required by GroovyConsole,GROOVY-6828,12817571,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,27/May/14 05:43,07/Apr/15 19:06,14/Jul/23 06:01,27/May/14 05:44,2.3.1,,,,,,,,,,,,,,,,,2.3.2,,,,,,,,0,,,,,,,"errors such as this sometimes in the GroovyConsole output window:
{noformat}
...stacktrace...
Caused by: java.lang.ClassNotFoundException: groovyjarjarasm.asm.util.Printer
{noformat}
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 27 05:45:38 UTC 2014,,,,,,,,,,"0|i2chpb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/May/14 05:44;paulk;see https://github.com/groovy/groovy-core/commit/d207330e;;;","27/May/14 05:45;paulk;We have half the classes included from asm-util (if we ever use any more I'd suggest removing the includes altogether).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compiler does not always make direct setter call inside inner class,GROOVY-6825,12817387,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,melix,melix,26/May/14 10:30,11/Nov/20 02:01,14/Jul/23 06:01,05/Jul/20 04:07,2.3.1,,,,,,,,,,,,,,,,,,,,,Static compilation,,,,0,,,,,,,"Similarily to GROOVY-6823, this code doesn't produce a direct setter call. However, this one is more complex to fix due to the current static compilation architecture.

{code}
@groovy.transform.CompileStatic
class Outer {
    String outerProperty
    private class Inner {
        String fromInner() {
            outerProperty = 'outer'
            //uterProperty
        }
    }

    String blah() {
        new Inner().fromInner()
    }
}
{code}
",,emilles,gillius,melix,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jul 05 04:07:07 UTC 2020,,,,,,,,,,"0|i2by8n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Dec/15 14:12;gillius;Is it possible this is the same issue as found in GROOVY-7705?;;;","08/Dec/15 16:46;shils;In Groovy 2.4.5, the bytecode of Inner#fromInner is:

{code}
 L0
    LINENUMBER 6 L0
    LDC ""outer""
    DUP
    ASTORE 1
    ALOAD 0
    GETFIELD Outer$Inner.this$0 : LOuter;
    ALOAD 1
    INVOKEVIRTUAL Outer.setOuterProperty (Ljava/lang/String;)V
    ACONST_NULL
    POP
    ARETURN
   L1
    ACONST_NULL
    ARETURN
{code}

So setOuterProperty is invoked on the outer class reference of the inner instance. That looks like a direct setter call to me, but perhaps Cédric meant something else.;;;","08/Dec/15 17:07;gillius;This was reported against Groovy 2.3.1 per the JIRA so it's possible it's no longer an issue for inner classes when using setters.

I tested making the field outerProperty private, and I do see the issue, it is exactly the same as what I see in GROOVY-7705, but for closures. When the setter exists, a direct call is made. When there is no setter, setProperty is called, rather than a synthetic method.;;;","08/Dec/15 17:29;shils;Yes, there shouldn't be a difference between closures and other inner classes as far as this problem is concerned.;;;","05/Jul/20 04:07;emilles;Static compiler now writes out direct setter call for inner class (or closure) access to outer class property: 
 https://github.com/apache/groovy/blob/GROOVY_2_5_X/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java#L292;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compiler does not always make direct method call for getProperty in an inner class,GROOVY-6823,12817346,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,26/May/14 10:10,28/May/14 03:04,14/Jul/23 06:01,26/May/14 11:02,2.3.1,,,,,,,,,,,,,,,,,2.3.2,,,,,,,,0,,,,,,,"In the following snippet of code:

{code}
@groovy.transform.CompileStatic
class Outer {
    String outerProperty = 'outer'
    private class Inner {
        String fromInner() {
            Holder holder = new Holder()
            holder.value = outerProperty
            holder.value
        }
    }

    String blah() {
        new Inner().fromInner()
    }
}
{code}

access to ""outerProperty"" is done through {{GroovyObject.getProperty}} but a direct method call can be done.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-26 10:10:34.0,,,,,,,,,,"0|i2bp87:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Calling outer class method inside ""super"" call in constructor fails with static compilation",GROOVY-6821,12817539,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,26/May/14 08:00,28/May/14 03:03,14/Jul/23 06:01,26/May/14 08:23,,,,,,,,,,,,,,,,,,2.3.2,,,,,,,,0,,,,,,,"The following code fails with a {{VerifyError}}:

{code}
class Parent {
        String str
        Parent(String s) { str = s }
    }
   @CompileStatic
    class Outer {
        String a

        private class Inner extends Parent {
           Inner() { super(getA()) }
        }

        String test() { new Inner().str }
    }
    def o = new Outer(a:'ok')
    assert o.test() == 'ok'
{code}

Note that this also fails, for a different reason, without {{@CompileStatic}}.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-26 08:00:25.0,,,,,,,,,,"0|i2bmjz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The type checker disallows the Outer.this notation,GROOVY-6820,12817606,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,26/May/14 02:37,28/May/14 03:04,14/Jul/23 06:01,26/May/14 03:06,2.2.2,,,,,,,,,,,,,,,,,2.2.3,2.3.2,,,,,,,0,,,,,,,"This code fails compilation because the type checker disallows the {{Outer.this}} notation inside a non-static inner class:

{code}
class Outer {
    int x
    class Inner {
        int foo() { 2*Outer.this.x }
    }
    int bar() {
        new Inner().foo()
    }
}
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-26 02:37:14.0,,,,,,,,,,"0|i2c7q7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
IncompatibleClassChangeError when using closures,GROOVY-6819,12818309,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,oc,oc,24/May/14 14:41,28/May/14 03:04,14/Jul/23 06:01,27/May/14 15:42,2.3.1,,,,,,,,,,,,,,,,,2.2.3,2.3.2,,,Compiler,,,,0,,,,,,,"{code}
99 /tmp> ~/Downloads/groovy-2.1.2/bin/groovy q
Here's the problem?!?
-- nope was actually OK
100 /tmp> ~/Downloads/groovy-2.2.1/bin/groovy q
Here's the problem?!?
-- nope was actually OK
101 /tmp> ~/Downloads/groovy-2.3.1/bin/groovy q
Here's the problem?!?
Caught: java.lang.IncompatibleClassChangeError
java.lang.IncompatibleClassChangeError
        at Foo$_bar_closure1.doCall(q.groovy:10)
        at Foo$_bar_closure1.doCall(q.groovy)
        at Foo.justcallme(q.groovy:3)
        at Foo$justcallme$0.callStatic(Unknown Source)
        at Foo.bar(q.groovy:8)
        at Foo$bar.call(Unknown Source)
        at q.run(q.groovy:15)
102 /tmp> <q.groovy
class Foo {
    static justcallme(Closure block) {
        block()
    }
    static foo() {
    }
    static void bar(Closure block) {
        this.justcallme {
println ""Here's the problem?!?""
            this.foo()
println ""-- nope was actually OK""
        }
    }
}
Foo.bar() { }
103 /tmp> groovy -v
Groovy Version: 2.3.1 JVM: 1.7.0_13 Vendor: Oracle Corporation OS: Mac OS X
104 /tmp> sw_vers
ProductName:    Mac OS X
ProductVersion: 10.8.5
BuildVersion:   12F45
105 /tmp>
{code}","JVM: 1.7.0_13, Mac OS X 10.8.5 (12F45)",blackdrag,melix,oc,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 27 15:42:14 UTC 2014,,,,,,,,,,"0|i2cu3r:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"26/May/14 11:33;pschumacher;I can replicate this. With 2.3.0 I do not get this error.;;;","26/May/14 13:27;melix;Regression introduced by https://github.com/groovy/groovy-core/commit/cce24f25fa747b09ab464240ba0e5af684bb6ae3;;;","27/May/14 15:42;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"StackOverflow Exception when calling super.method, which returns an instance of the corresponding class. ",GROOVY-6818,12817541,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,evox,evox,24/May/14 11:23,11/Jun/14 14:26,14/Jul/23 06:01,04/Jun/14 03:24,2.2.2,,,,,,,,,,,,,,,,,2.3.0,,,,groovy-jdk,,,,0,,,,,,,"You get a StackOverflow Exception when running following code:

{code:title=A.groovy|borderStyle=solid}
abstract class A {
    A attach(){
        System.out.println( ""A does something else"");
        return this;
    }
}
{code}
{code:title=B.groovy|borderStyle=solid}
class B extends A {
    @Override
    B attach(){
        System.out.println(""B does something else"");
        return (B) super.attach();
    }
}
{code}
{code:title=C.groovy|borderStyle=solid}
class C extends B {
    @Override
    C attach(){
        System.out.println(""C does something else"");
        return (C) super.attach();
    }
}
{code}

{code:title=Test.groovy|borderStyle=solid}
C c = new C(); c.attach();
{code}

This bug only occurs when the depth of the class hierarchy exceeds two classes.
The whole ErrorOutput can be found attached.

{code:title=Error.output|borderStyle=solid}
C does something else
C does something else
C does something else
C does something else
Exception in thread ""main"" java.lang.StackOverflowError
	at groovy.lang.MetaClassImpl.getMetaProperty(MetaClassImpl.java:2441)
	at groovy.lang.MetaClassImpl.getMetaProperty(MetaClassImpl.java:2415)
	at groovy.lang.MetaClassImpl.getProperty(MetaClassImpl.java:1510)
	at groovy.lang.MetaClassImpl.getProperty(MetaClassImpl.java:3308)
	at org.codehaus.groovy.runtime.callsite.ClassMetaClassGetPropertySite.getProperty(ClassMetaClassGetPropertySite.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGetProperty(AbstractCallSite.java:227)
	at C.attach(C.groovy:20)
	at C.attach(C.groovy)
	at B.attach(B.groovy)
	at C.super$3$attach(C.groovy)
	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1047)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:128)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuper0(ScriptBytecodeAdapter.java:148)
{code}




","Mac OSX Mavericks, IntelliJ IDEA",blackdrag,evox,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/May/14 11:23;evox;erroroutput.txt;https://issues.apache.org/jira/secure/attachment/12722405/erroroutput.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 04 03:24:00 UTC 2014,,,,,,,,,,"0|i2bukn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Jun/14 03:24;blackdrag;looks like the issue was fixed somewhen between 2.2.2 and 2.3.0;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
IntelliJ sees proper 2.3.1 release as 'groovy-2.3.1.SNAPSHOT',GROOVY-6815,12817277,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,alpheratz,alpheratz,23/May/14 04:37,28/May/14 03:03,14/Jul/23 06:01,27/May/14 15:07,2.3.1,,,,,,,,,,,,,,,,,2.3.2,,,,,,,,0,,,,,,,"Just downloaded a fresh copy of 2.3.1 ""Combined binary / source / documentation bundle: Distribution bundle""

In intelliJ, when I make a new project, I make a new Groovy library pointed at this fresh download

As attached image shows, IntelliJ displays the library name as 'groovy-2.3.1.SNAPSHOT.'

Taking a look inside groovy-2.3.1.jar/META-INF/groovy-release-info.properties, I see:

{code}
ImplementationVersion=2.3.1
BundleVersion=2.3.1.SNAPSHOT
BuildDate=19-May-2014
BuildTime=02:50 PM
{code}

I ASSUME (rightly or wrongly) that this is where IntelliJ is getting it's version info from?

In any case, something doesn't seem quite correct.",Intellij EAP 13.1.3 build 135.908 / win8.1 x64,alpheratz,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6829,,,,,,,,,,,,,,,,,,,,,"23/May/14 04:37;alpheratz;Capture.PNG;https://issues.apache.org/jira/secure/attachment/12723144/Capture.PNG",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 27 15:06:47 UTC 2014,,,,,,,,,,"0|i2ck1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/May/14 04:45;melix;Indeed, thanks for pointing at this. I am wondering if it was an error during the release process or a bug in the TeamCity plugin for releases. I will take a look!;;;","27/May/14 15:06;melix;Fixed by adding a sanity check in the build to make sure we don't release with wrong version numbers.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ArrayIndexOutOfBoundsException on JsonBuilder.toString,GROOVY-6812,12817545,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,risto,risto,21/May/14 08:57,28/Dec/14 11:26,14/Jul/23 06:01,28/Dec/14 11:26,2.3.1,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,JSON,,,,0,jsonBuilder,,,,,,"I've found a groovy object that cannot be transformed to a json string using the JsonBuilder. The object contains strings with a lot of wrongly encoded characters. Its swedish characters (Ã¥Ã¤Ã¶) in UTF-8 encoded as ISO8859-1.

This bug is not reproducable in Groovy 2.1",,pschumacher,risto,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/May/14 08:57;risto;JsonBuilderToStringTest.groovy;https://issues.apache.org/jira/secure/attachment/12722674/JsonBuilderToStringTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 11:26:07 UTC 2014,,,,,,,,,,"0|i2cgl3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"28/Dec/14 11:26;pschumacher;Thanks for reporting. Your example works for me with groovy 2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bug in the constructor of anonymous inner class,GROOVY-6811,12813411,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,bura,bura,21/May/14 04:37,11/Jun/14 14:25,14/Jul/23 06:01,10/Jun/14 09:28,2.3.1,,,,,,,,,,,,,,,,,2.3.3,,,,,,,,0,,,,,,,"Test example:
{code}
  class CreatePaymentPanel {
      def foo() { new SomeFragment() {} }
      class SomeFragment {}
  }
  new CreatePaymentPanel().foo()
{code}
Going through the AST I think I located the problem. Inner class is
generated as:
{code}
public class CreatePaymentPanel$SomeFragment {
    public CreatePaymentPanel this$0

    public CreatePaymentPanel$SomeFragment(CreatePaymentPanel $p$) {
        super()
        this$0 = $p$
    }
}
{code}
so far so good. Anonymous inner class looks like this:
{code}
public class CreatePaymentPanel$1 extends CreatePaymentPanel$SomeFragment {
    public CreatePaymentPanel this$0

    public CreatePaymentPanel$1(CreatePaymentPanel p0) {
        super()
        this$0 = p0
    }
}
{code}
and method foo:
{code}
  public Object foo() {
      new CreatePaymentPanel$1(this)
  }
{code}
The problem lies in `CreatePaymentPanel$1`'s constructor, in
particular its call of `super()`. Its superclass
`CreatePaymentPanel$SomeFragment` defines one constructor with
`CreatePaymentPanel` instance as parameter. If `CreatePaymentPanel$1`
called `super(p0)` all would be fine.",,bura,dsrkoc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-21 04:37:59.0,,,,,,,,,,"0|i2bx3r:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyCastException on type handling,GROOVY-6810,12818308,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,bgoetzmann,bgoetzmann,20/May/14 14:40,28/May/14 03:03,14/Jul/23 06:01,21/May/14 10:09,2.3.1,,,,,,,,,,,,,,,,,2.3.2,,,,,,,,0,,,,,,,"Executed in a Groovy console, in 2.3.1 version, the script bellow throws a org.codehaus.groovy.runtime.typehandling.GroovyCastException exception, but not with Groovy 2.3.0.

The script:
{code}
import java.security.AccessController 
import java.security.PrivilegedAction 

static void injectVariables(final def instance, def variables) { 
    instance.class.declaredFields.each { field -> 
        if (variables[field.name]) { 
            AccessController.doPrivileged(new PrivilegedAction() { 
                @Override 
                public Object run() { 
                    boolean wasAccessible = field.isAccessible() 
                    try { 
                        field.accessible = true 
                        field.set(instance, variables[field.name]) 
                        return null; // return nothing... 
                    } catch (IllegalArgumentException | IllegalAccessException ex) { 
                        throw new IllegalStateException(""Cannot set field: "" + field, ex) 
                    } finally { 
                        field.accessible = wasAccessible 
                    } 
                } 
            }) 
        } 
    } 
} 

class Test { 
    def p 
} 

def t = new Test() 

injectVariables(t, ['p': 'q'])
{code}

The exception:
{noformat}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'class ConsoleScript8' with class 'java.lang.Class' to class 'ConsoleScript8' 
    at ConsoleScript8$_injectVariables_closure1.doCall(ConsoleScript8:7) 
    at ConsoleScript8.injectVariables(ConsoleScript8:5) 
    at ConsoleScript8$injectVariables.callStatic(Unknown Source) 
    at ConsoleScript8.run(ConsoleScript8:32
{noformat}
",,bgoetzmann,blackdrag,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 21 10:09:42 UTC 2014,,,,,,,,,,"0|i2c27b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/May/14 16:52;paulk;add code tags;;;","20/May/14 16:58;paulk;Some extra info from the full stacktrace:
{noformat}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'class ConsoleScript0' with class 'java.lang.Class' to class 'ConsoleScript0'
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnSAM(DefaultTypeTransformation.java:392)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnNumber(DefaultTypeTransformation.java:306)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:227)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:599)
	at ConsoleScript0$_injectVariables_closure1.doCall(ConsoleScript0:7)
        ,,,
{noformat}
;;;","21/May/14 10:09;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError With Inner Class ,GROOVY-6809,12817563,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,brownj,brownj,20/May/14 07:54,09/Jun/20 10:02,14/Jul/23 06:01,31/Oct/19 12:08,2.3.0,2.4.0-beta-3,,,,,,,,,,,,,,,,2.5.13,3.0.0-rc-1,,,Compiler,,,,1,,,,,,,"The following code compiles but throws a VerifyError at runtime:

{code:title=Test.groovy|borderStyle=solid}
class Test {

    static void main(String[] args) {
        def a = new A()
    }

    static class A {
        A() {
            def b = new B()
        }

        void sayA() { println 'saying A' }

        class B extends A {
            public B() {
                super(A.this)
                sayA()
            }
        }
    }
}
{code}

I didn't go back through versions but I tested with 2.3.0 and that shows the problem.

{noformat}
Caught: java.lang.VerifyError: (class: Test$A$B, method: <init> signature: (LTest$A;)V) Expecting to find object/array on stack
java.lang.VerifyError: (class: Test$A$B, method: <init> signature: (LTest$A;)V) Expecting to find object/array on stack
	at Test$A.<init>(Test.groovy:9)
	at Test.main(Test.groovy:4)
{noformat}",,blackdrag,brownj,emilles,paulk,pschumacher,werickson,,,,,,,,,,"eric-milles commented on pull request #958: GROOVY-6809 and GROOVY-9168: AIC before delegate constructor call
URL: https://github.com/apache/groovy/pull/958
 
 
   Add support for:
   ```groovy
   class A {
     A() {
       this(new Runnable() {
         @Override
         void run() {
           ...
         }
       })
     }
     private A(Runnable action) {
       ...
     }
   }
   ```
   and
   ```groovy
    class A {
     A(Runnable action = new Runnable() { void run() { ... }}) {
       this.action = action
     }
     Runnable action
   }
   ```
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;01/Jul/19 15:54;githubbot;600","eric-milles commented on issue #958: GROOVY-6809 and GROOVY-9168: AIC before delegate constructor call
URL: https://github.com/apache/groovy/pull/958#issuecomment-507406528
 
 
   CI build passed on all JDKs except 10, which was stopped before it could complete.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;01/Jul/19 20:08;githubbot;600","danielsun1106 commented on pull request #958: GROOVY-6809 and GROOVY-9168: AIC before delegate constructor call
URL: https://github.com/apache/groovy/pull/958
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jul/19 23:24;githubbot;600","danielsun1106 commented on issue #958: GROOVY-6809 and GROOVY-9168: AIC before delegate constructor call
URL: https://github.com/apache/groovy/pull/958#issuecomment-508589649
 
 
   Merged. Thanks!
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jul/19 23:24;githubbot;600",,,,,,,,0,2400,,,0,2400,,,,,,,,GROOVY-7609,,,,,,,,,,,,,,,GROOVY-6777,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 09 21:34:08 UTC 2019,,,,,,,,,,"0|i2c5pb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Sep/14 15:52;pschumacher;With current master I get:

{noformat}
Caught: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: Test$A(Test$A)
groovy.lang.GroovyRuntimeException: Could not find matching constructor for: Test$A(Test$A)
        at Test$A$B.<init>(test.groovy:16)
        at Test$A.<init>(test.groovy:9)
        at Test.main(test.groovy:4)
{noformat};;;","01/Sep/16 00:36;werickson;I get the same error on Groovy v2.4.6 with the below code snippet:
{code:java}
import java.util.concurrent.ThreadFactory

class A {
    public A() {
        this(new ThreadFactory() {
            @Override
            public Thread newThread(final Runnable runnable) {
                return null
            }
        })
    }

    private A(final ThreadFactory factory) {
    }
}

final foo = new A()
{code}

{code}
Caught: java.lang.VerifyError: (class: A, method: <init> signature: ()V) Expecting to find object/array on stack
java.lang.VerifyError: (class: A, method: <init> signature: ()V) Expecting to find object/array on stack
	at foo.run(foo.groovy:18)
{code};;;","20/Sep/16 07:31;paulk;I am thinking this is the expected behavior. The nested class A only has a no-arg constructor.;;;","13/Feb/17 15:09;blackdrag;I think the base issue is a not set static context, or that fact being ignored. Related example:
{code:Java}
​class A {A(x){}}
class B extends A {
  B(){ 
    super (new Object() {}​)
  }
}

new B()​
{code}
fails with a VerifyError, because the compiler tries to use ""this"" for the anonymous inner class in the super call. But at this time, there is no initialized ""this"". But unlike A.this in a previous comment, which I think should fail, the code example in this comment is supposed to work by just not using the ""this""-context... in at least in a static compiler any call to outside ""this"" from the inner class is supposed to cause a compilation error as well.;;;","09/Jun/19 21:34;emilles;The AIC examples have a different bytecode sequence in Java vs Groovy.  For this Java example:
{code:java}
public class Runner {
  public static void main(String[] args) {
    new Runner();
  }
  public Runner() {
    this(new Runnable() {
      @Override public void run() {
        System.out.println(""ran"");
      }
    });
  }
  public Runner(Runnable action) {
    action.run();
  }
}
{code}
The no-arg constructor only delegates to another constructor after creating a new AIC.
{code}
  // Method descriptor #15 ()V
  // Stack: 3, Locals: 1
  public Runner();
     0  aload_0 [this]
     1  new Runner$1 [3]
     4  dup
     5  invokespecial Runner$1() [4]
     8  invokespecial Runner(java.lang.Runnable) [5]
    11  return
      Line numbers:
        [pc: 0, line: 6]
        [pc: 11, line: 11]
{code}

The groovyc version of the same looks like this:
{code}
  // Method descriptor #15 ()V
  // Stack: 4, Locals: 1
  public Runner();
     0  aload_0 [this]
     1  new Runner$1 [17]
     4  dup
     5  aload_0 [this]
     6  invokespecial Runner$1(Runner) [20]
     9  invokespecial Runner(java.lang.Runnable) [23]
    12  return
      Line numbers:
        [pc: 0, line: 13]
        [pc: 12, line: 18]
      Local variable table:
        [pc: 0, pc: 12] local: this index: 0 type: Runner
{code}

Looks like groovyc created a constructor ""Runner$1(Runner)"" and javac created ""Runner$1()"", requiring no this reference passed during construction.

Update: The constructor is augmented by {{InnerClassVisitor.visitConstructorCallExpression}} to have argument ""this"" passed.  If the inner class type had a static modifier, the addition of this would be skipped.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closures may have wrong inner class attributes,GROOVY-6808,12817478,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,20/May/14 07:23,28/May/14 03:04,14/Jul/23 06:01,24/May/14 07:09,2.3.1,,,,,,,,,,,,,,,,,2.3.2,,,,Compiler,,,,0,,,,,,,"ASM 5.0.2 has a bug which corrupts inner class tables. A workaround was written for GROOVY-6750 but it itself produces a corrupt inner class table. This can be highlighted with the following test case:

{code}
class Foo {
   Closure cl = { println 'foo' }
}
Class c = Class.forName('Foo$_closure1')
c.isAnonymousClass()
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6750,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-20 07:23:32.0,,,,,,,,,,"0|i2cgnz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The type checker should use the transform loader instead of the source unit loader for extension methods,GROOVY-6806,12817536,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,19/May/14 12:02,10/Jun/22 23:29,14/Jul/23 06:01,19/May/14 12:07,2.2.2,2.3.1,,,,,,,,,,,,,,,,2.3.2,,,,Static Type Checker,,,,0,,,,,,,"The issue is highlighted here: http://groovy.329449.n5.nabble.com/rxjava-with-groovy-type-checking-td5719389.html

If used from Gradle *and* that the extension module factory is a user defined factory, compilation will fail.",,emilles,jtravis,lawsonjl,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6008,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 10 23:29:34 UTC 2022,,,,,,,,,,"0|i2c0c7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jun/14 16:03;jtravis;I am still seeing this error with Groovy 2.3.2 and rxJava 0.19.0:

{noformat}
:compileJava UP-TO-DATE
:compileGroovy
startup failed:
General error during class generation: rx.lang.groovy.RxGroovyPropertiesModuleFactory cannot be cast to org.codehaus.groovy.runtime.m12n.PropertiesModuleFactory

java.lang.ClassCastException: rx.lang.groovy.RxGroovyPropertiesModuleFactory cannot be cast to org.codehaus.groovy.runtime.m12n.PropertiesModuleFactory
	at org.codehaus.groovy.runtime.m12n.StandardPropertiesModuleFactory.newModule(StandardPropertiesModuleFactory.java:38)
	at org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner.scanExtensionModuleFromProperties(ExtensionModuleScanner.java:77)
	at org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner.scanExtensionModuleFromMetaInf(ExtensionModuleScanner.java:72)
	at org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner.scanClasspathModules(ExtensionModuleScanner.java:54)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport$ExtensionMethodCache.getExtensionMethods(StaticTypeCheckingSupport.java:1832)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDGMMethodsForClassNode(StaticTypeCheckingSupport.java:180)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDGMMethodsForClassNode(StaticTypeCheckingSupport.java:166)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDGMMethodsByNameAndArguments(StaticTypeCheckingSupport.java:877)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDGMMethodsByNameAndArguments(StaticTypeCheckingSupport.java:864)
	at org.codehaus.groovy.transform.sc.transformers.BooleanExpressionTransformer$OptimizingBooleanExpression.visit(BooleanExpressionTransformer.java:148)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateNormalTernary(BinaryExpressionHelper.java:844)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateTernary(BinaryExpressionHelper.java:869)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitTernaryExpression(AsmClassGenerator.java:572)
	at org.codehaus.groovy.ast.expr.TernaryExpression.visit(TernaryExpression.java:43)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:313)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesBinaryExpressionMultiTypeDispatcher.evaluateEqual(StaticTypesBinaryExpressionMultiTypeDispatcher.java:222)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitDeclarationExpression(AsmClassGenerator.java:577)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:86)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:564)
	at org.codehaus.groovy.ast.stmt.ionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:510)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:374)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:331)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:451)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1063)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:185)
	at org.codehaus.groovy.control.CompilationUnit$16.call(CompilationUnit.java:805)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1047)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:583)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:561)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:538)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:119)
	at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:40)
	atadle.api.internal.tasks.compile.daemon.CompilerDaemonServer.execute(CompilerDaemonServer.java:53)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
{noformat};;;","10/Jun/22 15:13;lawsonjl;Still seeing this issue when building an artifact with Gradle 7.4.2, which is running Groovy 3.0.9.

However, the compilation classpath for the artifact contains Groovy 2.5.17, not Groovy 3.0.9. (Not sure which of the two is relevant here)

 ;;;","10/Jun/22 23:29;emilles;I think the project/target classpath is the proper one to use. If you are concerned about any issues that may arise it is best to use the same groovy major version for compile and runtime. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[Static type checking] - Reference to method is ambiguous. Cannot choose between,GROOVY-6804,12817479,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,bsideup,bsideup,19/May/14 10:14,22/Jan/17 06:40,14/Jul/23 06:01,11/Jun/14 07:37,2.3.1,,,,,,,,,,,,,,,,,2.3.3,,,,Static Type Checker,,,,0,,,,,,,"When there are 2 (or more) overloaded generic methods Groovy always checking only first one.

See pull request with @NotYetImplemented test case:
https://github.com/groovy/groovy-core/pull/421",,bsideup,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8059,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-19 10:14:21.0,,,,,,,,,,"0|i2bq1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic: ListAssignment for String takes precendence over Coercion when statically compiling,GROOVY-6803,12817566,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,tkruse,tkruse,19/May/14 08:03,26/Jan/23 22:21,14/Jul/23 06:01,08/Oct/21 19:20,2.4.0-rc-1,,,,,,,,,,,,,,,,,2.5.22,3.0.10,4.0.0-beta-2,,Static compilation,,,,0,,,,,,,"May or may not be a bug, to be decided.
Also see http://jira.codehaus.org/browse/GROOVY-6802

To reproduce:

import groovy.transform.CompileStatic

{code}@CompileStatic
class Foo {
  def static main(String[] args) {
    String b = [""foo""]
    assert b == ""[foo]""
  }
}{code}

Assumption: This should succeed, List probably should be coerced into String via toString() as is done without @CompileStatic.",,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6802,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-19 08:03:57.0,,,,,,,,,,"0|i2c907:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic: ListAssignment takes precedence over Coercion when statically compiling,GROOVY-6802,12811660,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,tkruse,tkruse,19/May/14 08:01,26/Jan/23 22:21,14/Jul/23 06:01,08/Oct/21 19:19,2.4.0-rc-1,,,,,,,,,,,,,,,,,2.5.22,3.0.10,4.0.0-beta-2,,Static compilation,,,,0,,,,,,,"Observed on 2.2.2, but maybe affects all releases. To reproduce:

import groovy.transform.CompileStatic

{code}@CompileStatic
class Foo {
  def static main(String[] args) {
    boolean b = [false]
    assert b
  }
}{code}

fails, but should succeed given List should be coerced to Boolean via asBoolean()

Also see discussion at 
http://comments.gmane.org/gmane.comp.lang.groovy.user/64604",,emilles,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6803,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 08 17:43:19 UTC 2021,,,,,,,,,,"0|i2ce2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Oct/21 17:43;emilles;{{boolean}} is seen as abstract so list assignment checks are skipped.  However {{Boolean}} is not and requires a change.  Also, map assignment could benefit from the same allowances.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The AntlrParserPlugin format hook (-Dantlr.ast=format) is corrupted by jarjar,GROOVY-6801,12817588,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,19/May/14 06:23,07/Apr/15 19:06,14/Jul/23 06:01,19/May/14 06:31,,,,,,,,,,,,,,,,,,2.3.1,,,,,,,,0,,,,,,,Under some cisrmstances the {{antlr.ast}} system property is being changed by jarjar into {{groovyjarjarantlr.ast}}.,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-19 06:23:15.0,,,,,,,,,,"0|i2cjxb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compilation error when calling method that has Optional<Closure> parameter,GROOVY-6800,12816955,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,robfletcher,robfletcher,19/May/14 03:39,14/Dec/15 18:08,14/Jul/23 06:01,14/Dec/15 18:07,2.3.0,2.4.0-rc-1,,,,,,,,,,,,,,,,2.3.11,2.4.2,,,Static Type Checker,,,,0,,,,,,,"I'm seeing a strange issue where if I try to call a method with an {{Optional<Closure>}} parameter from a type-checked context using {{Optional.of(someClosure)}} I get a compilation error. Other type parameters work fine in the same context and weirdly so does {{Optional.absent()}}.

I've attached 3 scripts that demonstrate the problem.

* _FailingWithClosure.groovy_ shows the problem occurring. I have a method that accepts {{Optional<Closure>}} and two statically compiled methods that call it, one with {{Optional.of(someClosure)}} and one with {{Optional.absent()}}.
* _WorkingWithString.groovy_ is the same code but with {{String}} type parameters instead of {{Closure}}. It works fine.
* _WorkingWithClosureAndCast.groovy_ shows that if I explicitly cast the argument to {{Optional<Closure>}} it works.",,fletcherr,jwagenleitner,melix,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"19/May/14 03:39;FailingWithClosure.groovy;https://issues.apache.org/jira/secure/attachment/12722673/FailingWithClosure.groovy","19/May/14 03:39;WorkingWithClosureAndCast.groovy;https://issues.apache.org/jira/secure/attachment/12723103/WorkingWithClosureAndCast.groovy","19/May/14 03:39;WorkingWithString.groovy;https://issues.apache.org/jira/secure/attachment/12722206/WorkingWithString.groovy",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 14 18:05:19 UTC 2015,,,,,,,,,,"0|i2cm0f:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"19/May/14 05:48;melix;Confirmed on latest Groovy sources.;;;","13/Dec/15 02:56;jwagenleitner;I tested the {{FailingWithClosure.groovy}} script and it successfully compiled and ran in 2.3.11 and 2.4.2+.  I would have resolved this ticket but since you [~melix] were assigned I wasn't sure if I should.;;;","14/Dec/15 18:05;pascalschumacher;Thanks for looking into this John. All static compiler / static type checking issues are assigned to Cédric when created, but that does mean he is currently working on them. Feel free to close issues that are not relevant anymore, even if they are assigned to somebody. If the assignee feels that the issue should not be closed he can always reopen the issue later on.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot static compile for..in when List interface is extended,GROOVY-6799,12814595,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,yukoba,yukoba,19/May/14 02:04,17/Dec/14 13:25,14/Jul/23 06:01,22/Oct/14 13:10,2.3.0,2.3.1,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Static compilation,,,,1,,,,,,,"Cannot compile this code in 2.3.0.

{code}
import groovy.transform.CompileStatic

@CompileStatic
class ForInTest {
    static interface List2<E> extends List<E> {}
    static class ArrayList2<E> extends ArrayList<E> implements List2<E> {}
    static List2 list = new ArrayList2()

    static void main(String[] args) {
        for (def e in list) {}
    }
}
{code}

The error message is this.
{quote}
Line 10, expecting casting to java.util.Iterator <E extends java.lang.Object> but operand stack is empty
{quote}

Maybe this problem is related to GROOVY-6791",,pschumacher,yukoba,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 22 13:10:49 UTC 2014,,,,,,,,,,"0|i2cplb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Oct/14 13:10;pschumacher;Works with current master, so I'm resolving this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Fix autocompletion of map entries in Groovy shell,GROOVY-6798,12817590,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,pschumacher,pschumacher,17/May/14 06:54,28/May/14 03:04,14/Jul/23 06:01,21/May/14 16:05,2.3.0,,,,,,,,,,,,,,,,,2.3.2,,,,Groovysh,,,,0,,,,,,,"Maps can contains strings with characters that can be interpreted differently,
to prevent it, completions of such entries will be surround with double quotes ("").

Special characters in completions should be escaped.

pull request: [https://github.com/groovy/groovy-core/pull/419]
",,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 21 16:05:00 UTC 2014,,,,,,,,,,"0|i2budr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/May/14 16:05;pschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MarkupTemplateEngine should allow custom template resolvers,GROOVY-6797,12817484,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,16/May/14 10:23,20/May/14 05:31,14/Jul/23 06:01,16/May/14 10:40,2.3.0,,,,,,,,,,,,,,,,,2.3.1,,,,Templating,,,,0,,,,,,,"The template engine doesn't allow custom template resolvers, making it impossible to use template caching in frameworks like Spring MVC which use their own locale resolving systems.

By allowing the template engine to provide its own template resolver, we solve this issue.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-16 10:23:12.0,,,,,,,,,,"0|i2bmlj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MarkupTemplateEngine won't cache templates,GROOVY-6795,12817562,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,16/May/14 09:23,20/May/14 05:31,14/Jul/23 06:01,16/May/14 10:41,2.3.0,,,,,,,,,,,,,,,,,2.3.1,,,,,,,,0,,,,,,,"The MarkupTemplateEngine doesn't cache template entries. While this can be worked around by an application for the outermost templates, includes will fail caching, which is very bad.
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-16 09:23:56.0,,,,,,,,,,"0|i2bvav:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Access forbidden can be triggered in MarkupTemplateEngine,GROOVY-6794,12817556,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,16/May/14 08:00,20/May/14 05:31,14/Jul/23 06:01,16/May/14 08:05,2.3.0,,,,,,,,,,,,,,,,,2.3.1,,,,Templating,,,,0,,,,,,,"The following template fails at runtime:

{code}
messages.each { message ->
    yield message.summary
}
{code}

If {{messages}} is of type {{Message}} where {{Message}} is:

{code}
class Message {
        private String summary

        String getSummary() {
            return summary
        }

        void setSummary(final String summary) {
            this.summary = summary
        }
    }
{code}

It fails with: 

{noformat}
Access to java.lang.Object#summary is forbidden
{noformat}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 16 08:06:34 UTC 2014,,,,,,,,,,"0|i2cfnz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/May/14 08:06;melix;https://github.com/groovy/groovy-core/commit/c2f5082c24c6efaa112bac5e827b44eb1ad9f648;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Module descriptors should be read in UTF-8,GROOVY-6793,12811666,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,guillaume,guillaume,16/May/14 07:44,20/May/14 05:31,14/Jul/23 06:01,16/May/14 07:53,2.2.2,2.3.0,,,,,,,,,,,,,,,,2.2.3,2.3.1,2.4.0-beta-1,,,,,,0,,,,,,,"The Spring Boot team recently logged the following issue:
https://github.com/spring-projects/spring-boot/issues/879#issuecomment-43316306

Someone runs Groovy on a mainframe server whose default encoding is EBCDIC. The ASTTransformationVisitor loads the module descriptors with the default platform encoding (as no charset is specified), and modules can't be loaded as the descriptor read contain odd looking characters.",IBM mainframe,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-16 07:44:24.0,,,,,,,,,,"0|i2csu7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassFormatError if a method has dots within its name,GROOVY-6792,12817580,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mxm-groovy,mxm,16/May/14 03:29,22/May/22 16:02,14/Jul/23 06:01,08/Mar/17 05:56,2.2.1,2.4.0-rc-1,,,,,,,,,,,,,,,,2.4.10,,,,Compiler,,,,0,ClassFormatError,,,,,,"I've got a ClassFormatError trying to run something like this:
{code}
class ATest extends TestCase {
  void 'test methods with dots within its name.dot'() {}
}
{code} 

Original source is https://github.com/JetBrains/intellij-community/blob/master/java/java-tests/testSrc/com/intellij/refactoring/RenameSuggestionsTest.groovy

Currently, the code at the above link works because all dots are replaced with underscores.
Reproduced on Win 8 with Java 1.8 and Groovy 2.2.1. Can't reproduce on Mac with any Java.

 

",,daniel_sun,githubbot,mxm,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 14 11:53:32 UTC 2017,,,,,,,,,,"0|i2bwhr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Feb/17 14:51;daniel_sun;parentheses are required when declaring methods.

The correct code should be as follows:
{code}
class ATest extends TestCase {
  void 'test methods with dots within its name.dot'() {}
}
{code};;;","27/Feb/17 14:44;paulk;[~daniel_sun] I believe it's just a typo in the above snippet. If you look at the link, all the examples have parentheses. And 2.5.0-SNAPSHOT still gives ClassFormatError for your example with the parentheses. To allow the dot we'd need to encode it somehow. I suspect the easiest thing for now would just be to disallow dots for the time being and give a friendly error message.;;;","27/Feb/17 14:47;paulk;I fixed what I believe was the typo in the original description.;;;","27/Feb/17 15:40;daniel_sun;>  I suspect the easiest thing for now would just be to disallow dots for the time being and give a friendly error message.
agreed :);;;","28/Feb/17 03:19;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/505

    GROOVY-6792: ClassFormatError if a method has dots within its name

    Provide a friendly error message for now - we can remove (some of) the checks if we find a good way to encode special chars

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy6792

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/505.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #505
    
----
commit 69b834b3da71fc6d755fda23f2a9621bf341d167
Author: paulk <paulk@asert.com.au>
Date:   2017-02-28T03:05:22Z

    GROOVY-6792: ClassFormatError if a method has dots within its name

----
;;;","08/Mar/17 05:51;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/505
;;;","08/Mar/17 05:56;paulk;Proposed PR merged. Now a friendly error message rather than ClassFormatError occurs for methods containing any of the following chars: ""."", "":"", ""/"", "";"", ""["", ""<"", "">"".;;;","14/Mar/17 11:53;paulk;This was found to break existing tests which included some of those special characters in the test names. My preliminary assessment is as follows:
Spock auto removes such names, so it isn't applicable to this discussion but non-spock tests could have those symbols when run using the gradle test runner - but not directly with groovy/groovyConsole. When I get time I'll do a more thorough assessment but for now the extra naming check is only turned on using a system property: groovy.compiler.strictNames. This system property is experimental and currently defaults to false (off = status quo). A future version of Groovy may change this system property to default to true or may re-enable the extra check all the time if some other workaround is found.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Cannot compile Map<K,V> == null",GROOVY-6791,12817447,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,yukoba,yukoba,14/May/14 14:45,17/Dec/14 13:25,14/Jul/23 06:01,23/Oct/14 14:09,2.3.0,2.3.1,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Static Type Checker,,,,0,,,,,,,"I cannot compile this code with 2.3.0.

{code}
import groovy.transform.TypeChecked

@TypeChecked
class TypeTest {
    static interface Map2<K,V> extends Map<K,V> {}

    static void main(String[] args) {
        Map2 map = null
        if (map == null) println ""map is null""
    }
}
{code}

The error message is 
{quote}
Error:(9, 13) Groovyc: [Static type checking] - Reference to method is ambiguous. Cannot choose between [boolean java.util.Map#equals(java.util.Map), boolean java.util.Map <K extends java.lang.Object, V extends java.lang.Object>#equals(java.lang.Object)]
{quote}

I can compile if I change it to this.
{code}if (map == (Object) null){code}

Also I can compile this too.
{code}
Map map = null
if (map == null) println ""map is null""
{code}",,blackdrag,candrews,melix,pschumacher,yukoba,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 23 14:09:49 UTC 2014,,,,,,,,,,"0|i2c0lj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"21/May/14 03:02;melix;Confirmed on 2.3.1.;;;","11/Jun/14 04:52;blackdrag;given code like this
{code:Java}
  def bar(String s){1}
  def bar(Object o){2}
  @CompileStatic
  def foo(){bar(null)
{code}
You will receive a similar error. That is because unlike dynamic Groovy the static compiler cannot use the runtime type, thus it makes no sense to make an exception just for null here to keep consistency. 

The for you unexpected thing probably is that there is an Map#equals(Map) extension method and not only the normal equals(Object) method.;;;","11/Jun/14 05:03;yukoba;Is there any problem to regard the type of uncasted null as java.lang.Object?
;;;","11/Jun/14 05:15;yukoba;This Java code returns 2. Maybe this problem is complicated.

{code:Java}
public class NullTest {
    static int method(Object arg) { return 1; }
    static int method(String arg) { return 2; }

    @Test
    public void test() {
        System.out.println(method(null));
    }
}
{code};;;","11/Jun/14 05:24;blackdrag;ok, I take my argument back;;;","11/Jun/14 05:27;blackdrag;If we follow Groovy we should make the argument Object, if we follow Java, then we should make it String. For me it should stay an error, to be more in line with declared types.;;;","11/Jun/14 06:02;yukoba;Thank you for reopening.

Another problem is for this Groovy code.
I checked with javap -c MapTest.class.
""6: ifnonnull     13"" is used for ""map == null"".
IntelliJ IDEA thinks DefaultGroovyMethod.equals(Map self, Map other) is called,
but maybe this is wrong too.
What is correct?

{code:Java}
@CompileStatic
class MapTest {
    @Test
    void test() {
        Map map = null
        println (map == null)
    }
}
{code}

{code}
  public void test();
    Code:
       0: aconst_null   
       1: astore_1      
       2: aload_1       
       3: pop           
       4: aload_0       
       5: aload_1       
       6: ifnonnull     13
       9: iconst_1      
      10: goto          14
      13: iconst_0      
      14: invokestatic  #36                 // Method java/lang/Boolean.valueOf:(Z)Ljava/lang/Boolean;
      17: invokestatic  #42                 // Method org/codehaus/groovy/runtime/DefaultGroovyMethods.println:(Ljava/lang/Object;Ljava/lang/Object;)V
      20: aconst_null   
      21: pop           
      22: return        
{code}
;;;","11/Jun/14 06:16;yukoba;And also I think DefaultGroovyMethods.equals(Map self, Map other) should be DefaultGroovyMethods.equals(Map self, Object other). Same to 6 other DefaultGroovyMethods.equals().
;;;","23/Oct/14 14:09;pschumacher;According to blackdrag this works on master, so I'm closing it.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Starting groovysh with groovysh.rc fails,GROOVY-6790,12817540,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tkruse,tkruse,14/May/14 11:24,20/May/14 05:31,14/Jul/23 06:01,15/May/14 07:00,2.3.0,,,,,,,,,,,,,,,,,2.3.1,,,,Groovysh,,,,1,,,,,,,"To fix, in Groovysh.groovy:

-            Command command = registry['load'] as Command
+            Command command = registry[':load'] as Command

But several other bugs are likely to exist due to bad practice of using repeated String literals to refer to commands in the command Registry.",,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 15 02:32:36 UTC 2014,,,,,,,,,,"0|i2br9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/May/14 02:32;tkruse;See https://github.com/groovy/groovy-core/pull/417
for fix;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Fix potential DoS attack with JSON parser,GROOVY-6789,12817555,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,14/May/14 04:18,20/May/14 05:31,14/Jul/23 06:01,14/May/14 04:19,2.2.2,2.3.0,,,,,,,,,,,,,,,,2.3.1,,,,,,,,0,,,,,,,See PR for details: https://github.com/groovy/groovy-core/pull/416,,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-14 04:18:47.0,,,,,,,,,,"0|i2c7wv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
type checker does not check generics bounds of wildcards properly,GROOVY-6787,12817567,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,blackdrag,blackdrag,13/May/14 09:48,22/Feb/16 20:48,14/Jul/23 06:01,23/Dec/15 08:59,2.2.2,2.3.0,2.4.0-rc-1,,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,,,,,,,"{code:Java}
public <T extends List<CharSequence>> void bar(T a){}
bar([new Object()])
{code}
This should not compile because Object is no CharSequence, but it does, because the type checker will simply ignore the bound and set T to LinkedList<Object>",,blackdrag,fpavageau,githubbot,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 23 08:59:03 UTC 2015,,,,,,,,,,"0|i2bphz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Dec/15 22:19;githubbot;GitHub user fpavageau opened a pull request:

    https://github.com/apache/groovy/pull/221

    GROOVY-6787 Compare arguments with the generic bounds

    The type inference on arguments shouldn't override the types of the
    parameters, especially their bounds. This prevented the bound checks from
    occurring.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fpavageau/groovy GROOVY-6787

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/221.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #221
    
----
commit 5cb1a6119279895f877ba82144c34675e70f8aeb
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-12-22T21:47:40Z

    GROOVY-6787 Compare arguments with the generic bounds
    
    The type inference on arguments shouldn't override the types of the
    parameters, especially their bounds. This prevented the bound checks from
    occurring.

----
;;;","23/Dec/15 08:56;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/221
;;;","23/Dec/15 08:59;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
2.3.0 CompileStatic regressions,GROOVY-6786,12817552,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,bsideup,bsideup,12/May/14 17:00,20/May/14 05:31,14/Jul/23 06:01,15/May/14 09:38,2.3.0,,,,,,,,,,,,,,,,,2.3.1,,,,Static compilation,Static Type Checker,,,0,,,,,,,"Last Groovy version (2.3.0) brings to our project few compilation errors, which are good in Java version, looks like CompileStatic bugs.

I created test cases with @NotYetImplemented and submitted PR to keep them with others.


See https://github.com/groovy/groovy-core/pull/415",,blackdrag,bsideup,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 15 09:39:38 UTC 2014,,,,,,,,,,"0|i2coev:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"15/May/14 09:38;blackdrag;that was actually 3 different issues, but all fixed now;;;","15/May/14 09:39;bsideup;Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem with GroovyConsole allow interruption and @CompileStatic,GROOVY-6784,12817564,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,12/May/14 07:57,28/May/14 03:03,14/Jul/23 06:01,21/May/14 07:59,2.3.0,,,,,,,,,,,,,,,,,2.2.3,2.3.2,,,,,,,0,,,,,,,"When running the following sample in Groovy Console, with ""allow interruption"" checked:
{code}
@Grab('com.netflix.rxjava:rxjava-groovy:0.18.1')

import groovy.transform.CompileStatic
import org.junit.Test

import rx.Observable

@CompileStatic
class Test1 {

    @Test
    void test1() {
        Observable.from([""mark"", ""perry""]).subscribe({ println(""item: $it"") })
    }

}
{code}
I get the following stacktrace:
{code}
JUnit 4 Runner, Tests: 1, Failures: 1, Time: 8
Test Failure: test1(Test1)
rx.exceptions.OnErrorNotImplementedException: Cannot cast object 'Test1@4b7d52f7' with class 'Test1' to class 'java.lang.Thread'
	at rx.Observable$26.onError(Observable.java:6015)
	at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:125)
	at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:94)
	at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:109)
	at rx.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:43)
	at rx.operators.OnSubscribeFromIterable.call(OnSubscribeFromIterable.java:29)
	at rx.Observable.subscribe(Observable.java:6302)
	at rx.Observable.subscribe(Observable.java:6006)
	at Test1.test1(ConsoleScript35:13)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runners.Suite.runChild(Suite.java:127)
	at org.junit.runners.Suite.runChild(Suite.java:26)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:138)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:128)
	at org.junit.runner.JUnitCore.runClasses(JUnitCore.java:73)
	at sun.reflect.GeneratedMethodAccessor304.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1318)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:927)
	at org.codehaus.groovy.vmplugin.v5.JUnit4Utils.realRunJUnit4Test(JUnit4Utils.java:84)
	at sun.reflect.GeneratedMethodAccessor303.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1318)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:927)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:77)
	at groovy.lang.GroovyShell.runJUnit4Test(GroovyShell.java:378)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:281)
	at groovy.lang.GroovyShell.run(GroovyShell.java:502)
	at groovy.lang.GroovyShell.run(GroovyShell.java:481)
	at groovy.lang.GroovyShell.run(GroovyShell.java:164)
	at groovy.lang.GroovyShell$run$1.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:977)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor288.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure.call(Closure.java:417)
	at groovy.lang.Closure.run(Closure.java:504)
	at java.lang.Thread.run(Thread.java:745)
Caused by: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'Test1@4b7d52f7' with class 'Test1' to class 'java.lang.Thread'
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnSAM(DefaultTypeTransformation.java:392)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnNumber(DefaultTypeTransformation.java:306)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:227)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:599)
	at Test1$_test1_closure1.doCall(ConsoleScript35)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
	at groovy.lang.Closure.call(Closure.java:423)
	at org.codehaus.groovy.runtime.ConvertedClosure.invokeCustom(ConvertedClosure.java:51)
	at org.codehaus.groovy.runtime.ConversionHandler.invoke(ConversionHandler.java:81)
	at com.sun.proxy.$Proxy16.call(Unknown Source)
	at rx.Observable$26.onNext(Observable.java:6020)
	at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:102)
	... 69 more

Result: org.junit.runner.Result@5e359fba
{code}
Which seems to be a problem with thread interruption and static compilation.",Groovy 2.3.0 / Java 8,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-12 07:57:32.0,,,,,,,,,,"0|i2c7yf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BUG! exception in phase 'class generation',GROOVY-6782,12817474,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pablo72,pablo72,11/May/14 15:21,20/May/14 05:31,14/Jul/23 06:01,13/May/14 08:48,2.3.0,,,,,,,,,,,,,,,,,2.3.1,,,,Static compilation,,,,0,,,,,,,"The following code fragment raise the compiler exception shown below

{noformat}
    @CompileStatic
    class ForLoop {

        protected List<String> columnsHeader

        def foo() {

            def line = 'hello,world'
            def tokens = splitString(line)
            for( int i=0; i<tokens.length; i++ )
                tokens[i] = tokens[i].trim()

            if( columnsHeader ) {
                def map = [:]
                for( int i=0; i<columnsHeader.size(); i++ )
                    map[ columnsHeader[i] ] = i<tokens.size() ? tokens[i] : null
                tokens = map
            }
        }

        static String[] splitString(String str) {  return null }

    }
{noformat}

{noformat}
Error:Groovyc: BUG! exception in phase 'class generation' in source unit '/Users/pditommaso/workspace/groovy_2_3/src/main/groovy/ForLoop.groovy' At line 16 column 25
On receiver: tokens with message: getAt and arguments: i
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesCallSiteWriter.makeSingleArgumentCall(StaticTypesCallSiteWriter.java:611)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeSingleArgumentCall(InvocationWriter.java:571)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateBinaryExpression(BinaryExpressionHelper.java:526)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionMultiTypeDispatcher.evaluateBinaryExpression(BinaryExpressionMultiTypeDispatcher.java:194)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:242)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:565)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter$CheckcastReceiverExpression.visit(StaticInvocationWriter.java:546)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeDirectMethodCall(InvocationWriter.java:141)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeDirectMethodCall(StaticInvocationWriter.java:252)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeDirectCall(InvocationWriter.java:252)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:351)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:98)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.makeCall(StaticInvocationWriter.java:507)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:82)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:421)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeInvokeMethod(StaticInvocationWriter.java:87)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:686)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:313)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesBinaryExpressionMultiTypeDispatcher.evaluateEqual(StaticTypesBinaryExpressionMultiTypeDispatcher.java:222)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:81)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:565)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:547)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeForLoopWithClosureList(StatementWriter.java:186)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeForStatement(StatementWriter.java:91)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitForLoop(AsmClassGenerator.java:497)
	at org.codehaus.groovy.ast.stmt.ForStatement.visit(ForStatement.java:47)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:493)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:357)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:314)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:434)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1063)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:177)
	at org.codehaus.groovy.control.CompilationUnit$16.call(CompilationUnit.java:805)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1047)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:583)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:561)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:538)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:54)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:87)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:100)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:121)

{noformat}",,melix,paolodt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon May 12 07:12:48 UTC 2014,,,,,,,,,,"0|i2cnbj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/May/14 04:05;pablo72;Just a note about the code example. The compile should report an error, because the line: 

{{tokens = map}}

try to assign a Map object to ""tokens"" which type is ""String[]"" since it is inferred by the above assignment: 

{{def tokens = splitString(line)}}


;;;","12/May/14 07:12;melix;Since {{tokens}} is declared using {{def}}, it's not an error. It only makes the flow type change.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Compound assignments to ""mixed type"" properties don't type-check",GROOVY-6781,12817477,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pniederw,pniederw,11/May/14 13:00,21/Mar/15 07:12,14/Jul/23 06:01,13/Mar/15 14:35,2.3.0,,,,,,,,,,,,,,,,,2.4.0,,,,Static Type Checker,,,,0,,,,,,,"{code}
class Foo {
  // ""mixed type"" property
  String getBar() {}
  void setBar(Object bar) {}
}

// assume script is @TypeChecked

def foo = new Foo()

// type checks
foo.bar = foo.bar + ""def""

// does not type check
// [Static type checking] - Cannot find matching method java.lang.Object#plus
foo.bar += ""def""
{code}",,melix,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 13 14:35:14 UTC 2015,,,,,,,,,,"0|i2clrz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Mar/15 14:35;melix;It doesn't throw an error anymore, I assume this was fixed with multisetter support in 2.4.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Groovysh "":purge all"" and "":show all"" commands fail",GROOVY-6779,12813360,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,pschumacher,pschumacher,10/May/14 02:47,20/May/14 05:31,14/Jul/23 06:01,10/May/14 08:53,2.3.0,,,,,,,,,,,,,,,,,2.3.1,,,,Groovysh,,,,0,,,,,,,"{quote}Groovy Shell (2.3.0, JVM: 1.7.0_55)
Type ':help' or ':h' for help.
-----------------------------------------------------------------------------------------------------------------------------------------------------
groovy:000> :purge all
Failed to load delegate function: groovy.lang.MissingFieldException: No such field: do_all for class: org.codehaus.groovy.tools.shell.commands.PurgeCo
mmand{quote}

{quote}Groovy Shell (2.3.0, JVM: 1.7.0_55)
Type ':help' or ':h' for help.
-----------------------------------------------------------------------------------------------------------------------------------------------------
groovy:000> :show all
Failed to load delegate function: groovy.lang.MissingFieldException: No such field: do_all for class: org.codehaus.groovy.tools.shell.commands.ShowCom
mand{quote}",,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-05-10 02:47:15.0,,,,,,,,,,"0|i2bnp3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"groovy scripts file path name containing ""e-n"" raises ""java.io.IOException: Invalid argument""",GROOVY-6778,12817579,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,tan9,tan9,09/May/14 15:52,26/Jul/14 01:44,14/Jul/23 06:01,23/Jul/14 02:54,2.3.0,,,,,,,,,,,,,,,,,2.3.5,2.4.0-beta-2,,,command line processing,,,,1,,,,,,,"Reproducing steps:
1. Create a groovy script named ""e-n.groovy"" (contents doesn't matter)
2. Run ""groovy.bat e-n.groovy"", bang!

{code}
Caught: java.io.IOException: Invalid argument
java.io.IOException: Invalid argument
{code}","Windows Server 2012 / Windows 8.1
JDK 7 / 8
Groovy 2.2.1 / 2.3.0",fintelia,paulk,stevedonie,tan9,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 23 02:54:04 UTC 2014,,,,,,,,,,"0|i2c4iv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Jun/14 10:24;stevedonie;Did some debugging on this and the problem appears to be having ""-n"" somewhere in the path to the script. In startGroovy.bat, there is this code:

{noformat}
rem horrible roll your own arg processing inspired by jruby equivalent

rem escape minus (-d), quotes (-q), star (-s).
set _ARGS=%*
if not defined _ARGS goto execute
set _ARGS=%_ARGS:-=-d%
set _ARGS=%_ARGS:""=-q%
set _ARGS=%_ARGS:?=-n%
{noformat}

and then later on there is this:
{noformat}
rem now unescape -q, -s, -d
set _ARG=%_ARG:-s=*%
set _ARG=%_ARG:-q=""%
set _ARG=%_ARG:-d=-%
set _ARG=%_ARG:-n=?%
{noformat}

So I think the problem would also be exposed by having a script named ""anything-s.groovy"" ""anything-d.groovy"" or ""anything-q.groovy"" or ""anything-n.groovy"". I also experienced the problem when I passed a fully qualified path to a script that had a ""-n"" in it, like this:

{noformat}
groovy.bat c:\test-new\script.groovy
{noformat}




;;;","22/Jul/14 12:43;fintelia;Those are the relevant lines of code, though you did not describe exactly what is going wrong. The very first replacement changes all dashes into ""-d"" to prevent them from interfering with any of the other conversions. The second block then converts instances of ""-d"" back into dashes:

{noformat}""anything-s.groovy"" -> ""anything-ds.groovy"" -> ""anything-s.groovy""{noformat}

The issue is that ""-n"" is converted into a question mark _after_ the ""-d"" to dash replacement:

{noformat}""anything-n.groovy"" -> ""anything-dn.groovy"" -> ""anything-n.groovy"" -> ""anything?.groovy""{noformat}

It is simply a matter of swapping those last two lines. I have submitted a [pull request|https://github.com/groovy/groovy-core/pull/490/] that does just that.;;;","23/Jul/14 02:54;paulk;Thanks for raising the issue. It should be fixed in the next release. And thanks to Jonathan for the PR.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inner class causes VerifierError,GROOVY-6777,12817572,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,graemerocher,graemerocher,09/May/14 09:08,24/Nov/19 02:45,14/Jul/23 06:01,31/Oct/19 12:10,2.3.0,,,,,,,,,,,,,,,,,3.0.0-rc-1,,,,,,,,0,,,,,,,"Steps to reproduce:

{code}
git clone git@github.com:grails-plugins/grails-resources.git
cd grails-resources
git checkout 0de76b489d83e43e6411cceaf28ff31d04620831
./grailsw test-app ResourceTagLibIntegTests
{code}

Exception:

{code}
| Failure:  testStashOfACustomTypeWithMultipleEntries(org.grails.plugin.resource.ResourceTagLibIntegTests)
|  java.lang.VerifyError: (class: org/grails/plugin/resource/ResourceTagLibIntegTests$FakeStashWriter, method: setInterceptor signature: (Lorg/codehaus/groovy/grails/test/support/GrailsTestInterceptor;)V) Incompatible object argument for function call
	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2483)
	at java.lang.Class.getDeclaredConstructors(Class.java:1891)
	at org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:46)
	at org.codehaus.groovy.util.LazyReference.get(LazyReference.java:33)
	at org.grails.plugin.resource.ResourceTagLibIntegTests.testStashOfACustomTypeWithMultipleEntries(ResourceTagLibIntegTests.groovy:231)
	a
{code}

The way I had to fix it was moving the inner class out of the outer class:

https://github.com/grails-plugins/grails-resources/commit/cd0e434b6dbc871dac11c34337561cbed956b200#diff-9222340082e4e1253d5a0d4ea60ddcd7L244",,graemerocher,jwagenleitner,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6809,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Mar 01 07:16:49 UTC 2015,,,,,,,,,,"0|i2btiv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Mar/15 07:16;pschumacher;may be related to [GROOVY-6809];;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"VerifierError in Groovy 2.3, doesn't happen in Groovy 2.2",GROOVY-6776,12813329,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,graemerocher,graemerocher,09/May/14 06:28,20/May/14 05:31,14/Jul/23 06:01,09/May/14 09:37,2.3.0,,,,,,,,,,,,,,,,,2.3.1,,,,Static Type Checker,,,,0,,,,,,,"I'm encountering a VerifierError with the following class:

https://github.com/grails-plugins/grails-tomcat8-plugin/blob/master/src/groovy/org/grails/plugins/tomcat/fork/ForkedTomcatServer.groovy

Stacktrace:

{code}
java.lang.VerifyError: (class: org/grails/plugins/tomcat/fork/ForkedTomcatServer, method: startSecure signature: ()V) Expecting to find integer on stack
	at org.grails.plugins.tomcat.TomcatServerFactory.createForked(TomcatServerFactory.groovy:45)
	at org.grails.plugins.tomcat.TomcatServerFactory.createForked(TomcatServerFactory.groovy)
	at org.grails.plugins.tomcat.TomcatServerFactory.createInline(TomcatServerFactory.groovy:36)
	at org.codehaus.groovy.grails.project.container.GrailsProjectRunner.runInline(GrailsProjectRunner.groovy:187)
	at org.codehaus.groovy.grails.project.container.GrailsProjectRunner.runApp(GrailsProjectRunner.groovy:123)
	at org.codehaus.groovy.grails.project.container.GrailsProjectRunner$runApp$0.call(Unknown Source)
{code}

Steps to reproduce with the attached app:

{code}
unzip new240.zip 
cd new240
./grailsw run-app
{code}",,blackdrag,graemerocher,guillaume,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"09/May/14 06:28;graemerocher;new240.zip;https://issues.apache.org/jira/secure/attachment/12723102/new240.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 09 09:37:45 UTC 2014,,,,,,,,,,"0|i2ced3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/May/14 06:38;graemerocher;Removing @CompileStatic from https://github.com/grails-plugins/grails-tomcat8-plugin/blob/master/src/groovy/org/grails/plugins/tomcat/fork/ForkedTomcatServer.groovy fixes the problem;;;","09/May/14 08:51;guillaume;Reproducible sample:
{code}
import groovy.transform.CompileStatic

@CompileStatic
class B {
    int i
    void startSecure(int i) {
        println i
        this.i = i
    }
}

@CompileStatic
class A {
    B b
    void startSecure() {
        b.startSecure null
    }
}

@CompileStatic 
def test() {
    def a = new A(b: new B())
    a.startSecure()
}

test()
{code};;;","09/May/14 09:03;guillaume;Simpler example from Jochen:
{code}
import groovy.transform.CompileStatic

void foo(int i) {}

@CompileStatic
void bar() {
    foo null
}

bar()
{code};;;","09/May/14 09:37;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyDoc reports Exception: groovy.lang.ReadOnlyPropertyException: Cannot set readonly property: comparator for class: java.util.TreeMap,GROOVY-6775,12817521,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,michaeli,michaeli,09/May/14 04:43,28/May/14 03:04,14/Jul/23 06:01,20/May/14 06:40,1.8.6,2.1.7,2.2.0,2.2.2,2.3.0,,,,,,,,,,,,,2.3.2,,,,GroovyDoc,,,,0,contrib,exception,help-requested,treemap,usertask,,"When starting and creating our help with groovydoc within a gradle build we got the following exception:
{noformat}
groovy.lang.ReadOnlyPropertyException: Cannot set readonly property: comparator for class: java.util.TreeMap
{noformat}

As a result no index-all.html file is generated, so we have no index and overview at all.

=> Stacktrace is attached

Gradle code:

{code}
def javaDocForHelp = task javadocForHelp(type: JavaExec, group:""documentation"") {
	description = ""This creates the documentation of the facade classes from the XYZ engine""
	// beware, the Groovydoc tool behaves strangely in some cases; e.g. if you change the order
	// of arguments or make a mistake, it might silently fail or ignore some parameters
	// for an explanation of the parameters, enter ""groovydoc -help"" on the command line
	def scriptingEngineSourceDirs = project("":XYZ-engine"").sourceSets.main.groovy.srcDirs
	scriptingEngineSourceDirs.each { inputs.dir(it) }
	ext.javadocDir = new File(docDir, ""javadoc"")
	outputs.dir(javadocDir)
	classpath configurations.compile.files
	main = ""org.codehaus.groovy.tools.groovydoc.Main""
	args ""-sourcepath"", scriptingEngineSourceDirs.join(File.pathSeparator)
	args ""-d"", javadocDir.path
	// packages
	args ""XYZ.scripting.facade""
	args ""XYZ.scripting.facade.security""
	args ""XYZ.scripting.facade.structure""
	args ""XYZ.utils""
	doFirst {
		javadocDir.mkdirs()
	}
}
{code}","Windows 7 Enterpirse 64 Bit, SP1, 16 GB RAM, Gradle 1.9",michaeli,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"09/May/14 04:43;michaeli;StacktraceGroovyDoc.txt;https://issues.apache.org/jira/secure/attachment/12723215/StacktraceGroovyDoc.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 20 06:49:27 UTC 2014,,,,,,,,,,"0|i2cmtz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/May/14 20:50;paulk;add code tags;;;","10/May/14 00:00;paulk;I was trying to replicate your issue. I used these build files against the groovy source tree:
{code:title=settings6775.gradle}
rootProject.name = 'groovy6775'
{code}
and
{code:title=build6775.gradle}
apply plugin: 'groovy'

buildDir = 'target'

repositories {
    mavenCentral()
}

dependencies {
    compile ""org.codehaus.groovy:groovy-all:2.3.0""
    compile ""org.fusesource.jansi:jansi:1.11""
    compile ""commons-cli:commons-cli:1.2""
}

sourceSets {
    main {
        groovy {
            srcDirs = [
                    'subprojects/groovy-swing/src/main/groovy',
                    'subprojects/groovy-swing/src/main/java'
            ]
        }
    }
}

task javadocForHelp(type: JavaExec, group:""documentation"") {
    description = ""This creates the documentation of some groovy swing classes""
    def scriptingEngineSourceDirs = rootProject.sourceSets.main.groovy.srcDirs
    scriptingEngineSourceDirs.each { inputs.dir(it) }
    ext.javadocDir = new File(buildDir, ""javadoc"")
    outputs.dir(javadocDir)
    classpath configurations.compile.files + sourceSets.main.runtimeClasspath
    main = ""org.codehaus.groovy.tools.groovydoc.Main""
    args ""-sourcepath"", scriptingEngineSourceDirs.join(File.pathSeparator)
    args ""-d"", javadocDir.path
    // packages
    args ""groovy.swing.binding""
    args ""groovy.swing.factory""
    doFirst {
        javadocDir.mkdirs()
    }
}
{code}
And ran this command:
{noformat}
> gradlew -b groovy6775.gradle -c settings6775.gradle javadocForHelp
{noformat}
And it seems to run without problems. Also, gradle's built-in groovydoc functionality seems to work fine for the groovy build.

Do you use any custom templates in your environment? Perhaps you are more familiar with the kind of thing that triggers the problem and can modify the standalone example above or prodice some alternative standalone example to help reproduce the problem?;;;","17/May/14 12:14;pschumacher;@Michael Inden:

It would be nice if you could answer Pauls questions. Thanks!;;;","19/May/14 10:02;michaeli;Hi,

i tried it with your demo and it worked for me (with just a few tiny example classes).
Seems to be no groovy problem but an error in our project build?!

There must by something strange in the preparation of the groovydoc task in our build.
I have to explore or ask one of our gradle gurus.The difference beetwen the plain example
an our project setup isn't obvious. I will post the reason as soon as i have got the solution.

Kind regards
Michael;;;","20/May/14 03:00;michaeli;Dear Groovy-Team,

First of all we do use the default GString templates groovy comes along with.
We could figure out the problem when using a debugger and reaching out for the generated GStringTemplate code which is compiled to a groovy script later on.
After this pinpointing the problem down to the template file ""index-all.html"".

One of our classes has a property called ""comparator"". 
The groovydoc and the index-all.html file with the following line 

entries[classLower] = """""" .... """"""

are producing the exception, because ""comparator"" ist used as ""classLower"" as porperty accesor instead
of an map access: When assigning via the supposed ""put"" ""entries[classLower] = "", whereas entries is a 
TreeMap, groovy obviously detects that ""comparator"" also is a private final field in TreeMap.
And here we go, groovy tries to set the ""property"" which is final and ends up in the described exception.



Fix: Replace one single line in the index-all.html-Template-File in grrovy (and/or improve groovy property acces logic, so that
       private final properties aren't accessed, when a map access is appropriate)

entries[classLower] = """"""
<dt><a href=""${classDoc.fullPathName}.html"" title=""${desc + packageOrInnerName}""><b>${classDoc.name()}</b></a> - ${desc}<a href=""./${packageName.replace('.', '/')}/package-summary.html"">${packageName}</a>
</dt><dd>${classDoc.firstSentenceCommentText()}</dd>""""""

===> 

entries.put(classLower, """"""
<dt><a href=""${classDoc.fullPathName}.html"" title=""${desc + packageOrInnerName}""><b>${classDoc.name()}</b></a> - ${desc}<a href=""./${packageName.replace('.', '/')}/package-summary.html"">${packageName}</a>
</dt><dd>${classDoc.firstSentenceCommentText()}</dd>"""""")


I think a temporary workaround would be to create copies of the default templates and use ""-stylesheetfile"", correct?

KInd regards
Christian & Michael
;;;","20/May/14 05:19;paulk;Yes, you can supply your own stylesheet files. Using put seems a worthwhile change. Do you want to create a PR or are you happy for one of us to do the change?;;;","20/May/14 05:27;michaeli;Hi Paul,

i tested this solution by proiding a jar file containg just the modified index-all.html and adding it to the classpath when generating help:

classpath ""C:/temp/modified_help.jar""

I would prefer if you do the change to groovy ;-)

Many thanx
Michael;;;","20/May/14 06:40;paulk;Made the change. Should be in 2.3.2. Thanks for reporting the original issue and debugging the cause.;;;","20/May/14 06:49;michaeli;Cool ;-);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BuilderASTTransformation uses wrong class loader to load builder strategy,GROOVY-6774,12817530,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pniederw,pniederw,08/May/14 19:23,28/May/14 03:03,14/Jul/23 06:01,21/May/14 04:29,2.3.0,,,,,,,,,,,,,,,,,2.3.2,,,,groovy-jdk,,,,2,,,,,,,"BuilderASTTransform loads builder strategies with the source unit's class loader, rather than the transform loader. As a result, compilation of code using @Builder fails in Gradle (and other tools that make a distinction between these class loaders). Solution is to use the transform loader, as for example done by TraitASTTransformation. ",,paulk,pniederw,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 21 04:29:43 UTC 2014,,,,,,,,,,"0|i2bzk7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/May/14 04:12;paulk;Should be fixed in master and the 2_3_X branch. If you have a chance to test, that would be great.;;;","19/May/14 12:08;pschumacher;As Paul fixed this issue for 2.3.1 I'm resolving it. Please reopen if the error still occurs. Thanks!;;;","19/May/14 19:33;paulk;Yes, I left it open because there is no test case which actually checks the loader being used and it wasn't easy to create such a test. I guess as long as it is working in gradle, we should be fine for now.;;;","21/May/14 00:39;pniederw;According to user feedback (http://forums.gradle.org/gradle/topics/the_new_builder_annotation_with_externalstrategy_in_groovy_2_3_1_still_result_in_compilation_error_if_build_with_gradle), `@Builder` now works when the default strategy is used, but stills fails when an explicit strategy is used. I think the problem is that `strategyClass.getTypeClass()` still loads the strategy class with the wrong class loader (needs to be loaded with transform loader).;;;","21/May/14 00:48;pniederw;(What I don't understand is why this is only a problem when a strategy is explicitly specified. Nevertheless, I'm pretty sure that getting rid of `strategyClass.getTypeClass()` will solve the problem.);;;","21/May/14 04:29;paulk;The isAssignableFrom check is now delayed and done on the class of the instance returned by the transform loader. Hopefully this should work in all scenarios.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Grapes broken in 2.3,GROOVY-6771,12811877,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,russel,russel,07/May/14 13:18,20/May/14 05:31,14/Jul/23 06:01,12/May/14 11:39,2.3.0,,,,,,,,,,,,,,,,,2.3.1,,,,Grape,,,,0,,,,,,,"The code:
{code}
#! /usr/bin/env groovy

@Grab('org.codehaus.groovyfx:groovyfx:0.4.0-SNAPSHOT')
import static groovyx.javafx.GroovyFX.start

import javafx.scene.paint.Color

start {
  stage title: 'Hello World', visible: true, {
    scene width: 250, height: 80, fill: Color.web('#d0c4b0'), {
      text x: 10, y: 30, text: 'Hello World.', font: '24pt ""Ocean Sans MT""'
    }
  }
}
{code}
when executed, cause the groovyfx-0.4.0-SNAPSHOT.jar artefact to be grabbed from my local Maven cache and put into the Grapes cache. However it failed with:
{quote}
Caused by: java.lang.ClassNotFoundException: groovyx.javafx.GroovyFX
	at javafx.application.Application.launch(Application.java:237)
{quote}
If I run the code with:
{quote}
groovy -cp .:$HOME/.groovy/grapes/org.codehaus.groovyfx/groovyfx/jars/groovyfx-0.4.0-SNAPSHOT.jar helloWorld_groovyfx_text.groovy
{quote}
Then it works as expected. This implies the artefact is fine but the Grapes manipulation of classpath is not.","Linux; Groovy master; GroovyFX master; JDK8u5",melix,paulk,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6768,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon May 12 10:15:27 UTC 2014,,,,,,,,,,"0|i2bxo7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/May/14 05:30;paulk;Might be a job for ""git bisect"" but do you happen to know the last known Groovy version where this worked? 2.2.2? 2.2.3-SNAPSHOT? One of the 2.3 betas? Ta.;;;","08/May/14 07:13;russel;Easier to use GVM and have lots of Groovy versions installed. 2.2.2 works fine, 2.3.0 fails, 2.3.1-SNAPSHOT fails.  Of course this doesn't help with the exact version of 2.3.0-SNAPSHOT. I'll see if I can do the bisect now that I have a known working version.;;;","12/May/14 10:15;melix;So bisect says:

{noformat}
cchampeau@ccvmware ~/DEV/PROJECTS/GITHUB/groovy-core (git::(no branch, bisect started on master)) $ git bisect good
06f50f537e488331dcbd11899b5381430c33504b is the first bad commit
commit 06f50f537e488331dcbd11899b5381430c33504b
Author: Jim White <james.paul.white@gmail.com>
Date:   Mon Feb 24 16:47:08 2014 -0800

    Make GroovyMain, GroovyShell, and GroovySocketServer more consistent in GroovyCodeSource usage, esp. wrt URL.
{noformat}

which leads us to think this bug is related to GROOVY-6768;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The method NioGroovyMethods#write does not truncate the content of a file,GROOVY-6770,12812126,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,pablo72,pablo72,07/May/14 10:38,20/May/14 05:31,14/Jul/23 06:01,10/May/14 16:08,2.3.0,,,,,,,,,,,,,,,,,2.3.1,2.4.0-beta-1,,,groovy-jdk,,,,0,,,,,,,"The write method should truncate any content of an existing file, instead currently it is appending the text to the current content. 

Begin so the following assertion is NOT satisfied: 

def path = Paths.get('example.text')
path.text = 'alpha'
path.text = 'beta'

assert path.text == 'beta'



",,paolodt,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 10 16:08:33 UTC 2014,,,,,,,,,,"0|i2cgef:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/May/14 16:08;pschumacher;Merged [pull request|https://github.com/groovy/groovy-core/pull/413]. Thanks for reporting and fixing this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unable to resolve resources from grapes through ClassLoader,GROOVY-6768,12817376,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,rec,rec,07/May/14 05:37,20/May/14 05:31,14/Jul/23 06:01,12/May/14 11:39,2.3.0,,,,,,,,,,,,,,,,,2.3.1,,,,Grape,,,,0,,,,,,,"With Groovy 2.3.0, is appears not to be possible to resolve resources from Grapes via the classloader.

I access the classloader through

{noformat}
Thread.currentThread().getContextClassLoader();
{noformat}

In Groovy 2.3.0, this returns a *org.codehaus.groovy.tools.RootLoader* which does not seem to know about Grapes.

In Groovy 2.2.2 and before, it returns a *groovy.lang.GroovyClassLoader* which knows about Grapes.

Resources are then resolved e.g. using

{noformat}
classloader.getResources(""META-INF/org.apache.uima.fit/types.txt"")
{noformat}

In Groovy 2.3.0, this returns no resources. In Groovy 2.2.2 it successfully locates the resources. This is with the same script, same Grape cache, same JDK, just different versions of Groovy used.

Related reports: 
* http://stackoverflow.com/questions/23504261/dkpro-groovy-usage-and-installation-with-uima
* https://issues.apache.org/jira/browse/UIMA-3808",,melix,rec,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6771,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon May 12 09:24:23 UTC 2014,,,,,,,,,,"0|i2c1cn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/May/14 09:24;melix;The commit which made the context class loader change is: https://github.com/groovy/groovy-core/commit/06f50f537e488331dcbd11899b5381430c33504b;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
collectEntries misleading error message,GROOVY-6766,12817546,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,dariusan,dariusan,07/May/14 02:22,28/Jul/14 20:21,14/Jul/23 06:01,28/Jul/14 05:34,2.2.1,,,,,,,,,,,,,,,,,2.3.6,2.4.0-beta-2,,,,,,,0,,,,,,,"Executing the following 
{code}
 [[1,'a'], [2,'b'], [3]].collectEntries()
{code}

leads to:

groovy.lang.MissingMethodException: No signature of method: java.util.ArrayList.getKey() is applicable for argument types: () values: []

It should rather throw an IllegalArgumentException

",,dariusan,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 28 05:34:48 UTC 2014,,,,,,,,,,"0|i2bs2f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Jul/14 05:34;paulk;The semantics for closures which return lists has now been made consistent with multiple assignment:
{code}
def (key, value) = listResultFromClosure
{code}
which means for your example above the key would be '3' and the value would be 'null'. Bad style at least but no longer prohibited. If your collector map doesn't handle null keys or values you will get an NPE or IllegalArgumentException.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem Referring To Statically Imported Constants,GROOVY-6764,12817549,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,brownj,brownj,06/May/14 21:12,01/Feb/17 23:19,14/Jul/23 06:01,01/Sep/16 22:49,2.1.9,2.4.0-rc-1,,,,,,,,,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"It appears that if a class implements an interface which declares constants, Groovy code which statically imports the constant from the class (not the interface) doesn't work.  I think this is supposed to work.  It does work from Java.  See the attached app in constantsquestion.zip which includes the following code.  Extract the .zip and run ""./gradlew test"" to see that the Java test passes and the Groovy test fails.

{code:borderStyle=solid|title=src/main/java/com/demo/Constants.java}
package com.demo;

public interface Constants {
    int ANSWER = 42;
}
{code}

{code:borderStyle=solid|title=src/main/java/com/demo/Helper.java}
package com.demo;

public class Helper implements Constants {
}
{code}

{code:borderStyle=solid|title=test/java/com/demo/JavaHelperTests.java}
package com.demo;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;
import static org.junit.Assert.assertEquals;
import static com.demo.Helper.ANSWER;

@RunWith(JUnit4.class)
public class JavaHelperTests {

    @Test
    public void testAccessingConstant() {
        // this test passes...
        assertEquals(42, ANSWER);
    }
}
{code}

{code:borderStyle=solid|title=test/groovy/com/demo/GroovyHelperSpec.groovy}
package com.demo

import spock.lang.Specification
import static com.demo.Helper.ANSWER

class GroovyHelperSpec extends Specification {

    void 'test referring to statically imported constant'() {
        // this test fails...
        expect:
        42 == ANSWER
    }
}
{code}

The error message from the Groovy spec is:

{noformat}
groovy.lang.MissingPropertyException: No such property: ANSWER for class: com.demo.GroovyHelperSpec
    at com.demo.GroovyHelperSpec.test referring to statically imported constant(GroovyHelperSpec.groovy:10)
{noformat}

Note that everything works fine from Groovy if the constant is imported from the interface instead of from the class which implements the interface.

Is this a bug?",,brownj,githubbot,paulk,ychulov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/May/14 21:12;brownj;constantsquestion.zip;https://issues.apache.org/jira/secure/attachment/12722197/constantsquestion.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 01 22:49:53 UTC 2016,,,,,,,,,,"0|i2c8k7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Aug/16 07:24;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/404

    GROOVY-6764: Problem Referring To Statically Imported Constants

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy6764

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/404.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #404
    
----
commit fb1ce06d4ea4685734238875f2aad8d99549dbe6
Author: paulk <paulk@asert.com.au>
Date:   2016-08-31T07:22:43Z

    GROOVY-6764: Problem Referring To Statically Imported Constants

----
;;;","01/Sep/16 22:47;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/404
;;;","01/Sep/16 22:49;paulk;Proposed PR merged. Thanks for spotting the issue Jeff.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy won't run in OSGI Java 7 environment,GROOVY-6762,12818304,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,guillaume,rburgst,rburgst,06/May/14 08:25,20/May/14 05:31,14/Jul/23 06:01,06/May/14 08:54,2.3.0,,,,,,,,,,,,,,,,,2.3.1,2.4.0-beta-1,,,,,,,0,,,,,,,"Currently the groovy-all-2.3.0 (as well as the indy) version require a Java 6 runtime environment, this is enforced by line 80 of {{gradle//assemble.gradle}}

{code}
            'Bundle-RequiredExecutionEnvironment': 'J2SE-1.6',
{code}

In my case I am running virgo on java 7 and therefore, the bundle will not load

{noformat}
gogo: BundleException: The bundle ""groovy-all_2.3.0 [154]"" could not be resolved. Reason: Missing Constraint: Bundle-RequiredExecutionEnvironment: J2SE-1.6
{noformat}

wouldn't it be possible to just remove this line?",Virgo Server 3.6.1 (@Java 7),guillaume,rburgst,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 06 09:12:18 UTC 2014,,,,,,,,,,"0|i2bpb3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/May/14 08:30;guillaume;Damn, so this is not a ""minimal"" requirement, but enforces exclusively JDK 6? :-(
As I'm not OSGi expert, is there a way to say JDK 6+ is needed?;;;","06/May/14 08:40;rburgst;wow, thats a fast response. I think it might actually be a problem in Virgo or the way that the runtime environment is specified. In my virgo configuration it supports

{noformat}
org.osgi.framework.executionenvironment = \
 OSGi/Minimum-1.0,\
 OSGi/Minimum-1.1,\
 J2SE-1.2,\
 J2SE-1.3,\
 J2SE-1.4,\
 J2SE-1.5,\
 JavaSE-1.6,\
{noformat}

As you can see the spelling for Java 1.6 is different as for 1.5. 

http://wiki.eclipse.org/Execution_Environments

lists also JavaSE-1.6

so it might actually just be a matter of changing

J2SE-1.6 to JavaSE-1.6;;;","06/May/14 08:54;guillaume;You're correct with the fact the label for Java SE 6 was wrong, and that's certainly why Virgo complains.

Talking with an OSGi expert, he told us that it's not strictly required to use that attribute anyway, as it's more for indicating that we don't encourage people to use a different JDK, but we're totally fine with people using Java SE 6 up to 9 even!

So I'm simply removing the line for now.;;;","06/May/14 08:57;rburgst;Thats great. Any ETA when a new version with a fix can be expected? 

For reference (just in case someone else is having the same problem): Virgo can be ""convinced"" to support also J2SE-1.6 as an execution environment by modifying

{{configuration/java6-server.profile}}

{code}
org.osgi.framework.executionenvironment = \
 OSGi/Minimum-1.0,\
 OSGi/Minimum-1.1,\
 J2SE-1.2,\
 J2SE-1.3,\
 J2SE-1.4,\
 J2SE-1.5,\
 JavaSE-1.6,\
 J2SE-1.6
{code}

just add the last line and virgo will stop complaining. Obviously having a proper 2.3.1 release would be even better!;;;","06/May/14 09:12;guillaume;No ETA yet for Groovy 2.3.1.
We'll wait a little bit to see if there are some regressions or critical issues that need fixing.
At least, what's nice is that you found a workaround, which will allow us to circumvent the problem till we release 2.3.1.
Thanks for reporting, and also for documenting the workaround above.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compiler doesn't respect contravariant type tokens,GROOVY-6761,12817519,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ldaley,ldaley,06/May/14 03:33,20/May/14 05:31,14/Jul/23 06:01,14/May/14 09:43,2.3.0,,,,,,,,,,,,,,,,,2.3.1,,,,Static Type Checker,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
class Thing {

  public <O> void contravariant(Class<? super O> type, O object) {}
  public <O> void invariant(Class<O> type, O object) {}  
  
  void m() {
    invariant(String, ""foo"")
    contravariant(String, ""foo"") // fails, can't find method
  }
}
{code}

Worked in rc-2, fails with 2.3.0 final. Haven't tested rc-4.",,blackdrag,ldaley,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 14 09:43:45 UTC 2014,,,,,,,,,,"0|i2c4nj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/May/14 09:43;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compiler fails to infer generic type,GROOVY-6760,12817475,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ldaley,ldaley,06/May/14 02:46,20/May/14 05:31,14/Jul/23 06:01,08/May/14 10:18,2.3.0,,,,,,,,,,,,,,,,,2.3.1,,,,Static Type Checker,,,,0,,,,,,,"{code}
@Grab(group='com.netflix.rxjava', module='rxjava-core', version='0.18.1') 
import rx.Observable

@groovy.transform.CompileStatic
class Example {
  static void main(String[] args) {
    Observable.just(""foo"") map {
      it.toUpperCase() // <- compiler doesn't know 'it' is a string
    } subscribe {
      println it
    }
  }
}
{code}",,blackdrag,guillaume,ldaley,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 08 10:18:18 UTC 2014,,,,,,,,,,"0|i2bvn3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/May/14 06:42;blackdrag;This seems to work for me;;;","06/May/14 06:55;guillaume;I also tried it (from the 2.3.0 Groovy Console) and didn't get any error.;;;","06/May/14 16:25;ldaley;I must have been using an old Groovy version accidentally. Closing.;;;","06/May/14 20:49;ldaley;Sorry, my example case was too simple. This one definitely doesn't work.

{code}
@Grab(group='com.netflix.rxjava', module='rxjava-core', version='0.18.1') 
import rx.Observable
import java.util.concurrent.Callable

@groovy.transform.CompileStatic
class Example {

  static <T> Observable<T> observe(Callable<Iterable<T>> callable) {
    Observable.from(callable.call())
  }
  
  static void main(String[] args) {
    observe({ [""foo""] }) map {
      it.toUpperCase() // <- compiler doesn't know 'it' is a string
    } subscribe {
      println it
    }
  }
}
{code};;;","08/May/14 10:18;blackdrag;the example in the comment will now work as well;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Explicit type hints are not respected,GROOVY-6757,12817538,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ldaley,ldaley,06/May/14 01:04,31/Mar/15 06:08,14/Jul/23 06:01,20/Mar/15 08:18,2.3.0,2.4.0-rc-1,,,,,,,,,,,,,,,,2.4.3,,,,Static Type Checker,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
class Example {
  static void main(String[] args) {
    Collections.<String>emptyList().get(0).toUpperCase()
  }
}
{code}

That fails to compile because it doesn't respect the <String> hint.",,ldaley,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7307,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 23 22:20:55 UTC 2015,,,,,,,,,,"0|i2ctbj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/May/14 11:27;melix;For this to work, we need to keep track of the explicit type information. {{MethodCallExpression}} has {{genericsTypes}}, but it seems to be unused. The AST doesn't have the {{String}} hint, so probably this information is just lost during parsing. In any case, {{genericsTypes}} in {{MethodCallExpression}} isn't used, so we need to solve two problems actually :);;;","30/May/14 10:33;melix;See also https://gist.github.com/deigote/aec2abd2d8ec3d72b66c;;;","23/Mar/15 22:20;ldaley;Super cool. Thanks Cedric.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Groovyc task should log build errors at error level, consistent with javac and allowing use of ant -q",GROOVY-6756,12817439,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,lujke,lujke,05/May/14 12:08,05/Apr/15 14:44,14/Jul/23 06:01,05/May/14 16:28,,,,,,,,,,,,,,,,,,2.3.1,,,,Ant integration,,,,0,,,,,,,"When failOnError is set, Groovyc currently logs the error at info level and then throws a BuildException. Unfortunately, when running ant with the quiet flag (ant -q), this means that compilation errors aren't displayed, and you're left with a mysteriously failed build with no reason provided. Javac errors are logged at the error level (and visible with -q), so groovyc should be too. 

Strangely, compilation failures _are_ logged at the error level if failOnError is false. I'm uncertain as to why it's currently the way it is. Perhaps the thrown exception used to include the error message and would be presented to the user, but this isn't the case anymore.

Pull request at https://github.com/groovy/groovy-core/pull/409",,lujke,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Mon May 05 16:28:30 UTC 2014,,,,,,,,,,"0|i2cu67:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/May/14 12:10;lujke;Added pull request: https://github.com/groovy/groovy-core/pull/409;;;","05/May/14 16:28;paulk;Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Bad type resolution causing bad classes and TypeNotPresentExceptions with joint compilation, deep generics and star imports",GROOVY-6755,12816632,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,lujke,lujke,04/May/14 22:28,05/Apr/15 14:44,14/Jul/23 06:01,07/May/14 09:50,,,,,,,,,,,,,,,,,,2.3.1,2.4.0-beta-1,,,Compiler,Stub generator / Joint compiler,,,0,,,,,,,"ResolveVisitor improperly marks generics types as being resolved when sub-generics types haven't been resolved, leading to classes being generated that lack fully qualified generics typing and then subsequent errors while compiling against those generated class files. Here's an example:

{code:title=a/Item.java}
package a;
public interface Item {}
{code}

{code:title=b/ItemListList.groovy}
package b
import a.*

class ItemListList {
  static List<List<Item>> ITEMS
}
{code}
If you compile this with the *joint compiler* and inspect ItemListList with javap, the type signature will be:
{code}
  public static java.util.List<java.util.List<Item>> ITEMS
{code}
Note that Item type is not fully qualified (it should refer to {{a.Item}}), and if that class file is accessed during a later compilation (e.g., for an incremental compilation or a groovy server page), an exception with a stack trace similar to the following will be thrown:
{code}
    java.lang.TypeNotPresentException: Type Item not present
    	at sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:117)
    	at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:125)
    	at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)
    	at sun.reflect.generics.visitor.Reifier.reifyTypeArguments(Reifier.java:68)
    	at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:138)
    	at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)
    	at sun.reflect.generics.visitor.Reifier.reifyTypeArguments(Reifier.java:68)
    	at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:138)
    	at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)
    	at sun.reflect.generics.repository.FieldRepository.getGenericType(FieldRepository.java:85)
    	at java.lang.reflect.Field.getGenericType(Field.java:237)
    	at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:357)
    	at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:261)
     ...
{code}
The problem is that {{ResolveVisitor}} marks a {{GenericsType}} as resolved iff the type (i.e., {{ClassNode}}) has been resolved, but ignores any failure to resolve any generic types associated with the generic type itself. To use the example above, when resolving {{List<List<Item>>}} it first attempts to resolve the generic type {{List<Item>}}. It successfully resolves {{List}} to {{java.util.List}}, but isn't yet able to resolve {{Item}} to {{a.Item}}, as a star import is used and the java-compiler stage of joint compilation has yet to run, so {{a.Item}} is unavailable for classloader-based resolution in {{resolveToOuter}} to occur. Nonetheless, it incorrectly marks {{List<Item>}} as resolved, as it only checks that the primary type was resolved. A later attempt at resolution occurs after the java compilation, at which time an attempt to resolve {{Item}} would work since a/Item.class now exists, but no re-attempt is made at this time to resolve the GenericType as it had already been marked as being resolved. The solution is simple: only mark a {{GenericType}} as resolved if both its type _and_ any genericsTypes it has are resolved.

Pull request is at https://github.com/groovy/groovy-core/pull/408

It's possible that this bug was responsible for GROOVY-3157.",,blackdrag,lujke,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Thu May 08 03:10:29 UTC 2014,,,,,,,,,,"0|i2cti7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"04/May/14 23:06;lujke;Issued pull request: https://github.com/groovy/groovy-core/pull/408;;;","07/May/14 09:50;blackdrag;I applied a modified version of the patch, see pull request for more details. Thanks for finding this one!;;;","07/May/14 10:40;lujke;Wow, yeah, that part really didn't show up well in the diff! It was just to avoid re-resolving {{type}} if it was already resolved by enclosing that code in an {{if (\!type.isResolved())}} block, so it was just an optimisation. I imagine no harm comes from resolving it a second time. Thank you!;;;","07/May/14 11:31;blackdrag;imho the condition is always true, since there is an if (type.isResolved()) return true; before;;;","07/May/14 16:28;lujke;Ah, that first line is actually:
  {code}if (genericsType.isResolved()) return true;{code},
whereas the test I added was, for, if we inline {{type}}, {{genericsType.getType().isResolved()}}. So if a generics type representing {{List<Item>}} was passed in as {{genericsType}}, as in the example above, {{genericsType.isResolved()}} is checking that the entirety of {{List<Item>}} is resolved while {{type.isResolved()}} it seeing just whether {{List}}, without its generics, had already been resolved, as is the case during the post-javac attempt to resolve {{List<Item>}}.

;;;","08/May/14 03:10;blackdrag;ah right... well... I think it is no problem. ResolveVisitor has a lot of places that try avoiding visits to already resolved values;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error in @TypeChecked when method in both Interface and Superclass,GROOVY-6751,12817525,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,ngalarneau,ngalarneau,02/May/14 14:53,05/Jun/14 07:38,14/Jul/23 06:01,15/May/14 14:30,2.2.2,,,,,,,,,,,,,,,,,2.3.1,,,,Static Type Checker,,,,0,,,,,,,"This groovy code has a compilation error:
{code}
import groovy.transform.TypeChecked

interface Ifc
{
  Object getProperty(String s)
}

class DuplicateMethodInIfc implements Ifc  // implemented in groovy.lang.GroovyObject
{
}

@TypeChecked
class Tester
{
  DuplicateMethodInIfc dup = new DuplicateMethodInIfc()
  Object obj = dup.getProperty(""foo"")   // <== Error here
}
{code}

The error is: DuplicateMethodInIfc.groovy: 16: [Static type checking] - Reference to method is ambiguous. Cannot choose between [java.lang.Object
Ifc#getProperty(java.lang.String), java.lang.Object groovy.lang.GroovyObject#getProperty(java.lang.String)]",,ngalarneau,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 05 07:38:29 UTC 2014,,,,,,,,,,"0|i2c5zb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/May/14 14:30;pschumacher;Fixed. Thanks for reporting.;;;","05/Jun/14 07:38;ngalarneau;Now this same issue appears to happen for @CompileStatic. I filed GROOVY-6849 for it.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.IncompatibleClassChangeError: MyClass and MyClass$MyInnerClass disagree on InnerClasses attribute with indy,GROOVY-6750,12817358,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,kha,kha,02/May/14 11:23,20/May/14 08:12,14/Jul/23 06:01,12/May/14 07:08,2.3.0-rc-4,,,,,,,,,,,,,,,,,2.2.3,2.3.1,,,bytecode,,,,0,,,,,,,"We compile our project using gmavenplus-plugin with the invokeDynamic flag activated. It compiles well.

But when running our test suite, 2 major issues:

* It is really really really slower that without invoke dynamic:-( This is the major concern.
* We see stacktraces like the one below.

Note: we only have *-indy groovy jars on classpath.

Errors are all concerning normal inner classes, whether there are static or not. To remove the exceptions, we have to exctract the static or inner class to another file. This is easy for static classes, but for inner classes, it is quite annoying ;-)

{code:java}
java.lang.InternalError: compileToBytecode
        at java.lang.invoke.MethodHandleStatics.newInternalError(MethodHandleStatics.java:97)
        at java.lang.invoke.LambdaForm.compileToBytecode(LambdaForm.java:460)
        at java.lang.invoke.LambdaForm.checkInvocationCounter(LambdaForm.java:634)
        at com.guestful.backend.service.DB$GCollection.findOne(DB.groovy:186)
        at com.guestful.backend.service.DB$GCollection.findOne(DB.groovy)
        at com.guestful.backend.event.handler.GuestfulJobListener.onJobTriggered(GuestfulJobListener.groovy:128)
        at com.ovea.tajin.framework.async.DefaultJobScheduler$JobRunner.run(DefaultJobScheduler.groovy:255)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:215)
        at com.ovea.tajin.framework.async.guice.AsyncModule$Task.run(AsyncModule.groovy:154)
        at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297)
        at com.ovea.tajin.framework.async.guice.AsyncModule$ExecutorProvider$5.execute(AsyncModule.groovy:129)
        at com.ovea.tajin.framework.async.DefaultJobScheduler.doSchedule(DefaultJobScheduler.groovy:227)
        at com.ovea.tajin.framework.async.DefaultJobScheduler.doSchedule(DefaultJobScheduler.groovy)
        at com.ovea.tajin.framework.async.DefaultJobScheduler.this$2$doSchedule(DefaultJobScheduler.groovy)
        at com.ovea.tajin.framework.async.DefaultJobScheduler.schedule(DefaultJobScheduler.groovy:203)
        at com.guestful.backend.event.handler.Sms.schedule(Sms.groovy:92)
        at com.guestful.backend.event.handler.Sms.this$2$schedule(Sms.groovy)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:215)
        at com.guestful.backend.event.handler.Sms.onReservationEdited(Sms.groovy:83)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:483)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:215)
        at com.ovea.tajin.framework.async.guava.EventHandler.handleEvent(EventHandler.groovy:72)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:215)
        at com.ovea.tajin.framework.async.guava.AsyncEventBus$1.run(AsyncEventBus.groovy:100)
        at com.ovea.tajin.framework.async.guice.AsyncModule$Task.run(AsyncModule.groovy:154)
        at com.google.common.util.concurrent.MoreExecutors$SameThreadExecutorService.execute(MoreExecutors.java:297)
        at com.ovea.tajin.framework.async.guice.AsyncModule$ExecutorProvider$5.execute(AsyncModule.groovy:129)
        at com.ovea.tajin.framework.async.guava.AsyncEventBus.dispatch(AsyncEventBus.groovy:97)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:215)
        at com.ovea.tajin.framework.async.guava.AsyncEventBus.dispatchQueuedEvents(AsyncEventBus.groovy:85)
        at com.ovea.tajin.framework.async.guava.EventBus.post(EventBus.groovy:262)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:215)
        at com.ovea.tajin.framework.async.EventBusDispatcher$_broadcast_closure1.doCall(EventBusDispatcher.groovy:69)
        at sun.reflect.GeneratedMethodAccessor260.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:483)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
        at groovy.lang.Closure.call(Closure.java:423)
        at groovy.lang.Closure.call(Closure.java:439)
        at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1373)
        at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1304)
        at com.ovea.tajin.framework.async.EventBusDispatcher.broadcast(EventBusDispatcher.groovy:61)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:215)
        at com.guestful.backend.rest.ReservationResource.editPublicReservation(ReservationResource.groovy:308)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:483)
        at org.glassfish.jersey.server.model.internal.ResourceMethodInvocationHandlerFactory$1.invoke(ResourceMethodInvocationHandlerFactory.java:81)
        at org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher$1.run(AbstractJavaResourceMethodDispatcher.java:151)
        at org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.invoke(AbstractJavaResourceMethodDispatcher.java:171)
        at org.glassfish.jersey.server.model.internal.JavaResourceMethodDispatcherProvider$VoidOutInvoker.doDispatch(JavaResourceMethodDispatcherProvider.java:136)
        at org.glassfish.jersey.server.model.internal.AbstractJavaResourceMethodDispatcher.dispatch(AbstractJavaResourceMethodDispatcher.java:104)
        at org.glassfish.jersey.server.model.ResourceMethodInvoker.invoke(ResourceMethodInvoker.java:406)
        at org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:350)
        at org.glassfish.jersey.server.model.ResourceMethodInvoker.apply(ResourceMethodInvoker.java:106)
        at org.glassfish.jersey.server.ServerRuntime$1.run(ServerRuntime.java:259)
        at org.glassfish.jersey.internal.Errors$1.call(Errors.java:271)
        at org.glassfish.jersey.internal.Errors$1.call(Errors.java:267)
        at org.glassfish.jersey.internal.Errors.process(Errors.java:315)
        at org.glassfish.jersey.internal.Errors.process(Errors.java:297)
        at org.glassfish.jersey.internal.Errors.process(Errors.java:267)
        at org.glassfish.jersey.process.internal.RequestScope.runInScope(RequestScope.java:320)
        at org.glassfish.jersey.server.ServerRuntime.process(ServerRuntime.java:236)
        at org.glassfish.jersey.server.ApplicationHandler.handle(ApplicationHandler.java:1028)
        at org.glassfish.jersey.servlet.WebComponent.service(WebComponent.java:373)
        at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:381)
        at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:344)
        at com.ovea.tajin.framework.support.jetty.Container$Jersey.super$4$service(Container.groovy)
        at sun.reflect.GeneratedMethodAccessor274.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:483)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1085)
        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:128)
        at com.ovea.tajin.framework.support.jetty.Container$Jersey.service(Container.groovy:207)
        at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:738)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1651)
        at com.google.inject.servlet.FilterChainInvocation.doFilter(FilterChainInvocation.java:66)
        at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449)
        at com.ovea.tajin.framework.support.shiro.GuiceShiroFilter.super$6$executeChain(GuiceShiroFilter.groovy)
        at sun.reflect.GeneratedMethodAccessor273.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:483)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1085)
        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:128)
        at com.ovea.tajin.framework.support.shiro.GuiceShiroFilter.executeChain(GuiceShiroFilter.groovy:60)
        at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365)
        at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90)
        at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83)
        at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:383)
        at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362)
        at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125)
        at com.google.inject.servlet.FilterDefinition.doFilter(FilterDefinition.java:164)
        at com.google.inject.servlet.FilterChainInvocation.doFilter(FilterChainInvocation.java:58)
        at com.mycila.guice.ext.web.HttpContextFilter.doFilter(HttpContextFilter.java:47)
        at com.google.inject.servlet.FilterDefinition.doFilter(FilterDefinition.java:164)
        at com.google.inject.servlet.FilterChainInvocation.doFilter(FilterChainInvocation.java:58)
        at org.eclipse.jetty.servlets.CrossOriginFilter.handle(CrossOriginFilter.java:248)
        at org.eclipse.jetty.servlets.CrossOriginFilter.doFilter(CrossOriginFilter.java:211)
        at com.google.inject.servlet.FilterDefinition.doFilter(FilterDefinition.java:164)
        at com.google.inject.servlet.FilterChainInvocation.doFilter(FilterChainInvocation.java:58)
        at com.google.inject.servlet.ManagedFilterPipeline.dispatch(ManagedFilterPipeline.java:120)
        at com.google.inject.servlet.GuiceFilter.doFilter(GuiceFilter.java:115)
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1622)
        at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:549)
        at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:219)
        at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1111)
        at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:478)
        at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:183)
        at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1045)
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)
        at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:109)
        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97)
        at org.eclipse.jetty.server.Server.handle(Server.java:462)
        at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:279)
        at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:232)
        at org.eclipse.jetty.io.AbstractConnection$2.run(AbstractConnection.java:534)
        at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:607)
        at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:536)
        at java.lang.Thread.run(Thread.java:744)
Caused by: java.lang.IncompatibleClassChangeError: com.guestful.backend.service.DB and com.guestful.backend.service.DB$GCollection disagree on InnerClasses attribute
        at java.lang.Class.getDeclaringClass0(Native Method)
        at java.lang.Class.getDeclaringClass(Class.java:1222)
        at java.lang.Class.getEnclosingClass(Class.java:1264)
        at java.lang.Class.getSimpleBinaryName(Class.java:1430)
        at java.lang.Class.getSimpleName(Class.java:1296)
        at java.lang.Class.isAnonymousClass(Class.java:1398)
        at java.lang.invoke.InvokerBytecodeGenerator.isStaticallyInvocable(InvokerBytecodeGenerator.java:590)
        at java.lang.invoke.InvokerBytecodeGenerator.generateCustomizedCodeBytes(InvokerBytecodeGenerator.java:519)
        at java.lang.invoke.InvokerBytecodeGenerator.generateCustomizedCode(InvokerBytecodeGenerator.java:490)
        at java.lang.invoke.LambdaForm.compileToBytecode(LambdaForm.java:454)
        ... 130 common frames omitted
{code}","Sun JDK 1.8.0
Windows 7 64 bits",blackdrag,guillaume,kha,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6808,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 03 19:46:13 UTC 2014,,,,,,,,,,"0|i2c187:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/May/14 13:14;guillaume;Might be a problem with our invoke dynamic support.
It's working correctly when not using the invoke dynamic support? (at least for a workaround till we find out what's going on);;;","02/May/14 13:19;kha;Yes! 
I disabled it for the moment.
;;;","03/May/14 07:03;blackdrag;as far as I understand it our invokedynamic part is not at fault here. It happens only with indy, because the case is otherwise not checked I guess. Going by the cause, what seems to be broken is the inner class table in the class. The difficulty in such things is always knowing what is right and what not. 

Mathieu, is your case structurally as simple as this?
{code:Java}
class A {
  class B{}
}
{code}
;;;","03/May/14 09:15;kha;Yes exactly. It fails with inner classes, but also fails with static inner classes, like this case:

{code:java}
class MyCacheClass {

    @EqualsAndHashCode
    static final class Key {
        final String restaurantId
        final LocalDate day

        Key(String restaurantId, LocalDate day) {
            this.restaurantId = restaurantId
            this.day = day
        }

        @Override
        String toString() { ""${restaurantId} ${day}"" }
    }

}
{code};;;","03/May/14 09:54;kha;Note: by moving the inner classes out, compilation works and our test suite is successful. 
But it is really damn slow ;-) All tests take 3 mins to run. Without the invokedynamic on the maven plugin, all test run in 1 min.
We only have *indy jars on the classpath.;;;","03/May/14 19:32;blackdrag;ok, thanks for the clarification.

As for the indy performance problem... well I would need something I can benchmark on. It is unlikely that gmaven has something to do with it. Also it would be good to know if this performance problem is the same with other versions of groovy;;;","03/May/14 19:46;kha;Yes I understand... Though I really don't know which test case I could give you: this is a test suite of a big application so even if I extract a really small part, I am wondering how I could find and isolate which part is slow...;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checking when extracting value of generic type does not wok,GROOVY-6748,12817473,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mperry,mperry,02/May/14 05:09,20/May/14 05:31,14/Jul/23 06:01,12/May/14 08:50,2.3.0-rc-4,,,,,,,,,,,,,,,,,2.3.1,,,,Static Type Checker,,,,0,,,,,,,"
The script at the URL https://gist.github.com/mperry/11471693 fails to type check when getting generic values of type A and B from a list and passing it to another method.",,blackdrag,mperry,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon May 12 08:50:00 UTC 2014,,,,,,,,,,"0|i2c43b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/May/14 08:50;blackdrag;fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Anonymous Inner Enum,GROOVY-6747,12813270,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,brownj,brownj,30/Apr/14 14:11,22/May/22 15:59,14/Jul/23 06:01,23/Mar/21 03:28,2.1.8,2.4.0-rc-1,,,,,,,,,,,,,,,,2.5.16,3.0.8,4.0.0-alpha-3,,,,,,0,ClassFormatError,,,,,,"Related to http://jira.grails.org/browse/GRAILS-11348.

See the attached enumquestion.zip which demonstrates the behavior without involving Grails.  Run ""./gradlew test"" to see a relevant test failure.

{code:title=src/main/groovy/com/demo/SampleAppIndicatorCodes.groovy|borderStyle=solid}
package com.demo

public enum SampleAppIndicatorCodes {
    YES(""Y"") {
        @Override
        public String getCode() {
            return booleanCode;
        }
    },
    NO(""N"") {
        @Override
        public String getCode() {
            return booleanCode;
        }
    };

    private String booleanCode = null

    private SampleAppIndicatorCodes(String booleanCode) {
        this.booleanCode = booleanCode
    }
    public abstract String getCode();

    public static SampleAppIndicatorCodes getSourceIndicator(String booleanCode) {
        if (""Y"".equalsIgnoreCase(booleanCode)) {
            return YES
        } else if (""L"".equalsIgnoreCase(booleanCode)) {
            return NO
        } else {
            throw new IllegalArgumentException(""No  Indicator for the code $booleanCode"")
        }
   }
}
{code}

{code:title=src/test/groovy/com/demo/SampleAppIndicatorCodesSpec.groovy|borderStyle=solid}
package com.demo

import spock.lang.Specification

class SampleAppIndicatorCodesSpec extends Specification {

    def 'test accessing YES code'() {
        expect:
        'Y' == SampleAppIndicatorCodes.YES.code
    }
}
{code}

For this particular case the anonymous inner classes seems like a peculiar way to do this but in general apparently this syntax is supposed to be valid.  I ran this example by Jochen this morning and he felt like this is probably a bug.
",,blackdrag,brownj,paulk,,,,,,,,,,,,,"eric-milles opened a new pull request #1528:
URL: https://github.com/apache/groovy/pull/1528


   ```groovy
     enum E {
       X {
       },
       Y
     }
   ```
   E provides a private, implicit constructor (String,int) for Y and a package-private, synthetic constructor (String,int,E) for X (aka E$1).  This is what the Java compiler does as well.
   
   https://issues.apache.org/jira/browse/GROOVY-6747


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;19/Mar/21 00:04;githubbot;600","danielsun1106 merged pull request #1528:
URL: https://github.com/apache/groovy/pull/1528


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;23/Mar/21 02:55;githubbot;600","danielsun1106 commented on pull request #1528:
URL: https://github.com/apache/groovy/pull/1528#issuecomment-804544443


   Merged. Thanks!


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;23/Mar/21 02:56;githubbot;600",,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Apr/14 14:11;brownj;enumquestion.zip;https://issues.apache.org/jira/secure/attachment/12722196/enumquestion.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 10 07:28:57 UTC 2014,,,,,,,,,,"0|i2c96n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/May/14 04:02;paulk;I guess if we want a short-term fix we can make any private fields/constructors/methods in an enum protected instead.

I also noticed that if you change the abstract {{getCode()}} method from public to private you get:
{noformat}
java.lang.ClassFormatError: Method getCode in class SampleAppIndicatorCodes has illegal modifiers: 0x402
{noformat}
We should catch that earlier with a better error message - though the short-term fix would avoid that scenario anyway.;;;","10/Jun/14 07:10;blackdrag;I think there are several problems with this code, one of them being booleanCode, which in a Java version would have to be static. But concentrating on the constructor problem one difference between Java and Groovy becomes obvious here. Java keeps the private constructor as a String,int,String variant. But it also creates a package private constructor that additionally takes SampleAppIndicatorCodes$1 as argument. This constructor is then used by the enum-AICs instead of the private one and that way the private access problem is avoided.;;;","10/Jun/14 07:25;blackdrag;the IllegalAccessError appears at about 2.1.4/2.1.3. Before Groovy refused the abstract method usage;;;","10/Jun/14 07:28;blackdrag;removing the abstract modifier the code compiles in 1.8.9, but YES.code does not use the getCode method defined in YES. Seems to be the same till version 2.1.3;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Groovy class files miss the ""EnclosingMethod"" attribute",GROOVY-6746,12817365,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,melix,melix,30/Apr/14 13:52,20/May/14 05:31,14/Jul/23 06:01,30/Apr/14 13:59,2.2.2,,,,,,,,,,,,,,,,,2.3.1,,,,Compiler,,,,0,,,,,,,"The class files produced by the groovy compiler do not have the {{EnclosingMethod}} attribute set for inner classes. It is not critical, but it causes some tools like the {{dex}} tool to complain.
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-30 13:52:54.0,,,,,,,,,,"0|i2bu13:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ImportCommand Regex Too Restrictive,GROOVY-6743,12817528,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,spmallette,spmallette,30/Apr/14 09:21,20/May/14 05:31,14/Jul/23 06:01,10/May/14 04:05,2.3.0,2.3.0-rc-2,,,,,,,,,,,,,,,,2.3.1,,,,Groovysh,,,,0,,,,,,,"When trying to use "":import"" with a namespace that contains a digit (such as ""org.apache.commons.math3.primes.Primes"", the regex  specified here:

https://github.com/groovy/groovy-core/blob/GROOVY_2_3_0_RC_2/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/commands/ImportCommand.groovy#L76

does not allow the command to continue processing returning ""Invalid import definition: ..."".  

A small adjustment to that regex will make the difference. Changing that line from:

if (! (importSpec ==~ '[a-zA-Z_. *]+;?$')) {

to

if (! (importSpec ==~ '[\\da-zA-Z_. *]+;?$')) {

seemed to do the trick.

",,guillaume,pschumacher,spmallette,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 10 04:05:06 UTC 2014,,,,,,,,,,"0|i2c007:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Apr/14 09:30;guillaume;Feeling like submitting a pull request for that change?;;;","30/Apr/14 12:00;spmallette;Pull request issued:

https://github.com/groovy/groovy-core/pull/401

It allows digits in the package/class names now.  Tests included. Thanks.;;;","10/May/14 04:05;pschumacher;Pull request merged. Thanks for reporting the issue and for fixing it.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy is unable to resolve this Generics use case,GROOVY-6742,12817535,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,nithril,nithril,30/Apr/14 08:00,26/Jul/18 04:38,14/Jul/23 06:01,11/May/18 09:56,2.2.2,,,,,,,,,,,,,,,,,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,,Static Type Checker,,,,0,,,,,,,"Groovy fails with the following error when compiling the hereafter function:
{{Groovy:unable to resolve class F}}

{code}
    public static <F, T> FutureCallback<F> deferredCallback(DeferredResult<T> deferredResult, final Function<F, T> function) {
        return new FutureCallback<F>() {
            @Override
            void onSuccess(F result) {
                deferredResult.setResult(function.apply(result))
            }
        };
    }
{code}

See attachment for a test case {{org.issues.Issue3}}

May be linked to GROOVY-6167 ","Groovy 2.2
Maven 3 with eclipse compiler",daniel_sun,nithril,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Apr/14 08:00;nithril;Generic.zip;https://issues.apache.org/jira/secure/attachment/12723246/Generic.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 11 09:56:12 UTC 2018,,,,,,,,,,"0|i2c8p3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Oct/14 13:23;pschumacher;@Nicolas Labrot: In Groovy 2.2.x and 2.3.x a lot of work was done on generic handling. Could you please check if this issues still occurs with recent groovy versions? Thanks!;;;","31/Oct/14 09:14;nithril;The issue still occurs with Groovy 2.3.7.

Now even Issue3_Java has compilation error (no compilation error occurs without the groovy compiler);;;","11/May/18 09:56;daniel_sun;Fixed by https://github.com/apache/groovy/commit/05aac51a0fd3356787b73a0a255270f286d1a96a;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Generic Traits and SAM type coercion,GROOVY-6741,12818283,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,30/Apr/14 06:02,23/Dec/14 19:45,14/Jul/23 06:01,22/Dec/14 06:42,2.3.0-beta-1,2.3.0-rc-2,,,,,,,,,,,,,,,,2.3.10,2.4.0-rc-1,,,Compiler,,,,1,,,,,,,"The following code:

{code}
trait GPredicate<T> {
    abstract boolean test( T t )
}

GPredicate<Integer> p = { Integer n -> n > 1 }
{code}

Results in an exception:

{code}
A transform used a generics containing ClassNode GPredicate <T extends java.lang.Object -> java.lang.Object> for the super class GPredicate$TraitAdapter directly. You are not supposed to do this. Please create a new ClassNode referring to the old ClassNode and use the new ClassNode instead of the old one. Otherwise the compiler will create wrong descriptors and a potential NullPointerException in TypeResolver in the OpenJDK. If this is not your own doing, please report this bug to the writer of the transform.
 at line: -1, column: -1
{code}",,lhotari,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 30 06:02:56 UTC 2014,,,,,,,,,,"0|i2cojb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Apr/14 06:02;tim_yates;Maybe related to: http://jira.codehaus.org/browse/GROOVY-6691;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Calling a static method of itself in an inner class causes ClassCastException,GROOVY-6740,12817520,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,nobeans,nobeans,30/Apr/14 01:20,09/Jul/14 00:38,14/Jul/23 06:01,09/Jul/14 00:38,2.3.0-rc-2,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,,,,,0,,,,,,,"{code}
class Foo1 {
  static call_directly() {
    foo()
  }
  static call_inClosure() {
    {-> foo() }.call()
  }
  static foo() {
    ""FOO""
  }
}
class Foo2 {
  // 'private' and 'static' don't affect this issue.
  class Bar {
    static call_directly() {
      foo()
    }
    static call_inClosure() {
      {-> foo() }.call()
    }
    static call_inClosure_others() {
      {-> Foo1.foo() }.call()
    }
    static foo() {
      ""FOO""
    }
  }
}

assert Foo1.call_directly() == 'FOO'
assert Foo1.call_inClosure() == 'FOO' // -- [1]

assert Foo2.Bar.call_directly() == 'FOO'
GroovyAssert.shouldFail(ClassCastException) { // WHY?? -- [2]
  Foo2.Bar.call_inClosure()
}
assert Foo2.Bar.call_inClosure_others() == 'FOO' // -- [3]
{code}

[1] It's no problem in a root class.
[2] ClassCastException occurs.
[3] It's no problem to call a other class's static method.
",Groovy Version: 2.3.0-rc-2 JVM: 1.8.0_05 Vendor: Oracle Corporation OS: Mac OS X,nobeans,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 09 00:38:33 UTC 2014,,,,,,,,,,"0|i2ci2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Apr/14 01:31;nobeans;If qualified by a class name, it works like [4]:

{code}
class Foo1 {
  static call_directly() {
    foo()
  }
  static call_inClosure() {
    {-> foo() }.call()
  }
  static foo() {
    ""FOO""
  }
}
class Foo2 {
  // 'private' and 'static' don't affect this issue.
  class Bar {
    static call_directly() {
      foo()
    }
    static call_inClosure() {
      {-> foo() }.call()
    }
    static call_inClosure_qualified() {
      {-> Bar.foo() }.call()
    }
    static call_inClosure_others() {
      {-> Foo1.foo() }.call()
    }
    static foo() {
      ""FOO""
    }
  }
}

assert Foo1.call_directly() == 'FOO'
assert Foo1.call_inClosure() == 'FOO' // -- [1]

assert Foo2.Bar.call_directly() == 'FOO'
GroovyAssert.shouldFail(ClassCastException) { // WHY?? -- [2]
  Foo2.Bar.call_inClosure()
}
assert Foo2.Bar.call_inClosure_others() == 'FOO' // -- [3]
assert Foo2.Bar.call_inClosure_qualified() == 'FOO' // -- [4]
{code}

Must it be qualified with a class? Is it a specification?;;;","08/Jul/14 18:55;nobeans;In Groovy 2.3.4, this issue was fixed. I think it's due to a fix for https://jira.codehaus.org/browse/GROOVY-6830.;;;","08/Jul/14 19:02;nobeans;In Groovy 2.3.3, I can replicate it. So it's certain to have been fixed at 2.3.4.;;;","09/Jul/14 00:38;paulk;Marking as resolved. Thanks for reporting that it is now working.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checking considers extension methods but not extension properties,GROOVY-6738,12817339,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,pniederw,pniederw,29/Apr/14 08:14,01/Feb/17 23:18,14/Jul/23 06:01,07/Nov/16 18:05,2.3.0-rc-2,,,,,,,,,,,,,,,,,2.4.8,,,,Static Type Checker,,,,0,,,,,,,"Say an extension class registered via an extension module declares a Player#getBonusPoints() extension method. Then `player.getBonusPoints()` type-checks, but `player.bonusPoints` doesn't.",,paulk,pniederw,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7952,GROOVY-7953,GROOVY-5568,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 07 18:06:31 UTC 2016,,,,,,,,,,"0|i2cfn3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Oct/16 00:49;shils;This appears to have been covered by GROOVY-5568, with the exception of a few cases: 
1. property expressions for extension methods starting with 'is' - GROOVY-7952 
2. property expressions for extension methods on primitives - GROOVY-7953;;;","07/Nov/16 00:52;paulk;Shil, do you believe we can close this?;;;","07/Nov/16 18:06;shils;Yes, thanks for reminding me.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Delegate triggers BUG! exception in phase 'class generation',GROOVY-6737,12817357,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,29/Apr/14 05:49,01/May/14 18:01,14/Jul/23 06:01,29/Apr/14 07:00,2.3.0-rc-2,,,,,,,,,,,,,,,,,2.3.0-rc-4,,,,,,,,0,,,,,,,"If a class A has a member of type B, and that type B has itself a member of type C annotated with @Delegate, that C uses generics *and* that B is precompiled, then compilation of A will fail.

Example:

{code}
class A {
   B b = new B()
}
{code}

and the precompiled class:

{code}
class B {
   @Delegate Map c = [:]
}
{code}
",,melix,paolodt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-29 05:49:19.0,,,,,,,,,,"0|i2bx73:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error adding a trait to a Map,GROOVY-6736,12817508,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,grooscript,grooscript,28/Apr/14 17:11,20/May/14 05:31,14/Jul/23 06:01,15/May/14 04:22,2.3.0,2.3.0-rc-2,,,,,,,,,,,,,,,,2.3.1,,,,,,,,0,traits,,,,,,"With this code:

trait Extra {
    String extra() { ""I'm an extra method"" }
}

def extraList = [] as Extra
assert extraList.extra() == ""I'm an extra method""

def extraMap = [:] as Extra
assert extraMap.extra() == ""I'm an extra method""

I get error:
Caught: java.lang.UnsupportedOperationException
java.lang.UnsupportedOperationException
	at com.sun.proxy.$Proxy8.extra(Unknown Source)
	at Extra$extra$0.call(Unknown Source)
	at Runtime.run(Runtime.groovy:9)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)",,grooscript,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-28 17:11:19.0,,,,,,,,,,"0|i2cnbr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
regression in varargs treatment for static compilation,GROOVY-6735,12816901,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,paulk,,28/Apr/14 15:52,07/Apr/15 19:07,14/Jul/23 06:01,29/Apr/14 06:44,,,,,,,,,,,,,,,,,,2.3.0-rc-4,,,,,,,,0,,,,,,,"The following example works fine in 2.2.2:
{code}
import groovy.transform.CompileStatic

@CompileStatic
def extractInfo(String s) {
  def squareNums = s.findAll(/\d+/) { String num -> num.toInteger() }.collect{ Integer num -> num ** 2 }
  def wordSizePlusNum = s.findAll(/\s*(\w+)\s*(\d+)/) { _, String word, String num -> word.size() + num.toInteger() }
  [squareNums, wordSizePlusNum]
}

assert extractInfo("" ab 12 cdef 34 jhg "") == [[144, 1156], [14, 38]]
{code}
but in 2.3.0-rc-2 it gives the following errors:
{noformat}
4 compilation errors:

Expected parameter of type java.lang.String[] but got java.lang.String
 at line: 5, column: 39

[Static type checking] - Cannot find matching method [Ljava.lang.String;#toInteger(). Please check if the declared type is right and if the method exists.
 at line: 5, column: 53

Expected parameter of type java.lang.Object but got java.lang.Integer
 at line: 5, column: 80

[Static type checking] - Cannot find matching method java.lang.Object#power(int). Please check if the declared type is right and if the method exists.
 at line: 5, column: 95
{noformat}
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 28 17:36:28 UTC 2014,,,,,,,,,,"0|i2cam7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Apr/14 15:55;paulk;obviously errors 2 through 4 are really noise resulting from the first error;;;","28/Apr/14 17:36;paulk;For another example:
{code}
@groovy.transform.CompileStatic
def method() {
  assert ""foobarbaz"".findAll('b(a)([rz])') { full, a, b -> assert ""BA""==""B$a"".toUpperCase() }.size() == 2
  assert ""foobarbaz"".findAll('ba') { found -> assert ""BA"" == found.toUpperCase() }.size() == 2
  assert ""foobarbaz"".findAll('ba') { String found -> assert ""BA"" == found.toUpperCase() }.size() == 2
}

method()
{code}
Without CompileStatic both pass. With @CS under 2.2.2 it gives the following error:
{noformat}
[Static type checking] - Cannot find matching method java.lang.Object#toUpperCase(). Please check if the declared type is right and if the method exists.
 at line: 4, column: 62
{noformat}
which I believe is to be expected without hints. On rc-2 it currently gives:
{noformat}
[Static type checking] - Cannot find matching method [Ljava.lang.String;#toUpperCase(). Please check if the declared type is right and if the method exists.
 at line: 4, column: 62

Expected parameter of type java.lang.String[] but got java.lang.String
 at line: 5, column: 38

[Static type checking] - Cannot find matching method [Ljava.lang.String;#toUpperCase(). Please check if the declared type is right and if the method exists.
 at line: 5, column: 69
{noformat}
whereas I believe line 5 should pass.

Not sure whether line 4 can be made to pass but if not, I'm unsure whether the error message is ok or should be something like (""Ambiguous prototypes for closure. More than one target method matches. Please use explicit argument types."") which might involve changing the hint.
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"StringGM#findAll(CharSequence, CharSequence, Closure) variant missing @CP hint",GROOVY-6734,12817370,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,28/Apr/14 15:50,07/Apr/15 19:06,14/Jul/23 06:01,28/Apr/14 20:22,2.3.0-rc-2,,,,,,,,,,,,,,,,,2.3.0-rc-4,,,,,,,,0,,,,,,,needs the @ClosureParam hint added,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 28 20:22:32 UTC 2014,,,,,,,,,,"0|i2c9ef:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Apr/14 20:22;paulk;hint and tests added;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError with CompileStatic,GROOVY-6733,12817356,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,paulk,,28/Apr/14 15:31,07/Apr/15 19:07,14/Jul/23 06:01,29/Apr/14 04:14,2.3.0-rc-2,,,,,,,,,,,,,,,,,2.3.0-rc-4,,,,,,,,0,,,,,,,"The following code causes a VerifyError:
{code}
import groovy.transform.CompileStatic

@CompileStatic
def extractSquares(String s) {
  s.findAll(~/\d+/) { String num -> num.toInteger() }.collect{ it ** 2 }
}

assert extractSquares("" ab 12 cdef 34 jhg "") == [144, 1156]
{code}
This occurs when the DGM method has the closure param not annotated with @CP or annotated with the following value:
{code}
@ClosureParams(value=FromString.class, options={""java.lang.String"",""java.lang.String[]""}
{code}
Adding a type to the last closure makes the error vanish:
{code}
collect{ Integer num -> num ** 2 }
{code}",,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 29 04:11:01 UTC 2014,,,,,,,,,,"0|i2cgxb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Apr/14 04:11;melix;The problem is actually limited to the {{power}} call. I can reduce the example to:

{code}
def integers = [4,5]
def powers = integers.collect{ it ** it }
{code}

This problem didn't occur in 2.2.X because we needed explicit closure param types. With inference, ""it"" is now {{Object}} so we need an additional cast when performing the {{power}} call.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checking - Cannot find matching method,GROOVY-6731,12817529,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,nithril,nithril,27/Apr/14 12:18,20/May/14 05:31,14/Jul/23 06:01,15/May/14 04:32,2.2.2,,,,,,,,,,,,,,,,,2.3.1,,,,Compiler,Static Type Checker,,,0,,,,,,,"{code:java}
@TypeChecked
class Issue2 {

    public void issue() {

        transform(new Function<String, String>() {

            String apply(String input) {
                return ""ok""
            }
        })
    }

    public <I, O> void transform(Function<? super I, ? extends O> function) {
    }
}

{code}

Compiler fails with the following error:
{{TypeChecker/src/main/java/org/issues/Issue2.groovy: 14 Groovy:\[Static type checking\] - Cannot find matching method org.issues.Issue2#transform(org.issues.Issue2$1). Please check if the declared type is right and if the method exists.}}

See attachment (org.issues.Issue2)


","Maven 3 with groovy-eclipse-compiler 2.8.0-01
OpenJDK 1.7.0_51
",melix,nithril,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Apr/14 12:18;nithril;TypeChecker.zip;https://issues.apache.org/jira/secure/attachment/12723143/TypeChecker.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 29 06:59:47 UTC 2014,,,,,,,,,,"0|i2ct2n:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"29/Apr/14 06:59;melix;Might be related to  GROOVY-6723, but also probably to GROOVY-6730 (the way AIC generics are represented internally differs from other classes).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TypeChecked : Cannot use diamond <> with anonymous inner classes,GROOVY-6730,12817471,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,nithril,nithril,27/Apr/14 12:12,20/May/14 05:31,14/Jul/23 06:01,15/May/14 04:34,2.2.2,,,,,,,,,,,,,,,,,2.3.1,,,,Compiler,Static Type Checker,,,0,,,,,,,"{code:java}
@TypeChecked
class Issue1 {

    public void issue(){

        Function<String,String> function = new Function<String,String>() {
            @Override
            String apply(String input) {
                return ""ok""
            }
        }
    }
}
{code}

Compiler fails with the following error:
{{TypeChecker/src/main/java/org/issues/Issue1.groovy: 14 Groovy:\[Static type checking\] - Cannot use diamond <> with anonymous inner classes}}

See attachment (org.issues.Issue1)


","Maven 3 with groovy-eclipse-compiler 2.8.0-01
OpenJDK 1.7.0_51
",nithril,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Apr/14 12:12;nithril;TypeChecker.zip;https://issues.apache.org/jira/secure/attachment/12723101/TypeChecker.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-27 12:12:14.0,,,,,,,,,,"0|i2bpwv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FirstParam.FirstGenericType don't works whe the method returns generic type,GROOVY-6729,12818307,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,uehaj,uehaj,26/Apr/14 15:38,28/Apr/14 19:31,14/Jul/23 06:01,27/Apr/14 10:02,2.2.1,2.3.0-rc-1,,,,,,,,,,,,,,,,2.3.0-rc-2,,,,Compiler,,,,0,,,,,,,"Following code fails. The method which using FirstParam.FirstGeneics and returns generic type (where List<T>), it have no effect for closure parameter inference. FirstParam.ToString also didn't works.

 fails:
{code}
    // NG. FirstParams.FirstGenericType looks don't works.
    static <T> List<T> callee01(List<T>self, @ClosureParams(FirstParam.FirstGenericType) Closure c) {
        self.each {
            c.call(it)
        }
        return self
    }
    // NG
    @TypeChecked
    void caller01() {
        callee01([""a"",""b"",""c""]) { a ->
            println(a.toUpperCase()) // [Static type checking] - Cannot find matching method java.lang.Object#toUpperCase(). Please check if the declared type is right and if the method exists.
        }
    }
{code}

if the return type is void, it works.
{code}
    // OK
    static <T> void callee02(List<T>self, @ClosureParams(FirstParam.FirstGenericType) Closure c) {
        self.each {
            c.call(it)
        }
    }
    @TypeChecked
    void caller02() {
        callee02([""a"",""b"",""c""]) { a ->
            println(a.toUpperCase())
        }
    }
    
{code}

and if the return type is monomorphic type, its also ok(following case, it's String)

{code}
    static <T> String callee03(List<T>self, @ClosureParams(FirstParam.FirstGenericType) Closure c) {
        self.each {
            c.call(it)
        }
        return ""foo""
    }

    @TypeChecked
    void caller03() {
        callee03([""a"",""b"",""c""]) { a ->
            println(a.toUpperCase())
        }
    }
{code}
",Groovy Version: 2.3.0-rc-1 JVM: 1.7.0_10 Vendor: Oracle Corporation OS: Mac OS X 10.9.2,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"26/Apr/14 15:38;uehaj;FirstParamTest.groovy;https://issues.apache.org/jira/secure/attachment/12722672/FirstParamTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-26 15:38:54.0,,,,,,,,,,"0|i2bvtz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CLONE - generation of groovy-jdk index entries in index-all.html needs further refactoring,GROOVY-6728,12814132,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,nobeans,nobeans,26/Apr/14 06:59,05/Apr/15 14:44,14/Jul/23 06:01,01/May/14 19:38,2.3.0-rc-1,,,,,,,,,,,,,,,,,2.3.1,,,,groovy-jdk,,,,0,,,,,,,"I've requested adding ""Groovy JDK"" docset to Dash (http://kapeli.com/dash). But a Dash committer said that it needs a index of classes to add a docset. So I made a patch.

On the way I found some other issues:

* a generic type ""E[]"" in a class name isn't replaced to ""java.lang.Object[]""
* generic types ""T"", ""T[]"", etc. in a parameter aren't replaced to ""java.lang.Object[]""
* class and interface aren't distinguished in index-all.html like this:
** ""Method in class java.util.List"" must be ""Method in interface java.util.List""
** ""Set - Class in java.util"" must be ""Set - Interface in java.util""

It needs a thorough refactoring to fix them. So, first, I sent a little patch just to add a index of classes. I hope that it's merged and a ""Groovy JDK 2.3.0"" docset for Dash would be released.

I'm doing the refactoring. I'll send it as another pull request later if I finish.",,nobeans,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Fri May 02 05:43:42 UTC 2014,,,,,,,,,,"0|i2bp7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Apr/14 07:02;paulk;Initial addition of classes to the index is complete, see GROOVY-6726.;;;","28/Apr/14 04:58;paulk;OK, I did a tiny bit more refactoring - RC2 is going out shortly so I thought it a good opportunity to remove the previous hack - though it still needs more work no doubt.;;;","29/Apr/14 04:25;nobeans;OK, I'll incorporate your changes. And I'll finally check a diff between html files of HEAD of master and ones of my work branch.;;;","01/May/14 02:48;nobeans;Please review my PR: https://github.com/groovy/groovy-core/pull/403;;;","01/May/14 19:38;paulk;Merged, thanks. It is targeting 2.3.1 unless for some reason we do another RC for 2.3.0.;;;","01/May/14 21:32;nobeans;Thank you!;;;","02/May/14 05:43;paulk;I did a little bit more work:  GROOVY-3937, GROOVY-6749 and GROOVY-5983. Feel free to suggest any further refactoring that might improve those changes.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
index entries of classes are missing in index-all.html,GROOVY-6726,12817436,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,nobeans,nobeans,26/Apr/14 03:00,05/Apr/15 14:44,14/Jul/23 06:01,26/Apr/14 09:54,2.3.0-rc-1,,,,,,,,,,,,,,,,,2.3.0-rc-2,,,,groovy-jdk,,,,0,,,,,,,"I've requested adding ""Groovy JDK"" docset to Dash (http://kapeli.com/dash). But a Dash committer said that it needs a index of classes to add a docset. So I made a patch.

On the way I found some other issues:

* a generic type ""E[]"" in a class name isn't replaced to ""java.lang.Object[]""
* generic types ""T"", ""T[]"", etc. in a parameter aren't replaced to ""java.lang.Object[]""
* class and interface aren't distinguished in index-all.html like this:
** ""Method in class java.util.List"" must be ""Method in interface java.util.List""
** ""Set - Class in java.util"" must be ""Set - Interface in java.util""

It needs a thorough refactoring to fix them. So, first, I sent a little patch just to add a index of classes. I hope that it's merged and a ""Groovy JDK 2.3.0"" docset for Dash would be released.

I'm doing the refactoring. I'll send it as another pull request later if I finish.",,nobeans,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Sat Apr 26 09:54:16 UTC 2014,,,,,,,,,,"0|i2c4qv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Apr/14 03:02;nobeans;Pull request: https://github.com/groovy/groovy-core/pull/391;;;","26/Apr/14 06:56;paulk;PR merged. I also did a little bit of minor hacking to get the interface/class displaying more correctly. It should really be done in a cleaner fashion - perhaps you will cover that in your refactoring. Thanks for your PR and interest in this area. I'll clone this issue and close it off. I'll leave the cloned issue for on-going refactoring.;;;","26/Apr/14 07:00;paulk;PR merged, and issue cloned (GROOVY-6728) for on-going work, thanks again.;;;","26/Apr/14 07:04;nobeans;Thank you, Paul!

> I'll clone this issue and close it off. I'll leave the cloned issue for on-going refactoring.
OK. I keep trying the refactoring.;;;","26/Apr/14 07:21;nobeans;I want to fix just a line in template.index-all.html because it's important to make a docset of Dash by javadocset command (https://github.com/Kapeli/javadocset).

Now:
{code}
AbstractMap - class in java.util
{code}

Expected:
{code}
AbstractMap - Class in java.util
{code}

Please check PR: https://github.com/groovy/groovy-core/pull/392;;;","26/Apr/14 07:30;nobeans;Please see my last comment.;;;","26/Apr/14 09:54;nobeans;Thank you, Paul!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
XML parsing error during grape uninstall,GROOVY-6725,12817344,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,25/Apr/14 18:33,07/Apr/15 19:07,14/Jul/23 06:01,25/Apr/14 18:35,2.2.2,,,,,,,,,,,,,,,,,2.3.0-rc-2,,,,Grape,,,,0,,,,,,,"Possibly some XML changes in the past have broken the code parsing the POM during grape uninstall processing
{noformat}
> grape uninstall commons-lang commons-lang 2.3
...
Caused by: groovy.lang.MissingMethodException: No signature of method: com.sun.org.apache.xerces.internal.dom.DeferredAttrImpl.plus() is applicable for argument
 types: (org.codehaus.groovy.runtime.GStringImpl) values: [-2.3]
Possible solutions: use([Ljava.lang.Object;), split(groovy.lang.Closure), is(java.lang.Object), wait(), isId(), any()
...
        at doCall(GrapeIvy.groovy:465)
...
{noformat}
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-25 18:33:31.0,,,,,,,,,,"0|i2c3y7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missing temporary type information check if a receiver has a property with generics,GROOVY-6724,12817537,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,25/Apr/14 09:34,28/Apr/14 19:30,14/Jul/23 06:01,25/Apr/14 10:25,2.2.2,2.3.0-rc-1,,,,,,,,,,,,,,,,2.2.3,2.3.0-rc-2,,,,,,,0,,,,,,,"The following code fails to compile:

{code}
class Foo {
    List<String> items = []
}

@groovy.transform.CompileStatic
void m(Object o) {
    if (o instanceof Foo) {
        assert o.items.empty
    }
}
{code}

error:

{noformat}
UG! exception in phase 'instruction selection' in source unit 'ConsoleScript1' Declaring class for method call to '<>' declared in Foo was not matched with found receiver java.lang.Object. This should not have happened!
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.extractPlaceHolders(StaticTypeCheckingVisitor.java:3957)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.resolvePlaceHoldersFromDeclaration(StaticTypeCheckingVisitor.java:3900)
{noformat}

Only happens if the target property contains generic information.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-25 09:34:14.0,,,,,,,,,,"0|i2cchb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checking generic types on static methods incorrectly fails for trivial cases,GROOVY-6723,12817355,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mperry,mperry,25/Apr/14 05:51,01/May/14 18:01,14/Jul/23 06:01,30/Apr/14 13:52,2.3.0-rc-1,,,,,,,,,,,,,,,,,2.3.0-rc-4,,,,Static Type Checker,,,,1,,,,,,,"
Type checking for generic method type parameters does not work when calling from a static method to another static method for trivially simple cases.  

See the following gist:
https://gist.github.com/mperry/11285137

I suspect this has gotten worse from 2.2.2 to 2.3.0-rc-1 as my project, FunctionalGroovy, does this a lot and I now have many compilation issues related to this when previous I did not.  A small number of these are genuine type checking issues.

",,blackdrag,guillaume,mperry,nithril,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 30 13:52:48 UTC 2014,,,,,,,,,,"0|i2bwqf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Apr/14 06:12;mperry;I did some more investigation and the following scripts fails type checking:

{code}
import groovy.transform.TypeChecked

@TypeChecked
class C1<A> {

    def void m1(A a) {
        C1.m2(a)
    }

    static <B> void m2(B b) {

    }

}

{code}

This fails with the message:

{quote}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
D:\repositories\functionalgroovy\consume\scripts\typeCheck1.groovy: 8: [Static type checking] - Cannot call <B> C1#m2(B) with arguments [A]
 @ line 8, column 9.
           C1.m2(a)
           ^

1 error
{quote}
;;;","25/Apr/14 06:14;blackdrag;actually it irritates me that this worked in 2.2.2, since this is quite similar to GROOVY-6415;;;","28/Apr/14 21:52;mperry;Is this intended to be fixed in the final 2.3 release?  I see that it is not in 2.3-rc-2 and no one is assigned.;;;","29/Apr/14 02:28;blackdrag;I am working on this, but I can't guarantee it will be in the final. GROOVY-6415 shows that it worked before only by chance, if it was even checked at all. Is 2.3.1 ok for you?;;;","29/Apr/14 02:33;mperry;2.3.1 is fine by me.  Disappointing that type checking is such a second thought in Groovy (something so simple worked by chance?), but glad to hear it will be addressed.  I understand we all have finite resources.;;;","29/Apr/14 02:45;guillaume;Mark, type checking is not a second thought at all! We have invested a huge amount of time in this support, and it's something we don't take lightly at all. It's a much more complex problem that it might appear, and it's very tricky to make it right.
You encounter some ""trivial"" cases that appear simple intuitively, but remember the complexity of generics in general (see the huge and famous generics FAQ as an exhibit: http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html) and that supporting all possible cases is arcane and tedious, to say the least.
If ever you have some spare cycles, we would gladly welcome your help on improving it!;;;","29/Apr/14 05:48;blackdrag;Mark, I spend already the whole Monday on trying to fix the issue. It looks simple, but it is really not. And the more I look into it the more I wonder how that could have ever worked. ;;;","30/Apr/14 13:52;blackdrag;this was indeed a tough nut;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler doesn't recognize covariant array of generics,GROOVY-6722,12817354,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,25/Apr/14 04:51,28/Apr/14 19:30,14/Jul/23 06:01,27/Apr/14 11:08,2.2.2,2.3.0-rc-1,,,,,,,,,,,,,,,,2.3.0-rc-2,,,,,,,,0,,,,,,,"The following code fails to compile:

{code}
abstract class Top<Elem,Result> {
    abstract Result exec(Elem... elems)
}

class Bottom extends Top<Integer, String> {
    @Override
    String exec(Integer... elems) {
        ""$elems""
    }
}
{code}

Under 2.3.0-rc-1, it produces:

{noformat}
2 compilation errors:

Can't have an abstract method in a non-abstract class. The class 'Bottom' must be declared abstract or the method 'java.lang.Object exec(java.lang.Object[])' must be implemented.
 at line: 5, column: 1

Method 'exec' from class 'Bottom' does not override method from its superclass or interfaces but is annotated with @Override.
 at line: 6, column: 5
{noformat}

Under 2.2.2:

{noformat}
1 compilation error:

Can't have an abstract method in a non-abstract class. The class 'Bottom' must be declared abstract or the method 'java.lang.Object exec(java.lang.Object[])' must be implemented.
 at line: 5, column: 1
{noformat}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-25 04:51:19.0,,,,,,,,,,"0|i2bwhj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MalformedParameterizedTypeException when using genericed interfaces from a library,GROOVY-6718,12817495,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,jon.barksdale,jon.barksdale,22/Apr/14 17:04,28/Dec/14 10:29,14/Jul/23 06:01,28/Dec/14 04:43,2.2.2,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Compiler,,,,4,generics,,,,,,"When compiling classes that implement interfaces with generics from a library (something not in the list of classes to compile, but still on the classpath), I get a java.lang.reflect.MalformedParameterizedTypeException. 

I have attached a gradle project that demonstrates the issue with a 'gradle clean compileGroovy'

This issue seems to be only with groovyc, not with the eclipse batch compiler. 

",,acourtneybrown,gcadien,ilialewis,jon.barksdale,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"22/Apr/14 17:04;jon.barksdale;parameterized-type-bug.tar.gz;https://issues.apache.org/jira/secure/attachment/12723241/parameterized-type-bug.tar.gz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 04:43:06 UTC 2014,,,,,,,,,,"0|i2c8hj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"30/Apr/14 14:23;jon.barksdale;From what we could tell, the exception seems to stem from the wildcards in generics (<? extends SomeClass>).  

So you can remove that from the library code as a workaround until this gets fixed. ;;;","28/Dec/14 04:43;pschumacher;Thanks for reporting. Your example works with groovy 2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyDoc omits and/or misplaces documentation for methods in .java files.  ,GROOVY-6714,12818301,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jdurbin,jdurbin,16/Apr/14 20:29,28/Apr/14 19:30,14/Jul/23 06:01,25/Apr/14 05:20,2.2.1,2.3.0-beta-2,,,,,,,,,,,,,,,,2.2.3,2.3.0-rc-2,,,GroovyDoc,,,,0,,,,,,,"GroovyDoc omits and/or misplaces documentation for some methods in java programs, making a hash of documentation output for mixed Java/Groovy projects. 

Whether or not this bug presents itself depends in an odd way on the number of methods and the number of inline comments in those methods.  It seems like it only appears when there are 3 or more methods and there are five or more inline comments in the first N-2 methods, where N is the number of methods.  

A minimal example of a java program exhibiting the problem follows: 

{code:title=SmallestExample.java|borderStyle=solid}
/**
* This is the smallest example I could reproduce the error with.
*/
public class SmallestExample {
	  	
	/**
	* function1
	*/
	public int function1(){
		// comment1
		// comment2
		// comment3
		// comment4
		// comment5  (this comment breaks it)
		return(0);
	}
	
	/**
	*  function2
	*/
	public int function2(){		
		return(0);
	}
	
	/**
	* function3
	*/
	public int function3() {
		return(0);				
	}
}
{code}

Running GroovyDoc on this example will omit the documentation for function3.  If there are more functions, the error can be induced by distributing the five or more inline comments in any way among the first few functions.  If there are six or more functions in an example like this the documentation for the sixth function will appear in place of the documentation for the fifth function (in alphabetical doc order, not necessarily in file order) and the sixth function will have no documentation.  The attached file includes examples of these cases.  In a number of tests it did not seem to matter what the content of the functions were, how they were named, etc.  Only the number of functions and the number of inline comments seemed to matter.   On a large Java file (part of a mixed java/groovy project) this bug can make a total hash of the documentation, omitting documentation for many methods and, worse, swapping in the wrong documentation for many others. 

GroovyDoc was run like this (where ~/local/groovy is the path to the groovy installation): 
{noformat}
groovydoc -classpath ~/local/groovy/lib/ -d doc/ ./minexamples/*.java
{noformat}
","Mac OS X 10.9.2
java version ""1.7.0_21""
Java(TM) SE Runtime Environment (build 1.7.0_21-b12)
Java HotSpot(TM) 64-Bit Server VM (build 23.21-b01, mixed mode)",jdurbin,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6254,,,,,,"16/Apr/14 20:29;jdurbin;groovydocbug.tgz;https://issues.apache.org/jira/secure/attachment/12723098/groovydocbug.tgz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 25 05:20:14 UTC 2014,,,,,,,,,,"0|i2c9pb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Apr/14 02:17;paulk;I haven't tracked down exactly where it occurs but it seems that single-line comments in Java are getting counted as two lines by the time it gets through the slightly convoluted parsing path which Java goes through for Groovydoc. Because the current Groovy parsing framework doesn't capture comments - they are thrown away during parsing - we have a hack which reads the raw source lines between the line numbers which we store away for each language component. With the single-line comments being counted as two lines, the from and to values we are using to extract the comment text are just plain wrong. If there has only been a small number of single-line comments in a file, you might not notice it but as you have already noted, once you get too many, the line counts are incorrect and we are grabbing the wrong text.;;;","25/Apr/14 02:42;pschumacher;Maybe [GROOVY-6254] and this issue are related? Both seems to be somehow caused by single-line comments in a java file.;;;","25/Apr/14 05:20;paulk;For some reason the java.g grammar file was putting an extra newline after single-line comments. Thanks for raising the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inherited generic property do not honour type ,GROOVY-6713,12817330,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,pablo72,pablo72,16/Apr/14 15:50,28/Dec/14 04:46,14/Jul/23 06:01,28/Dec/14 04:46,2.2.1,2.4.0-beta-3,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Static compilation,,,,0,,,,,,,"Generic properties do not honour the declared type in the subclass. For example:

{code}@CompileStatic
class X<T> {

  T target

}

@CompileStatic
class Y extends X<InputStream> {

  def f() {  target.read() }

}{code}

Reports the following compilation error:

org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
test.groovy: 14: [Static type checking] - Cannot find matching method java.lang.Object#read(). Please check if the declared type is right and if the method exists.
 @ line 14, column 14.
     def f() {  target.read()
",Groovy Version: 2.2.1 JVM: 1.7.0_40 Vendor: Oracle Corporation OS: Mac OS X,paolodt,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 04:46:10 UTC 2014,,,,,,,,,,"0|i2bu6v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Dec/14 04:46;pschumacher;Thanks for reporting. Your example works with groovy 2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Instantiating traits with generics that extend traits with generics does not compile,GROOVY-6708,12817504,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mperry,mperry,14/Apr/14 22:18,24/Apr/14 19:00,14/Jul/23 06:01,22/Apr/14 06:07,2.3.0-beta-2,,,,,,,,,,,,,,,,,2.3.0-rc-1,,,,,,,,0,,,,,,,"Groovy 2.3.0-beta-2 does not compile programs where a generic trait extends another generic traits with that same parameter.

I have put an example project that does not compile on Github at:

https://github.com/mperry/bug-trait-generic-inheritance

In this case, we have the trait Applicative<M> and trait Monad<M> extends Applicative<M> with a single method named ""left"" that uses the type M. A class that implements Applicative compiles, but one that implements Monad does not.
",,mperry,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-14 22:18:22.0,,,,,,,,,,"0|i2bzh3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy 2.3.0-beta-2 generic type checking incorrect,GROOVY-6707,12817499,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mperry,mperry,14/Apr/14 19:42,20/May/14 05:31,14/Jul/23 06:01,09/May/14 10:20,2.3.0-beta-2,,,,,,,,,,,,,,,,,2.3.1,,,,,,,,0,,,,,,,"Type checking a returned value from a generic method does not type check in Groovy 2.3.0-beta-2, but does in Groovy 2.2.2.  See the following gist:

https://gist.github.com/mperry/10692600

The output I get is:

D:\repositories\groovy-2.3-experimental\docs\scripts>groovy setTypeChecking.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
D:\repositories\groovy-2.3-experimental\docs\scripts\setTypeChecking.groovy: 31:
[Static type checking] - Cannot call <T> java.util.Set <java.util.List>#equals(java.util.Set <T>) with arguments [java.util.Set <java.util.List>]
 @ line 31, column 20.
           assertTrue(s == expected)
                      ^

D:\repositories\groovy-2.3-experimental\docs\scripts\setTypeChecking.groovy: 32:
[Static type checking] - Cannot call <T> java.util.Set <java.util.List>#equals(java.util.Set <T>) with arguments [java.util.Set <java.util.List>]
 @ line 32, column 20.
           assertTrue(create([1, 2]) == expected)
                      ^

2 errors

I am using Windows 7.

Note that the other lines type check pass that appear to have similar types involved.
",,blackdrag,mperry,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 09 10:20:34 UTC 2014,,,,,,,,,,"0|i2bstb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/May/14 10:20;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Custom base script abstract method throws NPE with the @BaseScript annotation on imports,GROOVY-6706,12817502,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,guillaume,guillaume,14/Apr/14 17:14,02/Jun/14 15:27,14/Jul/23 06:01,25/Apr/14 02:58,2.3.0-beta-2,,,,,,,,,,,,,,,,,2.3.0-rc-2,,,,,,,,0,,,,,,,"I was trying the custom abstract method for base scripts and encountered an NPE while using this variant with the base script class on imports:

{code}
@BaseScript(CustomBase)
import groovy.transform.BaseScript

println 'Hello'

abstract class CustomBase extends Script {
    def run() {
        before()
        internalRun()
        after()
    }
    
    abstract internalRun()
    
    def before() { println 'before' }
    def after()  { println 'after'  }
}
{code}

However, the version with the base script annotated local variable works:

{code}
import groovy.transform.BaseScript

@BaseScript CustomBase script

println 'Hello'

abstract class CustomBase extends Script {
    def run() {
        before()
        internalRun()
        after()
    }
    
    abstract internalRun()
    
    def before() { println 'before' }
    def after()  { println 'after'  }
}
{code}

The NPE I'm getting from within the Groovy Console is:
{code}
BUG! exception in phase 'semantic analysis' in source unit 'basescript_custom_abstract_metod.groovy' unexpected NullpointerException
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1052)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:583)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:561)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:538)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:286)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:259)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:674)
	at groovy.lang.GroovyShell.run(GroovyShell.java:501)
	at groovy.lang.GroovyShell.run(GroovyShell.java:481)
	at groovy.lang.GroovyShell.run(GroovyShell.java:164)
	at groovy.lang.GroovyShell$run$1.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:977)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor240.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure.call(Closure.java:417)
	at groovy.lang.Closure.run(Closure.java:504)
	at java.lang.Thread.run(Thread.java:744)
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.ast.ClassNode.removeMethod(ClassNode.java:596)
	at org.codehaus.groovy.transform.BaseScriptASTTransformation.changeBaseScriptType(BaseScriptASTTransformation.java:134)
	at org.codehaus.groovy.transform.BaseScriptASTTransformation.changeBaseScriptTypeFromPackageOrImport(BaseScriptASTTransformation.java:78)
	at org.codehaus.groovy.transform.BaseScriptASTTransformation.visit(BaseScriptASTTransformation.java:63)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1047)
	... 23 more
{code}",,guillaume,jimwhite,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 02 15:27:59 UTC 2014,,,,,,,,,,"0|i2by2v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Apr/14 17:57;jimwhite;I've seen an NPE like this also when using both a --basescript option on the command line along with a @BaseScript annotation in the script.

Also note that I did not implement the annotation on imports feature, although I will take a look at what the problem is.
;;;","16/Apr/14 14:15;jimwhite;Problem is that the AST transform is getting called more than once in certain situations.  Not only when using @BaseScript on imports but also things like configuring the base script from the command line or CompilerConfig.  This raises questions about which base class to use.  At the moment the solution is just to ignore the method change if it has already happened and there isn't a default run method in the AST for any reason.  

Fix is in PR #371.;;;","24/Apr/14 14:09;jimwhite;This bug fix should not be deferred from 2.3.0.  If you are refusing GROOVY-6675 then you should cherry pick the fix for this bug from PR #371.  It is the only one that touches BaseScriptTransformTest.groovy and BaseScriptASTTransformation.java.
;;;","24/Apr/14 20:26;paulk;I believe I have cherry picked this onto master and the rc branch but the next fix version hasn't been created yet (rc-2 I presume). I'll leave this open until that is created.;;;","25/Apr/14 02:58;paulk;Applied Jim's patch.;;;","02/Jun/14 15:27;jimwhite;The fix for this is in PR #371.  For some reason it still shows up as a difference against what I assume is the branch point in master.  I've run merge of my GROOVY-6675 against the current master (which is what the TeamCity CI build is doing also) and all remains well.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Memory leak in ClassInfo when using MetaClasses,GROOVY-6704,12813177,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,candrews,candrews,14/Apr/14 14:12,10/Oct/15 11:30,14/Jul/23 06:01,10/Oct/15 11:30,2.0.8,2.1.9,,,,,,,,,,,,,,,,2.4.0-beta-2,,,,,,,,0,,,,,,,"I'm trying to track down a memory leak in Grails and I'm pretty sure I've discovered the root cause of the leak is in Groovy. For reference, here's the thread on the grails-dev list on this topic: http://grails.1312388.n4.nabble.com/Easily-reproducible-memory-leak-in-Grails-td4655816.html

I also raised this issue on the groovy-dev mailing list at http://groovy.329449.n5.nabble.com/Memory-leak-in-ClassInfo-when-using-MetaClasses-td5719218.html

The problem is that when a class is loaded, then a metaclass is assigned, then the class is no longer reachable, the metaclass remains in memory. When this happens many times, lots of metaclasses are leaked, which becomes a significant problem. I discovered this problem because this how Grails implements GSPs - by loading the GSP as a groovy class, then when the GSP changes, loading a new class. The old class is unreachable, except for some internal Groovy structures... hence the memory leak.

Attached there is a junit test that reproduces this problem: [^LeakTest.groovy]

Eventually, that results in an OutOfMemoryError. Using a tool like visualvm, it is clear that the number of classes constantly rises, none are ever unloaded, and the permgen keeps getting used. The heap also rises. In my tests, it usually dies after about 5,000 iterations.

In my opinion, this shouldn't happen - this test case should run without leaking memory. Groovy should allow the MetaClasses to be garbage collected once the Class is no longer referenced by anything else. In other words, Groovy should hold a weak reference to the MetaClass/ClassInfo/etc for the Class based on the reachability of the Class.

By taking a heap dump in visualvm, I found that there are lots of instances of org.codehaus.groovy.runtime.metaclass.MetaMethodIndex$Entry.

The problem areas (that are GC roots) seem to be:
org.codehaus.groovy.reflection.ClassInfo's static field modifiedExpandos
org.codehaus.groovy.reflection.ClassInfo's static field globalClassSet

The classes that area created by classLoader.parseClass also stick around, which is why the permgen is leaking.

Can someone please help me determine how to fix this problem in Groovy?",,blackdrag,candrews,githubbot,jbochenski,lhotari,melix,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7591,GROOVY-7623,,,,,,,,,,,,,,,,"09/Oct/15 20:30;candrews;CVTest.java;https://issues.apache.org/jira/secure/attachment/12765900/CVTest.java","14/Apr/14 14:12;candrews;LeakTest.groovy;https://issues.apache.org/jira/secure/attachment/12722402/LeakTest.groovy","09/Oct/15 20:30;candrews;MyClassValue.java;https://issues.apache.org/jira/secure/attachment/12765901/MyClassValue.java",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Oct 10 11:30:50 UTC 2015,,,,,,,,,,"0|i2cd0n:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"04/May/14 18:11;candrews;I have created 2 pull requests (so far) in my attempt to address this issue:
https://github.com/groovy/groovy-core/pull/395 Use java.lang.ClassValue in ClassInfo (when available)
https://github.com/groovy/groovy-core/pull/407 Change ClassInfo.modifiedExpandos from being a HashSet (strong references) to a ManagedLinkedList (weak references);;;","24/Oct/14 17:23;pschumacher;Blackdrag merged the pull request back in July.

@Craig: Thanks for reporting this issue and for the pull requests. :);;;","25/Oct/14 03:26;melix;I am reopening this issue because the fix is still causing the Grails + Groovy 2.4 build to fail.;;;","25/Nov/14 02:27;lhotari;I'm trying to understand the org.codehaus.groovy.reflection.ClassInfo class, but I've never really been able to comprehend it. The role of modifiedExpandos is unclear to me.

It looks like it intentionally was a container to keep strong references and the PR with the commit https://github.com/groovy/groovy-core/commit/9960af91bdda5fce1c1285669199a6aabc664c53 broke this. 

The modifiedExpandos field didn't seem to be used for anything before so the only role I can see is to hold strong references intentionally.;;;","25/Nov/14 02:33;lhotari;The failing grails tests can be reproduced with the following steps:
{code}
git clone https://github.com/groovy/groovy-core.git
cd groovy-core
git checkout fccb7011c7
./gradlew clean jarAll install

cd ..
git clone https://github.com/grails/grails-core.git
cd grails-core
git checkout 2.5.x
./gradlew -Dgroovy.jar=../groovy-core/target/libs/groovy-all-2.4.0-SNAPSHOT.jar clean test
{code};;;","25/Nov/14 02:48;lhotari;faster way of reproducing failure
{code}
./gradlew -Dgroovy.jar=../groovy-core/target/libs/groovy-all-2.4.0-SNAPSHOT.jar :grails-test-suite-web:test -x :grails-test-suite-web:execIsolatedTests
{code}

it looks like some shared state is causing the problem since running tests in isolation makes them pass:
{code}
./gradlew -Dgroovy.jar=../groovy-core/target/libs/groovy-all-2.4.0-SNAPSHOT.jar :grails-test-suite-web:test -x :grails-test-suite-web:execIsolatedTests --tests '*.LinkRenderingTagLibTests'
{code};;;","25/Nov/14 16:06;candrews;[~lhotari] I just tried getting reproducing this failure. I was previously able to get it, and I had a bit of time, so I was going to work on it. However, I now can't get the failure to occur.

I tried your steps except I used the head of groovy-core/master (fa1192f6705054eb6f4de394e7bbab716d6b567e) and grails-core/2.5.x (bb5dc85041968563afa9adfd75e520c65cbec4dd).
{noformat}
C:\projects\grails-core>gradlew -Dgroovy.jar=C:\Users\candrews\Documents\GitHub\groovy-core\target\libs\groovy-all-2.4.0-SNAPSHOT.jar :grails-test-suite-web:test -x :grails-test-suite-web:execIsolatedTests
{noformat}
passed every time (I ran it a few times in case it was a race condition).;;;","25/Nov/14 16:08;lhotari;Craig, yes. I forgot to update progress here. It was a problem in AbstractGrailsTagTests class in Grails that didn't clean up metaclass changes. Fixed by commit https://github.com/grails/grails-core/commit/0eea2ca72c4a6a8399e1fb7c79e7ac7ea164c106
;;;","25/Nov/14 16:17;candrews;[~lhotari] cool, thanks for the update!

So it sounds like this issue should now be resolved as fixed. Woo hoo!;;;","09/Oct/15 16:20;candrews;Due to an OpenJDK bug https://bugs.openjdk.java.net/browse/JDK-8136353 a flag was added which disables the use of java.lang.ClassValue by default (flag added in Groovy 2.4.5, see GROOVY-7591). This change causes this memory leak issue to once again be a problem (hence I've reopened this issue).

The flag should be flipped to be enable the use of java.lang.ClassValue by default when the OpenJDK issue is fixed, which will once again fix this issue.

Also, it's been reported that the OpenJDK issue does not impact IBM J9 - so perhaps the flag should default to disabling  java.lang.ClassValue only on OpenJDK/Oracle Java, but enabled when using other JVMs? I've submitted a pull request at https://github.com/apache/incubator-groovy/pull/137;;;","09/Oct/15 16:30;githubbot;GitHub user candrews opened a pull request:

    https://github.com/apache/incubator-groovy/pull/137

    GROOVY-6704 Use ClassValue by default on IBM Java

    IBM Java doesn't have the ClassValue garbage collection issue that OpenJDK has (https://bugs.openjdk.java.net/browse/JDK-8136353) so when running on that JVM, enable ClassValue by default.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/candrews/incubator-groovy patch-1

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/137.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #137
    
----
commit d63f5dc62cf26a9abe16c15d046389cc273a7f11
Author: Craig Andrews <candrews@integralblue.com>
Date:   2015-10-09T16:30:10Z

    GROOVY-6704 Use ClassValue by default on IBM Java
    
    IBM Java doesn't have the ClassValue garbage collection issue that OpenJDK has (https://bugs.openjdk.java.net/browse/JDK-8136353) so when running on that JVM, enable ClassValue by default.

----
;;;","09/Oct/15 16:33;blackdrag;Craig, I thought you have confirmed that it worked. That ClassValue bug is something I found in all JDK8 and 9 versions I tested. It is very possible, that under some circumstance ClassValue still works, even with that bug. So can you verify the problem still exists?;;;","09/Oct/15 17:09;candrews;I did test it at the time, and I I just re-ran the test again.

JAVA_OPTS=-Xmx20m ./groovy ~/Downloads/LeakTest.groovy
fails after 373 iterations (which is to be expected as it's not using ClassValue so the original GROOVY-6704 occurs)

JAVA_OPTS=-Xmx20m ./groovy -Dgroovy.use.classvalue=true ~/Downloads/LeakTest.groovy
ran seemingly indefinitely (I let it get to 3,000 iterations before I got bored)

Java version:
$ java -version
openjdk version ""1.8.0_60""
OpenJDK Runtime Environment (build 1.8.0_60-b27)
OpenJDK 64-Bit Server VM (build 25.60-b23, mixed mode)

So the original LeakTest.groovy test still passes.

The test case at https://bugs.openjdk.java.net/browse/JDK-8136353 doesn't compile (""Other"" is undefined) - do you know how to reproduce that issue?

Also, do we have a test case that reproduces GROOVY-7591? So far, I have no idea how to see the problem that resulted in the change being made for ClassValue to be disabled by default.;;;","09/Oct/15 18:59;blackdrag;doesn't compile? Ah man... I really dislike the way of reporting bugs at Oracle. that bug report was done by me. But of course not directly, instead I have to write someone, who then puts it in a JIRA. I myself have no chance of commented or writing directly on the issue. Which also means I cannot fix the typo, that got in there somehow. Ah well... Other is supposed to be Dummy.;;;","09/Oct/15 20:30;candrews;I also really dislike the Oracle issue tracker... you can't even watch issues (nevermind add comments) unless you have an account, and it seems like very few people are eligible for accounts.

Still doesn't run:
{noformat}
Exception in thread ""main"" java.lang.IllegalAccessError: tried to access class Dummy from class MyClassValue
	at MyClassValue.computeValue(MyClassValue.java:6)
	at java.lang.ClassValue.getFromHashMap(ClassValue.java:227)
	at java.lang.ClassValue.getFromBackup(ClassValue.java:209)
	at java.lang.ClassValue.get(ClassValue.java:115)
	at CVTest.main(CVTest.java:13)
{noformat}

By changing Dummy to an inner class, I can make it run. I've attached [^CVTest.java] and [^MyClassValue.java]

Here's what I did:
$ javac MyClassValue.java && javac CVTest.java && jar cvf t/t.jar MyClassValue*.class && rm MyClassValue*.class && JAVA_OPTS=-Xmx4m java CVTest

After a while (~20 minutes) I got this error:
{noformat}
Exception in thread ""main"" java.lang.OutOfMemoryError: Compressed class space
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:760)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:73)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:368)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:362)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:361)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at CVTest.main(CVTest.java:12)
{noformat}
So I guess that's the test case and resulting proof for JDK-8136353

I find it fascinating that LeakTest.groovy does not hit JDK-8136353;;;","10/Oct/15 09:50;blackdrag;you can make the class public, then it should work. But 20 minutes for 4 MB mx... wow, I remember that failing faster. Anyway, it fails. 

As for why LeakTest.groovy does not hit the problem.. my assumption is the following: The error happens only for class values added to higher class loaders, maybe it is even limited to application and or system classloader. So Integer would be an example for this. 

In LeakTest you do generate a big amount of clases, but they are children of a class loader hosting the registry. For classes like Integer there will be only one entry for the life cycle of that test. 

I extracted that failing test from a problem Cedric had with Gradle, that caused the Groovy runtime to load many many times. Took a while of our both time to condense it to a test case as simple as the one in the java bug tracker ;) But I am happy I was able to exclude all of Groovy in that.;;;","10/Oct/15 11:30;melix;I'm closing this issue. We do not reopen issues for released version of Groovy. Please either create a duplicate of this bug report or create a new one explaining the different case. It makes it easier to follow since tickets belong to release notes.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Trait, public fields & as-operator",GROOVY-6702,12817351,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mxm-groovy,mxm,14/Apr/14 09:10,17/Jun/15 20:10,14/Jul/23 06:01,16/Apr/14 08:22,,,,,,,,,,,,,,,,,,2.3.0-rc-1,,,,,,,,0,,,,,,,"IMHO this code should work, now (snapshot from buildserver built on the 14th of April) it doesn't.
{code}
trait A {
    public abc = 4
}

assert (new Object() as A).pack_A__abc == 4
{code}",,melix,mxm,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 16 08:22:58 UTC 2014,,,,,,,,,,"0|i2covj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Apr/14 08:22;melix;Fixed, thanks for reporting it!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
index entries of same method name are missing in index-all.html,GROOVY-6701,12817380,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,nobeans,nobeans,14/Apr/14 08:36,24/Apr/14 19:00,14/Jul/23 06:01,14/Apr/14 09:08,,,,,,,,,,,,,,,,,,2.3.0-rc-1,,,,groovy-jdk,,,,0,,,,,,,"Some method names are used between different classes: for example, abs(), asBoolean(). But they are showed only once in index-all.html. So there are smaller number of index entries than actual existences.

It's caused by wrong implementation of comparator of TreeSet in DocGenerator.groovy. I sent a pull request to fix it. Please check it out.

https://github.com/groovy/groovy-core/pull/384",,guillaume,nobeans,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 14 09:08:00 UTC 2014,,,,,,,,,,"0|i2bzmn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Apr/14 08:54;guillaume;Well spotted!;;;","14/Apr/14 09:08;guillaume;Well spotted, thanks for the fix!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Deprecate old groovy.util.GroovyAssert class in favor of the new Groovy 2.3 groovy.test.GroovyAssert class,GROOVY-6700,12817507,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,guillaume,guillaume,guillaume,13/Apr/14 06:28,24/Apr/14 19:00,14/Jul/23 06:01,13/Apr/14 06:31,,,,,,,,,,,,,,,,,,2.3.0-rc-1,,,,,,,,0,,,,,,,,,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-13 06:28:41.0,,,,,,,,,,"0|i2brvj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Setting property in trait using ""super"" doesn't work",GROOVY-6697,12817494,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,will_lp,will_lp,11/Apr/14 13:22,23/Feb/15 01:12,14/Jul/23 06:01,14/Jan/15 08:48,2.3.0-beta-2,2.4.0-rc-1,,,,,,,,,,,,,,,,2.4.1,,,,groovy-runtime,,,,0,traits,,,,,,"
{code}
trait A {
  String foo
  def yell() { foo.toUpperCase() + ""!!"" }
}

class C implements A {
  void setBar(String foo) {
    // This fails with ""Caught: groovy.lang.MissingPropertyException: No such property: super for class: A""
    //A.super.foo = foo
   
    // This work
    A.super.setFoo(foo)
  }
}
{code}",Ubuntu 13.10. JDK 1.7.0_51-b13,pschumacher,will_lp,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 04:54:10 UTC 2014,,,,,,,,,,"0|i2bvon:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Dec/14 04:47;pschumacher;Thanks for reporting. Your example works with groovy 2.4.0-rc-1.;;;","28/Dec/14 04:54;pschumacher;Closed by accident. Still does not work.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@attribute on groovy.util.Node does not work when meta class is modified,GROOVY-6696,12818300,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,baptiste.mesta,baptiste.mesta,11/Apr/14 08:45,02/May/17 02:03,14/Jul/23 06:01,24/Apr/16 16:35,2.2.2,,,,,,,,,,,,,,,,,,,,,XML Processing,,,,0,,,,,,,"if a closure is added to the meta class it seems that the node.@attribute is not working anymore
however it is still working when we use quotes, i.e. node.'@attribute'

here is some tests that reproduce the probleme, they have to be run alone
{code:java}
    @Test
    public void working() throws Exception {
        //given
        def root = new XmlParser().parseText('''<node id=""12"">value</node>''')

        //when
        String id = root.@id;

        //then
        assertEquals(""12"", id);
    }
    @Test
    public void notWorking() throws Exception {
        //given
        Node.metaClass.findParent = { closure ->
            def parent = delegate.parent()
            if(parent == null){
                return null
            }
            if(closure(parent)){
                return parent
            }
            return parent.findParent(closure)
        }

        def root = new XmlParser().parseText('''<node id=""12"">value</node>''')

        //when
        String id = root.@id;

        //then
        assertEquals(""12"", id);
    }
    @Test
    public void workingOnlyWithQuotes() throws Exception {
        //given
        Node.metaClass.findParent = { closure ->
            def parent = delegate.parent()
            if(parent == null){
                return null
            }
            if(closure(parent)){
                return parent
            }
            return parent.findParent(closure)
        }

        def root = new XmlParser().parseText('''<node id=""12"">value</node>''')

        //when
        String id = root.'@id';

        //then
        assertEquals(""12"", id);
    }
{code}",,baptiste.mesta,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Apr 24 16:35:50 UTC 2016,,,,,,,,,,"0|i2cd2f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Apr/16 18:18;jwagenleitner;Running the following in GroovyConsole succeeds, I tested with 2.2.2, 2.4.6 and master:

{code}
import org.junit.*
import static org.junit.Assert.*

class Groovy6696Bug  {
    @Test
    public void notWorking() throws Exception {
        //given
        Node.metaClass.findParent = { closure ->
            def parent = delegate.parent()
            if(parent == null){
                return null
            }
            if(closure(parent)){
                return parent
            }
            return parent.findParent(closure)
        }

        def root = new XmlParser().parseText('''<node id=""12"">value</node>''')

        //when
        String id = root.@id;

        //then
        assertEquals(""12"", id);
    }
}
{code}

Results are:

{code}
JUnit 4 Runner, Tests: 1, Failures: 0, Time: 31
{code};;;","24/Apr/16 16:35;jwagenleitner;Resolving this since I can't reproduce.  Please reopen if it's still an issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
trait's groovyProxy is not DGM compatible,GROOVY-6695,12818297,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,uehaj,uehaj,11/Apr/14 03:37,31/Mar/15 06:08,14/Jul/23 06:01,13/Mar/15 14:39,2.3.0-beta-1,2.3.0-beta-2,,,,,,,,,,,,,,,,,,,,Compiler,,,,0,traits,,,,,,"Following test code:
{code}
class DynamicTraitTest extends GroovyTestCase {
  @groovy.transform.TypeChecked
  void testTraitTest() {
      def x = new String(""hello"") as Helloable
      x.hello()
      assert !(x instanceof String)
      assert x instanceof Helloable
      assert x.toUpperCase() == ""HELLO"" // exptected
      assert x.tr('h','*') == ""*ello"" // fails
  }
}

trait Helloable implements CharSequence {
    void hello() { println ""hello"" }
}

{code}
generates following Exception.
{quote}
% groovy dynamictrait2.groovy
groovy dynamictrait2.groovy
.hello
E
Time: 0.182
There was 1 error:
1) testTraitTest(DynamicTraitTest)Assertion failed: 

assert x.tr('h','*') == ""*ello"" // fails
       | |           |
       | |           false
       | String1_groovyProxy@1ce24091
       String1_groovyProxy@1ce24091

	at org.codehaus.groovy.runtime.InvokerHelper.assertFailed(InvokerHelper.java:398)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.assertFailed(ScriptBytecodeAdapter.java:646)
	at DynamicTraitTest.testTraitTest(dynamictrait2.groovy:9)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1318)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:927)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:77)
	at groovy.lang.GroovyShell.runJUnit3Test(GroovyShell.java:353)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:273)
	at groovy.lang.GroovyShell.run(GroovyShell.java:502)
	at groovy.lang.GroovyShell.run(GroovyShell.java:491)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:627)
	at groovy.ui.GroovyMain.run(GroovyMain.java:379)
	at groovy.ui.GroovyMain.process(GroovyMain.java:365)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:124)
	at groovy.ui.GroovyMain.main(GroovyMain.java:104)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)

FAILURES!!!
Tests run: 1,  Failures: 0,  Errors: 1

{quote}
IMHO, String.tr() is a DGM method for String, so above code is expected to be succeeded same as String.toUpperCase() on the groovyProxy.
","groovy -version
Groovy Version: 2.3.0-beta-2 JVM: 1.8.0 Vendor: Oracle Corporation OS: Mac OS X

java -version
java version ""1.8.0""
Java(TM) SE Runtime Environment (build 1.8.0-b132)
Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode)",melix,thejeed,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Apr/14 03:37;uehaj;dynamictrait2.groovy;https://issues.apache.org/jira/secure/attachment/12722194/dynamictrait2.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 13 14:39:07 UTC 2015,,,,,,,,,,"0|i2csef:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Apr/14 16:29;uehaj;deleted;;;","13/Mar/15 14:39;melix;Works with 2.4.1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static method call within trait is not transformed properly,GROOVY-6694,12817468,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,11/Apr/14 02:47,24/Apr/14 19:00,14/Jul/23 06:01,11/Apr/14 02:47,2.3.0-beta-2,,,,,,,,,,,,,,,,,2.3.0-rc-1,,,,,,,,0,,,,,,,"In the following example, the {{LOGGER}} receiver in the {{info}} method of the trait doesn't delegate to the class receiver, leading to a runtime error.

{code}
import java.util.logging.Logger

            trait Loggable {

                static def LOGGER = Logger.getLogger(this.class.name)

                void info(String msg) {
                    LOGGER.info(msg)
                }
            }

            class Test implements Loggable {}

            def t = new Test()
            t.info('foo')
{code}",,hubbitus,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-11 02:47:01.0,,,,,,,,,,"0|i2bv9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler fails to infer type if given a concrete type instead of a generified interface,GROOVY-6693,12817488,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,melix,melix,10/Apr/14 10:40,20/May/14 05:31,14/Jul/23 06:01,12/May/14 05:15,2.3.0-beta-2,,,,,,,,,,,,,,,,,2.3.1,,,,Static Type Checker,,,,0,,,,,,,"The following test case fails:

{code}
import groovy.transform.ASTTest
import static org.codehaus.groovy.transform.stc.StaticTypesMarker.*
import static org.codehaus.groovy.ast.ClassHelper.*

interface Converter<F, T> {
T convertC(F from)
}
  
class Holder<T> {
   T thing
  
   Holder(T thing) {
    this.thing = thing
   }
  
   def <R> Holder<R> convertH(Converter<? super T, ? extends R> func1) {
      new Holder(func1.convertC(thing))
   }
}

class IntToFloatConverter implements Converter<Integer,Float> {
    public Float convertC(Integer from) { from.floatValue() } 
}
 
@groovy.transform.TypeChecked
void foo() {
@ASTTest(phase=INSTRUCTION_SELECTION,value={
    def holderType = node.getNodeMetaData(INFERRED_TYPE)
    assert holderType.genericsTypes[0].type == Float_TYPE
})
def h1 = new Holder<Integer>(2).convertH(new IntToFloatConverter())
}
foo()
{code}

The important part is that when inference is done, it should map the placeholders from {{Converter<F,T>}} to the concrete implementations of {{IntToFloatConverter}}, that is to say {{Integer}} and {{Double}}.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-10 10:40:32.0,,,,,,,,,,"0|i2bpw7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
trait's groovyProxy class doesn't dispatch String#toString(),GROOVY-6692,12818296,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,uehaj,uehaj,10/Apr/14 01:35,24/Apr/14 19:00,14/Jul/23 06:01,16/Apr/14 06:59,2.3.0-beta-1,,,,,,,,,,,,,,,,,2.3.0-rc-1,,,,Compiler,,,,0,,,,,,,"following code(attached):
{code}
class DynamicTraitTest extends GroovyTestCase {
  @groovy.transform.TypeChecked
  void testTraitTest() {
      def x = new String(""hello"") as Helloable
      x.hello()
      assert !(x instanceof String)
      assert x.toUpperCase() == ""HELLO"" // exptected
      assert x.toString() == ""hello"" // fails
  }
}

trait Helloable {
    void hello() { println ""hello"" }
}
{code}

generate following exception:
{quote}
% groovy dynamictrait.groovy
 groovy dynamictrait.groovy
 .hello
 E
 Time: 0.13
 There was 1 error:
 1) testTraitTest(DynamicTraitTest)Assertion failed: 

 assert x.toString() == ""hello"" // fails
\        | |          |
\        | |          false
\        | String1_groovyProxy@24269709
\        String1_groovyProxy@24269709

     at org.codehaus.groovy.runtime.InvokerHelper.assertFailed(InvokerHelper.java:398)
     at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.assertFailed(ScriptBytecodeAdapter.java:646)
     at DynamicTraitTest.testTraitTest(dynamictrait.groovy:8)
     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
     at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
     at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
     at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1318)
     at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:927)
     at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:77)
     at groovy.lang.GroovyShell.runJUnit3Test(GroovyShell.java:353)
     at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:273)
     at groovy.lang.GroovyShell.run(GroovyShell.java:502)
     at groovy.lang.GroovyShell.run(GroovyShell.java:491)
     at groovy.ui.GroovyMain.processOnce(GroovyMain.java:627)
     at groovy.ui.GroovyMain.run(GroovyMain.java:379)
     at groovy.ui.GroovyMain.process(GroovyMain.java:365)
     at groovy.ui.GroovyMain.processArgs(GroovyMain.java:124)
     at groovy.ui.GroovyMain.main(GroovyMain.java:104)
     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
     at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
     at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)

 FAILURES!!!
 Tests run: 1,  Failures: 0,  Errors: 1
{quote}


I don't know precise behavior of above case, but metaClass.mixin works with this code:
{code}
class DynamicMixinTest extends GroovyTestCase {
  void testTraitTest() {
      String.metaClass.mixin Helloable
      def x = ""hello"".asType(Helloable)
      x.hello()
      assert !(x instanceof String)
      assert x.toUpperCase() == ""HELLO"" // exptected
      assert x.toString() == ""hello"" // fails
  }
}

class Helloable {
    void hello() { println ""hello"" }
}

{code}
","% groovy -v
Groovy Version: 2.2.0-rc-3 JVM: 1.8.0 Vendor: Oracle Corporation OS: Mac OS X
% java -version
java version ""1.8.0""
Java(TM) SE Runtime Environment (build 1.8.0-b132)
Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode)",melix,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Apr/14 01:35;uehaj;dynamictrait.groovy;https://issues.apache.org/jira/secure/attachment/12722668/dynamictrait.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 16 06:59:40 UTC 2014,,,,,,,,,,"0|i2c3xz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Apr/14 02:50;melix;I'm not sure it should be considered as a bug actually. What do others think? Should a proxy delegate the Object methods to the delegate?;;;","12/Apr/14 02:36;uehaj;I have small question about specification of trait.

Follwing code is based on a sample from [html/documentation/core-traits.html|http://beta.groovy-lang.org/docs/groovy-2.3.0-SNAPSHOT/html/documentation/core-traits.html#_runtime_implementation_of_traits].

{code}
trait Extra {
    String extra() { ""I'm an extra method"" }            
}
class Something {                                       
    String doSomething() { 'Something' }                
}
// @groovy.transform.TypeChecked
def foo() {
  def s = new Something() as Extra
  s.extra()
  s.doSomething()  // (1) [Static type checking] - Cannot find matching method Extra#doSomething(). Please check if the declared type is right and if the method exists.
}
{code}

(1) is stc error(definitly you know).
We can avoid this with follwing workaround.

{code}
trait Extra {
    String extra() { ""I'm an extra method"" }            
}
class Something {                                       
    String doSomething() { 'Something' }                
}
@groovy.transform.TypeChecked
def foo() {
  Something orig = new Something()
  def s = orig as Extra
  s.extra()
  orig.doSomething() // OK
}
{code}

But if so what is the raison d'etre of dispatching method like doSomething() to base object?
At least, in current trait specification, to mimic original object with proxy class looks not clear.
It looks incomplete because:

- (1) the proxy is not 'instanceof' of proxy target class(as mentioned in the Groovy trait spec)
- (2) the proxy is not DGM complient (GROOVY-6695)
- (3) method call to Object method(or any method which defined on parent class?) is not works expectedly(this GROOVY-6692)
- (4) call to original method is not STC safe(above example)

If so, it might be better to remove dispatching method?
If you want to use proxy target object, you can use it directly(like above workaround).

Probably you know, as contrasted with grooty's trait, Scala's runtime trait instantiation is:

{code:java}
trait Extra {
    def extra():String = ""I'm an extra method""
}
class Something {                                       
    def doSomething():String = ""Something""
}

val s = new Something() with Extra
assert(s.extra() == ""I'm an extra method"")
assert(s.doSomething() == ""Something"")
{code}

Of course this is not ""decorate"" an existing object like groovy's
trait, but object instaciation variant(this is a syntax sugar of
static class definition which which mixins trait(s)). But in this
scala code, about variable s:

- (1) s is 'instanceof' of Something
- (3) method call to Object method works expectedly
- (4) typesafe


I'd like to propose another new feature request, I hope if available the way to instanciate new object which 'implements' trait(s) like:

{code}
 ... = new Something() withTrait Extra;
{code}

This is syntax suger of:

{code}
 static class $SubClassOf_Something extends Something implements Extra {}
  ...
 ... = new $SubClassOf_Something()
{code}

(in above code, 'withTrait' is not method. it should be new keyword or probably ""implements"" is can be used for this purpose).
This is same as Scala's:

{code}
 ... = new Something() with Extra;
{code}

If you already considered, i'm happy if you tell me why you did not choose this approach.
;;;","12/Apr/14 03:43;uehaj;The work around which I mentioned above comment which uses original object variable is hard to use if you have to pass the decorator proxy object to another method as a parameter.

I think if there is a way to get proxy target object from proxy object, most of problem might be solved.

For example, make proxy object to have a method named getProxyTarget()which returns ""original coerced object"", so you can write like:
{code}
trait Extra {
    String extra() { ""I'm an extra method"" }            
}
class Something {                                       
    String doSomething() { 'Something' }                
}
@groovy.transform.TypeChecked
def foo() {
  def s = new Something() as Extra
  s.extra()
  ((Something)s.getProxyTarget()).doSomething()
}
{code}

of course proxy object base class have Object getProxyTarget() method. I think any trait definition implicitly have to have Object getProxyTarget() method.

or asType(TargetClass) is more elegant?

{code}
trait Extra {
    String extra() { ""I'm an extra method"" }            
}
class Something {                                       
    String doSomething() { 'Something' }                
}
@groovy.transform.TypeChecked
def foo() {
  def s = new Something() as Extra
  s.extra()
  (s as Something).doSomething()
}
{code}

how about this?;;;","12/Apr/14 11:48;melix;I will comment on your proposal (which makes sense) later, but just to be clear: Scala doesn't have ""runtime"" traits like {{withTraits}}. It's a shorthand notation for an anonymous inner class, which is very different. For example, you can't write : {{val foo = bar with Baz}}. The equivalent in Groovy would be to create an inner class. The {{withTraits}} method really allows decorating an object with some traits at runtime, which gives a different perspective.;;;","12/Apr/14 12:00;melix;Also what you describe is not different from *any* proxy generated by Groovy, using the {{as}} keyword. The trait implementation just follows this behavior. The reason we can't make a special handling for {{toString}}, for example, is that {{toString}} is not the only method which causes problem: what about {{equals}} and {{hashCode}}. If {{equals}} is implemented in the target object *and* that the proxy delegates to it, then a proxy would be *equal to* the target object. This breaks the contract of {{equals}}.;;;","12/Apr/14 12:10;melix;So regarding the {{getProxyTarget}} method, I think it's an interesting idea. It should be doable and compatible with type checking. It also has the advantage of working with the traditional proxies. Just to make my previous comment more explicit, try this in a groovy console:

{code}
class Foo {
    void foo() { println ""Foooooo"" }
    String toString() { 'FOO' }
}
interface Bar {}
def f = new Foo()
println f
def b = f as Bar
println b
b.foo()
{code}

Now, it doesn't make sense that a *trait* implements this, because *only* runtime traits are using a proxy. If you implement a trait normally, there's no such thing as a proxy target, so this would really be for runtime generated proxies.
;;;","12/Apr/14 19:47;uehaj;Thank you for clarification and background information.

I completely understand that Scala's new .. with syntax should not be called *runtime* trait instantiation. It's my misunderstanding.

And I know now the new Groovy's ""runtime implementation of traits"" is based on the traditional Groovy feature of runtime implementation interface with coercing. As just interest, Is there a way of runtime multiple interface implementing syntax?

So I'd like to drop my proposal about "" it might be better to remove dispatching method"".
Introducing Scala like ""new..with"" syntax to groovy could make sense but I have no actual use case or special needs so I would like to drop it also :)

I see also the needs of distinct between the result of ""runtime implementation of trait"" and ""statically normally trait implementing class's instance"". You mean on point to consider is where is the best place defining the method.

I have enough knowledge so as just one my idea, how about ""runtime implementation of trait"" do implement another trait like ""RuntimeTrait"" implicitly?

{code}
trait RuntimeTrait {
   Object asType(Class clazz) {
      if (clazz.isInstanceof(getProxyTarget())) {
         return getProxyTarget();
      }
      else {
         // Cannnot Cast Exception
      }
   }
   Object getProxyTarget() {
       // NO IDEA how implement this!!
   }
}
{code}

best regards,;;;","14/Apr/14 11:27;melix;I am in favor of adding {{getProxyTarget}}. My idea is to make the proxy implement the following interface:

{code}
/**
 * An interface implemented by some Groovy proxies which gives access to the proxied object. In particular, dynamically
 * generated proxies that implement traits will implement this interface in order to give access to the proxied
 * instance.
 *
 * @author Cedric Champeau
 * @since 2.3.0
 */
public interface GeneratedGroovyProxy {
    /**
     * @return the proxy target.
     */
    Object getProxyTarget();
}
{code}

I have a working implementation here. Now, I am not 100% convinced {{asType}} is necessary, because of one reason: the result of the {{asType}} operation as you suggest here may return the proxy object *or* fail. There's actually no reason to fail, as the target class may be another interface or trait. If it doesn't fail, then it would mean that sometimes, {{asType}} returns a decorated object, sometimes not. For that reason, I would give a -1.
;;;","14/Apr/14 20:19;uehaj;Thank you for response.

The reasons I prefer asType is, 

- (1) concise code under @TypeChecked
{code}
@groovy.transform.TypeChecked
def foo() {
    def y = ""abc"" as SomeTrait
    println (((String)y.getProxyTarget()).toUpperCase()) // emits ""ABC""
    println ((y as String).toUpperCase()) // emits ""ABC""
}

{code}

- (2) if you have only getProxyTarget, you have to do following separated two operations.
--     A) Get proxy target
--     B) Cast to required class
Under the TypeChecked context, B) is always needed so A) and B) is indivisible.
(Type inference is not possible in this situation I believe, isn't it)?
On the other hand, Under dynamic groovy, there might be a situation where B) is not needed.
But there is no big penalty. There should be no special reason to prevent to use coerce
Because you  already  use it to make runtime trait implement!
- (3) It feels symmetric for me that use both it to convert to proxy and convert from proxy.
      But it may be only subjective feeling.

So, IMHO, i faver ""asType"" solution(+1). And in addition, getProxyTarget() is not needed?
;;;","14/Apr/14 20:52;uehaj;> (Type inference is not possible in this situation I believe, isn't it)?

It might be possible when you implement special handling of ""getProxyTarget()"".
But already we have special handling on ""as"" syntax. the result of as operation
guaranteed to have type of specified class at compile time. So we groovy users
can use it without surprise.;;;","15/Apr/14 01:32;melix;I understand your motivations. Really, the problem I have with {{asType}} as suggested is that if you do {{asType}} on the original type, it will return the proxied object, that is to say that you loose the decoration. You will have to handle that at some point:

{code}
def a = new A()
def decorated = a as SomeTrait
void method(SomeTrait x) {
   def a = x as A
   a.methodFromTrait() // fail
}
{code}
;;;","15/Apr/14 02:08;uehaj;Could you let me clarify the problem you mentioned.
In following code,
{code}
class A {
    Object asType(Class clazz) { // (1)
        .................
    }
    void methodOfOriginalA() {
        println ""methodOfOriginalA""
    }
}

trait SomeTrait {
    void methodFromTrait() {
        println ""methodFromTrait""
    }
    Object asType(Class clazz) {
        return new A()
    }
}

a = new A()
decorated = a as SomeTrait  // (2)
void method(SomeTrait x) {
    x.methodFromTrait()
    def a = x as A // (3)
    a.methodOfOriginalA()
}

method(decorated)

{code}
If you define asType at (1), decorated class can't be cast back to original proxy target from proxied object at (3) ?

If this is the problem, I quite agree, but you cant try to (3) because you cant get the proxied object at (2) because (1) is called instead of get proxied object.
So this is actually safe if there is no other way to get proxied object.

For example, proxy object which is emerged from withTrait() could be the case. Hmm.
or withTrait() calls asType() mechanism internally?
;;;","15/Apr/14 02:10;uehaj;Anyway, if trait can be used for the place the asType() is defined,
{code}
@ForceOrverride
Object asType() {
}
{code}

Could override the original object's asType?
;;;","15/Apr/14 02:32;melix;Yes, implementing a trait that supports the conversion is one of my ideas. It would look like this:

{code}
trait ProxyConvertible implements GeneratedGroovyProxy {
    @groovy.transform.ForceOverride
    Object asType(Class target) {
        println ""Converting to $target""
        def proxy = getProxyInstance()
        if (target.isAssignableFrom(proxy.class)) {
            return proxy
        }
        DefaultGroovyMethods.asType(this, target)
    }
}
{code}

Unfortunatly, in your example, we can't use {{asType}}, because of Groovy internal coercion mechanisms. Even if you implement {{asType}}, independently of traits I mean, on any class, and that the target type is {{String}}, then it's {{toString}} which is used internally, not your {{asType}} implementation.;;;","15/Apr/14 05:02;melix;The only thing I can think of right now would be a helper method like in this snippet (focus on {{getAsType}}):

{code}
import org.codehaus.groovy.transform.trait.Traits
trait Helloable implements CharSequence {
    void hello() { println ""hello"" }
}
def str = ""hello""
def x = str as Helloable
x.hello()
assert !(x instanceof String)
assert x instanceof Helloable
assert x instanceof GeneratedGroovyProxy
assert x.toUpperCase() == ""HELLO"" // expected
assert x.proxyTarget.tr('h','*') == ""*ello""
def proxyTarget = x.proxyTarget
assert proxyTarget.is(str)
def converted = Traits.getAsType(x,String)
assert converted.is(str)
{code}

I have this working already. Again, think that what you are asking for is already a problem in Groovy with objects coerced to interfaces. The advantage of using {{Traits.getAsType}} here is that we don't go through the regular {{as}} coercion so we can bypass the fact that Groovy will handle the {{String}} case separately. Also the name {{getAsType}} is chosen so that you can add a static import without having a name clash with the traditional {{asType}} method.;;;","15/Apr/14 07:31;uehaj;Thank you for consideration.

If the return type of {{Traits.getAsType()}} is {{java.lang.Object}}, the result of it has to be casted to String.
The reason I want to use asType() is I want to use 'as'.
The reason I want to use 'as' is I want to remove a cast for the return value from it.
The reasons I want to remove the cast are:
- (1) shorten the code under static groovy (@TypeChecked,@CompileStatic) because cast is removed
- (2) If trait is ""compatible with static type checking/compilation"" so less cast is ideal.
      I imagine the reason why the closure parameter type inference wanted,
      it's because cast of 'it"" parameter is not only boiler plate, but also it makes a difference of dynamic groovy code.
      When we only add @TypeChecked, if I have to change the code to add a cast, Its not ideal.

So if the getAsType returns Object type, there is no difference to getProxyTarget() so I think there is no need to implement it.


;;;","15/Apr/14 07:36;melix;No, getAsType returns T:

{code}
public static <T> T getAsType(Object self, Class<T> clazz)
{code}
;;;","15/Apr/14 07:57;uehaj;Oh, I misunderstand if so it's looks pretty nice:)
Is it possible following method?
{code}
public interface GeneratedGroovyProxy {
    /**
     * @return the proxy target.
     */
    public <T> T getProxyTargetAs(Calss<T> clazz);
}
{code}
;;;","15/Apr/14 08:04;melix;It seems redundant, isn't it? To call it, you would need to know you have a {{GeneratedGroovyProxy}}, whereas {{Traits.getAsType}} doesn't make any assumption:

{code}
public static <T> T getAsType(Object self, Class<T> clazz) {
        if (self instanceof GeneratedGroovyProxy) {
            Object proxyTarget = ((GeneratedGroovyProxy)self).getProxyTarget();
            if (clazz.isAssignableFrom(proxyTarget.getClass())) {
                return (T) proxyTarget;
            }
        }
        return DefaultGroovyMethods.asType(self, clazz);
    }
{code};;;","15/Apr/14 09:31;uehaj;I probably misunderstand again.
Could you tell me the type signature of getProxyTarget()?
Is it like following?
{code}
public interface GeneratedGroovyProxy {
    /**
     * @return the proxy target.
     */
    public <T> T getProxyTarget();
}
{code}

If so I really satisfied. This is enough and reasonable solution I think.

If this is not the case,  the return type of getProxyTarget is java.lang.Object,
the point is difference between

{code}
def converted = Traits.getAsType(x,String) // (1)
{code}

and

{code}
def converted = x.getProxyTargetAs(String) // (2)
{code}

I feel (2) is better because
- (A) It looks like variation of getProxyTarget() and it is.
- (B) no need of import  org.codehaus.groovy.transform.trait.Traits
- (C) For the case of (1), the method has no meaning of solid 'asType' anymore. At least It might be renamed something like 'static <T> T getProxyTargetAsType(Class<T> clazz)' 

But I think it might just only my subjective feeling.;;;","15/Apr/14 09:58;melix;No, {{getProxyTarget}} can't be parametrized. It's:

{code}
0bject getProxyTarget()
{code}

The reason is that it's a runtime thing. You never know at compile time what will be the type of the proxied object. Take this example:

{code}
SomeTrait doSomethingMagic(o) {
    o as SomeTrait // proxy target is of type ""String"", but not known statically
}
def doSomethingWithTrait(SomeTrait t) {
   t.proxyTarget // this may fail, because not every trait is a proxy!
}
def converted = doSomethingMagic('string') // we only know that the return type is ""SomeTrait"", but could be either a Proxy or a regular trait
def other = doSomethingMagic(new Foo())

{code};;;","15/Apr/14 10:07;melix;BTW, all {{getProxyTargetAsType}} would do would be delegating to {{Traits.getAsType}}. Since we already have one method {{getProxyTarget}} (which is necessary to get the proxy target), that would mean generating two methods instead of one, for the sake of avoiding an import. Is it really worth it? I'm not convinced so far...;;;","15/Apr/14 16:34;uehaj;I convinced. Yes you are right.

(A) When following two methods (1) (2) are both exists:

- (1)Object GeneratedGroovyProxy#getProxyTarget()
- (2)T GeneratedGroovyProxy#getProxyTargetAsType() or Trait#getProxyTargetAsType() 

Under static groovy, programmer's choices:

- get the target proxy by (1) and cast to original type
- get the target proxy by (2), and don't cast

contrary,  under the dynamic groovy, you have one more choice.

- get the target proxy by (1) and cast to original type
- get the target proxy by (2), and don't cast
- get the target proxy by (1), and don't cast

(B) if we have no (1), only have (2), choices are following:

under static groovy:
- get the target proxy by (2), and don't cast

under dynamic groovy:
- get the target proxy by (2), and don't cast

(C) if we have only (1), no (2), choices are following:

under static groovy:
- get the target proxy by (1) and cast to original type

under dynamic groovy:
- get the target proxy by (1) and cast to original type
- get the target proxy by (1), and don't cast


I thought (B) is better than (C) because of following reason.

{quote}
(2) If trait is ""compatible with static type checking/compilation"" so less cast is ideal.
I imagine the reason why the closure parameter type inference wanted,
it's because cast of 'it"" parameter is not only boiler plate, but also *it makes a difference of dynamic groovy code.*
When we only add @TypeChecked, if I have to change the code to add a cast, Its not ideal.
{quote}

From point of view of this, getTargetProxy() should be hidden. But if it is impossible for the reason of implementation, (C) is better than (A).
If there is Traits.getAsType already,  for the reason of implementation,  we don't need to additionally implement GeneratedGroovyProxy#getProxyTargetAsType(). Because (2) is recommended to *don't use it* from programmer.
(C) must be the real situation.

thanks.;;;","16/Apr/14 06:59;melix;Thanks for your comments, I have pushed it onto master. It should be available in the next build.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot extend trait with generic parameter,GROOVY-6691,12811871,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mperry,mperry,09/Apr/14 21:06,10/Apr/14 17:16,14/Jul/23 06:01,10/Apr/14 02:46,2.3.0-beta-1,,,,,,,,,,,,,,,,,2.3.0-beta-2,,,,,,,,0,,,,,,,"I get a compiler error when I try to extend a trait with a generic type parameter.
{code}
trait Functor<T> { }
trait Applicative<App> extends Functor<App> { }
{code}
does not compile with the error message:
{noformat}
src\main\groovy\com\github\mperry\Applicative.groovy: 14: A transform used a generics containing ClassNode com.github.mperry.Functor <T> for the super class com.github.mperry.Applicative directly. You are not supposed to do this. Please create a new ClassNode referring to the old ClassNode and use the new ClassNode instead of the old one. Otherwise the compiler will create wrong descriptors and a potential NullPointerException in TypeResolver in the OpenJDK. If this is not your own doing, please report this bug to the writer
 of the transform. @ line 14, column 1.
   trait Applicative extends Functor {
:compileGroovy FAILED
   ^
{noformat}

Changing the Applicative trait to a simpler form gets the same compiler error:

{code}
trait Functor<T> { }
trait Applicative extends Functor { }
{code}

Extending from a non-generic trait compiles:

{code}
trait Functor { }
trait Applicative<App> extends Functor { }
{code}

I am using Gradle 1.11, Java 7 and Windows 7.

",,melix,mperry,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 10 02:46:29 UTC 2014,,,,,,,,,,"0|i2cacn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Apr/14 21:26;paulk;There is a hotfix in place pending review from other members of the core team but feel free to do some more experimentation.;;;","10/Apr/14 02:46;melix;Thanks for the report. I reworked the fix: https://github.com/groovy/groovy-core/commit/57ffb4f6cfa68d81536d4034dca841fa6d078074;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Traits cannot modify their internal variables,GROOVY-6688,12813248,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,tim_yates,tim_yates,09/Apr/14 09:10,24/Apr/14 19:00,14/Jul/23 06:01,15/Apr/14 13:37,2.3.0-beta-1,,,,,,,,,,,,,,,,,2.3.0-beta-2,,,,Compiler,,,,0,,,,,,,"{code}
trait Level {
    int maxLevel
    int currentLevel = 0
    
    void foo() {
        if( currentLevel < maxLevel ) {
            currentLevel += 1
        }
    }
}

class Leveller implements Level {
    Leveller() {
        maxLevel = 3
    }
}

def v = new Leveller()
v.foo()
v.foo()
v.foo()
v.foo()
assert v.currentLevel == 3
{code}

fails with 

{code}
Assertion failed: 

assert v.currentLevel == 3
       | |            |
       | 0            false
       Leveller@1f757867
{code}

But if you change the trait to:

{code}
trait Level {
    int maxLevel
    int currentLevel = 0
    
    void foo() {
        if( Level__currentLevel < maxLevel ) {
            Level__currentLevel += 1
        }
    }
}
{code}

It works...

I'm guessing this is a bug, as the given example (http://beta.groovy-lang.org/docs/groovy-2.3.0-beta-1/html/documentation/core-traits.html#_private_fields) of:

{code}
trait Counter {
    private int count = 0                   
    int count() { ++count }                 
}
class Foo implements Counter {}             
def f = new Foo()
assert f.count() == 1  
{code}

doesn't work if you add:

{code}
assert f.count() == 2
{code}

to the bottom
",,melix,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 09 11:18:25 UTC 2014,,,,,,,,,,"0|i2cn4n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Apr/14 09:17;melix;This bug highlights a more general problem with: +=, ++, -- and other variants. In this code, replace:

{code}
currentLevel += 1
{code}

with

{code}
currentLevel = currentLevel + 1
{code}

and it will work. The reason is how the code is internally transformed into helper method calls.;;;","09/Apr/14 09:25;tim_yates;Ahhh, I see what you mean...otherwise it just returns an incremented (or post incremented) copy of the original number (without updating the original);;;","09/Apr/14 11:18;melix;Fixed this one by supporting the ""plus equals"" and other assignment operators, yet {{++x}} and {{y--}} are not supported (see GROOVY-6689).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Traits aren't detected as implementing abstract methods,GROOVY-6687,12817462,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,09/Apr/14 07:52,10/Apr/14 17:16,14/Jul/23 06:01,09/Apr/14 08:00,2.3.0-beta-1,,,,,,,,,,,,,,,,,2.3.0-beta-2,,,,Compiler,,,,0,,,,,,,"If you have an abstract class, and then implement the abstract methods via a trait, eg:

{code}
abstract class AbstractSomething {
    abstract void something()
}

trait SomethingDoing {
    void something() {
       println ""Doing something""
    }
}

class Something extends AbstractSomething implements SomethingDoing {
    void foo() {
        something()
    }
}

new Something().foo()
{code}

Rather than the expected output {{Doing something}} we get:

{code}
Can't have an abstract method in a non-abstract class. The class 'Something' must be declared abstract or the method 'void something()' must be implemented.
{code}",,ceefour,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-09 07:52:45.0,,,,,,,,,,"0|i2csbb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Initial expressions are not transformed in traits,GROOVY-6686,12817482,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,09/Apr/14 07:24,10/Apr/14 17:16,14/Jul/23 06:01,09/Apr/14 07:25,2.3.0-beta-1,,,,,,,,,,,,,,,,,2.3.0-beta-2,,,,,,,,0,,,,,,,"The following code fails because initial expressions are not transformed:

{code}
trait Dummyable  {
    String x = this.class.name

    void info() {
        assert x == this.class.name
    }
}


class Util implements Dummyable {}

def util = new Util()
util.info()
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 09 07:25:58 UTC 2014,,,,,,,,,,"0|i2coqv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Apr/14 07:25;melix;See https://github.com/groovy/groovy-core/commit/0a0060314c1aa7c20693bfe69c9153baf4de5105;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
XmlParser trims text by default,GROOVY-6683,12812105,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,09/Apr/14 04:14,07/Apr/15 19:07,14/Jul/23 06:01,09/Apr/14 04:34,2.2.2,,,,,,,,,,,,,,,,,2.3.0-beta-2,,,,XML Processing,,,,0,breaking,,,,,,"When parsing a node like:
{code}
<node>  foo  </node>
{code}
{{XmlParser}} returns {{'foo'}} not {{'  foo  '}} when getting the text value. This autotrimming feature is markedly different from what most XML parsers do (and is easy to do after the fact by using the {{trim()}} method when needed). This issue swaps the default but this feature can still be turned back on with a {{trimWhitespace}} flag if desired.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 09 04:18:07 UTC 2014,,,,,,,,,,"0|i2c9jj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Apr/14 04:18;paulk;Proposed solution:
https://github.com/groovy/groovy-core/pull/375
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.util.Locale gives java.security.AccessControlException on App Engine,GROOVY-6679,12817486,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,marceloverdijk,marceloverdijk,08/Apr/14 01:40,20/May/14 05:31,14/Jul/23 06:01,11/May/14 13:33,2.2.0,,,,,,,,,,,,,,,,,2.2.3,2.3.1,,,,,,,0,,,,,,,"Until Groovy 2.1.9 I can successfully use java.util.Local on App Engine but 2.2.0 and onward gives a java.security.AccessControlException:
access denied (""java.lang.RuntimePermission"" ""accessClassInPackage.sun.util.resources"")",,blackdrag,marceloverdijk,melix,musketyr,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6471,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 11 13:30:20 UTC 2014,,,,,,,,,,"0|i2cfp3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Apr/14 01:57;musketyr;this is duplicate of GROOVY-6471;;;","08/Apr/14 04:39;marceloverdijk;I'm not sure if it's duplicate. Symptoms are at least the same.
Although GROOVY-6471 states it's fixed in 2.2.2 I still see the issue with java.util.Locale.
;;;","08/Apr/14 04:42;musketyr;it should be, but it wasn't. can you try latest 2.3.0 snapshot from https://oss.jfrog.org/oss-snapshot-local/ it looks like it solves the problem;;;","09/Apr/14 08:26;blackdrag;Marcel,  2.2.2 is not a released version at this point in time.. are you really sure you tried that version?;;;","09/Apr/14 12:19;marceloverdijk;@blackdrag: are you sure 2.2.2 is not yet released? It's available in Maven central since 26-Feb-2014;;;","09/Apr/14 12:23;melix;@Marcel & @Jochen: Yes, 2.2.2 is out since a while :);;;","11/May/14 04:17;pschumacher;@Marcel Overdijk: It would be nice if you can check if this is fixed in 2.3.0. Thanks!;;;","11/May/14 13:30;musketyr;yes, all the access exception with appengine are finally fixed in 2.3.0;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closure parameter type inference error if the receiver is a delegate type,GROOVY-6676,12817466,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,07/Apr/14 08:46,10/Apr/14 17:16,14/Jul/23 06:01,07/Apr/14 08:47,2.3.0-beta-1,,,,,,,,,,,,,,,,,2.3.0-beta-2,,,,Static Type Checker,,,,0,,,,,,,"The following code fails with a compile time error (""This should not have happened"") because the type inference engine doesn't use the right receiver type.

{code}
import java.util.concurrent.Callable

interface Foo {
    public <T> T background(Callable<T> backgroundOperation)
}
class FooImpl implements Foo {

    @Override
    def <T> T background(final Callable<T> backgroundOperation) {
        backgroundOperation.call()
    }
}
static void test(@DelegatesTo(Foo) Closure cl) {
    cl.delegate = new FooImpl()
    cl()
}

test {
    background { 'foo' }
}
{code}

Test case adapted from the Ratpack sources.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-07 08:46:31.0,,,,,,,,,,"0|i2bmhz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The JsonSlurper returns the wrong value type for floating point numbers.,GROOVY-6674,12817464,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,bura,bura,05/Apr/14 07:39,24/Apr/14 19:00,14/Jul/23 06:01,12/Apr/14 10:56,2.3.0-beta-1,,,,,,,,,,,,,,,,,2.3.0-rc-1,,,,JSON,,,,0,,,,,,,"In the 2.3.0-beta-1 version was broken backward compatibility.

{code:java}
def result = new JsonSlurper().parseText('{""message"":1.5}')
assert result.message.class == BigDecimal // failed with 2.3.0-beta-1 and was OK before
       |      |       |     |
       |      1.5     |     false
       [message:1.5]  class java.lang.Double
{code}",,bura,guillaume,richardhightower,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Apr 12 10:56:29 UTC 2014,,,,,,,,,,"0|i2bxhb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Apr/14 02:32;guillaume;Did you come up with a fix for that?;;;","06/Apr/14 03:25;bura;Yesterday I tried to fix this issue, but I found the solution only for two types of inner parsers: JsonParserType.CHAR_BUFFER (using by default) and JsonParserType.CHARACTER_SOURCE. For the other two parsers (JsonParserType.LAX and JsonParserType.INDEX_OVERLAY) the value is always returned in the Value container (groovy.json.internal.Value), i.e:

{code:java}
def result = new JsonSlurper().parseText('{""message"":1.5}')
assert result.message.class == BigDecimal // failed with 2.3.0-beta-1 and was OK before
       |      |       |     |
       |      1.5     |     false
       [message:1.5]  class groovy.json.internal.NumberValue
{code}

Immediately I was not able to find solutions. [~richardhightower] can you tell us how it can be fixed?;;;","07/Apr/14 10:37;richardhightower;http://jira.codehaus.org/browse/GROOVY-6674

JsonParserType.LAX and JsonParserType.INDEX_OVERLAY both use index overlay.

groovy.json.internal.NumberValue extends Number.

(http://docs.oracle.com/javase/7/docs/api/java/lang/Number.html)

We should add a toBigInteger and a toBigDecimal to NumberValue.

Since LAX and INDEX_OVERLAY did not exist before then they would not be covered under breaking backwards compatibility.

I think since JsonParserType.CHAR_BUFFER is used by default and Andrey fixed that then this is closed. Thoughts?
;;;","12/Apr/14 06:08;bura;PR: https://github.com/groovy/groovy-core/pull/378;;;","12/Apr/14 10:56;guillaume;Pull request applied, thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"ClassFormatError if trait (accidentally) ""extends"" interface",GROOVY-6672,12817331,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pniederw,pniederw,05/Apr/14 01:42,22/May/22 16:06,14/Jul/23 06:01,07/Apr/14 04:11,2.3.0-beta-1,,,,,,,,,,,,,,,,,2.3.0-beta-2,,,,Compiler,,,,0,ClassFormatError,,,,,,"{code}
interface Foo {}
trait Bar extends Foo {} // oops: should be ""implements""
{code}

No compile error occurs. Runtime error: ""java.lang.ClassFormatError: Interfaces must have java.lang.Object as superclass in class file Bar""",,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-05 01:42:17.0,,,,,,,,,,"0|i2bu33:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Types not inferred when coercing closures of generic method return type,GROOVY-6671,12813161,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ldaley,ldaley,04/Apr/14 20:42,06/May/14 02:45,14/Jul/23 06:01,06/May/14 02:45,2.3.0,,,,,,,,,,,,,,,,,2.3.0-rc-1,,,,Static Type Checker,,,,0,,,,,,,"I can't quite narrow down the exact cause of this.

This fails:

{code}
// Note: this interface must be in different script because of GROOVY-6670
interface Converter<F, T> {
  T convert(F from)
}

class Holder<T> {
  T thing

  Holder(T thing) {
    this.thing = thing
  }

  def <R> Holder<R> convert(Converter<? super T, ? extends R> func1) {
    new Holder(func1.convert(thing))
  }
}

@CompileStatic
void m() {
  new Holder<Integer>(2).convert {
    it
  } convert {
    it.floatValue() // fails, doesn't know 'it' is an Integer
  }
}

m()
{code}

However, this works and I can't work out what the difference is.

{code}
interface Action<T> {
  void execute(T thing)
}

class Thing<T> {
  T thing
  Thing(T thing) {
    this.thing = thing
  }
  
  void doWith(Action<? super T> action) {
    action.execute(thing)
  }
}


class Container {
  @groovy.transform.CompileStatic 
  static m() {
    makeThing(""a"") doWith { println it.toUpperCase() } // works
    makeThingFromCallable { ""a"" } doWith { println it.toUpperCase() } // works
  }
  
  static <T> Thing<? extends T> makeThing(T thing) {
    new Thing<T>(thing)
  }
  
  static <T> Thing<? extends T> makeThingFromCallable(java.util.concurrent.Callable<T> thing) {
    new Thing<T>(thing.call())
  }
  
}

Container.m()
{code}",,blackdrag,ldaley,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 06 02:39:56 UTC 2014,,,,,,,,,,"0|i2ciaf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Apr/14 08:27;blackdrag;Now this was quite some work to fix, because it was about touching about almost all the rough edges in the inference engine. But luckily I managed to fix it;;;","24/Apr/14 15:30;ldaley;Confirmed that rc-1 fixes the case that sparked this report.

Thanks Jochen.;;;","28/Apr/14 22:30;ldaley;I found another case that doesn't work.

{code}
@Grab(group='com.netflix.rxjava', module='rxjava-core', version='0.18.1') 
import rx.Observable

@groovy.transform.CompileStatic
class Example {
  static void main(String[] args) {
    Observable.just(""foo"") map {
      it.toUpperCase() // <- compiler doesn't know 'it' is a string
    } subscribe {
      println it
    }
  }
}
{code}

If I put this code in IDEA it thinks it is compilable, which leads me to believe that this is inferrable.

I tested this with 2.3.0-rc-2.;;;","06/May/14 00:45;ldaley;Problem exists in 2.3.0 final.;;;","06/May/14 02:04;blackdrag;which does exist? the original reported problem or the one from the comment. Because I think I checked only the original and forgot about the comment. But then it also means the problems are actually different ones.;;;","06/May/14 02:36;ldaley;Sorry, the problem raised in the comments exists in 2.3.0 final.

Want me to raise a new issue?;;;","06/May/14 02:39;blackdrag;yes, please close this one and make a new issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot coerce closure to SAM type when calling method of generic type,GROOVY-6670,12817379,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ldaley,ldaley,04/Apr/14 19:48,10/Apr/14 17:16,14/Jul/23 06:01,07/Apr/14 07:33,2.3.0-beta-1,,,,,,,,,,,,,,,,,2.3.0-beta-2,,,,,,,,0,,,,,,,"Sorry for the vague summary. The following doesn't compileâ¦

{code}
import groovy.transform.CompileStatic

interface Transform<T> {
  T transform(T input)
}

class Holder<T> {
  final T thing

  Holder(T thing) {
    this.thing = thing
  }

  T transform(Transform<T> transform) {
    transform.transform(thing)
  }
}

@CompileStatic
class Container {
  static void m() {
    def holder = new Holder<Integer>(2)
    def transformed = holder.transform {
      it * 2
    }
    assert transformed == 4
  }
}
{code}

The problem seems to be the holder.transform() call. This code works without @CompileStatic.

In GroovyConsole I get: 

{code}
java.lang.InstantiationException: Transform
{code}

In IDEA 13.1.1 I get:

{code}
Error:Groovyc: A groovyc error occurred while trying to load one of the classes in project dependencies, please ensure it's present. See the message and the stack trace below for reference
java.lang.ClassCircularityError: Transform
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:270)
	at groovy.transform.stc.ClosureSignatureHint.findClassNode(ClosureSignatureHint.java:133)
	at groovy.transform.stc.FromAbstractTypeMethods.getClosureSignatures(FromAbstractTypeMethods.java:41)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.doInferClosureParameterTypes(StaticTypeCheckingVisitor.java:2012)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferClosureParameterTypes(StaticTypeCheckingVisitor.java:2000)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallArguments(StaticTypeCheckingVisitor.java:1965)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2501)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:245)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:432)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:245)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitDeclarationExpression(ClassCodeVisitorSupport.java:107)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:86)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1501)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1789)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1762)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:144)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1063)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:173)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:110)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:61)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1047)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:583)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:561)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:538)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:286)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:259)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:245)
	at groovy.lang.GroovyClassLoader.recompile(GroovyClassLoader.java:739)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:696)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:765)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:753)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:270)
	at groovy.transform.stc.ClosureSignatureHint.findClassNode(ClosureSignatureHint.java:133)
	at groovy.transform.stc.FromAbstractTypeMethods.getClosureSignatures(FromAbstractTypeMethods.java:41)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.doInferClosureParameterTypes(StaticTypeCheckingVisitor.java:2012)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferClosureParameterTypes(StaticTypeCheckingVisitor.java:2000)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallArguments(StaticTypeCheckingVisitor.java:1965)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2501)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:245)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:432)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:245)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitDeclarationExpression(ClassCodeVisitorSupport.java:107)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:86)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1501)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1789)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1762)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:144)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1063)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:173)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:110)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:61)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1047)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:583)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:561)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:538)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:54)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:81)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:100)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:121)
{code}",,ldaley,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 07 05:09:12 UTC 2014,,,,,,,,,,"0|i2cm9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Apr/14 20:38;ldaley;This only seems to happen when all the types are declared in the same script.;;;","07/Apr/14 05:09;melix;Does it really happen with beta-1? I'm trying hard to reproduce it, but I can't.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compile in groovyConsole instantiates class,GROOVY-6669,12817465,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pascalschumacher,ldaley,ldaley,04/Apr/14 18:47,22/Feb/16 20:48,14/Jul/23 06:01,28/Oct/15 17:56,2.2.2,,,,,,,,,,,,,,,,,2.4.6,,,,Groovy Console,,,,0,,,,,,,"Probably not serious, but put this in groovyConsole and compileâ¦

{code}
class OtherThing {
    OtherThing() {
        def v = null
        v.hashCode()
    }
}
{code}

You'll get an NPE for the v.hashCode() line. If you add another statement before the class def (e.g. def c = null) it doesn't happen.

Weird.",,githubbot,jwagenleitner,ldaley,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 28 17:56:30 UTC 2015,,,,,,,,,,"0|i2bz3j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Oct/15 04:23;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/incubator-groovy/pull/163

    GROOVY-6669 - Compile in groovyConsole instantiates class

    For scripts that contain Class definitions the `GroovyShell#parse` [[1]](https://github.com/apache/incubator-groovy/blob/d1979d119f805f721600c114466311b928c4c587/src/main/groovy/lang/GroovyShell.java#L700) calls `InvokeHelper#createScript` which creates a new instance in order to bind properties [[2]](https://github.com/apache/incubator-groovy/blob/d1979d119f805f721600c114466311b928c4c587/src/main/org/codehaus/groovy/runtime/InvokerHelper.java#L436-L460).  The compile command should only parse the class to make sure there are no syntax errors so this fix just calls the same `GroovyClassLoader#parseClass` method that the `GroovyShell#run` command uses.
    
    With this change the following will compile:
    
    ```groovy
    class OtherThing {
        OtherThing() {
            def v = null
            v.hashCode()
        }
    }
    ```
    If one of the braces is left off:
    
    ```groovy
     class OtherThing {
        OtherThing() {
            def v = null
            v.hashCode()
        
    }
    ```
    The following compilation error occurs:
    
    ```
    1 compilation error:
    
    expecting '}', found '' at line: 6, column: 2
    ```

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/incubator-groovy GROOVY-6669

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/163.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #163
    
----
commit 2f4039047d27aedf99bc88d506623489cde2f0df
Author: John Wagenleitner <john.wagenleitner@gmail.com>
Date:   2015-10-28T04:00:01Z

    GROOVY-6669 - Compile in groovyConsole instantiates class
    
    For scripts that contain Class definitions the GroovyShell#parse calls InvokeHelper#createScript which creates a new instance in order to bind properties.  The compile command should only parse the class to make sure there are no syntax errors so this fix just calls the same parseClass method that the GroovyShell#run command uses.

----
;;;","28/Oct/15 17:54;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/163
;;;","28/Oct/15 17:56;pascalschumacher;Pull request merged! Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compiler doesn't coerce GString for getAt() call,GROOVY-6668,12817460,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,ldaley,ldaley,04/Apr/14 18:43,17/Sep/22 16:35,14/Jul/23 06:01,17/Sep/22 16:35,2.3.0-beta-1,2.4.0-rc-1,,,,,,,,,,,,,,,,5.0.0-alpha-1,,,,Static compilation,,,,0,,,,,,,"This might not be a bug, but it's a behaviour change from 2.2.

{code}
@groovy.transform.CompileStatic
class OtherThing {
    OtherThing() {
        Map<String, String> m = [:]
        def k = ""foo""
        m[""$k""].toUpperCase() // fails, no method toUpperCase() on object
        m[k].toUpperCase() // works
    }
}
{code}",,blackdrag,daniel_sun,emilles,githubbot,ldaley,melix,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8212,GROOVY-9617,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Sep 17 16:34:38 UTC 2022,,,,,,,,,,"0|i2bsx3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/May/14 14:24;pschumacher;@Cedric: @blackdrag: Any comments on this?;;;","01/Jun/14 06:58;melix;The first one ({{m[""$k""]}}) should fail with a type checking error (GString is not a String).;;;","15/May/18 14:56;daniel_sun;[~melix] It's better to support this case. Groovy users always mix string and gstring(including me).;;;","16/May/18 13:37;daniel_sun;
The following test passes.
{code:java}
        @groovy.transform.CompileStatic
        class OtherThing {
            OtherThing() {
                Map<String, String> m = [foo: ""bar""] as HashMap<String, String>
                String k = ""${'foo'}""   // GString value is assign to String variable, succeed
                assert ""BAR"" == m[k].toUpperCase()
            }
        }
        
        new OtherThing()
{code}
;;;","16/May/18 13:44;melix;I understand the temptation, but no, we shouldn't. This isn't about usability, this is about type safety. ""Fixing"" this would open Pandora's box. I think this works exactly as expected, and we must educate people that GString!=String.;;;","17/May/18 00:34;blackdrag;[~melix] to get this right...
{code}
def foo(String s){}
def x = 1
foo(""$x"")
{code}
you want this code to fail because a String is not a GString? Additionally you want 
{code}
def x = 1
String s = ""$x""
{code}
to fail for the same reason?

My point being m[""$k""] is still of a different category than the two above, if we are talking here about getAt(Object). If there is getAt(String) we are talking about the first example I gave.

And there is actually getAt(Object) for Map and getAt(String) for Object. This means both are available here. In dynamic Groovy it is therefore 100% legal and working to use a GString to find a String key in a map. What causes problems is using GString keys in the map literal and forcing the object variant like [(""$k""):v], and then looking it up using just a String. But that is not what this issue is about. ;;;","17/May/18 01:02;blackdrag;To add on the written before...  so while I disagree, that m[""$k""] should fail,{code}m[""$k""].toUpperCase(){code} fails because we call getAt(String) form Object here. The method is defined to return Object, thus no toUpperCase() is possible. Since this is a Map<String,String> and we have the DGM <K,V> V getAt(Map<K,V> self, K key), we have in theory a kind of getAt(String):String method available. So for me the real problem here are the damn generics and shadowing of DGM within DGM. If you would define a DGM <V> getAt(Map<String,V> self, String key), I would expect the toUpperCase() to work. ;;;","17/May/18 01:50;githubbot;GitHub user danielsun1106 opened a pull request:

    https://github.com/apache/groovy/pull/708

    GROOVY-6668: Static compiler doesn't coerce GString for getAt() call

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/danielsun1106/groovy GROOVY-6668

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/708.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #708
    
----
commit f3c3939b473c33acf0de5d95074bc2eb8bd61555
Author: Daniel Sun <realbluesun@...>
Date:   2018-05-17T01:49:00Z

    GROOVY-6668: Static compiler doesn't coerce GString for getAt() call

----
;;;","17/May/18 02:05;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/708#discussion_r188821671
  
    --- Diff: src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java ---
    @@ -468,7 +469,11 @@ protected void loadArguments(List<Expression> argumentList, Parameter[] para) {
                     expression.putNodeMetaData(PARAMETER_TYPE, para[i].getType());
                     expression.visit(acg);
                     if (!isNullConstant(expression)) {
    -                    operandStack.doGroovyCast(para[i].getType());
    +                    if (expression instanceof GStringExpression) {
    +                        operandStack.doGroovyCast(ClassHelper.STRING_TYPE);
    --- End diff --
    
    what if the method has a GString parameter? Converting to string is then wrong. You should add a test for this
;;;","17/May/18 02:06;daniel_sun;[~melix] Jochen has provided some examples to statement the nature of the issue. Here is the PR( https://github.com/apache/groovy/pull/708 ), I will merge it in 72 hours if you don't have objectations.;;;","17/May/18 02:07;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/708#discussion_r188821809
  
    --- Diff: src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java ---
    @@ -4101,13 +4101,17 @@ protected static ClassNode getGroupOperationResultType(ClassNode a, ClassNode b)
             return Number_TYPE;
         }
     
    -    protected ClassNode inferComponentType(final ClassNode containerType, final ClassNode indexType) {
    +    private static ClassNode convertGStringToStringType(ClassNode cn) {
    +        return GSTRING_TYPE.equals(cn) ? STRING_TYPE : cn;
    +    }
    +
    +    protected ClassNode inferComponentType(final ClassNode containerType, ClassNode indexType) {
             final ClassNode componentType = containerType.getComponentType();
             if (componentType == null) {
                 // GROOVY-5521
                 // try to identify a getAt method
                 typeCheckingContext.pushErrorCollector();
    -            MethodCallExpression vcall = callX(varX(""_hash_"", containerType), ""getAt"", varX(""_index_"", indexType));
    +            MethodCallExpression vcall = callX(varX(""_hash_"", containerType), ""getAt"", varX(""_index_"", convertGStringToStringType(indexType)));
    --- End diff --
    
    what if I add a DGM getAt(GString) for Map? This code looks like I would no longer be able to call it
;;;","17/May/18 02:16;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/708#discussion_r188822722
  
    --- Diff: src/test/groovy/bugs/Groovy6668Bug.groovy ---
    @@ -0,0 +1,65 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package groovy.bugs
    +
    +class Groovy6668Bug extends GroovyTestCase{
    +    void testGroovy6668() {
    +        assertScript '''
    +        @groovy.transform.CompileStatic
    +        class OtherThing {
    +            OtherThing() {
    +                Map<String, String> m = [:]
    +                def k = ""foo""
    +                m[""$k""].toUpperCase()
    +            }
    +        }
    +        
    +        OtherThing
    --- End diff --
    
    new OtherThing()?
;;;","17/May/18 02:46;githubbot;Github user danielsun1106 commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/708#discussion_r188825988
  
    --- Diff: src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java ---
    @@ -4101,13 +4101,17 @@ protected static ClassNode getGroupOperationResultType(ClassNode a, ClassNode b)
             return Number_TYPE;
         }
     
    -    protected ClassNode inferComponentType(final ClassNode containerType, final ClassNode indexType) {
    +    private static ClassNode convertGStringToStringType(ClassNode cn) {
    +        return GSTRING_TYPE.equals(cn) ? STRING_TYPE : cn;
    +    }
    +
    +    protected ClassNode inferComponentType(final ClassNode containerType, ClassNode indexType) {
             final ClassNode componentType = containerType.getComponentType();
             if (componentType == null) {
                 // GROOVY-5521
                 // try to identify a getAt method
                 typeCheckingContext.pushErrorCollector();
    -            MethodCallExpression vcall = callX(varX(""_hash_"", containerType), ""getAt"", varX(""_index_"", indexType));
    +            MethodCallExpression vcall = callX(varX(""_hash_"", containerType), ""getAt"", varX(""_index_"", convertGStringToStringType(indexType)));
    --- End diff --
    
    Good idea! 
    ```groovy
        /**
         * Get the value via the string value of the key
         * See GROOVY-6668 and the PR#708 (https://github.com/apache/groovy/pull/708)
         *
         * @param self a map
         * @param key a key
         * @param <V> value type
         * @return the value
         */
        public static <V> V getAt(Map<?, V> self, GString key) {
            if (null == key) {
                return null;
            }
    
            return self.get(key.toString());
        }
    ```
    
    but I wonder why we should not treat GString as String?
    As a groovy user, I won't write code like `GString str = ""${'someString'}""`, and I just write `String str = ""${'someString'}""` or  `def str = ""${'someString'}""` then treat `str` as a `String`...
;;;","17/May/18 02:49;githubbot;Github user danielsun1106 commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/708#discussion_r188826337
  
    --- Diff: src/test/groovy/bugs/Groovy6668Bug.groovy ---
    @@ -0,0 +1,65 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package groovy.bugs
    +
    +class Groovy6668Bug extends GroovyTestCase{
    +    void testGroovy6668() {
    +        assertScript '''
    +        @groovy.transform.CompileStatic
    +        class OtherThing {
    +            OtherThing() {
    +                Map<String, String> m = [:]
    +                def k = ""foo""
    +                m[""$k""].toUpperCase()
    +            }
    +        }
    +        
    +        OtherThing
    --- End diff --
    
    I just keep the code of the issue as it is. the `new OtherThing()` version is `testGroovy6668WithData` ;-)
;;;","17/May/18 03:51;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/708#discussion_r188832656
  
    --- Diff: src/test/groovy/bugs/Groovy6668Bug.groovy ---
    @@ -0,0 +1,65 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package groovy.bugs
    +
    +class Groovy6668Bug extends GroovyTestCase{
    +    void testGroovy6668() {
    +        assertScript '''
    +        @groovy.transform.CompileStatic
    +        class OtherThing {
    +            OtherThing() {
    +                Map<String, String> m = [:]
    +                def k = ""foo""
    +                m[""$k""].toUpperCase()
    +            }
    +        }
    +        
    +        OtherThing
    --- End diff --
    
    why not just shouldCompile then?
;;;","17/May/18 04:40;githubbot;Github user danielsun1106 commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/708#discussion_r188837462
  
    --- Diff: src/test/groovy/bugs/Groovy6668Bug.groovy ---
    @@ -0,0 +1,65 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package groovy.bugs
    +
    +class Groovy6668Bug extends GroovyTestCase{
    +    void testGroovy6668() {
    +        assertScript '''
    +        @groovy.transform.CompileStatic
    +        class OtherThing {
    +            OtherThing() {
    +                Map<String, String> m = [:]
    +                def k = ""foo""
    +                m[""$k""].toUpperCase()
    +            }
    +        }
    +        
    +        OtherThing
    --- End diff --
    
    I've fixed that according your suggestion :-)
;;;","17/May/18 08:00;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/708#discussion_r188869080
  
    --- Diff: src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java ---
    @@ -4101,13 +4101,17 @@ protected static ClassNode getGroupOperationResultType(ClassNode a, ClassNode b)
             return Number_TYPE;
         }
     
    -    protected ClassNode inferComponentType(final ClassNode containerType, final ClassNode indexType) {
    +    private static ClassNode convertGStringToStringType(ClassNode cn) {
    +        return GSTRING_TYPE.equals(cn) ? STRING_TYPE : cn;
    +    }
    +
    +    protected ClassNode inferComponentType(final ClassNode containerType, ClassNode indexType) {
             final ClassNode componentType = containerType.getComponentType();
             if (componentType == null) {
                 // GROOVY-5521
                 // try to identify a getAt method
                 typeCheckingContext.pushErrorCollector();
    -            MethodCallExpression vcall = callX(varX(""_hash_"", containerType), ""getAt"", varX(""_index_"", indexType));
    +            MethodCallExpression vcall = callX(varX(""_hash_"", containerType), ""getAt"", varX(""_index_"", convertGStringToStringType(indexType)));
    --- End diff --
    
    we can treat GString as a String if we know the target is a String. Plus the rules for assignment and for method calls are not identical. But my comment was not about adding getAt(GString) for Map. My comment was that this change looks like the following will no longer work:
      
          class X {
            int getAt(GString gs) {1}
          }
          assert new X()[""${42}""] == 1
;;;","27/Nov/18 06:16;githubbot;Github user danielsun1106 closed the pull request at:

    https://github.com/apache/groovy/pull/708
;;;","02/Mar/20 22:22;emilles;Recent changes made for GROOVY-9420 may impact this issue.  See also GROOVY-9097 and GROOVY-8212.  With the extension method {{getAt}} changed to accept {{Object}} for the key type, the STC error noted above will not be seen.
{code:groovy}
@groovy.transform.CompileStatic
void test(Map<String, String> map) {
        def key = ""foo""
        m[key].toUpperCase() // fine
        m[""$key""].toUpperCase() // compiles, but should throw NPE since the GString instance is not in keySet.
    }
}
{code}

;;;","02/Mar/20 22:26;emilles;Is it reasonable to use {{GString}} instances for keys in maps for any useful purpose?  Or could we add a STC warning (not error) when {{get}}, {{getAt}}, {{containsKey}}, etc. from a map is passed a {{GString}}?;;;","18/Aug/22 17:16;emilles;https://github.com/apache/groovy/pull/1766;;;","24/Aug/22 14:54;githubbot;eric-milles opened a new pull request, #1770:
URL: https://github.com/apache/groovy/pull/1770

   Here is the more controversial change of https://github.com/apache/groovy/pull/1766 so it can be debated/evaluated in isolation.
   
   A small change in `StaticTypeCheckingSupport#getDistance` can resolve the `map[""$key""]` issues. I know Cedric stated in 6668 that this should be an STC error, but if there is just one method and it accepts String, it will be chosen for a GString argument. This change just closes the distance between GString and String so that `m(String)` is selected over `m(Object)`. Yes, this puts `Map#get` and `Map#getAt` out of alignment for GString arguments, which was a stated concern.  But the gain is in alignment of dynamic and static behaviors.
   
   I checked `put` and `putAt` and I think there is consistency with `get` and `getAt`.  You can read and write via GString or String interchangeably.  I think this is the expectation of most users as described in 6668.
   
   https://github.com/apache/groovy/pull/708
   https://github.com/apache/groovy/pull/1766
   https://issues.apache.org/jira/browse/GROOVY-6668
   https://issues.apache.org/jira/browse/GROOVY-8212


;;;","17/Sep/22 16:34;githubbot;daniellansun merged PR #1770:
URL: https://github.com/apache/groovy/pull/1770


;;;","17/Sep/22 16:34;githubbot;daniellansun commented on PR #1770:
URL: https://github.com/apache/groovy/pull/1770#issuecomment-1250101219

   Merged. Thanks.


;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unexpected NullPointerException,GROOVY-6666,12817458,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,brownj,brownj,04/Apr/14 15:11,10/Apr/14 17:16,14/Jul/23 06:01,07/Apr/14 10:32,2.3.0-beta-1,,,,,,,,,,,,,,,,,2.3.0-beta-2,,,,,,,,1,,,,,,,"While upgrading Grails to use Groovy 2.3.0-beta-1 I came across a scenario where a NullPointerException is being thrown in a scenario where I don't think it should be.  It seems that the null safety operator isn't working as it should.

I have attached a simple sample app with the following code.  Running the test yields a NullPointerException.

{noformat}
./gradlew test
{noformat}

{code:title=src/main/groovy/com/demo/Widget.groovy|borderStyle=solid}
package com.demo

@groovy.transform.CompileStatic
class Widget {
    def isValid(Map m) {
        boolean isValid = true
        def dir = m.dir?.toString()
        def file = m.file?.toString()

        if(file) {
            if (!(file.startsWith('/') || dir?.endsWith('/'))) {
                isValid = false
            }
        }

        isValid
    }
}
{code}

{code:title=src/test/groovy/com/demo/WidgetSpec.groovy|borderStyle=solid}
package com.demo

import spock.lang.Specification

class WidgetSpec extends Specification {
    void 'test with file and no dir'() {
        when:
        def widget = new Widget()
        def m = [file: 'someFile']

        then:
        !widget.isValid(m)
    }
}
{code}",,blackdrag,brownj,kaendfinger,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"04/Apr/14 15:11;brownj;nullproblem.zip;https://issues.apache.org/jira/secure/attachment/12723211/nullproblem.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 07 10:32:52 UTC 2014,,,,,,,,,,"0|i2cedj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Apr/14 15:12;brownj;The use of @CompileStatic is important there.  The test passes if that is removed.;;;","04/Apr/14 16:54;kaendfinger;This is for sure a bug, and is definitely not intended, unless I didn't read the code right. :P I'm sure an expert will see this issue and take care of it.;;;","07/Apr/14 03:38;melix;Test case reduced to:
{code}
@groovy.transform.CompileStatic
def isValid() {
        Boolean test = null
        false || test
}
{code};;;","07/Apr/14 03:41;melix;Assigning back to Jochen because the bug is not specific to static compilation. The code in the previous comment fails without {{@CompileStatic}} too. It is a regression introduced by:

https://github.com/groovy/groovy-core/commit/bc5a0c526e49ce56e971efe1100815fb5e0b8b3e;;;","07/Apr/14 10:32;blackdrag;fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
indy caching bug for static method invocations,GROOVY-6662,12817394,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,04/Apr/14 08:33,05/Apr/14 00:00,14/Jul/23 06:01,04/Apr/14 09:45,,,,,,,,,,,,,,,,,,2.2.3,2.3.0-beta-1,,,groovy-runtime,,,,0,,,,,,,"{code:Java}
class A {
    static bar() {1}
}
class B {
    static bar() {2}
}
static foo(Class c) {
    c.bar()
}
assert foo(A)==1
assert foo(B)==2
{code}
This fails because the indy code adds only a guard for the receiver being a Class, but not for the class itself",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-04 08:33:45.0,,,,,,,,,,"0|i2bp9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
generic bounds ignored by type checking,GROOVY-6659,12817393,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,blackdrag,blackdrag,04/Apr/14 02:22,02/May/17 02:03,14/Jul/23 06:01,30/Sep/16 00:59,2.2.3,2.3.0,2.4.0-beta-3,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,Static compilation,Static Type Checker,,,0,,,,,,,"{code:Java}
class A{}
class B{}

@groovy.transform.CompileStatic
class Helper<V extends A> {
           public Helper(Closure<V> cl) {}
       }
@groovy.transform.CompileStatic
       static <C extends B> void extensionMethod(Closure<C> cl) {
           new Helper<C>(cl)
       }
{code}
The example is inspired by the fix done for GROOVY-6657, not sure versions before are affected, since this kind of code failed before. So it might be seen as regression.

Anyway, the code above should not compile, since Helper cannot extend A and B at the same time.",,blackdrag,fpavageau,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 30 07:19:13 UTC 2016,,,,,,,,,,"0|i2cq93:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Sep/16 21:52;jwagenleitner;This fails to compile on master with the message {{The type C is not a valid substitute for the bounded parameter <V extends A>}}.  It also fails if the two {{CompileStatic}} annotations are removed.;;;","30/Sep/16 01:26;jwagenleitner;It's fixed (does not compile) in master (2.5) but still compiles on 2_4_X.  So fix version should be set to 2.5.0.;;;","30/Sep/16 07:19;blackdrag;set to 2.5 beta 1;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker doesn't find constructor if generic placeholder name doesn't match,GROOVY-6657,12817448,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,03/Apr/14 12:36,05/Apr/14 00:01,14/Jul/23 06:01,03/Apr/14 15:44,2.2.2,,,,,,,,,,,,,,,,,2.2.3,2.3.0-beta-1,,,Static Type Checker,,,,0,,,,,,,"The following code fails compilation:

{code}
class Helper<V> {
    public Helper(Closure<V> cl) {}
}

static <C> void extensionMethod(Closure<C> cl) {
    new Helper<C>(cl)
}

extensionMethod {
    'string'
}
{code}

The type checker incorrectly tries to match the placeholder name, even if it's not defined at the same level. It's a regression, this used to compile in 2.2.1.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 03 12:37:25 UTC 2014,,,,,,,,,,"0|i2cetz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Apr/14 12:37;melix;This issue affects Reactor (see https://github.com/reactor/reactor/commit/fc489925abd794abd0196e50bbd7fb465a5ebe75);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyClassLoader parallelLockMap memory leak on Java 7,GROOVY-6655,12817442,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,djh,djh,03/Apr/14 08:17,10/Feb/23 21:39,14/Jul/23 06:01,17/Sep/22 08:29,2.2.2,,,,,,,,,,,,,,,,,4.0.5,,,,groovy-runtime,,,,2,classloader,java,leak,memory,metaprogramming,,"Java 7 introduced parallel classloading. There is a map in {{java.lang.ClassLoader}} called {{parallelLockMap}}. This map holds String keys for class names and the associated Objects used to synchronize on for each class.

Now, I found that dynamically parsing (perhaps also loading?) and unloading classes with {{GroovyClassLoader}} leaves obsolete keys in this map. Any time {{java.lang.ClassLoader#loadClass(..)}} is called, an entry is created for that class name if it does not exist. 

In the default Java delegating classloader paradigm the delegate classloader is asked for a class first, so a call to the root loader's {{java.lang.ClassLoader#loadClass(..)}} is made for a whole lot of classes, including Groovy metaclasses, polluting the map with keys.

!https://dl.dropboxusercontent.com/u/4655232/parallelLockMapMemoryLeak.png!

The entries that remain in the map even after the class and associated metaclasses themselves have been unloaded have the following two types of keys:

{{""groovy.runtime.metaclass.MyDynamicallyLoadedClassNameMetaClass""}}
{{""MyDynamicallyLoadedClassNameBeanInfo""}}

A key for the class name itself, ie. {{MyDynamicallyLoadedClassName}}, does not appear in the map. I am assuming it is never inserted there, but instead defined by {{GroovyClassLoader}} without asking the parent first. But these metaclass keys *do* leak into the map, eventually exhausting heap memory even if the classes themselves get nicely unloaded (from PermGen) when the {{GroovyClassLoader}} is GC'ed.

Here's a very simple test script that will eventually run out of memory (it does take some time):
{code:title=MemoryLeakTest.groovy}
    String newClass = ""class CLASSNAME {}""
    while (true) {
        GroovyClassLoader gcl = new GroovyClassLoader()
        Class clazz = gcl.parseClass(newClass.replace(""CLASSNAME"", ""NewClass""+System.nanoTime()))
        clazz.newInstance()
    }
{code}

Be sure to run JVM with

{noformat}
-XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled
{noformat}

to make sure you run out of *heap* memory and not *PermGen* space.

One fix for this would be to add a check to {{GroovyClassLoader}} that would prevent it from delegating to the parent first if the class to be loaded is a metaclass of a class loaded by that classloader. I am definitely no expert in this so you might come up with a much better idea.

This has been tested on Groovy 2.0.5 and 2.2.2 and I expect that it affects a lot of versions running on Java 7.

Sure, it doesn't leak memory at a very fast pace, only a {{ConcurrentHashMap}} entry for each class loaded and unloaded. I can see how in many applications this is not a major problem, but please consider for example a server that automatically checks students' programming assignments or such. Please do change the issue priority if appropriate.

!https://dl.dropboxusercontent.com/u/4655232/parallelLockMapMemoryLeak2.png!",Java 7,blackdrag,candrews,daniel_sun,djh,jbochenski,jkemnade,jpozorio,jwagenleitner,lexek,vision57,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8113,GROOVY-8189,,,,,,,,,,,,"17/Sep/22 08:24;daniel_sun;screenshot-1.png;https://issues.apache.org/jira/secure/attachment/13049394/screenshot-1.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Sep 17 08:28:12 UTC 2022,,,,,,,,,,"0|i2cjsf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"03/Apr/14 08:31;djh;This issue has been recently reported on the JDK side [here|https://bugs.openjdk.java.net/browse/JDK-8037342?page=com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel]. While this definitely is an issue in Java, Groovy should perhaps take care not to add to this problem with its metaclass entries, as there is no advantage in doing so.;;;","03/Apr/14 12:32;blackdrag;If I get this right, then it is enough to ask Launcher$AppLoader for random class names to provoke an OMME. I think you don't even need to generate a class at runtime for this.

So now the problem for us. Yes, we have a GroovyClassLoader, but unlike the name may imply for you a GroovyClassLoader is not responsible for loading all the Groovy runtime classes. A GroovyClassLoader may not even be in use. GroovyClassLoader is used only for runtime compiled code. The runtime itself is usually not loaded by a GroovyClassLoader. So the GroovyClassLoader is the wrong place to deny the request, since the GroovyClassLoader cannot know if the request would succeed or not.;;;","03/Apr/14 12:57;djh;Ah yes, I see. Runtime compiled code just happened to be how I ran into this issue! I'm not at all familiar with Groovy internals. 

Is there a way to avoid hitting the AppClassLoader with load requests for Groovy metaclasses? For my own application, I'm thinking of maybe implementing a custom ClassLoader that violates the basic delegating scheme to prevent those metaclass load requests from propagating up the ClassLoader hierarchy.

As for this JIRA, is there anything Groovy can do to avoid hitting this Java bug, or should we just wait for a Java fix?;;;","04/Apr/14 04:45;blackdrag;The typical use case of a server you mentioned means that there is no RootLoader at all. That appears only if we load Groovy from the command line. That is if you really did mean RootLoader, when you said ""root loader""  ;)

Now if you have the ability to put a loader in between the loader for the Groovy runtime and the AppLoader, then yes, you can simply block the requests. Even if your loader is the one doing the loading you won't need to delegate to the parent loader if this==MetaClass.class.getClassLoader(). ""this"" being the classloader. The reason you can do this is, that the custom meta class will require access to the runtime and for this the meta class cannot come from a higher loader, since that would either cause a ClassNotFoundException or the loader constraints are violated and you will have a second Groovy higher up.

But those are no options for this issue here... I don't think we can do anything but wait for them to fix that;;;","04/Apr/14 06:31;djh;By root loader I meant the AppClassLoader, sorry. Edited comment.

Is there any easy way to get my custom loader to be either in between the loader that loads Groovy runtime and the AppClassLoader, or to actually *be* the loader that loads the Groovy runtime? I could have the JVM use a custom system classloader, but that sounds quite dramatic. In a web app, I guess I could set the context classloader to a custom class?;;;","27/Jul/17 08:37;jkemnade;Adding a custom class loader that ""blocks"" {{loadClass}} does not solve the issue completely, you'd also have to do something about the script's {{MetaClass}}. When that is created, the {{defineClass}} goes all the way through to the root loader and there, {{defineClass}} calls {{loadClass}} again (via a native method). I really don't want to call reflection to the rescue to fiddle around with the root loader's {{parallelLockMap}}, but I fear that it might be the only ""solution"".;;;","04/Feb/21 21:54;jpozorio;I have found a workaround for this problem: https://issues.apache.org/jira/browse/GROOVY-8113?focusedCommentId=17279013&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-17279013;;;","17/Sep/22 08:28;daniel_sun;Your code works well with groovy 4.0.5 and Java8
{code:java}
    String newClass = ""class CLASSNAME {}""
    while (true) {
        GroovyClassLoader gcl = new GroovyClassLoader()
        Class clazz = gcl.parseClass(newClass.replace(""CLASSNAME"", ""NewClass""+System.nanoTime()))
        clazz.newInstance()
    }
{code}


 !screenshot-1.png! ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Can't @Override method with generic argument type in parameterized subclass,GROOVY-6654,12817332,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pniederw,pniederw,03/Apr/14 06:31,19/Sep/14 14:24,14/Jul/23 06:01,03/Apr/14 06:55,2.3.0-beta-1,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,Compiler,,,,0,,,,,,,"Base.groovy
{code}
class Base<T> {
  void foo(T t) {}
}
{code}

Derived.groovy
{code}
class Derived extends Base<String> {
  @Override
  void foo(String s) {}
}
{code}

Compile error: 
{code}
Error:(2, 3) Groovyc: Method 'foo' from class 'Derived' does not override method from its superclass or interfaces but is annotated with @Override.
{code}

Removing the @Override annotation appears to solve the problem. Earlier Groovy versions (e.g. 2.0.x) didn't have this problem. Tested with latest groovy-all-2.3.0-SNAPSHOT.",,aya_eiya,bpturner,burnayev,lhotari,melix,paulk,pniederw,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 19 14:24:07 UTC 2014,,,,,,,,,,"0|i2cqnj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Apr/14 06:55;melix;Fixed, thanks for the report!;;;","12/May/14 02:38;bpturner;Can someone confirm the fix here? I'm using the 2.3.0 final artifact and this same thing appears to be an issue there. This issue indicates it was fixed in beta 1, so I'm assuming, if that's true, that the fix would be in the 2.3.0 final artifact?;;;","12/May/14 12:58;pschumacher;Hi Bryan,

the fix is in the 2.3.0 final (see: [https://github.com/groovy/groovy-core/commit/2ef491110828d7c94148c214cdacba22438a7e30#diff-2e7f811f5498dbd11630a0f6350d72ac]).

It would be nice if you can post a small example showing the issue you are facing.

Thanks,
Pascal;;;","21/Aug/14 01:25;aya_eiya;I still encountered this bug in case of gradle testCompile using groovy-all.jar(2.3.6) with spock(0.7-groovy-2.0).
I'm avoiding the bug by using groovy-all.jar(2.2.2) for now.

Note:The bug can see in case of using  groovy-all.jar(2.4.0-beta-1 or 2).;;;","21/Aug/14 02:05;aya_eiya;I cannot make small example showing the issue yet...

If I can make the example, I report here again.;;;","21/Aug/14 03:00;aya_eiya;Year! I find the bug.

But It's not in 2.3.x or 2.4.0-beta.

The bug is in 2.2.x.In this version you can use @Override for the method having the same name of its super class""s method,regardless of its types of arguments.

And the version 2.3.x or upper is not allow this(Strictly check the argument type) for @Override.

So that you encounter the error when you upgrade the version from 2.2.x to 2.3.x or upper.

I didn't know this,but may have reported as other issue .

Working Example:
https://github.com/aya-eiya/groovy-bug-project;;;","22/Aug/14 02:47;paulk;So are you confirming that there is no new bug? I.e. 2.3 and above work as expected and 2.2.x has the less strict @Override - itself a bug only fixed for 2.3+?;;;","29/Aug/14 04:07;aya_eiya;Yes.
As far as I confirmed,2.3+ has no bugs,reporting the incorrect compile error message.

But in case of upgrading 2.2 to 2.3+,this is a little bit a problem.
;;;","19/Sep/14 14:24;burnayev;I still see the issue in Grails 2.4.2/groovy-all-2.3.3.

Here's a test:

abstract class Base<T> {
    abstract Map map(T t)
}

class Derived {
    @Override
    Map map(Obj obj) {
        return [:]
    }
}

Method 'map' from class 'Derived' does not override method from its superclass or interfaces but is annotated with @Override.

Thoughts?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StackOverflow Exception when calling super.method when extending java class,GROOVY-6653,12811779,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,alehbich,alehbich,03/Apr/14 05:22,05/Feb/23 16:21,14/Jul/23 06:01,07/Dec/21 22:38,2.2.1,,,,,,,,,,,,,,,,,4.0.0-rc-2,,,,groovy-runtime,,,,0,,,,,,,"You can get StackOverflowError when running following code:
{code:title=A.java}
package test.java;

public abstract class A<T> {
    protected String getText(T arg){
        return ""Class A."";
    }
}
{code}
{code:title=C.java}
package test.java;

public class C extends A<String> {
    @Override
    protected String getText(String arg){
        return super.getText(arg) + ""Class C. "";
    }
}
{code}
{code:title=D.groovy}
package test.java

class D extends C {
    @Override
    protected String getText(String arg) {
        return super.getText(arg) + 'Class D.';
    }

    public static void main(String[] args) {
        D d = new D();
        String res = d.getText(null);
        println(res);
    }
}
{code}

This bug occurs when class A is generic and method has parameterized argument.
{code:title=Output}
Exception in thread ""main"" java.lang.StackOverflowError
	at test.java.D.getText(D.groovy)
	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1085)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:128)
	at test.java.D.getText(D.groovy:6)
	at test.java.D.getText(D.groovy)
{code}
This bug looks similar to GROOVY-5385",,alehbich,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10594,,,,,,,,,,,,,"03/Apr/14 05:22;alehbich;erroroutput.txt;https://issues.apache.org/jira/secure/attachment/12722200/erroroutput.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 07 22:38:05 UTC 2021,,,,,,,,,,"0|i2ccb3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Jun/21 03:45;paulk;A workaround is to add {{@CompileStatic}} to {{D#getText}} in cases where no dynamic behavior is needed.;;;","07/Dec/21 22:38;emilles;https://github.com/apache/groovy/commit/19ade45010b92ae959d3b06909e99e93d6d07e53;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
String Array Concatenation result modified by Static Compilation,GROOVY-6650,12817382,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tkruse,tkruse,02/Apr/14 03:04,24/Apr/14 19:00,14/Jul/23 06:01,11/Apr/14 08:32,2.2.2,,,,,,,,,,,,,,,,,2.2.3,,,,,,,,0,,,,,,,"To reproduce

{code}
import groovy.transform.CompileStatic

@CompileStatic
public class Concat {
  public static void main(String[] args) {
    def x = 'a,b,c'.split(',')
    def y = 'd,e,f'.split(',')
    println(x + y)
  }
} 
{code}

Without @CompileStatic yields:
{code}
[a, b, c, d, e, f]
{code}
With @CompileStatic yields:
{code}
[a, b, c, [d, e, f]]
{code}
Should rather be the same.",,melix,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 09 03:49:28 UTC 2014,,,,,,,,,,"0|i2cep3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Apr/14 09:38;tkruse;I can reproduce using 2.3.0-beta-1;;;","09/Apr/14 03:49;melix;Using this code:
{code}
import groovy.transform.CompileStatic
import groovy.transform.ASTTest
import static org.codehaus.groovy.transform.stc.StaticTypesMarker.*
import static org.codehaus.groovy.classgen.asm.BytecodeHelper.*

@CompileStatic
public class Concat {
  public static void main(String[] args) {
    @ASTTest(phase=INSTRUCTION_SELECTION,value={
        println node.getNodeMetaData(INFERRED_TYPE)
    })
    def x = 'a,b,c'.split(',')
    @ASTTest(phase=INSTRUCTION_SELECTION,value={
        println node.getNodeMetaData(INFERRED_TYPE)
    })
    def y = 'd,e,f'.split(',')
    @ASTTest(phase=INSTRUCTION_SELECTION,value={
        def target = node.rightExpression.getNodeMetaData(DIRECT_METHOD_CALL_TARGET)
        def emn = target.extensionMethodNode
        println (""$emn.declaringClass#$emn.name${getMethodDescriptor(emn)}"")
    })
    def z = x + y
  }
}  
{code}

which ouputs:

{noformat}
java.lang.String[]
java.lang.String[]
org.codehaus.groovy.runtime.DefaultGroovyMethods#plus([Ljava/lang/Object;Ljava/lang/Object;)[Ljava/lang/Object;
{noformat}

We can see that the return type of {{split}} is properly inferred. The method which is chosen for the {{plus}} operation comes from DGM:

{noformat}
org.codehaus.groovy.runtime.DefaultGroovyMethods#plus(T[], T)
{noformat}

however in bytecode we see:
{code}
ALOAD 1
    LDC [Ljava/lang/Object;.class
    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType (Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;
    CHECKCAST [Ljava/lang/Object;
    ALOAD 2
    INVOKESTATIC org/codehaus/groovy/runtime/DefaultGroovyMethods.plus ([Ljava/lang/Object;Ljava/lang/Object;)[Ljava/lang/Object;
    LDC [Ljava/lang/String;.class
    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType (Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;
    CHECKCAST [Ljava/lang/String;
    ASTORE 3
{code}

so the receiver is converted to Object[], but not the argument. The method which should have been chosen is DGM#plus(T[],T[]) instead.

I assume a bug with vargs then.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Grab not respecting initClass=false,GROOVY-6648,12817445,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,01/Apr/14 20:32,07/Apr/15 19:06,14/Jul/23 06:01,02/Apr/14 07:55,2.2.2,,,,,,,,,,,,,,,,,2.2.3,,,,Grape,,,,0,,,,,,,,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-04-01 20:32:14.0,,,,,,,,,,"0|i2c8qf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static compilation fails at runtime for calling private constructor,GROOVY-6647,12817409,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,01/Apr/14 08:29,05/Apr/14 00:00,14/Jul/23 06:01,01/Apr/14 08:52,,,,,,,,,,,,,,,,,,2.2.3,2.3.0-beta-1,,,Static compilation,,,,0,,,,,,,"{code:Java}
class Foo{
  private Foo(){}
}
@CompileStatic
class Bar {
  def foo(){new Foo()}
}
{code}
This fails with 
java.lang.IllegalAccessError: tried to access method Foo.<init>()V from class Bar

The reason is that @TypeChecked makes no accessiblity check, but @CompileStatic needs that. In case of methods it fails, because StaticInvocationWriter is doing the check. Better would be to check during method selection already, because another accessible member might be missed otherwise (see GROOVY-6632 for this)",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6632,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 01 08:52:52 UTC 2014,,,,,,,,,,"0|i2bszz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Apr/14 08:52;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
vararg method resolution with static compilation selects wrong candidate between (String...) and (Class<?> ...),GROOVY-6646,12818293,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,tkruse,tkruse,31/Mar/14 05:44,05/Apr/14 09:38,14/Jul/23 06:01,01/Apr/14 03:01,,,,,,,,,,,,,,,,,,2.2.3,2.3.0-beta-1,,,Static compilation,,,,0,,,,,,,"As discussed here:
http://groovy.329449.n5.nabble.com/CompileStatic-breaking-vararg-call-resolution-td5718966.html
There seem to be at least two bug-like symptoms when using @CompileStatic, for resolving Constructors and for resolving methods.
```
import groovy.transform.CompileStatic

@CompileStatic
public class Starter {
    public static void main(String[] args) {
        new Starter(List.class, Map.class)
        //println foo (List.class, Map.class)
    }
    public Starter(Class<?>... classes) {System.out.println(""Classes"");}
    public Starter(String... strings) {System.out.println(""Strings"");}
    static def foo(Class... cs) { ""Classes"" }
    static def foo(String... ss) { ""Strings"" }
} 
```

When run like this, prints ""Strings"", should print ""Classes"" as it does without @CompileStatic.
When commenting out the call to foo, Should print ""Classes"", ""Classes"", instead currently does not compile:
```
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/tmp/Starter.groovy: 8: [Static type checking] - Cannot call Starter#foo(java.lang.String[]) with arguments [java.lang.Class <java.util.List>, java.lang.Class <java.util.Map>] 
 @ line 8, column 9.
           foo (List.class, Map.class)
```",,blackdrag,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Apr 05 09:38:33 UTC 2014,,,,,,,,,,"0|i2byhb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Apr/14 03:01;blackdrag;fixed;;;","05/Apr/14 09:38;tkruse;possibly related: https://jira.codehaus.org/browse/GROOVY-6650;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiling a source with a URL pointing to the current working directory produces incorrectly named classes for top-level closures,GROOVY-6641,12818295,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,awilkinson,awilkinson,27/Mar/14 12:17,01/Feb/19 21:21,14/Jul/23 06:01,01/Apr/14 07:19,2.2.1,2.2.2,,,,,,,,,,,,,,,,2.2.3,2.3.0-beta-1,,,Compiler,,,,0,,,,,,,"I identified this problem while diagnosing a [bug reported against Spring Boot|https://github.com/spring-projects/spring-boot/issues/594].

It's probably best described with an example:

{code}
GroovyClassLoader groovyClassLoader = new GroovyClassLoader();
CompilationUnit compilationUnit = new CompilationUnit(groovyClassLoader);
compilationUnit.addSource(new URL(""file:foo.groovy""));
compilationUnit.compile();

CompileUnit ast = compilationUnit.getAST();
System.out.println(ast.getClasses());
{code}

Compiling the above, and running it with a file named {{foo.groovy}} in the current working directory with the contents:

{code}
foo {

}
{code}

will produce the output:

{noformat}
[file:foo]
{noformat}

I would expect the class to be named {{foo}}, not {{file:foo}}. This is the result if {{foo.groovy}} is moved into a directory named {{foo}} and the URL used to reference it becomes {{file:foo/foo.groovy}}. 

I believe the problem lies in {{org.codehaus.groovy.ast.ModuleNode.extractClassFromFileDescription()}} as it does not consider a URL that contains no slashes. As a result it never strips off the {{file:}} prefix.",,blackdrag,joseph.henry,wilkinsona,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 01 21:21:50 UTC 2019,,,,,,,,,,"0|i2ckgf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Apr/14 07:19;blackdrag;fixed;;;","01/Feb/19 21:21;joseph.henry;This change caused a regression on linux systems where now a script that starts with a # will result in an error:

Exception in thread ""main"" java.lang.ClassFormatError: Illegal class name """" in class file 

simply doing this:

groovy /path/#myfile

will produce this error. All version prior to this change work fine.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compilation warning when using @AutoClone on an object with collection properties,GROOVY-6640,12817406,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,nicoletreague,nicoletreague,27/Mar/14 09:54,05/Apr/14 00:00,14/Jul/23 06:01,28/Mar/14 08:24,2.2.2,,,,,,,,,,,,,,,,,2.2.3,2.3.0-beta-1,,,groovy-jdk,,,,1,,,,,,,"I'm getting a compilation error/warning when I try to compile a class using the @AutoClone annotation (with a ""copy constructor"" style) which contains list/collection values. I am using Groovy 2.2.2, and building my code using IntelliJ Ultimate 12.1.3.

Attached is a simple test class I put together which produces the error when compiled. The error message I get in my IDE is as follows:

Groovyc: A transform used a generics containing ClassNode com.Test for the constructor protected void <init>(com.Test other)  { ... } directly. You are not supposed to do this. Please create a new ClassNode referring to the old ClassNode and use the new ClassNode instead of the old one. Otherwise the compiler will create wrong descriptors and a potential NullPointerException in TypeResolver in the OpenJDK. If this is not your own doing, please report this bug to the writer of the transform.",,nicoletreague,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Mar/14 09:54;nicoletreague;Test.groovy;https://issues.apache.org/jira/secure/attachment/12723138/Test.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 28 08:24:38 UTC 2014,,,,,,,,,,"0|i2btrr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Mar/14 08:24;paulk;Thanks for spotting the error. It should be fixed in the next releases of Groovy. If you get a chance to test the snapshot jars/build, that would be great.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker may create Expression$XXX.class files,GROOVY-6639,12817414,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,27/Mar/14 09:31,15/Oct/15 18:19,14/Jul/23 06:01,27/Mar/14 09:32,,,,,,,,,,,,,,,,,,2.2.3,,,,,,,,0,,,,,,,"In some circumstances (some {{@DelegatesTo}} annotations for example), the type checker creates an Expression$XXX.class file in the working directory.

Originally reported here: https://github.com/ratpack/ratpack/issues/282",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 27 09:32:32 UTC 2014,,,,,,,,,,"0|i2boz3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Mar/14 09:32;melix;Fixed by https://github.com/groovy/groovy-core/commit/a3ba4ffca25293cc001e88b480087cf84d8a78c1 (on master, 2.1.X and 2.2.X).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic when accessing parent class static properties produces access forbidden message with incorrect line number info,GROOVY-6637,12817405,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,graemerocher,graemerocher,26/Mar/14 07:34,02/May/17 02:03,14/Jul/23 06:01,20/Sep/16 01:05,2.2.2,2.3.0,2.3.1,2.4.0-rc-1,,,,,,,,,,,,,,2.4.3,,,,Static compilation,,,,0,,,,,,,"The following:

{code}
import groovy.transform.*

@CompileStatic
class Foo {
   static bar = ""hello""
}

@CompileStatic
class Bar extends Foo{
   static something() {
       println bar
   }
}
new Bar().something()
{code}

Produces:

{code}
Access to java.lang.Object#bar is forbidden at line: -1, column: -1
{code}

Changing the println to:

{code}
       println getBar()
{code}

fixes the problem, but shouldn't be necessary.

In addition, even if using only 'bar' was to be forbidden, the line number information is incorrect",,graemerocher,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 20 01:05:12 UTC 2016,,,,,,,,,,"0|i2cnkn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Sep/16 01:05;paulk;This seems to be fixed. I tried several recent versions and back to 2.4.3 with all versions working. I suspect some other issue fixed this one.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC/CS: constructor call with Map argument fails when javabean property has a setter but no getter,GROOVY-6636,12817391,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lhotari,lhotari,26/Mar/14 06:36,17/Dec/14 13:25,14/Jul/23 06:01,19/Sep/14 07:15,2.2.2,2.3.0,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Static Type Checker,,,,0,,,,,,,"STC/CS: constructor call with Map argument fails when javabean property has a setter but no getter for a property

code example:
https://gist.github.com/lhotari/acd561743c157139d7ee

{code}
import groovy.transform.*
 
@CompileStatic
class ForwardUrlMappingInfo {
    String id
    Map parameters = new HashMap()
 
    void setParams(Map params) {
       parameters = params
    }
 
// succeeds when there is a getter
//    Map getParams() {
//       parameters
//    }
}
 
@CompileStatic
def applyParams(Map params) {
    new ForwardUrlMappingInfo(id: params.id, params: (Map)params.params)
}
 
applyParams([id: 'test', params: [hello: 'world']])
{code}


{code}
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isAssignableTo(StaticTypeCheckingSupport.java:313)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.checkGroovyConstructorMap(StaticTypeCheckingVisitor.java:823)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.typeCheckMapConstructor(StaticTypeCheckingVisitor.java:1589)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorCallExpression(StaticTypeCheckingVisitor.java:1563)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitConstructorCallExpression(StaticCompilationVisitor.java:261)
	at org.codehaus.groovy.ast.expr.ConstructorCallExpression.visit(ConstructorCallExpression.java:44)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:415)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:245)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitDeclarationExpression(ClassCodeVisitorSupport.java:107)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:86)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitIfElse(StaticTypeCheckingVisitor.java:2478)
	at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:41)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitClosureExpression(CodeVisitorSupport.java:174)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClosureExpression(StaticTypeCheckingVisitor.java:1658)
	at org.codehaus.groovy.ast.expr.ClosureExpression.visit(ClosureExpression.java:43)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitProperty(ClassCodeVisitorSupport.java:141)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1043)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:162)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:110)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:60)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
{code}",,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-03-26 06:36:18.0,,,,,,,,,,"0|i2bywf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Annotated enum constants breaks enum,GROOVY-6634,12817377,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,melix,melix,25/Mar/14 15:12,02/May/17 02:03,14/Jul/23 06:01,05/Dec/15 20:52,2.4.0-rc-1,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,"If you write something like this:

{code}
enum FooEnum {
    foo,
    @Deprecated bar,
    baz,
    blah
}
{code}

Then the generated enum misses all constants after {{foo}}. There's no compilation error (and it should pass), but constants are just missing.",,jwagenleitner,melix,pascalschumacher,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7342,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 01 18:26:15 UTC 2015,,,,,,,,,,"0|i2c0t3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Apr/14 02:01;paulk;It isn't the annotation per se that is the problem. This example works correctly:
{code}
enum FooEnum { @Deprecated foo, @Deprecated bar, @Deprecated
  baz }
assert FooEnum.values() == [FooEnum.foo, FooEnum.bar, FooEnum.baz]
['foo', 'bar', 'baz'].each {
  assert FooEnum.getDeclaredField(it).annotations*.annotationType() == [Deprecated]
  assert FooEnum.getDeclaredField(it).type == FooEnum
}
{code}
As does this one:
{code}
enum FooEnum { @Deprecated foo, @Deprecated bar,
  @Deprecated baz, }
assert FooEnum.values() == [FooEnum.foo, FooEnum.bar, FooEnum.baz]
['foo', 'bar', 'baz'].each {
  assert FooEnum.getDeclaredField(it).annotations*.annotationType() == [Deprecated]
  assert FooEnum.getDeclaredField(it).type == FooEnum
}
{code}
But in this example, {{baz}} is parsed as the first class field:
{code}
enum FooEnum { @Deprecated foo, @Deprecated bar,
  @Deprecated baz }
assert FooEnum.values() == [FooEnum.foo, FooEnum.bar]
['foo', 'bar'].each {
  assert FooEnum.getDeclaredField(it).annotations*.annotationType() == [Deprecated]
  assert FooEnum.getDeclaredField(it).type == FooEnum
}
assert FooEnum.getDeclaredField('baz').type == Object
{code}
In the grammar ""annotation identifier"" on a new line and with no trailing comma is good enough to be seen as the first normal classField with the annotation as the placeholder for the type, yielding Object as the type. In theory a small tweak to the grammar might be able to fix this? But we do allow a comma with nothing after it, so it might be tricky.;;;","01/Dec/15 00:55;jwagenleitner;I tested this in master and it's fixed by GROOVY-7342 so I think this can be resolved.;;;","01/Dec/15 18:04;pascalschumacher;Thanks for looking into this. :)

As a committer you should be able to close issues yourself, otherwise your jira accounts rights are not set correctly.;;;","01/Dec/15 18:26;jwagenleitner;Doesn't seem like my rights have changed, on profile tab it shows I'm in the {{jira-users}} group and I don't have the option to close.  My 'jwagenleitner' JIRA account pre-dates my samed named ASF account so wonder if that might be the problem.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
All JsonOutput.toJson methods except JsonOutput.toJson(Object) do not check the argument for null.,GROOVY-6633,12817375,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,bura,bura,24/Mar/14 13:04,05/Apr/14 00:00,14/Jul/23 06:01,02/Apr/14 05:30,,,,,,,,,,,,,,,,,,2.2.3,,,,JSON,,,,0,,,,,,,,,bura,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 24 14:09:17 UTC 2014,,,,,,,,,,"0|i2c9hr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Mar/14 14:09;bura;Fixed, pull request: https://github.com/groovy/groovy-core/pull/362;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic selects wrong constructor when GString is a parameter,GROOVY-6632,12817350,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,ngalarneau,ngalarneau,24/Mar/14 11:59,26/Jul/18 04:38,14/Jul/23 06:01,17/May/18 05:44,2.2.2,,,,,,,,,,,,,,,,,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,,Static compilation,,,,1,,,,,,,"This JavaFX program runs fine on Java 8:

{code}
//@CompileStatic
class ImageCompStatic
{
  public static void main(String[] args)
  {
    PlatformImpl.startup({})   // quick hack to start up the JavaFX runtime
    String path = ""image.png""
    Image img = new Image(""$path"")
    println img.height
  }
}
{code}

If CompileStatic is not commented out, you get the following error at run time:
Exception in thread ""main"" java.lang.IllegalAccessError: tried to access method javafx.scene.image.Image.<init>(Ljava/lang/Object;)V from class ImageCompStatic

CompileStatic seems to change the selected constructor from the correct one:
{code}
public Image(String)
{code}
to the wrong one:
{code}
private Image(Object)
{code}

Changing the constructor invocation to:
{code}
    Image img = new Image(""$path"" as String)
{code}
also works.",,blackdrag,blmiller,daniel_sun,mauromol,ngalarneau,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6647,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 17 05:44:52 UTC 2018,,,,,,,,,,"0|i2ce1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Apr/14 08:13;blackdrag;first, the missing package imports are
import com.sun.javafx.application.PlatformImpl 
import javafx.scene.image.Image

second... I took a short look at it and it seems there is no accessibility check for constructor calls at all. For methods it is done in the StaticInvocationWriter. But that suggests, that if there is an accessible method, it might not be used and instead compilation fails. Still this is better, than just getting a runtime error like here.

So the very least that has to be done is to add an accessibility check to the writer for constructor calls to ensure the target constructor can actually be used;;;","01/Apr/14 08:54;blackdrag;GROOVY-6647 is related to the problem here. Thanks to the fix there, the code in this issue will no longer compile with @CompileStatic instead of failing at runtime. Though it is desirable that the code here simply takes the right constructor;;;","17/May/18 05:44;daniel_sun;The issue should be same with GROOVY-7883, which has been fixed in 2.5.0-rc-3(will be released soon);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Static compilation confused by factory methods, map initializers and generics",GROOVY-6630,12817438,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ddimitrov,ddimitrov,24/Mar/14 02:41,28/Apr/14 19:30,14/Jul/23 06:01,25/Apr/14 05:05,,,,,,,,,,,,,,,,,,2.3.0-rc-1,,,,Static compilation,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
class TestFails<T extends Comparable> {
    List<T> x
    static <M extends Comparable> TestFails<M> select(List<M> x) { 
        new TestFails<M>(x: x) 
    }
}
{code}

Error:(9, 22) Groovyc: [Static type checking] - Cannot assign value of type java.util.List <M> to variable of type java.util.List <T>

{code}
@groovy.transform.CompileStatic
class TestWorks<T extends Comparable> {
    List<T> x
    static <M extends Comparable> TestWorks<M> select(List<M> x) {
        new TestWorks<M>()
    }
}
{code}",,blackdrag,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 25 05:05:52 UTC 2014,,,,,,,,,,"0|i2brlr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"24/Apr/14 09:06;blackdrag;sadly Test is missing, thus I cannot know if that has been fixed or not. In a local experiment I used {code:Java}
class Test<T extends Comparable> extends TestFails<T> {
    List<T> x
}{code}which passes compilation in 2.3. Not sure that is what was asked for. The issue can be reopened any time of course;;;","24/Apr/14 20:49;ddimitrov;The test case is the first snippet in the issue description - {{TestFails}} used to break the compiler with the quoted message.  If we change the code as in {{TestWorks}} snippet (remove constructor params) then it compiles.

It boils down that when we use the default map constructor in a factory method, it fails typechecking if one of the fields has a generic type and the generic type parameter comes from the factory method (I hope that makes sense).;;;","24/Apr/14 20:50;ddimitrov;Actually, just noted the typo - corrected the first snippet.;;;","25/Apr/14 05:05;blackdrag;In that case I can close the issue as fixed in 2.3.0;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compiler fails on constructors with initializers,GROOVY-6628,12817407,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,ddimitrov,ddimitrov,24/Mar/14 01:44,28/Dec/14 05:17,14/Jul/23 06:01,28/Dec/14 05:17,2.2.2,2.3.1,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Static compilation,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
class Test {
    Test(InetAddress bindTo = InetAddress.getByName(""localhost"")) { }
}
{code}

Fails with NPE in the compiler",,ddimitrov,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 05:17:13 UTC 2014,,,,,,,,,,"0|i2bpzz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"16/May/14 12:52;pschumacher;On master (2.4-SNAPSHOT) I get:

{quote}org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during class generation: Internal compiler error while compiling test.txt
Constructor: null
Line 3, expecting casting to java.net.InetAddress but operand stack is empty

java.lang.ArrayIndexOutOfBoundsException: Internal compiler error while compiling test.txt
Constructor: null
Line 3, expecting casting to java.net.InetAddress but operand stack is empty
        at org.codehaus.groovy.classgen.asm.OperandStack.throwExceptionForNoStackElement(OperandStack.java:310){quote};;;","28/Dec/14 05:17;pschumacher;Thanks for reporting. Your example works with groovy 2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With CompileStatic And Class.newInstance(),GROOVY-6627,12817425,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,19/Mar/14 16:27,05/Apr/14 00:00,14/Jul/23 06:01,04/Apr/14 04:26,,,,,,,,,,,,,,,,,,2.2.3,2.3.0-beta-1,,,Compiler,,,,0,,,,,,,"While upgrading Grails to be compatible with Groovy 2.3 and JDK8 I came across a number of places where we invoke .newInstance() on a Class and that code no longer compiles with the current 2.3 code. 

{noformat}
newinstance $ groovy -version
Groovy Version: 2.1.9 JVM: 1.8.0 Vendor: Oracle Corporation OS: Mac OS X
newinstance $ 
newinstance $ cat Demo.groovy 
@groovy.transform.CompileStatic
class Demo {
    def createBuffer(Class<StringBuffer> c, String initialValue) {
        c.newInstance(initialValue)
    }
}
newinstance $ 
newinstance $ groovyc Demo.groovy 
newinstance $ 
{noformat}

{noformat}
newinstance $ groovy -version
Groovy Version: 2.3.0-SNAPSHOT JVM: 1.8.0 Vendor: Oracle Corporation OS: Mac OS X
newinstance $ 
newinstance $ cat Demo.groovy 
@groovy.transform.CompileStatic
class Demo {
    def createBuffer(Class<StringBuffer> c, String initialValue) {
        c.newInstance(initialValue)
    }
}
newinstance $ 
newinstance $ groovyc Demo.groovy 
>>> a serious error occurred: BUG! exception in phase 'instruction selection' in source unit 'Demo.groovy' Declaring class for method call to 'java.lang.Object newInstance(java.lang.Class, java.lang.Object[])' declared in java.lang.Class was not matched with found receiver java.lang.StringBuffer. This should not have happened!
>>> stacktrace:
BUG! exception in phase 'instruction selection' in source unit 'Demo.groovy' Declaring class for method call to 'java.lang.Object newInstance(java.lang.Class, java.lang.Object[])' declared in java.lang.Class was not matched with found receiver java.lang.StringBuffer. This should not have happened!
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.extractPlaceHolders(StaticTypeCheckingVisitor.java:3878)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.resolvePlaceHoldersFromDeclaration(StaticTypeCheckingVisitor.java:3797)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.resolvePlaceHoldersFromDeclaration(StaticTypeCheckingVisitor.java:3795)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnTypeGenerics(StaticTypeCheckingVisitor.java:3615)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnTypeGenerics(StaticTypeCheckingVisitor.java:3610)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2501)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:245)
{noformat}",,brownj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 20 09:04:34 UTC 2014,,,,,,,,,,"0|i2c6cn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Mar/14 09:04;brownj;Here is a link to a change I made recently to make Grails compile with Groovy 2.3.  

https://github.com/grails/grails-core/commit/c2143cc8d092bb8ef128cea9ad394520208cc061

All of the code there compiled fine with Groovy 2.2.2 and required the changes in that commit to compile with the latest 2.3.  Please let me know whatever I can do to help.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sql failed to process query unterminated ' character  - legal statement containing quotes,GROOVY-6625,12817325,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,libertyscott,libertyscott,17/Mar/14 09:58,05/Apr/14 00:00,14/Jul/23 06:01,21/Mar/14 02:56,2.2.1,2.2.2,,,,,,,,,,,,,,,,2.2.3,2.3.0-beta-1,,,groovy-runtime,,,,0,,,,,,,"Groovy sql (worked on Groovy 2.1.9, fails on 2.2.1 and 2.2.2)
Script fails with 

Caught: java.lang.IllegalStateException: Failed to process query. Unterminated '
 character?
java.lang.IllegalStateException: Failed to process query. Unterminated ' charact
er?
        at TestGroovy.main(TestGroovy.groovy:34)

Script to recreate attached

","Windows, Java 1.7.0_45",blackdrag,jwagenleitner,libertyscott,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Mar/14 09:58;libertyscott;TestGroovy.groovy;https://issues.apache.org/jira/secure/attachment/12722401/TestGroovy.groovy","18/Mar/14 14:04;libertyscott;TestH2.groovy;https://issues.apache.org/jira/secure/attachment/12722664/TestH2.groovy","18/Mar/14 14:10;libertyscott;stackTrace.txt;https://issues.apache.org/jira/secure/attachment/12723210/stackTrace.txt",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 21 02:56:02 UTC 2014,,,,,,,,,,"0|i2c5hb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"17/Mar/14 11:32;blackdrag;since I don't have a database to test this... could you provide a full stack trace?;;;","18/Mar/14 12:20;jwagenleitner;I have submitted a pull request for this issue, https://github.com/groovy/groovy-core/pull/360.;;;","18/Mar/14 14:04;libertyscott;Here's a version that uses H2 (which also sees the issue). Add an H2 jar to the Groovy lib folder and test with this. Groovy 2.2.1 and 2.2.2 get the error desccribed. Older Groovies actually the SQL (and get an error). To see the stacktrace, uncomment the try/catch;;;","18/Mar/14 14:10;libertyscott;Here's the stack trace from a Oracle execution;;;","20/Mar/14 05:19;paulk;I'll try to find time to test out John's PR in the next couple of days.;;;","20/Mar/14 10:06;libertyscott;after I finally was able to put together a jar containing the fixed class file, I got good results.

This fix does fix the bug. I have tested both my test case and the full process and this fix resolves the issue completely.

Thank you.;;;","21/Mar/14 02:56;paulk;Thanks for spotting the issue Scott and thanks for the PR John. Merged.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.util.Node#text incorrect when value is a NodeList,GROOVY-6621,12816852,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,ml10,ml10,15/Mar/14 23:42,05/Apr/15 14:44,14/Jul/23 06:01,07/Apr/14 19:00,2.2.2,,,,,,,,,,,,,,,,,2.3.0-beta-2,,,,XML Processing,,,,0,breaking,,,,,,"When groovy.util.Node#text checks for it's value being an instance of Collection, it only accounts for String children elements, which means the text() values of Node children of a NodeList value will not be part of the result.

Github PR with test case to follow.",,ml10,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Mon Apr 07 20:05:52 UTC 2014,,,,,,,,,,"0|i2btr3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"16/Mar/14 00:12;ml10;Github PR: https://github.com/groovy/groovy-core/pull/353;;;","25/Mar/14 22:04;ml10;[Updated Github PR|https://github.com/groovy/groovy-core/pull/364];;;","07/Apr/14 19:00;paulk;Added, thanks Andy! I will also add a convenience method ""localText"" or something similar to make getting the non-nested text a little easier.;;;","07/Apr/14 20:05;paulk;As noted in the PR, this is a very minor breaking change in behavior but the behavior didn't match the javadoc (which described the intended behavior) previously anyway.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
possible problem in regular expression documentation,GROOVY-6620,12817431,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,adrianshum,adrianshum,13/Mar/14 21:19,28/Apr/14 19:31,14/Jul/23 06:01,25/Apr/14 02:05,,,,,,,,,,,,,,,,,,,,,,Documentation,,,,0,,,,,,,"In the documentation http://groovy.codehaus.org/Regular+Expressions , the very first line states that :

bq. Groovy supports regular expressions natively using the ~""pattern"" expression

However, base on the content, the syntax should be ~/pattern/ instead of ~""pattern""",,adrianshum,blackdrag,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 25 02:05:08 UTC 2014,,,,,,,,,,"0|i2c0vj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Mar/14 03:58;blackdrag;/pattern/ and ""pattern"" are both String and ~ is applied as unary operator to it. The difference between the regular and the slashy string is that they have different escaping rules;;;","25/Apr/14 02:05;pschumacher;Thanks for reporting. 

I incorporated  blackdrags comment into the wiki page.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy command-line parser breaks when parsing '-n',GROOVY-6619,12817388,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,codespelunker,codespelunker,13/Mar/14 13:23,02/May/17 02:03,14/Jul/23 06:01,02/Jun/15 17:48,2.2.1,2.2.2,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,command line processing,,,,0,,,,,,,"Here's a simplified script that exposes the error:

args.each { println it }
def cli = new CliBuilder(usage: '...usage...')
cli.n(args: 1, 'The name')
def options = cli.parse(args)
println "":"" + options.n

Run the program with: groovy test.groovy -n name

Using Groovy 2.1.7, I get the expected response:

-n
name
:name

Using Groovy 2.2.2, I get something strange:

?
name
:false

Using -n also breaks any subsequent options passed on the same command line.
",,codespelunker,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 02 17:48:49 UTC 2015,,,,,,,,,,"0|i2c7iv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jun/15 17:48;pascalschumacher;Works for me, when using current master (2.5).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Enum constructor doesn't work properly with variable arguments,GROOVY-6618,12817426,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,bsideup,bsideup,13/Mar/14 04:20,10/Aug/22 21:51,14/Jul/23 06:01,27/Oct/14 10:17,2.2.2,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Compiler,,,,0,breaking,varargs,,,,,"{code:java}
enum Test {
    TEST1(1, 2, 3)

    Test(Integer... ints) {
        println ints
    }
}

println Test.TEST1
{code}

This code gives me only ""[1]"", but it should be ""[1,2,3]""


In Java everything is fine:
{code:java}
public enum Test {
  TEST1(1, 2, 3);
  
  Test(Integer... ints) {
    System.out.println(java.util.Arrays.toString(ints));
  }

  public static void main(String []args){}
}
{code}",,blackdrag,bsideup,candrews,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7370,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 27 10:17:31 UTC 2014,,,,,,,,,,"0|i2csgn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Mar/14 04:55;bsideup;https://jira.codehaus.org/browse/GROOVY-2933 this bug is also presented in 2.2.1 again (workaround - cast to List);;;","23/Oct/14 10:13;blackdrag;The bug lies in the the way the INIT method works (which is used to build the enum instance). We cannot call the constructor reflective, thus we do the same construction here, that we do for super- and this-calls in constructor delegation cases. For this we have MetaClass#selectAndTransformConstructor, which returns a number for the constructor. Since we can return only one thing, the method also modifies the argument array. Later code then makes assumptions about that array. arguments are transformed before the call. The problem now is that the call will expect an array with the numbers 1,2,3 as element 3 of the transformed argument array (the first two elements are the ordinal and the text of the enum). The argument array has in fact 5 elements, 1,2,3 being the last three. This is fine for the input state, but before the call the last three have to be packed in their own array. This step is missing. Thus it takes element 3 (the int 1) and casts it to Integer[], which Groovy allows. The result is the strangely missing 2 and 3.

A first bugfix try for this is to add the usual transformation done before invoking a method, which includes the vargs transformation. Since this will produce a new array, the old information can be overwritten with the new information. This works, for the cases where there is at least one given argument for the varargs case. Meaning in my changed version here TEST1(1, 2, 3) works properly. It's a bit messy, since the argument array will then contain unused elements, but it works in those cases.

But there is one more case and that is when the number of arguments is less than the number of parameters, This would be here for example TEST1(). This is valid for vargs and is supposed to produce an empty array. Since the original argument array is too short, this bug fix idea cannot be applied.;;;","23/Oct/14 10:18;blackdrag;to show that the problem is more general and actually not enum specific:
{code:Java}class Foo {
    Foo(String s,Integer[] a){println a}
    Foo() {this(""foo"",1,2,3)}
}
new Foo(){code}
will also print [1] only;;;","27/Oct/14 10:17;blackdrag;This issue should be fixed now. I had to setup a new method in DefaultTypeTransformation, which is called directly from bytecode. Since that will potentially cause problems to older 2.3 versions I decided to give this issue the label breaking (even though it is not strictly breaking anything) and made it 2.4 only;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
joint compiler fails to compile groovy class implemented java interface,GROOVY-6617,12817321,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,potter_ru,potter_ru,12/Mar/14 16:49,23/Nov/17 07:43,14/Jul/23 06:01,02/May/17 02:00,1.8.6,2.2.2,2.3.0,2.3.1,2.3.2,2.3.3,2.3.4,2.3.5,2.3.6,2.3.7,2.4.10,2.4.11,2.4.12,2.4.13,2.4.6,2.4.8,2.4.9,2.5.0-alpha-1,,,,Stub generator / Joint compiler,,,,0,,,,,,,"When groovy class implements java interface located in other package with method returning array of java objects (not primitive), joint compilation fails with org.codehaus.groovy.control.MultipleCompilationErrorsException

Running joint compiler again compiles this groovy class successfully.

Attached file contains example files and script to run groovyc in joint compiler mode. 
Run ./joint-compile.sh - MultipleCompilationErrorsException
Run it again - success.

To reproduce please remove created *.class files
Reproduced - always.

Workaround: add package name of returned java class to groovy method 
{code}
    public foo.JavaDataObject[] ...
{code}","linux x86-64
oracle jdk 1.6.0.45, oracle jdk 1.8.0.121",daniel_sun,paulk,potter_ru,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8172,,,,,,,,,,,,,,,,,,,,,,,,,,,"09/Oct/14 14:49;potter_ru;groovy-joint-compiler-bug-again.tar;https://issues.apache.org/jira/secure/attachment/12723107/groovy-joint-compiler-bug-again.tar","06/May/14 06:00;potter_ru;groovy-joint-compiler-bug.tar;https://issues.apache.org/jira/secure/attachment/12723242/groovy-joint-compiler-bug.tar",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 16 09:45:24 UTC 2017,,,,,,,,,,"0|i2bsh3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/May/14 05:58;potter_ru;test case attachment was updated.;;;","12/Jun/14 15:11;paulk;Error message:
{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
src\groovy\bar\GroovyLangService.groovy: 11: The return type of foo.JavaDataObject[] makeArray() in bar.GroovyLangService is incompatible with [Lfoo.JavaDataObject; in foo.JavaApi
. At [11:5]  @ line 11, column 5.
       public JavaDataObject[] makeArray () {
       ^

1 error
{noformat}
Stub:
{code}
package bar;

import java.lang.*;
import java.io.*;
import java.net.*;
import java.util.*;
import groovy.lang.*;
import groovy.util.*;

public class GroovyLangService
  extends java.lang.Object  implements
    foo.JavaApi,    groovy.lang.GroovyObject {
public  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}
public  void setMetaClass(groovy.lang.MetaClass mc) { }
public  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}
public  java.lang.Object getProperty(java.lang.String property) { return null;}
public  void setProperty(java.lang.String property, java.lang.Object value) { }
public static  java.lang.Object getTransactional() { return null;}
public static  void setTransactional(java.lang.Object value) { }
public  foo.JavaDataObject[] makeArray() { return (foo.JavaDataObject[])null;}
public  java.util.List<foo.JavaDataObject> makeList() { return (java.util.List<foo.JavaDataObject>)null;}
}
{code};;;","12/Jun/14 20:05;paulk;Should be fixed. Thanks greatly for your attachment. It now seems to build correctly. If you get a chance to test out the snapshot build to confirm on your actual project, that would also be great.;;;","13/Jun/14 06:20;potter_ru;Thanks Paul,

I confirm that your fix works for me.

I took changes made by you in the commit: https://github.com/groovy/groovy-core/commit/ef13700e77d6aa32c578ead9926ffbda6bad2849 (Verifier.java), and applied them to groovy-1.8.6 (I need exactly this version for Grails-2.0.3).
;;;","09/Oct/14 14:48;potter_ru;Joint compiler fails again when function has array of objects parameter.

Compilation error is different:
{noformat}
Can't have an abstract method in a non-abstract class. The class 'bar.GroovyLangService' must be declared abstract or the method '[Lfoo.JavaDataObject; makeArrayFromParams(foo.JavaDataObject[])' must be implemented.
 @ line 7, column 1.
   public class GroovyLangService implements JavaApi {
   ^

1 error
{noformat}

Workaround is the same - add full package name of returned java class to groovy method;;;","09/Oct/14 14:49;potter_ru;updated test case is attached;;;","07/Jun/16 06:41;potter_ru;The problem take place in 2.4.6 version of groovy. Please, try to find time to fix it.

Thanks.;;;","07/Jun/16 09:23;paulk;From my tests, this still fails on the 2_4_X branch but passes on master.;;;","07/Jun/16 10:48;paulk;I added the augmented passing test into master. Obviously it would be nice to back-port the fix to the 2_4_X branch so I'll leave this open but I lowered the priority.;;;","16/Jan/17 09:45;potter_ru;Sorry to say, but the bug still exists in 2.4.8 release.
Could be reproduced using the previous test case.
Please see the groovy-joint-compiler-bug-again.tar attachment.

Thanks and regards,
Igor;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic Reference to constructor is ambiguous,GROOVY-6616,12818289,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,nmccloud,nmccloud,09/Mar/14 19:32,01/Jun/14 18:03,14/Jul/23 06:01,16/May/14 15:49,2.2.2,,,,,,,,,,,,,,,,,2.3.1,,,,Static compilation,,,,0,,,,,,,"Groovy does not properly distinguish between overloaded methods when it is attempting to find the appropriate method to call when using @CompileStatic.

Example:

{code:title=MethodOverload.java|borderStyle=solid}
package test;

public class MethodOverload {
    
    public MethodOverload(String s, short[] arr) {}
    public MethodOverload(String s, int... arr) {}
    public MethodOverload(short[] arr) {} /* Causes confusion within Groovy */
    
    private static final String clz = ""@groovy.transform.CompileStatic\n"" + 
            ""public class Clz {\n"" + 
            ""public void run() {\n"" + 
            ""println(new test.MethodOverload('d',1))\n"" + 
            ""}\n"" + 
            ""}"";

    public static void main(String[] args) throws Exception {
        Class clazz = new groovy.lang.GroovyClassLoader().parseClass(clz);
        clazz.getMethod(""run"").invoke(clazz.newInstance());
    }
    
}
{code}

Running the above will throw the following:

{quote}
Exception in thread ""main"" org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
script1394410025829744485975.groovy: 4: [Static type checking] - Reference to method is ambiguous. Cannot choose between [void test.MethodOverload#<init>(short[]), void test.MethodOverload#<init>(java.lang.String, int[])]
 @ line 4, column 9.
   println(new test.MethodOverload(""d"",1))
{quote}

Groovy is mistakenly choosing (short[]) as one of the method candidates.",,nmccloud,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 01 18:03:01 UTC 2014,,,,,,,,,,"0|i2ct7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/May/14 15:49;pschumacher;Fixed. Thanks for reporting.;;;","01/Jun/14 18:03;nmccloud;Thank you;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy compiler throws internal error with @CompileStatic and getPropertyChangeListeners(),GROOVY-6614,12817412,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,sean.true,sean.true,07/Mar/14 15:06,08/Jul/14 15:28,14/Jul/23 06:01,20/Jun/14 20:49,2.2.2,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,Static compilation,Static Type Checker,,,1,,,,,,,"Compiling:

{code:java}
package bugreport.test

import groovy.beans.Bindable
import groovy.transform.CompileStatic

import java.beans.PropertyChangeListener


@CompileStatic
class GetListeners
{
  @Bindable
  String test = ""a test""
  public void testGetListeners(){
    getPropertyChangeListeners().each {PropertyChangeListener pcl -> println ""$pcl""}
  }
}

{code}
yields:

{panel:bgColor=#FFFFCE}
Groovyc: java.lang.ArrayIndexOutOfBoundsException: Internal compiler error while compiling C:\Users\strue\nca2\nca\playground\dpviewer\dpviewerfx\src\main\groovy\bugreport\test\GetListeners.groovy
Method: MethodNode@1847509784[[Ljava.beans.PropertyChangeListener; getPropertyChangeListeners(java.lang.String)]
Line -1, expecting casting to java.beans.PropertyChangeListener[] but operand stack is empty
	at org.codehaus.groovy.classgen.asm.OperandStack.doConvertAndCast(OperandStack.java:323)
	at org.codehaus.groovy.classgen.asm.OperandStack.doGroovyCast(OperandStack.java:290)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:584)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:543)
	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:357)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:314)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:434)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:177)
	at org.codehaus.groovy.control.CompilationUnit$15.call(CompilationUnit.java:794)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:54)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:80)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:85)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:121)
{panel}

The problem disappears when I remove the @CompileStatic from the class

I get a similar error when compiling similar code in our production context:

{panel:bgColor=#FFFFCE}
Groovyc: A groovyc error occurred while trying to load one of the classes in project dependencies, please ensure it's present. See the message and the stack trace below for reference
java.lang.VerifyError: (class:XXXX, method: getPropertyChangeListeners signature: (Ljava/lang/String; )[Ljava/beans/PropertyChangeListener0; ) Unable to pop operand off an empty stack
	at java.lang.Class.getDeclaredFields0(Native Method)
	at java.lang.Class.privateGetDeclaredFields(Class.java:2570)
	at java.lang.Class.getDeclaredFields(Class.java:1903)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:351)
	at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:258)
	at org.codehaus.groovy.ast.ClassNode.getUnresolvedSuperClass(ClassNode.java:973)
	at org.codehaus.groovy.ast.ClassNode.getUnresolvedSuperClass(ClassNode.java:968)
	at org.codehaus.groovy.control.ResolveVisitor.checkCyclicInheritence(ResolveVisitor.java:1204)
	at org.codehaus.groovy.control.ResolveVisitor.visitClass(ResolveVisitor.java:1181)
	at org.codehaus.groovy.control.ResolveVisitor.startResolving(ResolveVisitor.java:141)
	at org.codehaus.groovy.control.CompilationUnit$10.call(CompilationUnit.java:632)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:912)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:574)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:523)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:54)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:80)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:85)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:121)
{panel}",,mauromol,paulk,sean.true,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 20 20:49:18 UTC 2014,,,,,,,,,,"0|i2c0wf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jun/14 04:44;mauromol;I also hit this problem with Groovy 2.3.0 :-(;;;","20/Jun/14 07:56;paulk;I've pushed a fix for @Bindable. I'll do @Vetoable next before resolving the issue.;;;","20/Jun/14 17:37;mauromol;Great, thank you! For which compiler version(s) do you plan to release the fix?;;;","20/Jun/14 20:49;paulk;Fixed for both @Vetoable and @Bindable for the 2.3 and 2.4/master branches.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Running groovyConsole results in java.lang.UnsupportedClassVersionError,GROOVY-6613,12817422,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,asteingress,asteingress,07/Mar/14 02:18,15/Oct/15 18:15,14/Jul/23 06:01,07/Mar/14 02:37,,,,,,,,,,,,,,,,,,2.2.3,,,,Groovy Console,,,,0,,,,,,,"I just did a fresh build with {{./gradlew dist}} on *master*.

When running {{./bin/groovyConsole}} with JDK 6 from that build I get an java.lang.UnsupportedClassVersionError exception and groovyConsole won't startup:

{code}
./bin/groovyConsole
java.lang.UnsupportedClassVersionError: org/codehaus/groovy/runtime/NioGroovyMethods : Unsupported major.minor version 51.0
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClassCond(ClassLoader.java:637)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:621)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:283)
	at java.net.URLClassLoader.access$000(URLClassLoader.java:58)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:197)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at org.codehaus.groovy.tools.RootLoader.oldFindClass(RootLoader.java:171)
	at org.codehaus.groovy.tools.RootLoader.loadClass(RootLoader.java:143)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
	at org.codehaus.groovy.runtime.m12n.MetaInfExtensionModule.newModule(MetaInfExtensionModule.java:72)
	at org.codehaus.groovy.runtime.m12n.StandardPropertiesModuleFactory.newModule(StandardPropertiesModuleFactory.java:48)
	at org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner.scanExtensionModuleFromProperties(ExtensionModuleScanner.java:77)
	at org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner.scanExtensionModuleFromMetaInf(ExtensionModuleScanner.java:72)
	at org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner.scanClasspathModules(ExtensionModuleScanner.java:54)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:110)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:71)
	at groovy.lang.GroovySystem.<clinit>(GroovySystem.java:33)
	at org.codehaus.groovy.runtime.InvokerHelper.<clinit>(InvokerHelper.java:61)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:72)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:159)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at groovy.ui.Console.<clinit>(Console.groovy:79)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
{code}

The reason is that the groovy-nio module is built with the 51.0 class file format. Removing the groovy-nio makes groovyConsole startup again.",,asteingress,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-03-07 02:18:45.0,,,,,,,,,,"0|i2c7ev:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyRowResult case insensitive inconsistency,GROOVY-6612,12817420,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,yair.nergaon,yair.nergaon,07/Mar/14 01:11,28/May/14 03:03,14/Jul/23 06:01,23/May/14 05:15,2.2.1,,,,,,,,,,,,,,,,,2.2.3,2.3.2,,,groovy-jdk,SQL processing,,,0,groovy,,,,,,"Looks like GrrovyRowResult property access is not consistent.
The current implementation semantics which basically ""says as long as there is one key per case insensitive string the property fetching is case insensitive""  does not make sense to me and moreover it is not consistent. 
The attached testcase shows the inconsistency. In fact, it is not clear at all what should be the result after the second property assignment.

To overcome this bug I have AOP the propertySet and before any settings I removed the previous one (if exists) ensuring no than one String case insensitive key at the time. Without this my Sql row processing is not deterministic.
Thanks in advance,
Yair
",,paulk,yair.nergaon,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"07/Mar/14 01:11;yair.nergaon;GroovyRowResultCaseInsensitiveTest.groovy;https://issues.apache.org/jira/secure/attachment/12722661/GroovyRowResultCaseInsensitiveTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 23 05:15:40 UTC 2014,,,,,,,,,,"0|i2c0nj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"23/May/14 05:15;paulk;Thanks for spotting the issue. Indeed, we need to remove the old value for {{put}} and {{putAll}}, not that the latter is normally used directly.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Class compilation fails,GROOVY-6611,12817397,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mxm-groovy,mxm,07/Mar/14 01:08,15/Oct/15 18:20,14/Jul/23 06:01,10/Mar/14 10:57,2.2.2,,,,,,,,,,,,,,,,,2.2.3,,,,Compiler,,,,0,,,,,,,"Inspired by http://youtrack.jetbrains.com/issue/IDEA-121792

Try to compile the following file: 
{code}
import scala.runtime.AbstractPartialFunction
import scala.runtime.BoxedUnit

public abstract class OnSuccess<T> extends AbstractPartialFunction<T, BoxedUnit> {
    public final boolean isDefinedAt(T t) {false}

    public abstract void onSuccess(T t)
}
{code}
Scala have to be in class path. Download it [here|http://mvnrepository.com/artifact/org.scala-lang/scala-library/2.10.2].


Get the following exception:

Error:Groovyc: BUG! exception in phase 'semantic analysis' in source unit '/Users/maxmedvedev/IdeaProjects/inner-class/src/OnSuccess.groovy' 1
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:916)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:574)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:523)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:54)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:81)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:100)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:121)
Caused by: java.lang.ArrayIndexOutOfBoundsException: 1
	at org.codehaus.groovy.vmplugin.v5.Java5.makeInterfaceTypes(Java5.java:396)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:379)
	at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:258)
	at org.codehaus.groovy.ast.ClassNode.getUnresolvedSuperClass(ClassNode.java:973)
	at org.codehaus.groovy.ast.ClassNode.getUnresolvedSuperClass(ClassNode.java:968)
	at org.codehaus.groovy.control.ResolveVisitor.checkCyclicInheritence(ResolveVisitor.java:1204)
	at org.codehaus.groovy.control.ResolveVisitor.visitClass(ResolveVisitor.java:1181)
	at org.codehaus.groovy.control.ResolveVisitor.startResolving(ResolveVisitor.java:141)
	at org.codehaus.groovy.control.CompilationUnit$10.call(CompilationUnit.java:632)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:912)
	... 14 more",,blackdrag,mxm,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 10 10:57:13 UTC 2014,,,,,,,,,,"0|i2c84f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Mar/14 06:57;blackdrag;I might be able to fix this as soon as I get an answer here: http://stackoverflow.com/questions/22250619/classgetinterfaces-and-classgetgenericinterfaces-return-arrays-of-differin

if it is a jvm bug, I don't know what to do with this;;;","10/Mar/14 10:57;blackdrag;I decided to change the code to work around the problem. It will now use Class#getGenericInterfaces() only. I hope the problem does not show up again at another end, but at leasts the tests worked out so far. But actually this is an issue for Scala. They do something the java compiler would not do and they could prevent this easily as well.

Anyway... the code I have in place now will not give that exception anymore and thus I close it as fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""Expecting to find object/array on stack"" VerifyError when passing static member as argument to chained ctor call",GROOVY-6610,12818290,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,david_costanzo,david_costanzo,06/Mar/14 20:46,02/May/21 09:16,14/Jul/23 06:01,19/Mar/21 15:15,2.2.2,2.4.0-rc-1,,,,,,,,,,,,,,,,2.5.15,3.0.8,4.0.0-alpha-3,,Compiler,,,,1,,,,,,,"The attached script causes the following syntax error when run with Groovy 2.2.2.

{quote}
Caught: java.lang.VerifyError: (class: ReproBug$MyClass, method: <init> signature: ()V) Expecting to find object/array on stack
java.lang.VerifyError: (class: ReproBug$MyClass, method: <init> signature: ()V) Expecting to find object/array on stack
	at ReproBug.main(ReproBug.groovy:18)
{quote}

The code compiles and runs fine as a Java class, which is why I think this is a bug in Groovy.

The problem requires the conjunction of two things:
1) A constructor that invokes another constructor
2) Converting an integer to a string as a parameter to the constructor

I encountered this during real-world scripting (although I used a integer literal), but was able to figure out the cause and work-around the problem.  As such, this does not personally impact me; I am reporting it because I like Groovy and this is an easy way to contribute.

Since I don't know whether you prefer an attachment or an inline quote, here is the code.

{code}
public class ReproBug {

    static private Integer MYINT = 4;
    
    private static class MyClass {
        public final String value;

        public MyClass(String string) {
            value = string;
        }

        public MyClass() {
            this(MYINT.toString()); // <--- causes problems
        }
    }

    public static void main(String[] args) {
        System.out.println(new MyClass().value);
    }
}
{code}

I haven't figured out how to create a Groovy unit test case.  If someone can point me to an example where simply getting the script to compile is proof that the bug is fixed, I'll try to work the attached code into a Groovy unit test case.
",GNU/Linux (x64 SUSE and x86 Fedora Core 18),blackdrag,david_costanzo,emilles,shils,werickson,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/Mar/14 20:46;david_costanzo;ReproBug.groovy;https://issues.apache.org/jira/secure/attachment/12723209/ReproBug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 19 15:15:27 UTC 2021,,,,,,,,,,"0|i2cb7r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Mar/14 01:47;blackdrag;the problem is not the conversion itself, it is getting the value for MYINT. It is done by a property lookup, that uses ""this"" at a time where ""this"" is not yet available, because it happens, before we call super;;;","11/Mar/14 22:44;david_costanzo;Thanks for the explanation.  I've updated the issue summary to reflect your insight.;;;","28/Nov/15 19:18;shils;Note: this bug does not occur if ReproBug is statically compiled, since MYINT is accessed using a static bridge method in that case.;;;","19/Mar/21 15:15;emilles;Dynamic case was fixed earlier.  Static compilation case needed a small change to avoid an error for uninitialized ""this"" in Verifier.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyLexer#require(...) method execution may have a NULL parser,GROOVY-6608,12817433,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,aboyko,aboyko,05/Mar/14 21:58,15/Oct/15 18:19,14/Jul/23 06:01,11/Mar/14 09:54,2.2.0,,,,,,,,,,,,,,,,,2.2.3,,,,ast builder,,,,0,,,,,,,"The issue if found in Groovy Eclipse.

Test Scenario:
def scanFolders(){
	doThis(
		~""(?i)^sometext$"",	// SMART TAB FAILS AFTER HERE.
		// ESCAPE THE DOLLAR SIGN AND THE WORLD SPINS AGAIN
		~""(?i)^_vti_"", 		// Sub-folder exclusion Filter
		null,
		null
	);
};

Press enter at the end of the line and observe NPE in the log. NPE occurs in the method due to the null parser field.

The body of GroovyLexer#require(...) has a reference to parser that may not be set all the time. Furthermore the TODO comment in the method body states that error reporting should be done without parser usage: ""Direct to a common error handler, rather than through the parser"".",,aboyko,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 11 09:54:53 UTC 2014,,,,,,,,,,"0|i2btd3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Mar/14 09:54;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Object ranges should be inferred as Range<Object> for improved fluency,GROOVY-6605,12817311,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,03/Mar/14 07:09,04/Mar/14 16:31,14/Jul/23 06:01,03/Mar/14 07:19,2.2.2,,,,,,,,,,,,,,,,,2.2.3,2.3.0-beta-1,,,,,,,0,,,,,,,"The following code fails with {{master}}:

{code}
static BigInteger iterative(final BigInteger n) {
    validateParameter(n)
    BigInteger total = 1G
    if (n > 1) { (2G..n).each{BigInteger i -> total *= i } }
    total
  }
{code}

The reason is that the inferred type of the big integer range is not {{Range<BigInteger>}} but the concrete type {{ObjectRange}}. Unfortunately, this type is not generified in the Groovy codebase and can't be without breaking binary compatibility.

As a workaround, the inferred type should be {{Range<BigInteger}}.
",,melix,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 03 11:59:06 UTC 2014,,,,,,,,,,"0|i2cpjb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Mar/14 09:37;russel;Sponditious, fixed before I entered the issue :-)

There is one left though, to with trampolines:
{code}
static BigInteger tailRecursiveTrampoline(BigInteger n) {
    validateParameter(n)
    final Closure<BigInteger> iterate
    iterate = {BigInteger i, BigInteger result -> i < 2 ? result : iterate.trampoline(i - 1, result * i)}.trampoline()
    (BigInteger) iterate(n, 1G)
  }
{code}
leads to:
{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
file:/home/users/russel/Progs/Applications/Factorial/Groovy/Factorial_simple.groovy: 73: [Static type checking] - Incompatible generic argument types. Cannot assign groovy.lang.Closure <java.io.Serializable> to: groovy.lang.Closure <BigInteger>
 @ line 73, column 15.
       iterate = {BigInteger i, BigInteger result -> i < 2 ? result : iterate.trampoline(i - 1, result * i)}.trampoline()
                 ^
{code}
;;;","03/Mar/14 09:52;melix;I don't think it's an error here, but rather a limit of the type system. In:

{code}i<2 ? result : iterate.trampoline(i - 1, result * i){code}

{{result}} is a {{BigInteger}}, while {{iterate.trampoline(i-1, result *i)}} returns a {{Closure<BigInteger>}}. This makes me wonder how this code actually works :)

However, rewriting as this would pass:

{code}
import groovy.transform.*
@CompileStatic
static BigInteger tailRecursiveTrampoline(BigInteger n) {
    final Closure<BigInteger> iterate
    iterate = {BigInteger i, BigInteger result -> i < 2 ? result : (BigInteger) iterate.trampoline(i - 1, result * i)()}.trampoline()
    iterate(n, 1G)
  }
  
tailRecursiveTrampoline(5)
{code}

(note that the inner trampoline closure is called);;;","03/Mar/14 11:52;russel;OK, that bit in the middle is worrying ""how this code actually works"", if you don't know, I certainly don't :-)

Type issue: with a ? x : y I would have thought the type checker would demand that x and y were of compatible types BigInteger and Closure<BigInteger> are not compatible in that sense. However the code definitely works at run time with CompileStatic but type checking skipped. So there must be an implicit function call executed.

Having had the issue pointed out, I prefer your variant anyway so will switch to that. However it does leave a mystery to resolve.;;;","03/Mar/14 11:59;russel;OK, this is getting very weird, the trampoline is now creating a stack overflow: it isn't actually trampolining.

Hang on. I know how this works. _iterate_ returns a trampoline not a value until the last iteration when it returns a value so the version with the extra () must be wrong. Perhaps this is a case where the only type has to be Object.
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy 2.2.2 regression in the typechecker's handling of generics,GROOVY-6601,12817374,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,26/Feb/14 23:52,08/May/14 18:17,14/Jul/23 06:01,07/May/14 03:45,2.2.2,,,,,,,,,,,,,,,,,2.3.0,,,,Static Type Checker,,,,0,,,,,,,"The following code compiles under Groovy 2.2.1, but not under 2.2.2

{code}
@groovy.transform.CompileStatic
public class Test<T> {
    public Test(Class<T> p1) { }

    static <X> Test<X> create(Class<X> c) { new Test<X>(c) }
}
{code}

Works in both if we strip the generics at the call site:
{code}
package unlogger.dsl.core

@groovy.transform.TypeChecked
public class Test<T> {
    public Test(Class<T> p1) { }

    static <X> Test<X> create(Class<X> c) { new Test<X>(c as Class) }
}
{code}",,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-02-26 23:52:16.0,,,,,,,,,,"0|i2bypz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyClassLoader.addClasspath should respect URI paths and not use URL.equals,GROOVY-6597,12817373,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jimwhite,jimwhite,jimwhite,26/Feb/14 03:34,09/Apr/14 18:40,14/Jul/23 06:01,06/Apr/14 10:23,1.8.9,2.2.1,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,,,,,0,,,,,,,"GroovyClassLoader.addClasspath has two kinds of problems with URLs.  

For one thing it uses URL.equals to avoid adding duplicate paths to the classpath.  That is very bad since it is a blocking operation that performs domain name resolution. 

The second thing is that even though it is a URLClassLoader it doesn't add paths that are URIs/URLs as URLs but instead always makes a file: path.

The solution for both is to use URI for making and comparing paths before adding them with addURL(URL).",,jimwhite,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Apr 06 10:22:54 UTC 2014,,,,,,,,,,"0|i2cd0v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Feb/14 03:36;jimwhite;While handling URLs in the classpath is not really worthwhile for pre-2.3.0 Groovy, I think eliminating the use of URL.equals should probably be done for earlier versions as a bug fix.
;;;","26/Feb/14 03:38;jimwhite;Patch added to PR #337.  This almost deserves it's own pull, but my codebase and the test code currently rely on the other stuff in #337.
;;;","06/Apr/14 01:21;paulk;So Jim, was this resolved with PR#337 or is their more work to do? From the description above and the code in the PR, I think we are all good - just double checking with you.;;;","06/Apr/14 10:22;jimwhite;Yeah, looks like it was done then.  I think there are quite a few more issues with URIs in the compiler, but I'm ignoring them for now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
New template engine: MarkupTemplateEngine with optional type checking,GROOVY-6596,12817401,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,26/Feb/14 02:42,05/Apr/14 00:01,14/Jul/23 06:01,05/Mar/14 15:12,,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,Templating,,,,0,,,,,,,"Add a new template engine implementation with static compilation of templates and optional type checking of the model.

See http://melix.github.io/blog/2014/02/markuptemplateengine.html
And http://melix.github.io/blog/2014/02/markuptemplateengine_part2.html

for details.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 05 15:12:50 UTC 2014,,,,,,,,,,"0|i2cabr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Mar/14 15:12;melix;Merged.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Operators other than dot do not support carriage returns,GROOVY-6593,12817315,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,antoine_,antoine_,20/Feb/14 08:58,05/Apr/14 00:00,14/Jul/23 06:01,05/Mar/14 04:39,,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,syntax,,,,0,,,,,,,"In Groovy, you can add carriage returns before the dot operator. For instance:
{code:borderStyle=solid}
doSomething()
    .somethingElse()
    .collect { ... }
{code}

But with the safe navigation operator or the spread operator, it does not work.
{code:borderStyle=solid}
doSomething()
    ?.somethingElse() // does not compile, ""unexpected token ?.""
    ?.collect { ... }
{code}

{code:borderStyle=solid}
doSomething()
    *.somethingElse() // does not compile, ""unexpected token *.""
    .collect { ... }
{code}",,antoine_,paulk,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 06 20:56:52 UTC 2014,,,,,,,,,,"0|i2bsjz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Feb/14 14:09;tim_yates;Added PR: https://github.com/groovy/groovy-core/pull/332

Could do with checking;;;","05/Mar/14 04:39;paulk;Merged into master (for 2.3.0+). Thanks!;;;","05/Mar/14 05:47;paulk;I just extended the grammar change slightly to also cover the conditional and elvis operators.;;;","05/Mar/14 07:38;tim_yates;I thought conditionals were already covered?;;;","06/Mar/14 05:51;paulk;Conditionals already supported newlines in numerous places but not previously before the question mark. Ditto for Elvis. ;;;","06/Mar/14 05:59;tim_yates;You're right of course.

I was thinking of GROOVY-3401 but I specifically commented that the bit you fixed wasn't fixed by my patch

Sorry about that Paul

(btw, you also just fixed GROOVY-4464 I think!) ;-);;;","06/Mar/14 06:40;paulk;I think you are right about GROOVY-4464. I'll resolve that one too.;;;","06/Mar/14 20:56;paulk;This also resolves GROOVY-5159, so I'll mark that as a duplicate.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
field on primitive not recognized even if existing in wrapper type,GROOVY-6590,12817304,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,blackdrag,blackdrag,20/Feb/14 04:49,23/Feb/15 01:12,14/Jul/23 06:01,14/Jan/15 06:53,2.2.1,2.4.0-rc-1,,,,,,,,,,,,,,,,2.4.1,,,,Static Type Checker,,,,0,,,,,,,"The most simple case of this is when compiling 1.MAX_VALUE. The compiler recognizes 1 as int, but fails to see that MAX_VALUE is defined on Integer. Other version are {code:Java}int i=1; i.MAX_VALUE{code} and {code:Java}def i=""d""; i=1; i.MAX_VALUE{code}",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6351,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-02-20 04:49:22.0,,,,,,,,,,"0|i2ch6f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Read vs Write to members of base script supplied by @BaseScript is inconsistent,GROOVY-6586,12817378,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,jimwhite,jimwhite,17/Feb/14 22:44,03/Feb/22 22:32,14/Jul/23 06:01,05/Oct/21 22:24,2.2.1,,,,,,,,,,,,,,,,,4.0.0-beta-2,,,,,,,,0,,,,,,,"The base script class supplied by the @BaseScript annotation is documented as being able to offer access to member fields to the script code.  But this only works for reading.  If an attempt to write one of those fields is made then a script binding is created.

A workaround is to use getters and setters rather than accessing the field directly.
",,emilles,jimwhite,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/Feb/14 00:13;jimwhite;BaseScriptTransformationTest.groovy;https://issues.apache.org/jira/secure/attachment/12722198/BaseScriptTransformationTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 05 20:59:52 UTC 2021,,,,,,,,,,"0|i2cmlj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"18/Feb/14 12:38;jimwhite;The relationship between bindings (variables) and properties in scripts is very confusing.  Several areas need reviewing and should definitely be addressed for Groovy 3.0 and there may indeed be outright bugs which need fixing in 2.3.x.  I will use this issue to collect the bits of information as I find them.

Exhibit 1:

Script.getProperty and setProperty are asymmetric wrt 'binding' and 'metaClass' in order to keep from storing them in bindings when set.  But as we see from the behavior that opened this issue, that is happening to other properties.

Exhibit 2:

org.codehaus.groovy.runtime.ScriptReference bypasses Script.getProperty and setProperty and instead only works on the binding variables.  That is similar to what Script.invokeMethod is/was doing (see GROOVY-6582).

Exhibit 3:

Expando is a class like Script which also has dynamic properties and interacts with the MOP.  These two classes should be consistent in their behavior.;;;","02/Sep/14 15:25;jimwhite;Time to get this done. ;;;","05/Oct/21 20:59;emilles;{{groovy.lang.Script.setProperty(String,Object)}} was updated to check for setter before adding to binding.  This check is failing to find the setter in case of BaseClass application due to difference between {{getClass().getDeclaredMethods()}} and {{getClass().getMethods()}}.

See GROOVY-9554;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot use memoize() to cache metaclass method call,GROOVY-6584,12817372,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,armsargis,armsargis,17/Feb/14 06:21,01/Feb/17 23:18,14/Jul/23 06:01,07/Oct/16 04:03,2.2.1,,,,,,,,,,,,,,,,,2.4.8,,,,groovy-runtime,,,,1,,,,,,,"Hi I want to extend my list with new method and cache the result because actually it will query db but I am getting 'java.lang.UnsupportedOperationException', I reproduced it for simple case also using groovy console

{code}
def lst = []
lst.metaClass.getTotalCount = {
    println "">>>>>>>>>> 12 <<<<<<<<<<""
    12 // can be some select count(*) from xxx
}.memoize()

println lst.getTotalCount()
println lst.getTotalCount()
{code}

I am getting

{noformat}

java.lang.UnsupportedOperationException: org.codehaus.groovy.runtime.metaclass.ClosureMetaMethod$AnonymousMetaMethod
	at ConsoleScript10.run(ConsoleScript10:2)

{noformat}",,armsargis,farrellm,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 07 04:03:24 UTC 2016,,,,,,,,,,"0|i2clp3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Feb/14 08:58;armsargis;Probably for org.codehaus.groovy.runtime.metaclass.ClosureMetaMethod.AnonymousMetaMethod can be added:

{code}
        @Override
        protected Class[] getPT() {
            return closure.getParameterTypes();
        }
{code}

to solve this issue?;;;","02/Oct/16 20:01;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/434

    GROOVY-6584: Cannot use memoize() to cache metaclass method call

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-6584

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/434.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #434
    
----
commit 7d651b5c5bc119fdf687dd49eb78dbe7c146a5db
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-10-02T19:23:16Z

    GROOVY-6584: Cannot use memoize() to cache metaclass method call

----
;;;","07/Oct/16 04:02;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/434
;;;","07/Oct/16 04:03;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Script.invokeMethod bypasses getProperty when looking for closure-valued properties.,GROOVY-6582,12817303,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jimwhite,jimwhite,jimwhite,16/Feb/14 14:28,15/Oct/15 18:19,14/Jul/23 06:01,07/Mar/14 05:14,1.8.9,2.2.1,,,,,,,,,,,,,,,,2.2.3,2.3.0-beta-1,,,,,,,0,,,,,,,"The implementation of Script.invokeMethod calls binding.getVariable(name) rather than getProperty(name) when checking to see if there is a property with that name that has a value that implements Closure.  This is significantly bugged because if Script is subclassed (such as when using the @BaseScript annotation) and getProperty is overridden to supply Closure values then they are seen as property values as variables but not as functions.

Fixing this by having Script.invokeMethod call getProperty rather than binding.getVariable will make the behavior consistent with Expando.invokeMethod.  See also GROOVY-6586 where I'm assembling information on the big picture so that we can eventually have a logically consistent (and documented) system for these class-like dynamic properties in Groovy.",,blackdrag,jimwhite,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 07 05:14:34 UTC 2014,,,,,,,,,,"0|i2c5lr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Feb/14 15:22;jimwhite;Issued pull request #326 with a fix.  

https://github.com/groovy/groovy-core/pull/326;;;","17/Feb/14 02:14;blackdrag;First of all, you are right. I guess it was not important so far. But I am wondering if this qualifies as a breaking change. If yes, then it should go only to 2.3.0. But regardless of it being such a breaking change or not I think the change is too much for 1.8.10;;;","17/Feb/14 08:19;jimwhite;Breaking change?!?!  Please describe the scenario in which this borked code's behavior is not surprising.  Should we randomly choose some of the other methods in Script that get property values like ""print"" and such to also bypass getProperty?;;;","17/Feb/14 08:48;blackdrag;Jim, when I say breaking, then I mean that users can depend on the false behavior and after the change their code would break. Or do you think that is unlikely/impossible?;;;","17/Feb/14 11:45;jimwhite;I think it is basically impossible.  Anyone who found this behavior would know it is a bug (it wouldn't have stood any code review either but we lack such a process here).  So either no one has seen it or they did and simply worked around it (such as by implementing the property in Binding which will work either way) and didn't report it.

Oh, there's another workaround (the one I will be using) which is to override invokeMethod so that the MissingProperty -> check -> MissingMethod logic gets run twice.  Quite annoying.

There is change in behavior for a particular failure scenario.  If getProperty is overridden in a Script subclass and it handles MissingPropertyException by doing an invokeMethod on the property name then now it will fail by blowing the stack rather MissingMethodException.  I think the new behavior is correct (and either one terminates the script in any ordinary circumstance).;;;","17/Feb/14 11:48;jimwhite;And yes, all bug fixes will break code that depends on the bugged behavior and yet we still produce bug fix releases.  So what is the point of the 1.8.x releases?  ;;;","07/Mar/14 05:14;paulk;Pull request applied and merged to legacy branches. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
InnerClassCompletionVisitor does not overwrite existing propertyMissing/methodMissing impls completely,GROOVY-6580,12818279,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,asteingress,andre.steingress,andre.steingress,16/Feb/14 12:50,04/Mar/14 16:31,14/Jul/23 06:01,19/Feb/14 03:48,2.2.1,,,,,,,,,,,,,,,,,2.2.2,2.3.0-beta-1,,,class generator,,,,0,,,,,,,"{{InnerClassCompletionVisitor}} adds {{methodMissing}} and {{propertyMissing}} impls to static inner classes. 

{code}
    public java.lang.Object methodMissing(java.lang.String name, java.lang.Object args) {
        return Container.""$name""(* args )
    }

    public void propertyMissing(java.lang.String name, java.lang.Object val) {
        Container.""$name"" = val 
    }

    public java.lang.Object propertyMissing(java.lang.String name) {
        return Container.""$name""
    }
{code}

The issue is, whenever one of these is defined by the user {{InnerClassCompletionVisitor}} takes the already existing {{MethodNode}} and replaces its method block.

This leads to errors if the custom impl has chosen other parameter names as the {{InnerClassCompletionVisitor}} code expects:

{code}
class A {

  static class B {
  
      def propertyMissing(String name, Object myValue) {
          return value
      }
  }
}

def b = new A.B()
b.a = 'test' // groovy.lang.MissingFieldException: No such field: val for class: A
{code}

The {{MissingFieldException}} is thrown because there is no parameter named {{val}} in the user-defined method interface of {{propertyMissing}}.",,andre.steingress,keegan,stolsvik,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 19 03:48:49 UTC 2014,,,,,,,,,,"0|i2c75j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Feb/14 15:21;andre.steingress;The {{MissingFieldException}} can be fixed be rewriting the parameters in the MethodNode. But as the user implementation is rewritten by the ICCV anyway, it doesn't make sense to have {{methodMissing}}/{{propertyMissing}} implementations in static inner classes. 

There are some possibilities on how to handle this situation: 1) compiler error (which differs from the current behaviour of silently rewriting the method) 2) rewrite parameters and compiler warning 3) don't use  {{methodMissing}}/{{propertyMissing}} for delegation to the outer class and rewrite the mechanism, but that would be part of GROOVY-6581.;;;","16/Feb/14 16:31;stolsvik;Ah - I just commented on GROOVY-6581, where I argue that the only proper fix is #3.;;;","17/Feb/14 13:41;andre.steingress;Here is the pull request: https://github.com/groovy/groovy-core/pull/327;;;","19/Feb/14 03:48;andre.steingress;Fixed by showing an error message for static inner classes that implement either {{propertyMissing}} or {{methodMissing}} themselves.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
misleading error message for boolean assignment,GROOVY-6577,12817386,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,blackdrag,blackdrag,14/Feb/14 09:39,05/Apr/14 00:00,14/Jul/23 06:01,17/Feb/14 06:05,,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,Static Type Checker,,,,0,,,,,,,"The static compiler does not allow the assignment of literal null to a variable of type boolean. The compiler complains with this message: ""Cannot assign value of type java.lang.Object to variable of type boolean""

I consider this message being misleading since it is very well allowed to assign a value of type Object to a boolean,because it will be transformed using Groovy truth. According to that null will be transformed to false.

So either the message should be improved or the check removed for the boolean case",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-02-14 09:39:21.0,,,,,,,,,,"0|i2co13:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
list literal constructor misses direct constructor call,GROOVY-6576,12817363,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,blackdrag,blackdrag,14/Feb/14 09:16,04/Mar/14 16:31,14/Jul/23 06:01,17/Feb/14 09:49,,,,,,,,,,,,,,,,,,2.2.2,2.3.0-beta-1,,,Static compilation,,,,0,,,,,,,"In this example{code:Java}
class F {
    F(int i){}
}

def foo() {
  F f = [1]
}
{code}
The static compiler produces a call to castToType to let the runtime transform [1] into F. Because of performance this should not be done.",,blackdrag,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 17 09:49:24 UTC 2014,,,,,,,,,,"0|i2cs9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Feb/14 09:49;melix;Also optimized the case for arrays:

{code}
int[] foo = [1,3,5]
{code}

won't involve a dynamic call anymore.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missing type checks for assignment to array,GROOVY-6575,12817385,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,blackdrag,blackdrag,14/Feb/14 09:09,15/Oct/15 18:19,14/Jul/23 06:01,17/Feb/14 04:22,,,,,,,,,,,,,,,,,,2.2.2,,,,Static Type Checker,,,,0,,,,,,,"In this code {code:Java}
def foo(Object o) {
  int[] i = o
}
{code}

The static compiler won't perform any type checks",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-02-14 09:09:35.0,,,,,,,,,,"0|i2bqrb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
boolean local variable is compiled as Boolean,GROOVY-6574,12817322,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,14/Feb/14 08:51,15/Oct/15 18:19,14/Jul/23 06:01,15/Dec/14 04:11,,,,,,,,,,,,,,,,,,2.2.2,,,,class generator,,,,0,,,,,,,"the following code uses internally a Boolean instead of a boolean for the local variable. Since a boolean cannot hold null, this is an important difference. Slightly modified code seems to not have the problem. {code:Java}
def foo(Boolean o) {
  boolean b = o
  println b
}{code}",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 15 04:11:56 UTC 2014,,,,,,,,,,"0|i2c3gv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Dec/14 04:11;blackdrag;corrected fix version;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TailRecursive creates compilation error,GROOVY-6573,12816854,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,russel,russel,14/Feb/14 06:07,05/Apr/14 00:01,14/Jul/23 06:01,16/Feb/14 10:15,,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,,,,,0,,,,,,,"The code:
{code}
@TailRecursive
  private static BigInteger iterate(final BigInteger i, final BigInteger a, final BigInteger b) {
    i < 1 ? a : iterate(i - 1, b, a + b)
  }
{code}
compiles and works fine with the @TailRecursive commented out. With it in place:
{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
file:/home/users/russel/Progs/Applications/Fibonacci/Groovy/Fibonacci.groovy: 43: Apparent variable '__b__' was found in a static scope but doesn't refer to a local variable, static field or class. Possible causes:
You attempted to reference a variable in the binding or an instance variable from a static context.
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method '__b__' but left out brackets in a place not allowed by the grammar.
 @ line 43, column 32.
       i < 1 ? a : iterate(i - 1, b, a + b)
                                  ^

1 error
{code}","Debian Sid (aka Unstable), Groovy master 48b650edd3473cdcfe8b1f11667f005bd2bbaf92 using indy artefacts.",johanneslink,melix,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Feb 16 15:05:11 UTC 2014,,,,,,,,,,"0|i2cp8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Feb/14 09:11;johanneslink;I'll take over. Will open a pull request 2day or this weekend.;;;","14/Feb/14 10:01;johanneslink;Just submitted the pull request.;;;","16/Feb/14 10:15;melix;Merged #325, thanks!;;;","16/Feb/14 15:05;russel;Works a treat. Thanks to Johannes for fast turnaround, much appreciated.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError with implicit call() on closure field with @CompileStatic,GROOVY-6568,12818284,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,12/Feb/14 11:23,15/Oct/15 18:20,14/Jul/23 06:01,12/Feb/14 12:12,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,Static compilation,,,,0,,,,,,,"The following test case illustrates the issue, which only occurs if there are more than one argument to the call:

{code}
package org.codehaus.groovy.classgen.asm.sc.bugs

import groovy.transform.stc.StaticTypeCheckingTestCase
import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport

@Mixin(StaticCompilationTestSupport)
class GroovyVerifyErrorBug extends StaticTypeCheckingTestCase {

    @Override
    protected void setUp() {
        super.setUp()
        extraSetup()
    }

    void testShouldNotThrowVerifyErrorIfUsingImplicitCall() {
        assertScript '''
class Foo {
    Closure isUpper = { String it, String up -> it.toUpperCase() == up }

    def test(String str) {
        isUpper(str, 'ABC') // replace with isUpper.call(str,'ABC') and no error
    }
}
def foo = new Foo()
assert foo.test('abc')
'''
    }
}

{code}

Using {{.call}} doesn't throw any {{VerifyError}}.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-02-12 11:23:38.0,,,,,,,,,,"0|i2cne7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BUG! exception in phase 'class generation' in source unit 'ideaGroovyConsole.groovy' Error while popping argument from operand stack tracker in class Test method void <init>(),GROOVY-6566,12818285,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,bsideup,bsideup,10/Feb/14 06:06,04/Mar/14 16:31,14/Jul/23 06:01,10/Feb/14 08:54,2.2.0,,,,,,,,,,,,,,,,,,,,,Static compilation,,,,0,,,,,,," @groovy.transform.CompileStatic
class Test {
    Test() {
        Map<String, Integer> test = [a : 0, b : 5];
        test[""b""]--;
    }
}


new Test()
BUG! exception in phase 'class generation' in source unit 'ideaGroovyConsole.groovy' Error while popping argument from operand stack tracker in class Test method void <init>().
	at org.codehaus.groovy.classgen.asm.OperandStack.popWithMessage(OperandStack.java:74)
	at org.codehaus.groovy.classgen.asm.OperandStack.remove(OperandStack.java:215)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeDirectMethodCall(StaticInvocationWriter.java:187)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeDirectCall(InvocationWriter.java:243)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:342)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:89)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.makeCall(StaticInvocationWriter.java:498)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:73)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:412)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeInvokeMethod(StaticInvocationWriter.java:87)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:686)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.loadWithSubscript(BinaryExpressionHelper.java:680)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluatePostfixMethod(BinaryExpressionHelper.java:602)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluatePostfixMethod(BinaryExpressionHelper.java:628)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitPostfixExpression(AsmClassGenerator.java:570)
	at org.codehaus.groovy.ast.expr.PostfixExpression.visit(PostfixExpression.java:43)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:547)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:493)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:357)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:314)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:119)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructor(AsmClassGenerator.java:429)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1051)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:177)
	at org.codehaus.groovy.control.CompilationUnit$15.call(CompilationUnit.java:794)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:279)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:258)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)
	at groovy.lang.GroovyShell.run(GroovyShell.java:480)
	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:231)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:64)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
	at console.run(console.txt:25)",,bsideup,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 10 08:54:16 UTC 2014,,,,,,,,,,"0|i2c2yv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Feb/14 08:54;melix;I checked with {{2.2.2-SNAPSHOT}} and {{master}} and I can't reproduce so I assume it's fixed already.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker fails to infer a generic type without an intermediate variable definition,GROOVY-6564,12818303,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,10/Feb/14 04:03,04/Mar/14 16:31,14/Jul/23 06:01,11/Feb/14 05:06,,,,,,,,,,,,,,,,,,2.2.2,,,,,,,,0,,,,,,,"On {{master}}, the following code fails:

{code}
import groovy.transform.CompileStatic
import groovy.transform.Field

class Stream<T> implements Iterable<T> {
    public static Stream<String> from(BufferedReader reader) { new Stream(data:['a','b','c']) }
    
    List<T> data
    
    public Iterator<T> iterator() { data.iterator() }
    
    public <U> Stream<U> flatMap(Closure<? extends Collection<U>> closure) { new Stream(data:data.collect(closure)) }
}
 
@CompileStatic
def test() {
    Map<String,Integer> frequencies = [:].withDefault { 0 }
    BufferedReader r = null
    Stream.from(r)
        .flatMap { String it -> it.toList() }
        .each { String it -> frequencies[it]++ } // to test: .each { frequencies[it]++ }
}
 
test()
{code}

Curiously, adding an intermediate variable makes this pass:

{code}
import groovy.transform.CompileStatic
import groovy.transform.Field

class Stream<T> implements Iterable<T> {
    public static Stream<String> from(BufferedReader reader) { new Stream(data:['a','b','c']) }
    
    List<T> data
    
    public Iterator<T> iterator() { data.iterator() }
    
    public <U> Stream<U> flatMap(Closure<? extends Collection<U>> closure) { new Stream(data:data.collect(closure)) }
}
 
@CompileStatic
def test() {
    Map<String,Integer> frequencies = [:].withDefault { 0 }
    BufferedReader r = null
    Stream<String> stream = Stream.from(r)
        .flatMap { String it -> it.toList() }
    stream.each { String it -> frequencies[it]++ } // to test: .each { frequencies[it]++ }
}
 
test()
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-02-10 04:03:59.0,,,,,,,,,,"0|i2clnb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Implementation for running a script from a URL in GroovyMain is flawed.,GROOVY-6561,12817384,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jimwhite,jimwhite,jimwhite,09/Feb/14 03:39,06/Apr/14 05:26,14/Jul/23 06:01,06/Apr/14 05:26,1.8.9,2.2.1,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,command line processing,,,,0,,,,,,,"There are two significant problems with the way handling of URLs as scripts are implemented in GroovyMain.  I put them both here since I think any relevant changes will be done together.

The first (and simplest to fix) is a buggy URL checker (GroovyMain.isScriptUrl(String urlOrFilename)) that has a hardcoded (and case-sensitive?) list of URI schemes that it tests for (http, https, file, and jar).  This checking should be done by URI's parser and support any scheme that the platform implements.

The second and more substantial issue is that when a script source is specified by URL a correct URL-based SourceUnit does not get used for compilation.  Instead the text is simply grabbed from the URL and parsed as a string.  This is inconsistent with the way URL-sourced code is handled everywhere else.  

This is loosely connected to the long-standing GROOVY-1642 issue and also needs fixing so that GROOVY-6451 can work as intended.",,blackdrag,jimwhite,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Apr 06 05:25:20 UTC 2014,,,,,,,,,,"0|i2bqxz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Feb/14 03:18;blackdrag;I agree the about the first part, the code afaik predates URI and needs an update.

As for the second one... I guess the text is grabbed, because GroovyShell doesn't support URL sources. The compiler internally does, but afaik also not before 2.x. So a fix would have either to bypass GroovyShell or GroovyShell would need extensions;;;","24/Feb/14 10:14;jimwhite;GroovyShell does support GroovyCodeSource which does support URL.  I'd be inclined to add an evaluate(URI) to GroovyShell (for GroovyMain and other folks to do the right thing by using URI over URL) which is a little wrapper using GroovyCodeSource.
;;;","24/Feb/14 18:55;jimwhite;PR #337 has a fix for this and GROOVY-1642.;;;","06/Apr/14 05:25;pschumacher;Pull request was merged by Paul.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonOutput does not escape URL (windows path),GROOVY-6560,12817290,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,bura,bura,07/Feb/14 09:03,15/Oct/15 18:19,14/Jul/23 06:01,07/Feb/14 09:56,,,,,,,,,,,,,,,,,,2.2.2,2.3.0-beta-1,,,JSON,,,,0,,,,,,,"URL may contains '\' char and in this case url also must escaped.

To reproduce bug:

{code}
assert JsonOutput.toJson(new URL('file', '', 'C:\\this\\is\\windows\\path')) == '""file:C:\\\\this\\\\is\\\\windows\\\\path""'
{code}

{code}
Assertion failed: 

assert JsonOutput.toJson(new URL('file', '', 'C:\\this\\is\\windows\\path')) == '""file:C:\\\\this\\\\is\\\\windows\\\\path""'
                  |      |                                                   |
                  |      file:C:\this\is\windows\path                        false
                  ""file:C:\this\is\windows\path""
{code}
",,bura,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 07 09:56:13 UTC 2014,,,,,,,,,,"0|i2cgjz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Feb/14 09:21;bura;Fixed, pull request: https://github.com/groovy/groovy-core/pull/320;;;","07/Feb/14 09:56;guillaume;Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonOutput does not escape single char (char/Character),GROOVY-6559,12817353,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,bura,bura,07/Feb/14 04:23,15/Oct/15 18:19,14/Jul/23 06:01,07/Feb/14 06:58,,,,,,,,,,,,,,,,,,2.2.2,2.3.0-beta-1,,,JSON,,,,0,,,,,,,"To reproduce bug:

{code}
assert JsonOutput.toJson('""') == '""\\""""'
assert JsonOutput.toJson('""' as char) == '""\\""""'
{code}

{code}
Assertion failed:

assert JsonOutput.toJson('""' as char) == '""\\""""'
                  |                   |
                  """"""                 false
{code}",,bura,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 07 06:58:33 UTC 2014,,,,,,,,,,"0|i2c17b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Feb/14 04:24;bura;PR + tests coming soon;;;","07/Feb/14 05:55;bura;Fixed, pull request: https://github.com/groovy/groovy-core/pull/319;;;","07/Feb/14 06:58;guillaume;Thanks for spotting this!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
incrementing a Static Compiled Map with default Integer value won't compile,GROOVY-6558,12818280,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,06/Feb/14 11:00,15/Oct/15 18:20,14/Jul/23 06:01,07/Feb/14 04:39,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,Static compilation,,,,0,,,,,,,"The following code:

{code}
import groovy.transform.CompileStatic

@CompileStatic
def test() {
    Map<String,Integer> frequencies = [:].withDefault { 0 }
    frequencies[ 'a' ]++
    frequencies
}

test()
{code}

Causes a BUG exception:

{code}
BUG! exception in phase 'class generation' in source unit 'ConsoleScript75' Error while popping argument from operand stack tracker in class ConsoleScript75 method java.lang.Object test().
	at org.codehaus.groovy.classgen.asm.OperandStack.popWithMessage(OperandStack.java:74)
	at org.codehaus.groovy.classgen.asm.OperandStack.remove(OperandStack.java:215)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeDirectMethodCall(StaticInvocationWriter.java:187)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeDirectCall(InvocationWriter.java:243)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:342)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:89)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.makeCall(StaticInvocationWriter.java:498)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:73)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:412)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeInvokeMethod(StaticInvocationWriter.java:87)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:686)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.loadWithSubscript(BinaryExpressionHelper.java:680)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluatePostfixMethod(BinaryExpressionHelper.java:602)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluatePostfixMethod(BinaryExpressionHelper.java:625)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitPostfixExpression(AsmClassGenerator.java:570)
	at org.codehaus.groovy.ast.expr.PostfixExpression.visit(PostfixExpression.java:43)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:547)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:493)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:357)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:314)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:434)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:177)
	at org.codehaus.groovy.control.CompilationUnit$15.call(CompilationUnit.java:794)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:279)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:258)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)
	at groovy.lang.GroovyShell.run(GroovyShell.java:480)
	at groovy.lang.GroovyShell.run(GroovyShell.java:163)
	at groovy.lang.GroovyShell$run$1.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:977)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor307.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure.call(Closure.java:417)
	at groovy.lang.Closure.run(Closure.java:504)
	at java.lang.Thread.run(Thread.java:744)
{code}

(stacktrace from Groovy 2.2.1, but also fails similarly with todays 2.3.0 from the master branch)

{code}
    frequencies[ 'a' ] += 1
{code}

Also fails in a similar fashion

However,

{code}
    frequencies[ 'a' ]  = frequencies[ 'a' ] + 1
{code}

works fine",,melix,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 07 02:24:59 UTC 2014,,,,,,,,,,"0|i2cem7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Feb/14 02:24;melix;As far as I can tell, the test fails without {{.withDefault}} too.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE on TypeResolver using anonymous inner class and the jdk7 compiler,GROOVY-6556,12818281,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,davide.cavestro,davide.cavestro,06/Feb/14 04:57,28/Dec/14 05:36,14/Jul/23 06:01,28/Dec/14 05:36,2.2.1,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Compiler,,,,1,,,,,,,"I systematically obtain a _NullPointerException_ running some code compiled with the jdk1.7.0_51 (Oracle).

Here is an excerpt from the minimal project I've attached at [^project.zip]
{code:title=AbstractFoo.groovy}
package acme

abstract class AbstractFoo<T,M> implements Foo<T,M> {
    public Foo<T,M> bind (Bar bar, Closure c) {
        bind (bar, new Foo<T,M>() {
                T foo(Bar innerBar, M model) {
                    c.call (innerBar)
                }
        })//FAILS
		
//		bind (bar, [doIt: {}] as Foo) //WORKS
    }
    public abstract AbstractFoo<T,M> bind (Bar bar, Foo<T,M> delegate)
}
{code}

h5. Additional info
# Replacing the anonymous inner class with a map-based interface implementation it works.
# Using the jdk6 to compile and run the code it works.
# Compiling the code from Eclipse (using its compiler) then it works.

This is the error stacktrace
{quote}
java.lang.NullPointerException
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:203)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:218)
	at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:96)
	at java.beans.FeatureDescriptor.getParameterTypes(FeatureDescriptor.java:387)
	at java.beans.MethodDescriptor.setMethod(MethodDescriptor.java:114)
	at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:72)
	at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:56)
	at java.beans.Introspector.getTargetMethodInfo(Introspector.java:1149)
	at java.beans.Introspector.getBeanInfo(Introspector.java:416)
	at java.beans.Introspector.getBeanInfo(Introspector.java:163)
	at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:3065)
	at java.security.AccessController.doPrivileged(Native Method)
	at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:3063)
	at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:3046)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:176)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:192)
	at acme.AbstractFoo$1.$getStaticMetaClass(AbstractFoo.groovy)
	at acme.AbstractFoo$1.<init>(AbstractFoo.groovy)
	at acme.AbstractFoo.bind(AbstractFoo.groovy:5)
	at acme.AbstractFoo$bind.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
	at acme.FooTest.doIt(FooTest.groovy:11)
{quote}

The attached archive [^project.zip] is both a gradle and an eclipse project demonstrating the issue. I've produced it from scratch in order to closely reflect my real world scenario while limiting it to a bunch of classes and interfaces. However if you want I can probably further reduce it. 
BTW running {{FooTest.groovy}} from eclipse works fine, while from gradle (using jdk7) or from CLI it fails. As I said above also replacing the anonymous inner class with the map make the test work even with the jdk compiler.

This issue could be related to GROOVY-6088, however I preferred to file it separately.",Groovy Version: 2.2.1 JVM: 1.7.0_51 Vendor: Oracle Corporation OS: Linux,davide.cavestro,lhotari,mauromol,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/Feb/14 04:57;davide.cavestro;project.zip;https://issues.apache.org/jira/secure/attachment/12723096/project.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 05:36:09 UTC 2014,,,,,,,,,,"0|i2boev:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Mar/14 06:00;lhotari;workaround in Grails core possibly related to this bug:
https://github.com/grails/grails-core/commit/717b7b44;;;","22/Mar/14 06:02;lhotari;googling with the stacktrace brings up this blog article: http://blog.andresteingress.com/2012/10/11/groovy-quickie-ast-transformations-and-typeresolver-nps/;;;","28/Dec/14 05:36;pschumacher;Thanks for reporting. Your example works for me with groovy 2.4.0-rc-1 and jdk 1.7.0_72.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic runtime failure (GroovyCastException) with anonymous inner classes where method parameter is referenced in anonymous inner class implementation,GROOVY-6552,12817343,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lhotari,lhotari,04/Feb/14 03:51,15/Oct/15 18:20,14/Jul/23 06:01,04/Feb/14 08:36,2.1.9,2.2.1,,,,,,,,,,,,,,,,2.2.2,,,,Static compilation,,,,0,,,,,,,"Code compiled with CompileStatic fails at runtime (GroovyCastException) with anonymous inner classes where method parameter is referenced in anonymous inner class implementation.

{code}
@CompileStatic
class MyJunitAdapter {
    public TestRule newClassRule(final Class testClass) {
        return new TestRule() {
            Statement apply(Statement statement, Description description) {
                return new Statement() {
                    public void evaluate() throws Throwable {
                        println testClass.getName()
                        println ""in class rule - before""
                        statement.evaluate()                    
                        println ""in class rule - after""
                    }
                }
            }
        }
    }
}
{code}

Here is the full GroovyConsole script to reproduce the problem:
https://gist.github.com/lhotari/29a5d863252d18637765

You can comment out the @CompileStatic line to see what the expected output is.

The stacktrace contains this error message
{code}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'class MyTest' with class 'java.lang.Class' to class 'groovy.lang.Reference'
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:371)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:599)
{code}",,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 04 06:26:41 UTC 2014,,,,,,,,,,"0|i2c69b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Feb/14 04:11;lhotari;Might be related to issues: GROOVY-5101 GROOVY-5045 ;;;","04/Feb/14 06:26;melix;Simplified the test case by using nested anonymous inner classes. The following code produces the error when compiled statically:

{code}
import java.util.concurrent.Callable

String text(Class clazz) {
    new Callable<String>() {
        @Override
        String call() throws Exception {
            new Callable<String>() {

                @Override
                String call() throws Exception {
                    clazz.getName()
                }
            }.call()
        }
    }.call()
}

assert text(String) == 'java.lang.String'
{code}

;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError when instantiating class that has Java 8 default method in its ancestry,GROOVY-6550,12817284,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mpierce,mpierce,03/Feb/14 10:09,05/Apr/14 00:00,14/Jul/23 06:01,04/Feb/14 10:12,1.8.9,2.0.8,2.1.9,2.2.1,,,,,,,,,,,,,,2.3.0-beta-1,,,,bytecode,,,,0,compiler,,,,,,"I've created a simple repro here: https://bitbucket.org/marshallpierce/java8-groovy-verifyerror 

The README has full details; I'll copy a trimmed version here.

It looks like every available groovy version (1.8.9, 2.0.8, 2.1.9, 2.2.1) all have issues with generating bytecode for classes that extend interfaces that have default method implementations (new in Java 8).

Under Java 7, `./gradlew clean build` succeeds. Under Java 8, it fails with a VerifyError:

{code}
java.lang.VerifyError: (class: org/mpierce/groovy/GroovySetSubclass, method: super$1$parallelStream signature: ()Ljava/util/stream/Stream;) Illegal use of nonvirtual function call
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:259)
	at org.mpierce.groovy.GroovySetSubclassTest.class$(GroovySetSubclassTest.groovy)
	at org.mpierce.groovy.GroovySetSubclassTest.$get$$class$org$mpierce$groovy$GroovySetSubclass(GroovySetSubclassTest.groovy)
	at org.mpierce.groovy.GroovySetSubclassTest.testGroovySubclass(GroovySetSubclassTest.groovy:9)
{code}

GroovySetSubclass is a trivial subclass of HashSet. Java analogs are ",JDK 8 M8 b127,melix,mpierce,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 04 10:10:10 UTC 2014,,,,,,,,,,"0|i2cduf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"04/Feb/14 09:07;melix;Thanks for the bug report. I have just checked with {{master}} (that is to say the upcoming 2.3 release) and there is no error. It is worth mentionning that the only version of Groovy which officially runs on JDK 8 will be Groovy 2.3.
;;;","04/Feb/14 09:54;mpierce;Hi Cedric,
Thanks for the clarification; that's great to hear that master works. I'll use that for my own projects. :)

I stumbled on this issue while trying to get Gradle to build under JDK8 so that I could fix a bug that only happened when using Gradle to build another project under JDK8. Gradle uses 1.8.6 at the moment; is the answer for Gradle simply that they'll have to upgrade to 2.3+?

Just to be clear, does this mean that to use Gradle as a build tool, it would need to be using 2.3 internally if the runtime is 8+?;;;","04/Feb/14 10:02;melix;There are two different things:

* compiling Groovy classes with a JDK 8 runtime. This requires 2.3+
* compiling Groovy classes with JDK<8 and using a JDK 8 runtime. In most of the cases, this would work.

So Gradle is basically in situation 2, where their own codebase is compiled using an earlier JDK so it should work. Now if you want to compile Groovy classes, using Gradle, and JDK 1.8+, then yes, you have to put an explicit dependency on Groovy 2.3 (putting an explicit dependency is something that I would do anyway).

Does that answer your question?
;;;","04/Feb/14 10:10;mpierce;Yes it does, thanks very much! Feel free to mark this 'wontfix' or whatever your convention is.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovysh: Import command is vulnerable and ugly,GROOVY-6548,12817310,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,tkruse,tkruse,02/Feb/14 08:05,05/Apr/14 00:00,14/Jul/23 06:01,05/Feb/14 02:21,,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,Groovysh,,,,0,,,,,,,"to reproduce:

groovy:000> import java.awt.TextField
===> [import java.awt.TextField]
groovy:000> import java.awt.TextField;
===> [import java.awt.TextField, import java.awt.TextField;]

should be just one time textfield

groovy:000> import java.awt.TextField; println('foo')
===> [import java.awt.TextField; println('foo')]
groovy:000> 2+2
foo
===> 4

should be prevented

Also the output of the list of imports is unnecessarily verbose, the ""import "" prefix does not add information, it just takes away screen space. Ideally this would even reduce package names to one letter, but this is bothersome to parse, given the variants of the import command",,melix,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 05 02:21:48 UTC 2014,,,,,,,,,,"0|i2co4v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Feb/14 08:08;tkruse;See https://github.com/groovy/groovy-core/pull/318;;;","05/Feb/14 02:21;melix;Merged, thank you!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
exception in phase 'class generation' using getAt(),GROOVY-6541,12817327,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,ataylor284,ataylor284,29/Jan/14 12:41,15/Oct/15 18:20,14/Jul/23 06:01,07/Feb/14 09:33,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,Static compilation,,,,0,,,,,,,"Compiling the testcase generates the following error message:

 BUG! exception in phase 'class generation' in source unit '/home/ataylor/dev/groovybug/testcase.groovy' At line 13 column 23

The test case:

{code}
    class Foo {
        String getAt(int i) {
            ""0""
        }
    }
    @groovy.transform.CompileStatic
    class Bar {
        def bug() {
            def foo = new Foo()
            def bar = [""bar""]

            for (i in 1..2) {
                bar[i] = foo[i]
            }
        }
    }
{code}","groovy 2.2.1, Oracle JVM: 1.7.0_51 on Linux",ataylor284,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 30 02:42:19 UTC 2014,,,,,,,,,,"0|i2bsuf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"30/Jan/14 02:42;guillaume;On the mailing-list, someone mentioned that using an Integer as index for the getAt signature makes things work, as a workaround till this problem is fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"parameter.metaClass returns different result when parameter type is ""Class<?> parameter"" compared to when type is ""Class parameter""",GROOVY-6533,12817267,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lhotari,lhotari,27/Jan/14 09:04,15/Oct/15 18:20,14/Jul/23 06:01,11/Feb/14 08:21,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,Static compilation,,,,0,,,,,,,"parameter.metaClass returns different result when parameter type is ""Class<?> parameter"" compared to when type is ""Class parameter""

Here is example code for Groovy console to reproduce the problem:
{code}
class ShowMcDynamic {
  MetaClass findMc(Class someClass) {
      someClass.metaClass
  }
  MetaClass findMcWithGenericsParam(Class<?> someClass) {
      someClass.metaClass
  }
}
def mcByDynamic = new ShowMcDynamic().findMc(String)
def mcByDynamic2 = new ShowMcDynamic().findMcWithGenericsParam(String)
assert mcByDynamic.theClass==String
assert mcByDynamic2.theClass==String

@groovy.transform.CompileStatic
class ShowMcStatic {
  MetaClass findMc(Class someClass) {
      someClass.metaClass
  }
  MetaClass findMcWithGenericsParam(Class<?> someClass) {
      someClass.metaClass
  }
}
def mcByStatic = new ShowMcStatic().findMc(String)
def mcByStatic2 = new ShowMcStatic().findMcWithGenericsParam(String)
assert mcByStatic.theClass==String
assert mcByStatic2.theClass==String
{code}",,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-01-27 09:04:15.0,,,,,,,,,,"0|i2c0fb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"indy has no fastpath  for div, previous and next",GROOVY-6531,12817305,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,22/Jan/14 09:50,15/Oct/15 18:19,14/Jul/23 06:01,22/Jan/14 09:52,2.0.8,2.2.1,,,,,,,,,,,,,,,,2.2.2,,,,groovy-runtime,,,,0,,,,,,,"Indy uses IndyMath to create a fast dispatch path for certain math operations. From there next and previous are completely missing though. Another case is div. For double it is save to use the native double division logic, like the static compiler and primopts do. This needs also to be added",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 22 09:52:15 UTC 2014,,,,,,,,,,"0|i2cdnz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jan/14 09:52;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
finally blocks do not always execute,GROOVY-6530,12816850,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,joedj,joedj,22/Jan/14 02:19,28/Dec/14 06:44,14/Jul/23 06:01,28/Dec/14 06:44,2.2.1,2.2.2,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,,,,,2,,,,,,,"finally blocks do not always run, e.g. when an exception is thrown from another nested finally block.  I can confirm this issue in at least 2.2.2, 2.2.1, 2.0.5 and 1.8
{code}
/tmp$ cat finally.groovy
count = 0

def outer() {
    try {
        inner()
    } catch (Exception e) {
        println 'count is: ' + count
    }
}

def inner() {
    try {
        try {
            count = 1
        } finally {
            count = 2
            throw new RuntimeException('barf')
        }
    } finally {
        count = 3
    }
}

outer()
/tmp$ groovy-2.2.2/bin/groovy finally.groovy
count is: 2
{code}
","Mavericks, JDK 1.7.0_12-ea",joedj,jwagenleitner,ngalarneau,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"07/Mar/14 02:22;joedj;finally.groovy;https://issues.apache.org/jira/secure/attachment/12723137/finally.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 06:44:36 UTC 2014,,,,,,,,,,"0|i2cq33:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"28/Dec/14 06:44;pschumacher;Thanks for reporting. Your example now prints ""count is: 3"" when using groovy 2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Confusing Compiler Error For Static Method Calls,GROOVY-6528,12817271,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,brownj,brownj,20/Jan/14 09:34,15/Oct/15 18:20,14/Jul/23 06:01,17/Feb/14 07:49,,,,,,,,,,,,,,,,,,2.2.2,,,,Static Type Checker,,,,0,,,,,,,"{noformat}
groovy $ cat Demo.groovy 
@groovy.transform.CompileStatic
class Demo {
    def someMethod() {
        String.doSomething()
    }
}
groovy $ 
groovy $ groovyc Demo.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Demo.groovy: 4: [Static type checking] - Cannot find matching method java.lang.Class#doSomething(). Please check if the declared type is right and if the method exists.
 @ line 4, column 3.
   		String.doSomething()
     ^

1 error
{noformat}

I think it would make more sense to refer to java.lang.String#doSomething() rather than java.lang.Class#doSomething().  I understand that there may be complications related to the type checker making a distinction between String.doSomething() and Class<String>.doSomething() but I am filing this here to prompt a look at the issue to see if the situation can be improved.",,brownj,lhotari,ychulov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-01-20 09:34:23.0,,,,,,,,,,"0|i2ccfr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy type extension does not type check for generic parameter,GROOVY-6525,12817299,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mperry,mperry,17/Jan/14 07:07,04/Mar/14 16:31,14/Jul/23 06:01,21/Jan/14 03:00,2.1.9,2.2.1,,,,,,,,,,,,,,,,2.2.2,,,,Static Type Checker,,,,0,,,,,,,"The repository at https://github.com/mperry/bug-extension-module-generics  demonstrates a simple type checking issue for Groovy extension modules

The method ""to"" is defined as a static method in the classes Normal and ListExtension where ListExtension is a Groovy extension module and Normal a regular class.  

{code}
static <A, B> List<B> to(List<A> list, B b) {
    list.collect { A a -> b }
}
{code}

Both are type checked.  The test class attempts to call both methods, but the ""to"" method in the extension class will not type check with the generic parameter.  The program works when type checking is removed.

Using:
* Groovy 2.1.9
* Gradle 1.10
* Java 1.7.0_45
","Windows, Java 1.7.0_45, Gradle 1.10",melix,mperry,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 21 03:00:16 UTC 2014,,,,,,,,,,"0|i2c887:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"17/Jan/14 18:00;mperry;BTW, changing the B in the method signature to something like String works (type checks).;;;","20/Jan/14 08:04;melix;Code tags;;;","21/Jan/14 03:00;melix;I'm closing it, because I could reproduce with {{2.2.1}}, but not {{2.2.2-SNAPSHOT}} or {{2.3.0-SNAPSHOT}} so I assume it's already fixed!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Implicit closure coercion conflicts with DGM methods in type checked mode,GROOVY-6524,12817296,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,17/Jan/14 02:44,05/Apr/14 00:00,14/Jul/23 06:01,20/Jan/14 09:14,2.2.1,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,,,,,0,,,,,,,"The problem is highlighted with Java 8, where a {{Collection.sort(Comparator)}} method has been added. Given the following code:

{code}
list.sort { a,b -> a<=>b }
{code}

which takes a closure, then the type checker chooses the default method from {{Collection}}, {{Collection.sort(Comparator)}} because an implicit coercion of {{Closure}} to {{Comparator}} is possible.

However, there's a {{DGM#sort(Collection,Closure)}} method which should have been preferred.

The result is a build failure as seen in http://148.251.23.208:8111/viewLog.html?buildId=35&tab=buildResultsDiv&buildTypeId=Groovy_Jdk8Build",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-01-17 02:44:39.0,,,,,,,,,,"0|i2cbmn:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Improve Documentation for in DefaultGroovyMethods.intersect(..) ,GROOVY-6523,12817275,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,nalandial,nalandial,16/Jan/14 10:44,26/Jul/18 04:38,14/Jul/23 06:01,16/Apr/18 05:29,2.2.0,,,,,,,,,,,,,,,,,2.5.0-rc-2,,,,Documentation,,,,0,,,,,,,"As noted in GROOVY-1986, the current version of this method is slow compared to Java's existing retainAll method for Sets, on the order of 4000% in test cases with a significant amount of data and intersections. The performance can't be improved due to limitations in the Java API.

This should be documented, as we would have never chosen intersect(..) if we were aware of the performance implications vs. convenience it provides.",,nalandial,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 16 05:29:50 UTC 2018,,,,,,,,,,"0|i2craf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Apr/18 05:29;paulk;This has been improved somewhat with GROOVY-8548. Please open a new issue or PR if you think further improvements are required.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
implicit invocation not working for member closures when using @CompileStatic annotation,GROOVY-6522,12817307,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,jckdnk111,jckdnk111,16/Jan/14 09:21,15/Oct/15 18:19,14/Jul/23 06:01,21/Jan/14 08:45,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,Static compilation,,,,0,closure,compilestatic,,,,,"Originally discussed here: http://stackoverflow.com/questions/21149013/groovy-implicit-invocation-not-working-for-member-closures-when-using-compilest

Implicit invocation of member closures throws an exception while explicit closure invocation for member closures works correctly when using compile static.

Attached is a sample groovy script which demonstrates the issue.",OSX 10.9.1,blackdrag,jckdnk111,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Jan/14 09:21;jckdnk111;sample.groovy;https://issues.apache.org/jira/secure/attachment/12722191/sample.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 21 08:45:41 UTC 2014,,,,,,,,,,"0|i2byjb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jan/14 07:00;blackdrag;I confirmed the bug with Groovy 2.2.1;;;","21/Jan/14 05:20;melix;Fixed, thank you!

https://github.com/groovy/groovy-core/commit/d5c1449c5e0e8b496f0ae751c73a3eca6818e579;;;","21/Jan/14 06:51;melix;Reopening because the fix introduces breaking changes in Grails (and in general, in closure variable scoping);;;","21/Jan/14 08:45;melix;Regression fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GStringTemplateEngine shares binding,GROOVY-6521,12817260,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,16/Jan/14 03:29,15/Oct/15 18:20,14/Jul/23 06:01,16/Jan/14 03:37,,,,,,,,,,,,,,,,,,2.2.2,,,,,,,,0,,,,,,,"The following test case fails, because {{GStringTemplateEngine}} doesn't handle the binding correctly. It is shared among calls:

{code}
    void testShouldNotShareBinding() {
        String text = ""<% println delegate.books; books = books.split(\"",\""); out << books %>"";

        StringWriter sw = new StringWriter();
        GStringTemplateEngine engine = new GStringTemplateEngine();

        Template template = engine.createTemplate(text);

        Map data = [books: 'a,b,c,d']


        // round one sucess
        template.make(data).writeTo(sw);
        assert sw.toString() == '[a, b, c, d]'

        sw = new StringWriter();
        // round two fails
        data = [books: 'e,f,g,h']
        template.make(data).writeTo(sw);
        assert sw.toString() == '[e, f, g, h]'

    }

{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 16 03:37:58 UTC 2014,,,,,,,,,,"0|i2bp9r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jan/14 03:37;melix;https://github.com/groovy/groovy-core/commit/53e6d774d9e0becd968fee39abaf70c052bb2bd5;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Documentation bug: http://groovy.codehaus.org/JN1035-Maps,GROOVY-6516,12818483,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,yatima,yatima,14/Jan/14 03:49,25/Apr/14 01:50,14/Jul/23 06:01,22/Jan/14 11:10,,,,,,,,,,,,,,,,,,,,,,Documentation,,,,0,,,,,,,"At http://groovy.codehaus.org/JN1035-Maps

we read: 

""We can also use the '+' and '<<' operators to add elements to the map. Note that '<<' produces a new map while '+' modifies the map:""


This should be 

""We can also use the '+' and '<<' operators to add elements to the map. Note that '+=' produces a new map while '<<' modifies the map:""

as the program in the documentation (which is correct) illustrates:

def map4a = [:]
def map5a = map4a
assert map5a.is(map4a)
map4a << ['b':'b value'] // the map reference by map4a & map5a is extended
assert map5a.is(map4a)
map4a+= ['a':'a value'] // map4a is not the original map4a anymore
assert !map5a.is(map4a)
assert map4a == [b:'b value', a:'a value']
assert map5a == [b:'b value']
",,dtonhofer,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6472,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 22 11:10:21 UTC 2014,,,,,,,,,,"0|i2cnif:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jan/14 11:10;melix;Thanks for finding this, note that you can update the wiki directly if you find more errors.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AccessControlException at at org.codehaus.groovy.runtime.ProxyGeneratorAdapter$InnerLoader.<init>,GROOVY-6512,12818271,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,aneilson,aneilson,10/Jan/14 09:26,15/Oct/15 18:19,14/Jul/23 06:01,29/Jan/14 06:57,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,groovy-runtime,,,,0,,,,,,,"Instantiating at {{org.codehaus.groovy.runtime.ProxyGeneratorAdapter}} creates a {{ClassLoader}}. When a {{SecurityManager}} is enabled, this requires the {{java.lang.RuntimePermission ""createClassLoader""}} permission to be granted.

{noformat}
java.security.AccessControlException: access denied (""java.lang.RuntimePermission"" ""createClassLoader"")
        at java.security.AccessControlContext.checkPermission(AccessControlContext.java:366)
        at java.security.AccessController.checkPermission(AccessController.java:560)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)
        at com.quest.nitro.bootstrap.ForgeSecurityManager.checkPermission(ForgeSecurityManager.java:154)
        at java.lang.SecurityManager.checkCreateClassLoader(SecurityManager.java:611)
        at java.lang.ClassLoader.checkCreateClassLoader(ClassLoader.java:273)
        at java.lang.ClassLoader.<init>(ClassLoader.java:315)
        at org.codehaus.groovy.runtime.ProxyGeneratorAdapter$InnerLoader.<init>(ProxyGeneratorAdapter.java:801)
        at org.codehaus.groovy.runtime.ProxyGeneratorAdapter.<init>(ProxyGeneratorAdapter.java:151)
        at groovy.util.ProxyGenerator.instantiateAggregate(ProxyGenerator.java:161)
        at groovy.util.ProxyGenerator.instantiateAggregateFromBaseClass(ProxyGenerator.java:117)
        at groovy.util.ProxyGenerator.instantiateAggregateFromBaseClass(ProxyGenerator.java:103)
        at org.codehaus.groovy.runtime.DefaultGroovyMethods.asType(DefaultGroovyMethods.java:8087)
        at org.codehaus.groovy.runtime.dgm$48.invoke(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:271)
        at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:53)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
{noformat}

While we would grant this permission to the Groovy implementation, granting this permission to all (i.e., untrusted) protection domains that might appear on the stack weakens our security policy.

The solution is to instantiate {{InnerLoader}} within a privileged block (i.e., {{AccessController.doPrivileged(new PrivilegedAction<InnerLoader>()...}}. This would limit the protection domains that are checked to the groovy code itself, so that a specific grant for the groovy codebase could be made.",,aneilson,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon May 12 09:45:17 UTC 2014,,,,,,,,,,"0|i2br53:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jan/14 06:57;blackdrag;I applied a privileged block around it. It should work now;;;","12/May/14 09:45;aneilson;This fix resolves the problem I was seeing.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Illegal use of non virtual function call when compiling with JDK 8,GROOVY-6511,12817282,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,09/Jan/14 04:28,05/Apr/14 00:01,14/Jul/23 06:01,20/Jan/14 09:10,,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,jdk conflict,,,,0,,,,,,,"When compiling Groovy with JDK 8, lots of tests fail with ""Illegal use of non virtual function call"", due to the introduction of virtual extension methods.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2014-01-09 04:28:50.0,,,,,,,,,,"0|i2c3vj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problems with implicit closures inside of @Category-annotated classes,GROOVY-6510,12817320,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,david.hangl,david.hangl,01/Jan/14 06:05,23/Jul/22 16:17,14/Jul/23 06:01,10/Feb/22 21:57,,,,,,,,,,,,,,,,,,2.5.16,3.0.10,4.0.1,,,,,,0,,,,,,,"The behavior of implicit closures is in my opinion broken when used inside of a category.

As you can see in the attached TestCase in a simplified example, I had the following scenario:
- first there is an utility method (in the example the method ClosureInvoker#setDelegateAndInvokeClosure(Closure)) that gets a closure, resets the delegate object of it and calls this closure.
- next we have an ExtendedClass which isn't really used in the example itself other than being used as ""base""-class for the category/extension-methods. This is just because its own functionallity doesn't matter to get the buggy behavior. Just be ensured that it made more sense in the original context (e.g. it was passed to the utility method and used to setup the delegate object)
- now there is a category class with a method that invokes the utility method and passing an implicit closure to it (@see CategoryClass#doWorkWithImplicitClosure()). that implicit closure is invoking a method of the delegate object
- at last the testcase itself will call this category method and assert, that the delegate method was really called by the closure (@see ClosureInsideExtensionOrCategoryTest#testCategoryWithImplicitClosure())

As you can see in the additional test methods, the basic behavior does work as expected. But only in the special combination of an implicit closure inside of the category it fails.

As far as I can backtrack it, it seems that the AST-manipulations for category classes may do the damage. It appears to me, that it will manipulate ALL unqualified member-calls inside of any category-methods to be instead calls to the class given by the @Category-annotation. But this manipulation should in my opinion be escaped when entering the code-block of an implicit closure.

So refering to my example the method CategoryClass#doWorkWithImplicitClosure() seems to lead to the following code after AST-manipulation:

{code}
def static doWorkWithImplicitClosure(ExtendedClass obj) {
  ClosureInvoker.setDelegateAndInvokeClosure {->
    obj.invokeDelegate()
  }
}
{code}

This will result in avoiding the whole resolve strategy of the closure, as there won't be any unqualified member calls inside of the closure at all.

Instead I would expect, that it would generate the following code:

{code}
def static doWorkWithImplicitClosure(ExtendedClass obj) {	
  ClosureInvoker.setDelegateAndInvokeClosure {->
    //AST manipulation would ""prefix"" all unqualified 
    //member calls with ""obj."" outside of the closure 
    //but not here as we are inside of a closure
    invokeDelegate()
  }
}
{code}

which would be equivalent to ExtensionMethodClass#doWorkWithImplicitClosure(ExtendedClass)
",,blackdrag,david.hangl,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"01/Jan/14 06:05;david.hangl;ClosureInsideExtensionOrCategoryTest.groovy;https://issues.apache.org/jira/secure/attachment/12723140/ClosureInsideExtensionOrCategoryTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 10 21:57:57 UTC 2022,,,,,,,,,,"0|i2c83b:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"01/Jan/14 08:14;blackdrag;How does the closure then make calls on obj is @Category is used? With explicit this only?;;;","01/Jan/14 12:40;david.hangl;As far as I understand the implementation of closures and its resolve strategies, I would say the thisObject should be set to the 'obj' instead of setting it to the CategoryClass 'this' object 
(where 'obj' refers to the ExtendedClass object from my example)
So the normal resolve strategy of the closure will ensure a consistent behavior.

Edit:
It may also be the ownerObject instead of the thisObject. I haven't got an understanding in the real difference between these two (maybe someone can explain that to me in that context? :D);;;","02/Jan/14 04:00;david.hangl;Sleeping over it, setting the owner/thisObject seems also inconsistent to the extension method variant. Although apart from that considering only the semenatic meaning of a CategoryClass it would be perfect in my opinion :D.
So the way you suggested seems like a good alternative even if not perfect.
On the one hand it breaks the ""convention"", that unqualified member calls and member calls to the this object are ""equivalent"".
But on the other hand it's the only way that comes to my mind for giving a possibility to both accessing ""closure""-members as well as ""category-this""-members without introducing an additional ""closure-this""-token or something like that.
And it would contain a little analogy to the extension-method way. On the one hand unqualified member-calls that will access the ""closure""-members. On the other hand explicit calls ('obj.<member>' => 'this.<member>');;;","10/Feb/22 21:57;emilles;https://github.com/apache/groovy/commit/a708f649e86f832390f40c9374c530234a7efa4b;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
A public method annotated with @Memoized is not accessible by subclasses ,GROOVY-6509,12818491,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,pablo72,pablo72,30/Dec/13 08:17,04/Mar/14 16:31,14/Jul/23 05:59,02/Jan/14 05:54,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,,,,,0,,,,,,,"A public method annotated with @Memoized transformation is not accessible by subclasses. 

Tese case: 

class M  {
   int count 

  @groovy.transform.Memoized
  def int foo() {
    println 'foo'
    return ++count
  }
}

class Q extends M {}
assert new Q().foo() == 1  // throws MissingMethodException
 

Discussion thread 
http://groovy.329449.n5.nabble.com/Bug-in-Memoized-transformation-tc5717930.html


Cheers,
Paolo",,blackdrag,bloschetsov,paolodt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 02 05:54:18 UTC 2014,,,,,,,,,,"0|i2cecn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Dec/13 10:04;bloschetsov;Pull request for fix:
https://github.com/groovy/groovy-core/pull/302;;;","02/Jan/14 05:54;blackdrag;pull request applied, thanks for the work;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 Outer class property dispatcher called by an inner class's propertyMissing looks for attributes/fields rather than properties on the outer class,GROOVY-6508,12818274,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,lujke,lujke,29/Dec/13 14:28,15/Oct/15 18:19,14/Jul/23 06:01,02/Jan/14 10:03,,,,,,,,,,,,,,,,,,2.2.2,,,,ast builder,,,,0,,,,,,,"Appears to affect all versions such the introduction of inner classes in 1.7.

I have a unit test and bugfix and a pull request will be forthcoming.

Consider the following: 
{code:java}
class BaseFieldBearer {
    String baseField = 'baseValue'    
}

class BaseFieldBearerSub extends BaseFieldBearer {

    String getBaseFieldViaInner() {
        // An easy way to create an inner class and have it resolve something
        new java.util.concurrent.Callable<String>() {
            String call() {                
                baseField
            }
        }.call();
    }
}

BaseFieldBearerSub s = new BaseFieldBearerSub()
assert s.baseFieldViaInner == s.baseField
{code}

BaseFieldBearerSub.baseFieldViaInner will fail with the following:
{noformat}
Exception in thread ""main"" groovy.lang.MissingFieldException: No such field: baseField for class: BaseFieldBearerSub
        at groovy.lang.MetaClassImpl.getAttribute(MetaClassImpl.java:2628)
        at groovy.lang.MetaClassImpl.getAttribute(MetaClassImpl.java:3466)
        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.getGroovyObjectField(ScriptBytecodeAdapter.java:352)
        at BaseFieldBearerSub.this$dist$get$2(GroovyXXXBug.groovy)
        at BaseFieldBearerSub$1.propertyMissing(GroovyXXXBug.groovy)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaClassImpl.invokeMissingProperty(MetaClassImpl.java:778)
        at groovy.lang.MetaClassImpl$12.getProperty(MetaClassImpl.java:1896)
        at org.codehaus.groovy.runtime.callsite.GetEffectivePogoPropertySite.getProperty(GetEffectivePogoPropertySite.java:84)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGroovyObjectGetProperty(AbstractCallSite.java:231)
        at BaseFieldBearerSub$1.call(GroovyXXXBug.groovy:32)
        at BaseFieldBearerSub$1.call(GroovyXXXBug.groovy)
        at java_util_concurrent_Callable$call.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
        at BaseFieldBearerSub.getBaseFieldViaInner(GroovyXXXBug.groovy:30)
        at BaseFieldBearerSub$getBaseFieldViaInner.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
        at GroovyXXXBug.testInnerClassAccessingBaseFieldProperty(GroovyXXXBug.groovy:11)
        at GroovyXXXBug$testInnerClassAccessingBaseFieldProperty.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
        at GroovyXXXBug.main(GroovyXXXBug.groovy:17)
{noformat}

BaseFieldBearerSub.this$dist$get$2 is a dispatcher method that's meant to resolve a named property in the outer class, but instead of using ScriptBytecodeAdapter.getGroovyObjectProperty it calls ScriptBytecodeAdapter.getGroovyObjectField. If baseField were a property in the subclass then this would normally go unnoticed, as the attribute would be found (though any property getter method would be ignored). I expect that's why I couldn't find other references to this bug. 

The code at fault appears to be in InnerClassVisitorHelper as the dispatcher method uses an AttributeExpression instead of a PropertyExpression. I can't imagine there's any reason for the dispatcher to only consider attributes rather than properties, but I'm open to being corrected!
",,blackdrag,lujke,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Dec/13 14:28;lujke;GroovyOuterClassPropertyDispatcherBug.groovy;https://issues.apache.org/jira/secure/attachment/12722400/GroovyOuterClassPropertyDispatcherBug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 02 10:03:11 UTC 2014,,,,,,,,,,"0|i2cnp3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Dec/13 15:07;lujke;Issued pull request for fix and bugtest: https://github.com/groovy/groovy-core/pull/301
;;;","02/Jan/14 10:03;blackdrag;pull request applied. In 2.2 and 2.3 a modification of ComplexCommandSupport was needed though;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker select the wrong inject method,GROOVY-6504,12817278,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,24/Dec/13 04:59,17/Aug/22 18:49,14/Jul/23 06:01,20/Jan/14 09:12,,,,,,,,,,,,,,,,,,2.2.2,,,,Static Type Checker,,,,0,,,,,,,"In the following example:

{code}
['a','bb','ccc'].inject(0) { int acc, String str -> acc += str.length(); acc }
{code}

The type checker thinks the method to be called is {{DGM#inject(Object,Object,Closure)}} instead of {{DGM#inject(Collection,Object,Closure)}}
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8788,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 24 05:08:28 UTC 2013,,,,,,,,,,"0|i2citb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Dec/13 05:08;melix;Testing fix against Grails joint build before backporting to {{2.2.X}}

https://github.com/groovy/groovy-core/commit/4e00a0122ce64db5287869cb97388c3b1b8b746f ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Property not found for GroovyRowResult in nested .with,GROOVY-6502,12817210,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,bigtrose,bigtrose,20/Dec/13 16:08,08/Mar/22 12:16,14/Jul/23 06:01,05/Oct/21 20:41,2.2.1,,,,,,,,,,,,,,,,,,,,,groovy-jdk,SQL processing,,,0,,,,,,,"Within nested .with blocks, calling a method of the wrapper class fails with a missing property exception.

Example:
{code}
import groovy.sql.*

class Foo {}

class Test extends GroovyTestCase {
   void test() {
      new Foo().with {
         def result = new GroovyRowResult([:])

         result.with {
            assertEquals(""1:"", 1, 1)
         }
      }
   }
}

new Test().test()
{code}
Result: 
{noformat}
groovy.lang.MissingPropertyException: assertEquals
{noformat}

Note: Remove 'new Foo().with' and the code works. Also, the code works in Groovy 1.8.


",Windows,bigtrose,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 05 20:41:48 UTC 2021,,,,,,,,,,"0|i2bzqf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/May/14 00:07;paulk;add code tags;;;","05/Oct/21 20:41;emilles;works just fine;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Decouple AST transformation from its interface via ASTTransformationCustomizer,GROOVY-6501,12817273,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,aalmiray,aalmiray,20/Dec/13 14:20,04/Mar/14 16:31,14/Jul/23 06:01,13/Jan/14 09:30,2.2.1,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,Compiler,,,,0,,,,,,,"Say for example there's the following annotation provided by a library (acme-lib) that is in no way related to Groovy

{code}
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface DependsOn {
    String[] value();
}
{code}

You'd like to reuse this annotation to trigger a local AST transformation, problem is that the annotation's source must be changed to the following

{code}
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
@GroovyASTTransformationClass(""com.acme.ast.DependsOnASTTransformation"")
public @interface DependsOn {
    String[] value();
}
{code}

Now acme-lib has a hard dependency on Groovy, and that's assuming you can even touch the code and recompile it. Say for the sake of example you'd like to ""hijack"" some of the JPA annotations, you can't simply push Groovy to whatever JSR controls JPA's codebase (extra points for inserting Boromir's meme here? ;-)

So what if we could write the following code instead

{code}
def configuration = new CompilerConfiguration()
configuration.addCompilationCustomizers(new ASTTransformationCustomizer(DependsOn, ""com.acme.ast.DependsOnASTTransformation""))
def shell = new GroovyShell(configuration)
shell.evaluate(""""""
    class MyClass {
}"""""")
{code}",,aalmiray,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 13 09:30:01 UTC 2014,,,,,,,,,,"0|i2bxmf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Dec/13 14:29;melix;Reminds me of something I wrote last week: https://gist.github.com/melix/7928511;;;","20/Dec/13 16:15;aalmiray;Pull Request @ https://github.com/groovy/groovy-core/pull/300;;;","20/Dec/13 16:16;aalmiray;You're the best one qualified to review this patch ;-);;;","13/Jan/14 09:30;melix;Merged, thank you!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FactoryBuilderSupport does not expose a getter for disposalClosures,GROOVY-6500,12817263,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,aalmiray,aalmiray,20/Dec/13 14:16,04/Mar/14 16:31,14/Jul/23 06:01,03/Jan/14 04:49,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,groovy-jdk,,,,0,,,,,,,FBS fails to expose {{disposalClosures}} as a readable property. This hinders composition as required by Griffon's CompositeBuilder or any other FBS subclass that would like to read it. The fix is as simple as adding a public getter.,,aalmiray,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 03 04:49:58 UTC 2014,,,,,,,,,,"0|i2buh3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Dec/13 14:30;aalmiray;Pull Request @ https://github.com/groovy/groovy-core/pull/299;;;","03/Jan/14 04:49;blackdrag;I applied it to master and 2.2.x;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler reporting bug when calling extension module method in Groovy 2.2,GROOVY-6496,12817258,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mperry,mperry,19/Dec/13 21:21,15/Oct/15 18:19,14/Jul/23 06:01,20/Dec/13 05:40,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,,,,,0,,,,,,,"The Groovy compiler reports a bug when calling a method added by an extension module to a class using Groovy 2.2.  The error message is: 

""Declaring class for method call to 'fj.data.Stream to(java.lang.Integer, java.lang.Integer)' declared in java.lang.Integer was not matched with found receiver int. This should not have happened!.""

I have created a Github repository demonstrating the error at https://github.com/mperry/groovy-extension-module-bug

The to method here is added to a Java class called Stream using a Groovy extension module.

","Gradle 1.9
Java 1.7.0_45 64 bit
Groovy 2.2.1
Windows 7",melix,mperry,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 23 04:54:51 UTC 2013,,,,,,,,,,"0|i2bx5j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"20/Dec/13 05:40;melix;Thanks for the bug report! If you have the chance to test it against {{master}} or {{2.2.X}}, it would be very nice!;;;","21/Dec/13 06:23;mperry;Is there an easy way to do this via Gradle?  I tried using the groovy version 2.2.2-SNAPSHOT and 2.2.2, but this version was not found on Maven Central or Sonatype as used in my build.gradle file.

;;;","22/Dec/13 17:17;paulk;Not sure if you already worked it out, but you need something like this in your {{build.gradle}} file (syntax differs slightly for earlier versions of gradle):
{code}
repositories {
  maven {
    url ""http://snapshots.repository.codehaus.org""
  }
}
{code}
;;;","23/Dec/13 00:33;mperry;Thanks Paul, I had not tried again, low on the list of priorities.

I tried again, successfully got the 2.2.2-SNAPSHOT.  Looks like I got the same error.  I pushed the changes up to the Github repo, so you should be able to tell whether the problem still exists in the future by cloning the repo (https://github.com/mperry/groovy-extension-module-bug).

;;;","23/Dec/13 03:45;melix;Hi Mark. For some obscure reason, the CI server didn't build a snapshot with my changes. I have manually triggered and update, and meanwhile, I tested with a local Groovy build and your project now passes, so this is fixed. Thanks for your help!;;;","23/Dec/13 04:13;mperry;Cedric, I tried this again and got the same error.  Should I look deeper to see if there is a problem on my side?;;;","23/Dec/13 04:26;melix;Try with: {{gradle --refresh-dependencies test}} (it will make sure it downloads a fresh snapshot);;;","23/Dec/13 04:54;mperry;Confirmed that fixed it.  I had forgotten Gradle caches dynamic and changing modules for 24 hours.  Thanks for the fast turnaround.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
/c/Program Files (x86)/Groovy/Groovy-2.2.1/bin/startGroovy: line 96: [: too many arguments,GROOVY-6495,12817168,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ocroquette,ocroquette,18/Dec/13 03:38,15/Oct/15 18:19,14/Jul/23 06:01,03/Jan/14 05:34,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,,,,,0,,,,,,,"When $GROOVY_HOME contains spaces, which is typically the case under Windows, startGroovy reports the following error:
/c/Program Files (x86)/Groovy/Groovy-2.2.1/bin/startGroovy: line 96: [: too many arguments
",,blackdrag,ocroquette,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 03 05:34:52 UTC 2014,,,,,,,,,,"0|i2bpy7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Dec/13 03:45;ocroquette;Commit ID: 4ec5e01f89b6abcf84d3d6137c07dc7180a5bfcc
Pull request: #298
;;;","03/Jan/14 05:34;blackdrag;pull request applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
size() and iterator() not correct for an empty IntRange,GROOVY-6493,12817295,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pledbrook,pledbrook,17/Dec/13 15:49,04/Mar/14 16:31,14/Jul/23 06:01,17/Dec/13 16:48,2.1.9,2.2.1,,,,,,,,,,,,,,,,2.2.2,,,,Static compilation,,,,0,,,,,,,"The following script fails:

{code}
def empty = new IntRange(false, 5, 5)
assert empty.size() == 0
assert empty.iterator().hasNext() == false
{code}
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6482,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 17 16:00:58 UTC 2013,,,,,,,,,,"0|i2bn3b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Dec/13 16:00;paulk;linking related issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyScriptEngine: excessive reload of dependencies,GROOVY-6490,12817274,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,alessiostalla,alessiostalla,17/Dec/13 08:13,15/Oct/15 18:20,14/Jul/23 06:01,15/Dec/14 04:10,,,,,,,,,,,,,,,,,,2.2.2,,,,GroovyScriptEngine,,,,0,,,,,,,"Lengthy description posted on the mailing list. In short: GSE does not cache compiled classes right (it uses as the last-modified timestamp the time of compilation instead of the last-modified attribute of the source file). This can lead to needless recompilation of shared classes, especially under heavy load and heavy concurrency.",,alessiostalla,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Dec/13 11:02;alessiostalla;groovy-script-engine-test.zip;https://issues.apache.org/jira/secure/attachment/12722190/groovy-script-engine-test.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 15 04:10:34 UTC 2014,,,,,,,,,,"0|i2cjif:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Dec/13 11:02;alessiostalla;JUnit test case showing the issue. ;;;","10/Jan/14 09:23;blackdrag;thanks for the pull request. I applied it but also made some further changes, trying to reduce the amount of recompilations happening. Your test seems to perform now pretty good.I suggest you try this new version;;;","17/Jan/14 05:37;alessiostalla;My stress-test plan now doesn't slow the application to a crawl anymore. Files seem to only be recompiled when they are actually changed and cold startup with a lot of concurrent requests doesn't seem to be a problem anymore. You did a great job, thanks!;;;","17/Jan/14 07:05;blackdrag;Good to hear... it took me a while to get that. But your test was of tremendous help;;;","15/Dec/14 04:10;blackdrag;corrected missing fix version;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Static type checker bug for propery called ""names""",GROOVY-6489,12817174,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,cbrehm,cbrehm,17/Dec/13 04:20,04/Mar/14 16:31,14/Jul/23 06:01,22/Jan/14 10:14,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,Static Type Checker,,,,0,,,,,,,"I get a static type check error for a very simple groovy class.

It uses this java class:

{code}
package playground.groovy;

import java.util.List;

public class Foo {

    private List<String> names;

    public List<String> getNames() {
        return names;
    }

    public void setNames(List<String> names) {
        this.names = names;
    }
}
{code}

I use the java class in this groovy class:

{code}
@groovy.transform.TypeChecked()
class FooWorker {

    public void doSomething() {
        new playground.groovy.Foo().with {
            names = new ArrayList()
        }
    }
}
{code}

I load the groovy class like this:

{code}
GroovyClassLoader loader = new GroovyClassLoader(GroovyClassTest.class.getClassLoader());
Class<?> groovyClass = loader.parseClass(""...FooWorker.groovy""));
{code}

And I get this exception:

{code}
Exception in thread ""main"" BUG! exception in phase 'instruction selection' in source unit '...\FooWorker.groovy' Declaring class for method call to '<>' declared in playground.groovy.Foo was not matched with found receiver FooWorker. This should not have happened!
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.extractPlaceHolders(StaticTypeCheckingVisitor.java:3575)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.resolvePlaceHoldersFromDeclartion(StaticTypeCheckingVisitor.java:3500)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.storeWithResolve(StaticTypeCheckingVisitor.java:1133)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.storeField(StaticTypeCheckingVisitor.java:1143)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.existsProperty(StaticTypeCheckingVisitor.java:955)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.existsProperty(StaticTypeCheckingVisitor.java:882)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitPropertyExpressionSilent(StaticTypeCheckingVisitor.java:351)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitVariableExpression(StaticTypeCheckingVisitor.java:336)
        at org.codehaus.groovy.ast.expr.VariableExpression.visit(VariableExpression.java:70)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:400)
        at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitClosureExpression(CodeVisitorSupport.java:174)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClosureExpression(StaticTypeCheckingVisitor.java:1625)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.getInferredReturnTypeFromWithClosureArgument(StaticTypeCheckingVisitor.java:2341)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2229)
        at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1450)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1732)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1705)
        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:162)
        at org.codehaus.groovy.transform.StaticTypesTransformation.visit(StaticTypesTransformation.java:62)
        at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
        at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
        at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:279)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:258)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:244)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:185)
        at playground.groovy.GroovyClassTest.main(GroovyClassTest.java:43)
{code}

It seems the property name ""names"" causes a problem. When I change the name (to namesX, for example), it works just fine. <edit> After further testing, I found that the exception disappears when I either rename the getter/setter or the private field in class Foo. </edit>

I created this bug as requested by  Cedric Champeau, see http://groovy.329449.n5.nabble.com/Possible-bug-in-static-type-checker-td5717794.html

",,cbrehm,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-12-17 04:20:57.0,,,,,,,,,,"0|i2csw7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closure to SAM coercion cannot infer generic return type,GROOVY-6488,12817163,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ldaley,ldaley,15/Dec/13 09:04,04/Mar/14 16:31,14/Jul/23 06:01,21/Jan/14 14:46,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,Static compilation,,,,1,,,,,,,"Given the following:

{code}
import groovy.transform.CompileStatic

import java.util.concurrent.Callable

interface CustomCallable<T> {
  T call()
}

class Thing {
  static <T> T customType(CustomCallable<T> callable) {
    callable.call()
  }

  static <T> T callable(Callable<T> callable) {
    callable.call()
  }

  @CompileStatic
  static void run() {
    callable { [] }.add(1) // return type is inferred - passes compile
    customType { [] }.add(1) // return type is not inferred - fails compile
  }
}
{code}

The problem is visible in the run() method above.

It would be extremely useful for typed DSLs if the return type can be inferred for SAM coercion.

",,boaznahum,guillaume,ldaley,melix,mxm,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 13 07:47:54 UTC 2014,,,,,,,,,,"0|i2bzvz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jan/14 14:46;melix;Fixed in 2.2.2. More complex examples like:

{code}
            interface Action<T> { void execute(T t) }

            public <T> void exec(T t, Action<T> f) {
                f.execute(t)
            }

            exec('foo') { println it.toUpperCase() }
{code}

only work in 2.3.0+;;;","21/Jan/14 14:49;ldaley;I'll say it again you're the man.;;;","24/Jan/14 06:30;boaznahum;Can one tell when what is the due date of 2.2.2 ? 
The
Boaz

;;;","24/Jan/14 06:38;guillaume;We haven't planned a date yet, but definitely in the coming weeks.;;;","13/Feb/14 02:13;mxm-groovy;Cedric, could you describe how do you infer generics for closure argument in the latter example?

And what do you think about the following case? IMO an error should be caught at compilation. It fails at runtime in the current 2.3 build. 
{code}
interface Action<T, X> {
    void execute(T t, X x)
}

public <T, X> void exec(T t, X x, Action<T, X> f) {
    f.execute(t, x)
}

@CompileStatic
def foo() {
    exec('foo', 1) { String t, String x -> print t+x} // Action<String, Integer> is expected
}

{code};;;","13/Feb/14 02:47;melix;Hi Maxim,

If I compile your latest example with master (2.3), it fails with:

{noformat}
Expected parameter of type java.lang.Integer but got java.lang.String
 at line: 11, column: 32
{noformat}

Can you make sure you are using the latest sources?;;;","13/Feb/14 03:16;mxm-groovy;I download snapshots from http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all/2.3.0-SNAPSHOT/. The last snapahot was built 10 days ago. Are there any other places to download a newer one?;;;","13/Feb/14 03:19;melix;Yes, snapshots are now hosted on JFrog. See http://groovy.329449.n5.nabble.com/ANN-Groovy-infrastructure-update-td5718415.html for details.

The repository URL is: https://oss.jfrog.org/oss-snapshot-local/;;;","13/Feb/14 04:40;mxm-groovy;Ah, yes. Check the example once more. Compilation fails as expected. ;;;","13/Feb/14 04:46;melix;Excellent! Should I understand that you are implementing closure parameter type inference in IntelliJ IDEA? If yes, I'd be interested to hear your thoughts about the solution we proposed.;;;","13/Feb/14 07:25;mxm-groovy;Yes, I've implemented the first simple case already. Does any kind of spec exist for the second case? ;;;","13/Feb/14 07:47;melix;No, no spec at all. We only have unit tests so far.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compile error on class that overrides a method with return type that extends a class and implements an interface,GROOVY-6487,12817246,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,dmovchinn,dmovchinn,13/Dec/13 23:51,08/Mar/22 12:16,14/Jul/23 06:01,05/Oct/21 20:19,2.1.9,2.2.1,2.4.0-beta-3,,,,,,,,,,,,,,,,,,,Compiler,,,,0,,,,,,,"This code

interface T {
}

interface X {

	T getT();
}

class C1 {

	public Properties getT() {
		return null;
	}
}

class PT extends Properties implements T {
}

class C2 extends C1 implements X {

	@Override
	public PT getT() {
		return null;
	}
}

provokes the following error:
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:                                                                                                                                                  
Bug1.groovy: 11: The return type of java.util.Properties getT() in C1 is incompatible with T getT() in X                                                                                                                         
. At [11:2]  @ line 11, column 2.                                                                                                                                                                                                
        public Properties getT() {                                                                                                                                                                                               
    ^                                                                                                                                                                                                                            

1 error

but the same code in Java is OK.","OpenSUSE 12.3 i586, OpenJDK 1.7u45",dmovchinn,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"13/Dec/13 23:51;dmovchinn;Bug1.groovy;https://issues.apache.org/jira/secure/attachment/12723205/Bug1.groovy","13/Dec/13 23:51;dmovchinn;Bug1.java;https://issues.apache.org/jira/secure/attachment/12723097/Bug1.java",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 05 20:19:48 UTC 2021,,,,,,,,,,"0|i2c1i7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"05/Oct/21 20:19;emilles;Works in Groovy 2.5+;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic does not support empty ranges properly,GROOVY-6482,12817218,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pledbrook,pledbrook,11/Dec/13 08:53,04/Mar/14 16:31,14/Jul/23 06:01,21/Jan/14 15:00,2.1.9,2.2.1,,,,,,,,,,,,,,,,2.2.2,,,,Static compilation,,,,0,,,,,,,"In the following script, the empty range is apparently treated as a slice of size 1:

{code}
testMethod()

@groovy.transform.CompileStatic
def testMethod() {
    def list = [""1"", ""2"", ""3"", ""4""]

    assert list[0..<0] == []
    println list
}
{code}

If you remove the annotation, the assertion passes.",,pledbrook,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6493,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-12-11 08:53:37.0,,,,,,,,,,"0|i2ck8f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Can't use negative index on right-hand-side of exclusive range,GROOVY-6481,12813820,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,pledbrook,pledbrook,11/Dec/13 08:51,04/Mar/14 16:31,14/Jul/23 06:01,18/Dec/13 03:46,,,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,,"The assertion in this script fails:

{code}
testMethod()

def testMethod() {
    def list = [""1"", ""2"", ""3"", ""4""]

    assert list[0..<-1] == [""1"", ""2"", ""3""]
    println list
}
{code}

There is no compilation error, it's just that the negative index behaves unexpectedly, i.e. {{[0..<-1]}} seems to be the same as {{[0..<1]}}.",,paulk,pledbrook,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 18 03:46:08 UTC 2013,,,,,,,,,,"0|i2cpy7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Dec/13 14:35;paulk;What version of Groovy are you using? This looks like a bug we fixed a little while back: GROOVY-6194 but only in 2.2+.;;;","16/Dec/13 15:53;pledbrook;Pretty sure I tested with 2.1.9 and 2.2.1. Will try to verify tomorrow.;;;","17/Dec/13 16:11;paulk;I found an edge case (fixed in GROOVY-6493) in 2.2 that wasn't right but otherwise I think this is a duplicate - unless you are requesting a backport of the earlier fix into the 2_1_X stream.;;;","18/Dec/13 03:46;pledbrook;You're right, this is working in 2.2.1. I was submitting several bugs at the same time and must have missed testing this one with 2.2.x. Of course, a back port into 2.1.x would be nice, but it's not critical for me.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Can't use empty range on array with @CompileStatic,GROOVY-6480,12818268,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pledbrook,pledbrook,11/Dec/13 08:46,04/Mar/14 16:31,14/Jul/23 06:01,21/Jan/14 14:53,2.1.9,2.2.1,,,,,,,,,,,,,,,,2.2.2,,,,Static compilation,Static Type Checker,,,0,,,,,,,"This script fails:

{code}
testMethod()

@groovy.transform.CompileStatic
def testMethod() {
    def root = new ConfigObject()
    def list = [""1"", ""2"", ""3"", ""4""] as String[]

    assert list[0..<0] == []
    assert list[0..<-1] == [""1"", ""2"", ""3""]
    println list
}
{code}

The error is:

{noformat}
Caught: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object '0..<0' with class 'groovy.lang.EmptyRange' to class 'groovy.lang.IntRange' due to: org.codehaus.groovy.runtime.metaclass.MethodSelectionException: Could not find which method <init>() to invoke from this list:
  public groovy.lang.IntRange#<init>(int, int)
  protected groovy.lang.IntRange#<init>(int, int, boolean)
  public groovy.lang.IntRange#<init>(boolean, int, int)
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object '0..<0' with class 'groovy.lang.EmptyRange' to class 'groovy.lang.IntRange' due to: org.codehaus.groovy.runtime.metaclass.MethodSelectionException: Could not find which method <init>() to invoke from this list:
  public groovy.lang.IntRange#<init>(int, int)
  protected groovy.lang.IntRange#<init>(int, int, boolean)
  public groovy.lang.IntRange#<init>(boolean, int, int)
	at groovyBugs.testMethod(groovyBugs.groovy:8)
	at groovyBugs.run(groovyBugs.groovy:1)
{noformat}",,pledbrook,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-12-11 08:46:25.0,,,,,,,,,,"0|i2bvan:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Array Index Operator Incorrectly Trying to Use getAt Method,GROOVY-6477,12817226,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,davidclark,davidclark,10/Dec/13 11:20,28/Dec/14 06:49,14/Jul/23 06:01,28/Dec/14 06:49,2.2.1,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Compiler,,,,0,,,,,,,"When using @CompileStatic, the compiler tries to access a byte array using the getAt method instead of using array index operators/primitives.  Strangely, this only seems to happen when the array access is inside certain closures.  When the byte array access happens inside a Java-style for loop, the correct code is generated.",Groovy Version: 2.2.1 JVM: 1.7.0_17 Vendor: Oracle Corporation OS: Mac OS X,davidclark,melix,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Dec/13 11:20;davidclark;BadBytes.groovy;https://issues.apache.org/jira/secure/attachment/12723094/BadBytes.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 06:49:01 UTC 2014,,,,,,,,,,"0|i2c7xb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"04/Feb/14 09:42;melix;Actually using {{getAt}} is necessary, because in general, the compiler will not know if you use a negative index (which is supported by Groovy). So keeping this open because I would expect the same behavior everywhere.
;;;","28/Dec/14 06:49;pschumacher;Thanks for reporting. Your example works for me with groovy 2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic fails on valid generic type argument,GROOVY-6475,12817251,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,axel.fontaine,axel.fontaine,10/Dec/13 05:20,04/Mar/14 16:31,14/Jul/23 06:01,18/Feb/14 14:59,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,Compiler,,,,0,,,,,,,"The following code (using Jackson API)

TypeReference<Map<String, String>> mapTypeReference = new TypeReference<Map<String, String>>() {};

fails to compile with @CompileStatic with

[Static type checking] - Cannot use diamond <> with anonymous inner classes

Even though it is valid Java code and should work in Groovy.

",,axel.fontaine,boaznahum,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 18 11:28:30 UTC 2014,,,,,,,,,,"0|i2bph3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Dec/13 05:26;axel.fontaine;This then further breaks down with

Map<String, String> m = new ObjectMapper().readValue(c.toString(), mapTypeReference);

causing

[Static type checking] - Cannot assign value of type java.lang.Object to variable of type java.util.Map <String, String>;;;","04/Feb/14 09:51;melix;Could you check if it still happens with {{2.2.2-SNAPSHOT}} or {{2.3.0-SNAPSHOT}} ? I have fixed something that looks very similar recently.;;;","18/Feb/14 11:28;melix;Complete reproducible example:

{code}
@Grab('org.codehaus.jackson:jackson-core-asl:1.9.9')
import org.codehaus.jackson.type.TypeReference
@Grab('org.codehaus.jackson:jackson-mapper-asl:1.9.9')
import org.codehaus.jackson.map.ObjectMapper

@groovy.transform.CompileStatic
void foo() {
  TypeReference<Map<String, String>> mapTypeReference = new TypeReference<Map<String, String>>(){};
  //Map<String, String> m = new ObjectMapper().readValue('foo', mapTypeReference);
}

foo()
{code}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Immutable should provide a no-arg constructor,GROOVY-6473,12817250,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,wu-lee,wu-lee,06/Dec/13 08:22,04/Mar/14 16:31,14/Jul/23 06:01,06/Dec/13 08:34,1.8.6,2.0.5,,,,,,,,,,,,,,,,2.2.2,,,,xforms,,,,0,,,,,,,"Given this class:
{code}
@Immutable class Y { Collection c = []; int foo = 1 }
{code}
I expect the following to succeed:
{code}
def y = new Y()
assert y.c.class.name.constains('Unmodifiable')
{code}
In general, calling the no-arg constructor won't provide an interesting result unless the properties have default values but the constructor call should pass nonetheless.","Ubuntu Precise
Groovy Version: 1.8.6 JVM: 1.6.0_27 Vendor: Sun Microsystems Inc. OS: Linux 
Groovy Version: 2.0.5 JVM: 1.7.0_25 Vendor: Oracle Corporation OS: Linux ",paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 06 08:29:05 UTC 2013,,,,,,,,,,"0|i2csdj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Dec/13 08:29;paulk;Your example requiring null to be passed in the constructor highlights another less than intuitive requirement of the latest version of Groovy (that wasn't a requirement in earlier versions). We should add a no-arg constructor to remedy this problem. I have cloned a separate issue to capture this requirement.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AccessControlException when compiling scripts on the fly with Google App Engine dev server,GROOVY-6471,12817247,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,musketyr,musketyr,05/Dec/13 16:24,15/Oct/15 18:15,14/Jul/23 06:01,08/Apr/14 02:44,2.2.1,,,,,,,,,,,,,,,,,2.2.2,2.3.0-beta-2,,,Compiler,,,,1,,,,,,,"Similar security exception like the one from GROOVY-6405 still occurs in 2.2.1 under same conditions - compiling groovy scrips on Google App Engine dev server.

See the log attached for the details about the exception.","Ubuntu Linux 12.10 x64, Java 7u45
OS X Mavericks, Java 7u45
Windows 8
Google App Engine 1.8.8",blackdrag,guillaume,kdabir,marceloverdijk,musketyr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6679,,,,"05/Dec/13 16:24;musketyr;stacktrace.txt;https://issues.apache.org/jira/secure/attachment/12723234/stacktrace.txt","23/Mar/14 07:18;musketyr;stacktrace2.txt;https://issues.apache.org/jira/secure/attachment/12722199/stacktrace2.txt",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 08 04:36:15 UTC 2014,,,,,,,,,,"0|i2cdun:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jan/14 05:08;musketyr;any chance to get this fixed soon (in next release)? it's pretty annoying to force users to use custom builds instead of official ones.;;;","29/Jan/14 06:58;blackdrag;I applied a privileged block around it. It should work now;;;","29/Jan/14 07:02;musketyr;I wouldn't be so sure. Privileged block wasn't helping for GROOVY-6405 - see the b.patch which didn't help;;;","29/Jan/14 07:27;blackdrag;I suggest you try http://ci.groovy-lang.org:8111/repository/download/Groovy_Jdk7Build/369:id/target/distributions/groovy-sdk-2.1.10-SNAPSHOT.zip?guest=1 to see if it works or not;;;","29/Jan/14 09:04;musketyr;ok, I've tried http://ci.groovy-lang.org/repository/download/Groovy_Jdk7Build/372:id/target/distributions/groovy-binary-2.2.2-SNAPSHOT.zip and it looks working well;;;","22/Mar/14 02:04;musketyr;actually the 2.2.2 release versions still contains the bug;;;","22/Mar/14 03:11;kdabir;Fails for me with GAE 1.9.0 ,Groovy 2.2.2, Java 1.8, OS X Mavericks ;;;","23/Mar/14 06:37;blackdrag;and the stack trace is exactly the same?;;;","23/Mar/14 07:18;musketyr;stacktrace2.txt is the latest stacktrace. looks pretty similart to me, just the package name changed;;;","08/Apr/14 02:08;musketyr;just verified it still exists in 2.3.0-beta-1;;;","08/Apr/14 02:44;blackdrag;since the control block did not work I am now doing the forceful method and just swallow the exception;;;","08/Apr/14 04:36;marceloverdijk;Also affects Groovy 2.2.0;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Grab does not work if the same dependency is used with and without a classifier,GROOVY-6470,12817133,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,darthvader,darthvader,05/Dec/13 14:31,13/Nov/17 03:26,14/Jul/23 06:01,05/Dec/13 18:13,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,Grape,,,,0,,,,,,,"If a script uses the same artifact multiple times, once without a classifer and with classifier, e.g. 

{code}
@Grab(group = ""org.neo4j"", module = ""neo4j-kernel"", version = ""2.0.0-RC1"")
@Grab(group = ""org.neo4j"", module = ""neo4j-kernel"", version = ""2.0.0-RC1"", classifier = ""tests"")
{code}

only the jar without a classifier is loaded.

The root cause for this is some weird behaviour in Ivy. Ivy expects for this case a single DependencyDescriptor with multiple ArtifactDescriptors. Groovy generates a DependencyDescriptor for each dependency.

I've created locally a test case demoing the wrong behaviour and a bugfix as well. If desired I can sent a pull request for this. I assume the PR should be created vs master branch.",,darthvader,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8372,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Thu Dec 05 18:13:27 UTC 2013,,,,,,,,,,"0|i2bs8n:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"05/Dec/13 14:52;darthvader;see pull request https://github.com/groovy/groovy-core/pull/295;;;","05/Dec/13 18:13;paulk;fix applied - thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Call site caching bug prevents NumberNumber* call sites from going fast path,GROOVY-6469,12817249,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,04/Dec/13 03:58,15/Oct/15 18:19,14/Jul/23 06:01,04/Dec/13 04:49,,,,,,,,,,,,,,,,,,2.2.2,,,,,,,,0,,,,,,,"In every {{NumberNumber}} call site class, there's a call check which always return false:

{code}
if (checkCall(receiver)) {
                    return ((Integer) receiver).doubleValue() + ((Float) arg).doubleValue();
                }
{code}

which should be:

{code}
if (checkCall(receiver, arg)) {
                    return ((Integer) receiver).doubleValue() + ((Float) arg).doubleValue();
                }
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-12-04 03:58:33.0,,,,,,,,,,"0|i2c0a7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
List#sort(Comparable) conflict with jdk8,GROOVY-6465,12817257,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,blackdrag,blackdrag,02/Dec/13 09:14,28/Apr/14 19:30,14/Jul/23 06:01,25/Apr/14 02:26,,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,groovy-jdk,jdk conflict,,,0,breaking,,,,,,List#sort(Comparable) is a new default method on List and conflicts with out own sort method on Iterable ad for Groovy 1.8 on List,,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-12-02 09:14:49.0,,,,,,,,,,"0|i2cnwf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
antlib.xml is missing from jars,GROOVY-6464,12817092,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,pschumacher,kyrill007,kyrill007,01/Dec/13 11:38,15/Oct/15 18:19,14/Jul/23 06:01,01/Dec/13 16:00,2.0.6,2.1.9,2.2.0,2.2.1,,,,,,,,,,,,,,2.2.2,,,,Ant integration,,,,0,,,,,,,"We just tried to upgrade our Ant based build that uses Groovy to Groovy 2.2.0, and to our surprise the jar no longer contains antlib.xml file, which basically breaks all of our Ant tasks that Ant antlibs support to bring in Groovy tasks:

  <taskdef uri=""antlib:org.codehaus.groovy""
             resource=""org/codehaus/groovy/antlib.xml""
             classpathref=""groovy.path.id""/>

I believe this should be fixed rather urgently as it literally prevents users to upgrade to new versions of Groovy.",,kyrill007,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 01 16:00:50 UTC 2013,,,,,,,,,,"0|i2cewn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Dec/13 15:45;kyrill007;The last version to have it appears to be 2.0.5. To be completely precise I checked 2.0.8 and it is not there.;;;","01/Dec/13 15:58;pschumacher;antlib.xml is not only missing from the embeddable groovy-all.jar, but also from the groovy-ant.jar. :(

I changed the title to reflect this.;;;","01/Dec/13 16:00;pschumacher;Thanks for reporting. :) I fixed it with [this commit|https://github.com/groovy/groovy-core/commit/6fdb5eadbdc5b71473170aa4b18115346a0c3c93].;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Difference between @Grab behavior during compilation and at runtime,GROOVY-6462,12817255,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,01/Dec/13 05:19,07/Apr/15 19:07,14/Jul/23 06:01,02/Dec/13 14:38,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,,,,,0,,,,,,,the Grape.grab statements added for runtime execution of @Grab annotations are at a slightly different level of granularity than the compile-time behavior.,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-12-01 05:19:40.0,,,,,,,,,,"0|i2btlb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static method not found when called from within closure in child class,GROOVY-6460,12818482,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ket,ket,29/Nov/13 03:48,17/Dec/14 13:25,14/Jul/23 06:01,25/Oct/14 03:08,2.1.7,2.2.1,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,groovy-runtime,,,,0,,,,,,,"As of groovy 2.1.7, a static method is not found when it is called from within a closure in a child class.

Example:
{code}class Superclass {
    static SuperclassStaticMethod() {
        return ""A""
    }
}

class Closureclass extends Superclass {
    static closuremethod = {
        return ""B"" + SuperclassStaticMethod() // this should be found
    }
}

assert Closureclass.closuremethod() == ""BA""{code} 

Before groovy 2.1.7, this would work fine. As of groovy 2.1.7, including 2.2.1, this will result in a:

{quote}groovy.lang.MissingMethodException: No signature of method: Closureclass$__clinit__closure1.SuperclassStaticMethod() is applicable for argument types: () values: []
	at Closureclass$__clinit__closure1.doCall(closureSimple.groovy:9)
	at Closureclass$__clinit__closure1.doCall(closureSimple.groovy)
	at closureSimple.run(closureSimple.groovy:13){quote}
	
I suspect https://jira.codehaus.org/browse/GROOVY-5261 (Fix Version/s: 2.1.7, 2.2.0-beta-2) may be a cause.",,kt8,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Oct 25 03:08:31 UTC 2014,,,,,,,,,,"0|i2c92n:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"25/Oct/14 03:08;pschumacher;The example works again on current master.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
File.eachFileMatch is inconsistent with File.eachFile and incurs extra stat() syscalls,GROOVY-6457,12818275,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ericdahl,ericdahl,27/Nov/13 21:07,04/Mar/14 16:31,14/Jul/23 06:01,28/Nov/13 23:31,2.2.1,,,,,,,,,,,,,,,,,2.2.2,,,,groovy-jdk,,,,0,,,,,,,"[ResourceGroovyMethods#eachFileMatch|http://groovy.codehaus.org/groovy-jdk/java/io/File.html#eachFileMatch%28groovy.io.FileType,%20java.lang.Object,%20groovy.lang.Closure%29] iterates over each file/directory in a directory, while [ResourceGroovyMethods#eachFile|http://groovy.codehaus.org/groovy-jdk/java/io/File.html#eachFile%28groovy.io.FileType,%20groovy.lang.Closure%29] instead iterates over every directory entry, including things which aren't files or directories (e.g., fifos and sockets). {{eachFileMatch}} should behave similar to {{eachFile}}

Here's a demonstration showing that the methods return different results when iterating over everything:
{code}
[ecd@qk /tmp/tmp12345]$ ls -alF
total 36
drwxr-xr-x    2 ecd   wheel    512 Nov 27 20:46 ./
drwxrwxrwt  269 root  wheel  32256 Nov 27 20:20 ../
-rw-r--r--    1 ecd   wheel      0 Nov 27 20:13 .hidden
-rw-r--r--    1 ecd   wheel      0 Nov 27 20:13 bar
prw-r--r--    1 ecd   wheel      0 Nov 27 20:16 fifo|
-rw-r--r--    1 ecd   wheel      0 Nov 27 20:13 foo1
-rw-r--r--    1 ecd   wheel      0 Nov 27 20:13 foo2
-rw-r--r--    1 ecd   wheel      0 Nov 27 20:13 foo3
-rw-r--r--    1 ecd   wheel      0 Nov 27 20:13 foo4
-rw-r--r--    1 ecd   wheel      0 Nov 27 20:13 foo5
lrwxr-xr-x    1 ecd   wheel      4 Nov 27 20:46 symlink@ -> foo3
[ecd@qk /tmp/tmp12345]$ groovysh
Groovy Shell (2.2.1, JVM: 1.7.0_25)
Type 'help' or '\h' for help.
------------------------------------------------------------------------------------------------------------------------------------------------------
groovy:000> i = 0
===> 0
groovy:000> new File(""."").eachFile { ++i }
===> null
groovy:000> i
===> 9
groovy:000> j = 0
===> 0
groovy:000> new File(""."").eachFileMatch(~/.*/) { ++j }
===> null
groovy:000> j
===> 8
{code}


Furthermore, due to the lack of a check in {{eachFileMatch}} for the {{FileType.ANY}} case, it causes {{File.isFile()}} and {{File.isDirectory()}} to be called for every directory entry. This can be a significant performance impact particularly on slow NFS mounts in directories with thousands of files.

The extra {{stat}} syscalls can be seen with another demo, using the same directory structure as above:
{code}
class FileTests {

    def basic() { // 0 stats
        for (File f : new File(""/tmp/tmp12345"").listFiles()) { }
    }

    def groovyEachFile() {
        new File(""/tmp/tmp12345"").eachFile { }
    }

    def groovyEachFileMatch() {
        new File(""/tmp/tmp12345"").eachFileMatch(~/.*/) { }
    }

    def groovyEachFileRecurse() {
        new File(""/tmp/tmp12345"").eachFileRecurse { }
    }

    public static void main(String[] args) {
        FileTests fileTests = new FileTests();
        FileTests.getMethod(args[0]).invoke(fileTests);
    }
}
{code}
and truss/strace/dtrace will show the system calls for each:
{code}
[ecd@qk ~]$ (for m in basic groovyEachFile groovyEachFileMatch groovyEachFileRecurse; do echo $m $(truss groovy FileTests.groovy $m 2>&1 | grep tmp12345 | grep -c stat); done) | column -t
basic                  0
groovyEachFile         2
groovyEachFileMatch    20
groovyEachFileRecurse  11
{code}

",,ericdahl,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 28 23:31:53 UTC 2013,,,,,,,,,,"0|i2brz3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"27/Nov/13 21:52;ericdahl;I've submitted a pull request for this: https://github.com/groovy/groovy-core/pull/290;;;","28/Nov/13 23:31;paulk;Nice catch. Proposed PR merged. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractHttpServlet.applyResourceNameMatcher race condition,GROOVY-6456,12818489,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,rybin.andrey@gmail.com,rybin.andrey@gmail.com,27/Nov/13 13:15,05/Apr/14 00:00,14/Jul/23 06:01,13/Jan/14 09:27,2.2.0,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,Groovlet / GSP,,,,0,breaking,,,,,,"groovy.servlet.AbstractHttpServlet#applyResourceNameMatcher uses java.util.regex.Matcher object in this way:

matcher.reset(uri);

but Matcher is NOT ThreadSafe!

javadoc:
Instances of this class are not safe for use by multiple concurrent threads.

Pattern class IS thread safe.


stacktrace from bug demo
2013-12-01 23:36:50.009:WARN:oejs.ServletHandler:/1Test.groovy
java.lang.IndexOutOfBoundsException: start 0, end -1, s.length() 14
	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:476)
	at java.lang.StringBuffer.append(StringBuffer.java:309)
	at java.util.regex.Matcher.appendReplacement(Matcher.java:839)
	at java.util.regex.Matcher.replaceAll(Matcher.java:906)
	at groovy.servlet.AbstractHttpServlet.applyResourceNameMatcher(AbstractHttpServlet.java:303)
	at groovy.servlet.AbstractHttpServlet.getScriptUri(AbstractHttpServlet.java:290)
	at groovy.servlet.GroovyServlet.service(GroovyServlet.java:105)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:847)

",,blackdrag,guillaume,magicprinc,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"02/Dec/13 07:10;AbstractHttpServlet.java;https://issues.apache.org/jira/secure/attachment/12722193/AbstractHttpServlet.java","03/Dec/13 09:30;AbstractHttpServlet.perf.java;https://issues.apache.org/jira/secure/attachment/12722398/AbstractHttpServlet.perf.java","01/Dec/13 13:40;groovyServlet_MatcherBug.zip;https://issues.apache.org/jira/secure/attachment/12723136/groovyServlet_MatcherBug.zip",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 13 09:27:42 UTC 2014,,,,,,,,,,"0|i2bx3b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Dec/13 13:40;rybin.andrey@gmail.com;bug demo. 
$ groovy runme;;;","01/Dec/13 16:08;pschumacher;Thanks for reporting. :)

If you like to you can send us a pull request with a fix. Else I will take a look in the next few days if nobody else beats me to it.;;;","02/Dec/13 03:06;rybin.andrey@gmail.com;bug fixed, little optimized version;;;","02/Dec/13 03:08;rybin.andrey@gmail.com;Sorry, no time for pull, but new version attached.;;;","02/Dec/13 07:10;rybin.andrey@gmail.com;Matcher bug fixed. 
optimization. 
'NPE in war' bug fixed.;;;","02/Dec/13 08:04;rybin.andrey@gmail.com;during test process I found strange GroovyScripEngine behavior. I doubt: is it normal?

//Groovlet1.groovy
println DS //DS exists in binding

getResourceConnection was called several times:
//getScriptUri: /nsa/Groovlet1.groovy -> /Groovlet1.groovy
getResourceConnection: /Groovlet1.groovy
getResourceConnection: java/lang/DS.groovy
getResourceConnection: java/io/DS.groovy
getResourceConnection: java/net/DS.groovy
getResourceConnection: java/util/DS.groovy
getResourceConnection: groovy/lang/DS.groovy
getResourceConnection: groovy\lang\DS.groovy
getResourceConnection: groovy/util/DS.groovy
getResourceConnection: groovy\util\DS.groovy
getResourceConnection: DS.groovy
getResourceConnection: DS.groovy
getResourceConnection: java/lang/Groovlet1$DS.groovy
getResourceConnection: java/io/Groovlet1$DS.groovy
getResourceConnection: java/net/Groovlet1$DS.groovy
getResourceConnection: java/util/Groovlet1$DS.groovy
getResourceConnection: groovy/lang/Groovlet1$DS.groovy
getResourceConnection: groovy/util/Groovlet1$DS.groovy
getResourceConnection: Groovlet1$DS.groovy
getResourceConnection: Groovlet1BeanInfo.groovy
getResourceConnection: Groovlet1Customizer.groovy
;;;","02/Dec/13 12:57;pschumacher;Hi Andrej, 

np about the pull request. Thanks for the fixed version. :) I converted it to a [pull request|https://github.com/groovy/groovy-core/pull/294] to make reviewing easier.

Sadly I do not know if the GroovyScripEngine behavior is normal. Maybe blackdrag blackdrag or somebody else can comment on this?

;;;","02/Dec/13 13:29;guillaume;Regarding the behavior of GroovyScriptEngine, yes, that's its normal behavior, to try and find where DS is coming from. Seeing it looks like it's a capitalized name, Groovy thinks it might be a class, so it tries to find where that DS class could be coming from.;;;","03/Dec/13 06:06;rybin.andrey@gmail.com;Could You inspect new 'performant' version and do another pull request for it?
I did some obvious optimizations, so it should be faster.

AbstractHttpServlet.perf.java
*Matcher bugfix. 
*NPE in war bugfix.
*more optimizations;;;","11/Dec/13 15:20;pschumacher;I updated the pull request with the new version (AbstractHttpServlet.perf.java) of the patch.;;;","13/Jan/14 09:27;blackdrag;We decide to apply this even though it is a breaking change. But we think the feature is not used much and the fix is easy to do. So we think it is more important to fix the race condition here. thanks for the contribution;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic and @Delegate with generics causes compilation failure,GROOVY-6455,12818269,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,acourtneybrown,acourtneybrown,27/Nov/13 11:56,15/Oct/15 18:19,14/Jul/23 06:01,01/Dec/13 07:59,2.1.9,2.2.1,,,,,,,,,,,,,,,,2.2.2,,,,Static compilation,,,,4,,,,,,,"{code}
@groovy.transform.CompileStatic
class IntList {
	@Delegate List<Integer> delegate
}
{code}

compiling this code yields the following compilation error.

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during class generation: Internal compiler error while compiling /Users/abrown/tmp/groovy/test.groovy
Method: MethodNode@1827580455[boolean add(java.lang.Object)]
Line -1, expecting casting to boolean but operand stack is empty

java.lang.ArrayIndexOutOfBoundsException: Internal compiler error while compiling /Users/abrown/tmp/groovy/test.groovy
Method: MethodNode@1827580455[boolean add(java.lang.Object)]
Line -1, expecting casting to boolean but operand stack is empty
	at org.codehaus.groovy.classgen.asm.OperandStack.doConvertAndCast(OperandStack.java:327)
	at org.codehaus.groovy.classgen.asm.OperandStack.doGroovyCast(OperandStack.java:294)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:584)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:543)
	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:357)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:314)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:434)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:177)
	at org.codehaus.groovy.control.CompilationUnit$15.call(CompilationUnit.java:794)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:279)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:258)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:244)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:185)
	at groovy.lang.GroovyShell$2.run(GroovyShell.java:206)
	at groovy.lang.GroovyShell$2.run(GroovyShell.java:204)
	at java.security.AccessController.doPrivileged(Native Method)
	at groovy.lang.GroovyShell.run(GroovyShell.java:204)
	at groovy.lang.GroovyShell.run(GroovyShell.java:150)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:588)
	at groovy.ui.GroovyMain.run(GroovyMain.java:375)
	at groovy.ui.GroovyMain.process(GroovyMain.java:361)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:120)
	at groovy.ui.GroovyMain.main(GroovyMain.java:100)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)

1 error
{code}

Without the @CompileStatic annotation, the code compiles and works correctly.  Additionally, using the raw type (ie: List, in this case), also compiles successfully and works.  I also tried this with other generic types (Map, Collection, etc) and it produces similar compilation errors, but for different methods.

Lastly, the following code works, where the generic type parameter comes from the class declaring the @Delegate field
{code}
@groovy.transform.CompileStatic
class TList<T> {
	@Delegate Collection<T> delegate
}
{code}",,acourtneybrown,blackdrag,gcadien,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 01 07:59:24 UTC 2013,,,,,,,,,,"0|i2cpk7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Dec/13 07:59;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Can't delegate (with the @Delegate annotation) to a method whose name contains a dollar ($) character,GROOVY-6454,12817079,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,chocolateboy,chocolateboy,25/Nov/13 11:27,02/May/17 02:03,14/Jul/23 06:01,13/Apr/16 07:47,2.2.0,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,Compiler,xforms,,,0,regression,,,,,,"As of 2.2.0 it's no longer possible to delegate (via the @Delegate annotation) to a method whose name contains a dollar ($) character. The attached test case compiles and runs without error under Groovy 2.1.3 and 2.1.6, but fails to compile with the following error under 2.2.0:

> Caught: groovy.lang.MissingMethodException: No signature of method: Delegating.te$t() is applicable for argument types: (java.lang.Integer) values: [42]
> Possible solutions: test(java.lang.Integer), wait(), getAt(java.lang.String), wait(long), wait(long, int), dump()
","Linux (Ubuntu 12.04), Java SE (Oracle) 1.7.0_45-b18, Groovy 2.2.0",blackdrag,chocolateboy,erdi,githubbot,keegan,melix,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7073,,,,,,,,,,,,,,,,,,,,,"25/Nov/13 11:27;chocolateboy;dollar_delegate.groovy;https://issues.apache.org/jira/secure/attachment/12722666/dollar_delegate.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 13 07:47:40 UTC 2016,,,,,,,,,,"0|i2bt5r:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"25/Nov/13 13:07;blackdrag;I did not check for GROOVY_2_1_X, but in groovy 2.1.9 it works and in 2.2.0 not
;;;","26/Nov/13 04:33;melix;The change was introduced by 54360738ab13ce86381cb7e59840e33d8962ec93. It includes a refactor to use `shouldSkip` method in common with various AST transformations (ToString, EqualsAndHashCode, ...). This method explicitely excludes methods whose name include a dollar (probably considered as internal or generated methods).;;;","26/May/14 10:43;pschumacher;So what are we going to do about this?

@Paul: As [https://github.com/groovy/groovy-core/commit/54360738ab13ce86381cb7e59840e33d8962ec93] was done by you, maybe you can comment on this issue?;;;","14/Sep/14 01:54;pschumacher;Marcin Erdmann (from the closed duplicate of this issue): 
{quote}This is a blocking issue for Geb. It's impossible to compile it using latest Groovy which prevents us from updating the version used to build it - it's still using 1.8.9.{quote};;;","14/Sep/14 02:15;erdi;Saying that it is blocking was a bit of an exaggeration maybe... We can always generate these methods by hand/using IDE where we need it but it would be more convenient if we could use that annotation. Looks like the simplest fix would be to allow forcing inclusion of methods having $ in their name by specifying it in includes().

I would be happy to provide a pull request with such change if you are happy with that solution.;;;","16/Sep/14 19:14;paulk;@EqualsAndHashCode, @ToString, @TupleConstructor, @Builder and @Delegate all skip over properties, fields and/or methods containing '$'. One solution might be to add an allNames boolean which could be set to true to avoid this default behavior. It could be made available for @Delegate to start with and potentially some of the others if there is a real need. Would this be suitable?;;;","20/Feb/16 19:52;erdi;[~paulk] Adding such {{allNames}} boolean to {{@Delagate}} would be beneficial and allow removal of a significant number of manually written delegating methods in Geb. I'd be happy to contribute such improvement if you'd be interested in accepting it.;;;","21/Feb/16 23:30;paulk;I think such a change would be interesting (for 2.5+ only) as long as it was consistent, i.e. it would apply to not just @Delegate but the other impacted transforms that make use of {{AbstractASTTransformation#shouldSkip}} or {{AbstractASTTransformation#shouldSkipUndefinedAware}}, namely: @EqualsAndHashCode, @ToString, @TupleConstructor and @Builder (all strategies). The existing method calls within AbstractASTTransformation would need to remain and an overloaded version with an {{allNames}} boolean added. We need to wire the new method into those transforms and update the doco and tests.;;;","22/Feb/16 20:48;erdi;Awesome, I will look into it when I have some spare cycles. Looks like I finally found something that I can contribute to Groovy. I will write to the dev mailing list if I have questions or problems. Thanks for outlining in detail what will need to be done for the contribution to be accepted.;;;","22/Feb/16 22:01;paulk;Cool. Good luck. And do shout if you have any further questions.;;;","30/Mar/16 18:44;githubbot;GitHub user erdi opened a pull request:

    https://github.com/apache/groovy/pull/299

    Fix for GROOVY-6454

    Add allNames option which allows to include fields/properties/methods with internal names in code generated by Builder, Delegate, EqualsAndHashCode, MapConstructor, ToString and TupleConstructor AST transformations.
    
    I've added tests and updated javadocs and the guide around these new options.
    
    Please let me know if there is anything that needs to be changed, especially in the area of documentation, I'm happy to rework it.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/erdi/groovy GROOVY-6454

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/299.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #299
    
----

----
;;;","30/Mar/16 18:45;githubbot;Github user erdi commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/299#discussion_r57941783
  
    --- Diff: src/spec/test/ClassDesignASTTransformsTest.groovy ---
    @@ -189,14 +189,14 @@ class NumberBooleanBuilder {
         StringBuilder nums = new StringBuilder()
         @Delegate(includeTypes=[AppendFloatSelector], interfaces=false)
         StringBuilder bools = new StringBuilder()
    -    String result() { ""${nums.toString()} | ${bools.toString()}"" }
    +    String result() { ""${nums.toString()} ~ ${bools.toString()}"" }
    --- End diff --
    
    This had to be changed because using a pipe here broke the formatting of asciidoc table this snippet was used in.
;;;","30/Mar/16 18:49;erdi;Hopefully the submitted pull request is what you are after, [~paulk]. Let me know if anything in there needs more work.;;;","13/Apr/16 05:42;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/299
;;;","13/Apr/16 07:47;paulk;PR applied, thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovysh in Windows 7/8/10 doesn't support arrow keys and Del,GROOVY-6453,12818474,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,rybin.andrey@gmail.com,rybin.andrey@gmail.com,25/Nov/13 04:36,07/Dec/20 22:09,14/Jul/23 06:01,11/Nov/20 08:31,2.2.0,,,,,,,,,,,,,,,,,3.0.7,4.0.0-alpha-2,,,Groovysh,,,,10,console,jline,,,,,"I have bare windows 8 with fresh JDK. I run Groovysh in cmd.exe.
Groovysh 2.1.9 works as expected.

Groovysh 2.2.0 doesn't react to arrow keys and Del, i.e. up key doesn't show previous command, left key doesn't shift cursor etc.

After some investigation I found what is working:
ctrl-a   go to beginning of line
ctrl-e   go to End of line
ctrl-f   go Forward one char
ctrl-b   go Backward one char
ctrl-d   delete the char
ctrl-h   and backspace = delete left char
ctrl-p   recall previous line
ctrl-n   recall next line
ctrl-s   search
ctrl-r   reverse search 
It's nice and feel myself like a Linux hacker, but I want arrow keys too ;-)

I tried different options:
- upgrade jline2.10 to 2.11 - no effect
- --terminal=unix - it helps, but duplicate prompt (groovy:000>) and no more colors in console 


Looks like problem lies in new jline v2 (groovysh 2.1.9 uses jline1.0)","Windows 8, 64bit (v6.2, build 9200), java version ""1.7.0_45"" SE Runtime Environment (build 1.7.0_45-b18) HotSpot 64-Bit Server VM (build 24.45-b08, mixed mode), Russian locale (!)",akiraly,daniel_sun,darksnake,deisner,glockenstein,graemerocher,guyr,lhotari,magicprinc,ninside,pluradj,pschumacher,qaston,wayyoung,webczat,"danielsun1106 opened a new pull request #1413:
URL: https://github.com/apache/groovy/pull/1413


   …d Del


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Nov/20 13:28;githubbot;600","danielsun1106 merged pull request #1413:
URL: https://github.com/apache/groovy/pull/1413


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;11/Nov/20 04:35;githubbot;600",,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6859,,,,,,"08/Sep/20 00:03;ninside;image-2020-09-07-20-03-41-004.png;https://issues.apache.org/jira/secure/attachment/13011194/image-2020-09-07-20-03-41-004.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 08 13:28:56 UTC 2020,,,,,,,,,,"0|i2cabj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Nov/13 09:32;graemerocher;Reported JLine issue https://github.com/jline/jline2/issues/115;;;","26/Nov/13 10:31;graemerocher;Original issue https://github.com/jline/jline2/issues/100

115 was closed as a duplicate;;;","26/Nov/13 12:09;pschumacher;Apparently this error does not occur for all locales. I can replicate it with Windows 7 and a german locale.

This workaround mentioned in the jline issue works for me: 

{quote}The other, less nice, workaround is to just use (assuming emacs mode) Control-n for down and Control-p for up{quote};;;","12/Apr/14 03:59;pschumacher;The jline 2 issue was [fixed|https://github.com/jline/jline2/pull/134]. Now we just have to wait for a jline 2 release.;;;","07/Jun/14 08:36;webczat;Actually the issue was fixed, but arrows still don't work and I believe it is groovy's fault this time.
I've tested jline-2.11 and 2.12 and a custom test application, 2.11 gives some strange characters when pressing arrows, 2.12 works.
Note that when groovy is running and jline-2.11 is used nothing at all shows on the screen when pressing arrows, and trace does not give the event on keypress, the same in jline 2.12.;;;","08/Jun/14 05:10;webczat;This bug is caused by the fact that jline2 now reads keys from console using winapi functions, but before that, it checks if the InputStream passed to the ConsoleReader is System.in or a FileInputStream attached to the stdin file descriptor.
groovysh wraps System.in in it's own stream and that causes this problem.
I've tested it using a program that just created a ConsoleReader and performed reader.readLine() in an infinite loop.
Everything was ok when System.in was passed, but it broke when System.in has been wrapped in a BufferedInputStream.
The results were identical.;;;","09/Jun/14 03:45;pschumacher;Hi Micha,

thanks for your analysis. :) Any ideas on how to fix this?;;;","09/Jun/14 04:28;webczat;Actually, I am not sure, because I do not know what this wrapper stream is doing.
The easiest thing would be to just remove a wrapper completely.
If you would reset System.in to a wrapper it will work but I believe it would skip the wrapper completely, because jline uses windows console api to read keys in this case and does not probably use System.in.
I didn't do an in-depth analysis of everything, so I am not sure about the possible ways to go except removing a wrapper.;;;","10/Jun/14 00:43;lhotari;jline 2.12 is available in maven central now http://search.maven.org/#artifactdetails%7Cjline%7Cjline%7C2.12%7Cjar;;;","11/Jun/14 13:13;lhotari;FYI, We are using jline 2.12 in Grails now. Jline has changed the way how UnixTerminal.restore() behaves. 
We had to do this hack for Grails:
https://github.com/grails/grails-core/commit/113d9c2b
because of this change in jline 2.12:
https://github.com/jline/jline2/commit/187cc08f
Just to make you aware of the problems we had in Grails when upgrading to jline 2.12 . 
jline 2.12 did fix the issues with Windows terminals.

It might be better to use something like this in a shell script to save and restore terminal settings:
{code}
saved_terminal_settings=$(stty -g)
call the app
stty ""$saved_terminal_settings""
{code}
this is what jline is trying to do, but for some reason that doesn't work for Grails.
;;;","02/Jul/14 10:17;glockenstein;I tested the beta of groovy 2.4.0 with jline 2.12 under windows 7 and arrow keys still do not work.;;;","20/Apr/15 16:07;webczat;As I said few months ago, this is *NOT* a jline bug, but a groovy bug (see comments above). And I am not surprised it still doesn't work, and it seems that it also doesn't work for my friend (I myself still didn't update groovy to the latest version actually).;;;","28/May/15 00:00;wayyoung;I am using groovysh 2.4.3 + jline2 2.12.1 on windows 7 with Chinese locale. 
The arrow keys are not worked.
As your analyzing, I modified the isSystemIn(...) in WindowsTerminal.java from jline2 to always return true.
Now the arrow keys are worked.
Thank you very much!!
;;;","11/Jun/15 14:17;webczat;Okay, but this still should be fixed, and actually it is not a jline bug, unless we expect jline to add an override that says: this is really a console. Othervise groovy has to do something.;;;","15/Jun/15 15:21;pluradj;This works for me to enable arrow keys `-Djline.terminal=none`.

I haven't spent a long time in these packages, so I'm not really clear what I'm missing out on with this setting -- see WindowsTerminal.java from jline, and the WrappedInputStream usage in InteractiveShellRunner.groovy from groovy-groovysh. jline doesn't detect that the input stream is actually stdin because groovysh wrappers it.

jline acknowledges that it is a bit messy...
https://github.com/jline/jline2/blob/master/src/main/java/jline/WindowsTerminal.java#L77

https://github.com/jline/jline2/blob/master/src/main/java/jline/WindowsTerminal.java#L170

https://github.com/apache/incubator-groovy/blob/master/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/InteractiveShellRunner.groovy#L49
;;;","03/Feb/16 20:16;deisner;""I'm not really clear what I'm missing out on with this setting""

In my case (groovysh launced from Windows 7 cmd.exe), setting jline.terminal to none does fix the arrow key history browsing, but it breaks tab-completion. :^(;;;","14/Nov/17 21:45;qaston;You can add the following code to your groovy.rc as a workaround:
{noformat}
@groovy.transform.InheritConstructors
class WindowsTerminalControlCharFix extends jline.WindowsTerminal {
	@Override
	protected boolean isSystemIn(java.io.InputStream i) throws IOException {
			// groovysh wraps the input stream in WrappedInputStream, need to handle this case properly to enable windows controll character handling
			if (i instanceof org.codehaus.groovy.tools.shell.util.WrappedInputStream) {
					return super.isSystemIn(((org.codehaus.groovy.tools.shell.util.WrappedInputStream)i).wrapped);
			}
			return super.isSystemIn(i);
	}
}

// if no terminal specified use a version of windows terminal class that handles windows control characters properly - see https://issues.apache.org/jira/browse/GROOVY-6453
if (!System.getProperty(""jline.terminal"")) {
	jline.TerminalFactory.registerFlavor(jline.TerminalFactory.Flavor.WINDOWS, WindowsTerminalControlCharFix.class);
	System.setProperty(""jline.terminal"",""win"");
}
{noformat};;;","29/Oct/18 05:28;guyr;Found this via search.  I'm on Windows 7 64-bit, and tried both groovy-2.6.0-alpha-3 and groovy-3.0.0-alpha-3.  Cursor keys are not working in either one.  I'm surprised to see this issue is now 5 years old.  Is there some basic restriction preventing this from being corrected in groovysh?

I tried creating a groovy.rc file containing the contents from the previous post by Dariusz Antoniuk, but don't know where to put it.  I tried in \groovy-3.0.0-alpha-3\bin, \groovy-3.0.0-alpha-3\conf, and C:\Users\<myusername>\.groovy, and it still didn't work.

[UPDATE]

Found this post that says the file to update is actually groovysh.rc.  

https://stackoverflow.com/questions/52898321/groovysh-rc-file-breaks-groovysh-evaluate-switch

So I updated that in my home directory.  Now I'm getting a NullPointerException:

D:\>groovysh
Picked up JAVA_TOOL_OPTIONS: -Duser.timezone=GMT
FATAL: java.lang.NullPointerException
java.lang.NullPointerException
        at java.util.concurrent.ConcurrentHashMap.replaceNode(ConcurrentHashMap.java:1106)
        at java.util.concurrent.ConcurrentHashMap.remove(ConcurrentHashMap.java:1097)
        at org.codehaus.groovy.runtime.memoize.UnlimitedConcurrentCache.remove(UnlimitedConcurrentCache.java:70)
        at groovy.lang.GroovyClassLoader.removeClassCacheEntry(GroovyClassLoader.java:640)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.runtime.callsite.PlainObjectMetaMethodSite.doInvoke(PlainObjectMetaMethodSite.jav
        at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoCachedMethodSiteNoUnwrapNoCoerce.invoke(P
ethodSite.java:213)
        at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:55)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:47)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:128)
        at org.codehaus.groovy.tools.shell.Interpreter.evaluate(Interpreter.groovy:96)
        at org.codehaus.groovy.tools.shell.Evaluator$evaluate.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:47)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:128)
        at org.codehaus.groovy.tools.shell.Groovysh.evaluateWithStoredBoundVars(Groovysh.groovy:263)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.runtime.callsite.PlainObjectMetaMethodSite.doInvoke(PlainObjectMetaMethodSite.jav
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(P
ethodSite.java:190)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:58)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:51)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:157)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:177)
        at org.codehaus.groovy.tools.shell.Groovysh.execute(Groovysh.groovy:204)
        at org.codehaus.groovy.tools.shell.Shell.leftShift(Shell.groovy:122)
        at org.codehaus.groovy.tools.shell.Shell$leftShift$0.call(Unknown Source)
        at org.codehaus.groovy.tools.shell.commands.LoadCommand$_load_closure1.doCall(LoadCommand.groovy:86)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:104)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:326)
        at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:264)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1043)
        at groovy.lang.Closure.call(Closure.java:421)
        at org.codehaus.groovy.runtime.DefaultGroovyMethods.callClosureForLine(DefaultGroovyMethods.java:5913)
        at org.codehaus.groovy.runtime.IOGroovyMethods.eachLine(IOGroovyMethods.java:463)
        at org.codehaus.groovy.runtime.IOGroovyMethods.eachLine(IOGroovyMethods.java:416)
        at org.codehaus.groovy.runtime.ResourceGroovyMethods.eachLine(ResourceGroovyMethods.java:349)
        at org.codehaus.groovy.runtime.ResourceGroovyMethods.eachLine(ResourceGroovyMethods.java:333)
        at org.codehaus.groovy.runtime.dgm$989.invoke(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(Poj
hodSite.java:246)
        at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:55)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:47)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:128)
        at org.codehaus.groovy.tools.shell.commands.LoadCommand.load(LoadCommand.groovy:82)
        at org.codehaus.groovy.tools.shell.commands.LoadCommand$load.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:47)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:128)
        at org.codehaus.groovy.tools.shell.Groovysh.loadUserScript(Groovysh.groovy:400)
        at org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:588)
        at org.codehaus.groovy.tools.shell.Groovysh$run$0.callCurrent(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:51)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:157)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:169)
        at org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:577)
        at org.codehaus.groovy.tools.shell.Groovysh$run.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:47)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:136)
        at org.codehaus.groovy.tools.shell.Main.startGroovysh(Main.groovy:193)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.runtime.callsite.PlainObjectMetaMethodSite.doInvoke(PlainObjectMetaMethodSite.jav
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(P
ethodSite.java:190)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:70)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:47)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:136)
        at org.codehaus.groovy.tools.shell.Main.main(Main.groovy:159)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:114)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:136);;;","08/Sep/20 00:03;ninside;[~qaston] I put the code snippet right inside my shell wrapper. It does restore arrow keys functionality! Thanks for the suggestion.

However now the cursor itself stays on the previous line (the line that was restored from history and executed).

I am on windows 10. 

 

!image-2020-09-07-20-03-41-004.png!;;;","08/Sep/20 00:56;ninside;hmm hyper.js doesn't have that behavior. So maybe it is windows terminal issue...;;;","08/Nov/20 13:27;daniel_sun;[~pluradj] Your suggestion works for me. Thanks a lot!;;;","08/Nov/20 13:28;daniel_sun;[~pluradj] Here is the PR based on your suggestion:
https://github.com/apache/groovy/pull/1413;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Grab group element is documented as optional but the implementation requires it,GROOVY-6452,12817219,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,pschumacher,pschumacher,24/Nov/13 15:33,17/Dec/14 13:25,14/Jul/23 06:01,26/Aug/14 22:05,2.1.9,,,,,,,,,,,,,,,,,2.3.7,2.4.0-beta-3,,,Documentation,Grape,,,0,,,,,,,"The javadoc for {{@Grab}} lists {{group}} as an optional element. However, it is no more optional than {{module}} or {{version}} (which are both listed as required).",,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 27 13:06:53 UTC 2014,,,,,,,,,,"0|i2cmvb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Nov/13 15:58;paulk;This will be the same story as for {{GrabExclude}}. They are all required unless the 'value' shorthand convenience form is used, so in that sense they are all optional. They should of course be consistent. I vaguely remember some problem with making some of them optional - hopefully that was something to do with very old Java versions and has gone away. In any case, the groovydoc could be improved.

Just a technical note: the code in GAT sets the version to ""*"" if it is left out and all the values when the Maven or Ivy compact forms are used - so by the time the annotation is being looked at later, all of the attributes are filled in correctly. However, to provide proper assistance to IDEs/code checkers we would want the convenience form to be valid in source form from a Java definition point of view.;;;","25/Nov/13 11:28;pschumacher;Thanks for the info Paul. :) I will investigate/test. I just created the issue so I do not forget it.;;;","26/Aug/14 06:10;paulk;Assuming we merge https://github.com/groovy/groovy-core/pull/506 then we could make use of {{Undefined.STRING}} to tidy up the different default values within {{@Grab}}.;;;","26/Aug/14 20:21;paulk;Turns out that empty String values were good enough since an empty String isn't a valid value for any of Grab's use cases, so a special undefined value wasn't needed.;;;","26/Aug/14 22:05;paulk;Change made - hope that's ok;;;","27/Aug/14 13:06;pschumacher;Sure. Great solution. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Support repository roots in @GrabResolver should work correctly for relative hrefs,GROOVY-6451,12811796,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jimwhite,jimwhite,jimwhite,24/Nov/13 14:37,05/Apr/15 14:44,14/Jul/23 06:01,06/Apr/14 01:42,1.8.9,2.2.0,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,Grape,,,,0,grabresolver,,,,,,"@GrabResolver fails to correctly interpret the root URL values as hrefs when they are relative.  This is a long-standing cause of Groovy scripts being unable to be distributed with non-centrally managed dependencies.

While Grape is great when dependencies are in repositories that are independent of the source files that use them, it is often the case that a source file (especially Groovy script files) and it's JAR dependencies are most naturally managed together.  This improvement to Grape allows the root attribute of the @GrabResolver annotation to be relative to the source file in which the annotation is used.  This is a completely backward-compatible change because these relative URLs are only created when the root value is not already a URL, and without this change a root value that is not a valid URL causes an error when the code is executed.

While being able to distribute an archive containing a Groovy script and its dependencies is nice and the FAQ that prompted this improvement, an even groovier use case for this feature is putting a Groovy script file and it's supporting Maven repository in a shared location and using the remote URL execution feature of the Groovy CLI.
",,guillaume,jimwhite,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Nov/13 14:41;jimwhite;patch-groovy-6451.txt;https://issues.apache.org/jira/secure/attachment/12722393/patch-groovy-6451.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Tue Nov 26 03:54:28 UTC 2013,,,,,,,,,,"0|i2bvlz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Nov/13 16:02;paulk;Looks good Jim. I was worried that perhaps on Windows there was some form of existing path containing a ':', e.g. an absolute root such as 'C:\Temp\grapes' that might break with your proposed change but I couldn't get any existing absolute URL of that form to work so I think I concur with your assessment that the change should be backward-compatible.;;;","24/Nov/13 23:32;jimwhite;Yeah, it is very safe.  Anything that has a ':' in it is not changed at all and anything that did not have a ':' wouldn't work at all before this change because it would get a MalformedURLException.  

The only thing I'm iffy about in this is using URL.toExternalForm() which is protocol-specific instead of URI.toString() which is RFC 2396.  I used the URL formatter because SourceUnit takes URLs and I don't have time to research the details right now, but the URL stuff has been largely deprecated in favor of URI because of some broken things in URL.;;;","25/Nov/13 10:49;jimwhite;What's up with removing the 2.1.10 and 1.8.10 targets?  This change (which is either and improvement or bug fix depending on your perspective) most certainly needs to go into those branches.  I also think that this fix is important enough to catch the 2.1.10 release since it is something that I think quite a few folks will find is very groovy.;;;","25/Nov/13 11:04;jimwhite;How do I get this patch applied to the GROOVY_2_2_X branch?  My git-fu is fairly basic.;;;","25/Nov/13 11:07;melix;Don't worry about the branches. We will cherry pick the change.;;;","25/Nov/13 13:45;jimwhite;At present, this will only work as intended for collocated repositories when the source files are on the local file system.  Turns out that the remote script execution (URL) feature of the Groovy CLI is *not* using the SourceUnit(URL, ...) constructor but is instead using SourceUnit(String, ...) and only passing in the base name of the URL.  I'll create a JIRA for that when I have time.;;;","26/Nov/13 03:54;guillaume;I'm changing back the fix version to just 2.3.0 for now.
Normally, such ""improvements"" are for X.Y releases, not for X.Y.Z bug fix releases.
We might see for 2.2.2 if we include it with the additional URL support you're mentioning, or if we wait for 2.3.0.
The exact roadmap and timeframe for 2.3.0 is not yet decided though, so we might consider making an exception and include that improvement in 2.2.2. 
No need to rush the integration. But this is a useful addition to @Grab!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy-module's extension method don't work by Grape Annotation(always on Java SE 8),GROOVY-6447,12811782,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,uehaj,uehaj,23/Nov/13 16:00,30/Jul/14 03:31,14/Jul/23 06:01,30/Jul/14 03:31,2.2.0-rc-3,,,,,,,,,,,,,,,,,2.3.5,,,,Grape,,,,0,,,,,,,"Similar issue to GROOVY-6446,

{code}
@Grab( 'com.bloidonia:groovy-stream:0.6.2' )
import groovy.stream.Stream

println([1,2,3].iterator().toStream())
{code}
Fails same exception
{quote}
Caught: groovy.lang.MissingMethodException: No signature of method: java.util.ArrayList$Itr.toStream() is applicable for argument types: () values: []
Possible solutions: toString(), toString(), toSet()
groovy.lang.MissingMethodException: No signature of method: java.util.ArrayList$Itr.toStream() is applicable for argument types: () values: []
Possible solutions: toString(), toString(), toSet()
	at s.run(s.groovy:5)
{quote}

With  Java 8 environment, this happens always.
And with Java 8, following code never success with same error.
{code}
groovy.grape.Grape.grab(['group': 'com.bloidonia', 'module': 'groovy-stream', 'version': '0.6.2'])
println([1,2,3].iterator().toStream())
{code}

","java version ""1.8.0-ea""
Java(TM) SE Runtime Environment (build 1.8.0-ea-b115)
Java HotSpot(TM) 64-Bit Server VM (build 25.0-b57, mixed mode)

MacOSX 10.9 marverics",paulk,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6446,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 30 03:31:31 UTC 2014,,,,,,,,,,"0|i2c18f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Nov/13 16:03;uehaj;P.S. If you put the groovy-module jar in your class path, it succeed.;;;","28/Jul/14 23:07;paulk;Is this working in recent versions of Groovy/Java8? The above example seemed to work OK for me on master.;;;","29/Jul/14 08:24;uehaj;With Groovy Version: 2.3.6 JVM: 1.8.0_11 Vendor: Oracle Corporation OS: Mac OS X,
this test code works well with no exception.

But It can be reproduced easily now with Groovy 2.2.0-rc-3 with JDK 1.8.0_11,
so I think this problem is solved by now.
;;;","30/Jul/14 03:31;paulk;OK, let's resolve for now and we can re-open/create a new issue if the problem surfaces again.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy-module's extension method don't work by Grape Annotation(sometimes),GROOVY-6446,12811781,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,uehaj,uehaj,23/Nov/13 15:27,30/Jul/14 03:31,14/Jul/23 06:01,30/Jul/14 03:31,2.2.0,,,,,,,,,,,,,,,,,2.3.5,,,,Grape,,,,0,,,,,,,"Sometimes Groovy module's extension methods don't inject to target Class when get the module by Grab annotation.
I attached test code but easy way to regenerate this issue is, use  tim yates's groovy-stream:

{code}
@Grab( 'com.bloidonia:groovy-stream:0.6.2' )
import groovy.stream.Stream


println([1,2,3].iterator().toStream())
{code}

fails indeterminately in my environment(1 time per 3 .. 10 trial, or serial)
{quote}
Caught: groovy.lang.MissingMethodException: No signature of method: java.util.ArrayList$Itr.toStream() is applicable for argument types: () values: []
Possible solutions: toString(), toString(), toSet()
groovy.lang.MissingMethodException: No signature of method: java.util.ArrayList$Itr.toStream() is applicable for argument types: () values: []
Possible solutions: toString(), toString(), toSet()
	at s.run(s.groovy:5)
{quote}

Following code seems to success.
{code}
groovy.grape.Grape.grab(['group': 'com.bloidonia', 'module': 'groovy-stream', 'version': '0.6.2'])
println([1,2,3].iterator().toStream())
{code}

Is it related to static class initializer invocation timing? I don't sure.

Attached code trying to generate this problem in test case, but it don't work
under testing framework by some reason I can't tell.
So to regenerate it you have to use groovy command from shell:

{quote}
% unzip test.zip
% cd test
% ./gradlew uploadArchives # put module into /tmp/myRepo
% groovy src/test/resouces/GrabTest.groovy
Caught: groovy.lang.MissingMethodException: No signature of method: java.lang.String.hello() is applicable for argument types: () values: []
Possible solutions: sleep(long), sleep(long, groovy.lang.Closure), split(), next(), split(), next()
groovy.lang.MissingMethodException: No signature of method: java.lang.String.hello() is applicable for argument types: () values: []
Possible solutions: sleep(long), sleep(long, groovy.lang.Closure), split(), next(), split(), next()
	at sample.GrabTest.main(GrabTest.groovy:10)
{quote}

P.S. If you put the groovy-module jar in your class path, it succeed.
","java version ""1.7.0_10""
Java(TM) SE Runtime Environment (build 1.7.0_10-b18)
Java HotSpot(TM) 64-Bit Server VM (build 23.6-b04, mixed mode)

MacOSX 10.9 Marverics",paulk,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6447,,,,"23/Nov/13 15:46;uehaj;test.zip;https://issues.apache.org/jira/secure/attachment/12723233/test.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 30 03:31:05 UTC 2014,,,,,,,,,,"0|i2c72v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jul/14 08:28;uehaj;This problem is not reproduced under Groovy Version: 2.3.6 JVM: 1.7.0_10 Vendor: Oracle Corporation OS: Mac OS X.

;;;","30/Jul/14 03:31;paulk;OK, let's resolve for now and we can re-open/create a new issue if the problem surfaces again.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inner class can't access container class inherited attributes,GROOVY-6445,12817156,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,chochos,chochos,22/Nov/13 12:03,17/Dec/14 13:25,14/Jul/23 06:01,29/Oct/14 15:10,3.x,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Compiler,,,,0,compiler,,,,,,"An inner class cannot directly access the inherited attributes of its container class.

To reproduce:

class Parent {
   String name
}
class External extends Parent {
  String outer
  Internal inner(String p) {
    new Internal(inner:p)
  }
  class Internal {
    String inner
    void boom() {
      println ""Outer is "" + outer + "", inner is "" + inner
//******** HERE'S THE PROBLEM
      println ""But parent is "" + name // Only works with External.this.name or getName()
    }
  }
}
 
new External(outer:""good"", name:""fucked"").inner(""good"").boom()
",Any,chochos,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 29 15:10:53 UTC 2014,,,,,,,,,,"0|i2boan:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Oct/14 15:10;pschumacher;Example works on current master.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closures are incorrectly coerced if a method call is done inside a closure,GROOVY-6444,12817242,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,22/Nov/13 06:39,26/Nov/13 14:48,14/Jul/23 06:01,22/Nov/13 10:32,2.2.0,,,,,,,,,,,,,,,,,2.2.1,,,,,,,,0,,,,,,,"The following test case demonstrates the problem:
{code}
Class foo(Runnable r) {
    // please do not remove wrapping inside a closure
    // because that's precisely what this test is supposed to check!
    { -> bar(r) }()
}

Class bar(Runnable r) {
   r.class
}

assert Closure.isAssignableFrom(foo { 'Hello' })
{code}

The assertion fails, with the class being a {{Proxy}}, which implies coercion to {{Runnable}}, which is implemented by {{Closure}} was involved.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-11-22 06:39:56.0,,,,,,,,,,"0|i2c46n:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Upgrade to Gradle 1.9,GROOVY-6440,12817204,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,19/Nov/13 09:56,05/Apr/14 00:00,14/Jul/23 06:01,19/Nov/13 10:07,,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,,,,,0,,,,,,,,,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-11-19 09:56:25.0,,,,,,,,,,"0|i2bvev:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Newify AST transformation doesn't work for anon inner classes,GROOVY-6438,12817236,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,uehaj,uehaj,18/Nov/13 05:21,17/Dec/14 13:25,14/Jul/23 06:01,17/Aug/14 07:31,2.2.0-rc-3,,,,,,,,,,,,,,,,,2.3.7,2.4.0-beta-3,,,xforms,,,,0,,,,,,,"This code:
{code}
@Newify String test() {
  new Object() { def x() { String.new('ABC') } }.x()
}
assert ""ABC""==test()
{code}

results in:
{noformat}
groovy.lang.MissingMethodException: No signature of method: static java.lang.String.new() is applicable for argument types: (java.lang.String) values: [ABC]
{noformat}

",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 17 07:31:36 UTC 2014,,,,,,,,,,"0|i2cj2v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Aug/14 07:31;paulk;Should be fixed. Thanks for spotting the problem.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sql.withTransaction() doesn't rollback on checked exceptions,GROOVY-6437,12818264,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,dsrkoc,dsrkoc,18/Nov/13 03:27,28/May/14 03:03,14/Jul/23 06:01,26/May/14 02:19,2.1.9,2.2.0-rc-3,,,,,,,,,,,,,,,,2.3.2,,,,SQL processing,,,,2,,,,,,,"If checked exception is thrown in the {{Sql#withTransaction(Closure)}} code block, the transaction will not be rolled back. Rollback is still invoked for runtime exceptions, {{SQLException}}, and {{Error}} - exceptions that are explicitly handled by {{withTransaction}}.

The following code illustrates the behaviour:

{code}
def sql = groovy.sql.Sql.newInstance(...)
try {
    sql.withTransaction {
        sql.execute ""CREATE TABLE foo_table (col1 INTEGER)""
        sql.execute ""INSERT INTO foo_table (col1) VALUES (42)""
        throw new Exception(""will not cause rollback"")
    }
} catch (e) {
    assert e.message == ""will not cause rollback""
    assert sql.firstRow(""SELECT COUNT(*) n FROM foo_table"").n == 1
    sql.execute ""DROP TABLE foo_table"" // clean-up by hand
}
{code}

Expected (but undesirable) outcome is that transaction is not rolled back - table {{foo_table}} still exists in the catch block with one inserted row.

In Groovy 2.0.x and earlier, checked exceptions would indeed cause rollback. The above code would fail on the first assertion, attempting to read from a non-existing table.

Exception handling code in {{withTransaction}} basically hasn't changed between 2.0 and 2.1, yet the method exhibits different behaviour.",,blackdrag,dsrkoc,paulk,pschumacher,tegi,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon May 26 03:03:30 UTC 2014,,,,,,,,,,"0|i2bvuv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Nov/13 07:35;blackdrag;around line 3058 in Sql.java we have {code:Java}        } catch (SQLException e) {
            handleError(connection, e);
            throw e;
        } catch (RuntimeException e) {
            handleError(connection, e);
            throw e;
        } catch (Error e) {
            handleError(connection, e);
            throw e;
        }{code}
The exception from inside the open block is of type Exception... even though this is correct, I assume, that the exception was in the past wrapped in an InvokerInvocationException or a InvocationTargetException. What exactly fixed that, I cannot tell yet, but it behaves correctly now. This means though the code there needs adjustement. And I wonder why not simply catch Throwable? The code there looks like checked exception have been taken out on purpose, but that does not make sense to me.;;;","24/May/14 05:59;pschumacher;@Paul: It would be nice if you could take a look at this. Looks like a serious bug to me.;;;","24/May/14 21:01;paulk;Yes, I was looking at this again yesterday actually. I haven't been able to find a definitive reference to how different kinds of exceptions should be handled in this case. To keep the Java API unchanged we want to wrap checked exceptions within a SQLException but unchecked exceptions, errors and existing SQLExceptions do not need to be re-rewrapped.;;;","24/May/14 22:21;paulk;See https://github.com/groovy/groovy-core/pull/426;;;","26/May/14 02:19;paulk;Exception is now caught too. Thanks for raising the issue.;;;","26/May/14 03:03;dsrkoc;It was my pleasure. ;-) Thanks for fixing it.
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Log annotations broken for Turkish locale,GROOVY-6436,12817270,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,pschumacher,pschumacher,16/Nov/13 13:16,15/Oct/15 18:20,14/Jul/23 06:01,17/Nov/13 03:14,2.1.9,2.2.0-rc-3,,,,,,,,,,,,,,,,2.2.1,,,,,,,,0,,,,,,,"Logging annotations produce wrong method name for ""info"" keyword since in Turkish locale uppercase form of ""i"" is uppercase i with a dot. Please see below link for details.

[http://java.sys-con.com/node/46241]

Sample error message from usage:
{quote}
groovy.lang.MissingMethodException: No signature of method: ch.qos.logback.classic.Logger.isÃÆÃ¢â¬Å¾ÃâÃÂ°nfoEnabled() is applicable for argument types: () values: [] Possible solutions: isInfoEnabled(), isInfoEnabled(org.slf4j.Marker), isErrorEnabled(), isWarnEnabled(), isErrorEnabled(org.slf4j.Marker), isWarnEnabled(org.slf4j.Marker)
{quote}

source: [https://github.com/groovy/groovy-core/pull/283] / [https://github.com/groovy/groovy-core/pull/284]",,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6485,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 17 03:14:42 UTC 2013,,,,,,,,,,"0|i2cdzr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Nov/13 03:14;pschumacher;Pull request applied. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checking error when assigning BigInteger child to BigInteger var from static context,GROOVY-6435,12817203,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mahool,mahool,15/Nov/13 03:40,15/Oct/15 18:20,14/Jul/23 06:01,18/Nov/13 05:55,2.1.9,2.2.0-rc-3,,,,,,,,,,,,,,,,2.2.1,,,,Static Type Checker,,,,0,,,,,,,"A static type checking error ""[Static type checking] - Cannot assign value of type MyInteger to variable of type java.math.BigInteger"" when assigning child class of BigInteger to a BigInteger variable.  Occurs only from static context when @CompileStatic enabled.  Does not occur for similar case for BigDecimal. 

Example:
{code}
public class MyDecimal extends java.math.BigDecimal {
  public MyDecimal(String s) {super(s);}
}

public class MyInteger extends java.math.BigInteger {
  public MyInteger(String s) {super(s);}
}

public class Foo {

  @groovy.transform.CompileStatic
  public static void run() {
    BigDecimal d = new MyDecimal(""3.0"");
    BigInteger i = new MyInteger(""3""); //compile error: [Static type checking]
  }
}

Foo.run();
{code}",,blackdrag,mahool,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 18 09:45:15 UTC 2013,,,,,,,,,,"0|i2bu7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Nov/13 03:44;mahool;Perhaps related to GROOVY-6431;;;","18/Nov/13 05:55;blackdrag;fixed;;;","18/Nov/13 09:45;mahool;Confirmed. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Newify AST transformation doesn't work for closure,GROOVY-6434,12817233,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,uehaj,uehaj,14/Nov/13 15:10,01/Aug/22 14:06,14/Jul/23 06:01,18/Nov/13 05:23,2.2.0-rc-3,,,,,,,,,,,,,,,,,2.2.1,,,,,,,,0,,,,,,,"This code:
{code}

@Newify([String])
String test1() {
    return String(""ABC"")
}

@Newify([String])
String test2() {
    return { -> String(""ABC"") }.call()
}

assert ""ABC""==test1()
assert ""ABC""==test2()

{code}

results in:
{quote}
Caught: groovy.lang.MissingMethodException: No signature of method: x.String() is applicable for argument types: (java.lang.String) values: [ABC]
Possible solutions: toString(), toString(), print(java.lang.Object), print(java.lang.Object), print(java.io.PrintWriter), run()
groovy.lang.MissingMethodException: No signature of method: x.String() is applicable for argument types: (java.lang.String) values: [ABC]
Possible solutions: toString(), toString(), print(java.lang.Object), print(java.lang.Object), print(java.io.PrintWriter), run()
	at x$_test2_closure1.doCall(x.groovy:9)
	at x.test2(x.groovy:9)
	at x$test2$0.callCurrent(Unknown Source)
	at x.run(x.groovy:13)
{quote}

I expect this test2 works as well as test1.
",,paulk,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10713,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 21 03:57:21 UTC 2013,,,,,,,,,,"0|i2cffr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Nov/13 00:02;paulk;This is for the same reason as GROOVY-6421;;;","17/Nov/13 17:05;paulk;Closures should now work but not all inner code is hooked up yet, e.g.:
{code}
@Newify String test() {
  new Object() { def x() { String.new('ABC') } }.x()
}
assert ""ABC""==test()
{code}
I'll leave this issue open until I create another one for that case.;;;","18/Nov/13 05:23;paulk;OK, I cloned the issue to handle the anonymous inner class case and will now resolve this one.;;;","21/Nov/13 03:57;uehaj;Thanks, it worked well for my purpose.
I tried:

Groovy Version: 2.2.1-SNAPSHOT JVM: 1.7.0_10 Vendor: Oracle Corporation OS: Mac OS X

I appreciate it.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ASTTransformationCustomizer should support raw Expressions for parameters,GROOVY-6432,12817229,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,14/Nov/13 08:22,15/Oct/15 18:19,14/Jul/23 06:01,22/Nov/13 08:36,2.1.9,,,,,,,,,,,,,,,,,2.2.1,,,,,,,,0,,,,,,,"The {{ASTTransformationCustomizer}} only supports basic types for annotation values. It would be good if it could support any {{Expression}} too. This would solve this, which is not working:

{code}
new ASTTransformationCustomizer(value:500, unit: TimeUnit.MILLISECONDS, TimedInterrupt)
{code}

which could be written this way:

{code}
new ASTTransformationCustomizer(value:500, unit: new PropertyExpression(new ClassExpression(ClassHelper.make(TimeUnit)),'MILLISECONDS'), TimedInterrupt)
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-11-14 08:22:43.0,,,,,,,,,,"0|i2cni7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
method resolution with parameter BigInteger fails for argument extending BigInteger,GROOVY-6431,12817228,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mahool,mahool,14/Nov/13 02:06,15/Oct/15 18:19,14/Jul/23 06:01,18/Nov/13 05:55,2.1.7,2.1.9,2.2.0-rc-3,,,,,,,,,,,,,,,2.2.1,,,,,,,,0,,,,,,,"When extending java.lang.BigInteger, using an obj of that child class as argument to a method with BigInteger parameter causes a MissingMethodException.  Similar variations with BigDecimal or Number work fine.

Sample:
{code}
public class MyDecimal extends java.math.BigDecimal {
    public MyDecimal(String s) {super(s);}
}

public class MyInteger extends java.math.BigInteger {
    public MyInteger(String s) {super(s);}
}

class Expression {
    public int takeNumber(Number a) {return 1;}
    public int takeBigDecimal(BigDecimal a) {return 2;}
    public int takeBigInteger(BigInteger a) {return 3;}
}

Expression exp = new Expression();
assert 1 == exp.takeNumber(new MyInteger(""3"")); //works fine: 1
assert 2 == exp.takeBigDecimal(new MyDecimal(""3.0"")); //works fine: 2 
assert 3 == exp.takeBigInteger(new MyInteger(""3"")); //MissingMethodException
{code}",,blackdrag,mahool,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"14/Nov/13 02:06;mahool;extendBigInt.groovy;https://issues.apache.org/jira/secure/attachment/12723204/extendBigInt.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 18 09:45:50 UTC 2013,,,,,,,,,,"0|i2c9qf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"15/Nov/13 03:44;mahool;Perhaps related to GROOVY-6435;;;","18/Nov/13 05:55;blackdrag;should be fixed now;;;","18/Nov/13 09:45;mahool;Confirmed it is fixed. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checking error when multiple-dispatching on instance fields from static context,GROOVY-6430,12817208,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,ddimitrov,ddimitrov,13/Nov/13 20:31,08/Mar/22 12:16,14/Jul/23 06:01,05/Oct/21 20:11,2.2.0-rc-3,2.3.0,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,Static Type Checker,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
class InstanceGenericsInStaticContext {
//    List<Class> classes = [] // If we use List it all works!
    Collection<Class> classes = []

    def compilesInstance() {
        println classes*.simpleName
    }

    // Groovyc: [Static type checking] - No such property: simpleName for class: java.util.Set <java.lang.Class>
    static compilesStatic() {
        Collection<Class> x = []
        println x*.simpleName
    }

    static compilesStatic(InstanceGenericsInStaticContext it) {
        it.classes.first().simpleName
        println it.classes.collect { (Class) it }*.simpleName
    }

    static doesNotCompile(InstanceGenericsInStaticContext it) {
        println it.classes*.simpleName
    }

    static doesNotCompile2(InstanceGenericsInStaticContext it) {
        Collection<Class> x = it.classes
        println x*.simpleName
    }
}
{code}",,ddimitrov,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 05 20:11:44 UTC 2021,,,,,,,,,,"0|i2bmxj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"05/Oct/21 20:11;emilles;Works in Groovy 2.5+;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
flow typing detects unexpected error at if-else flow,GROOVY-6429,12818270,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,uehaj,uehaj,13/Nov/13 15:21,27/Nov/22 20:10,14/Jul/23 06:01,27/Nov/22 20:10,2.2.0-rc-2,2.3.0,2.4.0-beta-3,,,,,,,,,,,,,,,5.0.0-alpha-1,,,,Static Type Checker,,,,0,,,,,,,"In groovy 2.2.0-rc-3, this code:
{code}
class A{
}
class B extends A{
    void foo(){}
}

@groovy.transform.TypeChecked
void test1(A x) {
    if (x instanceof B) {
        x.foo()
    }
}

@groovy.transform.TypeChecked
void test2(A x) {
    if (!(x instanceof B)) {
        return
    }
    x.foo()
}

@groovy.transform.TypeChecked
void test3(A x) {
    if (!(x instanceof B)) {
        return
    }
    else {
        x.foo()
    }
}
@groovy.transform.TypeChecked
void test4(A x) {
    if (!(x instanceof B)) {
        return
    }
    assert x instanceof B
    x.foo()
}

test1(new B())
test2(new B())
test3(new B())
test4(new B())

{code}
expects all OK. but test2 and test3 results in:
{quote}
% groovy a.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/Users/uehaj/work/201311/comprehension_groovy/a.groovy: 19: [Static type checking] - Cannot find matching method A#foo(). Please check if the declared type is right and if the method exists.
 @ line 19, column 5.
       x.foo()
       ^

/Users/uehaj/work/201311/comprehension_groovy/a.groovy: 28: [Static type checking] - Cannot find matching method A#foo(). Please check if the declared type is right and if the method exists.
 @ line 28, column 9.
           x.foo()
           ^

2 errors
{quote}",,emilles,paulk,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8412,GROOVY-8523,GROOVY-9931,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 27 20:10:47 UTC 2022,,,,,,,,,,"0|i2cbr3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Apr/18 11:45;paulk;After GROOVY-8523, test2 now works but test3 still doesn't compile.;;;","27/Nov/22 20:10;emilles;https://github.com/apache/groovy/commit/f348e50481c24f21413c4d2b52b501b433003051;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AutoCloneStyle.SIMPLE doesn't play well with generics,GROOVY-6428,12818263,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,melix,melix,13/Nov/13 09:37,26/Nov/13 14:48,14/Jul/23 06:01,16/Nov/13 00:01,2.2.0-rc-3,,,,,,,,,,,,,,,,,2.2.1,,,,,,,,0,,,,,,,"The {{SIMPLE}} style of autocloning doesn't like generics. The following code will fail compilation:

{code}
@AutoClone(style=AutoCloneStyle.SIMPLE)
class Book {
    String isbn
    String title
    List<String> authors
    Date publicationDate
}
{code}

The error is a typical AST transformation failure due to the reuse of generics (missing call to {{getPlainNodeReference}}):

{noformat}
A transform used a generics containing ClassNode Book for the method protected void cloneOrCopyMembers(Book other) throws java.lang.CloneNotSupportedException { ... } directly. You are not supposed to do this. Please create a new ClassNode referring to the old ClassNode and use the new ClassNode instead of the old one. Otherwise the compiler will create wrong descriptors and a potential NullPointerException in TypeResolver in the OpenJDK. If this is not your own doing, please report this bug to the writer of the transform.
{noformat}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-11-13 09:37:03.0,,,,,,,,,,"0|i2c4l3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovysh not running using the groovy-all jar,GROOVY-6426,12818477,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,08/Nov/13 03:16,15/Oct/15 18:20,14/Jul/23 06:01,08/Nov/13 03:26,2.1.9,2.2.0-rc-3,,,,,,,,,,,,,,,,2.2.1,,,,,,,,0,,,,,,,Basically the work done earlier for GROOVY-3079 didn't survive m18n refactoring. The jarjar task has some excludes for a class that has moved into a subproject.,,daspilker,mxm,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3079,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 02 02:50:03 UTC 2013,,,,,,,,,,"0|i2ckaf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Nov/13 03:26;paulk;fixed - should be back the way it was in earlier releases now - thanks for spotting the problem;;;","02/Dec/13 00:24;mxm-groovy;I still can't run org.codehaus.groovy.tools.shell.Main with a groovy-all-2.2.1.jar only. 
It wants jansi.jar not included to groovy-all.

I get the following error:

java.lang.NoClassDefFoundError: org/fusesource/jansi/AnsiConsole
	at org.codehaus.groovy.tools.shell.Main.<clinit>(Main.groovy:36)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:121)
Caused by: java.lang.ClassNotFoundException: org.fusesource.jansi.AnsiConsole
	at org.codehaus.groovy.tools.RootLoader.findClass(RootLoader.java:175)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at org.codehaus.groovy.tools.RootLoader.loadClass(RootLoader.java:147)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	... 12 more
 ;;;","02/Dec/13 02:33;pschumacher;Hi Maxim,
running groovysh from groovy-all.jar is not supposed to work, because the libs required (jline and jansi) are not bundeled into groovy-all to keep its size small.;;;","02/Dec/13 02:50;mxm-groovy;Hi Pascal,
thanks for clarification.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@GrabExclude's group element is documented as optional but the implementation requires it,GROOVY-6424,12818476,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,awilkinson,awilkinson,06/Nov/13 08:18,26/Nov/13 14:48,14/Jul/23 06:01,25/Nov/13 15:24,2.1.9,,,,,,,,,,,,,,,,,2.2.1,,,,Grape,,,,0,,,,,,,"The javadoc for {{@GrabExclude}} lists {{group}} as an optional element. However, if it is omitted, compilation will fail:

{code}
/Users/awilkinson/Desktop/app.groovy: 4: The missing attribute ""group"" is required in @GrabExclude annotations
 @ line 4, column 1.
   @GrabExclude(module='spring-core')
   ^

1 error
{code}",,paulk,pschumacher,wilkinsona,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 25 15:25:11 UTC 2013,,,,,,,,,,"0|i2bqsn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Nov/13 04:09;pschumacher;[pull request|https://github.com/groovy/groovy-core/pull/286];;;","24/Nov/13 04:26;paulk;""group"" is optional when using the compact form, e.g.:
{code}
@GrabExclude('org.springframework:spring-core')
{code}
but not if using the long form which uses the ""module"" attribute. We could probably word this better in the groovydoc.;;;","25/Nov/13 15:25;pschumacher;pull request merged;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Move dependency on JLine to Groovysh module,GROOVY-6423,12817193,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,06/Nov/13 03:56,08/Nov/13 20:49,14/Jul/23 06:01,06/Nov/13 04:15,,,,,,,,,,,,,,,,,,2.2.0-rc-3,,,,,,,,0,,,,,,,"The only module which makes use of JLine is Groovysh, but the dependency is defined on the main gradle file, which is wrong. The dependency should be moved to the groovysh module instead.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-11-06 03:56:33.0,,,,,,,,,,"0|i2cakf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Newify fails for local variable assignment,GROOVY-6421,12817202,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pschumacher,pschumacher,05/Nov/13 04:11,26/Nov/13 14:48,14/Jul/23 06:01,17/Nov/13 17:00,2.1.9,,,,,,,,,,,,,,,,,2.2.1,,,,,,,,0,,,,,,,"This:
{code}
    @Newify foo() {
        def x = Integer.new(42)
    }
    foo() 
{code}

Fails with:
{quote}Caught: groovy.lang.MissingMethodException: No signature of method: newifyBug.Integer() is applicable for argument types: (java.lang.Integer) values: [44]
groovy.lang.MissingMethodException: No signature of method: newifyBug.Integer() is applicable for argument types: (java.lang.Integer) values: [44]
        at newifyBug.foo(newifyBug.groovy:6)
        at newifyBug.run(newifyBug.groovy:9)
{quote}

source: [http://groovy.329449.n5.nabble.com/Potential-problem-with-Newify-td5717385.html]",,paulk,pschumacher,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 17 16:59:38 UTC 2013,,,,,,,,,,"0|i2bten:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Nov/13 05:32;paulk;Would be autofixed if we correct GROOVY-6422.;;;","16/Nov/13 14:25;uehaj;IMHO, if you 'correct' GROOVY-6422,
even though it might fix @Newify 's problems (GROOVY-6434, GROOVY-6421),
it breaks vast number of existing other AST Transformations which calls visit by hand.
For example, org.codehaus.groovy.ast.builder AstBuilderTransformation, and many third party
transformations which not included in groovy-core.

I hope this problems is regarded as a @Newify's bug.

;;;","16/Nov/13 19:44;paulk;The intention would not be to break existing behavior but to provide an alternative/augmented way to visit all nodes and swap Newify over to using the new approach.;;;","17/Nov/13 16:59;paulk;OK, started doing the fix locally to the NewifyASTTransformation. The more generic solution for GROOVY-6422 could be refactored out later.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"A stored procedure call (sql.call) fails, when any of the result-sets are NOT used in closure (param 3). ",GROOVY-6420,12817223,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,tomjoseph,tomjoseph,04/Nov/13 22:03,20/May/14 05:31,14/Jul/23 06:01,05/May/14 15:40,,,,,,,,,,,,,,,,,,2.3.1,,,,SQL processing,,,,0,,,,,,,"A stored procedure call (sql.call) fails, when any of the result-sets are NOT used in closure (param 3). 

*Cause*
File: groovy.sql.Sql
Method: public void call(String sql, List<Object> params, Closure closure) throws Exception
The connection and statement is closed before result set
{code:title=groovy.sql.Sql}
	public void call(String sql, List<Object> params, 
                            Closure closure) throws Exception {
	...
	} finally {
	    closeResources(connection, statement);
	    for (GroovyResultSet rs : resultSetResources) {
		closeResources(null, null, rs);
	    }
	}
{code}

Here the 'closeResources(null, null, rs)' method in finally block fails, when the result-set is used for the first time here after the statement is closed. 	

{code:title=groovy.sql.CallResultSet}
	if (firstCall) {
	    resultSet = (ResultSet) call.getObject(indx + 1);
	    firstCall = false;
	}
{code} 
 
*Suggested Fix*
In class 'groovy.sql.Sql', method 'void call(String sql, List<Object> params, Closure closure)', switch the close connection/statement line after resultset. 
{code:title=groovy.sql.Sql}     
    for (GroovyResultSet rs : resultSetResources) {
        closeResources(null, null, rs);
    }
    closeResources(connection, statement);
{code}",,paulk,pschumacher,tomjoseph,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon May 05 15:40:12 UTC 2014,,,,,,,,,,"0|i2cfev:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Nov/13 03:53;pschumacher;Hi Tom,

thanks for reporting this issue.

It would be nice if you could post a short example for this because I was not able to write a test for groovy-sql which replicates this issue (probably just my lack of knowledge of groovy-sql).

Thanks!;;;","05/May/14 15:40;paulk;Suggested change made. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy java.lang.VerifyError,GROOVY-6419,12817187,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,bodiam,bodiam,04/Nov/13 08:02,15/Oct/15 18:19,14/Jul/23 06:01,08/Nov/13 10:36,2.1.8,,,,,,,,,,,,,,,,,2.2.1,,,,,,,,0,,,,,,,"Hi all, this is not 'my' bug, but one from stackoverflow, which I thought to put here: http://stackoverflow.com/questions/19735433

{noformat}
class Test {
        public void doIt() {
                int x = null
        }
}
{noformat}


gives the following error:

{noformat}
Caught: java.lang.VerifyError: (class: Test, method: doIt signature: ()V) Expecting to find integer on stack
java.lang.VerifyError: (class: Test, method: doIt signature: ()V) Expecting to find integer on stack
	at test.run(test.groovy:3)

shell returned 1
{noformat}",Groovy 2.1.8,blackdrag,bodiam,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 08 10:36:34 UTC 2013,,,,,,,,,,"0|i2cm5j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"08/Nov/13 10:36;blackdrag;fixed ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic complains when trying to call generic methods with different generic type parameter names,GROOVY-6415,12817212,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,acourtneybrown,acourtneybrown,31/Oct/13 15:49,01/May/14 18:01,14/Jul/23 06:01,30/Apr/14 13:53,2.1.9,,,,,,,,,,,,,,,,,2.3.0-rc-4,,,,Static compilation,Static Type Checker,,,4,,,,,,,"{code}
@groovy.transform.CompileStatic
class Foo {
	String method() {
		return callT('abc')
	}

    private <T> T callT(T t) {
		return callV(t)
	}

	private <V> V callV(V v) {
		return v
	}
}

println new Foo().method()
{code}

Without @CompileStatic annotation, it outputs 'abc'.

With @CompileStatic annotation, it generates a compilation error:
{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/Users/abrown/tmp/groovy/generics.groovy: 8: [Static type checking] - Cannot call Foo#callV(java.lang.Object <V>) with arguments [java.lang.Object <T>]
 @ line 8, column 10.
   		return callV(t)
            ^

1 error
{code}",,acourtneybrown,blackdrag,gcadien,ilialewis,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 30 13:53:28 UTC 2014,,,,,,,,,,"0|i2bunj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Oct/13 16:10;acourtneybrown;As a workaround, you can get around the compilation error by explicitly casting the object to (Object).  For example, change the callT method above to:
{code}
private <T> T callT(T t) {
  return callV((Object) t)
}
{code};;;","30/Apr/14 13:53;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CLONE - Incorrect parameter for annotations throws compilation exception with obfuscated message,GROOVY-6412,12817078,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,aljacinto,aljacinto,31/Oct/13 08:17,11/Jun/14 14:25,14/Jul/23 06:01,29/May/14 04:44,2.1.2,,,,,,,,,,,,,,,,,2.3.3,,,,Compiler,,,,0,,,,,,,"Same issue as below, my test class is:
{code}
@Qualifier
@Retention(RUNTIME)
@Target([FIELD, TYPE, METHOD])
public @interface MyAnnotation {
	MyValue value()
}
{code}
Note: Did not import package for FIELD, TYPE and METHOD.
got the error below:
{noformat}
General error during class generation: org.codehaus.groovy.ast.expr.VariableExpression cannot be cast to org.codehaus.groovy.ast.expr.PropertyExpression

java.lang.ClassCastException: org.codehaus.groovy.ast.expr.VariableExpression cannot be cast to org.codehaus.groovy.ast.expr.PropertyExpression
        at org.codehaus.groovy.vmplugin.v5.Java5.configureAnnotationFromDefinition(Java5.java:227)
        at org.codehaus.groovy.vmplugin.v5.Java5.configureAnnotation(Java5.java:242)
        at org.codehaus.groovy.classgen.AnnotationVisitor.visit(AnnotationVisitor.java:81)
        at org.codehaus.groovy.classgen.ExtendedVerifier.visitAnnotation(ExtendedVerifier.java:154)
        at org.codehaus.groovy.classgen.ExtendedVerifier.visitAnnotations(ExtendedVerifier.java:115)
        at org.codehaus.groovy.classgen.ExtendedVerifier.visitClass(ExtendedVerifier.java:52)
        at org.codehaus.groovy.control.CompilationUnit$15.call(CompilationUnit.java:773)
        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
:services:easervices:groovydoc
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
:services:easervices:groovydoc UP-TO-DATE
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:506)
        at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:118)
        at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:39)
:common:persistence:persistence-utility:processResources
        at org.gradle.api.internal.tasks.compile.daemon.CompilerDaemonServer.execute(CompilerDaemonServer.java:52)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(Reflectioch.java:35)
        at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
        at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)
        at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
:common:persistence:persistence-utility:processResources UP-TO-DATE
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
        at java.lang.Thread.run(Thread.java:724)
{noformat}

---- From original Jira

Test class below.  The problem is simple, and it should have been found immediately on compilation.  Instead, a completely cryptic message is given from the exception thrown from the AnnotationVisitor:

""java.lang.ClassCastException: org.codehaus.groovy.ast.expr.VariableExpression cannot be cast to org.codehaus.groovy.ast.expr.PropertyExpression""

Expected behavior (best case) should give the file name, annotation, and line number of the offense.  In Grails this problem is especially bad because the stack traces are exceptionally long making this even more difficult to deal with.

The following class will cause this issue, when compiled:

import javax.persistence.*

@Entity
class Foo{
        
    @Id
    @GeneratedValue
    long id
    
    @Temporal(DATE)
    Date testDate
}

When compiled it will produce this stack trace (to avoid the stack trace, change DATE above to TemporalType.DATE):

org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed, General error during class generation: org.codehaus.groovy.ast.expr.VariableExpression cannot be cast to org.codehaus.groovy.ast.expr.PropertyExpression

java.lang.ClassCastException: org.codehaus.groovy.ast.expr.VariableExpression cannot be cast to org.codehaus.groovy.ast.expr.PropertyExpression
        at org.codehaus.groovy.classgen.AnnotationVisitor.visitExpression(AnnotationVisitor.java:137)
        at org.codehaus.groovy.classgen.AnnotationVisitor.visit(AnnotationVisitor.java:97)
        at org.codehaus.groovy.classgen.ExtendedVerifier.visitAnnotation(ExtendedVerifier.java:108)
        at org.codehaus.groovy.classgen.ExtendedVerifier.visitAnnotations(ExtendedVerifier.java:90)
        at org.codehaus.groovy.classgen.ExtendedVerifier.visitField(ExtendedVerifier.java:59)
        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:842)
        at org.codehaus.groovy.classgen.ExtendedVerifier.visitClass(ExtendedVerifier.java:51)
        at org.codehaus.groovy.control.CompilationUnit$10.call(CompilationUnit.java:669)
        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:8
85)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:436)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:417)
        at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:56)
        at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:220)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:101)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130)","JDK 1.7, Windows 7",aljacinto,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 29 04:44:09 UTC 2014,,,,,,,,,,"0|i2ccav:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"29/May/14 04:44;paulk;Your example now gives the following compilation error:
{noformat}
3 compilation errors:

Expected enum value for attribute value in @java.lang.annotation.Target
 at line: 7, column: 10

Expected enum value for attribute value in @java.lang.annotation.Target
 at line: 7, column: 17

Expected enum value for attribute value in @java.lang.annotation.Target
 at line: 7, column: 23
{noformat}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect exception behavior when class has @CompileStatic,GROOVY-6411,12817084,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,acourtneybrown,acourtneybrown,30/Oct/13 19:18,15/Oct/15 18:20,14/Jul/23 06:01,22/Nov/13 08:02,2.1.8,,,,,,,,,,,,,,,,,2.2.1,,,,Static compilation,,,,5,,,,,,,"{code}
import groovy.transform.CompileStatic

@CompileStatic
class Client<T> {
  static String method() {
    return ({
      try {
        return doSomething()
      } catch (IOException ioe) {
        println ""IOException: ${ioe}""
      } catch (Exception e) {
        println ""Exception: ${e}""
      }
    })()
  }

  private static <T> T doSomething() throws IOException {
    throw new IOException()
    return null
  }
}

Client.method()
{code}

Without the @CompileStatic, it outputs (as expected)
{code}
IOException: java.io.IOException
{code}

With the @CompileStatic, it outputs
{code}
Exception: org.codehaus.groovy.runtime.InvokerInvocationException: java.io.IOException
{code}",,acourtneybrown,gcadien,ilialewis,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 31 08:12:30 UTC 2013,,,,,,,,,,"0|i2cttj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Oct/13 08:12;melix;The problem seems to be related to bridge methods that are generated by the static compiler (Java does something similar). Given that {{doSomething()}} is private and called from within an inner class (the closure), a bridge method is generated. Making the method public/protected/package private is a workaround.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Methods from java.lang.Object shouldn't be considered abstract,GROOVY-6410,12817194,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,melix,melix,30/Oct/13 15:13,08/Nov/13 20:49,14/Jul/23 06:01,06/Nov/13 11:44,2.2.0-rc-2,,,,,,,,,,,,,,,,,2.2.0-rc-3,,,,,,,,0,,,,,,,"When determining if a type is a SAM-type, methods from {{java.lang.Object}} should be ignored. For example, the following class is not considered as a SAM-type:

{code}
interface Predicate<T> {
   boolean apply(T val)
   boolean equals(Object that)
}
{code}

This example is a simplified version of {{Predicate}} from {{Guava}}. Basically, the {{equals}} method will always be implemented, so it shouldn't be considered abstract, even if it's defined explicitely in the interface. This prevents {{Closure}} from being automatically coerced to {{Predicate}}.

A simple script showing the problem:
{code}
@Grab('com.google.guava:guava:15.0')
import com.google.common.base.Predicate

static <T> boolean doAll(Iterator<T> itr, Predicate<T> predicate ) {}

def itr = ['a','b'].iterator()
doAll(itr) { it.length()>3 } // fails to coerce automatically
{code}",,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 30 23:19:29 UTC 2013,,,,,,,,,,"0|i2ccjz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Oct/13 23:19;paulk;You need look no further than {{java.util.Comparator}} for an example.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With @CompileStatic And Typed Collections,GROOVY-6408,12817195,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,brownj,brownj,30/Oct/13 10:48,03/Feb/22 22:43,14/Jul/23 06:01,11/Oct/21 17:24,2.1.9,2.3.0,2.4.0-rc-1,,,,,,,,,,,,,,,4.0.0-alpha-3,,,,Static Type Checker,,,,0,,,,,,,"The following code compiles:

{code:borderStyle=solid|title=Demo.groovy}
@groovy.transform.CompileStatic
class Demo {
    def test(Listener listener1) {
        def listener2 = new DefaultListener()
        List<Listener> listeners = [listener1, listener2]
    }
}


interface Listener {}

class DefaultListener implements Listener {}
{code}

This also compiles:

{code:borderStyle=solid|title=Demo.groovy}
@groovy.transform.CompileStatic
class Demo {
    def test(Listener listener1) {
        def listener2 = new DefaultListener()
        List<Listener> listeners = [listener1]
    }
}


interface Listener {}

class DefaultListener implements Listener {}
{code}

This will not compile:

{code:borderStyle=solid|title=Demo.groovy}
@groovy.transform.CompileStatic
class Demo {
    def test(Listener listener1) {
        def listener2 = new DefaultListener()
        List<Listener> listeners = [listener2]
    }
}


interface Listener {}

class DefaultListener implements Listener {}
{code}

{noformat}
staticcompiledcollection $ groovy -version
Groovy Version: 2.1.9 JVM: 1.6.0_51 Vendor: Apple Inc. OS: Mac OS X
staticcompiledcollection $ 
staticcompiledcollection $ cat Demo.groovy 
@groovy.transform.CompileStatic
class Demo {
    def test(Listener listener1) {
        def listener2 = new DefaultListener()
        List<Listener> listeners = [listener2]
    }
}


interface Listener {}

class DefaultListener implements Listener {}
staticcompiledcollection $ 
staticcompiledcollection $ groovyc Demo.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Demo.groovy: 5: [Static type checking] - Incompatible generic argument types. Cannot assign java.util.List <DefaultListener> to: java.util.List <Listener>
 @ line 5, column 36.
           List<Listener> listeners = [listener2]
                                      ^

1 error

staticcompiledcollection $
{noformat}

",,brownj,emilles,jwagenleitner,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 11 17:24:39 UTC 2021,,,,,,,,,,"0|i2bx9r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Oct/13 11:14;melix;From my understanding, first example should not compile unless you have {{List<? extends Listener>}};;;","30/Oct/13 11:24;brownj;I think having the first one not compile would be reasonable.  However, if the first one is considered valid then the third one should also be considered valid.  Allowing [listener1, listener2] but not allowing [listener2] is inconsistent.;;;","11/Oct/21 17:24;emilles;See GROOVY-6912, GROOVY-7106, GROOVY-7128, GROOVY-7274, GROOVY-7468, GROOVY-8909, and GROOVY-9844;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With EqualsAndHashCode And Primitive Boolean Properties,GROOVY-6407,12817215,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,brownj,brownj,29/Oct/13 21:49,15/Oct/15 18:20,14/Jul/23 06:01,31/Oct/13 16:56,2.1.6,2.1.9,,,,,,,,,,,,,,,,2.2.0-rc-3,,,,,,,,1,,,,,,,"If a class marked with @EqualsAndHashCode contains a boolean property as well as a corresponding ""is*"" method the EqualsAndHashCode transformation generates some invalid code.

{noformat}
equals_and_hash_code $ groovy -version
Groovy Version: 2.1.9 JVM: 1.6.0_51 Vendor: Apple Inc. OS: Mac OS X
equals_and_hash_code $ 
equals_and_hash_code $ cat Demo.groovy 
@groovy.transform.EqualsAndHashCode
class Demo {
    boolean myBooleanProperty

    boolean isMyBooleanProperty() {
        false
    }

    static main(args) {
        println new Demo().hashCode()
    }
}

equals_and_hash_code $ 
equals_and_hash_code $ groovy Demo.groovy 
Caught: groovy.lang.MissingMethodException: No signature of method: Demo.getMyBooleanProperty() is applicable for argument types: () values: []
Possible solutions: setMyBooleanProperty(boolean), isMyBooleanProperty()
groovy.lang.MissingMethodException: No signature of method: Demo.getMyBooleanProperty() is applicable for argument types: () values: []
Possible solutions: setMyBooleanProperty(boolean), isMyBooleanProperty()
	at Demo.hashCode(Demo.groovy)
	at Demo$hashCode.call(Unknown Source)
	at Demo.main(Demo.groovy:10)
equals_and_hash_code $ 
{noformat}

I have tested with Groovy 2.1.6 and 2.1.9 and both demonstrate this behavior.

This problem is manifesting in Grails.  See http://jira.grails.org/browse/GRAILS-10701.",,brownj,lhotari,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 31 16:56:10 UTC 2013,,,,,,,,,,"0|i2c57z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Oct/13 16:25;paulk;A similar error is thrown calling {{toString()}} if {{@ToString}} is applied to the same class. Using {{InvokerHelper.getProperty}} to access the property fixes the problem in both cases. ;;;","31/Oct/13 16:56;paulk;Fixed. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AccessControlException with Google App Engine and indy version of the Groovy,GROOVY-6405,12817189,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,musketyr,musketyr,28/Oct/13 18:31,15/Oct/15 18:19,14/Jul/23 06:01,21/Nov/13 05:32,2.1.8,,,,,,,,,,,,,,,,,2.2.1,,,,,,,,0,,,,,,,"When trying to compile groovlet on Google App Engine development server I get the attached exception.

It looks this only apply when indy version of Groovy is used, default version
seems to be ok.

The problem occurs in org.codehaus.groovy.vmplugin.v5.Java5.configureAnnotation(Java5.java:265) when
the annotation is sun.reflect.CallerSensitive.","java version ""1.7.0_45""
Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
on Ubuntu 12.04 x64",blackdrag,musketyr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Nov/13 09:55;blackdrag;a.patch;https://issues.apache.org/jira/secure/attachment/12722192/a.patch","21/Nov/13 02:10;blackdrag;b.patch;https://issues.apache.org/jira/secure/attachment/12723093/b.patch","28/Oct/13 18:31;musketyr;failing-groovy-gae.zip;https://issues.apache.org/jira/secure/attachment/12723203/failing-groovy-gae.zip","28/Oct/13 18:31;musketyr;stacktrace.txt;https://issues.apache.org/jira/secure/attachment/12723135/stacktrace.txt",,,,,4.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Dec 05 15:55:48 UTC 2013,,,,,,,,,,"0|i2c79b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Oct/13 18:34;musketyr;Is very likely this is an OS dependent problem. Please, try it in virutal machine of Ubuntu 12.04. It has been reported here too:

https://plus.google.com/u/0/107804573729662238528/posts/RXwLmc3SHcV;;;","29/Oct/13 03:26;blackdrag;The line causing the problem is Method[] declaredMethods = type.getDeclaredMethods(); I assume type here is a class from sun.reflect. But why we create a ClassNode for a class from that package is a bit beyond me
;;;","29/Oct/13 09:24;blackdrag;Vladimir, are you using the openjdk, or a package from Ubuntu for the jdk? I cannot find the link anymore, but somewhere I had a page saying that the openjdk in Ubuntu has messed up priviledges. If you could test with the oracle jdk it would surely help to ensure the issue is not related to that;;;","30/Oct/13 13:45;musketyr;It shows me I'm using oracle java 7.;;;","30/Oct/13 17:45;musketyr;don't you know, could be these messed up priveledges shared across the java vendor packages?;;;","30/Oct/13 18:35;musketyr;verified - I use Oracle Java

{code}
groovy:000> System.getProperty('java.vendor')
===> Oracle Corporation
groovy:000> System.getProperty('java.vendor.url')
===> http://java.oracle.com/
groovy:000> System.getProperty('java.version')
===> 1.7.0_45
{code};;;","31/Oct/13 14:45;musketyr;bq. The line causing the problem is Method[] declaredMethods = type.getDeclaredMethods(); I assume type here is a class from sun.reflect. But why we create a ClassNode for a class from that package is a bit beyond me.

type is java.lang.Class, the class causing the violation is annotation sun.reflect.CallerSensitive as written in the description.;;;","01/Nov/13 05:11;blackdrag;Oh, I did not see CallerSensitive... but that explains perfectly the problem. I knew having an internal visible annotation on ""public"" API is stupid, but I thought it would not have an effect. Now I know it has one.

The question is what we do. Currently I know no other way, than recognizing catching the exception and skip the contents in that case.;;;","01/Nov/13 05:38;musketyr;Well, that I was afraid of. I hope it won't hurt the performance much.;;;","01/Nov/13 11:29;musketyr;Actually following might work as well:

{code}
    // org.codehaus.groovy.vmplugin.v5.Java5
    private void setAnnotationMetaData(Annotation[] annotations, AnnotatedNode an) {
        for (Annotation annotation : annotations) {
            if (annotation.getClass().getPackage() == null || !""sun.reflect"".equals(annotation.getClass().getPackage().getName())) {
                AnnotationNode node = new AnnotationNode(ClassHelper.make(annotation.annotationType()));
                configureAnnotation(node, annotation);
                an.addAnnotation(node);    
            }
        }
    }
{code}

EDIT: this didn't helped, so the only way is probably that catch block;;;","20/Nov/13 09:55;blackdrag;it would be very good if someone (Vladimir?) could try out the patch I attached;;;","20/Nov/13 11:36;musketyr;I've tried it and it solves the issue.;;;","21/Nov/13 02:10;blackdrag;I attached one more file called b.patch. Vladimir could you test that one please too? I think using a PrivilegedAction might be better and allows finer control. If this one works as well I have to think about which to take ;);;;","21/Nov/13 03:21;musketyr;the b.patch doesn't seem to be working, I'm getting the old good AccessControlException.
;;;","21/Nov/13 05:32;blackdrag;I applied a.patch. Thanks for testing Vladimir;;;","04/Dec/13 19:07;musketyr;Thank you too, for fixing it! But I have a problem. I've tried 2.2.1 in which it should be already fixed and it didn't worked.

I'm now getting pretty similar error (see stacktrace2.txt). I may be caused by something added in 2.2.x branch or after the time it was fixed. I should probably open new issue for this, shouldn't I?;;;","04/Dec/13 19:09;musketyr;or maybe reopen this one. here's the stacktrace, I wasn't able to add the attachment, probably because it's already closed:

http://pastebin.com/vJ9Rmhud;;;","05/Dec/13 04:16;blackdrag;the issue here was a failure in the compiler, now it is the runtime, so it is a new issue... and since it is SAM-related only in 2.2 - but the fix should be the same way at another place;;;","05/Dec/13 15:55;musketyr;Well, the issue here was for scripts compiled in runtime - so the combination of both mentioned. Ok, I'll create another one.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect stubs for enums without constants,GROOVY-6404,12817196,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mxm-groovy,mxm,28/Oct/13 01:29,17/Jun/15 20:10,14/Jul/23 06:01,12/Jun/14 23:18,2.2.0-rc-1,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,Stub generator / Joint compiler,,,,0,,,,,,,"Generated stub for empty enum class misses ';' at the beginning of the class. 

{code}
enum E {
}
{code}

{code}
public enum E
  implements
    groovy.lang.GroovyObject {
//here should be ';'
public static final p.A.E MIN_VALUE = null;
public static final p.A.E MAX_VALUE = null;
public  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}
public  void setMetaClass(groovy.lang.MetaClass mc) { }
public  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}
public  java.lang.Object getProperty(java.lang.String property) { return null;}
public  void setProperty(java.lang.String property, java.lang.Object value) { }
public  p.A.E next() { return (p.A.E)null;}
public  p.A.E previous() { return (p.A.E)null;}
public static final  p.A.E $INIT(java.lang.Object... para) { return (p.A.E)null;}
}

{code}",,mxm,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 12 23:18:30 UTC 2014,,,,,,,,,,"0|i2cqxj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Jun/14 23:18;paulk;Should be fixed. Thanks for pointing out the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"SpreadMap is horribly broken - isEmpty, containsKey, keySet etc. all fail",GROOVY-6403,12817180,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,timtiemens,timtiemens,26/Oct/13 22:04,15/Oct/15 18:19,14/Jul/23 06:01,03/Nov/13 03:44,1.8.9,2.1.7,2.2.0-beta-1,,,,,,,,,,,,,,,2.2.0-rc-3,,,,,,,,0,,,,,,,"groovy.lang.SpreadMap implementation is incorrect.
Of the Map contract, it correctly implements:
size() get() equals() hashCode()

The rest of the Map methods have incorrect (missing) implementations:
isEmpty()  keySet() containsKey()  ..etc.

Also, List.toSpreadMap() is broken since it returns an instance of SpreadMap.
",,paulk,timtiemens,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"26/Oct/13 22:13;timtiemens;spreadmap-patch.txt;https://issues.apache.org/jira/secure/attachment/12723057/spreadmap-patch.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 03 03:44:12 UTC 2013,,,,,,,,,,"0|i2bu1j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"26/Oct/13 22:13;timtiemens;Fix tabs;;;","31/Oct/13 16:29;paulk;I think we should apply this. Originally SpreadMap was for internal use only and was correct for all the methods used internally by the groovy codebase. Given that it is in the groovy.lang package though, we should not leave it in its current form!;;;","03/Nov/13 03:44;paulk;fixed - thanks for the suggestion and patch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic causes null-safe operator to call method twice,GROOVY-6402,12817178,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,gcadien,gcadien,25/Oct/13 15:47,29/Oct/13 16:35,14/Jul/23 06:01,28/Oct/13 12:13,2.1.7,,,,,,,,,,,,,,,,,2.1.9,2.2.0-rc-2,,,Static compilation,,,,4,,,,,,,"{code:java}
import groovy.transform.CompileStatic
import java.util.concurrent.atomic.AtomicLong

class Sequencer {
  private final AtomicLong sequenceNumber = new AtomicLong(0)

  public Long getNext() {
    return sequenceNumber.getAndIncrement()
  }
}

@CompileStatic
class Main {
  static void main(String[] args) {
    final seq = new Sequencer()
    (1..5).each {
      println seq.next?.longValue()
    }
  }
}
{code}

With @CompileStatic the output is:
{code}
1
3
5
7
9
{code}
Without @CompileStatic the output is:
{code}
0
1
2
3
4
{code}",,acourtneybrown,gcadien,ilialewis,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-10-25 15:47:34.0,,,,,,,,,,"0|i2cjgv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic type inference bug with overridden methods: causes GroovyCastException at runtime,GROOVY-6401,12811659,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,lhotari,lhotari,23/Oct/13 22:58,29/Oct/13 16:35,14/Jul/23 06:01,24/Oct/13 08:31,2.1.8,,,,,,,,,,,,,,,,,2.1.9,2.2.0-rc-2,,,,,,,0,,,,,,,"{code}
import groovy.transform.CompileStatic

@CompileStatic
interface Greeter {
   public void sayHello()
}

@CompileStatic
class HelloGreeter implements Greeter {
   public void sayHello() {
       println ""Hello world!""
   }
}

@CompileStatic
class A {
   Greeter createGreeter() {
       new HelloGreeter()
   }
   
   void sayHello() {
      // also fails: def greeter = createGreeter()
      // successfull: def greeter = (Greeter)createGreeter()
      Greeter greeter = createGreeter()
      greeter.sayHello()
   }   
}

@CompileStatic
class HelloThereGreeter implements Greeter {
   public void sayHello() {
       println ""Hello there!""
   }
}

@CompileStatic
class B extends A {
   Greeter createGreeter() {
       new HelloThereGreeter()
   }
}


new B().sayHello()
{code}

Throws exception
{code}
Exception thrown
loka 24, 2013 6:53:33 AP. org.codehaus.groovy.runtime.StackTraceUtils sanitize
WARNING: Sanitizing stacktrace:
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'HelloThereGreeter@5a0e8a14' with class 'HelloThereGreeter' to class 'HelloGreeter'
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:360)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:599)
	at A.sayHello(flowtyping_bug.groovy:24)
	at A$sayHello.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at flowtyping_bug.run(flowtyping_bug.groovy:44)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:257)
	at groovy.lang.GroovyShell.run(GroovyShell.java:481)
	at groovy.lang.GroovyShell.run(GroovyShell.java:163)
	at groovy.lang.GroovyShell$run$0.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:954)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
	at groovy.lang.Closure.call(Closure.java:411)
	at groovy.lang.Closure.call(Closure.java:405)
	at groovy.lang.Closure.run(Closure.java:492)
	at java.lang.Thread.run(Thread.java:744)

org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'HelloThereGreeter@5a0e8a14' with class 'HelloThereGreeter' to class 'HelloGreeter'
	at A.sayHello(flowtyping_bug.groovy:24)
	at A$sayHello.call(Unknown Source)
	at flowtyping_bug.run(flowtyping_bug.groovy:44)
{code}

",,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 28 05:47:27 UTC 2013,,,,,,,,,,"0|i2cbgv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Oct/13 22:58;lhotari;This bug is causing http://jira.grails.org/browse/GRAILS-10482;;;","27/Oct/13 23:37;lhotari;The fix seems to be causing some new problems with @CS. 
Some tests in Grails-Groovy 2_1_X joint build are failing (http://hudson.grails.org/job/groovy_2_1_grails_joint_build/lastCompletedBuild/testReport/) because of this problem:

{code}
import groovy.transform.CompileStatic

@CompileStatic
class SynchronousPromise<T> {
    Closure<T> callable
    Object value

    SynchronousPromise(Closure<T> callable) {
        this.callable = callable
    }

    T get() throws Throwable {
        if (value == null) {
            try {
                value = callable.call()
            } catch (e) {
                value = e
            }
        }
        if (value instanceof Throwable) {
            throw value
        }
        return value
    }
}

def promise = new SynchronousPromise({ ""Hello"" })
promise.get()
{code}

Running this example in GroovyConsole 2.1.9-SNAPSHOT throws this exception:
{code}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'Hello' with class 'java.lang.String' to class 'groovy.lang.Closure'
	at SynchronousPromise.get(ConsoleScript4:15)
	at SynchronousPromise$get.call(Unknown Source)
	at ConsoleScript4.run(ConsoleScript4:28)
{code}
;;;","27/Oct/13 23:43;lhotari;This doesn't work:
{code}
import groovy.transform.CompileStatic

@CompileStatic
class SynchronousPromise<T> {
    Closure<T> callable
    Object value

    SynchronousPromise(Closure<T> callable) {
        this.callable = callable
    }

    T get() throws Throwable {
        value=callable.call()
        return value
    }
}

def promise = new SynchronousPromise({ ""Hello"" })
promise.get()
{code}

but it works with this change (remove <T> from callable field):
{code}
import groovy.transform.CompileStatic

@CompileStatic
class SynchronousPromise<T> {
    Closure callable
    Object value

    SynchronousPromise(Closure<T> callable) {
        this.callable = callable
    }

    T get() throws Throwable {
        value=callable.call()
        return value
    }
}

def promise = new SynchronousPromise({ ""Hello"" })
promise.get()
{code};;;","28/Oct/13 05:47;melix;Last comment fixed by https://github.com/groovy/groovy-core/commit/79b7a8a0b7fa8914e35c0fb6f8ee13753b87a0cb;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Constructor call with @CompileStatic causes ArrayIndexOutOfBoundsException during compilation,GROOVY-6400,12811637,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,graemerocher,graemerocher,22/Oct/13 02:54,29/Oct/13 16:35,14/Jul/23 06:01,25/Oct/13 08:23,2.1.8,,,,,,,,,,,,,,,,,2.1.9,2.2.1,,,Static compilation,,,,0,,,,,,,"Problematic definition:

https://github.com/grails/grails-core/blob/master/grails-test/src/main/groovy/org/codehaus/groovy/grails/test/runner/GrailsProjectTestRunner.groovy#L101

Stack trace:

{code}
[ant:groovyc] org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
[ant:groovyc] General error during clas
[ant:groovyc] s generation: size==0
[ant:groovyc] 
[ant:groovyc] java.lang.ArrayIndexOutOfBoundsException: size==0
[ant:groovyc] 	at org.codehaus.groovy.classgen.asm.OperandStack.getTo
[ant:groovyc] pOperand(OperandStack.java:735)
[ant:groovyc] 	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper
[ant:groovyc] .java:299)
[ant:groovyc] 	at org.codehaus.groovy.classgen.asm.sc.StaticTypesBinaryExpressionMultiTypeDispatcher.evaluateEqual(StaticTypesBinar
[ant:groovyc] yExpressionMultiTypeDispatcher.java:222)
[ant:groovyc] 	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper
[ant:groovyc] .java:78)
[ant:groovyc] 	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:543)
[ant:groovyc] 	at org.codehaus.
[ant:groovyc] groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
[ant:groovyc] 	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpre
[ant:groovyc] ssionStatement(StatementWriter.java:604)
[ant:groovyc] 	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGen
[ant:groovyc] erator.java:525)
[ant:groovyc] 	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
[ant:groovyc] 	at org.codehaus.groovy
[ant:groovyc] .classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
[ant:groovyc] 	at org.codehaus.groovy.classgen.asm.sc.StaticTypesSt
[ant:groovyc] atementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
[ant:groovyc] 	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBl
[ant:groovyc] ockStatement(AsmClassGenerator.java:471)
[ant:groovyc] 	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
[ant:groovyc] 	at org.c
[ant:groovyc] odehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
[ant:groovyc] 	at org.codehaus.groovy.ast
[ant:groovyc] .ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
[ant:groovyc] 	at org.codehaus.groovy.classgen.AsmClassGen
[ant:groovyc] erator.visitStdMethod(AsmClassGenerator.java:335)
[ant:groovyc] 	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(As
[ant:groovyc] mClassGenerator.java:292)
[ant:groovyc] 	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:119)
[ant:groovyc] 
[ant:groovyc] 	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructor(AsmClassGenerator.java:407)
[ant:groovyc] 	at org.codehaus.groovy.ast.Cla
[ant:groovyc] ssNode.visitContents(ClassNode.java:1051)
[ant:groovyc] 	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport
[ant:groovyc] .java:50)
[ant:groovyc] 	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
[ant:groovyc] 	at org.codehaus.groovy.cont
[ant:groovyc] rol.CompilationUnit$15.call(CompilationUnit.java:794)
[ant:groovyc] 	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(C
[ant:groovyc] ompilationUnit.java:1036)
[ant:groovyc] 	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
[ant:groovyc] 	at org.cod
[ant:groovyc] ehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
[ant:groovyc] 	at org.codehaus.groovy.control.Compilatio
[ant:groovyc] nUnit.compile(CompilationUnit.java:527)
[ant:groovyc] 	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:506)
[ant:groovyc] 	at or
[ant:groovyc] g.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:59)
[ant:groovyc] 	at org.codehaus.groovy.tools.FileSystemCompiler.
[ant:groovyc] doCompilation(FileSystemCompiler.java:215)
[ant:groovyc] 	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompile
[ant:groovyc] r.java:148)
[ant:groovyc] 	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:178)
[ant:groovyc] 	a
[ant:groovyc] t org.codehaus.groovy.ant.FileSystemCompilerFacade.main(FileSystemCompilerFacade.java:38)
[ant:groovyc] 
[ant:groovyc] 1 error
{code}",,blackdrag,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 25 08:23:22 UTC 2013,,,,,,,,,,"0|i2cpo7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Oct/13 03:00;melix;This might be already fixed as a side effect of GROOVY-6390. If it still fails against {{2.1.9-SNAPSHOT}}, then this is a distinct bug.;;;","22/Oct/13 03:50;blackdrag;The stack contains an evaluateEqual, so I think it is not fixed by GROOVY-6390;;;","25/Oct/13 04:33;blackdrag;reduced example:{code:Java}
class A{}
class B {
    A a = new A()
    @groovy.transform.CompileStatic
    B(){}
}
{code}
moving the transform on the class level makes the error disappear;;;","25/Oct/13 08:23;blackdrag;fixed... this will now produce a compile time error. The example tries to pull non static compiled into a part that is static compiled, which is not allowed, thus the compile time error;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
same linkedlist code different behavior between groovy and java,GROOVY-6396,12817200,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,farmer1992,farmer1992,17/Oct/13 22:27,17/May/17 12:50,14/Jul/23 06:01,19/Sep/16 01:18,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,jdk conflict,,,,2,breaking,,,,,,"I am using `linkedlist` as a stack in groovy 

as doc says, `pop()` take elm from the first

    Stack Method  Equivalent Deque Method  
    push(e)       addFirst(e) 
    pop()         removeFirst()


so a `linkedlist` [1,2,3] should pop() 1 2 3

and it does in Java, but does NOT in groovy. WHY?

test below

{code:title=A.java}
import java.util.*;
    
public class A{
    
    
    public static void main(String[] args){
    
        String[] x = ""1/2/3/"".split(""/"");
        LinkedList <String> stack = new LinkedList<String>(Arrays.asList(x));
        System.out.println(stack.pop());
    }
}
{code}

compile and run
{noformat}
$ javac A.java
$ java A
1
{noformat}
runing in groovy
{noformat}    
$ ln -s A.java A.groovy
$ groovy A.groovy
3
{noformat}

here is my java and groovy version
{noformat}
$ java -version
java version ""1.6.0_51""
Java(TM) SE Runtime Environment (build 1.6.0_51-b11-457-11M4509)
Java HotSpot(TM) 64-Bit Server VM (build 20.51-b01-457, mixed mode)

$ groovy -version
Groovy Version: 2.1.5 JVM: 1.6.0_51 Vendor: Apple Inc. OS: Mac OS X
{noformat}
",,farmer1992,githubbot,jkemnade,mjjustin,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7937,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 17 12:50:27 UTC 2017,,,,,,,,,,"0|i2ccpz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Oct/13 17:25;paulk;add code tags;;;","20/Oct/13 17:49;paulk;Possibly pop was added to Groovy prior to Java 1.6. I presume if you use the matching push and pop operators you will get the expected behavior. We'll need to discuss how best to handle this anomaly as it's a breaking change but it would be nice not to have this difference.;;;","23/Oct/13 03:26;paulk;possibly a duplicate of GROOVY-4181;;;","29/Apr/14 03:04;paulk;I think this was accidentally closed prematurely;;;","29/Apr/14 03:05;paulk;Adding the example from the closed duplicate issue:
{code}
Deque stack = new LinkedList()

stack.push(1)
stack.push(2)

assert stack.peek() == 2
{code}
;;;","29/Apr/14 06:34;paulk;PR here but please read caveats in PR comment before merging:
https://github.com/groovy/groovy-core/pull/400
;;;","13/Sep/16 06:36;paulk;There are two parts to this issue. One is that DGM methods on an interface are being selected ahead of methods already available within the instance. The other is that the DGM push/pop methods for Lists store/retrieve items in the reverse order to the backing list compared with Java's Deque interface. This issue will solve the latter of those two issues. The clone will be for solving the former.;;;","13/Sep/16 06:37;paulk;Ignore above PR, I'll create two new PRs dealing with the two parts to this issue.;;;","13/Sep/16 09:43;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/419

    GROOVY-6396: same linkedlist code different behavior between groovy a…

    …nd java

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy6396

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/419.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #419
    
----
commit 72bcd6ed039b854678228653daf88acc8604676b
Author: paulk <paulk@asert.com.au>
Date:   2016-09-13T09:40:31Z

    GROOVY-6396: same linkedlist code different behavior between groovy and java

----
;;;","18/Sep/16 04:43;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/419#discussion_r79297398
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -8928,6 +8932,27 @@ public int compare(Map.Entry<K, V> e1, Map.Entry<K, V> e2) {
             if (self.isEmpty()) {
                 throw new NoSuchElementException(""Cannot pop() an empty List"");
             }
    +        return self.remove(0);
    +    }
    +
    +    /**
    +     * Removes the last item from the List. Using add() and pop()
    --- End diff --
    
    Should this be `removeLast()` instead of `pop()`
;;;","18/Sep/16 04:43;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/419#discussion_r79297434
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -8928,6 +8932,27 @@ public int compare(Map.Entry<K, V> e1, Map.Entry<K, V> e2) {
             if (self.isEmpty()) {
                 throw new NoSuchElementException(""Cannot pop() an empty List"");
             }
    +        return self.remove(0);
    +    }
    +
    +    /**
    +     * Removes the last item from the List. Using add() and pop()
    +     * is similar to push and pop on a Stack.
    +     * <pre class=""groovyTestCase"">
    +     * def list = [""a"", false, 2]
    +     * assert list.removeLast() == 2
    +     * assert list == [""a"", false]
    +     * </pre>
    +     *
    +     * @param self a List
    +     * @return the item removed from the List
    +     * @throws NoSuchElementException if the list is empty and you try to pop() it.
    --- End diff --
    
    I think `if the list is empty` suffices here and don't think the rest of the sentence is needed (same for `pop` throws).
;;;","18/Sep/16 04:43;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/419#discussion_r79297378
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -8913,11 +8913,15 @@ public int compare(Map.Entry<K, V> e1, Map.Entry<K, V> e2) {
         }
     
         /**
    -     * Removes the last item from the List. Using add() and pop()
    -     * is similar to push and pop on a Stack.
    -     * <pre class=""groovyTestCase"">def list = [""a"", false, 2]
    -     * assert list.pop() == 2
    -     * assert list == [""a"", false]</pre>
    +     * Removes the initial item from the List, similar to pop on a Stack.
    --- End diff --
    
    I wonder if most associate removing items from the top of a Stack, so in this case would it make sense to say 
    >..similar to pop on a Deque.
;;;","18/Sep/16 04:43;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/419#discussion_r79297452
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -8966,20 +8991,24 @@ public int compare(Map.Entry<K, V> e1, Map.Entry<K, V> e2) {
         }
     
         /**
    -     * Appends an item to the List. Synonym for add().
    -     * <pre class=""groovyTestCase"">def list = [3, 4, 2]
    +     * Prepends an item to the start of the List, similar to push on a stack.
    --- End diff --
    
    Same comment as with pop, would using Deque instead of Stack make sense?
;;;","18/Sep/16 04:43;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/419#discussion_r79297442
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -8928,6 +8932,27 @@ public int compare(Map.Entry<K, V> e1, Map.Entry<K, V> e2) {
             if (self.isEmpty()) {
                 throw new NoSuchElementException(""Cannot pop() an empty List"");
             }
    +        return self.remove(0);
    +    }
    +
    +    /**
    +     * Removes the last item from the List. Using add() and pop()
    +     * is similar to push and pop on a Stack.
    +     * <pre class=""groovyTestCase"">
    +     * def list = [""a"", false, 2]
    +     * assert list.removeLast() == 2
    +     * assert list == [""a"", false]
    +     * </pre>
    +     *
    +     * @param self a List
    +     * @return the item removed from the List
    +     * @throws NoSuchElementException if the list is empty and you try to pop() it.
    +     * @since 2.5.0
    +     */
    +    public static <T> T removeLast(List<T> self) {
    +        if (self.isEmpty()) {
    +            throw new NoSuchElementException(""Cannot pop() an empty List"");
    --- End diff --
    
    `pop()` -> `removeLast()`
;;;","18/Sep/16 21:31;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/419
;;;","19/Sep/16 01:18;paulk;Proposed PR merged. Thanks for reporting the issue.;;;","17/May/17 08:56;jkemnade;I must admit that I'm not a fan of this change. It is a breaking change and breaks some of my scripts.
{code}
def list = []
list.push('foo')
list.push('bar')
assert list == ['foo', 'bar']
{code}
works with 2.4.x but fails with 2.5-alpha-1.;;;","17/May/17 09:12;jkemnade;Since GROOVY-7937 gives the {{LinkedList}} method precedence over the {{DGM}} method, this change is not technically needed. It just serves the purpose of giving Groovy's {{List.push}} the same semantics as {{Deque.push}}.;;;","17/May/17 11:10;paulk;[~jkemnade] would you expect {{LinkedList}} and {{ArrayList}} to behave differently?;;;","17/May/17 11:27;jkemnade;That depends on whether I'm currently thinking in Stack or in List semantics.
And I think there are more questions that we need to ask ourselves:

Which output do we expect from the code snipped I posted above?
I'm not even sure about that one. Depends on whether you come from Stack or JavaScript (where Array.push pushes to the end).

What is the use case for the default method?
This will only be used for a List instance that does not implement push itself, like {{[]}} in a Groovy script. How should that behave?

Do we want a change in behavior from Groovy 2.4 to Groovy 2.5, which is a minor level release after all?;;;","17/May/17 12:40;paulk;This was debated back and forth over several years before we made the current call. Our reasoning is as follows.
We basically decided that users using {{[]}} should to some degree not care whether it is a LinkedList or an ArrayList, it's just a list and the exact kind is an implementation detail that we might decide to change in the future.
If we did change it to be a LinkedList, we would want to follow Java's behavior. Our users expected other Lists to behave in the same way.
So the discrepancy with Java was deemed a bug. We allow breaking changes which fix bugs in minor releases but decided it wasn't appropriate in a point release.
The issue is marked as breaking. Users using only stack operations, e.g. push, pop won't be affected. It's just when you mix the stack and list behaviors that the issue arises.
We don't like any breaking changes but the difference with Java was deemed to be unacceptable too.;;;","17/May/17 12:50;jkemnade;Okay, I guess I can find a way around the issue. I should be able to override the behavior by implementing an override inside my own category, i.e.
{code}
class ListPushOverride {
  public static <T> boolean push(List<T> self, T value) {
        return self.add(value);
  }
}

use(ListPushOverride){
    def list = []
    list.push('foo')
    list.push('bar')
    assert list == ['foo', 'bar']
}
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovysh: filename completion of save command broken,GROOVY-6392,12817118,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,pschumacher,pschumacher,16/Oct/13 15:10,26/Nov/13 14:48,14/Jul/23 06:01,16/Oct/13 15:45,2.2.0-rc-1,,,,,,,,,,,,,,,,,2.2.1,,,,Groovysh,,,,0,,,,,,,"see: [pull request|https://github.com/groovy/groovy-core/pull/272] for details",,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-10-16 15:10:30.0,,,,,,,,,,"0|i2ctfb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovysh: broken alias and register commands,GROOVY-6391,12817142,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,tkruse,tkruse,15/Oct/13 11:55,26/Nov/13 14:48,14/Jul/23 06:01,15/Oct/13 14:27,2.2.0-rc-1,,,,,,,,,,,,,,,,,2.2.1,,,,Groovysh,,,,0,,,,,,,"To reproduce, start groovysh
groovy:000> alias foo bar
ERROR groovy.lang.MissingPropertyException:
No such property: completor for class: org.codehaus.groovy.tools.shell.InteractiveShellRunner
Possible solutions: completer",Ubuntu Precise Java7,pschumacher,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 15 14:27:19 UTC 2013,,,,,,,,,,"0|i2brsn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Oct/13 11:57;tkruse;See https://github.com/groovy/groovy-core/pull/269;;;","15/Oct/13 11:59;tkruse;Not sure whether this should be labelled ""Major"". I don't know if those commands are used by anyone in the world. The register command is not even documented:
http://groovy.codehaus.org/Groovy+Shell#GroovyShell-Commands

The patch is also quite tiny;;;","15/Oct/13 14:27;pschumacher;Pull request merged. Thanks for reporting the issue and thanks for submitting a pull request to fix it. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Super constructor calls are made using MOP with @CompileStatic,GROOVY-6390,12817173,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,15/Oct/13 09:53,29/Oct/13 16:35,14/Jul/23 06:01,15/Oct/13 10:12,,,,,,,,,,,,,,,,,,2.1.9,2.2.0-rc-2,,,,,,,0,,,,,,,"Even if the type checker recognizes super constructor calls, the generated bytecode still uses the dynamic path, that is to say the meta-object protocol path.

This is related to GROOVY-6080 because {{@CompileStatic}} can't be used as a workaround.",,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-10-15 09:53:36.0,,,,,,,,,,"0|i2cpuf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovysh flawed display of collections,GROOVY-6389,12817181,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,tkruse,tkruse,15/Oct/13 09:14,26/Nov/13 14:48,14/Jul/23 06:01,15/Oct/13 13:28,2.2.0-rc-1,,,,,,,,,,,,,,,,,2.2.1,,,,Groovysh,,,,0,,,,,,,"To reproduce, in groovysh:

groovy:000> ['x': 42]
===> {x=42}

Should be [x:42]

groovy:000> co = new ConfigObject()
===> groovy.util.ConfigObject@51af7c57 

Should be: [:]

See https://github.com/groovy/groovy-core/pull/268",JVM: 1.7.0_40 Vendor: Oracle Corporation OS: Linux,pschumacher,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 15 13:28:20 UTC 2013,,,,,,,,,,"0|i2bx0f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Oct/13 13:28;pschumacher;Pull request merged. Thanks for reporting and thanks for the pull request. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovysh completion vulnerable to map types with 'class' entry,GROOVY-6387,12818255,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,tkruse,tkruse,14/Oct/13 10:38,26/Nov/13 14:48,14/Jul/23 06:01,14/Oct/13 15:39,2.2.0-beta-2,,,,,,,,,,,,,,,,,2.2.1,,,,Groovysh,,,,0,,,,,,,"To reproduce, start groovysh, enter:

{noformat} 
groovy:000> config = new ConfigSlurper().parse(new File('foo.groovy').toURL())
groovy:000> config.
{noformat} 

press tab
should list properties, newline instead

For full stack, run groovysh --debug

{quote}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'groovy.util.ConfigObject@6ad21538' with class 'groovy.util.ConfigObject' to class 'java.lang.Class' due to: java.lang.ClassNotFoundException: groovy.util.ConfigObject@6ad21538
        at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToClass(DefaultTypeTransformation.java:380)
        at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:249)
        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:599)
        at org.codehaus.groovy.tools.shell.completion.ReflectionCompletor.getPublicFieldsAndMethods(ReflectionCompletor.groovy:277)
        at org.codehaus.groovy.tools.shell.completion.ReflectionCompletor$getPublicFieldsAndMethods.callStatic(Unknown Source)
        at org.codehaus.groovy.tools.shell.completion.ReflectionCompletor.complete(ReflectionCompletor.groovy:74)
        at org.codehaus.groovy.tools.shell.completion.ReflectionCompletor$complete.call(Unknown Source)
{quote}

This line fails:
Class clazz = instance.class

I last touched the failing class ReflectionCompletor, but sadly I currently have no working environment to run all tests.",Ubuntu Precise Java 6,pschumacher,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 14 15:39:53 UTC 2013,,,,,,,,,,"0|i2c02v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Oct/13 11:19;tkruse;See https://github.com/groovy/groovy-core/pull/266.;;;","14/Oct/13 12:00;tkruse;Updated bug title and text after understanding what happened.;;;","14/Oct/13 15:39;pschumacher;Thanks! :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovyc task throws ZipException when it encounters classpath resources that are not jars,GROOVY-6386,12817154,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,jkschneider,jkschneider,11/Oct/13 23:22,14/Oct/13 16:53,14/Jul/23 06:01,14/Oct/13 03:42,2.1.7,,,,,,,,,,,,,,,,,2.1.8,,,,Ant integration,,,,0,,,,,,,"While it could be argued that classpath resources should never contain files that are not java resources, in practice classpath resources built from dependency management systems like Ivy sometimes do contain such resources.  Importantly, the javac task successfully ignores them rather than failing.",,jkschneider,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 14 03:42:39 UTC 2013,,,,,,,,,,"0|i2c29b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Oct/13 11:54;jkschneider;Pull request submitted with fix: https://github.com/groovy/groovy-core/pull/265;;;","14/Oct/13 03:42;melix;Merged, thank you!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.bat: Can't use question mark in script parameters,GROOVY-6385,12817167,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,pschumacher,pschumacher,11/Oct/13 13:52,18/Nov/13 12:53,14/Jul/23 06:01,23/Oct/13 03:30,2.1.7,,,,,,,,,,,,,,,,,2.1.9,2.2.1,,,command line processing,,,,0,,,,,,,see [http://groovy.329449.n5.nabble.com/Can-t-use-question-mark-in-script-parameters-td5716658.html] for details,Windows 7,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5347,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 23 03:38:08 UTC 2013,,,,,,,,,,"0|i2ctjj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Oct/13 14:04;pschumacher;Created a [pull request|https://github.com/groovy/groovy-core/pull/264] out of Dominique's suggestion on the mailing list.;;;","23/Oct/13 03:38;pschumacher;Pull request applied. All credit goes to Dominique for supplying the solution.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Change all calls to Class.forName to direct dispatch so that differences around classloading between Groovy and Java are resolved,GROOVY-6384,12817185,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,graemerocher,graemerocher,10/Oct/13 07:44,14/Oct/13 16:53,14/Jul/23 06:01,10/Oct/13 09:29,2.1.7,,,,,,,,,,,,,,,,,2.1.8,2.2.0-rc-1,,,,,,,0,,,,,,,"See issue http://jira.grails.org/browse/GRAILS-10562

Currently in Groovy if you do Class.forName("".."") for dynamic dispatch the classloader for the calling class is not used. This completely breaks the semantics of the method as described in the javadoc http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#forName(java.lang.String)

Given that monkey patching Class.forName("".."") is an unbelievably bad idea and the behavior should be the same as Java the recommendation is that all calls to Class.forName("".."") are made directly. This has a number of benefits including:

* Same semantics as the original Java method
* Improved performance
* Fewer long explanation as to why this method is broken to users",,blackdrag,graemerocher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 10 09:29:54 UTC 2013,,,,,,,,,,"0|i2cmcv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Oct/13 09:29;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong example in the api of class Map(dropWhile),GROOVY-6379,12811653,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,janschumacher,janschumacher,08/Oct/13 03:14,14/Oct/13 16:54,14/Jul/23 06:01,10/Oct/13 05:23,,,,,,,,,,,,,,,,,,2.1.8,2.2.0-rc-1,,,,,,,0,,,,,,,"In the api of class map, is the example in the description for the method dropWhile(Closure closure) incorrect.
http://groovy.codehaus.org/groovy-jdk/java/util/Map.html#dropWhile(groovy.lang.Closure)
{code}
def shopping = [milk:1, bread:2, chocolate:3]
assert shopping.takeWhile{ it.key.size() < 6 } == [milk:1, bread:2]
assert shopping.takeWhile{ it.value % 2 } == [milk:1]
assert shopping.takeWhile{ k, v -> k.size() + v <= 7 } == [milk:1, bread:2]
{code}
It must be 
{code}
def shopping = [milk:1, bread:2, chocolate:3]
assert shopping.dropWhile{ it.key.size() < 6 } == [milk:1, bread:2]
assert shopping.dropWhile{ it.value % 2 } == [milk:1]
assert shopping.dropWhile{ k, v -> k.size() + v <= 7 } == [milk:1, bread:2]
{code}",,blackdrag,guillaume,janschumacher,paulk,,,,,,,,,,,,,,,,,,,,,,600,600,,0%,600,600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 10 05:23:26 UTC 2013,,,,,,,,,,"0|i2c8vb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Oct/13 04:22;blackdrag;just renaming takeWhile to dropWhile is incorrect 
{code}
shopping.dropWhile{ it.key.size() < 6 }
{code}
will leave only chocolate; 
{code}
shopping.dropWhile{ it.value % 2 }
{code}
leaves [bread:2, chocolate:3]; 
{code}
shopping.dropWhile { k, v -> k.size() + v <= 7 }
{code}
is {{[chocolate:3]}} again.;;;","10/Oct/13 05:23;paulk;Fixed. Thanks for spotting that typo/cut-n-paste glitch.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Assignment of values from Map to another causes ""Incompatible generic argument types."" when using @TypeChecked",GROOVY-6378,12817147,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,blorgo71,blorgo71,07/Oct/13 12:43,28/Dec/14 06:55,14/Jul/23 06:01,28/Dec/14 06:55,2.2.0-beta-2,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Compiler,,,,1,,,,,,,"The following script causes a compilation error since Groovy 2.2.

The error occurs as soon as you start putting 'mixed' types in the Maps (e.g. Integer and String). I checked it again in Groovy 2.1.3 and it compiled fine.

{code}
import groovy.transform.TypeChecked

@TypeChecked
def myFunction() {
  Map mapA=[e:1,et:'Error',ev:'Hello']
  Map mapB=[e:0,et:'No Error',ev:'World']
  
  mapB.e=mapA.e  

// causes compilation error: [Static type checking] - Incompatible generic argument types. Cannot assign java.io.Serializable <? extends java.io.Serializable> to: java.io.Serializable <? extends java.io.Serializable>

  println ""${mapB.e}""
}

myFunction()
{code}",Tested on Windows and Mac Os with Java 1.7,blorgo71,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 06:55:26 UTC 2014,,,,,,,,,,"0|i2cd73:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Oct/13 05:08;blorgo71;I tried to debug the problem. So far I found out, that the error first comes up in Groovy 2.1.4. The method checkCompatibleAssignmentTypes() in StaticTypeCheckingSupport says left and right Expression are compatible (in method typeCheckAssignment() of Class StaticTypeCheckingVisitor). The 2.1.3 version resulted in false and called the DefaultTypeCheckedExtension. Newer versions run through the end and finally the method matches() in GenericsTypeMatcher is called. This method returns false and so java.io.Serializable <? extends java.io.Serializable> != java.io.Serializable <? extends java.io.Serializable>.;;;","28/Dec/14 06:55;pschumacher;Thanks for reporting. With groovy 2.4.0-rc-1 your example works (again).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DateGroovyMethods#updated should be renamed to DateGroovyMethods#copyWith,GROOVY-6375,12813725,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,03/Oct/13 17:52,07/Apr/15 19:06,14/Jul/23 06:01,03/Oct/13 23:37,,,,,,,,,,,,,,,,,,2.2.0-rc-1,,,,,,,,0,,,,,,,"This would align the name with the copyWith recently added to the Immutable transform. The ""updated"" method should be deprecated.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-10-03 17:52:53.0,,,,,,,,,,"0|i2c29j:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Verify error when coercing Map for a final class,GROOVY-6374,12817162,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,paulk,,03/Oct/13 17:50,15/Oct/15 18:19,14/Jul/23 06:01,22/Nov/13 09:22,2.2.0-beta-2,,,,,,,,,,,,,,,,,2.2.1,,,,,,,,0,,,,,,,"{code}
final class Foo {}
[bar: { -> }] as Foo
{code}
ProxyGenerator or ProxyGeneratorAdapter should be checking for the final class and providing a nicer error message.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-10-03 17:50:47.0,,,,,,,,,,"0|i2cawv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Immutable fails to recognize non immutable classes,GROOVY-6372,12811647,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,melix,melix,03/Oct/13 03:18,14/Oct/13 16:53,14/Jul/23 06:01,10/Oct/13 07:43,2.1.7,,,,,,,,,,,,,,,,,2.1.8,2.2.0-rc-1,,,,,,,0,,,,,,,"The following test will compile fine and not fail, but it should not, because the {{Point}} class is not immutable. The commented {{knownImmutableClasses}} parameter should be mandatory for this to compile:

{code}
import groovy.transform.Immutable
import groovy.transform.TupleConstructor

@TupleConstructor
final class Point {
    final int x
    final int y
    public String toString() { ""($x,$y)"" }
}

@Immutable//(knownImmutables=['a','b','c'])
class Triangle {
    Point a,b,c
}

def p = new Triangle(a:[47,22], b:[12,12],c:[88,17])
assert p.toString() == 'Triangle((47,22), (12,12), (88,17))' // @ToString equivalent
try {
    p.a = [0,0]
} catch (ReadOnlyPropertyException rope) {
    println 'ReadOnly property'
}
{code}",,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 10 07:43:35 UTC 2013,,,,,,,,,,"0|i2c77b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Oct/13 04:38;paulk;This is probably checkable at compile time but shouldn't break at runtime - I just committed a change for the runtime behavior. Compile-time checking exploration to follow ...;;;","10/Oct/13 07:43;paulk;Some cases, e.g. enums defined with the same source file as an Immutable might still be checked at runtime (depending on compilation order) but the classname whitelist checking is now at compile time and the runtime checks have been tightened up too. You could always add enums into the explicit whitelist if you need stricter behavior.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closure taking Object[] in @CompileStatic class gets actual parameters wrapped in additional Object[],GROOVY-6365,12817106,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,acourtneybrown,acourtneybrown,26/Sep/13 15:18,14/Oct/13 16:53,14/Jul/23 06:01,08/Oct/13 04:17,2.1.7,,,,,,,,,,,,,,,,,2.1.8,2.2.0-rc-1,,,Static compilation,,,,4,,,,,,,"{code}
@groovy.transform.CompileStatic
class MyClass {
  void method() {
    final cl = { Object[] args -> println ""cl: ${args}"" }
    cl('c1-1', 'c1-2')
  }
}

class MyClass2 {
  void method() {
    final cl = { Object[] args -> println ""cl2: ${args}"" }
    cl('c1-1', 'c1-2')
  }
}

new MyClass().method()
new MyClass2().method()
{code}

Produces the output:

{code}
cl: [[c1-1, c1-2]]
cl2: [c1-1, c1-2]
{code}

indicating that the Closure in the statically-compiled MyClass is receiving the arguments wrapped in an additional Object[].",,acourtneybrown,blackdrag,gcadien,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 08 04:17:26 UTC 2013,,,,,,,,,,"0|i2cnpr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Oct/13 04:17;blackdrag;The issue showed an old issue in the Groovy AST, that only had no effect in the past. This is now fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"The extension mechanism do not work when a method named ""X"" is a added to class having a private method named ""X""",GROOVY-6363,12817161,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,pablo72,pablo72,26/Sep/13 08:31,25/Jan/22 16:42,14/Jul/23 06:01,25/Jan/22 15:14,2.1.6,,,,,,,,,,,,,,,,,5.0.0-alpha-1,,,,groovy-runtime,,,,0,,,,,,,"Take in consideration the following example, extend the java.nio.Path interface adding a new method named ""isEmpty"". 

The extension method signature would be: 

def static boolean isEmpty( Path path ) { 
: 
} 


But the above method is never invoked because the UnixPath which implements the Path interface declares a *private* method isEmpty() as well. 



",,emilles,paolodt,,,,,,,,,,,,,,"eric-milles opened a new pull request #1678:
URL: https://github.com/apache/groovy/pull/1678


   category with same or more specific self-type can already replace method (of any visibility)
   
   https://issues.apache.org/jira/browse/GROOVY-6363


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;21/Jan/22 16:20;githubbot;600","eric-milles merged pull request #1678:
URL: https://github.com/apache/groovy/pull/1678


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;25/Jan/22 15:14;githubbot;600","eric-milles merged pull request #1678:
URL: https://github.com/apache/groovy/pull/1678


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;25/Jan/22 16:42;githubbot;600",,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 25 15:14:41 UTC 2022,,,,,,,,,,"0|i2borr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jan/22 16:20;emilles;https://github.com/apache/groovy/pull/1678;;;","25/Jan/22 15:14;emilles;https://github.com/apache/groovy/commit/c63c466c24b2196357067633f195601a770fc83a;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic doesn't determine correct type for return from generic static method,GROOVY-6358,12817146,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,acourtneybrown,acourtneybrown,23/Sep/13 16:05,20/May/14 05:31,14/Jul/23 06:01,16/May/14 12:34,2.1.7,,,,,,,,,,,,,,,,,2.3.1,,,,Static compilation,,,,4,,,,,,,"The following code produces the compilation error:

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
bad.groovy: 20: [Static type checking] - Cannot assign value of type java.lang.Object to variable of type Ifc
 @ line 20, column 16.
   	    Ifc ifc = Generator.create(Ifc)
                  ^

1 error
{code}

{code:java}
import groovy.transform.CompileStatic
import java.lang.reflect.Method

interface Ifc {
	void method()
}

@CompileStatic
class Generator {
	static <T> T create (Class<T> clazz) {
	    return clazz.methods.collectEntries { Method method ->
	        [ (method.name) : { println ""${method.name} called""} ]
	    }.asType(clazz)
	}
}

@CompileStatic
class User {
	static void main() {
	    Ifc ifc = Generator.create(Ifc)
	    ifc.method()
	}
}

User.main()
{code}

Without the @CompileStatic on the User class, the code compiles and runs as expected.",,acourtneybrown,gcadien,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 16 12:34:12 UTC 2014,,,,,,,,,,"0|i2cpqf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/May/14 12:34;pschumacher;Fixed. Thanks for reporting.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inner classes in Groovy should have the same access modifiers as in Java,GROOVY-6357,12812123,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,rene.scheibe,rene.scheibe,20/Sep/13 04:29,14/Oct/13 16:53,14/Jul/23 06:01,14/Oct/13 03:38,2.1.7,,,,,,,,,,,,,,,,,2.1.8,,,,bytecode,class generator,,,0,,,,,,,"There are differences in the flags/access modifiers for inner classes between Java and Groovy.

Java code:
{code}
public class Java {
              class InnerPackage { }
    public    class InnerPublic { }
    protected class InnerProtected { }
    private   class InnerPrivate { }
}
{code}

Groovy code:
{code}
import groovy.transform.PackageScope

class Groovy {
    @PackageScope class InnerPackage { }
    public        class InnerPublic { }
    protected     class InnerProtected { }
    private       class InnerPrivate { }
}
{code}

Flags for inner classes (extracted via javap):
|| ||package scope ||public scope ||protected scope ||private scope ||
|Java   |ACC_SUPER |ACC_SUPER, ACC_PUBLIC |ACC_SUPER, ACC_PUBLIC                |ACC_SUPER |
|Groovy |ACC_SUPER |ACC_SUPER, ACC_PUBLIC |ACC_SUPER, 0x4 (means ACC_PROTECTED) |ACC_SUPER, 0x2 (means ACC_PRIVATE) |

Comment from blackdrag:
{quote}
I think as Groovy does is correct. But we did learn only recently, that 
the VMs have trouble doing it like this. AS a result we forbid the 
private modifer on classes... but looks like we forgot inner classes.
{quote}

These different flags for example result in Cobertura failing to instrument the inner classes because ASM throws this exception:
{noformat}
Unable to instrument file build/instrumented_classes/Groovy$InnerPrivate.class
java.lang.IllegalArgumentException: Invalid access flags: 34
        at org.objectweb.asm.util.CheckClassAdapter.checkAccess(Unknown Source)
        at org.objectweb.asm.util.CheckClassAdapter.visit(Unknown Source)
        at org.objectweb.asm.ClassVisitor.visit(Unknown Source)
        at net.sourceforge.cobertura.instrument.pass1.DetectDuplicatedCodeClassVisitor.visit(DetectDuplicatedCodeClassVisitor.java:205)
        at org.objectweb.asm.ClassReader.accept(Unknown Source)
        at org.objectweb.asm.ClassReader.accept(Unknown Source)
        at net.sourceforge.cobertura.instrument.CoberturaInstrumenter.instrumentClass(CoberturaInstrumenter.java:153)
        at net.sourceforge.cobertura.instrument.CoberturaInstrumenter.instrumentClass(CoberturaInstrumenter.java:121)
        at net.sourceforge.cobertura.instrument.CoberturaInstrumenter.addInstrumentationToSingleClass(CoberturaInstrumenter.java:234)
        at net.sourceforge.cobertura.instrument.Main.addInstrumentationToSingleClass(Main.java:298)
        at net.sourceforge.cobertura.instrument.Main.addInstrumentation(Main.java:307)
        at net.sourceforge.cobertura.instrument.Main.addInstrumentation(Main.java:316)
        at net.sourceforge.cobertura.instrument.Main.parseArguments(Main.java:399)
        at net.sourceforge.cobertura.instrument.Main.main(Main.java:421)
        at net.saliman.gradle.plugin.cobertura.CoberturaRunner.instrument(CoberturaRunner.java:79)
{noformat}",,darxriggs,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Sep/13 04:52;groovy-inner-classes.tar.gz;https://issues.apache.org/jira/secure/attachment/12722392/groovy-inner-classes.tar.gz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-09-20 04:29:57.0,,,,,,,,,,"0|i2bxq7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Working with namespaced attributes awkward with XmlSlurper,GROOVY-6356,12811638,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,alpheratz,alpheratz,19/Sep/13 19:33,24/Apr/14 19:00,14/Jul/23 06:01,13/Apr/14 23:42,2.1.7,,,,,,,,,,,,,,,,,2.3.0-rc-1,,,,XML Processing,,,,0,,,,,,,"When trying to update (or remove) the xlink:title attribute in the following, one has to use the full namespaced tag name.

{code}
import groovy.xml.*

def xmlSource = '''<bob:root 
  xmlns:bob=""stuff""
  xmlns:gmi=""http://www.isotc211.org/2005/gmi""
  xmlns:xlink=""http://www.w3.org/1999/xlink"">
  <gmi:instrument xlink:title=""$INSTRUMENT""/>
</bob:root>'''

def bobRoot = new XmlSlurper(false, true).parseText(xmlSource).declareNamespace(bob: 'stuff', ns2: 'http://www.example.org/NS2', gmi: ""http://www.isotc211.org/2005/gmi"")

def instrument = bobRoot.'gmi:instrument'

// NB: does NOT work: instrument[0].attributes().remove('xlink:title')
// does work: instrument[0].attributes().remove('{http://www.w3.org/1999/xlink}title')

// NB: leads to duplicate attribute: instrument.'@xlink:title' = 'XXX'
instrument.'@{http://www.w3.org/1999/xlink}title' = 'XXX'
println instrument.'@xlink:title'

println new StreamingMarkupBuilder().bind {
  mkp.yield instrument
}.toString()

'OK'
{code}

I SHOULD be able to simply do:

{code}
instrument.'@xlink:title' = 'XXX'
{code}

Note that I can do:

{code}
println instrument.'@xlink:title'
{code}

So there is an inconsistency/incompleteness/confusion here.

I'm also wondering why I needed to use 'instrument[0]' to get at the attributes. Also seems 'odd' to me.",Win 8/64 java 1.7_40,alpheratz,guillaume,lhotari,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 15 09:17:34 UTC 2014,,,,,,,,,,"0|i2ct8f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Apr/14 23:42;paulk;Hi Bob, should be fixed for the upcoming 2.3 release. If you can test it a bit more, that would be great. I haven't merged back onto older versions at this stage but that can be done if there is sufficient demand.;;;","14/Apr/14 04:30;alpheratz;Downloaded the latest snapshot whole and ran against that.

All looks good:

{code}
groovy> import groovy.xml.* 
groovy> println GroovySystem.getVersion() 
groovy> def xmlSource = '''<bob:root  
groovy>   xmlns:bob=""stuff"" 
groovy>   xmlns:gmi=""http://www.isotc211.org/2005/gmi"" 
groovy>   xmlns:xlink=""http://www.w3.org/1999/xlink""> 
groovy>   <gmi:instrument xlink:title=""$INSTRUMENT""/> 
groovy> </bob:root>''' 
groovy> def bobRoot = new XmlSlurper(false, true). 
groovy>                     parseText(xmlSource). 
groovy>                     declareNamespace(bob: 'stuff',  
groovy>                                      ns2: 'http://www.example.org/NS2', 
groovy>                                      gmi: ""http://www.isotc211.org/2005/gmi"") 
groovy> def instrument = bobRoot.'gmi:instrument' 
groovy> println new StreamingMarkupBuilder().bind { 
groovy>   mkp.yield instrument 
groovy> }.toString() 
groovy> instrument[0].attributes().remove('xlink:title') 
groovy> println new StreamingMarkupBuilder().bind { 
groovy>   mkp.yield instrument 
groovy> }.toString() 
groovy> instrument.'@xlink:title' = 'XXX' 
groovy> println new StreamingMarkupBuilder().bind { 
groovy>   mkp.yield instrument 
groovy> }.toString() 
groovy> 'OK' 
 
2.3.0-SNAPSHOT
<gmi:instrument xlink:title='$INSTRUMENT' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:gmi='http://www.isotc211.org/2005/gmi'></gmi:instrument>
<gmi:instrument xmlns:gmi='http://www.isotc211.org/2005/gmi'></gmi:instrument>
<gmi:instrument xlink:title='XXX' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns:gmi='http://www.isotc211.org/2005/gmi'></gmi:instrument>
Result: OK
{code}

Nice job. Thanks.
;;;","15/Apr/14 02:23;lhotari;Grails Groovy 2.3 JDK 8 joint build started failing. [NPE at groovy.util.slurpersupport.NamespaceAwareHashMap.adjustForNamespaceIfNeeded(NamespaceAwareHashMap.java:75)| http://hudson.grails.org/view/Grails%202.4.x/job/groovy_2_3_jdk8_grails_joint_build/102/testReport/org.codehaus.groovy.grails.web.pages.ext.jsp/SimpleJspTagTests/testSimpleTagUsage/]

{code}
java.lang.NullPointerException
	at groovy.util.slurpersupport.NamespaceAwareHashMap.adjustForNamespaceIfNeeded(NamespaceAwareHashMap.java:75)
	at groovy.util.slurpersupport.NamespaceAwareHashMap.put(NamespaceAwareHashMap.java:55)
	at groovy.util.slurpersupport.NamespaceAwareHashMap.put(NamespaceAwareHashMap.java:24)
	at groovy.util.XmlSlurper.startElement(XmlSlurper.java:398)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.startElement(AbstractSAXParser.java:509)
	at com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator.startElement(XMLDTDValidator.java:745)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanStartElement(XMLDocumentFragmentScannerImpl.java:1362)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl$ContentDriver.scanRootElementHook(XMLDocumentScannerImpl.java:1292)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:3122)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl$PrologDriver.next(XMLDocumentScannerImpl.java:880)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:606)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:510)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:848)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:777)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1213)
	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:649)
	at groovy.util.XmlSlurper.parse(XmlSlurper.java:201)
	at groovy.util.XmlSlurper.parse(XmlSlurper.java:238)
	at groovy.util.XmlSlurper$parse.call(Unknown Source)
	at org.codehaus.groovy.grails.web.pages.ext.jsp.TldReader.init(TldReader.groovy:43)
	at org.codehaus.groovy.grails.web.pages.ext.jsp.TldReader.access$0(TldReader.groovy)
	at org.codehaus.groovy.grails.web.pages.ext.jsp.TldReader$_closure1.doCall(TldReader.groovy:37)
	at org.codehaus.groovy.grails.web.pages.ext.jsp.TldReader$_closure1.call(TldReader.groovy)
	at org.codehaus.groovy.runtime.IOGroovyMethods.withStream(IOGroovyMethods.java:1186)
	at org.codehaus.groovy.grails.web.pages.ext.jsp.TldReader.<init>(TldReader.groovy:36)
	at org.codehaus.groovy.grails.web.pages.ext.jsp.TagLibraryResolverImpl.loadJspTagLib(TagLibraryResolverImpl.groovy:172)
	at org.codehaus.groovy.grails.web.pages.ext.jsp.TagLibraryResolverImpl.loadJspTagLib(TagLibraryResolverImpl.groovy)
	at org.codehaus.groovy.grails.web.pages.ext.jsp.TagLibraryResolverImpl.this$2$loadJspTagLib(TagLibraryResolverImpl.groovy)
{code}

called from https://github.com/grails/grails-core/blob/master/grails-web-jsp/src/main/groovy/org/codehaus/groovy/grails/web/pages/ext/jsp/TldReader.groovy#L43
{code}
        def rootNode = new XmlSlurper(false, false, true).parse(inputStream)
{code}
;;;","15/Apr/14 07:54;paulk;Thanks for the report Lari. I believe I have fixed the NPE issue for the non-namespace aware examples as per above. There are still other errors from that joint build when I checked just now. Are they expected?;;;","15/Apr/14 08:00;lhotari;Thanks Paul, no they aren't expected. Here's a [failure|http://hudson.grails.org/view/Grails%202.4.x/job/groovy_2_3_jdk8_grails_joint_build/103/testReport/org.codehaus.groovy.grails.web.pages.ext.jsp/GroovyPageWithJSPTagsTests/testGRAILS3797/]. XmlSlurper has validation disabled. Why does the parser try to download the DTD when validation is disabled?

This might be a problem in the Grails code since that was quite recently changed to use XmlSlurper for parsing. It's probably not related to GROOVY-6356 changes. 

It looks like JDK8 has a restriction for downloading DTDs by default. However I'm just wondering why doesn't disabling validation disable downloading of DTDs.;;;","15/Apr/14 08:05;guillaume;DTD loading / resolving and XSD schema validation are two different things.
I think this SO question gives some cue you might be interested in, Lari:
http://stackoverflow.com/questions/1185519/how-to-read-well-formed-xml-in-java-but-skip-the-schema;;;","15/Apr/14 08:09;lhotari;Yes they are, but it surprises me that XmlSlurper doesn't have an easy way to disable DTD loading / resolving. 

I found these settings in Xerces documentation:
http://xerces.apache.org/xerces2-j/features.html#nonvalidating.load-external-dtd
http://xerces.apache.org/xerces2-j/features.html#nonvalidating.load-dtd-grammar

It's a real surprise to me that Xerces defaults to these settings. I've always thought that these are only used when validation is enabled.

;;;","15/Apr/14 08:12;lhotari;SO answer: http://stackoverflow.com/a/155874/166062;;;","15/Apr/14 08:34;lhotari;not very groovy 
{code}
    static XmlSlurper createNonValidatingXmlSlurper() {
        SAXParserFactory factory = FactorySupport.createSaxParserFactory();
        factory.setNamespaceAware(false)
        factory.setValidating(false)
        setQuietly(factory, XMLConstants.FEATURE_SECURE_PROCESSING, true)
        setQuietly(factory, ""http://apache.org/xml/features/disallow-doctype-decl"", false)
        setQuietly(factory, ""http://apache.org/xml/features/nonvalidating/load-dtd-grammar"", false)
        setQuietly(factory, ""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false)
        new XmlSlurper(factory.newSAXParser().getXMLReader())
    }
    
    private static void setQuietly(SAXParserFactory factory, String feature, boolean value) {
        try {
            factory.setFeature(feature, value);
        }
        catch (ParserConfigurationException ignored) { }
        catch (SAXNotRecognizedException ignored) { }
        catch (SAXNotSupportedException ignored) { }
    }
{code}

Is this worth another JIRA issue?;;;","15/Apr/14 09:13;paulk;Does something like this work:
{code}
def slurper = IOUtils.createXmlSlurper()
slurper.setFeature(""http://apache.org/xml/features/nonvalidating/load-dtd-grammar"", false)
slurper.setFeature(""http://apache.org/xml/features/nonvalidating/load-external-dtd"", false)
def rootNode = slurper.parse(inputStream)
{code}
;;;","15/Apr/14 09:17;lhotari;Thanks, I pushed a similar change and the build in is the queue on our build server.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect field lookup failure when a child class invokes a method that creates an anonymous class,GROOVY-6355,12813174,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,mpierce,mpierce,19/Sep/13 10:38,28/Dec/14 06:58,14/Jul/23 06:01,28/Dec/14 06:58,2.1.7,2.2.0-beta-2,,,,,,,,,,,,,,,,2.3.9,,,,Compiler,,,,0,,,,,,,"See https://bitbucket.org/marshallpierce/groovy-subclass-field-lookup-bug for a very small reproduction of the bug (run 'gradle build', look at failing tests).

It appears that looking up fields in parent classes gets confused when the field lookup happens inside an anonymous class created by either parent or child.","jdk 1.7 u40, tested on os x and linux",mpierce,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 06:58:37 UTC 2014,,,,,,,,,,"0|i2c3o7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"28/Dec/14 06:58;pschumacher;Thanks for reporting. Your example works for me with groovy 2.3.9.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker ignores wrong number of constructor arguments,GROOVY-6352,12817113,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,blackdrag,blackdrag,17/Sep/13 09:52,22/Feb/16 20:48,14/Jul/23 06:01,22/Dec/15 10:53,2.1.7,2.2.0-beta-2,2.3.0,2.4.0-rc-1,,,,,,,,,,,,,,2.4.6,,,,Static Type Checker,,,,0,,,,,,,"{code:Java}
class X {}
@groovy.transform.CompileStatic
def foo() {
  new X(""f"")
}
println foo()
{code}
This code compiles and runs in static compilation, even though the type checker should have complained. In normal Groovy this fails at runtime, as does if the type checker only is used.",,blackdrag,fpavageau,githubbot,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 22 10:54:28 UTC 2015,,,,,,,,,,"0|i2coan:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Dec/15 15:15;githubbot;GitHub user fpavageau opened a pull request:

    https://github.com/apache/groovy/pull/218

    GROOVY-6352 Check the arguments even for the default constructor

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fpavageau/groovy GROOVY-6352

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/218.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #218
    
----
commit 3522575a375b1beca9a893c801efbfda23fde0c5
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2015-12-21T15:02:20Z

    GROOVY-6352 Check the arguments even for the default constructor

----
;;;","22/Dec/15 10:53;pascalschumacher;Pull request merged. Thanks!;;;","22/Dec/15 10:54;githubbot;Github user fpavageau closed the pull request at:

    https://github.com/apache/groovy/pull/218
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checking error when accessing static members of a primitive type,GROOVY-6351,12817144,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,rcruzjo,rcruzjo,16/Sep/13 15:08,06/Oct/16 22:51,14/Jul/23 06:01,06/Oct/16 22:51,2.1.7,2.3.0,2.4.0-rc-1,,,,,,,,,,,,,,,2.4.1,,,,Static Type Checker,,,,0,,,,,,,"The issue is the following. If I declare a variable of a Java primitive type (for example an int) and try to access a static field in a type checked annotated method (such as MAX_VALUE), there is a failure stating '[Static type checking] - No such property: MAX_VALUE for class: int'. An example of this could be:

{code}

@groovy.transform.TypeChecked
void runMethod (){
int i = 10
println(i.MAX_VALUE)
}

runMethod()

{code}

However, running the same snippet without the annotation works fine. This happens as far as I know with all primitive types.
I don't know if the previous code is correct, given that as a primitive type you don't have static fields, and they only appear in runtime because of autoboxing, but I think there should be a consistency between the two situations.
Furthermore, I think this might be related with issue GROOVY-6349.

I attach some examples to use as test cases.

",,rcruzjo,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6590,,,,"16/Sep/13 15:08;rcruzjo;Testcases.groovy;https://issues.apache.org/jira/secure/attachment/12723200/Testcases.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 06 21:57:50 UTC 2016,,,,,,,,,,"0|i2cew7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"06/Oct/16 21:57;shils;Fixed as of 2.4.1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
adding two empty lists fails with NPE,GROOVY-6350,12817105,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,16/Sep/13 09:58,14/Oct/13 16:53,14/Jul/23 06:01,25/Sep/13 08:43,2.1.7,2.2.0-beta-2,,,,,,,,,,,,,,,,2.1.8,2.2.0-rc-1,,,Static Type Checker,,,,0,,,,,,,"for the expression []+[] the static type checker seems to get confused and fails with a NPE. The checker gets the generics from th list types used here and expects them to exist in a placeholder map, which they do not, and the result is the NPE.",,blackdrag,lhotari,musketyr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 25 08:43:20 UTC 2013,,,,,,,,,,"0|i2c5fb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Sep/13 23:25;lhotari;I wonder if the commit also fixes GROOVY-6359 ;;;","25/Sep/13 08:43;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checking error when accessing class of a primitive type,GROOVY-6349,12817131,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,rcruzjo,rcruzjo,16/Sep/13 09:18,02/May/17 02:03,14/Jul/23 06:01,06/Oct/16 22:51,2.1.7,2.3.0,2.4.0-beta-3,,,,,,,,,,,,,,,2.4.1,,,,Static Type Checker,,,,1,,,,,,,"There is an inconsistency between the behaviour in runtime and in the static type checker when accessing the class of a Java primitive type. Suppose we have the following code:

{code}
void runMethod (){
int i = 10
println(i.class)
}

runMethod()
{code}

If I run this in the Groovy console everything runs fine, autoboxing is performed and 'class java.lang.Integer' is printed as the output. However, if I annotate the method with @groovy.transform.TypeChecked, there is an exception stating '[Static type checking] - No such property: class for class: int'. The same happens if I don't declare a variable and try to use a literal int instead.

As far as I know, this happens with all the primitive types. In addition, trying to access their metaClass works well with or without the type checking enabled.

I attach some of the examples I could come up with.",,ariel.andres.morelli,davidmc24,rcruzjo,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Sep/13 09:18;rcruzjo;TestCases.groovy;https://issues.apache.org/jira/secure/attachment/12722665/TestCases.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 06 22:03:18 UTC 2016,,,,,,,,,,"0|i2c1w7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"06/Oct/16 22:03;shils;Fixed as of 2.4.1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
upTo()/downTo() exception messages for illegal arguments should not leak implementation details,GROOVY-6345,12817141,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,pschumacher,pschumacher,pschumacher,14/Sep/13 09:45,14/Oct/13 16:54,14/Jul/23 06:01,14/Sep/13 11:48,2.2.0-beta-2,,,,,,,,,,,,,,,,,2.2.0-rc-1,,,,,,,,0,breaking,,,,,,see [http://groovy.329449.n5.nabble.com/upto-downto-exception-messages-td5716443.html] for details,,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 18 07:59:39 UTC 2013,,,,,,,,,,"0|i2bxy7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Sep/13 10:28;pschumacher;I created a [pull request|https://github.com/groovy/groovy-core/pull/249] for this.;;;","18/Sep/13 07:59;paulk;Labelled as a ""breaking"" change - though only people relying on the exact wording of the error message will notice any change.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassFormatError when class name contains invalid chars,GROOVY-6344,12817110,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,welvet,welvet,14/Sep/13 05:45,22/May/22 16:05,14/Jul/23 06:01,16/Oct/14 08:49,2.1.7,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Compiler,,,,0,ClassFormatError,,,,,,"Declare closure like: ""def fn(a1,a2) {.."" in groovy script containing ""-"" will result in a ClassFormaError.
",Groovy Version: 2.1.7 JVM: 1.7.0_40 Vendor: Oracle Corporation OS: Linux (ubuntu),blackdrag,welvet,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 25 04:17:12 UTC 2013,,,,,,,,,,"0|i2bttr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Nov/13 04:17;blackdrag;The thing to do for this issue is to add name mangling to Groovy.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic: can't access static field from nested closures,GROOVY-6343,12817132,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,eman,eman,13/Sep/13 20:00,20/May/14 05:31,14/Jul/23 06:01,15/May/14 13:26,2.1.7,,,,,,,,,,,,,,,,,2.3.1,,,,Static compilation,Static Type Checker,,,4,,,,,,,"The following code:
{code}
@groovy.transform.CompileStatic
class A {

  public static final CONST = ""a""

  public static List doSomething() {
    return (0..1).collect{ int x ->
      (0..1).collect{ int y ->
        return CONST
      }
    }
  }
}
A.doSomething()
{code}

fails with this compilation error:
{code}
Access to java.lang.Object#CONST is forbidden at line: -1, column: -1
{code}
",,acourtneybrown,eman,gcadien,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 15 13:26:20 UTC 2014,,,,,,,,,,"0|i2c15r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/May/14 13:26;pschumacher;Fixed. Thanks for reporting.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic + Elvis operator cause null pointers to be thrown,GROOVY-6342,12817121,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,aarmistead,aarmistead,12/Sep/13 17:59,28/May/14 03:04,14/Jul/23 06:01,21/May/14 04:59,2.3.0,,,,,,,,,,,,,,,,,2.2.3,2.3.2,,,Static compilation,,,,6,,,,,,,"When using @CompileStatic and an elvis operator unexpected NullPointerExceptions are thrown. Here is an example script to recreate the issue.




{code}
package my.company
@Grab(group='org.codehaus.groovy', module='groovy-all', version='2.1.6')
import groovy.transform.CompileStatic

@CompileStatic
class Outer {
	
	public static void main(String[] args) {
		Inner inner
		int someInt = inner?.somestuff ?: 0
		println someInt
	}

	class Inner {
		int somestuff
	}
}
{code}
You would expect this to print 0 always, but if @CompileStatic is used a NPE is thrown. Without @CompileStatic 0 is printed as expected.",,aarmistead,acourtneybrown,gcadien,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-09-12 17:59:18.0,,,,,,,,,,"0|i2cj9r:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic + @Canonical + integer property == null pointer in hashcode,GROOVY-6341,12817111,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jon.barksdale,jon.barksdale,12/Sep/13 13:44,15/Oct/15 18:19,14/Jul/23 06:01,06/Dec/13 15:30,2.1.6,,,,,,,,,,,,,,,,,2.2.0-rc-3,,,,Static compilation,xforms,,,6,,,,,,,"Using the @CompileStatic annotation with @Canonical, and having an integer property creates a null pointer opportunity in the generated hashCode method - 

it decompiles to this: 

public int hashCode()
    {
        int _result = HashCodeHelper.initHash();
        int _tmp = _result;
        if(!DefaultGroovyMethods.is(getName(), this))
        {
            int i = HashCodeHelper.updateHash(_result, getName());
            _result = i;
            int _tmp1 = i;
        }
        if(!DefaultGroovyMethods.is(getSomeNum(), this))
        {
            int j = HashCodeHelper.updateHash(_result, getSomeNum().intValue());
            _result = j;
            int _tmp2 = j;
        }
        return _result;
    }


Note the intValue being called without checking to see if the getter returns null. ",,acourtneybrown,gcadien,jon.barksdale,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/Sep/13 13:44;jon.barksdale;groovy-canonical-int-bug.tar.gz;https://issues.apache.org/jira/secure/attachment/12722391/groovy-canonical-int-bug.tar.gz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 06 15:30:14 UTC 2013,,,,,,,,,,"0|i2csjj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"03/Dec/13 20:33;paulk;I wonder if this was fixed as a side effect of GROOVY-6407? Jon, any chance you could check with a Groovy 2.2.x version? ;;;","06/Dec/13 10:24;jon.barksdale;Well.. the test case that is attached to the ticket seems to pass if you up the groovy version to 2.2.1, so we can probably mark it fixed :) ;;;","06/Dec/13 15:30;paulk;OK, I'll assume it was fixed as a side effect of GROOVY-6407. If anyone finds a counter example please reopen or create a new issue. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Explicit private getter method is executed if an implicit getter method exists because of a public property.,GROOVY-6340,12817112,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,mataniko,mataniko,11/Sep/13 13:53,17/Dec/14 13:25,14/Jul/23 06:01,29/Oct/14 15:15,2.1.1,,,,,,,,,,,,,,,,,2.3.7,,,,groovy-runtime,,,,0,,,,,,,"I created a small object called Bug with a public String called bugString. 
My object also has a private method called getBugString() which modifies the value of bugString.

Since Groovy generates properties automatically we now have a public getBugString method and a private one.

When calling bug.bugString the private getter method is executed outside the scope of the class.

When serializing the bug object the correct value is returned (as it should)

I've attached sample code demonstrating the problem.



",OS X,mataniko,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Sep/13 13:53;mataniko;groovyGetterBug.groovy;https://issues.apache.org/jira/secure/attachment/12723133/groovyGetterBug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 29 15:15:24 UTC 2014,,,,,,,,,,"0|i2byzz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Oct/14 15:15;pschumacher;Example project works with 2.3.7.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
weird verify error with TupleConstructor and Lazy,GROOVY-6337,12811772,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,paulk,,10/Sep/13 10:21,07/Apr/15 19:07,14/Jul/23 06:01,20/Jan/14 22:56,,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,xforms,,,,0,,,,,,,"This script:
{code}
@groovy.transform.TupleConstructor
class Picker {
  @Lazy result = foo()
}
new Picker()
{code}
gives this error:
{noformat}
java.lang.VerifyError: (class: Picker, method: <init> signature: ()V) Expecting to find object/array on stack

	at java.lang.Class.getDeclaredConstructors0(Native Method)

	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2483)

	at java.lang.Class.getDeclaredConstructors(Class.java:1891)

	at org.codehaus.groovy.reflection.CachedClass$2$1.run(CachedClass.java:69)
{noformat}
Also, this script:
{code}
@groovy.transform.TupleConstructor
class Picker {
  @Lazy result = null
}
new Picker()
{code}
gives this error:
{noformat}
groovy.lang.ReadOnlyPropertyException: Cannot set readonly property: result for class: Picker
{noformat}
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 20 22:56:06 UTC 2014,,,,,,,,,,"0|i2co73:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jan/14 01:27;paulk;By moving the lazy transform earlier and removing the lazy field from the list of properties, i.e.:
{code}
-@GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
+@GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
 public class LazyASTTransformation implements ASTTransformation, Opcodes {
 
     private static final ClassNode SOFT_REF = ClassHelper.makeWithoutCaching(SoftReference.class, false);
@@ -81,11 +82,14 @@
 
             fieldNode.rename(""$"" + fieldNode.getName());
             fieldNode.setModifiers(ACC_PRIVATE | (fieldNode.getModifiers() & (~(ACC_PUBLIC | ACC_PROTECTED))));
+            // remove the property, leaving the renamed field
+            ClassNode cNode = fieldNode.getDeclaringClass();
+            PropertyNode pNode = cNode.getProperty(fieldNode.getName());
+            cNode.getProperties().remove(pNode);
{code}
resolves the errors noted above but 3 tests which rely on the underlying dollar getter now break. Perhaps the tests need updating but I am wondering whether user code makes similar assumptions.;;;","16/Jan/14 01:28;paulk;The failing tests:
{noformat}
groovy.bugs.Groovy3726Bug > testTransientPropertiesResultingInVarArgsMethods FAILED
    java.lang.NoSuchMethodException: GroovyBean3726C.get$bar()

groovy.bugs.Groovy3726Bug > testVolatilePropertiesResultingInBridgeMethods FAILED
    java.lang.NoSuchMethodException: GroovyBean3726A.get$foo()

org.codehaus.groovy.transform.FieldTransformTest > testGroovyTransformsShouldTransferToFields FAILED
    groovy.lang.MissingFieldException: No such field: $foo for class: TestScripttestGroovyTransformsShouldTransferToFields235
{noformat}
;;;","20/Jan/14 22:56;paulk;Given we haven't had specific requests for this to be fixed in user scripts I will just fix in 2.3 for now. We can backport later if there is demand.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.VerifyError when using field from parent as default value for a parameter in a child's contructor,GROOVY-6334,12817164,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ncode,ncode,08/Sep/13 12:17,15/Oct/15 18:19,14/Jul/23 06:01,27/Nov/13 07:09,2.1.6,,,,,,,,,,,,,,,,,2.2.2,,,,bytecode,,,,0,VerifyError,,,,,,"When using a field of the parent as a default value for a parameter in the child's constructor, the following exception is thrown:

java.lang.VerifyError: (class: Child, method: <init> signature: ()V) Expecting to find object/array on stack
	at bug.run(bug.groovy:1)",Groovy Version: 2.1.7 JVM: 1.7.0_25 Vendor: Oracle Corporation OS: Linux,blackdrag,ncode,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"08/Sep/13 12:17;ncode;bug.groovy;https://issues.apache.org/jira/secure/attachment/12722390/bug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 27 07:09:12 UTC 2013,,,,,,,,,,"0|i2cfvz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"27/Nov/13 07:09;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Changes required regarding unaryPlus and bitwiseNegate operators for numbers,GROOVY-6333,12811763,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,05/Sep/13 07:08,07/Apr/15 19:06,14/Jul/23 06:01,05/Sep/13 08:32,2.2.0-beta-1,,,,,,,,,,,,,,,,,2.2.0-beta-2,,,,,,,,0,,,,,,,"Split off from GROOVY-6229. This is to cover these anomolies:
{code}
println 1.unaryMinus()    // => -1
println 1.unaryPlus()     // => MME unaryPlus
println 1.bitwiseNegate() // => MME bitwiseNegate
{code}
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-09-05 07:08:29.0,,,,,,,,,,"0|i2coaf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Name in delegate block is resolved to (inexisting) field rather than (existing) getter,GROOVY-6332,12817069,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,pniederw,pniederw,03/Sep/13 05:46,14/Oct/13 16:53,14/Jul/23 06:01,10/Sep/13 11:43,2.2.0-beta-1,,,,,,,,,,,,,,,,,2.2.0,,,,Static Type Checker,,,,0,,,,,,,"{code}
class Car {
  private String _brand
  String getBrand() { _brand }
  void setBrand(String brand) { _brand = brand }
}

class Builder {
  def <T> T configure(@DelegatesTo.Target Class<T> target, @DelegatesTo(genericTypeIndex=0) Closure cl) {
    def obj = target.newInstance() 
    cl.delegate = obj
    cl.resolveStrategy = Closure.DELEGATE_FIRST
    cl.call()
    obj 
  }
}

@groovy.transform.TypeChecked
class Main {
  void run() {
    def builder = new Builder()
    def car = builder.configure(Car) {
      brand = brand // [Static type checking] - The variable [brand] is undeclared.
    }
  }
}

new Main().run()
{code}",,blackdrag,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 10 11:43:16 UTC 2013,,,,,,,,,,"0|i2ct07:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Sep/13 11:34;blackdrag;fixed;;;","10/Sep/13 11:43;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy not checking generics information correctly for covariant methods implementing interfaces,GROOVY-6330,12811900,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,29/Aug/13 04:45,07/Apr/15 19:07,14/Jul/23 06:01,26/Mar/14 04:10,2.1.6,2.2.0-beta-1,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,Compiler,,,,0,,,,,,,"For this class:
{code}
class StringIterator implements Iterator<String> {
  void remove() { }
  boolean hasNext() { false }
  def next() { 3 }
}
{code}
The compiler should complain that next doesn't have return type String.
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 26 04:10:04 UTC 2014,,,,,,,,,,"0|i2codb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Aug/13 04:59;paulk;I should add that if {{next}} has type {{String}}, the compiler is happy and if {{next}} has type {{Integer}}, the compiler complains. So most paths seem to work but it would appear not the above case.;;;","10/Mar/14 20:48;paulk;Some additional information:
* changing the return type of {{next}} to {{CharSequence}} leads to a detected compilation error, though the error message is slightly wrong: {{The return type of java.lang.CharSequence next() in StringIterator is incompatible with java.lang.Object next() in java.util.Iterator}} - hopefully this is just the error message missing the generics info - though it could be a false detection and a poor error message
* even adding {{@CompileStatic}} doesn't change the compiler incorrect behavior for the case above;;;","26/Mar/14 04:10;paulk;Fixed as part of preliminary work for GROOVY-6329;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Delegate should support including/excluding which methods are delegated to (and optionally complain if multiple exist) - advanced use cases,GROOVY-6329,12817128,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,oliver_plow,oliver_plow,29/Aug/13 04:30,05/Apr/14 00:00,14/Jul/23 06:01,26/Mar/14 04:07,2.1.0,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,groovy-jdk,,,,0,,,,,,,"I have 3 delegate clases:

{code}
class CommonDelegate {
    def String value = ""CommonDelegate""
}
{code}

{code}
class CommonDelegate2 {
    def String value = ""CommonDelegate2""
}
{code}

{code}
class CommonDelegate3 {
    def String value = ""CommonDelegate3""
}
{code}

and a class Foo:

{code}
class Foo extends CommonDelegate {

    @Delegate
    def CommonDelegate2 commonDelegate2 = new CommonDelegate2()

    @Delegate
    def CommonDelegate3 commonDelegate3 = new CommonDelegate3()

}
{code}

Now, I run this code:

{code}
def Foo foo = new Foo()
println(foo.getValue())
{code}

And this prints ""CommonDelegate2""

Question is now whether @Delegate should complain about the ambiguous call to getValue() in foo.getValue() as people expect @Delegate to be type-safe",groovy-2.1.0 on Windows using IDEA IC123.139,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 26 04:07:42 UTC 2014,,,,,,,,,,"0|i2bs1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Aug/13 04:37;paulk;Cloned from GROOVY-5974 to handle advanced use cases as discussed in that issue.;;;","26/Mar/14 04:07;paulk;Now handles includeTypes and excludeTypes similar to Lombok (with basic generics support);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
onMethodSelection() doesn't fire when setter is called with property syntax,GROOVY-6328,12817108,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,pniederw,pniederw,28/Aug/13 02:46,03/Feb/22 22:32,14/Jul/23 06:01,28/Oct/21 19:26,2.2.0-beta-1,,,,,,,,,,,,,,,,,4.0.0-beta-2,,,,Static Type Checker,,,,0,,,,,,,"{code}
import groovy.transform.TypeChecked

@TypeChecked
class MyCar {
    String brand
}

@TypeChecked(extensions = [""MyChecker.grovy""])
class MyCarMain {
    static void main(String[] args) {
        def main = new MyCarMain()
        main.configureCar {
            brand = ""BMW""
        }
    }

    MyCar configureCar(@DelegatesTo(MyCar) Closure closure) {
        def car = new MyCar()
        closure.delegate = car
        closure.resolveStrategy = Closure.DELEGATE_FIRST
        closure.call()
        car
    }
}
{code}

Same when {{MyCar}} declares explicit getter and setter instead of property. Changing to {{setBrand(""BMW"")}} solves the problem.",,emilles,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 05 17:36:24 UTC 2021,,,,,,,,,,"0|i2cslr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Oct/21 17:36;emilles;For ""setBrand(...);"" there is a {{MethodNode}} created for the property within {{org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor#findMethod}} that then passes through the typical method selection process.

For ""brand = ...;"", {{StaticTypeCheckingVisitor}} selects the actual {{PropertyNode}}, unless there is an explicit setter declared in the source.  {{StaticTypeCheckingVisitor#existsProperty}} is where this happens.

If an explicit setter is declared, {{StaticTypeCheckingVisitor#ensureValidSetter}} triggers a callback for the dummy expression ""%.setBrand('BMW')"".  To also get a callback for the binary expression, a call to {{extension.onMethodSelection(expression, methodTarget);}} could be added below {{setType(...)}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Nonsensical error message when trying to call instance method from closure enclosed in static method,GROOVY-6326,12817136,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,pniederw,pniederw,27/Aug/13 22:11,28/Dec/14 07:03,14/Jul/23 06:01,28/Dec/14 07:03,2.2.0-beta-1,2.3.0,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Static compilation,,,,0,,,,,,,"{code}
import groovy.transform.CompileStatic

@CompileStatic
class MyCar {}

@CompileStatic
class MyCarMain {
    static void main(String[] args) {
        def main = new MyCarMain()
        main.configureCar {
            doit()
        }
    }

    MyCar configureCar(@DelegatesTo(MyCar) Closure closure) {
        def car = new MyCar()
        closure.delegate = car
        closure.resolveStrategy = Closure.DELEGATE_FIRST
        closure.call()
        car
    }

    void doit() {
        println ""doit""
    }
}
{code}

Here I inadvertently used {{doit()}} instead of {{main.doit()}}. However the error message didn't help:

{code}
Groovyc: Access to java.lang.Object#owner is forbidden
{code}",,melix,pniederw,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 07:03:54 UTC 2014,,,,,,,,,,"0|i2cfuf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jan/14 05:11;melix;I can't reproduce this particular error on {{master}}, however there is another one: in your example, {{doit}} is non static, so the compiler shouldn't have let you use it from a non static context. It triggers another obscure error:

{noformat}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'class MyCarMain' with class 'java.lang.Class' to class 'MyCarMain'
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:371)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:599)
	at MyCarMain$_main_closure1.doCall(ConsoleScript5:11)
	at MyCarMain$_main_closure1.doCall(ConsoleScript5)
{noformat}

Making {{doit}} static fixes the problem, but the error should be caught.;;;","28/Dec/14 07:03;pschumacher;Thanks for reporting. Your example works with groovy 2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checking complains when calling getter of delegated-to object with property syntax,GROOVY-6325,12818149,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,pniederw,pniederw,27/Aug/13 21:35,14/Oct/13 16:53,14/Jul/23 06:01,10/Sep/13 11:42,2.2.0-beta-1,,,,,,,,,,,,,,,,,2.2.0,,,,Static Type Checker,,,,0,,,,,,,"{code}
import groovy.transform.TypeChecked

@TypeChecked
class MyCar {
    private String _brand
    private String _model

    String getBrand() {
        return _brand
    }

    void setBrand(String brand) {
        _brand = brand
    }

    String getModel() {
        return _model
    }

    void setModel(String model) {
        _model = model
    }
}

@TypeChecked
class MyCarMain {
    static void main(String[] args) {
        def main = new MyCarMain()
        def car = main.configureCar {
            brand = ""BMW""
            model = brand
        }
        println car.model
    }

    MyCar configureCar(@DelegatesTo(value = MyCar, strategy = Closure.DELEGATE_FIRST) Closure closure) {
        def car = new MyCar()
        closure.delegate = car
        closure.resolveStrategy = Closure.DELEGATE_FIRST
        closure()
        car
    }
}
{code}

{code}
Groovyc: [Static type checking] - The variable [brand] is undeclared.
{code}

{{model = getBrand()}} solves the problem. Problem doesn't occur when declaring {{MyCar}} as:

{code}
class MyCar {
  String brand
  String model
}
{code}",,blackdrag,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 10 11:42:38 UTC 2013,,,,,,,,,,"0|i2bzfz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Sep/13 11:33;blackdrag;fixed;;;","10/Sep/13 11:42;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic error when property of delegated-to object is read,GROOVY-6323,12818248,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,pniederw,pniederw,27/Aug/13 20:28,14/Oct/13 16:53,14/Jul/23 06:01,10/Sep/13 11:42,2.2.0-beta-1,,,,,,,,,,,,,,,,,2.2.0,,,,Static compilation,,,,0,,,,,,,"{code}
import groovy.transform.CompileStatic

@CompileStatic
class MyCar {
    String brand
    String model
}

@CompileStatic
class MyCarMain {
    static void main(String[] args) {
        def main = new MyCarMain()
        def car = main.configureCar {
            brand = ""BMW""
            model = brand + "" X5""
        }
        println car.model
    }

    MyCar configureCar(@DelegatesTo(MyCar) Closure closure) {
        def car = new MyCar()
        closure.delegate = car
        closure.resolveStrategy = Closure.DELEGATE_FIRST
        closure()
        car
    }
}
{code}

The line {{model = brand + "" X5""}} produces this compile error:

{code}
Groovyc: Access to java.lang.Object#brand is forbidden
{code}

There is no such compile error when using {{@TypeChecked}}.",,blackdrag,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 10 11:42:15 UTC 2013,,,,,,,,,,"0|i2cr8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Sep/13 11:33;blackdrag;fixed;;;","10/Sep/13 11:42;blackdrag;now really fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic on class using with(Closure) leads to compilation error.,GROOVY-6317,12818142,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,acourtneybrown,acourtneybrown,20/Aug/13 16:14,14/Oct/13 16:53,14/Jul/23 06:01,26/Aug/13 05:20,2.1.6,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Static compilation,,,,0,,,,,,,"{code:java}
import groovy.transform.CompileStatic

interface Bar {
  String getField()
}

class BarImpl implements Bar {
  String field
}

class Foo {
  Bar bar

  Foo(String field) {
    this.bar = new BarImpl(field: field)
  }
}

@CompileStatic
class Tester {
  void test() {
    Foo foo = new Foo('value')
    println foo.bar.with { ""$field"" }
  }
}

new Tester().test()
{code}

when compiled with groovyc results in the following compilation error:

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
bad.groovy: 23: [Static type checking] - The variable [field] is undeclared.
 @ line 23, column 28.
   		println foo.bar.with { ""$field"" }
                              ^

1 error
{code}

However, without the @CompileStatic on the Tester class, the code compiles cleanly and runs successfully.

From what I've been able to discern, the compilation error does not occur if the with() occurs on the 'top-level' object and only occurs when the contained/subordinate object is an interface.",,acourtneybrown,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 26 05:20:53 UTC 2013,,,,,,,,,,"0|i2bssv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Aug/13 05:20;blackdrag;fixed by another issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ResourceGroovyMethods uses BufferedWriter/BufferedOutputStream,GROOVY-6314,12816467,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,johann,johann,18/Aug/13 10:51,05/Apr/15 14:44,14/Jul/23 06:01,13/Jan/14 08:25,2.1.4,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,groovy-jdk,,,,0,collection,garbage,gc,performance,,,"{{ResourceGroovyMethods}} uses {{BufferedWriter}} and {{BufferedOutputStream}} to write in-memory data to files. This is bad because it causes 8 K of chars or bytes to be created per-call.

For example, this

{code}
new File('keks') << 'ah'
{code}

generates 16 KB of unnecessary waste.

Affected methods:

* write(File file, String text)
* write(File file, String text, String charset)
* append(File file, Object text)
* append(File file, byte[] bytes)
* append(File file, Object text, String charset)

Solution:

{code}
    public static void append(File file, byte[] bytes) throws IOException {
        BufferedOutputStream stream = null;
        try {
            stream = new BufferedOutputStream(new FileOutputStream(file, true));
            stream.write(bytes, 0, bytes.length);
            stream.flush();

            OutputStream temp = stream;
            stream = null;
            temp.close();
        } finally {
            closeWithWarning(stream);
        }
    }
{code}

(Before)

{code}
    public static void append(File file, byte[] bytes) throws IOException {
        OutputStream stream = null;
        try {
            stream = new FileOutputStream(file, true);
            stream.write(bytes, 0, bytes.length);
            stream.flush();

            OutputStream temp = stream;
            stream = null;
            temp.close();
        } finally {
            closeWithWarning(stream);
        }
    }
{code}

(After)",,blackdrag,johann,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Mon Jan 13 08:25:43 UTC 2014,,,,,,,,,,"0|i2cbwv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Aug/13 02:52;blackdrag;I think I can agree with all but the Object cases. Imho in general buffering for writing makes only sense if you have multiple writes and the chunks you write are smaller than size of the buffer in the BufferedOutputStream. In case of the byte[] it is a single write, so this optimization does not apply. The only cases with potential multiple writes are the Object cases with the Object being an InputStream, a Reader or a Writable. Normally those should become separate DGM methods. ;;;","08/Sep/13 01:58;pschumacher;I crated a [pull request|https://github.com/groovy/groovy-core/pull/245] for this. Please review. Thanks! :);;;","13/Jan/14 08:25;blackdrag;I applied the pull request ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyC fails on this=null,GROOVY-6313,12817083,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,kaendfinger,kaendfinger,15/Aug/13 08:02,08/Mar/22 12:16,14/Jul/23 06:01,05/Oct/21 15:52,2.1.6,2.2.0-beta-1,,,,,,,,,,,,,,,,,,,,Compiler,,,,0,Compiler,,,,,,"I was experimenting with Groovy when I wanted to see how it worked if I did:
""this = null"" as a statement. GroovyC failed to compile it, crashing internally. I unfortunately can not get the exception.",,emilles,kaendfinger,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 05 15:52:55 UTC 2021,,,,,,,,,,"0|i2bx7j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Oct/21 15:52;emilles;Compiler: ""cannot have 'this' as LHS of an assignment"";;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using @CompileStatic on code that uses spread operator on a Set results in compilation error,GROOVY-6311,12817123,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,acourtneybrown,acourtneybrown,14/Aug/13 18:41,14/Oct/13 16:54,14/Jul/23 06:01,21/Aug/13 02:02,2.1.6,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Compiler,Static compilation,,,0,,,,,,,"The two attached files (bad.groovy & good.groovy) demonstrate the problem.  In bad.groovy, a class with the @CompileStatic annotation attempts to collect the objects from a Set<> using the spread operator and fails with the compilation error:

org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
bad.groovy: 17: [Static type checking] - No such property: strings for class: java.util.Set <Inner>
 @ line 17, column 13.
       println outer.inners*.strings
               ^

1 error

In good.groovy, the equivalent .collect{} is used for the spread operator and it compiles and runs as expected.",,acourtneybrown,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"14/Aug/13 18:41;acourtneybrown;bad.groovy;https://issues.apache.org/jira/secure/attachment/12722395/bad.groovy","14/Aug/13 18:41;acourtneybrown;good.groovy;https://issues.apache.org/jira/secure/attachment/12723229/good.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 21 02:02:16 UTC 2013,,,,,,,,,,"0|i2buj3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Aug/13 02:02;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@TimedInterrupt et al only partially support multiple annotations within a single source file,GROOVY-6307,12811903,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,12/Aug/13 08:08,07/Apr/15 19:07,14/Jul/23 06:01,13/Aug/13 18:29,,,,,,,,,,,,,,,,,,2.2.0-beta-2,,,,,,,,0,,,,,,,"@TimedInterrupt has provisions for supporting multiple annotations within the same source file. If for example you do:
{code}
@groovy.transform.TimedInterrupt(value = 2L, applyToAllClasses=false)
class Class1 { def method1() {} }

@groovy.transform.TimedInterrupt(value = 1L, applyToAllClasses=false)
class Class2 { def method2() {} }

new Class1().method1()
new Class2().method2()
{code}
All is ok. But if applyToAllClasses is true in either case, or some other occurrence of the annotation occurs at the script level you obtain the rather cryptic compilation error:
{noformat}
2 compilation errors:

The field 'TimedInterrupt$expireTime' is declared multiple times.
 at line: -1, column: -1

The field 'TimedInterrupt$startTime' is declared multiple times.
 at line: -1, column: -1
{noformat}
Similarly, if you have two methods in a script or class both with an annotation, you will receive the above error.

I propose to add the hashCode of the annotation into the generated field and also provide an additional ""applyToAllMembers"" annotation parameter. It will allow the above errors to be avoided.

The same comments apply (more or less) to @ThreadInterrupt and @ConditionalInterrupt. The same change (with minor tweaks) can be applied to all three.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 13 18:29:13 UTC 2013,,,,,,,,,,"0|i2ct6f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Aug/13 18:29;paulk;applyToAllMembers added to all three annotations and duplicate naming issue resolved by adding a hashCode into the name.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unable to use Grape to grab DLLs,GROOVY-6306,12818527,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,sdanig,sdanig,11/Aug/13 00:03,14/Oct/13 16:53,14/Jul/23 06:01,13/Aug/13 22:40,2.0.5,,,,,,,,,,,,,,,,,2.2.0-beta-2,,,,Grape,,,,0,,,,,,,"As per GROOVY-4722, we should be able to use the ""ext"" or ""type"" attribute on the @Grab annotation to add a dependency on a DLL. Here's the sample code from GROOVY-4722:

{code}@Grab(group='net.sf.jacob-project', module='jacob', version='1.14.3')
@Grab(group='net.sf.jacob-project', module='jacob', version='1.14.3', classifier='x64', type='dll')
import groovy.grape.Grape
println 'done'{code}

However, this is the stack trace I get:

{code}>groovy -d test.groovy
Caught: java.lang.ExceptionInInitializerError
java.lang.ExceptionInInitializerError
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:525)
        at java.lang.Class.newInstance0(Class.java:372)
        at java.lang.Class.newInstance(Class.java:325)
        at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:248)
        at groovy.lang.GroovyShell.run(GroovyShell.java:220)
        at groovy.lang.GroovyShell.run(GroovyShell.java:150)
        at groovy.ui.GroovyMain.processOnce(GroovyMain.java:557)
        at groovy.ui.GroovyMain.run(GroovyMain.java:344)
        at groovy.ui.GroovyMain.process(GroovyMain.java:330)
        at groovy.ui.GroovyMain.processArgs(GroovyMain.java:119)
        at groovy.ui.GroovyMain.main(GroovyMain.java:99)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
Caused by: java.util.zip.ZipException: error in opening zip file
        at java.util.zip.ZipFile.open(Native Method)
        at java.util.zip.ZipFile.<init>(ZipFile.java:214)
        at java.util.zip.ZipFile.<init>(ZipFile.java:144)
        at java.util.zip.ZipFile.<init>(ZipFile.java:158)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:525)
        at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
        at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:190)
        at groovy.grape.GrapeIvy.processOtherServices(GrapeIvy.groovy:314)
        at groovy.grape.GrapeIvy$processOtherServices.callCurrent(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
        at groovy.grape.GrapeIvy$processOtherServices.callCurrent(Unknown Source)
        at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:258)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:231)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:52)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:145)
        at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:236)
        at groovy.grape.Grape.grab(Grape.java:129)
        at groovy.grape.Grape$grab.callStatic(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallStatic(CallSiteArray.java:53)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:157)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:165)
        at test.<clinit>(test.groovy)
        ... 20 more{code}

I'm using Groovy 2.0.5, and the line numbers have changed a bit in master, but the bug still exists here:

https://github.com/groovy/groovy-core/blob/master/src/main/groovy/grape/GrapeIvy.groovy

{code}for (URI uri in uris) {
    //TODO check artifact type, jar vs library, etc
    File file = new File(uri)
    processCategoryMethods(loader, file)
    processOtherServices(loader, file)
}{code}

The processCategoryMethods() method checks that the file is a JAR before doing its magic, but the processOtherServices() method just assumes that the file provided is a Zip file.",,gredler,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 16 11:04:12 UTC 2013,,,,,,,,,,"0|i2coa7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Aug/13 22:37;paulk;There are potentially two parts to your example. Firstly, as you point out the processOtherServices method is making assumptions about the type of the artifact. I have placed that within a try - catch to avoid that problem. I assume that is all that is required as far as this issue is concerned.

The second part to your example would be getting the dll on the java.library.path. The following code worked for me though:
{code}
@Grab(group='net.sf.jacob-project', module='jacob', version='1.14.3')
@Grab(group='net.sf.jacob-project', module='jacob', version='1.14.3', classifier='x86', type='dll')
import com.jacob.com.*
import com.jacob.activeX.*
def homedir = System.getProperty('user.home')
def dll = new File(homedir + ""/.groovy/grapes/net.sf.jacob-project/jacob/dlls"", ""jacob-1.14.3-x86.dll"")
//println dll.absolutePath
//println dll.exists()
System.setProperty(LibraryLoader.JACOB_DLL_PATH, dll.absolutePath)
LibraryLoader.loadJacobLibrary()
def ie = new ActiveXComponent(""clsid:0002DF01-0000-0000-C000-000000000046"")
def ieo = ie.getObject()
Dispatch.put(ieo, ""Visible"", new Variant(true))
Dispatch.put(ieo, ""AddressBar"", new Variant(true))
//println Dispatch.get(ieo, ""Path"")
Dispatch.call(ieo, ""Navigate"", new Variant(""http://groovy.codehaus.org""))
sleep 5000
ie.invoke(""Quit"", new Variant[0])
println 'done'
{code}
So I presume the above fix is sufficient for now.;;;","13/Aug/13 22:40;paulk;You should also check out the Scriptom library. Also, you might want to nudge the jacob authors to publish more recent artifacts to a maven repo and potentially pack the dll's into the base jar and unpack it themselves when needed. There are existing issues/forum discussions on these topics I believe.;;;","16/Aug/13 11:04;sdanig;Thanks for the fix! Any chance Grape can automatically detect DLLs and add them to the java.library.path?

I'm already using Scriptom, I just wanted my example code snippet to be as small as possible. The Jacob DLL auto-extract feature would be great, and it looks like they already have a feature request for this:

https://sourceforge.net/p/jacob-project/feature-requests/42/

You're also correct about the conversations around uploading newer Jacob Maven artifacts:

https://sourceforge.net/p/jacob-project/discussion/375945/thread/f48df3bc/

Thanks again!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stub generator chokes on multi-dimensional arrays,GROOVY-6302,12818253,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,gromopetr,gromopetr,09/Aug/13 09:21,08/Jul/14 15:28,14/Jul/23 06:01,12/Jun/14 23:17,1.8.5,2.1.6,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,Stub generator / Joint compiler,,,,0,,,,,,,"{code}
class GroovyClass {
    Map<String, String[][]> foo() { null }
}

{code}

Stub (note the foo method at the end):

{code}
import java.lang.*;
import java.io.*;
import java.net.*;
import java.util.*;
import groovy.lang.*;
import groovy.util.*;

public class GroovyClass
  extends java.lang.Object  implements
    groovy.lang.GroovyObject {
public  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}
public  void setMetaClass(groovy.lang.MetaClass mc) { }
public  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}
public  java.lang.Object getProperty(java.lang.String property) { return null;}
public  void setProperty(java.lang.String property, java.lang.Object value) { }
public  java.util.Map<java.lang.String, [Ljava.lang.String;[]> foo() { return (java.util.Map<java.lang.String, [Ljava.lang.String;[]>)null;}
}
{code}
",,gromopetr,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 12 23:17:40 UTC 2014,,,,,,,,,,"0|i2com7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Jun/14 23:17;paulk;Should be fixed. Thanks for pointing out the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JavaStubGenerator clears instance initializers,GROOVY-6300,12812049,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,08/Aug/13 10:28,14/Oct/13 16:53,14/Jul/23 06:01,08/Aug/13 11:36,,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,,,,,0,,,,,,,"The {{JavaStubGenerator}} class uses the {{Verifier}} one which clears the instance initializers once its job is done. The problem is that it breaks instance initializers in case we're using joint compilation.
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-08-08 10:28:24.0,,,,,,,,,,"0|i2c0uf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"executing "" this.binding.variables"" from groovy.ui.Console throws StackOverflowException",GROOVY-6298,12817062,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,dariusan,dariusan,07/Aug/13 06:06,08/Mar/22 12:16,14/Jul/23 06:01,17/Jan/22 20:46,2.1.5,,,,,,,,,,,,,,,,,,,,,Groovy Console,,,,0,StackOverflowError,,,,,,"excuting twice:

{code}
 this.binding.variables
{code}

leads to StackOverflowException",,dariusan,emilles,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 17 20:46:37 UTC 2022,,,,,,,,,,"0|i2c9dr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Oct/13 12:40;pschumacher;@Rest of groovy team: Should we close this as 'won't fix'?;;;","17/Jan/22 20:46;emilles;Works in Groovy 2.5+;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyDoc doesn't escape angle brackets in @code and @literal tags,GROOVY-6295,12811762,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,rene.scheibe,rene.scheibe,02/Aug/13 03:20,14/Oct/13 16:53,14/Jul/23 06:01,09/Aug/13 06:26,1.8.9,2.0.8,2.1.6,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,GroovyDoc,,,,0,,,,,,,"As an example see the broken HTML [1] for the CodeNarc Gradle plugin [2].

Method _setReportFile()_:

a) Method Summary
It prints ""{@code reports"" instead of formatting the text correctly.

b) Method Detail
It prints ""Use reports..enabled instead."" because it renders the <report-type> string directly as a tag instead of encoding it.

See the Javadoc Documentation [3] for @code tag.

The relevant GroovyDoc implementation is here [4].

[1] http://www.gradle.org/docs/current/groovydoc/org/gradle/api/plugins/quality/CodeNarc.html
[2] https://github.com/gradle/gradle/blob/master/subprojects/code-quality/src/main/groovy/org/gradle/api/plugins/quality/CodeNarc.groovy#L77-L86
[3] http://docs.oracle.com/javase/1.5.0/docs/tooldocs/windows/javadoc.html#{@code\}
[4] https://github.com/groovy/groovy-core/blob/master/subprojects/groovy-groovydoc/src/main/java/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java#L756",,darxriggs,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 09 06:26:27 UTC 2013,,,,,,,,,,"0|i2cab3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Aug/13 03:21;rene.scheibe;I'll have a look at it and try to provide a patch.

-> see https://github.com/groovy/groovy-core/pull/237;;;","09/Aug/13 06:26;pschumacher;Pull request merged. Thanks for reporting the issue and thanks for providing the pull request. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Immutable collection members are apparently mutable (sometimes?),GROOVY-6293,12815644,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,wu-lee,wu-lee,01/Aug/13 07:04,04/Mar/14 16:31,14/Jul/23 06:01,06/Dec/13 09:23,1.8.6,2.0.5,,,,,,,,,,,,,,,,2.2.2,,,,xforms,,,,0,,,,,,,"Given these classes:

  @Immutable class X { Collection c = [] }
  @Immutable class Y { Collection c = []; int foo = 1 }

I get this behaviour:

  x = new X(null); x.c << 1; // UnsupportedOperationException
  y= new Y(null); y.c << 1; // Success !?
  println y; // Y([1], 0)


See also the discussion with the same subject on the mailing list.

","Ubuntu Precise
Groovy Version: 1.8.6 JVM: 1.6.0_27 Vendor: Sun Microsystems Inc. OS: Linux 
Groovy Version: 2.0.5 JVM: 1.7.0_25 Vendor: Oracle Corporation OS: Linux ",paulk,wu-lee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 06 09:23:25 UTC 2013,,,,,,,,,,"0|i2c51z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Dec/13 09:23;paulk;Fixed - thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Null arg call not ambiguouseven though it should be,GROOVY-6289,12815657,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,31/Jul/13 07:08,15/Oct/15 18:19,14/Jul/23 06:01,01/Aug/13 07:59,,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,,,,,0,,,,,,,"A simple new Exception(null) should not succeed, since there is a String and a Throwable version of the constructor, that both have the same distance to Object. Instead a random one of the two is chosen.",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 01 07:59:26 UTC 2013,,,,,,,,,,"0|i2conb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Aug/13 07:59;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Overloaded operator with return type,GROOVY-6288,12818254,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,egarcia,egarcia,31/Jul/13 06:29,14/Oct/13 16:53,14/Jul/23 06:01,26/Aug/13 07:33,2.2.0-beta-1,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Static compilation,Static Type Checker,,,0,,,,,,,"When creating a class with a method:
{code}
...
public int plus(int o2) {
  return 0;
}
...
{code}

...and calling it like...

{code}
int result = myObj + 2;
{code}

(every class is annotated with @TypeChecked and @CompileStatic) ...I got:

{code}
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesCallSiteWriter.makeSingleArgumentCall(StaticTypesCallSiteWriter.java:600)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeSingleArgumentCall(InvocationWriter.java:531)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateBinaryExpression(BinaryExpressionHelper.java:497)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionMultiTypeDispatcher.evaluateBinaryExpression(BinaryExpressionMultiTypeDispatcher.java:216)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:142)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:529)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:297)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesBinaryExpressionMultiTypeDispatcher.evaluateEqual(StaticTypesBinaryExpressionMultiTypeDispatcher.java:222)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitDeclarationExpression(AsmClassGenerator.java:524)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:86)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:511)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:457)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:321)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:278)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:398)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$15.call(CompilationUnit.java:794)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:54)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:80)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:85)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:121)
{code}",,blackdrag,egarcia,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 26 07:33:09 UTC 2013,,,,,,,,,,"0|i2cm3r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Jul/13 06:45;egarcia;Actually, having a return type or not is irrelevant. The problem happens when you have @CompileStatic on the invoking class/method;;;","31/Jul/13 17:14;egarcia;Ok, found this little bit on the @CompileStatic GEP-10:

{code}
Static compilation is for the moment only supported at the method level (do not try to add it to a class) and supports direct method calls as long as you do not:

* use methods from DefaultGroovyMethods
* use ""indirect"" methods like list << obj where the AST representation is not a method call but a binary expression
{code}

...so I'll close this as it seems to be a known issue;;;","01/Aug/13 03:12;melix;Reopening the bug: the comment from the GEP is very old and wrong. You really have something that should work here.;;;","26/Aug/13 07:33;blackdrag;this has been fixed already;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovyc ant task generates invalid stub (picks wrong constructor) and fails in Java 1.7 compilation,GROOVY-6282,12818256,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,lhotari,lhotari,27/Jul/13 00:18,18/Jan/23 00:03,14/Jul/23 06:01,08/Jun/21 22:08,2.1.6,,,,,,,,,,,,,,,,,2.5.21,3.0.9,4.0.0-beta-1,,Stub generator / Joint compiler,,,,0,,,,,,,"The current master branch of Grails won't compile with Java 1.7 . It compiles ok with Java 1.6 .

The error message is:
{code}
[ant:groovyc] /tmp/groovy-generated-614097634888075990-java-sourc
[ant:groovyc] e/org/codehaus/groovy/grails/cli/interactive/GrailsInteractiveCompletor.java:15: error: unreported exception IOException; must b
[ant:groovyc] e caught or declared to be thrown
[ant:groovyc] super ((java.io.InputStream)null);
[ant:groovyc]       ^
{code}

Reproducing error:
{code}
git clone https://github.com/grails/grails-core.git
cd grails-core
git checkout 1239b8ed
./gradlew clean compileGroovy
{code}

Generated stub with error:
{code}
package org.codehaus.groovy.grails.cli.interactive;

import java.lang.*;
import java.io.*;
import java.net.*;
import java.util.*;
import groovy.lang.*;
import groovy.util.*;

@groovy.transform.CompileStatic() public class GrailsInteractiveCompletor
  extends jline.SimpleCompletor  implements
    groovy.lang.GroovyObject {
public GrailsInteractiveCompletor
(grails.util.BuildSettings settings, java.util.List<java.io.File> scriptResources) {
super ((java.io.InputStream)null);
}
public  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}
public  void setMetaClass(groovy.lang.MetaClass mc) { }
public  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}
public  java.lang.Object getProperty(java.lang.String property) { return null;}
public  void setProperty(java.lang.String property, java.lang.Object value) { }
public  grails.util.BuildSettings getSettings() { return (grails.util.BuildSettings)null;}
public  void setSettings(grails.util.BuildSettings value) { }
public  java.util.Map getCompletorCache() { return (java.util.Map)null;}
public  void setCompletorCache(java.util.Map value) { }
@java.lang.Override() public  int complete(java.lang.String buffer, int cursor, java.util.List clist) { return (int)0;}
public static  java.lang.String[] getScriptNames(java.util.List<java.io.File> scriptResources) { return (java.lang.String[])null;}
}
{code}

However the stub is ok if I remove ""groovyOptions.useAnt = true"" and ""options.useAnt = true"" from the build.gradle of Grails:

{code}
package org.codehaus.groovy.grails.cli.interactive;

import java.lang.*;
import java.io.*;
import java.net.*;
import java.util.*;
import groovy.lang.*;
import groovy.util.*;

@groovy.transform.CompileStatic() public class GrailsInteractiveCompletor
  extends jline.SimpleCompletor  implements
    groovy.lang.GroovyObject {
public GrailsInteractiveCompletor
(grails.util.BuildSettings settings, java.util.List<java.io.File> scriptResources) {
super ((java.lang.String)null);
}
public  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}
public  void setMetaClass(groovy.lang.MetaClass mc) { }
public  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}
public  java.lang.Object getProperty(java.lang.String property) { return null;}
public  void setProperty(java.lang.String property, java.lang.Object value) { }
public  grails.util.BuildSettings getSettings() { return (grails.util.BuildSettings)null;}
public  void setSettings(grails.util.BuildSettings value) { }
public  java.util.Map getCompletorCache() { return (java.util.Map)null;}
public  void setCompletorCache(java.util.Map value) { }
@java.lang.Override() public  int complete(java.lang.String buffer, int cursor, java.util.List clist) { return (int)0;}
public static  java.lang.String[] getScriptNames(java.util.List<java.io.File> scriptResources) { return (java.lang.String[])null;}
}
{code}


diff of generated stubs:
{code}
< super ((java.lang.String)null);
---
> super ((java.io.InputStream)null);
{code}

Source code of GrailsInteractiveCompletor:
https://github.com/grails/grails-core/blob/1239b8edb606cca1c137285393a366898e18e196/grails-bootstrap/src/main/groovy/org/codehaus/groovy/grails/cli/interactive/GrailsInteractiveCompletor.groovy#L47

however the picked constructor in the successfull case is also invalid. The groovy source code is calling the constructor with the String[] constructor.

Source code of the super class, jline's SimpleCompletor: https://github.com/jline/jline/blob/master/src/main/java/jline/SimpleCompletor.java#L53 ",,blackdrag,emilles,lhotari,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 08 22:08:49 UTC 2021,,,,,,,,,,"0|i2bvs7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jul/13 03:30;blackdrag;The stub generator does not know the return type of getScriptNames(scriptResources). And as a result, it will just select the first constructor that fits in terms of number of arguments. Which that one is depends on the JVM and parameters given to it, since it is reflected by the internal ordering the JVM uses and that is not fixed. So it is perfectly possible that one time InputStream and one time String or String[] is used. It is quite random.

Since the stub is supposed to be only a helper for javac rather than real code, the question is here: what exactly is wrong?
Looking at GrailsInteractiveCompletor it throws an IOException, but the stub as you have shown it, does not. The result is an compilation error due to the declared IOException being thrown in the InputStream version taken, but not thrown or catched in the stub.

Since the source declares the exception being thrown, the exception has to appear in the stub as well. This is so to say part1 of the bug. With this fixed there will be no failing compilation anymore. Part2 would be that the ""right"" method is selected, in which case throwing the exception is actually not needed, since the String[] version does not throw it. But this is something the stub generator does not guarantee. In those cases you are supposed to use a cast super((String[])getScriptNames(scriptResources)) to go around this limitation.

So I think this issue should be solely about adding the missing throws declaration in the stub.;;;","29/Jul/13 04:02;lhotari;I tried to modify the constructor like this:
{code}
    GrailsInteractiveCompletor(BuildSettings settings, List<File> scriptResources) {
        super((String[])getScriptNames(scriptResources))
        this.settings = settings
    }
{code}

I removed the ""throws IOException"" since SimpleCompletor's String[] consructor doesn't throw an exception (that was an error in GrailsInteractiveCompletor's constructor) 

{code}
    public SimpleCompletor(final String[] candidateStrings) {
        this(candidateStrings, null);
    }
{code}

This change (removing the ""throws IOException"" and adding the cast to String[]) didn't fix the problem and the same error remains.


;;;","29/Jul/13 04:16;blackdrag;can you take a look at the stub an tell me if the cast is in the stub? Because if not, then this is a second bug... though that would be very strange;;;","29/Jul/13 06:12;lhotari;The cast doesn't make a difference in the stub. The stub is identical (compared to before making changes):
{code}
package org.codehaus.groovy.grails.cli.interactive;

import java.lang.*;
import java.io.*;
import java.net.*;
import java.util.*;
import groovy.lang.*;
import groovy.util.*;

@groovy.transform.CompileStatic() public class GrailsInteractiveCompletor
  extends jline.SimpleCompletor  implements
    groovy.lang.GroovyObject {
public GrailsInteractiveCompletor
(grails.util.BuildSettings settings, java.util.List<java.io.File> scriptResources) {
super ((java.io.InputStream)null);
}
public  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}
public  void setMetaClass(groovy.lang.MetaClass mc) { }
public  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}
public  java.lang.Object getProperty(java.lang.String property) { return null;}
public  void setProperty(java.lang.String property, java.lang.Object value) { }
public  grails.util.BuildSettings getSettings() { return (grails.util.BuildSettings)null;}
public  void setSettings(grails.util.BuildSettings value) { }
public  java.util.Map getCompletorCache() { return (java.util.Map)null;}
public  void setCompletorCache(java.util.Map value) { }
@java.lang.Override() public  int complete(java.lang.String buffer, int cursor, java.util.List clist) { return (int)0;}
public static  java.lang.String[] getScriptNames(java.util.List<java.io.File> scriptResources) { return (java.lang.String[])null;}
}
{code};;;","19/Sep/13 07:33;blackdrag;Lari I was able to reproduce the problem you had in the Groovy 2.1.x and Grails 2.3.x joint build, but I was also able to verify, that adding the cast fixes the problem for me
;;;","19/Sep/13 09:45;blackdrag;actually I found that it makes a difference if the super class comes from the classpath.. I am going to push a fix;;;","19/Sep/13 13:35;lhotari;Jochem, Thanks!;;;","25/Sep/13 08:42;blackdrag;
as far as I can tell, the issue happens if the super class is not resolved, because for example the super class is not on visible to the compiler.;;;","12/Jun/14 23:20;paulk;Jochen, was the fix you mentioned pushed?;;;","08/Jun/21 22:08;emilles;GROOVY-10122 fix finds helper method return type;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
private super class members are not ignored,GROOVY-6278,12817091,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,blackdrag,blackdrag,25/Jul/13 09:45,08/Mar/22 12:16,14/Jul/23 06:01,22/Jan/22 15:20,2.3.0,,,,,,,,,,,,,,,,,,,,,Static compilation,Static Type Checker,,,0,,,,,,,"{code:Java}
class Foo { private x=2 }
class Bar extends Foo{}
@groovy.transform.CompileStatic
def foo() {
  return new Bar().x
}
{code}
the logic in existsProperty finds Foo#x, even though it is private. Groovy does not allow access to super class private members. Compilation should fail here in static compilation mode as well as with the type checker.",,blackdrag,emilles,jwagenleitner,keegan,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-9850,GROOVY-9093,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jan 22 15:20:40 UTC 2022,,,,,,,,,,"0|i2cgx3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Aug/16 00:42;paulk;If you replace {{return new Bar().x}} with {{def b = new Bar(); return b.x}}, you get:
{noformat}
Access to Bar#x is forbidden at line: 6, column: 29
{noformat}
but only for {{CompileStatic}} not {{TypeChecked}}.
So there is a partial check but in the wrong spot (currently {{StaticTypesCallSiteWriter}}). It needs to be earlier - probably within {{existsProperty}} as suggested.;;;","08/Aug/16 03:45;paulk;For completeness, a method example (not just a field) highlighting the bug:
{code}
class Foo { private y(){} }
class Bar extends Foo{}
@groovy.transform.TypeChecked
def baz() { new Bar().y() }
baz()
{code}
Yields the following runtime error:
{noformat}
groovy.lang.MissingMethodException: No signature of method: Bar.y()
{noformat}
;;;","22/Jan/22 15:20;emilles;Fixed by GROOVY-9093, et al.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
super class private members are preferred over public members of the current class with lower priority,GROOVY-6277,12817097,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,blackdrag,blackdrag,25/Jul/13 09:15,26/Jan/22 21:23,14/Jul/23 06:01,22/Jan/22 22:37,2.1.6,2.2.0-beta-1,2.3.0,2.4.0-rc-1,,,,,,,,,,,,,,5.0.0-alpha-1,,,,Static compilation,,,,0,,,,,,,"{code:Java}
class Foo { private getX() {1}}
class Bar extends Foo {public x=2}
@groovy.transform.CompileStatic
def foo() {
return new Bar().x
}
assert foo()==2
{code}
The above example fails at compile time because existsProperty first looks for a getter and finds th private one in Foo. This getter is inaccessible from foo() even in normal Groovy, and should have been ignored instead. If it had been ignored existsProperty might have found Bar#x as a better fit instead",,blackdrag,emilles,jwagenleitner,keegan,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jan 22 22:37:17 UTC 2022,,,,,,,,,,"0|i2cf4n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jan/22 22:37;emilles;https://github.com/apache/groovy/commit/de88bf281b6eef3265eb9bad5d77ada6b8da1794
https://github.com/apache/groovy/commit/5bec4f25783c66c0a3b94dc4d991dae8dcd39000;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Outer class method call failure with @CompileStatic,GROOVY-6276,12817077,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,25/Jul/13 03:16,20/May/14 05:31,14/Jul/23 06:01,16/May/14 15:39,2.1.6,,,,,,,,,,,,,,,,,2.2.3,2.3.1,,,Static compilation,,,,0,,,,,,,"Take the following code:
{code}
import groovy.transform.CompileStatic

@CompileStatic
class Outer {
    private int outerField = 1
    private int outerMethod() { 2 }
    int outerProperty = 3
    class Inner {
        void assertions() {
            assert outerField == 1            // #1
            assert outerMethod() == 2         // #2
            assert outerProperty == 3         // #3
            //assert getOuterProperty() == 4  // #4
        }
    }
    void test() {
        new Inner().assertions()
    }
}
new Outer().test()

{code}

Assertion #2 fails *at runtime* with:

{noformat}Cannot find matching method Outer$Inner#getOuterProperty(){noformat} which makes me think that the type checker does know that the method belongs to the outer class, but the receiver is not loaded properly. In fact, it should use a generated bridge method for the private method here.

Uncommenting #4 leads to a static type checking error, which indicates that the {{getXXX}} method call is not checking that a property can be defined in an outer class.",,melix,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 16 12:38:21 UTC 2014,,,,,,,,,,"0|i2cgzb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/May/14 12:38;pschumacher;With current master (2.4-Snapshot) this error occurs:


{quote}Caught: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'Outer$Inner@4b8baa34' with class 'Outer$Inner' to class 'Outer'
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'Outer$Inner@4b8baa34' with class 'Outer$Inner' to class 'Outer'{quote}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DOMCategory: text() doesn't get node value if it is a CDATA section,GROOVY-6275,12817072,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,bashnesnos,bashnesnos,24/Jul/13 17:51,14/Oct/13 16:53,14/Jul/23 06:01,25/Jul/13 19:13,2.1.6,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,XML Processing,,,,0,,,,,,,"DOMCategory.test() fetches nothing if data in a node is wrapped in CDATA section.
E.g.:

{code}
    <root>
        <testText>text works</testText>
        <testCDATA><![CDATA[cdata works]]></testCDATA>
    </root>
    ....
    root.testCDATA.text() == """"
{code}

It seems adding a check for CDATA_SECTION_NODE type should be sufficient.
Please find attached test and proposed fix.",,bashnesnos,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Jul/13 17:51;bashnesnos;CdataBugTest.groovy;https://issues.apache.org/jira/secure/attachment/12722394/CdataBugTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 25 19:13:39 UTC 2013,,,,,,,,,,"0|i2csj3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"25/Jul/13 19:13;paulk;Thanks for spotting the problem. It should be fixed now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
replaceNode improvements for XML processing,GROOVY-6274,12811760,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,24/Jul/13 06:38,07/Apr/15 19:07,14/Jul/23 06:01,24/Jul/13 20:12,2.2.0-beta-1,,,,,,,,,,,,,,,,,2.2.0-beta-2,,,,,,,,0,breaking,,,,,,"Groovy's XML processing has a few slightly inconsistent features and a small hole wrt replacing nodes.

The {{replaceNode(Closure)}} method for {{DOMCategory}} returns the last added node rather than the removed node (making it inconsistent with the built-in {{replaceChild}} method) and equivalent methods for general collections (e.g. {{remove}} for {{ArrayList}}).

Ditto for the corresponding method in {{XmlParser}}. Also, {{XmlParser}} lacks a {{replaceNode(Node)}} variant.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 24 20:12:03 UTC 2013,,,,,,,,,,"0|i2btyn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Jul/13 20:12;paulk;replaceNode(Node) added to XmlParser and behavior for replaceNode(Closure) aligned.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot define a no-args closure in Groovy Shell,GROOVY-6272,12817088,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,pschumacher,pschumacher,22/Jul/13 12:06,14/Oct/13 16:53,14/Jul/23 06:01,22/Jul/13 13:11,2.1.6,2.2.0-beta-1,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Groovysh,,,,0,,,,,,,"1. I wanted to define this very simple no-args closure, foo, using groovysh:

{code}
def foo = { ->
        println ""test""
}
{code}

2. But the moment I hit ENTER in the shell after typing out the first line,
I get the following error:

{quote}
$ groovysh
Groovy Shell (2.1.5, JVM: 1.6.0_43)
Type 'help' or '\h' for help.
-----------------------------------------------------------------------------------
groovy:000> def foo = { ->
ERROR org.codehaus.groovy.control.MultipleCompilationErrorsException:
startup failed:
groovysh_parse: 2: unexpected token: -> @ line 2, column 13.
   def foo = { ->
                   ^
1 error
            at java_lang_Runnable$run.call (Unknown Source)
{quote}

source: [http://groovy.329449.n5.nabble.com/groovysh-bug-Cannot-define-a-no-args-closure-which-I-can-define-outside-of-it-td5716267.html]",,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 22 13:11:14 UTC 2013,,,,,,,,,,"0|i2bw7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jul/13 13:11;pschumacher;Thanks to Jason Dillon for the hint how to fix this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovyc AIOBE when using CompileStatic with generics,GROOVY-6271,12815439,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,paulk,,22/Jul/13 06:50,08/Mar/22 12:16,14/Jul/23 06:01,05/Oct/21 15:29,2.2.0-beta-1,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,Static compilation,,,,0,,,,,,,"For this code (left mostly in Java-ish style in case you want to convert back to Java to test it):
{code}
@Grab('org.functionaljava:functionaljava:3.1')
import static fj.data.hlist.HList.HCons;
import static fj.data.hlist.HList.HNil;
import static fj.data.hlist.HList.HAppend.append;
import static fj.data.hlist.HList.HAppend;
import static fj.data.hlist.HList.nil;
import groovy.transform.CompileStatic

@CompileStatic
public class HListExample {
  public static void main(String[] args) {
    final HCons<String, HCons<Integer, HCons<Boolean, HNil>>> a =
      nil().extend(true).extend(3).extend(""Foo"");

    final HCons<Double, HCons<String, HCons<Integer[], HNil>>> b =
      nil().extend([1, 2] as Integer[]).extend(""Bar"").extend(4.0);
//      nil().extend(new Integer[]{1, 2}).extend(""Bar"").extend(4.0);

    final HAppend<HNil, HCons<Double, HCons<String, HCons<Integer[], HNil>>>,
      HCons<Double, HCons<String, HCons<Integer[], HNil>>>> zero = append();

    final HAppend<HCons<Boolean, HNil>, HCons<Double, HCons<String, HCons<Integer[], HNil>>>,
      HCons<Boolean, HCons<Double, HCons<String, HCons<Integer[], HNil>>>>> one = append(zero);

    final HAppend<HCons<Integer, HCons<Boolean, HNil>>, HCons<Double, HCons<String, HCons<Integer[], HNil>>>,
      HCons<Integer, HCons<Boolean, HCons<Double, HCons<String, HCons<Integer[], HNil>>>>>> two = append(one);

    final HAppend<HCons<String, HCons<Integer, HCons<Boolean, HNil>>>,
      HCons<Double, HCons<String, HCons<Integer[], HNil>>>,
        HCons<String, HCons<Integer, HCons<Boolean, HCons<Double, HCons<String, HCons<Integer[], HNil>>>>>>> three = append(two);

    final HCons<String, HCons<Integer, HCons<Boolean, HCons<Double, HCons<String, HCons<Integer[], HNil>>>>>> x = three.append(a, b);

    System.out.println(x.head()); // Foo
    System.out.println(x.tail().tail().tail().tail().head()); // Bar
  }
}
{code}
works (with minor mods in Java) and without @CompileStatic but with @CompileStatic I get three unexpected errors:
{noformat}
Groovyc: java.lang.ArrayIndexOutOfBoundsException: 1
	at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:128)
	at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:107)
	at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.compareGenericsWithBound(GenericsType.java:343)
	at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.checkGenerics(GenericsType.java:275)
	at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.matches(GenericsType.java:246)
	at org.codehaus.groovy.ast.GenericsType.isCompatibleWith(GenericsType.java:173)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isAssignableTo(StaticTypeCheckingSupport.java:361)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.allParametersAndArgumentsMatch(StaticTypeCheckingSupport.java:222)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.chooseBestMethod(StaticTypeCheckingSupport.java:1001)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.findMethod(StaticTypeCheckingVisitor.java:3018)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitStaticMethodCallExpression(StaticTypeCheckingVisitor.java:1777)
	at org.codehaus.groovy.ast.expr.StaticMethodCallExpression.visit(StaticMethodCallExpression.java:44)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:444)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:245)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitDeclarationExpression(ClassCodeVisitorSupport.java:107)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:86)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1409)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1686)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1659)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:120)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:172)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:110)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:60)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:54)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:80)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:85)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:121)
{noformat}
{noformat}
Groovyc: [Static type checking] - Cannot find matching method fj.data.hlist.HList$HCons#extend(int). Please check if the declared type is right and if the method exists.
{noformat}
{noformat}
Groovyc: [Static type checking] - Cannot find matching method fj.data.hlist.HList$HCons#extend(java.lang.String). Please check if the declared type is right and if the method exists.
{noformat}
",,emilles,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 05 15:29:19 UTC 2021,,,,,,,,,,"0|i2cc7b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jul/13 06:55;paulk;Based on Heterogeneous list example from:
https://github.com/functionaljava/functionaljava/blob/master/demo/src/main/fj/demo/HList_append.java;;;","16/May/14 12:45;pschumacher;With current master (2.4-SNAPSHOT) I get:

{quote}16: [Static type checking] - Incompatible generic argument types. Cannot assign fj.data.hlist.HList$HCons <java.math.BigDecimal, fj.data.hlist.HList$HCons> to: fj.data.hlist.HList$HCons <Double, HCons>
 @ line 16, column 7.
         nil().extend([1, 2] as Integer[]).extend(""Bar"").extend(4.0);
         ^
32: [Static type checking] - Cannot call fj.data.hlist.HList$HAppend <HCons, HCons, HCons>#append(fj.data.hlist.HList$HCons <String, HCons>, fj.data.hlist.HList$HCons <Double, HCons>) with arguments [fj.data.hlist.HList$HCons <java.lang.String,  j.data.hlist.HList$HCons>, fj.data.hlist.HList$HCons <java.math.BigDecimal, fj.data.hlist.HList$HCons>]
 @ line 32, column 115.
   ons<Integer[], HNil>>>>>> x = three.appe{quote};;;","05/Oct/21 15:29;emilles;Works under 4.0b1 if literal ""4.0"" is changed to ""4.0d"".;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Verifyerror  in static compiled code,GROOVY-6270,12818257,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,22/Jul/13 03:01,14/Oct/13 16:53,14/Jul/23 06:01,22/Jul/13 05:01,2.1.6,2.2.0-beta-1,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Static compilation,,,,0,,,,,,,"The following program is a test for GROOVY-5883: {code:Java}
            @groovy.transform.CompileStatic
            class Test<T> {
                def map(Closure<T> mapper) { 1 }
                def m1(Closure<Boolean> predicate) {
                    map { T it -> return predicate(it) ? it : null }
                }
                def m2(Closure<Boolean> predicate) {
                    map { T it -> return predicate(it) ? it : (T) null }
                }
                def m3(Closure<Boolean> predicate) {
                    Closure<T> c = { T it -> return predicate(it) ? it : null }
                    map(c)
                }
            }
            def t = new Test<String>()
            assert t.m1{true} == 1
            assert t.m2{true} == 1
            assert t.m3{true} == 1
{code}
This fails to execute in static compilation mode only with a VerifyError in the generated Closure#doCall methods in any of m1/m2/m3.created",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 22 05:01:51 UTC 2013,,,,,,,,,,"0|i2ci73:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jul/13 05:01;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
'class generation' bug when CompileStatic with HashMap and List,GROOVY-6266,12817066,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,radim.vachtl,radim.vachtl,17/Jul/13 15:23,14/Oct/13 16:53,14/Jul/23 06:01,20/Aug/13 08:42,2.1.6,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Static compilation,,,,0,,,,,,,"The test.groovy code below throws
{noformat}
Caught: BUG! exception in phase 'class generation' in source unit 'test.groovy' At line 7 column 13
On receiver: AR.key with message: getAt and arguments: 0
{noformat}

{code}
@groovy.transform.CompileStatic 
class MyClass{
  HashMap<String,List<List>> AR=new HashMap<String,List<List>>()
  
  MyClass(){
    AR.get('key',[['val1'],['val2']])
    println AR.'key'[0]
  }
}

MyClass c=new MyClass()
{code}
",Windows 2003,blackdrag,paulk,radim.vachtl,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 20 08:42:47 UTC 2013,,,,,,,,,,"0|i2c0gf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Jul/13 07:08;blackdrag;looks like the resolving of AR.key goes wrong and no type is stored for that PropertyExpression. What should have happened is that StaticTypeCheckingVisitor recognizes AR as map and handles AR.key as map access which returns a List<List> and then store that type. What seems to happen is that the type is built, but the case falls though everything in existsProperty. In other words the code fails silently;;;","22/Jul/13 15:59;paulk;add code tags;;;","20/Aug/13 08:42;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static.propertyMissing with name and value doesn't called,GROOVY-6264,12817086,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,hubbitus,hubbitus,17/Jul/13 02:37,11/Aug/22 21:03,14/Jul/23 06:01,11/Aug/22 21:03,2.1.3,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,groovy-runtime,,,,0,,,,,,,"{code}
class Foo{} 

Foo.metaClass.static.propertyMissing << {name -> println ""missing static getter $name ""} 
Foo.metaClass.propertyMissing << {name,value -> println ""missing object setter $name $value""} 
Foo.metaClass.propertyMissing << {name -> println ""missing object getter $name ""} 
Foo.metaClass.static.propertyMissing << {name,value -> println ""missing static setter $name $value""} 

Foo.attr 
new Foo().attr1 
new Foo().attr1 = ""bar"" 
Foo.attr = ""bar"" // exception here 
{code}

According to http://groovy.codehaus.org/Using+methodMissing+and+propertyMissing it should.

Please note, I'm googling deeper and found only unanswered question - http://groovy.329449.n5.nabble.com/static-propertyMissing-with-name-and-value-doesn-t-work-Should-it-td5711002.html which is almost copied here, but no any workaround.",,emilles,hubbitus,poundex,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 11 21:03:57 UTC 2022,,,,,,,,,,"0|i2bn4v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jul/13 11:23;hubbitus;What very interesting I can archive such behaviour by:
{code}
@Singleton class Config{
    public def var1 = 'one'
    String var2 = 'two'

    public static set(String name, value){
        Config.instance.""$name"" = value;
    }

    static{
        Config.metaClass.static.propertyMissing = {prop->
            instance.""$prop""
        }
    }
}

[ Config.instance, Config.instance ]

println Config.var1
Config.var1 = '11'
println Config.var1

println Config.var2
Config.var2 = '22'
println Config.var2
{code}

But I have not found mention of ""public static set(String name, value)"" in any documentation but spent few hours googling.;;;","05/Aug/13 14:15;poundex;Thanks for the workaround, Pavel, works perfectly. 
(Same problem, Groovy 2.1.6);;;","11/Aug/22 21:03;emilles;I get this output:
missing static getter attr 
missing object getter attr1 
missing object setter attr1 bar
missing static setter attr bar;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Accessing private methods from public ones using categories and inheritance causes MissingMethodException,GROOVY-6263,12818238,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,dsrkoc,dsrkoc,16/Jul/13 11:05,02/May/17 02:03,14/Jul/23 06:01,19/Mar/15 05:43,1.8.9,2.0.8,2.1.6,2.4.0-rc-1,,,,,,,,,,,,,,2.5.0-alpha-1,,,,groovy-runtime,,,,1,breaking,,,,,,"Private methods cannot be accessed from public ones when categories are used, and inheritance is involved.

Consider this code:

{code}
class A {
    private foo(a) { 1 }
    def baz() { foo() }
}

class B extends A {}

class C {}

use(C) {
    new B().baz()
}
{code}

Calling {{baz()}} fails with the {{MissingMethodException}}. Here is the error message and the partial stacktrace:

{code:none}
groovy.lang.MissingMethodException: No signature of method: B.foo() is applicable for argument types: () values: []
Possible solutions: baz(), any(), find(), use([Ljava.lang.Object;), find(groovy.lang.Closure), is(java.lang.Object)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:55)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:78)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:137)
	at A.baz(ConsoleScript0:3)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1085)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:39)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at ConsoleScript0$_run_closure1.doCall(ConsoleScript0:11)
	at ConsoleScript0$_run_closure1.doCall(ConsoleScript0)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
	at groovy.lang.Closure.call(Closure.java:411)
	at groovy.lang.Closure.call(Closure.java:405)
	at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.use(GroovyCategorySupport.java:109)
	at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.access$400(GroovyCategorySupport.java:65)
	at org.codehaus.groovy.runtime.GroovyCategorySupport.use(GroovyCategorySupport.java:249)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.use(DefaultGroovyMethods.java:385)
	at org.codehaus.groovy.runtime.dgm$594.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoMetaMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:313)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:52)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:145)
	at ConsoleScript0.run(ConsoleScript0:10)
...
{code}

Without using categories, everything is fine:

{code}
//use(C) {
    assert new B().baz() == 1
//}
{code}

as is without inheritance:
{code}
use(C) {
    assert new A().baz() == 1
}
{code}

Not using {{private}} modifier also helps:

{code}
class A {
    protected foo(a) { 1 }
    def baz() { foo() }
}

class B extends A {}

class C {}

use(C) {
    assert new B().baz() == 1
}
{code}",,blackdrag,daspilker,dsrkoc,hubbitus,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 19 05:57:59 UTC 2015,,,,,,,,,,"0|i2cj4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jul/13 17:16;blackdrag;I did not check, but I strongly assume, that in case of the category a meta class based path is taken instead of the call site caching one. This path may not have the information needed to set the ""view port"" right, thus simply fails to see the private methods. If I am right, then is is not possible to fix before Groovy 3;;;","19/Mar/15 05:43;blackdrag;I took a second look at this and I found a solution. There is a minimal chance this change is breaking thus I it is only 2.5;;;","19/Mar/15 05:53;daniel.spilker@hamburg.de;Nice, thanks! Now I just need to motivate the Jenkins people to update from 1.8.9 to 2.5. ;-);;;","19/Mar/15 05:57;blackdrag;and a 2.5.0 release ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sql.withTransaction setAutoCommit in finally not wrapped in try/catch,GROOVY-6262,12811787,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,jss,jss,16/Jul/13 11:01,14/Oct/13 16:53,14/Jul/23 06:01,17/Jul/13 00:42,1.8.9,2.0.6,2.1.6,2.2.0-beta-1,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,SQL processing,,,,1,,,,,,,"When using an instance of Sql constructed with a DataSource, I experience a Connection Closed SQLException inside of withTransaction. In the finally clause, calling setAutoCommit(savedAutoCommit) causes another SQLException to be thrown. This means that cacheConnection remains true, and useConnection is still set. The connection is never closed and returned to the DataSource's pool which would allow it to be closed and a new one opened. The next time withTransaction is called, it uses the already set useConnection, which will throw the Connection Closed SQLException again.

This should be fixable by simply wrapping the setAutoCommit in a try/catch just as the other parts of closeResources wrap their actions.",,jspiewak,pschumacher,samp,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 26 09:28:28 UTC 2013,,,,,,,,,,"0|i2cazr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jul/13 13:03;pschumacher;I created [pull request|https://github.com/groovy/groovy-core/pull/218] with the suggested change.;;;","17/Jul/13 00:41;pschumacher;Fixed.

Thanks for reporting. :);;;","26/Aug/13 09:28;samp;Is there an estimated release date for 2.1.7? We are running into this bug more frequently and I'm trying to decide if I need to monkey patch Sql or not.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inefficient method DefaultGrailsDomainClassInjector.implementsMethod(..),GROOVY-6261,12811740,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,adriannistor,adriannistor,16/Jul/13 09:55,05/Apr/15 14:44,14/Jul/23 06:01,17/Jul/13 00:49,2.1.6,2.2.0-beta-1,,,,,,,,,,,,,,,,2.2.0-beta-2,,,,,,,,0,patch,performance,,,,,"The problem appears in versions 2.1.6, 2.2.0-beta-1 and in revision ca83beb.

I attached a simple patch that fixes it.

The patch moves only one line, but it looks larger because I indented the loop to preserve formatting.

In method ""DefaultGrailsDomainClassInjector.implementsMethod"", the loop over ""methods"" should not be executed when 
""(argTypes == null || argTypes.length ==0)"" is false.  When  ""(argTypes == null || argTypes.length ==0)"" is false, ""isZeroArg"" is false, which makes ""methodMatch"" false, which means the loop will not execute ""return true"".  ""return true"" is the loop's only side effect, so when ""return true"" cannot be executed, the loop is not necessary.
Note that ""argTypes"" and ""argTypes.length"" are never modified in the loop, so the value of ""(argTypes == null || argTypes.length ==0)"" does not change during the loop execution.",,adriannistor1,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Jul/13 09:55;patch.diff;https://issues.apache.org/jira/secure/attachment/12723228/patch.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Wed Jul 17 00:49:14 UTC 2013,,,,,,,,,,"0|i2cmrz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jul/13 10:01;adriannistor;Pull request at: https://github.com/groovy/groovy-core/pull/217;;;","17/Jul/13 00:49;pschumacher;Merged pull request.

Thanks. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc information loss when using generics,GROOVY-6258,12817076,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mbezjak,mbezjak,16/Jul/13 07:35,28/May/14 03:03,14/Jul/23 06:01,20/May/14 05:28,2.1.6,,,,,,,,,,,,,,,,,2.3.2,,,,GroovyDoc,,,,0,contrib,,,,,,"-------------------------------
$ groovydoc --version
GroovyDoc 2.1.6
$ cat > Foo.groovy <<EOF
class Foo {
    List<String> bar() { null }
}
EOF
$ groovydoc Foo.groovy
$ open index.html
-------------------------------

Problem:
Generated GAPI shows only `List bar()` method. Information about generics (String) is lost. This is suboptimal because the API needs to reiterate the same information in the /** */ documentation.

Further information:
http://groovy.329449.n5.nabble.com/groovydoc-information-loss-for-enums-and-generics-td5716165.html",,mbezjak,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 20 05:28:04 UTC 2014,,,,,,,,,,"0|i2bql3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/May/14 12:17;pschumacher;Miro Bezjak provided a pull request which fixed this issue: [https://github.com/groovy/groovy-core/pull/243];;;","17/May/14 12:32;mbezjak;I'm afraid the [pull request|https://github.com/groovy/groovy-core/pull/243/files] didn't address generics. Only enums as reported in [GROOVY-6257|https://jira.codehaus.org/browse/GROOVY-6257]. I can still reproduce the problem with:

{code}
$ groovydoc --version
GroovyDoc 2.3.0
{code}
;;;","17/May/14 12:36;pschumacher;Reopened: I mixed things up. As Miro clarified the pull request did not fix this issue.;;;","19/May/14 05:53;paulk;The GroovyDoc tool is in need of a bit of a re-write but we are waiting on the long-awaited antlr grammar change, In any case, for 2.3.1 simple generics should now be displayed in groovydoc. For more complex cases, the generics should display but without proper links to all of the types.;;;","19/May/14 06:56;paulk;Just noticed that some generics info isn't being carried over in our Java to Groovy AST converter - so that needs tweaking too. In the meantime, Groovy files will have a little bit more info than Java ones.;;;","20/May/14 01:07;paulk;2.3.2 should handle multiple type arguments and handle the differences discovered for Java vs Groovy files.

Still a few things need fixing, e.g. for ListWithDefault, it currently displays:
{code}
class ListWithDefault
...
boolean add(int i, Object t)
boolean addAll(Collection<? extends def> ts)
Object get(int index)
{code}
but should be:
{code}
class ListWithDefault<T>
...
boolean add(int i, T t)
boolean addAll(Collection<? extends T> ts)
T get(int index)
{code};;;","20/May/14 05:28;paulk;OK, I fixed up a few more type argument/type parameter issues. If everyone is happy, I'll resolve this now. There are still some remaining minor issues. It might be best to capture them in separate Jiras otherwise this one could just keep dragging on.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc information loss for enums,GROOVY-6257,12817061,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mbezjak,mbezjak,16/Jul/13 07:30,14/Oct/13 16:53,14/Jul/23 06:01,04/Oct/13 08:57,2.1.6,,,,,,,,,,,,,,,,,2.1.8,,,,GroovyDoc,,,,0,,,,,,,"-------------------------------
$ groovydoc --version
GroovyDoc 2.1.6
$ cat > Foo.groovy <<EOF
enum Foo {
    A, B, C, D
}
EOF
$ groovydoc Foo.groovy
$ open index.html
-------------------------------

Problem: generated GAPI doesn't show enumerated values of `Foo` (A, B, C, D).

Further information:
http://groovy.329449.n5.nabble.com/groovydoc-information-loss-for-enums-and-generics-td5716165.html",,mbezjak,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-07-16 07:30:41.0,,,,,,,,,,"0|i2clbj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
XMLSlurper accessing xml:id,GROOVY-6255,12817071,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,rwinch,rwinch,15/Jul/13 09:47,24/Apr/14 19:00,14/Jul/23 06:01,13/Apr/14 23:39,2.0.6,2.1.6,2.2.0-beta-1,,,,,,,,,,,,,,,2.3.0-rc-1,,,,XML Processing,,,,0,,,,,,,"I believe I have found a regression introduced by GROOVY-4637 The issue is most easily demonstrated through the following tests:

{code}
import spock.lang.*

class XmlSlurperPasivityTest extends Specification {
  def theInputData = '''<?xml version=""1.0"" encoding=""UTF-8""?>
            <appendix version=""5.0"" xmlns=""http://docbook.org/ns/docbook"" xmlns:xml=""http://www.w3.org/XML/1998/namespace""> 
              <section xml:id=""a""/> 
            </appendix>'''

  def theXml = new XmlSlurper().parseText(theInputData)
      .declareNamespace(xml:'http://www.w3.org/XML/1998/namespace', docbook: 'http://docbook.org/ns/docbook')

  def 'attributes().get(""id"")'() {
    when:
      def id = theXml.section[0].attributes().get('id')
    then: 'failure with >= groovy 1.6 and success with < groovy 1.6'
      id == 'a'
  }

  def '.@id'() {
    when:
      def id = theXml.section[0].@'id'
    then: 'failure with >= groovy 1.6 and success with < groovy 1.6'
      id == 'a'
  }

  def '.@""xml:id""'() {
    when:
      def id = theXml.section[0].@'xml:id'
    then: 'failure with >= groovy 1.6 and success with < groovy 1.6'
      id == 'a'
  }
  
  def 'attributes().get()'() {
    when:
      def id = theXml.section[0].attributes().get('{http://www.w3.org/XML/1998/namespace}id')
    then: 'success with >= groovy-1.6'
      id == 'a'
  }

  def 'attributes().get(""xml:id"")'() {
    when:
      def id = theXml.section[0].attributes().get('xml:id')
    then: 'failure with all'
      id == 'a'
  }
}
{code}",,jwagenleitner,paulk,rwinch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Apr 13 23:39:44 UTC 2014,,,,,,,,,,"0|i2bnl3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"13/Apr/14 23:39;paulk;As far as I could tell, this only affected the 'xml' namespace. It should be fixed in the next release. I haven't merged into older versions of Groovy at the moment but can do if there is sufficient demand.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc fails when java files start with single line comments,GROOVY-6254,12818519,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,roller_vaclav,roller_vaclav,15/Jul/13 08:54,28/Apr/14 19:30,14/Jul/23 06:01,25/Apr/14 07:11,2.0.7,2.1.6,,,,,,,,,,,,,,,,2.2.3,2.3.0-rc-2,,,GroovyDoc,,,,0,,,,,,,"GPars cannot have its groovyDoc generated since we switched from 1.8.6 to 2.0.x.
Neither the ""gradlew groovyDoc"" nor the ""groovydoc groovyx/gpars/*"" commands work in under any 2.0 and 2.1 Groovy version. They both throw an exception and generate nothing:

To reproduce, checkout GPars () and run ""gradlew groovyDoc"". Alternatively switch to the src/main/groovy and run ""groovydoc -d doc groovyx/gpars/*""


Caused by: java.util.NoSuchElementException
	at java.util.StringTokenizer.nextToken(StringTokenizer.java:332)
	at org.codehaus.groovy.tools.groovydoc.SimpleGroovyClassDocAssembler.getChildTextFromSource(SimpleGroovyClassDocAssembler.java:498)
	at org.codehaus.groovy.tools.groovydoc.SimpleGroovyClassDocAssembler.getDefaultValue(SimpleGroovyClassDocAssembler.java:484)
	at org.codehaus.groovy.tools.groovydoc.SimpleGroovyClassDocAssembler.visitAnnotationFieldDef(SimpleGroovyClassDocAssembler.java:301)
	at org.codehaus.groovy.antlr.treewalker.TraversalHelper.visitNode(TraversalHelper.java:66)
	at org.codehaus.groovy.antlr.treewalker.TraversalHelper.openingVisit(TraversalHelper.java:527)
	at org.codehaus.groovy.antlr.treewalker.TraversalHelper.accept_FirstSecondAndThirdChild_v_v_ForthChild(TraversalHelper.java:381)
	at org.codehaus.groovy.antlr.treewalker.SourceCodeTraversal.accept(SourceCodeTraversal.java:154)
	at org.codehaus.groovy.antlr.treewalker.TraversalHelper.acceptChildren(TraversalHelper.java:513)
	at org.codehaus.groovy.antlr.treewalker.TraversalHelper.accept_v_AllChildren_v(TraversalHelper.java:448)
	at org.codehaus.groovy.antlr.treewalker.SourceCodeTraversal.accept(SourceCodeTraversal.java:124)
	at org.codehaus.groovy.antlr.treewalker.TraversalHelper.acceptSiblings(TraversalHelper.java:503)
	at org.codehaus.groovy.antlr.treewalker.TraversalHelper.accept_FirstChild_v_RestOfTheChildren(TraversalHelper.java:456)
	at org.codehaus.groovy.antlr.treewalker.SourceCodeTraversal.accept(SourceCodeTraversal.java:191)
	at org.codehaus.groovy.antlr.treewalker.TraversalHelper.acceptSiblings(TraversalHelper.java:503)
	at org.codehaus.groovy.antlr.treewalker.TraversalHelper.process(TraversalHelper.java:551)
	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.parseJava(GroovyRootDocBuilder.java:110)
	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.getClassDocsFromSingleSource(GroovyRootDocBuilder.java:73)
	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.processFile(GroovyRootDocBuilder.java:208)
	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.buildTree(GroovyRootDocBuilder.java:165)
	at org.codehaus.groovy.tools.groovydoc.GroovyDocTool.add(GroovyDocTool.java:81)
	at org.codehaus.groovy.tools.groovydoc.GroovyDocTool$add.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at org.codehaus.groovy.tools.groovydoc.Main.execute(Main.groovy:205)
	at org.codehaus.groovy.tools.groovydoc.Main.main(Main.groovy:173)
	... 6 more
",,melix,paulk,venca,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6714,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 25 07:11:47 UTC 2014,,,,,,,,,,"0|i2ck6f:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"15/Jul/13 09:52;melix;Ok guys, I can't really say why currently, but it seems that the GPars file headers are causing problems here. If you replace the {{//}} with a {{/* .. */}} block, it passes. I had to modify only 3 files to have it work: {{AsyncFun.java}}, {{ActiveObject.java}} and {{ActiveMethod.java}}.
;;;","15/Jul/13 10:17;roller_vaclav;Awesome! Thanks a lot for a prompt advice, Cedric.
It seems, GroovyASTTransformationClasses can cause groovydoc some headache.

;;;","25/Apr/14 07:11;paulk;I tried this again with the latest version of Groovydoc after fixing GROOVY-6714 after locally reverting to the old version of the GPars source file. Without the fix I still got the error described in this issue. With the fix for GROOVY-6714 there is no longer an error (on the old or new file).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Grab of an extension module with a transitive dependency fails,GROOVY-6251,12811755,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,13/Jul/13 22:28,07/Apr/15 19:07,14/Jul/23 06:01,21/Jul/13 01:49,2.1.6,2.2.0-beta-1,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,,,,,0,,,,,,,"If you have an extension module with an additional dependency required for loading, the order of jar processing can lead to failure to load the extension.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jul 21 01:49:02 UTC 2013,,,,,,,,,,"0|i2c2x3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jul/13 22:32;paulk;Applied to master. Awaiting feedback.;;;","21/Jul/13 01:49;paulk;No adverse feedback received. Leaving change as initially committed and merged onto 2_1_X.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Parsing issue with enums using inner generic methods,GROOVY-6250,12817060,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,13/Jul/13 01:35,07/Apr/15 19:06,14/Jul/23 06:01,21/Jul/13 01:50,2.2.0-beta-1,,,,,,,,,,,,,,,,,2.2.0-beta-2,,,,parser,,,,0,,,,,,,"As per the mailing list:
http://groovy.markmail.org/thread/lw3nm5yjzm37gkbr

The type parameter information is being incorrectly treated during parsing.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jul 21 01:50:35 UTC 2013,,,,,,,,,,"0|i2cbin:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jul/13 22:31;paulk;Applied to master. Awaiting feedback.;;;","21/Jul/13 01:50;paulk;No negative feedback, leaving unchanged.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""int not-equal int"" compiled using slow path in static complation mode",GROOVY-6249,12817034,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,blackdrag,blackdrag,12/Jul/13 09:00,14/Oct/13 16:54,14/Jul/23 06:01,12/Jul/13 12:52,,,,,,,,,,,,,,,,,,2.1.7,,,,Static compilation,,,,0,,,,,,,"{code:Java}
@groovy.transform.CompileStatic
boolean foo(int i, int j) {
  return i!=j
}
{code}
In this code the i!=j is done using the runtime code even though it should be done directly using the jvm codes for compares",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-07-12 09:00:02.0,,,,,,,,,,"0|i2c50n:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@EqualsAndHashCode assumes get style getters for boolean properties,GROOVY-6245,12815598,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,erdi,erdi,09/Jul/13 10:32,01/Feb/17 23:19,14/Jul/23 06:01,06/Aug/16 05:03,2.1.6,2.2.0-beta-1,2.4.5,,,,,,,,,,,,,,,2.4.8,,,,xforms,,,,1,,,,,,,"It basically means that equals() and hashCode() generated using @EqualsAsHashCode will throw MissingMethodException if you define only is style getters for a glass. I expected the following to pass but it doesn't:

{code}
import groovy.transform.EqualsAndHashCode 

@EqualsAndHashCode
class A {
    boolean a
 
    boolean isA() { a }
}
 
def a1 = new A(a: true)
def a2 = new A(a: true)
assert a1.a
assert a1.hashCode()
assert a1 == a2
{code}",,erdi,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5752,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 06 05:03:20 UTC 2016,,,,,,,,,,"0|i2bz27:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Jul/13 04:54;paulk;This possibly overlaps with GROOVY-5752. I.e. in both cases it might not be the AST transform that is the problem. If you change the type of ""a"" to be the wrapper type (i.e. Boolean), your code works. That workaround shouldn't be needed but it might be that we tweak how the getters are generated rather than tweak @EqualsAndHashCode.;;;","10/Jul/13 05:12;erdi;Thanks for mentioning the workaround Paul. I can confirm that it works for me. I need to specifically use primitive types in getters as they are used by an interface the class implements but changing only the field type to Boolean made the exception go away. I also need to have explicit is style accessors as the class is being serialized to json using jackson and it gets confused if it sees both get and is style getters for a property. ;;;","05/Aug/16 09:33;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/379

    GROOVY-6245: @EqualsAndHashCode assumes get style getters for boolean…

    … properties

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy6245

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/379.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #379
    
----
commit 50ba3758e3fb435e6d7135455ef62251a0af22e6
Author: paulk <paulk@asert.com.au>
Date:   2016-08-05T09:22:31Z

    GROOVY-6245: @EqualsAndHashCode assumes get style getters for boolean properties

----
;;;","06/Aug/16 00:08;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/379
;;;","06/Aug/16 05:03;paulk;Proposed PR merged and ported back to the 2_4_X branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyConsole doesn't show SimpleMessage,GROOVY-6244,12817045,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,09/Jul/13 04:13,10/Jul/13 04:42,14/Jul/23 06:01,09/Jul/13 04:15,2.1.5,,,,,,,,,,,,,,,,,2.1.6,,,,,,,,0,,,,,,,"If the compiler adds a {{SimpleMessage}} as a compilation error (which happens with {{addErrorAndContinue}}), the error is not displayed by the Groovy Console.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-07-09 04:13:29.0,,,,,,,,,,"0|i2bztr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Semantics of multiple assignment different using @CompileStatic,GROOVY-6243,12817055,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,08/Jul/13 15:38,10/Jul/13 04:42,14/Jul/23 06:01,08/Jul/13 16:13,2.1.5,,,,,,,,,,,,,,,,,2.1.6,,,,Static compilation,,,,0,,,,,,,"The static compiler doesn't have the same semantics for multiple assignments. For example, this:

{code}
void test(int result, int next) {
    (result, next) =  [next, next + result]
    println result
    println next
}

test(0,1)
{code}

prints
{noformat}
1
1
{noformat}

but using {{@CompileStatic}}, it returns:

{noformat}
1
2
{noformat}

Behaviors should be aligned.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-07-08 15:38:50.0,,,,,,,,,,"0|i2cf53:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type inference fails for methods returning generic map types,GROOVY-6241,12818526,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,robfletcher,robfletcher,08/Jul/13 05:04,14/Oct/13 16:53,14/Jul/23 06:01,10/Sep/13 08:02,2.1.5,,,,,,,,,,,,,,,,,2.1.8,2.2.0,,,Static compilation,Static Type Checker,,,0,,,,,,,"The static type checker rejects the last of the 4 assignments in the following code:

{code}
@groovy.transform.CompileStatic
class Foo {
    static void main(String... args) {
        List<Integer> list = [1, 2, 3]
        List<Integer> immutableList = [1, 2, 3].asImmutable()
        Map<String, Integer> map = [foo: 123, bar: 456]
        Map<String, Integer> immutableMap = [foo: 123, bar: 456].asImmutable()
    }
}
{code}

with the error {{Incompatible generic argument types. Cannot assign java.util.Map <java.lang.Object, java.lang.Object> to: java.util.Map <String, Integer>}}.

The generic signature on {{asImmutable}} should be sufficient for type inference to work (as it does for the list in the 2nd assignment).",,blackdrag,fletcherr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 10 08:02:11 UTC 2013,,,,,,,,,,"0|i2ceo7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Sep/13 03:28;blackdrag;looks like my fix to that one will also make clear that optimizers for int[].getAt(int) are needed;;;","10/Sep/13 08:02;blackdrag;Looks like the optimizers where not needed after fixing the information flow. The issue here should be fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker confuses method calls on closure expressions with closure.call,GROOVY-6238,12817044,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,04/Jul/13 11:14,10/Jul/13 04:42,14/Jul/23 06:01,04/Jul/13 11:25,2.1.5,,,,,,,,,,,,,,,,,2.1.6,,,,Static Type Checker,,,,0,,,,,,,"The following code does not compile because the type checker confuses {{curry}} with {{call}}:

{code}
@TypeChecked
void test() {
    def cl = { it }.curry(42)
    def val = cl.call()
    assert val == 42
}
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-07-04 11:14:15.0,,,,,,,,,,"0|i2c40n:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
wrong resolution for hidden generics,GROOVY-6237,12817056,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,04/Jul/13 09:58,10/Jul/13 04:42,14/Jul/23 06:01,08/Jul/13 08:19,,,,,,,,,,,,,,,,,,2.1.6,2.2.0-beta-1,,,Static Type Checker,,,,0,,,,,,,"{code:Java}
class Blah {}
class MyList extends LinkedList<Object> {}
List<Blah> o = new MyList()
{code}
should not pass the type checker, but 
{code:Java}
class Blah {}
class MyList extends LinkedList<Object> {}
List<Object> o = new MyList()
{code}
should. Currently both pass.",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 08 08:19:41 UTC 2013,,,,,,,,,,"0|i2ckdj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Jul/13 08:19;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
code compiled with CompileStatic will under some circumstances call wrong version of overloaded method,GROOVY-6235,12818470,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,robfletcher,robfletcher,04/Jul/13 04:15,10/Jul/13 04:42,14/Jul/23 06:01,04/Jul/13 06:59,2.1.5,,,,,,,,,,,,,,,,,2.1.6,,,,Static compilation,,,,0,,,,,,,"I'm calling a Java API that has a method {{addImage(String...)}} and another {{addImage()}} which calls the first with a single argument.

When I call the no-argument method from a Groovy class it works fine but if I add {{@CompileStatic}} to that Groovy class it will now dispatch to the varargs form with no arguments.

Also I found that if the call target is a field of the Groovy class it works properly, this only happens when the call target is a local variable.

I have been unable to reproduce this when calling a class of my own so I've attached a test case calling the same API I'm using (im4java).",,fletcherr,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"04/Jul/13 04:34;compileStaticOverloadCall.tgz;https://issues.apache.org/jira/secure/attachment/12723130/compileStaticOverloadCall.tgz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 04 06:59:44 UTC 2013,,,,,,,,,,"0|i2c0z3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"04/Jul/13 04:30;robfletcher;I've managed to recreate it by introducing a sub-class of the call target. Updated test case attached.

I have 2 Java classes; {{Thing}} and {{SubThing extends Thing}}. The overloaded methods are declared on {{Thing}}. A dynamically compiled Groovy class that calls {{new SubThing().method()}} dispatches correctly to {{Thing.method()}} but a statically compiled Groovy class will call {{Thing.method(new String[0])}}.

This does not happen when the Groovy code calls {{new Thing().method()}} only when it calls the sub-class.;;;","04/Jul/13 04:35;melix;Does the original example imply a class hierarchy too?;;;","04/Jul/13 04:53;robfletcher;Yes, the original involved methods defined on {{org.im4java.core.Operation}} and called on {{org.im4java.core.IMOperation}} which extends {{Operation}}.;;;","04/Jul/13 06:59;melix;Thanks for the example, really helped!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy can not be build with Gradle 1.6,GROOVY-6234,12816885,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,pschumacher,pschumacher,03/Jul/13 14:49,10/Jul/13 04:42,14/Jul/23 06:01,04/Jul/13 00:32,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,,,,,0,,,,,,,"Calling for example ""gradle clean dist"" fails with this message:

{quote}
         FAILURE: Build failed with an exception.
       
        * Where:
        Build file '/home/Checkouts/Git/Git/GroovyCore/subprojects/groovy-swing/build.gradle' line: 2
       
        * What went wrong:
        A problem occurred evaluating project ':groovy-swing'.
        > Circular referencing during evaluation for root project 'groovy'.
       
        * Try:
        Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.
       
        BUILD FAILED
       
        Total time: 1 mins 13.343 secs 
{quote}",,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 04 00:32:40 UTC 2013,,,,,,,,,,"0|i2c3ev:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Jul/13 00:27;paulk;Pascal, should we close this now that we (kudos to you, Guillaume and Luke Daley's support) have the build working with 1.7-RC1?;;;","04/Jul/13 00:32;pschumacher;Because of the required version of the  BND plugin Gradle 1.7 is now required to build Groovy.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static type checker fails to check constructor arguments,GROOVY-6233,12817050,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,03/Jul/13 07:04,10/Jul/13 04:42,14/Jul/23 06:01,08/Jul/13 08:18,,,,,,,,,,,,,,,,,,2.1.6,2.2.0-beta-1,,,Static Type Checker,,,,0,,,,,,,"{code:Java}
class Foo<T>{  Foo(T a, T b){} }
@groovy.transform.TypeChecked
def bar() {
    Foo<Map> f = new Foo<Map>(""a"",1)
}
bar()
{code}
The code passes, even though ""a"" and 1 are surely no maps.",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 08 08:18:45 UTC 2013,,,,,,,,,,"0|i2crx3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Jul/13 08:18;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker fails with internal error for diamond ,GROOVY-6232,12817058,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,03/Jul/13 06:59,03/Mar/21 00:00,14/Jul/23 06:01,08/Jul/13 08:18,,,,,,,,,,,,,,,,,,2.1.6,2.2.0-beta-1,,,Static Type Checker,,,,0,,,,,,,"{code:Java}
class Foo<T>{  Foo(T a, T b){} }
@groovy.transform.CompileStatic
def bar() {
    Foo<Object> f = new Foo<>(""a"", new Object())
}
bar(){code}
fails with an internal error, even though it should have passed",,blackdrag,,,,,,,,,,,,,,,"eric-milles opened a new pull request #1505:
URL: https://github.com/apache/groovy/pull/1505


   https://issues.apache.org/jira/browse/GROOVY-6232
   https://issues.apache.org/jira/browse/GROOVY-9956


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;27/Feb/21 21:30;githubbot;600","danielsun1106 merged pull request #1505:
URL: https://github.com/apache/groovy/pull/1505


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;02/Mar/21 23:59;githubbot;600","danielsun1106 commented on pull request #1505:
URL: https://github.com/apache/groovy/pull/1505#issuecomment-789311952


   Merged. Thanks!


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;03/Mar/21 00:00;githubbot;600",,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 08 08:18:26 UTC 2013,,,,,,,,,,"0|i2cpgf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Jul/13 08:18;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TypeChecker confuses attribute with field if getter has different type,GROOVY-6230,12818497,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,robfletcher,robfletcher,02/Jul/13 11:10,10/Jul/13 04:42,14/Jul/23 06:01,04/Jul/13 04:21,2.1.5,,,,,,,,,,,,,,,,,2.1.6,,,,Static compilation,,,,0,,,,,,,"I noticed this today when trying to use {{@CompileStatic}} with some code that uses {{java.awt.Dimension}} which has a {{public double getWidth()}} and {{public int width}}.

I have a method that expects an {{int}} parameter and pass it {{dim.@width}} but the static compilation reports {{Cannot find matching method Thing#callee(double). Please check if the declared type is right and if the method exists.}}

I have attached a test (well, a piece of code that should compile).

This may be a regression of GROOVY-5704.",,fletcherr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"02/Jul/13 11:10;compileStaticBug.tgz;https://issues.apache.org/jira/secure/attachment/12723201/compileStaticBug.tgz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 03 03:45:15 UTC 2013,,,,,,,,,,"0|i2bs2v:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"03/Jul/13 03:45;robfletcher;Interestingly even an explicit Java style cast is not accepted by the static compiler. i.e. if I do {{callee((int)dim.@width)}} the same compile time error is raised.

Correction: sorry this only happens when I omit the method call braces {{callee (int)dim.@width}} so that may be valid.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Compile time type of result of integer increment/decremnt is Object, not int?",GROOVY-6223,12817048,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mpierce,mpierce,28/Jun/13 13:35,10/Jul/13 04:42,14/Jul/23 06:01,01/Jul/13 05:13,2.1.5,,,,,,,,,,,,,,,,,2.1.6,,,,Static Type Checker,,,,0,,,,,,,"See https://bitbucket.org/marshallpierce/groovy-int-increment-decrement for a simple test case.

See https://bitbucket.org/marshallpierce/groovy-int-increment-decrement/src/11bf750fb3a14441598841f819aca7b2f88f9474/src/main/groovy/IntIncrementDecrementTest.groovy?at=master for the source in question.

It seems like if it's determining types statically, then it should know that i and j are ints, and that the type of i++ and ++j should also be int.","JVM 1.7.0_25, Groovy 2.1.5",melix,mpierce,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 01 05:13:12 UTC 2013,,,,,,,,,,"0|i2c1uv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jul/13 05:13;melix;Thanks, the problem was that the inferred type wasn't stored on pre/postfix expressions.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closure return type inference not used if a method is directly using a closure as argument,GROOVY-6219,12817054,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,27/Jun/13 02:15,10/Jul/13 04:42,14/Jul/23 06:01,27/Jun/13 07:08,2.1.5,,,,,,,,,,,,,,,,,2.1.6,,,,Static Type Checker,,,,0,,,,,,,"The following code fails compilation (which is what we want):

{code}
@TypeChecked
void printMessage(Closure<String> messageProvider) {
    println ""Received message : ${messageProvider()}""
}
@TypeChecked
void testMessage() {
    def returnsString = { 'Hello, Groovy!' }
    def returnsInt = { int x, int y -> x+y }
    printMessage(returnsString)			
    printMessage(returnsInt)			
}
{code}

However if we do:

{code}
@TypeChecked
void printMessage(Closure<String> messageProvider) {
    println ""Received message : ${messageProvider()}""
}
@TypeChecked
void testMessage() {
    printMessage { 'Hello, Groovy!' }
    printMessage { int x, int y -> x+y }
}
{code}

It fails recognizing that the second call to {{printMessage}} is invalid.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-06-27 02:15:35.0,,,,,,,,,,"0|i2cowf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker doesn't find the inject method,GROOVY-6218,12816875,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,27/Jun/13 02:13,04/Mar/14 16:31,14/Jul/23 06:01,22/Jan/14 10:33,2.1.5,,,,,,,,,,,,,,,,,2.2.2,,,,Static Type Checker,,,,0,,,,,,,"For some reason, in the following code, the {{inject}} method is not recognized by the type checker:

{code}
@groovy.transform.TypeChecked
def foo() {
    [milk: [1,1.0], croissant:[4,0.85]].inject(0) { int sum, Map.Entry<String,List> entry -> 
        List<? extends Number> v = entry.value
        sum += v[0]*v[1]
        sum 
    }
}

foo()
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-06-27 02:13:12.0,,,,,,,,,,"0|i2bnnj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"The Edit command should replace the shell buffer, not append.",GROOVY-6217,12817027,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,larryj,larryj,26/Jun/13 12:11,05/Apr/15 14:44,14/Jul/23 06:01,30/Jun/13 13:43,2.1.5,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,Groovysh,,,,0,,,,,,,"When you use the edit command in groovysh, the editor's contents should replace the current shell buffer, not append to it.

Steps to reproduce:

  1) launch groovysh on any platform
  2) type an incomplete expression:  
              groovy:000> x = {
  3) type '\e' to launch an editor
  4) Complete the expression in the editor:
              x = { println 2 + 2 }
  5) save and close the editor
  6) notice the new expression has *not* been parsed and executed
  7) type '\d' to display the current buffer.  Notice the edit command *appended* rather than *replaced* the current buffer:
            groovy:002> \d
              000> x = {
              001> x = { println 2 + 2 }

  
              ",,larryj,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Sun Jun 30 13:43:57 UTC 2013,,,,,,,,,,"0|i2bq67:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"26/Jun/13 12:19;larryj;Created pull request:  https://github.com/groovy/groovy-core/pull/211;;;","30/Jun/13 13:43;pschumacher;Thank you Larry for reporting the issue and thanks for pull request with the fix. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem with @TypeChecked and switch statements,GROOVY-6215,12818249,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,brownj,brownj,24/Jun/13 11:24,10/Jul/13 04:42,14/Jul/23 06:01,26/Jun/13 10:06,2.1.5,,,,,,,,,,,,,,,,,2.1.6,,,,Compiler,,,,0,,,,,,,"{code:title=Demo.groovy|borderStyle=solid}
import groovy.transform.CompileStatic

@CompileStatic
class Demo {

    def processNumber(int x) {
        def value = getValueForNumber(x)
        value
    }

    def getValueForNumber(int x) {
        def valueToReturn
        switch(x) {
            case 1:
                valueToReturn = 'One'
                break
            case 2:
                valueToReturn = []
                valueToReturn << 'Two'
                break
        }
        valueToReturn
    }

    static void main(args) {
        def demo = new Demo()
        println demo.processNumber(1)
        println demo.processNumber(2)
        println demo.processNumber(3)
    }
}
{code}


That code will throw a ClassCastException.

{noformat}
 $ groovy Demo
Caught: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'One' with class 'java.lang.String' to class 'java.util.List'
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'One' with class 'java.lang.String' to class 'java.util.List'
	at Demo.processNumber(Demo.groovy:7)
	at Demo.main(Demo.groovy:27)
{noformat}

The compiler is generating the following code for the processNumber method:

{noformat}
 @TypeChecked.TypeCheckingInfo(inferredType=""AAlDbGFzc05vZGUAABBMamF2YS91dGlsL0xpc3Q7AQAAAAEBAAAJQ2xhc3NOb2RlAAASTGphdmEvbGFuZy9PYmplY3Q7AQAAAAEBAAAJQ2xhc3NOb2RlAAADTEU7Af////8A/////wAAAAABAAlDbGFzc05vZGUAABJMamF2YS9sYW5nL09iamVjdDsA/////w=="", version=1)
  public Object processNumber(int x)
  {
    List value = (List)ScriptBytecodeAdapter.castToType(getValueForNumber(x), List.class);
    return value; return null;
  }
{noformat}

It appears that the compiler is picking up the type from whatever the last case statement is.
",,brownj,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 24 11:44:44 UTC 2013,,,,,,,,,,"0|i2c7uv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Jun/13 11:44;melix;This bug shows that the inferred type after a switch is wrong. Switch should be considered as an improved ""if"" statement, which is it not here. Not specific to {{@CompileStatic}} though.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SpreadExpression BUG! when slicing a List,GROOVY-6212,12817041,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ice9,ice9,21/Jun/13 11:35,02/May/17 02:03,14/Jul/23 06:01,01/Jun/15 11:56,2.1.5,2.4.0-rc-1,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,Compiler,,,,0,,,,,,,"Evaluating
{code}
(1..3)[*0..2]
{code}
throws: {{BUG! exception in phase 'class generation' in source unit 'ConsoleScript42' SpreadExpression should not be visited here}}
It works fine if I manually call {{getAt}}:
{code}
(1..3).getAt([*0..2]) // [1, 2, 3]
{code}
It also works if I add something besides the spread:
{code}
(1..3)[*0..2, 2] // [1, 2, 3, 3]
{code}
as shown in the Ranges and List-Slicing section of [Getting Started Guide > Collections|http://groovy.codehaus.org/JN1015-Collections].

There are other SpreadExpression BUG!s, but I'm not sure if this bug is the same:
http://jira.codehaus.org/issues/?jql=text%20%7E%20%22SpreadExpression%22",,daniilo,githubbot,ice9,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7446,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 13 12:27:17 UTC 2017,,,,,,,,,,"0|i2ch7r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jun/13 11:37;ice9;Groovy 2.1.5. Cannot edit the issue, sorry.;;;","01/Jun/15 00:45;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/30

    GROOVY-6212: SpreadExpression BUG! when slicing a List

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy6212

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/30.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #30
    
----
commit 1e34509199f3b23c1ee6de7f4a6b6e1b8407cfaf
Author: Paul King <paulk@asert.com.au>
Date:   2015-06-01T00:43:49Z

    GROOVY-6212: SpreadExpression BUG! when slicing a List

----
;;;","01/Jun/15 11:56;paulk;Thanks for spotting the problem and raising the issue.;;;","01/Jun/15 12:44;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/30
;;;","13/Apr/17 12:27;daniilo;[~paulk] I'm getting the following behaviour in 2.5.0-alpha-1:
{code}
def a = ['foo']
def m = [foo: 42]

println m.get(*a)   // 42
println m.getAt(*a) // 42
println m[*a]       // null
{code}

Is it intended?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Fix failing Process tests on windows,GROOVY-6211,12817007,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,21/Jun/13 06:14,07/Apr/15 19:07,14/Jul/23 06:01,21/Jun/13 17:44,2.1.5,,,,,,,,,,,,,,,,,2.1.6,2.2.0-beta-1,,,,,,,0,,,,,,,"Due to changes in how Processes are executed on Windows (in combination with Java ignoring the JAVA_HOME environment property and instead using the registry java.home setting) causes tests in the Groovy build to fail in Windows. See here for more details:
http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html#jruntime
",Windows,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 21 06:23:46 UTC 2013,,,,,,,,,,"0|i2bmov:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jun/13 06:23;paulk;Fix applied. Will Resolve once CI builds have confirmed that other platforms haven't been affected.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Fix javadoc/groovydoc vulnerability,GROOVY-6210,12817036,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,19/Jun/13 07:21,15/Oct/15 18:19,14/Jul/23 06:01,19/Jun/13 08:48,2.1.5,,,,,,,,,,,,,,,,,2.1.6,,,,Documentation,,,,0,,,,,,,"Both javadoc and groovydoc are vulnerable to an issue fixed only in JDK 1.7.0 update 25.

See 
[1] http://www.oracle.com/technetwork/topics/security/javacpujun2013-1899847.html
[2] http://www.kb.cert.org/vuls/id/225657

The build should be patched to fix the generated files independently of the JDK being used to build Groovy.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-06-19 07:21:58.0,,,,,,,,,,"0|i2bydr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect flow typing reset after if branch,GROOVY-6207,12817046,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,12/Jun/13 13:45,14/Jun/13 05:10,14/Jul/23 06:01,12/Jun/13 14:14,2.1.4,,,,,,,,,,,,,,,,,2.1.5,,,,Static Type Checker,,,,0,,,,,,,"The following code produces a runtime error due to incorrect flow typing inference:

{code}
import groovy.transform.*
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.FIELD])
@interface Ann1 {}
@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.FIELD])
@interface Ann2 {}

            class A {
                @Ann2
                String field
            }
            
            @CompileStatic
            def doit(obj, String propName) {
                def field = obj.getClass().getDeclaredField propName
                println field
                if(field) {
                    def annotation = field.getAnnotation Ann1
                    if(true) {
                        annotation = field.getAnnotation Ann2
                    }
                    return annotation
                }
                return null
            }
            
            println doit(new A(), ""field"")
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-06-12 13:45:10.0,,,,,,,,,,"0|i2ct1r:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
META-INF/services/org.codehaus.groovy.runtime.ExtensionModule missing from groovy-all.jar,GROOVY-6205,12816997,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,pschumacher,pschumacher,11/Jun/13 14:53,14/Jun/13 05:10,14/Jul/23 06:01,11/Jun/13 15:01,2.1.4,,,,,,,,,,,,,,,,,2.1.5,2.2.0-beta-1,,,,,,,0,,,,,,,"see: [http://groovy.329449.n5.nabble.com/Groovy-2-1-4-embedded-issue-td5715701.html]

",,hubbitus,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 12 06:32:02 UTC 2013,,,,,,,,,,"0|i2bs47:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jun/13 15:01;pschumacher;see: [https://github.com/groovy/groovy-core/commit/19fdf544778b0ed12c77f4f55fd5e1c7140d5876]

I just reverted this change: [https://github.com/groovy/groovy-core/commit/54362c7b90ec2a8641d7e3ec85ea981cff8d8e1c]

Maybe there is a better solution, but I'm to tired to think of one at the moment.;;;","11/Jun/13 15:38;paulk;Thanks Pascal, modules without the extension file will now have an unneeded empty dir but that is better than skipping the files in that directory when it is needed.;;;","12/Jun/13 06:32;paulk;OK, just did a minor tweak. So left your revert in place but trying to fix some of the anomalies using other approaches. Currently, the additional empty META-INF folder in the META-INF directory is now gone but there is still the empty ""antlr"" folder hierarchy at the root and an unneeded maven folder with contents within the META-INF directory.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyScriptEngine does not take script base class into account,GROOVY-6203,12817039,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,nicoulaj,nicoulaj,09/Jun/13 10:47,12/Jun/16 08:45,14/Jul/23 06:01,22/May/16 08:07,2.0.5,,,,,,,,,,,,,,,,,2.4.7,,,,GroovyScriptEngine,,,,0,,,,,,,"When configuring GroovyScriptEngine with a custom script base class, the script engine does not take it account:

{code}
CompilerConfiguration cc = new CompilerConfiguration();

cc.setScriptBaseClass(ScriptBase.class.getName());

GroovyScriptEngine engine = new GroovyScriptEngine(""file://."");

engine.setConfig(cc);

Script script = engine.createScript(""test.groovy"", new Binding());

assertTrue(script instanceof ScriptBase); // fails

{code}

This has been discussed here: http://groovy.329449.n5.nabble.com/setScriptBaseClass-does-not-work-for-GroovyScriptEngine-td5710646.html
The workaround with setting the CompilerConfiguration on the GroovyClassLoader works.
Also related: GROOVY-3281",,githubbot,jwagenleitner,nicoulaj,pascalschumacher,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6994,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 22 08:07:44 UTC 2016,,,,,,,,,,"0|i2cgr3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jun/13 10:52;nicoulaj;Corrected sample code (can't edit, sorry):

{code}
CompilerConfiguration cc = new CompilerConfiguration();

cc.setScriptBaseClass(ScriptBase.class.getName());

GroovyScriptEngine engine = new GroovyScriptEngine(""file://."");

engine.setConfig(cc);

Script script = engine.createScript(""test.groovy"", new Binding());

assertTrue(script instanceof ScriptBase); // fails
{code};;;","10/Jun/13 01:25;pschumacher;Updated the sample code for Julien.;;;","19/May/16 10:32;githubbot;GitHub user roded opened a pull request:

    https://github.com/apache/groovy/pull/335

    GROOVY-6203: GroovyScriptEngine does not take script base class into …

    …account
    
    https://issues.apache.org/jira/browse/GROOVY-6203
    
    The alternative as I see it was to remove the config's setter and add it to the constructors. 
    Comments welcome.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/roded/groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/335.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #335
    
----
commit a4b91d623024717d4a4ffb1f9f726b7386e0dea3
Author: Roded Bahat <rodedb@gmail.com>
Date:   2016-05-19T10:30:27Z

    GROOVY-6203: GroovyScriptEngine does not take script base class into account

----
;;;","22/May/16 08:06;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/335
;;;","22/May/16 08:07;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MIssed generics in delegated method,GROOVY-6202,12817033,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,mxm-groovy,mxm,07/Jun/13 04:19,17/Jun/15 20:10,14/Jul/23 06:01,28/Dec/14 07:31,,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,,Compiler,,,,1,,,,,,,"{code}
class A {
    public <T> T foo(Closure<T> c) {c.call()}
}

class B {
    @Delegate
    A a = new A()
}
{code}

A#foo's signature:
{code}
// access flags 0x1
// signature <T:Ljava/lang/Object;>(Lgroovy/lang/Closure<TT;>;)TT;
// declaration: T foo<T>(groovy.lang.Closure<T>)
public foo(Lgroovy/lang/Closure;)Ljava/lang/Object;
{code}

B#foo's signature:
{code}
// access flags 0x1
// signature <T:Ljava/lang/Object;>(Lgroovy/lang/Closure;)Ljava/lang/Object;
// declaration:  foo<T>(groovy.lang.Closure)
public foo(Lgroovy/lang/Closure;)Ljava/lang/Object;   
{code}",,ldaley,mxm,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 07:31:47 UTC 2014,,,,,,,,,,"0|i2c3vz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jun/13 07:14;ldaley;This is an issue for me with Geb that prevents IDEA completing stuff.;;;","28/Dec/14 07:31;pschumacher;With groovy 2.4.0-rc-1 I get:

A: public <T extends java/lang/Object> T foo(groovy.lang.Closure<T>);
B: public <T extends java/lang/Object> java.lang.Object foo(groovy.lang.Closure<java.lang.Object>);

so I'm closing this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"groovysh hangs on Edit command when using terminal editor (vim, nano, etc.) on posix terminals",GROOVY-6201,12817040,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,larryj,larryj,06/Jun/13 17:07,10/Jul/13 04:42,14/Jul/23 06:01,17/Jun/13 17:11,2.1.4,,,,,,,,,,,,,,,,,2.1.6,2.2.0-beta-1,,,Groovysh,,,,0,,,,,,,"I would love to make more use of groovysh from linux, and would be happy to submit a patch if a someone will point me in the right direction.

No matter what combinations of environment or editor setting I try, groovysh will hang on the Edit command (edit or \e) if I use a terminal based editor like vim.

Steps to reproduce:
1. Use ubuntu or os x, I suspect any posix environment
2. set your EDITOR environment variable to vim, pico, nano, emacs, or any terminal-based editor
3. launch groovysh
4. (optional) populate a buffer with a groovy command
5. launch the edit command with 'edit'
7. notice that groovysh hangs
8. in a separate terminal, you can verify the correct editor is launched in a separate process ($ps aux | grep vi), but there's no way to bring it to the foreground
9. Use Ctrl-C to abort groovysh, which also kills the orphaned editor process

If groovysh would support terminal-based editors it'd be my REPL of choice. .  I prefer keyboard over mouse, which is why I would prefer groovysh to groovyConsole.

Thanks for any pointers!

","ubuntu 12.04 64 bit, os x snow leopard",guillaume,larryj,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 17 17:11:09 UTC 2013,,,,,,,,,,"0|i2bz0f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Jun/13 01:49;guillaume;Any idea how to support this?;;;","10/Jun/13 14:27;larryj;I found a potential solution.   Pull request coming shortly.;;;","11/Jun/13 01:32;larryj;Created pull request https://github.com/groovy/groovy-core/pull/208;;;","17/Jun/13 11:38;larryj;I updated the pull request based on Pascal's comments.;;;","17/Jun/13 17:11;pschumacher;Pull request applied.

Thanks Larry. :) ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Ant groovyc throws a NoClassDefFoundError compiling a groovy class with @DelegatesTo and @CompileStatic,GROOVY-6200,12816918,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,bborchardt,bborchardt,06/Jun/13 16:19,14/Jun/13 05:10,14/Jul/23 06:01,07/Jun/13 09:24,2.1.4,,,,,,,,,,,,,,,,,2.1.5,,,,Static compilation,,,,0,,,,,,,"I attached a sample project. The offending class is shown below. For some reason passing the closure inline triggers the error. The error goes away if I remove @CompileStatic, or declare the closure variable before passing it into method2. It also does not occur when compiling in IDEA, only with Ant.

The error itself is easy to work around, but very difficult to identify since there is nothing in the error indicating what code triggered it.
{code}
@groovy.transform.CompileStatic
class MyClass {
    void method1() {
        method2({})
    }

    void method2(@DelegatesTo(strategy = Closure.DELEGATE_FIRST, value = String) Closure body) {

    }
}
{code}
Stack trace:
{code}
build.xml:24: java.lang.NoClassDefFoundError: groovy/lang/GroovyObject
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:791)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:634)
        at groovy.lang.GroovyClassLoader.defineClass(GroovyClassLoader.java:504)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.evaluateExpression(StaticTypeCheckingSupport.java:1369)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallArguments(StaticTypeCheckingVisitor.java:1837)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2186)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:220)
        at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1359)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1634)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1607)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:120)
        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:172)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:110)
        at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:60)
        at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
        at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:506)
        at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:59)
        at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:215)
        at org.codehaus.groovy.ant.Groovyc.runCompiler(Groovyc.java:1103)
        at org.codehaus.groovy.ant.Groovyc.compile(Groovyc.java:1154)
        at org.codehaus.groovy.ant.Groovyc.execute(Groovyc.java:769)
        at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)
        at org.apache.tools.ant.Task.perform(Task.java:348)
        at org.apache.tools.ant.Target.execute(Target.java:390)
        at org.apache.tools.ant.Target.performTasks(Target.java:411)
        at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)
        at org.apache.tools.ant.Project.executeTarget(Project.java:1368)
        at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)
        at org.apache.tools.ant.Project.executeTargets(Project.java:1251)
        at org.apache.tools.ant.Main.runBuild(Main.java:809)
        at org.apache.tools.ant.Main.startAnt(Main.java:217)
        at org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)
        at org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)
Caused by: java.lang.ClassNotFoundException: groovy.lang.GroovyObject
        at java.net.URLClassLoader$1.run(URLClassLoader.java:366)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:423)
        at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:648)
        at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:758)
        at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:746)
        ... 56 more
{code}","Windows 7, Java 6, Ant 1.8.2, Groovy 2.1.4",bborchardt,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/Jun/13 16:19;bborchardt;DelegatesToTest.zip;https://issues.apache.org/jira/secure/attachment/12722947/DelegatesToTest.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 07 12:43:50 UTC 2013,,,,,,,,,,"0|i2cjwv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"07/Jun/13 07:46;melix;As a workaround, you can use:
{code:xml}
        <groovyc destdir=""${classes.dir}""
                 srcdir=""${src.dir}""
                 classpathref=""groovy.path""
                 fork=""true"" includeAntRuntime=""false"">
{code};;;","07/Jun/13 09:24;melix;I pushed a fix for this, if you can give it a try, it would be great!;;;","07/Jun/13 12:43;bborchardt;Would love to use fork=""true"", but unfortunately the groovyc task seems to fail with long classpaths when forking so that doesn't work for our project.

Just tried the latest snapshot and the error went away.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic class throws runtime errors accessing outer class methods inside nested closures,GROOVY-6199,12818244,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,bborchardt,bborchardt,06/Jun/13 14:07,14/Oct/13 16:53,14/Jul/23 06:01,20/Aug/13 02:38,2.1.4,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Static compilation,,,,0,,,,,,,"The following class throws an exception at runtime when executed. It works fine without @CompileStatic.
{code}
@groovy.transform.CompileStatic
class MyClass {
    public static void main(String[] args) {
        new MyClass().run()
    }

    void run() {
        1.times {
            1.times {
                myMethod()
            }
        }
    }

    void myMethod() {
        println 'hi'
    }
}
{code}
{color:red}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'MyClass$_run_closure1@4cf92ef9' with class 'MyClass$_run_closure1' to class 'MyClass'

	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:360)

	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:599)

	at MyClass$_run_closure1_closure2.doCall(ConsoleScript0:10)

	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)

	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)

	at java.lang.reflect.Method.invoke(Method.java:601)

	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)

	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)

	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)

	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)

	at groovy.lang.Closure.call(Closure.java:411)

	at groovy.lang.Closure.call(Closure.java:427)

	at org.codehaus.groovy.runtime.DefaultGroovyMethods.times(DefaultGroovyMethods.java:10646)

	at MyClass$_run_closure1.doCall(ConsoleScript0:9)

	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)

	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)

	at java.lang.reflect.Method.invoke(Method.java:601)

	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)

	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)

	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)

	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)

	at groovy.lang.Closure.call(Closure.java:411)

	at groovy.lang.Closure.call(Closure.java:427)

	at org.codehaus.groovy.runtime.DefaultGroovyMethods.times(DefaultGroovyMethods.java:10646)

	at MyClass.run(ConsoleScript0:8)

	at MyClass.main(ConsoleScript0:4)

	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)

	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)

	at java.lang.reflect.Method.invoke(Method.java:601)

	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)

	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)

	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1318)

	at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:822)
{color}","Windows 7, Java 6, Groovy 2.1.4",bborchardt,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 20 02:38:24 UTC 2013,,,,,,,,,,"0|i2cqx3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Aug/13 02:38;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Get wrong result using XXX Assign operator on byte array,GROOVY-6197,12816995,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lusxiao,lusxiao,05/Jun/13 08:11,10/Jul/13 04:42,14/Jul/23 06:01,02/Jul/13 04:38,2.0.7,2.1.3,2.1.4,,,,,,,,,,,,,,,2.1.6,,,,class generator,,,,0,,,,,,,"Run this script:

	byte[] b = new byte[1]
	b[0] = 16
	b[0] |= 2
	println b[0]

Got result: 16
Right result is 18

This bug only occurs when using xxx Assign operator, e.g. |=, += , -=.
And Int array works fine.","Groovy lib 2.1.3
jdk 1.7",lusxiao,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-06-05 08:11:54.0,,,,,,,,,,"0|i2ct7j:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy compiler throws ArrayIndexOutOfBoundsException when combining @CompileStatic with @ToString/@EqualsAndHashCode with certain property names,GROOVY-6196,12818242,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,bborchardt,bborchardt,04/Jun/13 17:40,14/Oct/13 16:54,14/Jul/23 06:01,09/Sep/13 08:23,2.1.4,,,,,,,,,,,,,,,,,2.1.8,2.2.0,,,Static compilation,,,,1,,,,,,,"It seems to occur when a property in the object has a name where the 2nd character is uppercase. It happens with both @ToString and @EqualsAndHashCode. Example:
{code}
@groovy.transform.CompileStatic
@groovy.transform.ToString
class MyClass {
    List<String> aList
}
{code}
{color:red}
Groovyc: java.lang.ArrayIndexOutOfBoundsException: Internal compiler error while compiling C:\myProject\src\MyClass.groovy
Method: MethodNode@781552568[java.lang.String toString()]
Line -1, expecting casting to java.lang.Object but operand stack is empty
	at org.codehaus.groovy.classgen.asm.OperandStack.doConvertAndCast(OperandStack.java:327)
	at org.codehaus.groovy.classgen.asm.OperandStack.doGroovyCast(OperandStack.java:294)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.loadArguments(StaticInvocationWriter.java:271)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeDirectMethodCall(StaticInvocationWriter.java:136)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeDirectCall(InvocationWriter.java:228)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:326)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:76)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.makeCall(StaticInvocationWriter.java:445)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:60)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:382)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeInvokeMethod(StaticInvocationWriter.java:90)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:650)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.transform.sc.transformers.BooleanExpressionTransformer$OptimizingBooleanExpression.visit(BooleanExpressionTransformer.java:95)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeIfElse(StatementWriter.java:279)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitIfElse(AsmClassGenerator.java:473)
	at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:41)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:457)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:457)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:321)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:278)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:398)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$15.call(CompilationUnit.java:794)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
{color}","Windows 7, Java 6, Groovy 2.1.4",acourtneybrown,bborchardt,blackdrag,gcadien,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 09 08:23:22 UTC 2013,,,,,,,,,,"0|i2cs3r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jul/13 06:44;blackdrag;from a short look I can tell the following: there is a *dynamic* method call to getaList. With dynamic I mean that there is no set target for this. That means the invocation writer fails to make the direct method call and falls back to calling makeCallSite, which is empty in the static invocation writer. The result is that no value is placed on the stack, resulting in the operend stack related exception seen above.;;;","09/Sep/13 08:23;blackdrag;fixed by correcting the way property names are build;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Use of overloaded methods with empty/varags parameters fails if type checking is active,GROOVY-6195,12818240,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,bborchardt,bborchardt,04/Jun/13 17:20,14/Jun/13 05:10,14/Jul/23 06:01,07/Jun/13 11:01,2.1.4,,,,,,,,,,,,,,,,,2.1.5,,,,Static compilation,Static Type Checker,,,0,,,,,,,"Example 1:
{code}
@groovy.transform.CompileStatic
class MyClass {
    public static void main(String[] args) {
        def list = ['a', 'b', 'c']
        Object[] arr = list.toArray()
        println arr
    }
}
{code}
{color:red} 
Groovyc: [Static type checking] - Reference to method is ambiguous. Cannot choose between [java.lang.Object <T>[] java.util.List <E extends java.lang.Object>#toArray(java.lang.Object <T>[]), java.lang.Object[] java.util.List <E extends java.lang.Object>#toArray()]
{color}

Example 2:
{code}
@CompileStatic
class JavaFxApp extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        Group root = new Group();
        root.getChildren().add(new Label('Hello World'));
        primaryStage.setScene(new Scene(root));
        primaryStage.show();
    }
}
{code}
{color:red}
Groovyc: [Static type checking] - Reference to method is ambiguous. Cannot choose between [void javafx.scene.Group#<init>(javafx.scene.Node[]), void javafx.scene.Group#<init>()]
{color}","Windows 7, Java 6, Groovy 2.1.4",bborchardt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-06-04 17:20:54.0,,,,,,,,,,"0|i2bvxj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Exclusive range operation results in wrong result with negative index,GROOVY-6194,12816897,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,paulk,russel,russel,04/Jun/13 03:22,14/Oct/13 16:53,14/Jul/23 06:01,18/Sep/13 07:52,,,,,,,,,,,,,,,,,,2.2.0-rc-1,,,,,,,,0,breaking,,,,,,"The script:
{code}
final a = [1, 2, 3, 4]
assert a[-3..-2] == [2, 3]
assert a[-3..<-2] == [2]
assert a[2..-3] == [3, 2]
assert a[1..-1] == [2, 3, 4]
assert a[1..<-1] == [2, 3]
{code}
when executed, results in:
{noformat}
Caught: Assertion failed: 

assert a[1..<-1] == [2, 3]
       ||        |
       |[2, 1]   false
       [1, 2, 3, 4]

Assertion failed: 

assert a[1..<-1] == [2, 3]
       ||        |
       |[2, 1]   false
       [1, 2, 3, 4]

	at rangeSpecs.run(rangeSpecs.groovy:8)
{noformat}
I do not understand the last result here, i.e. that the wrong result happens.",,paulk,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 18 07:54:30 UTC 2013,,,,,,,,,,"0|i2bwtj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Jun/13 18:03;paulk;Just to flesh out possible further inconsistencies, what would you expect from:
{code}
a[-2..<1]
{code}
It currently doesn't equal what you get from this:
{code}
a[-2..<-3]
{code}
The current formula in {{DefaultGroovyMethodsSupport#subListBorders}} is using {{range.isReverse()}} in the calculation which I suspect we cannot use.;;;","05/Jun/13 00:01;paulk;My suspicion is that {{DefaultGroovyMethodsSupport#subListBorders}} should use {{boolean reverse = from > to;}} and not use the ""guessed"" value of reverse from the original range object.;;;","09/Jun/13 21:50;paulk;My suspicion was only partially accurate. It turns out that the Range abstraction when dealing with inclusive/exclusive and negative index values is a lossy abstraction. There simply isn't enough information retained in the current implementation to deduce the correct values. Here is a spike which would correct the problem:

https://github.com/paulk-asert/groovy-core/commit/20f7f4cee

Why is it a spike? I haven't added tests or removed the ""legacy"" implementation in several places. We should discuss if everyone is happy with this breaking change first. After this change, the following script runs successfully:
{code}
final a = [1, 2, 3, 4]
assert a[-3..-2] == [2, 3]
assert a[-3..<-2] == [2]
assert a[2..-3] == [3, 2]
assert a[1..-1] == [2, 3, 4]
assert a[1..<-1] == [2, 3]
assert a[-2..<1] == [3]
assert a[-2..<-3] == [3]
{code}
;;;","18/Sep/13 07:54;paulk;Flagging as a breaking change - though it really is only the broken cases which have changed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@EqualsAndHashCode override not working when used with @Immutable if @Immutable appears first,GROOVY-6192,12816909,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,jwagenleitner,jwagenleitner,02/Jun/13 22:24,14/Jun/13 05:10,14/Jul/23 06:01,03/Jun/13 04:31,2.1.4,,,,,,,,,,,,,,,,,2.1.5,2.2.0-beta-1,,,ast builder,,,,0,,,,,,,"I am using the @Immutable annotation and need to customize the @EqualsAndHashCode fields.  If the @Immutable annotation appears first it doesn't work.  However, if I place @EqualsAndHashCode first it works.

@Canonical works correctly regardless of what order the annotations appear.

{code}
import groovy.transform.*

@EqualsAndHashCode(includes = ['id'])
@Immutable
class A {
    String id
    String name
}

@Immutable
@EqualsAndHashCode(includes = ['id'])
class B {
    String id
    String name
}

def a1 = new A('1', 'foo')
def a2 = new A('1', 'foo2')

assert a1.equals(a2)
assert a2.equals(a1)

def b1 = new B('1', 'foo')
def b2 = new B('1', 'foo2')

assert b1.equals(b2)  // fails
assert b2.equals(b1)  // fails
{code}",Groovy Version: 2.1.4 JVM: 1.7.0_11 Vendor: Oracle Corporation OS: Linux,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 03 04:31:38 UTC 2013,,,,,,,,,,"0|i2c8in:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"02/Jun/13 23:30;jwagenleitner;Added a pull request, https://github.com/groovy/groovy-core/pull/202.;;;","03/Jun/13 04:31;paulk;Thanks, pull request applied.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Memory leak in GroovyScriptEngineImpl,GROOVY-6191,12817019,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,enterit,enterit,31/May/13 09:54,15/Oct/15 18:20,14/Jul/23 06:01,18/Nov/13 06:57,2.1.3,,,,,,,,,,,,,,,,,2.2.1,,,,,,,,2,,,,,,,"Previously evaluation of the same script (but different String instances) led to reading script class from cache, now if different String instances are used for script text, the value is not found in cache, so that script engine compiles the same script again and adds new Class instance to the classMap.

This leads to inefficient caching, and also may cause memory leak.

Please consider the following code sample:
{code}
  e = new org.codehaus.groovy.jsr223.GroovyScriptEngineImpl()
  println e.eval('System.identityHashCode(this.getClass())')
  println e.eval('System.identityHashCode(this.getClass())')
  println e.eval(new String('System.identityHashCode(this.getClass())'))
{code}

In groovy 1.7 it produced 3 identical lines in output.
In groovy 2.1.3 the third line differs from previous two.",,blackdrag,enterit,jhuxhorn,milindvijayshah,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 18 06:57:40 UTC 2013,,,,,,,,,,"0|i2c1fj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Oct/13 12:42;pschumacher;@blackdrag: Maybe you can comment on this issue?;;;","14/Nov/13 12:40;milindvijayshah;Hi, We are facing out of memeory issue on production server. when we analyze the heapdump we found that ManagedConcurrentMap occupied 45% heap and while looking into this issue, we found that its due to hard refereneces inside the ManagedConcurrentMap. can you please let us know in which version we can have fix for this issue. we need to restart the production server on weekly basis becuase of this.

you can found more details on this bugs at below location : 

http://groovy.329449.n5.nabble.com/memory-leak-in-GroovyScriptEngineImpl-td5715613.html
;;;","14/Nov/13 13:18;huxi;Shouldn't this be fixable by simple replacing {{int h = System.identityHashCode(key);}} at https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/util/AbstractConcurrentMapBase.java#L54 with {{int h = key == null? 0 : key.hashCode();}}

It must be more complex than that...;;;","14/Nov/13 16:59;blackdrag;Joern... I looked at that line... and I can not tell anymore why Alex made that change back then. He had key.hashCode() before. Could it really be that easy?
;;;","14/Nov/13 17:17;huxi;I don't know where else that class is used. Maybe it was some kind of performance enhancement {{String.hashCode()}} is likely slower than {{System.identityHashCode(..)}}, at least during first call on big Strings.

I wanted to suggest extending {{ManagedConcurrentMap}} for this use case (just to avoid side effects) and overriding hash(K key) - but it's static. :(

Using {{identityHashCode}} seems highly counter-intuitive to me... and this gives me even more ""there must be a good reason"" vibes. But it's definitely wrong in this case.;;;","15/Nov/13 06:05;blackdrag;I guess performance was the reason indeed. One reason I did no change so far is also that this data structure is not so easy to extend.

I wonder if I should not change the map in https://github.com/groovy/groovy-core/blob/master/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java#L96 to a ManagedConcurrentValueMap, like in line 99, but with softreferences of course.;;;","15/Nov/13 06:06;blackdrag;As for ManagedConcurrentMap... the meta class structure is using this map, so I think simply changing that line is not good enough;;;","15/Nov/13 09:49;blackdrag;I checked a bit the history and it seems this bug is at lest no regression. There are actually two maps in this, one for ""global"" closures, the other the class cache. GROOVY-5706 and GROOVY-5786 have been made to change that map. And now it is the other. ;;;","18/Nov/13 06:57;blackdrag;I changed the map type;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java8 lambda style coercion for Closure,GROOVY-6188,12817025,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,30/May/13 09:21,25/Nov/13 05:21,14/Jul/23 06:01,25/Nov/13 05:21,3.0.0-alpha-1,,,,,,,,,,,,,,,,,2.2.0,,,,,,,,0,,,,,,,see http://docs.codehaus.org/display/GroovyJSR/GEP+12+-+SAM+coercion,,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-05-30 09:21:47.0,,,,,,,,,,"0|i2br0f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyResultSet Proxy not working with Object methods,GROOVY-6187,12818523,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,paulk,,30/May/13 06:03,29/Nov/16 20:33,14/Jul/23 06:01,26/Jun/13 17:17,1.8.9,2.0.8,2.1.3,,,,,,,,,,,,,,,2.1.5,,,,SQL processing,,,,0,,,,,,,"When using eachRow the following works fine (as do calls through getAt etc. or getMetaClass()):
{code}
sql.eachRow(""select * from PERSON"") { println it }
{code}
but accessing the methods from Object or DGM methods like dump() fail. All these fail:
{code}
sql.eachRow(""select * from PERSON"") { println it.getClass() }
sql.eachRow(""select * from PERSON"") { println it.toString() }
sql.eachRow(""select * from PERSON"") { println it.dump() }
sql.eachRow(""select * from PERSON"") { println it.hashCode() }
{code}
with messages like:
{noformat}
groovy.lang.MissingMethodException: No signature of method: groovy.sql.GroovyResultSet.toString() is applicable for argument types: () values: []
Possible solutions: toString(), toString(), notify()
{noformat}
",,blackdrag,guspower,hubbitus,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 29 20:33:07 UTC 2016,,,,,,,,,,"0|i2cml3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jun/13 00:33;paulk;Hmmm, some code that used to work fine in 2.1.3 now produces:
{noformat}
groovy.lang.MissingMethodException: No signature of method: groovy.sql.GroovyResultSetProxy$DummyResultSet.toRowResult() is applicable for argument types: () values: []
{noformat}
The {{toRowResult}} in {{SqlGroovyMethods}} is defined for {{ResultSet}} which {{DummyResultSet}} implements but only indirectly.;;;","26/Jun/13 17:17;paulk;The code changes for this fix were in 2.1.4 but it didn't work in all scenarios until the 2.1.5 packaging bug (GROOVY-6205) was fixed.;;;","29/Nov/16 19:54;guspower;I've just seen this resurface in 2.4.3. Curiously it only occurs when I'm running from a shadowJar rather than from a gradle task. I can create a sample project if that'd help?;;;","29/Nov/16 20:26;blackdrag;does that mean you put the groovy runtime into a different package?;;;","29/Nov/16 20:33;guspower;No I used the gradle shadowJar plugin - https://github.com/johnrengelman/shadow - to create an uber jar, I didn't shade the packages.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Cannot invoke method next() on varible, which is initialized by default, in each\eachWithIndex",GROOVY-6186,12818239,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,aievdokimov,aievdokimov,30/May/13 04:49,15/Oct/15 18:20,14/Jul/23 06:01,26/Nov/13 06:29,2.1.3,,,,,,,,,,,,,,,,,2.2.1,,,,primtive opts,,,,0,,,,,,,"The following code throws java.lang.NullPointerException: Cannot invoke method next() on null object
{code}
int x 
[1..10].each{
x++
}
{code}
Expected result:
X should be increased in each step. 

Stacktrace for code:
java.lang.NullPointerException: Cannot invoke method next() on null object

	at org.codehaus.groovy.runtime.NullObject.invokeMethod(NullObject.java:77)

	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:45)

	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)

	at org.codehaus.groovy.runtime.callsite.NullCallSite.call(NullCallSite.java:32)

	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)

	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)

	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)

	at ConsoleScript18$_run_closure1.doCall(ConsoleScript18:3)

	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)

	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)

	at java.lang.reflect.Method.invoke(Method.java:597)

	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)

	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)

	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)

	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)

	at groovy.lang.Closure.call(Closure.java:411)

	at groovy.lang.Closure.call(Closure.java:427)

	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1325)

	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1297)

	at org.codehaus.groovy.runtime.dgm$148.invoke(Unknown Source)

	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:271)

	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:53)

	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)

	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)

	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)

	at ConsoleScript18.run(ConsoleScript18:2)

	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:257)

	at groovy.lang.GroovyShell.run(GroovyShell.java:481)

	at groovy.lang.GroovyShell.run(GroovyShell.java:163)

	at groovy.lang.GroovyShell$run.call(Unknown Source)

	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:951)

	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)

	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)

	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)

	at java.lang.reflect.Method.invoke(Method.java:597)

	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)

	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)

	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)

	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)

	at groovy.lang.Closure.call(Closure.java:411)

	at groovy.lang.Closure.call(Closure.java:405)

	at groovy.lang.Closure.run(Closure.java:492)

	at java.lang.Thread.run(Thread.java:662)

java.lang.NullPointerException: Cannot invoke method next() on null object

	at ConsoleScript18$_run_closure1.doCall(ConsoleScript18:3)

	at ConsoleScript18.run(ConsoleScript18:2)",,aievdokimov,blackdrag,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 26 06:29:57 UTC 2013,,,,,,,,,,"0|i2cjb3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Aug/13 05:06;pschumacher;@blackdrag: Should this work?;;;","10/Aug/13 05:44;blackdrag;since it is an int, yes. the compiler wrongly treats it as Integer, since it is put in a reference for the closure. Even if it is closure shared, it needs to be initialized with 0;;;","26/Nov/13 06:29;blackdrag;will now cause a cast exception on declaration;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Errors with static attribute expression,GROOVY-6183,12816904,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,28/May/13 11:12,01/Jun/13 06:11,14/Jul/23 06:01,29/May/13 03:35,2.1.3,,,,,,,,,,,,,,,,,2.1.4,,,,,,,,0,,,,,,,"The following code triggers an {{InvalidClassChangeError}}:

{code}
class A {
   static boolean setterCalled = false

   static protected int x

   public static void setX(int a) {
      setterCalled = true
      x = a
   }
}

class B extends A {
   static void directAccess() {
      this.@x = 2
   }
}
B.directAccess()
assert B.isSetterCalled() == false
assert B.x == 2
{code}

While this one will trigger an internal compiler error

{code}
class A {
   static protected int x
   public static void reset() { this.@x = 2 }
}
{code}

{noformat}BUG! exception in phase 'class generation' in source unit 'ConsoleScript1' Error while popping argument from operand stack tracker in class A method void reset().{noformat}
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6162,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-05-28 11:12:07.0,,,,,,,,,,"0|i2chmf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker skip mode not always applied to anonymous inner classes,GROOVY-6180,12816975,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,28/May/13 07:57,30/Aug/16 01:43,14/Jul/23 06:01,28/May/13 08:03,,,,,,,,,,,,,,,,,,2.1.4,,,,Static Type Checker,,,,0,,,,,,,"In some circumstances, the type checker would try to statically compile anonymous inner class nodes even if the enclosing method is skipped.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-05-28 07:57:12.0,,,,,,,,,,"0|i2csnb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sublist can be modified by parent list operations,GROOVY-6179,12816967,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,asteingress,asteingress,asteingress,28/May/13 07:02,14/Oct/13 16:53,14/Jul/23 06:01,18/Jul/13 13:52,1.8.9,2.0.8,2.1.3,,,,,,,,,,,,,,,2.2.0-beta-2,,,,groovy-jdk,,,,0,,,,,,,"{code}
List listA = [0, 1, 2] // .withDefault{ 42 }
def listB = listA[1..2]
listA[1] = 5
assert listB == [5, 2]
{code}

The last line shows the sublist being modified by the assignment to index 1 of the parent list. 

This is caused by the internal use of the ArrayList#subList method. The JavaDoc states that

??The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list.??",,asteingress,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6177,GROOVY-6152,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 05 01:34:58 UTC 2013,,,,,,,,,,"0|i2bnvr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/May/13 15:59;paulk;It affects both directions actually. Just one example:
{code}
def list = [1, 3.4, ""foo""]//.withDefault{ 42 }
def sub = list[0..1]
sub[3] = 42
assert sub == [1, 3.4, null, 42]
assert list == [1, 3.4, null, 42, ""foo""]
{code}
;;;","31/May/13 00:54;asteingress;I'll take over this issue if this is ok to you, Paul.;;;","05/Jun/13 01:34;asteingress;Here is the PR: https://github.com/groovy/groovy-core/pull/205;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
List substraction doesn't work correctly with objects that have the same hash code,GROOVY-6176,12817012,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,mikle314,mikle314,28/May/13 00:58,08/Mar/22 12:16,14/Jul/23 06:01,17/Jan/22 20:16,2.1.1,2.1.3,,,,,,,,,,,,,,,,,,,,groovy-runtime,,,,0,,,,,,,"During list substraction groovy removes elements with the same hash code. But it has to remove equal elements. (It is obviously that sometimes non equal elements can have the same hash code)
{code}
class MyClass {
 int value = 0
 boolean equals(o) {
  if (o instanceof MyClass && value == o.value) return true
  return false
 }
 int hashCode() {
  return 1
 }
}

def o1 = new MyClass(value:1)
def o2 = new MyClass(value:2)
def o3 = new MyClass(value:3)
def list = [o1, o2]
def result = list - [o3]
assert result == [] // it looks strange, I think
{code}
",,emilles,mikle314,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 17 20:16:12 UTC 2022,,,,,,,,,,"0|i2c35z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/May/13 06:05;paulk;add code tags;;;","28/May/13 06:14;paulk;The workaround is for your class to implement {{Comparable}} and provide a compareTo method, e.g.:
{code}
int compareTo(Object other) { value.compareTo(other.value) }
{code};;;","17/Jan/22 20:16;emilles;Works fine in Groovy 2.5+;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
invoking Closure property like method fails because of doCall/call asynchronity,GROOVY-6175,12817009,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,blackdrag,blackdrag,27/May/13 09:21,01/Feb/17 23:18,14/Jul/23 06:01,24/Nov/16 06:19,,,,,,,,,,,,,,,,,,2.4.8,,,,groovy-runtime,,,,0,,,,,,,"In this code:{code:Java}
class Lol {
    def clo = {
        println ""arg $it""
    }.memoize()
}
{code}
a new Lol().clo(""my arg"") fails, even though it should work. Looking at the error message it can be seen, that the runtime tries to do a doCall, while the MemoizeFunction that is stored in clo does not have that method (instead it overrides call(Object[])). Looking at MetaClassImpl you can find the following piece of code around line 1121:{code:Java}
        if (value instanceof Closure) {  // This test ensures that value != this If you ever change this ensure that value != this
            Closure closure = (Closure) value;
            MetaClass delegateMetaClass = closure.getMetaClass();
            return delegateMetaClass.invokeMethod(closure.getClass(), closure, CLOSURE_DO_CALL_METHOD, originalArguments, false, fromInsideClass);
        }
{code}
That code clearly tries to do doCall, instead of call. It is to be assumed that code following this does not check for both variants equally.

Proposed fix: use call instead of doCall",,blackdrag,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8003,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 24 05:18:29 UTC 2016,,,,,,,,,,"0|i2ctun:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Nov/16 04:44;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/462

    GROOVY-6175: invoking Closure property like method fails because of doCall

    Per the Closure class docs, to be able to use a Closure in short form, e.g., c(), in subclasses, you need to provide a doCall method with any signature you want to. This ensures that getMaximumNumberOfParameters() and getParameterTypes() will work too without any additional code. If no doCall method is provided a closure must be used in its long form, e.g., c.call().

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-6175

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/462.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #462
    
----
commit 76cffc9bab8825389258034cc0c231603ebe619e
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-11-22T03:54:10Z

    GROOVY-6175: invoking Closure property like method fails because of doCall/call asynchronity
    
    Per the Closure class docs, to be able to use a Closure in short form, e.g., c(), in subclasses, you need to provide a doCall method with any signature you want to. This ensures that getMaximumNumberOfParameters() and getParameterTypes() will work too without any additional code. If no doCall method is provided a closure must be used in its long form, e.g., c.call().

----
;;;","24/Nov/16 05:18;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/462
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy support of class inner enums is strange,GROOVY-6174,12818241,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,hubbitus,hubbitus,27/May/13 08:50,02/May/17 02:03,14/Jul/23 06:01,25/Aug/16 07:05,2.1.3,,,,,,,,,,,,,,,,,,,,,Compiler,,,,0,,,,,,,"pack.MyClassWithEnumPack.groovy:
{code}
package pack

class MyClassWithEnumPack {
	public static enum MyEnum{ ONE, TWO, THREE }

	def static howdy() {
		println 'Howdy'
	}
}
{code}

enum-test.groovy:
{code}
import pack.MyClassWithEnumPack

// http://testinfected.blogspot.ru/2008/01/dry-groovy-how-to-get-groovy-to-import.html
new MyClassWithEnumPack().howdy()

MyClassWithEnumPack.MyEnum t;
println t;
{code}

Fails to run:
{code}
[pasha@hubbitus testpackage]$ groovy ./enum-test.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/home/pasha/imus/imus-tools.GIT/testpackage/enum-test.groovy: 8: unable to resolve class MyClassWithEnumPack.MyEnum 
 @ line 8, column 28.
   MyClassWithEnumPack.MyEnum t;
                              ^

1 error
{code}

What very interesting, groovy really known about that enum, because code:
{code}
import pack.MyClassWithEnumPack

println MyClassWithEnumPack.MyEnum.ONE;
{code}
Works!

What even more interesting, it is compile time issue. If I comment out using of inner enum:
{code}
import pack.MyClassWithEnumPack

//MyClassWithEnumPack.MyEnum t;
//println t;
{code}

Then run compile:
{code}
$ groovyc ./enum-test.groovy
{code}

And then run initial variant:
{code}
$ groovy ./enum-test.groovy
{code}
it then works as expected and because there file pack/MyClassWithEnumPack$MyEnum.class present.",,hubbitus,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 25 07:05:31 UTC 2016,,,,,,,,,,"0|i2c8q7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Aug/16 07:05;paulk;This seems to be fixed on recent versions of Groovy. Please reopen if you have further problems.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Memory tweaks for groovy compiler,GROOVY-6171,12817005,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,werdna,werdna,24/May/13 17:12,01/Jun/13 06:11,14/Jul/23 06:01,29/May/13 06:52,,,,,,,,,,,,,,,,,,2.1.4,2.2.0-beta-1,,,Compiler,,,,0,,,,,,,"I've been doing some profiling of Groovy-Eclipse and I found a few things you should be aware of in the Groovy compiler:

# org.codehaus.groovy.classgen.asm.ClosureWriter.UseExistingReference should be a static interface.  As it is now, every reference to {{UseExistingReference.class}} will have a back pointer to an instance of {{ClosureWritier}}.  Making the interface static will avoid that back reference.
# The {{org.codehaus.groovy.ast.ASTNode.metaDataMap}} field should be lazily initiailzed.  And when it is initialized, it should be done with a smaller initial size.  This field is taking up massive amounts of space in my profile and it is mostly and empty field.

These two changes would cause massive memory savings in Groovy-Eclipse.  We have already implemeted #2 and have seen a big benefit.",,blackdrag,guillaume,melix,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 29 06:52:40 UTC 2013,,,,,,,,,,"0|i2c507:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/May/13 14:49;guillaume;Hi Andrew! What about making pull requests of those enhancements so we can have a closer look at the proposed changes? (and also to avoid increasing the number of patches on your side as well :-);;;","27/May/13 00:07;werdna;Done.  See https://github.com/groovy/groovy-core/pull/197;;;","27/May/13 08:41;blackdrag;Andrew, how many ListHashMap instances do you have active in those profiling sessions?;;;","27/May/13 10:43;werdna;Depending on which projects are open, somewhere on the order of 80,000.

Groovy-Eclipse caches ModuleNodes where possible.  They shouldn't be calculated unless something has changed.;;;","27/May/13 11:56;blackdrag;So the magnitude of what the enhancements will give are less than 5MB?;;;","27/May/13 13:03;werdna;Actually, that's not correct.  The number is 80,000 ClassNodes.  And each ClassNode has a full AST below it, so a ballpark is around 500,000 ASTNodes.  Not only is it the memory, but also the extra initialization time of creating these empty maps that are not used.;;;","28/May/13 04:18;blackdrag;That's why I asked for the number of ListHashMap instances ;) 500k is of course an entire different number than 80k... still I would expect no more than 100MB being used by that. On the other hand you are of course right with the object creation taking time, that is not really needed. So I see this more as an speed improvement than one for memory, though it is  very rare that you can save on both. Anyway... +1 for the change, now that the magnitude is more clear to me.;;;","29/May/13 05:28;melix;Tested the pull request, everything looks fine, but I would suggest to only put the improvement into {{master}}, what do you think?;;;","29/May/13 06:52;melix;After discussions with the team, we agreed to introduce the improvement in both {{master}} and {{2_1_X}} branches.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Generics: within a single declaration, generic type definition order matters",GROOVY-6167,12816977,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,davide.cavestro,davide.cavestro,23/May/13 07:07,26/Jul/18 04:38,14/Jul/23 06:01,17/May/18 16:57,2.1.0,2.4.0-beta-3,,,,,,,,,,,,,,,,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,,Compiler,,,,2,,,,,,,"The following is valid Java code, but the groovyc fails complaining
{color:red}_unable to resolve class X_
{color}
{code:java}
public class Foo<T extends List<X>, X extends Number>{}
{code}
while changing the generic type definition order it works
{code:java}
public class Foo<X extends Number, T extends List<X>>{}
{code}
",,daniel_sun,davide.cavestro,mauromol,nithril,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 17 16:57:10 UTC 2018,,,,,,,,,,"0|i2cqhr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Sep/14 16:03;pschumacher;Still does not work on current master.;;;","17/May/18 16:57;daniel_sun;Fixed by 
 [https://github.com/apache/groovy/commit/0f187102660593d9d95d486ba4b62f5091cc4580]
 [https://github.com/apache/groovy/commit/48807d5b1ba094e2f0dc212b6c92b4b370fe8394]
https://github.com/apache/groovy/commit/3ff3111fc033bf74ecdbbc4f69e0fc0f76fbdf26;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE when mixing anonymous inner class and generics,GROOVY-6166,12816972,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,guillaume,guillaume,22/May/13 09:18,17/Dec/14 13:25,14/Jul/23 06:01,03/Sep/14 16:02,,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,,Compiler,,,,0,,,,,,,"{code}
class Handler<T> { void handle(T t) {} }

public <T> Handler handler(Class<T> type, Closure<?> configurer) {
    new Handler() {
        void handle(T object) {}
    }
}

handler(String) {}
{code}

throws:

{code}
java.lang.NullPointerException
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:332)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:362)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:172)
	at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:93)
	at java.beans.FeatureDescriptor.getParameterTypes(FeatureDescriptor.java:387)
	at java.beans.MethodDescriptor.setMethod(MethodDescriptor.java:114)
	at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:72)
	at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:56)
	at java.beans.Introspector.getTargetMethodInfo(Introspector.java:1131)
	at java.beans.Introspector.getBeanInfo(Introspector.java:414)
	at java.beans.Introspector.getBeanInfo(Introspector.java:161)
	at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:3015)
	at java.security.AccessController.doPrivileged(Native Method)
	at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:3013)
	at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:2996)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:176)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:192)
	at bugAicGenerics$1.$getStaticMetaClass(bugAicGenerics.groovy)
	at Handler.<init>(bugAicGenerics.groovy)
	at bugAicGenerics$1.<init>(bugAicGenerics.groovy)
	at bugAicGenerics.handler(bugAicGenerics.groovy:4)
	at bugAicGenerics$handler.callCurrent(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:145)
	at bugAicGenerics.run(bugAicGenerics.groovy:9)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:257)
	at groovy.lang.GroovyShell.run(GroovyShell.java:220)
	at groovy.lang.GroovyShell.run(GroovyShell.java:150)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:588)
	at groovy.ui.GroovyMain.run(GroovyMain.java:375)
	at groovy.ui.GroovyMain.process(GroovyMain.java:361)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:120)
	at groovy.ui.GroovyMain.main(GroovyMain.java:100)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
{code}",,guillaume,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 03 16:02:20 UTC 2014,,,,,,,,,,"0|i2bwon:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Sep/14 16:02;pschumacher;Works on current master, so I'm closing this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Incorrect property lookup if a method starts with ""get""",GROOVY-6165,12816961,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,22/May/13 08:24,01/Jun/13 06:11,14/Jul/23 06:01,23/May/13 03:22,,,,,,,,,,,,,,,,,,2.1.4,,,,,,,,0,,,,,,,"{code}
import groovy.transform.*

@TupleConstructor
class Person { String name }

public <T> List<T> names(
    @DelegatesTo.Target List<T> list, 
    @DelegatesTo(genericTypeIndex = 0) Closure modify) {
        list.collect {
            modify.delegate = it
            modify()
        }
}

@CompileStatic
def test(List<Person> persons) {
    def names = names(persons) {
        getname().toUpperCase()
    }
    assert names == ['GUILLAUME', 'CÃDRIC']
}

test([new Person('Guillaume'), new Person('CÃ©dric')])
{code}

If I make a typo in getName() method like above, I get a runtime error instead of getting a type checker compile-time error.",,guillaume,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 23 03:22:02 UTC 2013,,,,,,,,,,"0|i2c2d3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/May/13 08:28;guillaume;Actually there seems to be two distinct problems.
If you use @TypeChecked, you're getting the missing method at runtime (and not compile error).
But there's a problem with @CompileStatic as well, as I get the following odd cast error to Thread!
{code}
Exception thrown

org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'ConsoleScript44@79145bff' with class 'ConsoleScript44' to class 'java.lang.Thread'
	at ConsoleScript44$_test_closure2.doCall(ConsoleScript44)
	at ConsoleScript44$_test_closure2.doCall(ConsoleScript44)
	at ConsoleScript44$_names_closure1.doCall(ConsoleScript44:11)
	at ConsoleScript44.names(ConsoleScript44:9)
	at ConsoleScript44.test(ConsoleScript44:17)
	at ConsoleScript44$test.callCurrent(Unknown Source)
	at ConsoleScript44.run(ConsoleScript44:23)
{code};;;","23/May/13 03:22;melix;The problem wasn't with {{@DelegatesTo}} but with the way properties are looked up when you use a method starting with ""get"" or ""is"". ""getname"" produced a lookup to the ""name"" property which exists, but the ""getname"" method is not valid because there's no uppercase ""n"".;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
'this' in static context not treated as class by @CompileStatic,GROOVY-6162,12816979,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pledbrook,pledbrook,21/May/13 05:34,01/Jun/13 06:11,14/Jul/23 06:01,29/May/13 03:35,2.0.8,2.1.3,,,,,,,,,,,,,,,,2.1.4,,,,Static Type Checker,,,,0,,,,,,,"This Groovy script fails to compile:

{code}
@groovy.transform.CompileStatic
class MyClass {
    static void main(String[] args) {
        println ""Class loader: ${this.classLoader}""
    }
}

MyClass.main([] as String[])
{code}

It complains that {{MyClass}} doesn't have a {{classLoader}} property. It seems that the static type checker does not treat {{this}} correctly in the context of a static method/property/initialiser.",,pledbrook,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6183,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 28 10:14:42 UTC 2013,,,,,,,,,,"0|i2cb1j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/May/13 10:14;pledbrook;The workaround of course is to use a class literal, such as {{MyClass.classLoader}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static method  is not resolved inside anonymous class,GROOVY-6161,12816973,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,mxm-groovy,mxm,21/May/13 04:49,08/Mar/22 12:16,14/Jul/23 06:01,03/Mar/21 00:28,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,groovy-runtime,,,,0,,,,,,,"{code}
class A {
    static def foo() {
        print ""foo""
    }

    public static void main(String[] args) {
        new Runnable() {
            void run() {
                new Runnable() {
                    void run() {
                        foo()  //foo() is not resolved
                    }
                }.run()
            }
        }.run()
    }
}
{code}",,mxm,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-05-21 04:49:06.0,,,,,,,,,,"0|i2cpvb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missing directory entries in groovy-all JAR,GROOVY-6158,12816966,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,kapy,kapy,20/May/13 03:49,01/Jun/13 06:11,14/Jul/23 06:01,22/May/13 23:35,2.1.3,,,,,,,,,,,,,,,,,2.1.4,2.2.0-beta-1,,,,,,,0,,,,,,,"When:

Checking groovy-all jar content via any zip tool.

I expect:

{code}
groovy/beans
groovy/beans/Bindable.class
...
{code}

I get:

{code}
groovy/beans/Bindable.class
...
{code}

e.g, all entries for directories are not packaged in the jar. This causes a problem while trying to get groovy resources from classpath:

http://bugs.sun.com/view_bug.do?bug_id=4761949


In particular, it breaks Spock integration with Arquillian:

https://issues.jboss.org/browse/ARQ-1143",,kapy,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 22 23:35:49 UTC 2013,,,,,,,,,,"0|i2bwfr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/May/13 06:05;kapy;Pull request sent here: https://github.com/groovy/groovy-core/pull/189;;;","22/May/13 23:35;paulk;Change applied. Thanks for the pull request!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Grapes/@Grab does not work with JDK8,GROOVY-6156,12818105,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,russel,russel,19/May/13 00:46,15/Oct/15 18:19,14/Jul/23 06:01,04/Oct/13 13:31,2.1.3,,,,,,,,,,,,,,,,,2.1.8,,,,,,,,0,,,,,,,"Groovy appears not to be able to run TestNG tests. The code:
{code}
@Grab('org.testng:testng:6.8.5')
@Grab('org.codehaus.groovy:groovy-testng:2.2.0-SNAPSHOT')
import org.testng.annotations.Test
import static org.testng.Assert.assertEquals

class testngFails {
  @Test void calculateTheResult() {
    assertEquals('Hello World.', 'Hello World.')
  }
}
{code}
when executed results in the output:
{quote}
Caught: org.testng.TestNGException: 
An error occurred while instantiating class testngFails: null
org.testng.TestNGException: 
An error occurred while instantiating class testngFails: null
	at org.testng.internal.ClassHelper.createInstance1(ClassHelper.java:398)
	at org.testng.internal.ClassHelper.createInstance(ClassHelper.java:299)
	at org.testng.internal.ClassImpl.getDefaultInstance(ClassImpl.java:110)
	at org.testng.internal.ClassImpl.getInstances(ClassImpl.java:186)
	at org.testng.internal.TestNGClassFinder.<init>(TestNGClassFinder.java:120)
	at org.testng.TestRunner.initMethods(TestRunner.java:409)
	at org.testng.TestRunner.init(TestRunner.java:235)
	at org.testng.TestRunner.init(TestRunner.java:205)
	at org.testng.TestRunner.<init>(TestRunner.java:153)
	at org.testng.SuiteRunner$DefaultTestRunnerFactory.newTestRunner(SuiteRunner.java:522)
	at org.testng.SuiteRunner.init(SuiteRunner.java:157)
	at org.testng.SuiteRunner.<init>(SuiteRunner.java:111)
	at org.testng.TestNG.createSuiteRunner(TestNG.java:1273)
	at org.testng.TestNG.createSuiteRunners(TestNG.java:1260)
	at org.testng.TestNG.runSuitesLocally(TestNG.java:1114)
	at org.testng.TestNG.run(TestNG.java:1031)
Caused by: java.lang.ExceptionInInitializerError
	at org.testng.internal.ObjectFactoryImpl.newInstance(ObjectFactoryImpl.java:29)
	at org.testng.internal.ClassHelper.createInstance1(ClassHelper.java:387)
	... 15 more
Caused by: java.lang.RuntimeException: No suitable ClassLoader found for grab
	at testngFails.<clinit>(testngFails.groovy)
	... 17 more
{quote}",,bgoetzmann,blackdrag,guillaume,melix,paulk,russel,seanf,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6279,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 08 06:25:07 UTC 2013,,,,,,,,,,"0|i2c5sv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/May/13 01:11;russel;I find that GINT does not work either so changed the title of the bug report.

The GINT script:
{code}
@GrabResolver(name='atlassian', root='https://maven.atlassian.com/content/groups/public/')
@Grab('org.swift.tools:gint:1.8.0')
import org.swift.tools.Gint

includeTool << Gint

gint.initialize(this)

//  GINT always trims the received data so the trailing newline will be removed.
expectedResult = 'Hello World.'

new File('.').listFiles([accept: {directory, name -> name.startsWith('helloWorld_') && name.endsWith('.groovy')}] as FilenameFilter).each{script ->
  gint.setCmdGenerator('groovy',  [file: script])
  gint.add(name: script, data: expectedResult)
}

gint.finalizeTest()
{code}
fails with the error:
{quote}
java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:491)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
Caused by: java.lang.ExceptionInInitializerError
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:414)
	at java.lang.Class.newInstance(Class.java:443)
	at org.codehaus.groovy.runtime.InvokerHelper.createScript(InvokerHelper.java:420)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:625)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:605)
	at groovy.lang.GroovyShell$parse.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
	at gant.Gant.loadScript(Gant.groovy:235)
	at gant.Gant$loadScript$1.callCurrent(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at gant.Gant.loadScript(Gant.groovy:268)
	at gant.Gant$loadScript$0.callCurrent(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at gant.Gant.loadScript(Gant.groovy:248)
	at gant.Gant$loadScript.callCurrent(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at gant.Gant.processArgs(Gant.groovy:536)
	at gant.Gant$processArgs.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at gant.Gant.main(Gant.groovy:668)
	... 6 more
Caused by: java.lang.RuntimeException: No suitable ClassLoader found for grab
	at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:212)
	at groovy.grape.GrapeIvy.chooseClassLoader(GrapeIvy.groovy:182)
	at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:248)
	at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:212)
	at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:237)
	at groovy.grape.Grape.grab(Grape.java:127)
	at groovy.grape.Grape$grab.callStatic(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallStatic(CallSiteArray.java:53)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:157)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:165)
	at test_all_gint.<clinit>(test_all_gint)
	... 39 more
{quote};;;","19/May/13 11:26;russel;Fails with a standard install, so not an indy artefact problem.;;;","19/May/13 16:52;paulk;Hmmm. Both scripts worked fine for me using Java 7. Are you perhaps using Java 8?;;;","20/May/13 02:33;russel;Hummm? likewise, I thought I had tried JDK8, JDK8_Lambda and JDK7 and found it failed with all three. This was wrong, JDK7 does seem to work. I have changed the title accordingly.;;;","18/Sep/13 03:22;blackdrag;There is no way to solve this of yet, since the guys at the jdk did not yet decide for a replacement for jdk8;;;","18/Sep/13 07:10;russel;I think it is not an option to say we cannot solve this if Groovy is to be used for scripting. Which method is it that is causing the problem? Is it part of a public API or an internal method someone found? I cannot believe a public API method got removed, there are deprecated methods 18 years old that have not been removed: Sun and now Oracle seem to believe public API methods should never be removed, so why mark anything as deprecated?

I have now stopped using Groovy for scripting because of this @Grab and JDK8 problem. ;;;","18/Sep/13 07:25;blackdrag;Russel, I think you didn't get my comment fully... The method that is causing the problem is sun.reflect.Reflection#getCallerClass(int). Yes, it is an internal method, and yes, we should maybe have never used it and find other ways. It is not only Groovy that has now a problem because of that, it is also for example log4j (and several other frameworks). Many alternatives have been suggested, but none of them offers the same capability. 

They promised to find a solution for this in jdk8, so we are actually waiting for them to act. It is of course unfortunate, that they did not put it back in jdk8 before that developer release even though they did know long before this is causing problems. ;;;","18/Sep/13 08:07;russel;The developer release, b106, isn't a release candidate, it is effectively beta 1. I am therefore hopeful that appropriate changes are possible. I feel a Twitter campaign coming on?;;;","18/Sep/13 08:16;guillaume;We're actually thinking of applying that patch from Cédric:
https://github.com/melix/groovy-core/commit/ab73b582f8aebfad13ffe7a032dc4ad6b1479b3c

It's a work around that we found using Security Managers.
We will likely integrate that change across all branches, and update that once JDK 8 comes up with a nicer solution (if ever).

Perhaps you could try this change, and see how (well) it works in the context of JDK 8?

Thanks for your help testing this.;;;","18/Sep/13 12:08;russel;If Cédric can check to ensure there are no conflicting changes in the interim and publish a feature branch on a Git repository, I can pull that feature branch, try things and report in.;;;","18/Sep/13 12:47;guillaume;Or simply just cherry-pick that commit!
Let's keep things simple.;;;","18/Sep/13 13:20;russel;Pulling a ready prepared feature branch is a lot more simple for me that fiddling with cherry picking.

Let's keep things simple, for the testers.;;;","04/Oct/13 12:39;russel;I pulled the latest master/HEAD and built 2.3.0-SNAPSHOT. I then ran:
{code}
@Grab('org.testng:testng:6.8.7')
@Grab('org.codehaus.groovy:groovy-testng:2.3.0-SNAPSHOT')
import org.testng.annotations.Test
import static org.testng.Assert.assertEquals

class GROOVY_6156 {
  @Test void calculateTheResult() {
    assertEquals('Hello World.', 'Hello World.')
  }
}
{code}
but got the result:
{quote}
Caught: java.lang.NoClassDefFoundError: com/google/inject/Module
java.lang.NoClassDefFoundError: com/google/inject/Module
Caused by: java.lang.ClassNotFoundException: com.google.inject.Module
{quote}
Of course, the problem may not actually be related.;;;","04/Oct/13 13:30;guillaume;Sounds unrelated, and seems to be a missing dependency to Guice.;;;","04/Oct/13 20:20;paulk;Yes, I get the same error with Java 7 and Russel's script but adding in the required dependency (which is strangely listed as provided in the pom - though TestNG's POM has been broken for many years, so what is one more error!) fixes the problem with Java 7 and 8:
{code}
@Grab('org.testng:testng:6.8.5')
@Grab('com.google.inject:guice:2.0')
@Grab('org.codehaus.groovy:groovy-testng:2.2.0-SNAPSHOT')
@GrabConfig(systemClassLoader=true)
import org.testng.annotations.Test
import static org.testng.Assert.assertEquals

class testngFails {
  @Test void calculateTheResult() {
    assertEquals('Hello World.', 'Hello World.')
  }
}
{code}
;;;","05/Oct/13 05:05;russel;Paul, Your fix does not work for me. :-(;;;","05/Oct/13 05:12;russel;If the TestNG POM had been broken wouldn't Cédric have fixed it by now?;;;","05/Oct/13 06:04;paulk;Russel, what error do you get now? I was using b108 and master?

I would have thought fixing the POM a useful idea but Cédric seems to have his own ideas of what an optional dependency is and now it seems a provided one too. :-(;;;","07/Oct/13 03:56;melix;What do you mean by ""my own ideas"" ? :)

A provided dependency is something that is, as is states, provided in the environment you run on. Typically, servlet API is required to build, but it is provided by the application server so you don't want to provide it in your war. If {{guice}} is a provided dependency, then IMHO it's a problem in the POM, not in Groovy, which behaves normally here: it will not download nor add the dependency on classpath, since it's supposed to be there...

As for an optional dependency: it's a dependency that you need to build your project, but that not everyone depends on. For example, you build a bridge with several databases, but you don't want you users to download the drivers for every database, you you put the dependencies as optional. The user then is required to explicitely add a dependency on the driver.;;;","07/Oct/13 04:05;melix;Oh, I'm not *the* Cédric you were referring to :);;;","07/Oct/13 05:54;paulk;@Groovy Cedric: I agree with your definitions. :-)

At the moment, TestNG assumes you have already some dependency containing Guice injection in your classpath. I suspect some JSR330 containers might now provide this but I would be surprised if many test environments where I would expect TestNG to be used would normally (or at least exclusively) be run in such containers. Also, TestNG pollutes your classpath with numerous unneeded jars, e.g. junit, hamcrest-core, beanshell, snakeyaml. I understand (partially) the reasoning: to allow lazy developers not to work out which of the optional bits they might want and where to get them. But you could use profiles (admittedly slightly broken in earlier times) or a testng-all artifact if you really wanted to accommodate that scenario without penalising your vigilant users.;;;","07/Oct/13 11:04;russel;Paul, things are exactly the same.
{code}
@Grab('org.testng:testng:6.8.7')
@Grab('com.google.inject:guice:3.0')
@Grab('org.codehaus.groovy:groovy-testng:2.3.0-SNAPSHOT')
import org.testng.annotations.Test
import static org.testng.Assert.assertEquals

class GROOVY_6156 {
  @Test void calculateTheResult() {
    assertEquals('Hello World.', 'Hello World.')
  }
}
{code}
gives me:
{quote}
Caught: java.lang.NoClassDefFoundError: com/google/inject/Module
java.lang.NoClassDefFoundError: com/google/inject/Module
Caused by: java.lang.ClassNotFoundException: com.google.inject.Module
{quote}
whether I use Java 7 or Java 8.

I have other @Grabs working on Java 8 so it is something specific to this combination.;;;","07/Oct/13 15:13;paulk;Russel, does the @GrabConfig as per my example help?;;;","08/Oct/13 05:00;russel;Yes it does. Sorry I had completely missed that.

So the question here is, can the Guice dependency alone be put in via the system class loader or is it required to have TestNG and the Groovy-TestNG loaded there as well?;;;","08/Oct/13 05:03;russel;Just did the experiment, it is only Guice that has to go in via the system class loader. The following works fine:
{code}
@Grab('com.google.inject:guice:3.0')
@GrabConfig(systemClassLoader=true)
import java.util.concurrent.ConcurrentHashMap

@Grab('org.testng:testng:6.8.7')
@Grab('org.codehaus.groovy:groovy-testng:2.3.0-SNAPSHOT')
import org.testng.annotations.Test
import static org.testng.Assert.assertEquals

class GROOVY_6156 {
  @Test void calculateTheResult() {
    assertEquals('Hello World.', 'Hello World.')
  }
}
{code}
Assuming the @GrabConfig is local to the one @Grab and not a global setting.;;;","08/Oct/13 06:25;paulk;Unfortunately it's global at the moment. The plan was for the @Grapes annotation to be the grouping mechanism which meant you could have put the guice @Grab and @GrabConfig inside a @Grapes and it would have been isolated - but we haven't implemented it to date. The thinking has been that @Grab is meant for simple dependency declarations. If you have something more complex than what is currently supported, perhaps in general you are better off leveraging a build system like gradle or even considering OSGi if you need strict isolation and can justify the added complexity.

So, today we just merge all @Grab related annotations together - making the @Grapes annotation effectively a no-op at the moment and hence why we don't encourage it much these days. If we had needed to keep the @Grab annotations around until runtime we would have needed @Grapes as a holder but as of Java 8 we could even hide that away with the @Repeatable meta-annotation.

I still think we should eventually add the @Grapes isolation capability, so I'm not advocating deprecating @Grapes - just indicating the current state of play.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,
"Can't access private static constant from closure, when using @CompileStatic",GROOVY-6155,12816960,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,lusxiao,lusxiao,16/May/13 05:12,14/Oct/13 16:54,14/Jul/23 06:01,27/Aug/13 05:32,2.0.8,2.1.3,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Static compilation,,,,0,,,,,,,"Can not access private static constant from colosure with @CompileStatic
Code:
{code}
@groovy.transform.CompileStatic
class A{
  private static final int BASE = 10
  
  void test() {
      def c = { 
              println BASE
      }
      
      c()
  }  
}

new A().test()
{code}
Output(Without @CompileStatic)
{noformat}
10
{noformat}

Output(With @CompileStatic)
{noformat}
1 compilation error:

Access to A#BASE is forbidden at line: -1, column: -1
{noformat}

----

But this code can work(wrap another closure)
{code}
@groovy.transform.CompileStatic
class A{
  private static final int BASE = 10
  
  void test() {
      def c = { 
          def c1 = {
              println BASE
          }
          c1()
      }
      
      c()
  }  
}

new A().test()
{code}",JDK1.7,blackdrag,lusxiao,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 27 05:32:33 UTC 2013,,,,,,,,,,"0|i2csbz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Aug/13 05:32;blackdrag;has been fixed by another issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SecureASTCustomizer using whitelist does not work deterministically,GROOVY-6153,12818517,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,yimingdu,yimingdu,13/May/13 14:16,01/Jun/13 06:11,14/Jul/23 06:01,29/May/13 09:17,2.0.1,,,,,,,,,,,,,,,,,2.1.4,,,,Compiler,,,,0,,,,,,,"We are using a GSE with {{SecureASTCustomizer}} to restrict use of certain classes. In my experiment, it does not work with a very simple test case: some classes in the package ""java.lang"" simply circumvent the restriction even without the use of reflection.

Here's how I set it up:
I used both import whitelist and receive whilelist, they are the same and contains actaully just two classes: java.lang.Object and test.
{code}		
		final String[] WHITE_CLASSES = {""java.lang.Object"", ""test""};				
		List<java.lang.String> classWhiteList = new ArrayList<java.lang.String>();
		classWhiteList.addAll(Arrays.asList(WHITE_CLASSES));
		
		final SecureASTCustomizer secure = new SecureASTCustomizer();
		secure.setIndirectImportCheckEnabled(true);
		secure.setImportsWhitelist(classWhiteList);
		secure.setReceiversWhiteList(classWhiteList);
		secure.setPackageAllowed(true);
		secure.setClosuresAllowed(true);
		secure.setMethodDefinitionAllowed(true);

		CompilerConfiguration cc = gse.getConfig();
		cc.addCompilationCustomizers(secure);
{code}

I expect that the above setting will complain the use of ""java.lang.Long"" & ""java.lang.System"". Howerver, the following script runs without any problem.

{code}
java.lang.Long lo = 5.6;
java.lang.System.out.println(""run "");		
{code}

When I went on to the following, it starts complaining the Math class.
{code}
java.lang.Long lo = 5.6;
java.lang.System.out.println(""run "" + java.lang.Math.abs(lo));		
{code}
I tried also java.lang.Thread, and it gets complained too. Is there any special exceptions to the whitelist?",Windows,melix,yiming du,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 29 09:17:39 UTC 2013,,,,,,,,,,"0|i2ctvz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/May/13 14:24;yimingdu;I tried to explicitly blacklist the System class, and it does not work either. It seems that some classes (also including java.lang.String)are just immune to the check.

;;;","13/May/13 15:29;yimingdu;More experiments:

After I changed
java.lang.Long lo = 5.6;

to 
java.lang.Long lo = new Long(5.6);

I got the expected SecurityException, seemingly autoboxing tricked the check process.

Also, after I changed 
java.lang.System.out.println(""run ""); 

to
java.lang.System.getenv(""test"");
I got the SecurityException. Does it have to do with static import here? or field access instead of methods?





;;;","29/May/13 08:50;melix;Formatting tags;;;","29/May/13 09:03;melix;There are two things in one here. First, a bug in {{SecureASTCustomizer}} which forgets to check that the receiver of a property expression is allowed:

{code}
System.out.println('run')
{code}

where {{System.out}} is a {{PropertyExpression}}.

The second point is whether you want to prevent people from *declaring* types too, which is not checked currently:

{code}
java.lang.Long x = ...
{code};;;","29/May/13 09:17;melix;Fixed now. Note that to prevent the use of declaration types, you have to use the constant types white/blacklist.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
LazyList does not allow range access,GROOVY-6152,12816993,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,asteingress,asteingress,asteingress,13/May/13 09:27,10/Jul/13 04:42,14/Jul/23 06:01,31/May/13 00:39,1.8.9,2.0.8,2.1.3,,,,,,,,,,,,,,,2.2.0-beta-1,,,,groovy-jdk,,,,0,,,,,,,"This pieces of code raises on IndexOutOfBoundsException:

{code}
def a = [1].withDefault {42}
assert a[2..-1] == [42]

java.lang.IndexOutOfBoundsException: toIndex = 3

	at java.util.SubList.<init>(Unknown Source)

	at java.util.RandomAccessSubList.<init>(Unknown Source)

	at java.util.AbstractList.subList(Unknown Source)

	at groovy.lang.ListWithDefault.subList(ListWithDefault.java:237)

	at org.codehaus.groovy.runtime.DefaultGroovyMethods.getAt(DefaultGroovyMethods.java:4864)

{code}

ListWithDefault#subList(int, int) should handle this case instead of delegating to List#subList(int, int)",,asteingress,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6179,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 31 00:38:57 UTC 2013,,,,,,,,,,"0|i2cpcn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/May/13 17:59;paulk;I think it makes sense to support ranges with two positive index values. And we should align normal list access I suspect, e.g.:

{code}
def a = [1]      // note: no ""withDefault""
println a[0,1,2] // => [1, null, null]
println a        // => [1]
println a[0..2]  // => IOOBE but should probably be [1, null, null]
{code}

Also, we need to define what makes sense if we have negative index values.

The most conservative approach would be to not grow the list in the case of one or more negative index values and if either index caused growth to throw an IllegalArgumentException? But other approaches are also possible.
;;;","14/May/13 02:18;asteingress;There is another issue with empty ranges. DGM returns a new ArrayList instance in that case but should return an instance of ListWithDefault.;;;","14/May/13 18:40;paulk;It's an interesting question as to whether the empty range case should return a ListWithDefault. Certainly if getAt for Range uses subList, then it should but getAt with a collection of Indices doesn't use subList. It makes me think we should align those two methods.

A case in point (sub is a plain ArrayList):
{code}
def list = [1].withDefault{42}
assert list[4] == 42
assert list == [1, null, null, null, 42]
def sub = list[0,2,4]
assert sub[3] == null
{code};;;","28/May/13 03:07;asteingress;Here is the pr: https://github.com/groovy/groovy-core/pull/198;;;","29/May/13 16:05;paulk;The EmptyRange DGM method isn't quite right. Add "".withDefault{ 42 }"" to the Javadoc groovyTestCase. I guess the best implementation at the moment is to supply an empty ArrayList as the delegate. A non-""view"" implementation like the reverse case but I think the ""view"" implementation is wrong anyway as per GROOVY-6179 (thanks for creating that BTW). Let me know if you want me to fix this issue.;;;","29/May/13 16:05;paulk;needs a minor tweak;;;","31/May/13 00:38;asteingress;Thanks, Paul! The EmptyRange access is now fixed on master.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Multi-assignment declarations should allow ""final"" keyword instead of ""def"" placeholder",GROOVY-6148,12816982,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,russel,russel,08/May/13 06:33,02/Oct/19 00:52,14/Jul/23 06:01,02/Oct/19 00:26,,,,,,,,,,,,,,,,,,3.0.0-beta-3,,,,syntax,,,,0,,,,,,,"The line:
{quote}
def (x, y) = l.split()
{quote}
works fine. However, the line:
{quote}
final (x, y) = l.split()
{quote}
fails with a compile error. If def gives a rebindable variable and final gives an unrebindable variable in other places it should here as well.
",,paulk,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 02 00:26:29 UTC 2019,,,,,,,,,,"0|i2bt2f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jun/16 06:03;paulk;Just mention the workaround is to use ""final def"" but agree the shorthand should work.;;;","02/Jun/16 07:07;paulk;Changing the {{multipleAssignmentDeclarationStart}} definition in the grammar from:
{code}
(modifier nls | annotation nls)* ""def"" nls LPAREN
{code}
to
{code}
(modifier nls | annotation nls | ""def"" nls)+ LPAREN
{code}
Seems to be the change required. And seems like a reasonable change for modifiers.

It does make the use of attributeless annotations a little confusing. Not that we currently support it but if you wanted to have something like @Lazy annotating a multi-assignment, you would need need something like:
{code}
@Lazy() (x, y) = [1, 2]
{code}
Note the empty brackets after @Lazy which could normally be elided but not here. Otherwise the (x, y) would be mistaken as attributes for the annotation. Note: the @Lazy example above is just fictitious. It currently knows nothing about multi-assignments, so the above is NOT supported.;;;","02/Oct/19 00:26;paulk;The parrot parser supports:
{code}
def (x, y) = s.split()
var (x, y) = s.split()
final (x, y) = s.split()
{code}
So, I think we can close this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic: dispatch bug with overloaded method when last argument is an array and there is an separate method without the last array argument,GROOVY-6147,12818235,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lhotari,lhotari,07/May/13 11:04,01/Jun/13 06:11,14/Jul/23 06:01,27/May/13 09:06,,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,,,,0,,,,,,,"There is a dispatch bug in CompileStatic with overloaded method when last argument is an array and there is an separate method without the last array argument.

Example of such method signatures:
{code}
List<MetaMethod> respondsTo(Object obj, String name, Object[] argTypes);
List<MetaMethod> respondsTo(Object obj, String name);
{code}


This example demonstrates the bug:
{code}
class Hello {
   def hello() {
      ""Hello""
   }

   def hello(String name) {
      ""Hello $name""
   }
}

class DispatchBug {
   def e=new Hello()
   
   @groovy.transform.CompileStatic
   def demo() {
      def d=new Hello()
      println org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(d).respondsTo(d, ""hello"")
      
      println org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(e).respondsTo(e, ""hello"")
   }
   
   def demoDynamic() {
      def d=new Hello()
      println org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(d).respondsTo(d, ""hello"")
      
      println org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(e).respondsTo(e, ""hello"")
   }
}

def bugdemo=new DispatchBug()

bugdemo.demo()
bugdemo.demoDynamic()
{code}

It prints out:
{code}
[public java.lang.Object Hello.hello()]
[public java.lang.Object Hello.hello(), public java.lang.Object Hello.hello(java.lang.String)]
[public java.lang.Object Hello.hello(), public java.lang.Object Hello.hello(java.lang.String)]
[public java.lang.Object Hello.hello(), public java.lang.Object Hello.hello(java.lang.String)]
{code}",,candrews,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-05-07 11:04:12.0,,,,,,,,,,"0|i2csf3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Confusing treatment of m['foo'], m.get('foo'), m.foo, m.getFoo() for Maps",GROOVY-6144,12816970,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,rattigan,rattigan,04/May/13 13:47,23/Apr/23 21:57,14/Jul/23 06:01,25/Jan/22 18:21,,,,,,,,,,,,,,,,,,5.0.0-alpha-1,,,,groovy-runtime,,,,0,breaking,,,,,,"See the following example for some Map-related quirks that have bitten me a few times. I think it's crucial to iron out these inconsistencies in order to prevent the grooviness of maps from being a liability.

I think the rules should be:

1. subscript operator always uses map interface (for both get and set/put)
2. property access always prefers setFoo(bar) over set('foo', bar)
3. existence of setFoo() or getFoo() prevents use of map interface for property access, whether reading or writing (to avoid inconsistency between x = m.foo and m.foo = x)

I guess that accessing m.'foo' should be equivalent to accessing m.foo, but maybe it should be equivalent to m['foo']. I can see arguments for both.

{code}

def m = [:]
// 1. as expected, accessing a map by subscript
assert m['class'] == null
assert m['metaClass'] == null

// 2. which of these should pass? I think the current behaviour is questionable:
// getters should be preferred over map members for this syntax.
// I would expect these to pass instead: 
// assert m.class == m.getClass()
// assert m.metaClass == m.getMetaClass()
assert m.class == null // WRONG
assert m.'class' == null // WRONG (?)
assert m.metaClass == null // WRONG
assert m.'metaClass' == null // WRONG (?)
 
// 3. as expected, using map interface method
assert m.get('class') == null

// 4. as expected, using getter
assert m.getClass() instanceof Class

// 5. as expected, accessing map by subscript
assert (m['class'] = 'foo') == 'foo'

// 6. this is unexpected, and it is inconsistent with (1) and (5). I would expect the following to pass, 
// since we're using the subscript operator:
// assert (m['metaClass'] = 'foo') == 'foo'
try { m['metaClass'] = 'foo'; assert false } catch (ClassCastException e) { } // WRONG

// 7. this is consistent with (2), but I would argue that this should fail by the same logic: 
// Maps have a getClass(), therefore it has a property 'class'. 
// Attempting to set the property should attempt to invoke setClass(), which doesn't exist.
// It should therefore throw a MissingMethodException for setClass()
assert (m.class = 'foo') == 'foo' // WRONG
assert (m.'class' = 'foo') == 'foo' // WRONG (?)

// 8. I think this is doing the right thing - preferring the property over map semantics - but it is inconsistent with (2)
try { m.metaClass = 'foo'; assert false } catch (ClassCastException e) { }
try { m.'metaClass' = 'foo'; assert false } catch (ClassCastException e) { }

// 9. as expected, looking for setter, none exists
try { m.setClass('foo'); assert false } catch (MissingMethodException e) { }

{code}",,emilles,rattigan,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5001,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 25 18:21:37 UTC 2022,,,,,,,,,,"0|i2cp0n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jan/22 16:59;emilles;https://github.com/apache/groovy/pull/1674

Note that ""class"" and ""empty"" and ""metaClass"" still have special handling and are not routed to the accessors to avoid too much breakage.  If you want to be certain that you are using the accessor method, use method call syntax.;;;","25/Jan/22 18:21;emilles;https://github.com/apache/groovy/commit/051d3cf3ef29a521137b9d6b71cb8097d077d46b
https://github.com/apache/groovy/commit/bbbff15b867157d8ed9f05207265a5ea80357ba6;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovysh & groovysh completion vulnerable to Classes with custom getProperty(),GROOVY-6143,12816953,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,tkruse,tkruse,04/May/13 07:43,10/Jul/13 04:42,14/Jul/23 06:01,19/May/13 02:44,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,Groovysh,,,,0,,,,,,,"Groovyjsh may raise MissingpropertyExceptions due to careless calls to the .class property, should use getClass instead (one call introduce by me earlier).
The same goes for completion, which btw can be extended to complete properties found via getProperties().
To reproduece, e.g. call (on groovy master branch):

x = new Object() {public Object getProperty(String name) {throw new MissingPropertyException('From test', name, null)}}

or tab completion on such an Object.",Any,pschumacher,tkruse,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 19 02:44:30 UTC 2013,,,,,,,,,,"0|i2cmp3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/May/13 07:45;tkruse;Reference: https://github.com/groovy/groovy-core/pull/178;;;","19/May/13 02:44;pschumacher;Pull request applied. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inner class of inner class cannot reference outer class members,GROOVY-6141,12816962,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,rattigan,rattigan,03/May/13 17:55,08/Jul/14 15:28,14/Jul/23 06:01,03/Jul/14 05:17,2.1.2,,,,,,,,,,,,,,,,,2.3.4,,,,groovy-runtime,,,,0,,,,,,,"{code}
class A {
  def x = 1
  def b = new B()
  class B {
    def y = 2
    def c = new C()
    def f () {
      println y
      println x
    }
    class C {
      def z = 3
      def f() {
        println z
        println y
        println x
      }
    }
  }
}

def a = new A()
a.b.f()
a.b.c.f()
{code}

produces the output:

{quote}
2
1
3
2
Exception thrown
May 3, 2013 6:49:34 PM org.codehaus.groovy.runtime.StackTraceUtils sanitize
WARNING: Sanitizing stacktrace:
groovy.lang.MissingFieldException: No such field: x for class: A$B
{quote}",,blackdrag,rattigan,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 03 05:17:42 UTC 2014,,,,,,,,,,"0|i2c51r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jul/14 05:17;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic: in operator (isCase) isn't null safe in CS mode,GROOVY-6137,12816946,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lhotari,lhotari,02/May/13 23:41,24/Jan/23 18:32,14/Jul/23 06:01,27/May/13 08:01,2.1.3,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,,,,0,,,,,,,"in operator is null safe in dynamic compilation mode (I guess that's because of the internal NullObject). 
Similar code throws an exception in static compilation mode.

example:
{code}
def isCaseNull(a, b) {
   a in b
}

@groovy.transform.CompileStatic
def isCaseNullCS(a, b) {
   a in b
}

isCaseNull(1, null)
isCaseNullCS(1, null)
{code}",,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7473,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-05-02 23:41:02.0,,,,,,,,,,"0|i2ciy7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy classes with @CompileStatic can't infer generic types in some cases,GROOVY-6135,12816879,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,bborchardt,bborchardt,02/May/13 17:44,08/May/14 18:17,14/Jul/23 06:01,07/May/14 07:18,2.1.3,,,,,,,,,,,,,,,,,2.3.0,,,,Static compilation,,,,0,,,,,,,"The following gives a compiler error:

{code}
import javax.xml.ws.Holder

@groovy.transform.CompileStatic
class MyClass {
    public static void main(String[] args) {
        Holder<Integer> holder = new Holder<Integer>()
        holder.value = 5
        println holder.value > 4
    }
}
{code}

[Static type checking] - Cannot find matching method java.lang.Object#compareTo(int). Please check if the declared type is right and if the method exists.","Windows 7, Java 1.6, Groovy 2.1.3",bborchardt,guillaume,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 01 07:27:32 UTC 2014,,,,,,,,,,"0|i2c973:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"02/May/13 18:06;bborchardt;Here's one more example:

{code}
@groovy.transform.CompileStatic
class MyClass {
    static void main(String[] args) {        
        MyClass myClass = new MyClass().instantiate(MyClass)
        println myClass
    }
    
    def <T> T instantiate(Class<T> type) {
        type.newInstance()
    }
}
{code}

[Static type checking] - Cannot assign value of type java.lang.Object to variable of type MyClass;;;","13/Jun/13 16:11;bborchardt;Another example:
{code}
@groovy.transform.CompileStatic
class MyClass {
    static final Map<String, String> map = [
            a: 'a',
            b: 'b'
    ].asImmutable()
}
{code}
[Static type checking] - Incompatible generic argument types. Cannot assign java.util.Map <java.lang.Object extends java.lang.Object, java.lang.Object extends java.lang.Object> to: java.util.Map <String, String>

The same is not true when I do this with a List though, just with a Map.;;;","01/May/14 05:46;tim_yates;Tried these out, and they all work in Groovy 2.2.2+;;;","01/May/14 07:27;guillaume;We're trying to release 2.3.0-RC-3 today, could you try with it too?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
bad example in comment of SourceAwareCustomizerFactory(source(basenameVaidator:{})),GROOVY-6133,12816942,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,uehaj,uehaj,01/May/13 23:50,01/Jun/13 06:11,14/Jul/23 06:01,02/May/13 01:37,2.1.3,,,,,,,,,,,,,,,,,2.1.4,,,,Documentation,,,,0,,,,,,,"In groovy-2.1.3/src/main/org/codehaus/groovy/control/customizers/builder/SourceAwareCustomizerFactory.java, I found following error:

{noformat}
omizers/builder% diff -p SourceAwareCustomizerFactory.java SourceAwareCustomizerFactory.java~
*** SourceAwareCustomizerFactory.java	2013-05-02 13:44:59.000000000 +0900
--- SourceAwareCustomizerFactory.java~	2013-04-12 15:01:58.000000000 +0900
*************** import java.util.Map;
*** 55,61 ****
   *     }
   *
   *     // apply CompileStatic AST annotation on files whose name is 'foo' or 'bar'
!  *     builder.source(basenameValidator: { it in ['foo', 'bar'] }) {
   *         ast(CompileStatic)
   *     }
   *
--- 55,61 ----
   *     }
   *
   *     // apply CompileStatic AST annotation on files whose name is 'foo' or 'bar'
!  *     builder.source(basenames: { it in ['foo', 'bar'] }) {
   *         ast(CompileStatic)
   *     }
   *
{noformat} 

Following document has the same error and other errors, i fixed.
http://docs.codehaus.org/display/GROOVY/Advanced+compiler+configuration
",,melix,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 02 01:37:47 UTC 2013,,,,,,,,,,"0|i2bx2f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/May/13 01:37;melix;Good catch, thank you!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Surprising Behavior With @CompileStatic And Collection.putAt,GROOVY-6131,12816969,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,brownj,brownj,30/Apr/13 23:15,01/Jun/13 06:11,14/Jul/23 06:01,02/May/13 09:29,2.1.1,2.1.2,2.1.3,,,,,,,,,,,,,,,2.1.4,,,,Compiler,,,,0,,,,,,,"{code:title=Helper.groovy|borderStyle=solid}
@groovy.transform.CompileStatic
class Helper {
    void addToCollection(Collection coll, int index, val) {
        coll[index] = val
    }
}
{code}

Compiled with 2.1.1 the decompiled class looks something like this:

{noformat}
import groovy.lang.GroovyObject;
import groovy.lang.MetaClass;
import groovy.transform.TypeChecked.TypeCheckingInfo;
import java.util.Collection;

public class Helper
  implements GroovyObject
{
  public Helper()
  {
    Helper this;
    MetaClass localMetaClass = $getStaticMetaClass();
    this.metaClass = localMetaClass;
  }

  @TypeChecked.TypeCheckingInfo(inferredType=""AAlDbGFzc05vZGUAAAFWAP////8="", version=1)
  public void addToCollection(Collection coll, int index, Object val)
  {
    Object localObject = val;
  }

  static
  {
    __$swapInit();
    long l1 = 0L;
    __timeStamp__239_neverHappen1367381386616 = l1;
    long l2 = 1367381386616L;
  }
}
{noformat}

The method doesn't really do anything.",,brownj,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 02 09:29:31 UTC 2013,,,,,,,,,,"0|i2bvin:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/May/13 08:41;melix;Confirmed on master too.;;;","02/May/13 09:00;melix;It's very unfortunate that the compiler didn't generate an error here. The {{Collection}} interface doesn't guarantee that we can do a {{putAt}}. It non-static Groovy, it works because the runtime type is for example {{List}} which supports {{putAt}}, but in general, for a {{Collection}}, it wouldn't work statically.;;;","02/May/13 09:29;melix;Fixed by throwing an error during type checking.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic def map = new HashMap<>() crashes compiler,GROOVY-6129,12818229,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,Nkey,Nkey,30/Apr/13 10:06,01/Jun/13 06:11,14/Jul/23 06:01,30/Apr/13 11:51,2.1.3,,,,,,,,,,,,,,,,,2.1.4,,,,Compiler,Static compilation,Static Type Checker,,0,compilestatic,static,typechecked,,,,"Code like:

   @CompileStatic
    void test(){
        def map = new HashMap<>()
    }

breaks compiler with stacktrace:

Groovyc: java.lang.NullPointerException
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferDiamondType(StaticTypeCheckingVisitor.java:565)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:482)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:245)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitDeclarationExpression(ClassCodeVisitorSupport.java:107)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:86)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1330)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1602)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1575)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:120)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:72)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:54)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:80)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:85)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:121)
","Windows, Groovy 2.1.3, Intelijj Idea",melix,Nkey,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Apr/13 10:06;Nkey;CompileStaticDiamondTest.groovy;https://issues.apache.org/jira/secure/attachment/12722388/CompileStaticDiamondTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 30 11:51:22 UTC 2013,,,,,,,,,,"0|i2cjtb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"30/Apr/13 11:51;melix;Thanks for the report. The error shown up because the diamond operator normally requires a type on the left hand side that allows matching the generics types. Here it wasn't the case, good catch.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect encoding in generated java stubs,GROOVY-6128,12816939,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mxm-groovy,mxm,30/Apr/13 05:15,17/Jun/15 20:10,14/Jul/23 06:01,30/Jul/14 04:02,,,,,,,,,,,,,,,,,,2.4.0-beta-3,,,,Stub generator / Joint compiler,,,,1,,,,,,,"It seems that JavaStubGenerator sometimes generates stub files with incorrect encodings

see attached files and http://youtrack.jetbrains.com/issue/IDEA-106154 for details.

Compilatation fails with message:
{USER_HOME}\.IntelliJIdea12\system\compile-server\test_3f67e250\groovyStubs\test\java-production\Test.java
Error:(16,29) java: illegal character: \65533
Error:(16,30) java: illegal character: \65533
Error:(16,31) java: invalid method declaration; return type required
Error:(16,47) java: cannot return a value from method whose result type is void

",,mxm,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Apr/13 05:15;mxm;Test+%28generated+stub%29 (1).java;https://issues.apache.org/jira/secure/attachment/12723128/Test%2B%2528generated%2Bstub%2529+%281%29.java","30/Apr/13 05:15;mxm;project (1).zip;https://issues.apache.org/jira/secure/attachment/12722942/project+%281%29.zip",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-04-30 05:15:08.0,,,,,,,,,,"0|i2csb3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"VerifyError ""Incompatible argument to function"" when returning value from function after instanceof check in a function that should return Object (bug in inference base return type selection)",GROOVY-6127,12816948,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,lhotari,lhotari,29/Apr/13 23:08,01/Jun/13 06:11,14/Jul/23 06:01,30/Apr/13 09:58,2.1.3,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,,,,0,,,,,,,"This code started failing after adding the ""return value"" after the ""if (value instanceof CharSequence)"" line.

This fails:
{code}
    static Object convertValueToType(Object value, Class targetType) {
        if(targetType != null && value != null && !(value in targetType)) {
            if (value instanceof CharSequence) {
                value = value.toString()
                if(value in targetType) {
                    return value
                }
            }
            try {
                if (value instanceof Number && (targetType==Long || targetType==Integer)) {
                    if(targetType == Long) {
                        value = ((Number)value).toLong()
                    } else {
                        value = ((Number)value).toInteger()
                    }
                } else if (value instanceof String && targetType in Number) {
                    String strValue = value.trim()
                    if(targetType == Long) {
                        value = Long.parseLong(strValue)
                    } else if (targetType == Integer) {
                        value = Integer.parseInt(strValue)
                    } else {
                        value = StringGroovyMethods.asType(strValue, targetType)
                    }
                } else {
                    value = new SimpleTypeConverter().convertIfNecessary(value, targetType)
                }
            } catch (e) {
                // ignore
            }
        }
        return value
    }
{code}

This works:
{code}
    static Object convertValueToType(Object passedValue, Class targetType) {
        Object value = passedValue
        if(targetType != null && value != null && !(value in targetType)) {
            if (value instanceof CharSequence) {
                value = value.toString()
                if(value in targetType) {
                    return value
                }
            }
            try {
                if (value instanceof Number && (targetType==Long || targetType==Integer)) {
                    if(targetType == Long) {
                        value = ((Number)value).toLong()
                    } else {
                        value = ((Number)value).toInteger()
                    }
                } else if (value instanceof String && targetType in Number) {
                    String strValue = value.trim()
                    if(targetType == Long) {
                        value = Long.parseLong(strValue)
                    } else if (targetType == Integer) {
                        value = Integer.parseInt(strValue)
                    } else {
                        value = StringGroovyMethods.asType(strValue, targetType)
                    }
                } else {
                    value = new SimpleTypeConverter().convertIfNecessary(value, targetType)
                }
            } catch (e) {
                // ignore
            }
        }
        return value
    }
{code}

perhaps this has something to do with inference based return type selection.
",,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 30 09:57:30 UTC 2013,,,,,,,,,,"0|i2bq6f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Apr/13 08:03;melix;Here is a smaller code snippet showing the problem:

{code}
    @CompileStatic
    Object convertValueToType(Object value, Class targetType) {
            if (value instanceof CharSequence) {
                value = value.toString()
            }
            if (value instanceof String) {
                String strValue = value.trim()                    
            }
    }
{code}

The generated bytecode looks like:

{code}
00014 LTestScripttestShouldNotThrowIncompatibleArgToFunVerifyError0; Object Class . .  :  :     ALOAD 1
00015 LTestScripttestShouldNotThrowIncompatibleArgToFunVerifyError0; Object Class . .  : Object  :     INVOKEVIRTUAL java/lang/String.trim ()Ljava/lang/String;
{code}

which means that the first parameter ({{ALOAD 1}}) is loaded but no {{CHECKCAST}} is added to ensure the object is of the right type.;;;","30/Apr/13 09:57;melix;Updating status to blocker since the bug is more problematic than it looks: it's related to handling of flow typing within conditional branches which can lead to invalid bytecode with {{@CompileStatic}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic: dispatch doesn't choose correct method when parameterized generic types are used,GROOVY-6126,12818251,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lhotari,lhotari,28/Apr/13 14:58,20/May/14 05:31,14/Jul/23 06:01,16/May/14 11:54,2.1.3,,,,,,,,,,,,,,,,,2.3.1,,,,Static compilation,,,,0,,,,,,,"Example in grails-data-mapping:
https://github.com/lhotari/grails-data-mapping/commit/73e977fd4c29b592276baab3e74fba310edd0086#L0R146

In this case persistentClass is defined as parameterized:
protected Class<D> persistentClass


HibernateTemplate has several load methods:
{code}
public <T> T load(Class<T> entityClass, Serializable id) throws DataAccessException;
public void load(final Object entity, final Serializable id) throws DataAccessException;
{code}


persistentClass has to be explicitly casted as Class to call the correct method. It will call the 2nd load method with the Object parameter without casting.

This is the code in my example (this version calls correct methods):
{code}
    D load(Serializable id) {
        id = convertIdentifier(id)
        if (id != null) {
            return hibernateTemplate.load((Class)persistentClass, id)
        }
    }
{code}

This calls the wrong method:
{code}
    D load(Serializable id) {
        id = convertIdentifier(id)
        if (id != null) {
            return hibernateTemplate.load(persistentClass, id)
        }
    }
{code}

Parametrized generic types don't seem to be properly handled in method dispatch.


",,blackdrag,lhotari,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 16 11:54:20 UTC 2014,,,,,,,,,,"0|i2c52f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Apr/13 15:08;lhotari;I get a compilation error for methods that only have a method accepting a ""Class"" argument, for example 
{code}
    D get(Serializable id) {
        if (id || (id instanceof Number)) {
            id = convertIdentifier(id)
            D result = (D)hibernateTemplate.get((Class)persistentClass, id)
            return GrailsHibernateUtil.unwrapIfProxy(result)
        }
    }
{code}
This fails without the explicit cast.

{code}
HibernateGormStaticApi.groovy: 101: [Static type checking] - Cannot find matching method 
org.codehaus.groovy.grails.orm.hibernate.GrailsHibernateTemplate#get(java.lang.Class <D>, java.io.Serializable). 
Please check if the declared type is right and if the method exists.
 @ line 101, column 27.
               D result = (D)hibernateTemplate.get(persistentClass, id)
                             ^

1 error
{code};;;","19/Aug/13 06:42;blackdrag;using this code: {code:Java}
class Loader {
    public <T> T load(Class<T> entityClass, Serializable id) {entityClass.newInstance()}
    public void load(final Object entity, final Serializable id) {}
}

@groovy.transform.CompileStatic
class MyClass<D> {
    Class<D> persistentClass
    Loader hibernateTemplate = new Loader()
    MyClass(Class<D> c) {
        this.persistentClass = c
    }
     
    D load(Serializable id) {
        id = convertIdentifier(id)
        if (id != null) {
            return hibernateTemplate.load(persistentClass, id)
        }
    }
    
    Serializable convertIdentifier(Serializable s) {""1""}
}
class Foo{}
MyClass<Foo> mc = new MyClass(Foo)
println mc.load(""2"")
{code}
I found that for the load call we compare Class<T> with Class<D> path:
GenericsType$GenericsTypeMatcher.checkGenerics(ClassNode) line: 275	
GenericsType$GenericsTypeMatcher.matches(ClassNode) line: 246	
GenericsType.isCompatibleWith(ClassNode) line: 173	
StaticTypeCheckingSupport.isAssignableTo(ClassNode, ClassNode) line: 361	
StaticTypeCheckingSupport.allParametersAndArgumentsMatch(Parameter[], ClassNode[]) line: 222	

It fails because the name T is not D. That is of course wrong. The result is that the method is excluded from the selection process and then of course the wrong method is taken in the end.;;;","16/May/14 11:54;pschumacher;Thanks for reporting this. Blackdrags example now works, so I'm resolving this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bugs in GPathResult.parent() and '..' notation,GROOVY-6125,12817597,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,eddelplus,eddelplus,27/Apr/13 05:51,05/Apr/15 14:43,14/Jul/23 06:01,18/May/13 06:22,2.1.3,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,XML Processing,,,,0,breaking,,,,,,"The XmlSlurper sample from the documentation
{code:xml}
    <records>
      <car name='HSV Maloo' make='Holden' year='2006'>
        <country>Australia</country>
        <record type='speed'>Production Pickup Truck with speed of 271kph</record>
      </car>
      <car name='P50' make='Peel' year='1962'>
        <country>Isle of Man</country>
        <record type='size'>Smallest Street-Legal Car at 99cm wide and 59 kg in weight</record>
      </car>
      <car name='Royale' make='Bugatti' year='1931'>
        <country>France</country>
        <record type='price'>Most Valuable Car at $15 million</record>
      </car>
    </records>
{code}

 fails these additional asserts:

{code}
    assert records.car.record.findAll({it.@type == 'price'}).parent().country == 'France'
    assert records.car.country.findAll({it == 'Australia'}).'..'.record.@type == 'speed'
{code}

On on an XML, where some 'cars' don't have a 'country' child this expression will still return all countries: records.cars.country.parent(). It should only return 'cars' with at least one 'country' child.

Fixing the problem involved:
- Adding a public parent() method and parent private property to Node
- Implementing an additional subclass NodeParents of GPathResult
- Simplifying childNodes() in NodeChildren, so that it utilizes the classes nodeIterator()
- Implementing ParentNodes with a nodeIterator() override
- Cleaning up FilteredNode children to follow the same pattern
- Instantiating ParentNodes in GPathResult.parent()
- Calling parent() for property '..'

And as an added refinement to the GPath syntax:
- Defining GPathResult.getAt(closure) to call findAll(closure)

All changed source code in groovy.util.slurpersupport is in the attached zip. The groovy source contains the asserts. All of which pass.

This fix supersedes the proposed fix for #6122",JDK 6,eddelplus,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Apr/13 05:51;eddelplus;NewGroovyClass.groovy;https://issues.apache.org/jira/secure/attachment/12723198/NewGroovyClass.groovy","27/Apr/13 05:51;eddelplus;slurpersupport.zip;https://issues.apache.org/jira/secure/attachment/12722385/slurpersupport.zip",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Sat May 18 06:22:46 UTC 2013,,,,,,,,,,"0|i2c7hb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"27/Apr/13 21:33;paulk;For future reference, a github pull request is quite a bit easier for us to handle compared to a zip but all contributions are greatly appreciated.

Just a little bit on XmlSlurper history. The original author wanted .parent() or '..' to unwrap one level of GPath expression so that for instance:
{code}
root.gpath1.gpath2.parent().gpath3
{code}
would be equivalent to:
{code}
root.gpath1.gpath3
{code}

In hindsight, I think this wasn't the ideal use of '..' or .parent() but some people might be relying on this behavior. So to move forward we would need to mark this as a breaking change, decide which version we would release this for and also provide an implementation of the existing functionality under a different name, perhaps "".pop()"" or "".undo()"".;;;","28/Apr/13 02:12;eddelplus;There is a .parents() method in GPathResult that throws a ""Not implemented yet"" exception in all the subclasses. I could implement that. Problem is that .parent() has been introduced as the equivalent of '..'. So redefining '..' to mean .parents() is as much of a breaking change. In terms of what XPath to GPath migrants will think, the proposed new behavior for '..' makes more sense.

So I'd suggest taking the plunge with changing .parent(), leaving .parents() as it is, and adding .pop(). I think this shouldn't need to wait for 3.x, if we can get it into 2.2 beta.

I'll create a fresh pull request after GROOVY-6122 has been acccepted.;;;","29/Apr/13 19:00;eddelplus;Fresh pull request is now on GitHub. I've left out the getAt(Closure) part. Tried to attain maximum compatiblity with existing tests. All previous tests still succeed. This change actually brings XmlSlurper more in line with XmlParser. There are two tests with .parent() that work for both, one had been identfied as giving problems with XmlSlurper before. I really believe this fixes the gap with what the functionality should have been in the first place. Very small breaking change should be OK for 2.2.0.;;;","02/May/13 02:17;melix;Code tags, copied the sample from the docs for reference;;;","02/May/13 02:23;melix;Agreed that the ""parent"" semantics in suggested here are better than the actual ones. I added the {{breaking}} tag to this issue. As for 2.2 vs 3.0, my vote would go to 2.2 but maybe it's worth asking people on the ML if anyone relies on the old behavior.;;;","18/May/13 06:22;paulk;Thanks for the issue and pull request.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot use array slice with @CompileStatic,GROOVY-6124,12818214,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pledbrook,pledbrook,27/Apr/13 03:58,01/Jun/13 06:11,14/Jul/23 06:01,29/Apr/13 07:01,2.0.8,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,,,,0,,,,,,,"This code:

{code}
def cmd
if (args.size() == 0) {
    cmd = ""help""
    args = []
}
else {
    cmd = args[0]
    args = args.size() == 1 ? [] : args[1..-1]
}
{code}

results in this _runtime_ error:

{noformat}
Exception in thread ""main"" org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object '1..-1' with class 'groovy.lang.IntRange' to class 'int'
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToNumber(DefaultTypeTransformation.java:146)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.intUnbox(DefaultTypeTransformation.java:60)
	at uk.co.cacoethes.lazybones.LazyBonesMain.main(LazyBonesMain.groovy:32){noformat}

You can reproduce by unpacking the attached project into a fresh directory and running {{./gradlew run}}",,pledbrook,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Apr/13 03:58;pledbrook;static-compilation-bug.zip;https://issues.apache.org/jira/secure/attachment/12722943/static-compilation-bug.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-04-27 03:58:53.0,,,,,,,,,,"0|i2c89z:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FilteredNodeChildren doesn't provide childNodes() iterator,GROOVY-6122,12816881,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,eddelplus,eddelplus,26/Apr/13 17:20,05/Apr/15 14:43,14/Jul/23 06:01,29/Apr/13 05:23,2.1.3,,,,,,,,,,,,,,,,,2.1.4,2.2.0-beta-1,,,XML Processing,,,,0,,,,,,,"Given the standard XML example from the documentation, the following GPath expressions did not return the same result:
{code}
records.car.country
records.car.findAll({ true }).country
{code}

The reason is a missing implementation of childNodes() in FilteredNodeChildren.

Merging the code patterns for flattening all the child iterators in NodeChildren and for filtering with the lazy-evaluated closure originally passed to the parent via .findAll() in the existing iterator implementations of FilteredNodeChildren.

The suggested implementation (uploaded) passes all the assert in the documentation example. It also passes these additional asserts, proving that two findAll() filters can be chained and the GPath can be further extended beyond the filter:
{code}
assert records.car.findAll({ true }).country == 'AustraliaIsle of ManFrance'
assert records.car.findAll({ it.@make =~ /e/ }).record.@type == 'speedsize'
assert records.car.findAll({ true }).findAll({ it.@make =~ /ug/ }).country == 'France'
{code}
",JDK 6,eddelplus,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"26/Apr/13 17:20;eddelplus;FilteredNodeChildren.java;https://issues.apache.org/jira/secure/attachment/12723170/FilteredNodeChildren.java",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Mon Apr 29 05:23:37 UTC 2013,,,,,,,,,,"0|i2butr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Apr/13 21:24;paulk;It would be more accurate to say that FilteredNodeChildren relies on an inherited childNodes() implementation which doesn't take into account the filtering Closure. But in any case, given GROOVY-6125, should we close this issue?;;;","28/Apr/13 01:16;eddelplus;I think we should keep this issue for the childNodes of FilteredNodeChildren, because this (after testing) hopefully will not break anything and can be introduced short term. I'd still have to rework the fix, given the additional insight gained from GROOVY-6125. Both childNodes() and iterator() in NodeChildren should be fixed, so that they can safely be inherited by FilteredNodeChildren. That'll be cleaner.;;;","28/Apr/13 01:55;eddelplus;Here's a nice clean GitHub pull request:
[https://github.com/groovy/groovy-core/pull/175];;;","29/Apr/13 05:23;paulk;Applied, thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Object[].groupBy is not defined,GROOVY-6121,12816804,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,uehaj,uehaj,24/Apr/13 22:30,10/Jul/13 04:42,14/Jul/23 06:01,25/Apr/13 05:02,2.1.3,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,groovy-jdk,,,,0,,,,,,,"groupBy(Closure) GDK method is defined only on java.util.Collection, but array(Object[]) lacks it.
For example,
{quote}
groovy -e 'println(([""ab"",""ba"",""ac""] as String[]).groupBy\{ it[0] \})'
Caught: groovy.lang.MissingMethodException: No signature of method: [Ljava.lang.String;.groupBy() is applicable for argument types: (script_from_command_line$_run_closure1) values: [script_from_command_line$_run_closure1@4f209819]
Possible solutions: grep(), grep(), grep(java.lang.Object), drop(int), countBy(groovy.lang.Closure), grep(java.lang.Object)
{quote}

On the other hand, countBy{} is defined on Object[].
Is there any reason with this asymmetry?

","Mac OS X, JDK8 (""1.8.0-ea-b83"")",paulk,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 25 05:02:36 UTC 2013,,,,,,,,,,"0|i2ceon:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Apr/13 05:01;paulk;we just haven't added it yet;;;","25/Apr/13 05:02;paulk;added, thanks for the suggestion;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Verify error in class annotated with @Category if instance field is used,GROOVY-6120,12816892,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mxm-groovy,mxm,24/Apr/13 06:18,17/Jun/15 20:09,14/Jul/23 06:01,09/Jul/13 03:15,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,,,,,0,breaking,,,,,,"The following code fails with Verify error
{code}
@Mixin(Foo)
class Bar {}

@Category(Bar)
class Foo {
    public x = 5

    def foo() {
        print x //verify error because of the field reference
    }
}

new Bar().foo()
{code}

But if we use field 'x' outside of 'Foo' no errors happen
{code}
@Mixin(Foo)
class Bar {}

@Category(Bar)
class Foo {
    public x = 5

    def foo() {
    }
}

new Bar().x = 4
print new Bar().x //prints 5
{code}

So imho the first code snippet should not throw the error.",,melix,mxm,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 09 03:15:05 UTC 2013,,,,,,,,,,"0|i2cn3z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Apr/13 18:41;paulk;A workaround is to replace ""{{print x}}"" with ""{{print this.x}}"".;;;","25/Apr/13 10:01;melix;It's a bit strange to see both {{@Category}} and {{@Mixin}} here. The {{@Category}} AST transformation will turn:

{code}
@Category(Bar)
class Foo {
    def foo() {
    }
}
{code}

into:

{code}
class Foo {
    static def foo(Bar self) {
    }
}
{code}

If you put a field in the category class, like here, then it's at best unsafe. Currently the transform doesn't touch fields. So you end up with:

{code}
class Foo {
    public x = 5
    static def foo(Bar self) {
    }
}
{code}

When you use a category:

{code}
use(Foo) {
   bar.foo()
}
{code}

There's no instance of {{Foo}} which is created, so using a field is not appropriate. We could transform fields into static fields, but it would be IMHO unsafe (shared mutable static state).

My preference goes to forbid usage of fields into classes annotated with {{@Category}}, which is a clear rule (no state allowed in categories, be it static or not).

Another option would be to only allow static final fields of immutable types. In any case, you should not use fields in categories.;;;","25/Apr/13 12:28;mxm-groovy;Ok. I didn't understand clear how @Category managed fields. My example showed that fields were possibly injected into 'Bar' somehow.  

So I agree that the best decision is to forbid instance fields in @Category classes.;;;","26/Apr/13 01:07;paulk;The other alternative is to translate references that look like {{this.x}} to {{self.x}}. It would then make sense to _mixin_ such classes (and would avoid resorting to unsafe/static alternatives) but possibly is difficult to explain in terms of normal {{@Category}} usage.;;;","26/Apr/13 02:50;melix;Here's the pull request: https://github.com/groovy/groovy-core/pull/173

We're still unsure in what version of Groovy we should integrate the fix, since it's a potential (but low risk) breaking change.;;;","09/Jul/13 03:15;melix;Merged PR;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker doesn't recognize explicit map constructor,GROOVY-6119,12816818,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,23/Apr/13 09:15,01/Jun/13 06:11,14/Jul/23 06:01,25/Apr/13 02:43,2.1.3,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,Static Type Checker,,,0,,,,,,,"If a class defines a constructor which takes a map as argument, then the type checker doesn't recognize it and will think that constructor calls with maps are the default groovy map-style constructor.

example:

{code}
class Foo {
   String message
   Foo(Map map) {
      message = map.msg
   }
}
def foo = new Foo(msg: 'bar')
assert foo.message == 'bar'
{code}

Fails with:

{noformat}
[Static type checking] - No such property: msg for class: Foo
{noformat}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-04-23 09:15:43.0,,,,,,,,,,"0|i2ca0v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Class with @CompileStatic, @Immutable, and a List property causes a compiler exception to be thrown",GROOVY-6114,12816865,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,bborchardt,bborchardt,19/Apr/13 17:35,01/Jun/13 06:11,14/Jul/23 06:01,25/Apr/13 02:43,2.1.3,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,,,,0,,,,,,,"When compiling the following class the groovy compiler throws an exception. In addition, when compiling multiple classes there is no indication which class caused the exception (making it hard to find).

{code}
@groovy.transform.CompileStatic
@groovy.transform.Immutable
class MyClass {
    List<String> myList
}
{code}

{noformat}
java.lang.ArrayIndexOutOfBoundsException: size==0
{noformat}","Windows 7, Java 6, 64-bit, Groovy 2.1.3",bborchardt,lhotari,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 28 08:22:52 UTC 2013,,,,,,,,,,"0|i2buxr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"21/Apr/13 04:13;paulk;The problem goes away when either @CompileStatic or @Immutable is commented out. Some more of the stack trace:
{noformat}
java.lang.ArrayIndexOutOfBoundsException: size==0
	at org.codehaus.groovy.classgen.asm.OperandStack.getTopOperand(OperandStack.java:714)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:299)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesBinaryExpressionMultiTypeDispatcher.evaluateEqual(StaticTypesBinaryExpressionMultiTypeDispatcher.java:222)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:78)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:529)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:511)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeIfElse(StatementWriter.java:296)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitIfElse(AsmClassGenerator.java:473)
	at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:41)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeIfElse(StatementWriter.java:285)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitIfElse(AsmClassGenerator.java:473)
	at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:41)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
{noformat}

;;;","22/Apr/13 11:31;melix;The problem comes from a statement generated by the {{@Immutable}} AST transformation:

{code}DefaultGroovyMethods.asImmutable(null){code}

See https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java#L250

Since there are multiple {{asImmutable}} methods, the type checker is not able to select the right one.

;;;","23/Apr/13 08:57;melix;Solving it by an explicit cast exposes another bug, which is that the generated code looks like this:
{code}
if (foo instanceof Cloneable) {
   bar = foo.clone()
}
{code}
The problem is that this code cannot be statically compiled: the {{Cloneable}} interface doesn't make the {{clone}} method explicitely public. So if the field type is an interface, like here, there's no guarantee that the {{clone}} method will be public. It throws a {{bad access to protected}} error at runtime.

This can be fixed by invoking the clone method by reflection, but, again, it unveils another bug, which seems to be related to the way the static compiler handles named arguments for constructor calls. Here, there's an explicit constructor with a hash map as parameter, and the static compiler doesn't call it... At least, progressing :);;;","23/Apr/13 09:16;melix;Created GROOVY-6119 to track the last error.;;;","24/Apr/13 04:42;melix;Pull request: https://github.com/groovy/groovy-core/pull/170;;;","03/May/13 09:33;lhotari;I got a similar exception with 2.1.3 
{code}
java.lang.ArrayIndexOutOfBoundsException: size==0
	at org.codehaus.groovy.classgen.asm.OperandStack.doConvertAndCast(OperandStack.java:312)
	at org.codehaus.groovy.classgen.asm.OperandStack.doGroovyCast(OperandStack.java:296)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:584)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:507)
	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:457)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:321)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:278)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:398)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$15.call(CompilationUnit.java:794)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:506)
	at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:118)
	at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:39)
	at org.gradle.api.internal.tasks.compile.daemon.CompilerDaemonServer.execute(CompilerDaemonServer.java:52)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:355)
	at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:722)
{code}

reproducing problem:
{code}
git clone --branch stc-AIOBException-bug git://github.com/lhotari/grails-data-mapping.git
cd grails-data-mapping
./gradlew install -PskipTests -x signArchives
{code}

I wonder if this is the same bug?;;;","03/May/13 10:06;lhotari;There is another example in the stc-compilation-bug2 branch.

{code}
git clone --branch stc-compilation-bug2 git://github.com/lhotari/grails-data-mapping.git
cd grails-data-mapping
./gradlew install -PskipTests -x signArchives
{code}

removing the last commit makes it compile (git reset --hard HEAD~1).

It starts failing after adding @CompileStatic to HibernateGormStaticApi.
{code}
commit d97074e7391280f466b8787e0f9141bbd2d1175e
Author: Lari Hotari <lari.hotari@sagire.fi>
Date:   Fri May 3 17:59:28 2013 +0300

    Use CompileStatic in HibernateGormStaticApi

diff --git a/grails-datastore-gorm-hibernate4/src/main/groovy/org/codehaus/groovy/grails/orm/hibernate/HibernateGormStaticApi.groovy b/grails-datastore-gorm-hibernate4/src/main/groovy/org/codehaus/groovy/grails/orm/hibernate/HibernateGormStaticApi.groovy
index c2f9e78..1509698 100644
--- a/grails-datastore-gorm-hibernate4/src/main/groovy/org/codehaus/groovy/grails/orm/hibernate/HibernateGormStaticApi.groovy
+++ b/grails-datastore-gorm-hibernate4/src/main/groovy/org/codehaus/groovy/grails/orm/hibernate/HibernateGormStaticApi.groovy
@@ -56,7 +56,7 @@ import org.springframework.transaction.support.TransactionSynchronizationManager
  * @author Graeme Rocher
  * @since 1.0
  */
-//@CompileStatic
+@CompileStatic
 class HibernateGormStaticApi<D> extends GormStaticApi<D> {
     private static final EMPTY_ARRAY = [] as Object[]
{code}

however an almost similar class compiles in the hibernate3 module (hibernate4 module is copy&pasted from hibernate3 module currently):

{code}
diff grails-datastore-gorm-hibernate/src/main/groovy/org/codehaus/groovy/grails/orm/hibernate/HibernateGormStaticApi.groovy grails-datastore-gorm-hibernate4/src/main/groovy/org/codehaus/groovy/grails/orm/hibernate/HibernateGormStaticApi.groovy
{code}

The most essential difference is that the failing hibernate4 version has anonymous innerclasses, for example:

{code}
<         (List)hibernateTemplate.execute({Session session ->
<             ids = ids.collect { convertIdentifier((Serializable)it) }
<             def criteria = session.createCriteria(persistentClass)
<             hibernateTemplate.applySettings(criteria)
<             def identityName = persistentEntity.identity.name
<             criteria.add(Restrictions.'in'(identityName, ids))
<             def results = criteria.list()
<             def idsMap = [:]
<             for (object in results) {
<                 idsMap[object[identityName]] = object
<             }
<             results.clear()
<             for (id in ids) {
<                 results << idsMap[id]
---
>         (List)hibernateTemplate.execute(new GrailsHibernateTemplate.HibernateCallback() {
>             def doInHibernate(Session session) {
>                 ids = ids.collect { HibernateUtils.convertValueToType((Serializable)it, identityType) }
>                 def criteria = session.createCriteria(persistentClass)
>                 hibernateTemplate.applySettings(criteria)
>                 def identityName = persistentEntity.identity.name
>                 criteria.add(Restrictions.'in'(identityName, ids))
>                 def results = criteria.list()
>                 def idsMap = [:]
>                 for (object in results) {
>                     idsMap[object[identityName]] = object
>                 }
>                 results.clear()
>                 for (id in ids) {
>                     results << idsMap[id]
>                 }
>                 results
{code}

I had also other problems with anonymous innerclasses in CompileStatic and that explains some of the differences.

;;;","04/May/13 00:01;paulk;I suspect this is a separate issue.;;;","28/May/13 08:22;melix;@lari: regarding the issue you've seen in https://jira.codehaus.org/browse/GROOVY-6114?focusedCommentId=324642&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-324642

This is different, and was related to GROOVY-6180;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Class with @CompileStatic throws VerifyError when passing int constant to method taking varargs object array,GROOVY-6113,12816935,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,bborchardt,bborchardt,19/Apr/13 17:19,01/Jun/13 06:11,14/Jul/23 06:01,30/Apr/13 11:31,2.1.3,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,,,,0,,,,,,,"Run this code to reproduce the error:

{code}
@groovy.transform.CompileStatic
class MyClass {

    static void main(String[] args) {
        printObjects(MyConstants.MY_CONSTANT)
    }

    private static void printObjects(Object... objects) {
        for(Object o : objects) {
            println o
        }
    }
}

class MyConstants {
    public static final int MY_CONSTANT = 1
}
{code}","Windows 7, Java 6, 64-bit, Groovy 2.1.3",bborchardt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-04-19 17:19:38.0,,,,,,,,,,"0|i2c2jr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Access to java.lang.Object#delegate is forbidden with Gaelyk,GROOVY-6109,12816924,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,17/Apr/13 10:47,01/Jun/13 06:11,14/Jul/23 06:01,17/Apr/13 10:51,,,,,,,,,,,,,,,,,,2.1.4,,,,,,,,0,,,,,,,"Gaelyk uses AST transformations for queries and one of those throws an error at compile time when using {{@DelegatesTo}}:

{code}
Access to java.lang.Object#delegate is forbidden
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-04-17 10:47:21.0,,,,,,,,,,"0|i2bmnb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Null-safe operator on lhs of comparison may lead to NPE with @CompileStatic,GROOVY-6108,12816934,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,17/Apr/13 08:02,01/Jun/13 06:11,14/Jul/23 06:01,17/Apr/13 08:18,,,,,,,,,,,,,,,,,,2.1.4,,,,,,,,0,,,,,,,"The following code throws an NPE at runtime if compiled using {{@CompileStatic}}:

{code}
class A {
  int foo() { 123 }
}
A a = null
def bar = a?.foo() == 123 // will evaluate to false
assert bar == false
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-04-17 08:02:52.0,,,,,,,,,,"0|i2bnr3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unable to access an outer class static method from a super call in the inner-class constructor,GROOVY-6107,12818228,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,dmovchinn,dmovchinn,17/Apr/13 06:50,01/Feb/17 23:19,14/Jul/23 06:01,30/Sep/16 15:45,2.1.3,2.4.0-beta-3,,,,,,,,,,,,,,,,2.4.8,,,,groovy-runtime,,,,0,call,class,constructor,inner,outer,super,"The following code

{code}
import groovy.transform.*

//@CompileStatic
class X {
    
    final Y y = new Y();
    
    public static List<String> l() {
        return Arrays.asList(""a"", ""b"");
    }
    
    class Y extends ArrayList<String> {
        Y() {
            super(l());
        }
    }
}

new X()
{code}

works fine with @CompileStatic but doesn't work without it.

Full stack trace:
{noformat}
Apr 17, 2013 2:48:57 PM org.codehaus.groovy.runtime.StackTraceUtils sanitize
WARNING: Sanitizing stacktrace:
groovy.lang.MissingMethodException: No signature of method: static X$Y.l() is applicable for argument types: () values: []
Possible solutions: is(java.lang.Object), any(), min(), last(), pop(), tail()
	at groovy.lang.MetaClassImpl.invokeStaticMissingMethod(MetaClassImpl.java:1373)
	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1359)
	at org.codehaus.groovy.runtime.callsite.StaticMetaClassSite.callStatic(StaticMetaClassSite.java:62)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallStatic(CallSiteArray.java:53)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:157)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:161)
	at X$Y.<init>(super_call_bug.groovy:14)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
	at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:190)
	at X.<init>(super_call_bug.groovy:6)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
	at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:186)
	at super_call_bug.run(super_call_bug.groovy:19)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:257)
	at groovy.lang.GroovyShell.run(GroovyShell.java:481)
	at groovy.lang.GroovyShell.run(GroovyShell.java:163)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:951)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor207.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
	at groovy.lang.Closure.call(Closure.java:411)
	at groovy.lang.Closure.call(Closure.java:405)
	at groovy.lang.Closure.run(Closure.java:492)
	at java.lang.Thread.run(Thread.java:662)

groovy.lang.MissingMethodException: No signature of method: static X$Y.l() is applicable for argument types: () values: []
Possible solutions: is(java.lang.Object), any(), min(), last(), pop(), tail()
	at X$Y.<init>(super_call_bug.groovy:14)
	at X.<init>(super_call_bug.groovy:6)
	at super_call_bug.run(super_call_bug.groovy:19)
{noformat}","OpenSUSE 12.2
OpenJDK 1.7u17
Groovy 2.1.3",dmovchinn,jwagenleitner,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Apr/13 06:50;dmovchinn;super_call_bug.groovy;https://issues.apache.org/jira/secure/attachment/12723126/super_call_bug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 30 15:45:54 UTC 2016,,,,,,,,,,"0|i2cqq7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"02/Sep/14 16:02;pschumacher;Still occurs on current master. The exception is now:

>>> a serious error occurred: BUG! exception in phase 'instruction selection' in source unit 'outer.groovy' Declaring class for method call to 'java.util.List l()' declared in X was not matched with found receiver X$Y. This should not have happened!
>>> stacktrace:
BUG! exception in phase 'instruction selection' in source unit 'outer.groovy' Declaring class for method call to 'java.util.List l()' declared in X was not matched with found receiver X$Y. This should not have happened!
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.extractPlaceHolders(StaticTypeCheckingVisitor.java:4140)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.resolvePlaceHoldersFromDeclaration(StaticTypeCheckingVisitor.java:4080)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnTypeGenerics(StaticTypeCheckingVisitor.java:3932)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitStaticMethodCallExpression(StaticTypeCheckingVisitor.java:2040)
        at org.codehaus.groovy.ast.expr.StaticMethodCallExpression.visit(StaticMethodCallExpression.java:44)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitListOfExpressions(CodeVisitorSupport.java:273)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitTupleExpression(CodeVisitorSupport.java:178)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitArgumentlistExpression(CodeVisitorSupport.java:283)
        at org.codehaus.groovy.ast.expr.ArgumentListExpression.visit(ArgumentListExpression.java:74)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitConstructorCallExpression(CodeVisitorSupport.java:139)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorCallExpression(StaticTypeCheckingVisitor.java:1682)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitConstructorCallExpression(StaticCompilationVisitor.java:276)
        at org.codehaus.groovy.ast.expr.ConstructorCallExpression.visit(ConstructorCallExpression.java:44)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1622)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:119)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructor(StaticTypeCheckingVisitor.java:1918)
        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1059)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:240)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:118)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:244)
        at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:118)
        at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:61)
        at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
        at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1052)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:588)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:566)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:543)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:522)
        at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:59)
        at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:215)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:148)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:178)
        at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:162)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128);;;","30/Sep/16 15:45;jwagenleitner;Confirmed issue is fixed in 2_4_X (2.4.8-SNAPSHOT) and on master (2.5).  I believe (have not confirmed exact commit) the commit that fixed this was https://github.com/apache/groovy/commit/ed85b205cb269fa74837c5469433de60c302d9ba.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
A list of syntax highlighting errors,GROOVY-6106,12816943,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,asteingress,dmovchinn,dmovchinn,16/Apr/13 10:03,10/Jul/13 04:42,14/Jul/23 06:01,02/May/13 09:59,2.1.3,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,Groovy Console,,,,0,binary,highlighting,numbers,syntax,underscored,,"The Groovy Console does not perform syntax highlighting correctly for:
* hexadecimal numbers (0x....);
* binary numbers (0b....);
* numbers with underscores (90_000);
* empty strings concatenated with ""+"" operator","OpenJDK 1.7u17
OpenSUSE 12.3 i586
Groovy 2.1.3",asteingress,dmovchinn,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Apr/13 10:03;dmovchinn;list-of-sh-errors.png;https://issues.apache.org/jira/secure/attachment/12723167/list-of-sh-errors.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 18 04:29:05 UTC 2013,,,,,,,,,,"0|i2btlj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"17/Apr/13 13:22;asteingress;Changed the priority to ""minor"". ;;;","18/Apr/13 04:29;asteingress;Here is the pull request: https://github.com/groovy/groovy-core/pull/169;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unable to access static interface fields from classes annotated with @CompileStatic,GROOVY-6104,12816863,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,dmovchinn,dmovchinn,16/Apr/13 02:57,01/Jun/13 06:11,14/Jul/23 06:01,16/Apr/13 08:22,2.1.3,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,,,,0,,,,,,,"Any class that extends a class that implements an interface with a final static field cannot access it.

Example:

{code}
import java.awt.*;
import javax.swing.*;

import groovy.transform.*;

@CompileStatic
class MyFrame extends JFrame {
    MyFrame() {
        super(""My Frame"");
        defaultCloseOperation = DISPOSE_ON_CLOSE;
        preferredSize = new Dimension(800, 600);
        pack();
        locationRelativeTo = null;
    }
}

EventQueue.invokeLater {
    new MyFrame().visible = true;
}
{code}","Oracle JDK 1.6u43
Linux OpenSUSE 12.2 x86_64
Groovy 2.1.3",dmovchinn,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Apr/13 02:57;dmovchinn;csbug.groovy;https://issues.apache.org/jira/secure/attachment/12723168/csbug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 16 03:04:38 UTC 2013,,,,,,,,,,"0|i2cdmn:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"16/Apr/13 03:00;dmovchinn;Without @CompileStatic it is OK.;;;","16/Apr/13 03:04;melix;Confirmed. As a workaround, either use explicit prefix (WindowConstants.DISPOSE_ON_CLOSE) or import static:

{code}
import static javax.swing.WindowConstants.*
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
verify error with compile static ,GROOVY-6101,12816830,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,peterd,peterd,13/Apr/13 06:13,01/Jun/13 06:11,14/Jul/23 06:01,16/Apr/13 12:18,2.1.3,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,,,,0,,,,,,,"This method (full sample code attached)

{code}
    @CompileStatic
    int hashCode() {
        long hash = 0
        for (int i = 0; i < 64; i++)
            if (board[i]?.ordinal())
                hash = (hash * 13) + i + board[i].ordinal()

	int ret = (int) hash		
        return ret
    }
...
    Piece[] board = new Piece[64]
{code}

causes a verify error: java.lang.VerifyError: (class: Board, method: hashCode signature: ()I) Expecting to find integer on stack.

The problem seems to be related to the enum (""Piece"") that is used in ""board""; when i change board to int[], it works fine.
",,melix,peterd,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"13/Apr/13 06:13;peterd;staticcompileerror.groovy;https://issues.apache.org/jira/secure/attachment/12722940/staticcompileerror.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 16 12:18:23 UTC 2013,,,,,,,,,,"0|i2bw0v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Apr/13 09:39;melix;The error comes from the usage of the nullsafe operator on a method that returns a primitive type. I managed to reproduce the issue with this code:
{code}
class Piece {
    int x() { 333 }
}

@groovy.transform.CompileStatic
void foo() {
    Piece[] pieces = [new Piece(), null] as Piece[]
    int sum = 0
    for (int i=0;i<pieces.length;i++) {
        if (pieces[i]?.x()) {
            sum += pieces[i].x()
        }
    }
    assert sum == 333
}
foo()
{code}

When the nullsafe operator is called, the method call may return {{null}} but as we're statically compiling, the result is incompatible with the method signature of {{x}}.;;;","16/Apr/13 12:17;melix;Raising to critical because it shows another error which is critical:

{code}
 import groovy.transform.CompileStatic

@CompileStatic
class Foo {
   boolean hasSideEffect = false
   int x() { hasSideEffect=true; 333 }
}
            
@CompileStatic
void test() {            
   Foo foo = new Foo()
   if (foo.x()==null) {
      println 'ok'
   }
   assert foo.hasSideEffect
}

test()
{code}

This fails because the static compiler assumes that comparing an int to null will always return null. This is true, but we should *always* evaluate the LHS of the comparison because it can have side effects.;;;","16/Apr/13 12:18;melix;Thanks for spotting that!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic gives ClassCastException at runtime when calling methods on Object in some scenarios,GROOVY-6099,12816802,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,bborchardt,bborchardt,12/Apr/13 17:03,01/Jun/13 06:11,14/Jul/23 06:01,16/Apr/13 06:54,2.1.3,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,,,,0,,,,,,,"Execute the following code, it will throw the exception. You can replace the values 1 and [] with any two incompatible types.

{code:title=MyClass.groovy}
@groovy.transform.CompileStatic class MyClass {
    public static void main(String[] args) {
        Object o = getObject()
        if(o == null) {
            o = 1
        } else {
            println o.toString()
        }
    }

    public static Object getObject() {
        ''
    }
}
{code}","Windows 7, Java 6, Groovy 2.1.3",bborchardt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-04-12 17:03:55.0,,,,,,,,,,"0|i2ck1r:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"@CompileStatic fails to compile when accessing boolean property using ""isPropertyName()"" getter method",GROOVY-6098,12816932,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,bborchardt,bborchardt,12/Apr/13 16:34,01/Jun/13 06:11,14/Jul/23 06:01,18/Apr/13 04:47,2.1.3,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,,,,0,,,,,,,"The following code gives the error: [Static type checking] - The variable [booleanProperty] is undeclared. It works fine if the method is named ""getBooleanProperty"".

{code:title=MyClass.groovy}
@groovy.transform.CompileStatic
class MyClass {
    MyClass() {
        println booleanProperty
    }

    // this works fine if we name this getter ""getBooleanProperty""
    public boolean isBooleanProperty() {
        return true
    }
}
{code}","Windows 7, Java 6, Groovy 2.1.3",bborchardt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/Apr/13 16:34;bborchardt;MyClass.groovy;https://issues.apache.org/jira/secure/attachment/12723047/MyClass.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-04-12 16:34:35.0,,,,,,,,,,"0|i2csq7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Using super.propertyName gives a MissingMethodException when the property is a boolean and uses the ""isPropertyName"" naming convention.",GROOVY-6097,12816889,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,bborchardt,bborchardt,12/Apr/13 16:04,18/May/23 00:59,14/Jul/23 06:01,06/Dec/21 02:59,2.1.3,,,,,,,,,,,,,,,,,4.0.0-rc-2,,,,groovy-jdk,,,,1,,,,,,,"See the following code:

{code:title=MyClass.groovy}
class MyClass extends MySuperClass {
    public static void main(String[] args) {
        new MyClass()
    }

    MyClass() {
        println booleanProp // prints true
        println this.booleanProp // prints true
        println super.booleanProp // MissingMethodException
    }
}

class MySuperClass {
    boolean booleanProp

    boolean isBooleanProp() {
        return true
    }
}
{code}","Windows 7, Java 1.6, Groovy 2.1.3",bborchardt,emilles,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-11064,,,,GROOVY-10708,GROOVY-10707,,,,,,,,,,,,"12/Apr/13 16:04;bborchardt;MyClass.groovy;https://issues.apache.org/jira/secure/attachment/12722939/MyClass.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 06 02:59:48 UTC 2021,,,,,,,,,,"0|i2btzz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"06/Dec/21 02:59;emilles;https://github.com/apache/groovy/commit/7846085b07732a2370f76a22f2d350ea3ea9be0f;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static checker fails on correct code,GROOVY-6095,12816921,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mxm-groovy,mxm,11/Apr/13 04:40,08/Apr/22 16:14,14/Jul/23 06:01,27/May/13 06:39,,,,,,,,,,,,,,,,,,2.1.4,,,,,,,,0,,,,,,,"Sample project to reproduce attached

Static checker fails compiling the following code
{code}
import groovy.transform.CompileStatic

import javax.servlet.ServletContext
import javax.servlet.ServletRegistration

/**

 * author: Richard Vowles - http://gplus.to/RichardVowles
 */
@CompileStatic
class ServletExample {

  public void myMethod(ServletContext ctx) {
    ctx.getServletRegistrations().each { String name, ServletRegistration sr ->
      println name
    }

  }
}
{code}
with the message
{{Groovyc: [Static type checking] - Cannot call org.codehaus.groovy.runtime.DefaultGroovyMethods#each(java.util.Map <java.lang.String, java.lang.Object extends javax.servlet.ServletRegistration>, groovy.lang.Closure) with arguments [java.util.Map <java.lang.String, java.lang.Object extends javax.servlet.ServletRegistration>, groovy.lang.Closure]}}",,fpavageau,mxm,,,,,,,,,,,,,,"eric-milles commented on pull request #1123: GROOVY-6095, GROOVY-9338: check a wildcard's bounds instead of base type
URL: https://github.com/apache/groovy/pull/1123
 
 
   argument type is like ""Class<?>"" or ""Class<? extends X>"" and parameter type is like ""Class<? extends T>""; neither argument type is compatible
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;14/Dec/19 21:07;githubbot;600",,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,GROOVY-10576,,,,,,,,,,,,,"11/Apr/13 04:40;mxm;broken.zip;https://issues.apache.org/jira/secure/attachment/12723165/broken.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-04-11 04:40:38.0,,,,,,,,,,"0|i2bxs7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ImportNode doesn't contain line information,GROOVY-6094,12816808,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,11/Apr/13 03:43,12/Apr/13 16:55,14/Jul/23 06:01,12/Apr/13 02:35,,,,,,,,,,,,,,,,,,2.1.3,,,,,,,,0,,,,,,,"Line/column information is absent from some {{ImportNode}} nodes. This is especially critical for star imports, for which there's no workaround to find the line number.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 11 06:48:14 UTC 2013,,,,,,,,,,"0|i2c3if:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Apr/13 06:48;melix;Pull request: https://github.com/groovy/groovy-core/pull/161

Note that the PR makes use of node metadata, not because it's cool, but in order to avoid breaking binary compatibility with previous Groovy releases, by changing the return types of the various addImport methods ;);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@XmlEnumValue annotation is lost from enum constant during compilation,GROOVY-6093,12816908,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jcttrll,jcttrll,10/Apr/13 20:45,12/Apr/13 16:55,14/Jul/23 06:01,11/Apr/13 16:07,2.1.2,,,,,,,,,,,,,,,,,2.1.3,2.2.0-beta-1,,,Compiler,,,,0,annotation,enum,jaxb,XmlEnumValue,,,"Consider the following enum, defined using Groovy (package and imports omitted):

@XmlEnum
enum GroovyEnum {
	@XmlEnumValue(""good"")
	BAD
}

When marshaling the enum as part of a larger object graph using JAXB, the expected behavior is that ""good"" will be the value of the generated XML element or attribute, as per the definition of the @XmlEnumValue annotation. In actuality, the value is marshaled as the enum constant name, ""BAD"".

Further investigation indicates the @XmlEnumValue annotation cannot be found on GroovyEnum.BAD via reflection at runtime; it has been ""lost"" during compilation.

Creating an identical (as much as permitted by syntax) enum in Java works as expected when used in a Groovy compilation.

The attached Zip archive contains a set of files demonstrating the behavior, as driven by a JUnit 4 test case (JaxbMarshalingTest.groovy). GroovyEnum.groovy is the class being compiled incorrectly. Also included in the archive is JavaEnum.java; references to GroovyEnum can be trivially replaced with JavaEnum to demonstrate expected behavior.","OS: Windows 7, Windows XP
JVM: 1.7.0_17 (Oracle)",jcttrll,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Apr/13 20:45;jcttrll;groovy-enum-annotation-bug.zip;https://issues.apache.org/jira/secure/attachment/12723125/groovy-enum-annotation-bug.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 11 16:07:08 UTC 2013,,,,,,,,,,"0|i2ccvj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"10/Apr/13 22:26;paulk;Looks to me like a bug in AntlrParserPlugin#enumConstantDef(). I think we need to save the annotations and add them to the created enumField. I can't see this happening anywhere in the current code.;;;","11/Apr/13 16:07;paulk;Fixed, thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Explicit use of ""delegate"" doesn't make use of @DelegatesTo",GROOVY-6091,12816860,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,10/Apr/13 09:07,12/Apr/13 16:55,14/Jul/23 06:01,10/Apr/13 09:31,2.1.2,,,,,,,,,,,,,,,,,2.1.3,,,,Static compilation,Static Type Checker,,,0,,,,,,,"If a method is annotated with {{@DelegatesTo}} and that code in a closure explicitely uses ""delegate"", the type checker doesn't use the type information available thanks to {{@DelegatesTo}}.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-04-10 09:07:31.0,,,,,,,,,,"0|i2cbs7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"@CompileStatic problem with methods returning array of Objects - Error msg: ""Cannot return value of type [LSomeClass; on method returning type SomeClass[]""",GROOVY-6086,12816913,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lhotari,lhotari,07/Apr/13 23:11,12/Apr/13 16:55,14/Jul/23 06:01,08/Apr/13 10:20,2.1.2,,,,,,,,,,,,,,,,,2.0.8,2.1.3,,,Static compilation,Static Type Checker,,,0,,,,,,,"Using @CompileStatic in Grails grails.util.PluginBuildSettings class causes this kind of compilation errors:

{code}
[Static type checking] - Cannot return value of type [Lorg.codehaus.groovy.grails.io.support.Resource; on method returning type org.codehaus.groovy.grails.io.support.Resource[]
{code}

I've tried to isolate the problem, but I didn't succeed. I pushed a branch that has the compile error in it. 

reproducing problem:
{code}
git clone -b cs-bug-arrays https://github.com/grails/grails-core.git
cd grails-core
// git fetch && git checkout cs-bug-arrays
./gradlew install -PskipTests -x signArchives -x docs -x javadoc -x gdoc -x groovydoc -x javadocJar -x sourcesJar
{code}",,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 08 13:39:41 UTC 2013,,,,,,,,,,"0|i2c2en:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Apr/13 23:59;lhotari;Upgrading to Groovy 2.1.2 version seems to break the build:

this fails (after upgrading to Groovy 2.1.2):
{code}
git checkout e8224f4e0ff63ae62eb4fc7d3d4c3b18c7310fdf
./gradlew install -PskipTests -x signArchives -x docs -x javadoc -x gdoc -x groovydoc -x javadocJar -x sourcesJar
{code}

this compiles (before upgrading to Groovy 2.1.2):
{code}
git checkout bddcd880eb374907bdf55a0082e7bc6c5f0c8cc2
./gradlew install -PskipTests -x signArchives -x docs -x javadoc -x gdoc -x groovydoc -x javadocJar -x sourcesJar
{code};;;","08/Apr/13 07:08;melix;Can you double check, but it seems for me that {{2.1.3-SNAPSHOT}} doesn't have the problem so I probably fixed this ""by accident"".;;;","08/Apr/13 07:22;melix;Forget the previous comment: it fails with 2.1.3-SNAPSHOT too, this is because I didn't do a ""clean"" before. But it gives a hint about the problem...;;;","08/Apr/13 10:20;melix;See https://github.com/groovy/groovy-core/commit/d015ba5a3912eb63df82083efad6f7d8807f79d4;;;","08/Apr/13 13:39;lhotari;Great work Cedric! Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Annotation for inner interface in Java stub should not use dollar notation,GROOVY-6085,12818232,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,agrimm,agrimm,07/Apr/13 19:12,05/Apr/15 14:44,14/Jul/23 06:01,04/Jul/13 03:12,1.7.11,1.7.4,1.8.8,,,,,,,,,,,,,,,2.1.6,2.2.0-beta-1,,,Stub generator / Joint compiler,,,,1,,,,,,,"From looking at the code, this issue appears to affect all versions after 1.7.3, but I've only tested a few.

As with many other places in the code, printAnnotation needs to replace '$' with '.' in inner interface class names.  Otherwise a ""cannot find symbol"" error occurs during java compilation.

In 1.7.4, the patch is:

{noformat}
diff --git a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
index eff3ac1..7a1e92e 100644
--- a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
+++ b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
@@ -591,7 +591,7 @@ public class JavaStubGenerator
     private void printAnnotations(PrintWriter out, AnnotatedNode annotated) {
         if (!java5) return;
         for (AnnotationNode annotation : annotated.getAnnotations()) {
-            out.print(""@"" + annotation.getClassNode().getName() + ""("");
+            out.print(""@"" + annotation.getClassNode().getName().replace('$', '.') + ""("");
             boolean first = true;
             Map<String, Expression> members = annotation.getMembers();
             for (String key : members.keySet()) {
{noformat}

In master, it would be:

{noformat}
diff --git a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
index 1e8f585..42fc5e2 100644
--- a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
+++ b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
@@ -716,7 +716,7 @@ public class JavaStubGenerator {
     }
 
     private void printAnnotation(PrintWriter out, AnnotationNode annotation) {
-        out.print(""@"" + annotation.getClassNode().getName() + ""("");
+        out.print(""@"" + annotation.getClassNode().getName().replace('$', '.') + ""("");
         boolean first = true;
         Map<String, Expression> members = annotation.getMembers();
         for (String key : members.keySet()) {
{noformat}",,agrimm,dream_brother,esword,guillaume,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"19/Jun/13 09:58;esword;groovy-annots.zip;https://issues.apache.org/jira/secure/attachment/12722387/groovy-annots.zip","21/Jun/13 10:03;esword;groovy-annots2.zip;https://issues.apache.org/jira/secure/attachment/12722658/groovy-annots2.zip",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Fri Jul 05 22:13:03 UTC 2013,,,,,,,,,,"0|i2c6lb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/May/13 06:36;paulk;Andy, do you have a small example which currently fails?;;;","11/May/13 14:01;agrimm;Hi, Paul, thanks for responding.  I have an example, but it's unfortunately not small.  I ran into this problem while compiling eucalyptus, and I have since moved on to other projects.  I will try to make another attempt.  For now, I can point you to where the inner interface is defined, and the reference to it which fails.

First, the interface:

https://github.com/eucalyptus/eucalyptus/blob/master/clc/modules/msgs/src/main/java/com/eucalyptus/component/ComponentId.java#L141

Then, the reference:

https://github.com/eucalyptus/eucalyptus/blob/master/clc/modules/reporting/src/main/java/com/eucalyptus/reporting/service/ReportingMessages.groovy#L30

The compilation of the latter, which is being compiled using a groovyc task in ant, is defined here:

https://github.com/eucalyptus/eucalyptus/blob/master/clc/modules/module-inc.xml#L206

and fails with:

{noformat}
  [groovyc] /tmp/groovy-generated-5530094202277916256-java-source/com/eucalyptus/reporting/service/ReportingMessage.java:11: error: cannot find symbol
  [groovyc] @com.eucalyptus.component.ComponentId$ComponentMessage(value=Reporting.class) public class ReportingMessage
  [groovyc]                          ^
  [groovyc]   symbol:   class ComponentId$ComponentMessage
  [groovyc]   location: package com.eucalyptus.component
{noformat}

Sorry, that's not a great test case for you.  I'll try to prune it down.;;;","11/May/13 14:27;agrimm;Also, FWIW, related links:

https://eucalyptus.atlassian.net/browse/EUCA-2993
https://bugzilla.redhat.com/show_bug.cgi?id=949352

We've already applied this patch to groovy in Fedora.;;;","11/May/13 23:04;paulk;Any chance you could try with some recent versions of Groovy? Adding your change certainly doesn't fail any existing test in our test suite but my attempts to reproduce the error have failed so far. Calling getName() seems to be currently returning the '.' version. I haven't traced it through to see if there was an underlying change that caused this fix by accident but none of the Jira issues for Java stubs over the last 12 months seem to indicate they did such a change.;;;","19/Jun/13 09:58;esword;Here is a tiny project that shows the problem when using gradle to build, though the problem occurs with ant as well.  I am hitting the problem in a real project that is using the Jackson JsonInclude annotation, but simplified the sample project so it is entirely self contained.  I reproduced the issue with with groovy 1.8.4, 2.1.4, 2.1.5, and the 2.1.6 and 2.2.0 snapshot releases as of last night.

I tried all sorts of combinations for writing the annotation - full class path, import statics, etc.  The stub is always generated wrong.

Note that Intellij and Eclipse both seem to work fine.  I checked the stubs from intellij and it just leaves out the annotations, so that may be why.

This is killing us.  May have to move a ton of class from groovy to java just to work around this unless anyone has another idea?  Like can I slip a step into the gradle build that would let me hack the stub and change the $ to a .?;;;","21/Jun/13 06:22;paulk;Erik and Andy, once the CI builds have done there thing (over the next hour or two), can you check the 2.1.6 and 2.2.0 snapshot releases. I just pushed a fix. Tests to follow but if you can confirm whether it is fixed for you, that would be great. Thanks.;;;","21/Jun/13 06:28;paulk;Erik, even after the latest changes, your gradle build still failed for me - not sure whether gradle uses its own version of groovy for stub generation or whether there was some snapshot jar caching going on. Anyway, this worked from the commandline (shown for windows):
{noformat}
> C:\groovy-github\target\install\bin\groovyc -j --sourcepath src\main\java;src\main\groovy src\main\groovy\example\AnnotatedClass.groovy src\main\java\example\annot\TestAnnot.java src\main\groovy\example\sub\SomethingThatUsesAnnotatedClass.java
{noformat}
;;;","21/Jun/13 10:03;esword;Paul - thanks for the fast response.  I used gradle to pull the 2.1.6 snapshot about 90 minutes ago and verified it was the same as the latest on the download site - groovy-all-2.1.6-20130621.110245-3.jar.  As you said, the gradle build still failed.  Looking at the debug log output (build16.log in the new zip I have attached), I see an older version of groovy (1.8.6) listed in some of the classpath statements, but I can't tell if that really interferes or not.

I also tried a simple ant build (also included in the new zip) and got strange results.  The first time I do a compile, it works.  The second time I compile, it fails, and it will continue to fail until I do a clean and then build again.  (See ant.log file.)  Very odd.  I couldnât find docs for an option to force it to keep the stub files after compilation was done, so I couldnât verify that the stubs were being generated correctly one time and incorrectly the next.

The new zip does not have the groovy jar in the lib dir for the ant build since I didnât want to push up a 6M file.  Let me know if you want it to have a complete set up.;;;","21/Jun/13 14:40;pschumacher;Hello Eric,

the build with the Pauls (partial) fix for this issue did hang on the buildserver. I restarted it and finished just a few minutes ago. If you have the time can you give this build a try?

Edit: Please disregard my comment, as I can not find the new jar in the repository yet. Sorry!;;;","23/Jun/13 05:16;paulk;Eric,

When placing the latest groovy-all snapshot jar in your lib directory (groovy-all-2.2.0-20130621.195639-198.jar) the ant build seems to consistently build OK. It would be great if you could confirm.

P.S. If you want to keep the stubs, check out the comments in GROOVY-4432.;;;","29/Jun/13 11:41;esword;Confirmed with the 2.1.6 SNAPSHOT this morning - no more compile errors.  I think this bug is fixed.  Sorry for the delay in checking it.  Been fighting another issue with groovy and proxy problems with spring security annotations.  I'll likely be filing something with that soon, though most likely with the spring team I think.;;;","04/Jul/13 02:57;dream_brother;I cannot use Jackson polymorphic types in Groovy, because of this issue.

{code}@JsonSubTypes.Type{code} is transformed to {code}@org.codehaus.jackson.annotate.JsonSubTypes$Type{code}

{code}
[ERROR] /home/nik/repos/web_client/target/generated-sources/groovy-stubs/main/ru/round/domain/payments/requisites/PaymentRequisites.java:[10,1378] cannot find symbol
[ERROR] symbol:   class JsonSubTypes$Type
[ERROR] location: package org.codehaus.jackson.annotate
{code};;;","04/Jul/13 03:11;guillaume;This should be fixed in the next 2.1.6 release.;;;","04/Jul/13 05:29;guillaume;I've added a test for non-regression.
But even removing the {{replace('$', '.')}} doesn't make the test fail.
We might have fixed the ClassNode's name upper the chain.;;;","05/Jul/13 22:13;paulk;Thanks Guillaume.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyResultSet not updateable for Prepared Statements,GROOVY-6082,12818227,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,eddelplus,eddelplus,04/Apr/13 15:47,12/Apr/13 16:55,14/Jul/23 06:01,04/Apr/13 22:30,2.1.1,,,,,,,,,,,,,,,,,2.1.3,2.2.0-beta-1,,,SQL processing,,,,0,,,,,,,"sql.resultSetConcurrency = java.sql.ResultSet.CONCUR_UPDATABLE

  followed by

sql.eachRow('select * from WINE where ID=?', [data.ID]) { ... }

  results in exception from underlying H2 database when trying to change the result set within the closure.

The result set is readonly. You may need to use conn.createStatement(.., ResultSet.CONCUR_UPDATABLE). [90140-170]

  Whereas this works:

sql.eachRow('select * from WINE where ID=' + data.ID) { ... }

  Some tentative debugging in groovy.sql.Sql failed to reach a break point set at the place where Statements are created utilizing the Sql.resultSetConcurrency property. Suspicion is, that there is a separate bit of code for PreparedStatements where Sql.resultSetConcurrency is currently disregarded.",JDK 6u37 x86 on Win7/SP1 x64 with H2 1.3.170,eddelplus,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 04 22:30:03 UTC 2013,,,,,,,,,,"0|i2c83r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Apr/13 22:30;paulk;Indeed, the PreparedStatement path through the code didn't set the appropriate flags. It should do so now. Please try out a snapshot release if you can to see if it works for you. Thanks for spotting the issue and your investigative work which lead straight to the problem.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
IncompatibleClassChangeError: the number of constructors during runtime and compile time,GROOVY-6080,12818504,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pablo72,pablo72,04/Apr/13 04:56,20/Nov/14 03:46,14/Jul/23 06:01,29/Oct/13 06:59,2.1.2,,,,,,,,,,,,,,,,,2.1.9,2.2.0-rc-2,,,,,,,7,,,,,,,"Exception classes compiled with Java 6 raise the following error running the application using Java 7 

java.lang.IncompatibleClassChangeError: the number of constructors during runtime and compile time for java.lang.Exception do not match. Expected 4 but got 5
	at groovy.lang.MetaClassImpl.selectConstructorAndTransformArguments(MetaClassImpl.java:1410) ~[groovy-all-2.1.2.jar:2.1.2]
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.selectConstructorAndTransformArguments(ScriptBytecodeAdapter.java:234) ~[groovy-all-2.1.2.jar:2.1.2]
	at nextflow.exception.TaskValidationException.<init>(TaskValidationException.groovy) ~[main.jar:na]
	at nextflow.exception.InvalidExitException.<init>(TaskValidationException.groovy) ~[main.jar:na]
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.7.0_09]
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source) ~[na:1.7.0_09]
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source) ~[na:1.7.0_09]
	at java.lang.reflect.Constructor.newInstance(Unknown Source) ~[na:1.7.0_09]
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77) ~[groovy-all-2.1.2.jar:2.1.2]
	at org.codehaus.groovy.reflection.CachedConstructor.doConstructorInvoke(CachedConstructor.java:71) ~[groovy-all-2.1.2.jar:2.1.2]
	at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrap.callConstructor(ConstructorSite.java:81) ~[groovy-all-2.1.2.jar:2.1.2]
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57) ~[groovy-all-2.1.2.jar:2.1.2]
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182) ~[groovy-all-2.1.2.jar:2.1.2]
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:190) ~[groovy-all-2.1.2.jar:2.1.2]


See also 

http://blog.proxerd.pl/article/how-to-fix-incompatibleclasschangeerror-for-your-groovy-projects-running-on-jdk7","Java 6, Java 7",alrodgers,blackdrag,lhotari,paolodt,sukrit007,tjwebb,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 20 03:46:24 UTC 2014,,,,,,,,,,"0|i2c0fr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Aug/13 14:25;tjwebb;This bug is also causing issues in Grails: http://jira.grails.org/browse/GRAILS-10336;;;","15/Oct/13 07:19;lhotari;The exception is thown here:
https://github.com/groovy/groovy-core/blob/GROOVY_2_1_X/src/main/groovy/lang/MetaClassImpl.java#L1409 

Java 7 adds 5th constructor:
http://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html#Exception%28java.lang.String,%20java.lang.Throwable,%20boolean,%20boolean%29;;;","15/Oct/13 23:04;lhotari;Marking a exception class with @CompileStatic is a possible workaround after Groovy 2.1.9 , GROOVY-6390 is the related issue.;;;","19/Nov/14 14:37;sukrit007;So this worked when I compiled my code in JDK6 but ran in JDK7 ....    

However, if I compile in JDK7 with JDK6 compatibility but run in JRE6,  CompileStatic does not help.   Mainly our build and dev environment is using JDK7 , but production env. has not yet been migrated to JDK7 yet.

Groovy 2.1.9;;;","20/Nov/14 03:46;blackdrag;CompileStatic must help, because it is not using the infrastructure that caused the problem. A class recompiled with Groovy 2.1.9 on JDK7 and run on JDK6 cannot produce the error message given in this issue anymore. If you are still getting this message, then you did not use Groovy 2.1.9 for compilation.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Chained null-safe navigation is broken in CompileStatic mode,GROOVY-6078,12816861,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lhotari,lhotari,03/Apr/13 02:50,12/Apr/13 16:55,14/Jul/23 06:01,03/Apr/13 15:19,2.1.2,,,,,,,,,,,,,,,,,2.1.3,,,,Static Type Checker,,,,0,,,,,,,"Chained elvis is broken in CompileStatic mode. Here's an example that reproduces the problem:

{code}
@groovy.transform.CompileStatic
def elvisNPE() {
    Map<String, Map<String,Integer>> m=[:]
    // this is ok
    println m?.a 
    // throws NPE   
    println m?.a?.b
}
elvisNPE()
{code}",,lhotari,pledbrook,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 03 12:04:31 UTC 2013,,,,,,,,,,"0|i2btdb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Apr/13 08:46;pledbrook;Do you really mean Elvis here? That example looks suspiciously like it's using the null-safe navigation operator.;;;","03/Apr/13 12:03;lhotari;oh sorry I made a naming mistake. Elvis is so cool that I totally forgot it's a different thing. Yes, I mean null-safe navigation. (I don't have permission to rename the issue);;;","03/Apr/13 12:04;lhotari;please rename to something like ""Chained null-safe navigation is broken in CompileStatic mode"";;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Dynamic dispatch fails to recognize updates in the meta-class,GROOVY-6077,12818460,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,roller_vaclav,roller_vaclav,03/Apr/13 00:56,15/Oct/15 18:19,14/Jul/23 06:01,23/Dec/13 07:14,2.1.1,2.1.2,,,,,,,,,,,,,,,,2.2.2,,,,groovy-runtime,,,,1,,,,,,,"{code}
def a = new Dummy()
//def a = new Object()
Closure cl = {a.foo()}

a.metaClass.foo {println ""Original version""}
cl(1.5G)

a.metaClass.foo {println ""Updated version""}
cl(1.5G)

class Dummy {}
This issue imposes some problems on GPars DynamicDispatchActors:

{code}

This script outputs:
Original version
Original version

while I would expect
Original version
Updated version

Additionally, the behavior differs depending on whether ""a"" is an instance of a Java or a Groovy class. After making ""a"" an instance of a Java class, I get the expected output.",,blackdrag,lhotari,russel,venca,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 23 07:14:57 UTC 2013,,,,,,,,,,"0|i2bw3z:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"23/Dec/13 07:14;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"The compiler doesn't honor the ""target bytecode"" flag",GROOVY-6075,12816874,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,02/Apr/13 12:15,12/Apr/13 16:55,14/Jul/23 06:01,02/Apr/13 13:15,,,,,,,,,,,,,,,,,,2.1.3,,,,,,,,0,,,,,,,"The compiler configuration supports a {{target bytecode}} flag, but currently only {{1.5}} or {{1.6}} are supported. The compiler should honor what the user requests and set the class version to the appropriate value.

This includes support for {{1.6}} or {{1.7}}. Future versions should include support for {{1.8}} when ASM5 is out.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-04-02 12:15:57.0,,,,,,,,,,"0|i2bp2v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"`String | []` represented as ClassExpression in AST (causing problems in Spock data tables)",GROOVY-6072,12816801,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pniederw,pniederw,01/Apr/13 06:36,15/Oct/15 18:19,14/Jul/23 06:01,14/Aug/13 03:55,1.8.9,2.1.1,,,,,,,,,,,,,,,,2.1.3,,,,Compiler,,,,0,,,,,,,"The expression {{String | []}} is represented as a {{BinaryExpression}} after the _conversion_ phase (as expected), but as a {{ClassExpression}} after the _semantic analysis_ phase (as if it was {{String[]}}). This causes problems in Spock data tables. Same with other binary operators (e.g. {{String && []}}).",,melix,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 03 12:13:39 UTC 2013,,,,,,,,,,"0|i2cjaf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Apr/13 12:13;melix;Well spotted. See https://github.com/groovy/groovy-core/commit/36bfcaa05e70fef0c343c1a474fcc345c122d83a for explanation!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
br null no longer works in builder - generates invalid HTML,GROOVY-6071,12816849,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mlzarathustra,mlzarathustra,28/Mar/13 19:56,29/Mar/13 20:03,14/Jul/23 06:01,29/Mar/13 20:03,2.1.1,,,,,,,,,,,,,,,,,,,,,Groovlet / GSP,XML Processing,,,0,,,,,,,"It used to be that I could achieve a valid <br/> tag by saying 

html.html {
   body {
     br null
   }
}

(in a groovlet, e.g. from netbeans or tomcat)

But now instead, it outputs <br></br> which firefox flags as invalid HTML.  It also gives me two line breaks instead of one, so there is no way to get a single line break that I could find, other than using 

mkp.yieldUnescaped('<br/>')

I'm not sure of all the ins and outs of valid XHTML and doctypes (I'm not using one) but at the very least, the 'br null' behavior of generating <br/> was useful.


Thanks,
  -= miles =-","windows, linux",mlzarathustra,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 29 20:03:45 UTC 2013,,,,,,,,,,"0|i2brrj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Mar/13 20:49;paulk;Both MarkupBuilder (the default for Groovlets) and StreamingMarkupBuilder have an expandEmptyElements property which flips between the two behaviors but it should default to the original behavior. Also just empty brackets after the br (i.e. {{br()}}) is the usually preferred style with the markup builders rather than using null.;;;","28/Mar/13 20:52;paulk;Does this script work correctly for you?
{code}
def sw = new StringWriter()
def mb = new groovy.xml.MarkupBuilder(sw)
mb.br()
assert sw.toString() == '<br />'
{code};;;","29/Mar/13 14:44;mlzarathustra;The script does work.

When I set html.expandEmptyElements=false, the tomcat version works.  So apparently the default setting is true, which is not the original behavior.

I'm using the standard (I think) setup, adding the following to WEB-INF/web.xml:
{noformat}
<servlet>
  <servlet-name>Groovy</servlet-name>
  <servlet-class>groovy.servlet.GroovyServlet</servlet-class>
</servlet>

<servlet-mapping>
  <servlet-name>Groovy</servlet-name>
  <url-pattern>*.groovy</url-pattern>
</servlet-mapping>
{noformat} 

I couldn't find a way to display the version dynamically 
(println org.codehaus.groovy.runtime.InvokeHelper.getVersion() gave an error)
but it should be 2.1.1


;;;","29/Mar/13 19:44;paulk;Yes, just checked the code and javadoc for ServletBinding. Indeed it sets expandEmptyElements to true for its MarkupBuilder (bound to the html variable). Looking back at the history, e.g. GROOVY-4864, it seems this was to avoid things like <textarea/> which apparently played havoc with certain browsers. So, it seems there are potential issues with both defaults.;;;","29/Mar/13 19:51;mlzarathustra;thanks for looking into it.
I hope I remember that setting!;;;","29/Mar/13 20:03;paulk;No problems, I will close the issue for now - somehow I think we might need to have a better solution for this at some point.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Thread safety issue in AntBuilder leads to major memory leak,GROOVY-6068,12816867,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,frenchyan,frenchyan,26/Mar/13 19:48,12/Apr/13 16:55,14/Jul/23 06:01,29/Mar/13 23:36,2.0.7,,,,,,,,,,,,,,,,,2.1.3,2.2.0-beta-1,,,Ant integration,,,,0,,,,,,,"The code in {{AntBuilder}} which manipulates the standard input and output stream is not thread safe: https://github.com/groovy/groovy-core/blob/GROOVY_2_0_7/subprojects/groovy-ant/src/main/java/groovy/util/AntBuilder.java#L207

If 2 or more threads are using {{AntBuilder}} at the same time then you end up with System.out or System.err holding a reference to a {{DemuxOutputStream}}.

Unfortunately this class ({{DemuxOutputStream}}) ends up (via a long chain of objects) to hold references to {{AntTypeDefinitions}} classes which are then never garbage collected.

After I ran my code for a long time, I used JProfiler and generated the attached screenshot. I had over 180,000 instances of {{AntTypeDefinitions}} (and growing...)

I just checked the trunk on github for {{groovy-core}} and can see it is the same code since 2.0.7. So I am assuming it is the same issue.",,frenchyan,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Mar/13 19:18;frenchyan;Groovy6068.groovy;https://issues.apache.org/jira/secure/attachment/12723124/Groovy6068.groovy","26/Mar/13 19:48;frenchyan;Screen Shot 2013-03-26 at 1.58.54 PM.png;https://issues.apache.org/jira/secure/attachment/12722936/Screen+Shot+2013-03-26+at+1.58.54+PM.png",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 29 23:36:51 UTC 2013,,,,,,,,,,"0|i2bz7r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Mar/13 23:59;paulk;Possibly a duplicate of (or related to) GROOVY-3488. Not sure I would consider it a blocker - it is likely this issue has been around for numerous years with people working around it by various means. Obviously we would still want to fix it. Patches welcome. :-);;;","28/Mar/13 16:17;frenchyan;Of course I cannot judge the level of priority of a bug and I think the final decision definitely needs to be made by the owners/maintainers of the project. The way I look at it is that groovy is a language used by many people and frameworks (ex: grails). As such, having a bug that leads to a memory leak is definitely bad. This is why I think it is pretty important to fix it (note that I am pointing out exactly where the bug is, not ""there is a memory leak, I don't know where it is"").

In regards to the bug itself, I have done some more thinking about it and really (besides not being thread safe), the big issue is manipulating {{System.xxx}} during the life of the application. I checked the apache ant (1.8.2) source code and the *only* place where the {{DemuxOutputStream}} class is used and assigned to {{System.xxx}} seems to be when {{ant}} is invoked on the command line which does make sense. Manipulating {{System.xxx}} during the life of the application does not make sense. If any other thread (even without triggering the thread safety bug I mentioned), issue a {{System.out.println(...)}}, it will be funneled to the {{DemuxOutputStream}} which does not make sense.

I am no expert in apache ant, so I cannot speak to why this is done. From my quick understanding, it seems that the main purpose is so that if any (ant) task ends up using {{System.xxx}} instead of the log associated to the task, it still gets funneled into the log associated to the task. This would require somebody familiar with the ant code base to chime in...

On my end, I ""hacked"" around by entirely copying/pasting the {{AntBuilder}} class into a {{AntBuilder6068}} class and simply commenting out the use of {{System.xxx}}. All my test and my program seems to work fine (the memory leak is gone). I do not know if this is the proper fix and what are the exact consequences of doing it. But it is clear that tweaking {{System.xxx}} is just wrong.
;;;","28/Mar/13 17:34;paulk;Adjusting priority down - agree that it is important but blocker would mean we don't ever release again under any circumstances until this is fixed. I will put together a solution to hopefully make it thread-safe and allow stream ""saving"" to be disabled. If you could test it, that would be great. I will add a subsequent comment when it is ready.;;;","28/Mar/13 19:18;frenchyan;Here is a small test (attached) demonstrating the issue. Simply run it with {{groovy Groovy6068}} and you will (sooner or later) get an exception like this:

{code}
Caught: java.lang.Exception: detected issue: org.apache.tools.ant.DemuxInputStream
java.lang.Exception: detected issue: org.apache.tools.ant.DemuxInputStream
	at Groovy6068$_run_closure1_closure4.doCall(Groovy6068.groovy:27)
	at Groovy6068$_run_closure1.doCall(Groovy6068.groovy:23)
	at Groovy6068.run(Groovy6068.groovy:8)
{code}

If you change {{nbThreads}} to {{1}} the problem does not manifest itself;;;","28/Mar/13 19:19;frenchyan;@Paul: I will gladly review the code change if you want me to...;;;","28/Mar/13 22:11;paulk;If you can try the snapshot jar that would be great. All version (if that is what you are using) is here:

http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all/2.2.0-SNAPSHOT/

Look for the latest timestamped jar.

Thanks, Paul.;;;","29/Mar/13 18:52;frenchyan;I am not sure how to use the jar file. When I try it like this:

{code}
java -jar groovy-all-2.2.0-20130329.082238-105.jar Groovy6068.groovy
{code}

I get exceptions:

{code}
Caused by: java.lang.ClassNotFoundException: org.apache.tools.ant.BuildException
	at java.net.URLClassLoader$1.run(URLClassLoader.java:202)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
{code}

What is the proper way to test it out?

Thanks
Yan;;;","29/Mar/13 19:55;paulk;The all jar doesn't bundle ant. Just add the appropriate ant jar(s) to your classpath. Alternatively, it will probably be good enough to rename to groovy-all-2.1.2.jar (or whatever version you are using) and drop it into your current distribution (back up the original might be useful). Note you might need the non-all jar depending on how you have things set up (e.g. using groovy from the commandline). Also, see here:
http://stackoverflow.com/questions/12391985/when-running-groovy-scripts-using-the-groovy-all-jar-how-do-you-specify-a-class
about calling via GroovyMain if you use the approach of adding jars to your Java classpath.;;;","29/Mar/13 23:05;frenchyan;I just tried with {{groovy-all-2.2.0-20130329.082238-105.jar}} and the problem is indeed gone. I left a couple of comments on github in regards to the change: on one end the thread safety issue is definitely addressed which means the memory leak won't happen again which is really good, but on the other end I am not sure what the right approach really is to handle what {{ant}} is trying to achieve exactly. I guess again, the good news is that in that regard it is not worse than how it was prior to this change :);;;","29/Mar/13 23:36;paulk;Thanks for raising the issue and your testing of the solution.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MetaClassImpl triggers new entries for maps with default,GROOVY-6067,12815580,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,melix,melix,22/Mar/13 10:30,22/Feb/16 20:48,14/Jul/23 06:01,15/Nov/15 10:53,1.8.9,2.1.2,,,,,,,,,,,,,,,,2.4.6,,,,groovy-jdk,,,,0,,,,,,,"The following code:
{code}
def map = [:].withDefault { 'foo' }
Map.metaClass.bar = { -> 'ok' }
assert map.bar() == 'ok'
assert !map.containsKey('bar')

println map.keySet()
{code}

Fails at the second assertion, because MetaClassImpl triggers an unexpected get() into the map.

Note that the behaviour is not the same if you use a per instance MC, which probably means inconsistencies...
",,melix,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 15 10:53:51 UTC 2015,,,,,,,,,,"0|i2chbj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Nov/15 10:53;pascalschumacher;Script works with 2.4.6, therefore I'm resolving this issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Overriding enum methods in constant specific body does not work if non-default constructor is used,GROOVY-6065,12818220,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,zsolt.varszegi,zsolt.varszegi,21/Mar/13 07:28,12/Apr/13 16:55,14/Jul/23 06:01,23/Mar/13 05:55,2.1.2,,,,,,,,,,,,,,,,,2.0.8,2.1.3,2.2.0-beta-1,,,,,,2,,,,,,,"This works as expected:

{code}
enum Country {
    Hungary,
    Italy,
    Poland{ String getCountryCode() { 'pl' } }
    
    String getCountryCode() { 
         name()[0..1].toLowerCase()
     }
}

assert Country.Hungary.countryCode == 'hu'
assert Country.Italy.countryCode == 'it'
assert Country.Poland.countryCode == 'pl'
{code}

but if we use a non-default constructor then the following fails on the last assertion:
{code}
enum Country {
    Hungary(1),
    Italy(2),
    Poland(3){ String getCountryCode() { 'pl' } }

    
    int population
    
    Country(population) {
        this.population = population
    }

     String getCountryCode() { 
         name()[0..1].toLowerCase()
     }
}

assert Country.Hungary.countryCode == 'hu'
assert Country.Italy.countryCode == 'it'
assert Country.Poland.countryCode == 'pl'
{code}",,erdi,fletcherr,paulk,zsolt.varszegi,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Mar 23 05:55:49 UTC 2013,,,,,,,,,,"0|i2bn7b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Mar/13 05:55;paulk;Should now work - let me know if you have any further issues;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileDynamic misses the processor,GROOVY-6064,12816847,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,21/Mar/13 05:15,12/Apr/13 16:55,14/Jul/23 06:01,21/Mar/13 05:22,2.1.2,,,,,,,,,,,,,,,,,2.1.3,,,,,,,,0,,,,,,,"{{@CompileDynamic}} alias doesn't work because the alias processor isn't bundled in the distribution.

The reason is that it is found in the wrong source directory (test instead of main).",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-03-21 05:15:41.0,,,,,,,,,,"0|i2c3pj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"In CompileStatic mode, GString & String are mismatched",GROOVY-6063,12816891,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,chice,chice,21/Mar/13 04:30,07/Jul/13 03:42,14/Jul/23 06:01,07/Jul/13 03:42,2.1.2,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,,,,0,,,,,,,"When I am trying to call foo(GString ...), groovy always calls foo(String ...)



{code}

import groovy.sql.Sql
import org.junit.Test

import javax.sql.DataSource
import java.sql.Connection
import java.sql.DriverManager

import static org.testng.Assert.assertTrue

class MyGSql extends  Sql {

    MyGSql(DataSource dataSource) {
        super(dataSource)
    }

    MyGSql(Connection connection) {
        super(connection)
    }

    MyGSql(Sql parent) {
        super(parent)
    }
}

class TestGroovyGStringBug {
    @Test
    @groovy.transform.CompileStatic
    void Test() {
        Class.forName(""com.mysql.jdbc.Driver"");
        def conn = DriverManager.getConnection(""jdbc:mysql://localhost:3306/information_schema"", ""test"", ""test"");
        MyGSql mygsql = new MyGSql(conn);
        Sql sql = (Sql)mygsql

        def tableName = ""TABLES""

        GString s = ""SELECT * FROM ${Sql.expand(tableName)}""

        assertTrue( ! sql.firstRow(s).isEmpty() )
        assertTrue( ! mygsql.firstRow(s).isEmpty() )
    }
}

{code}





The generated code:
{code}

  @Test
  @TypeChecked.TypeCheckingInfo(inferredType=""AAlDbGFzc05vZGUAAAFWAP////8="", version=1)
  public void Test()
  {
    Class.forName(""com.mysql.jdbc.Driver"");
    Connection conn = DriverManager.getConnection(""jdbc:mysql://localhost:3306/information_schema"", ""test"", ""test"");
    MyGSql mygsql = new MyGSql(conn);
    Sql sql = mygsql;

    String tableName = ""TABLES"";

    GString s = new GStringImpl(new Object[] { Sql.expand(tableName) }, new String[] { ""SELECT * FROM "", """" });

    Assert.assertTrue(!sql.firstRow(s).isEmpty()); null;
    Assert.assertTrue(!mygsql.firstRow((String)ScriptBytecodeAdapter.castToType(s, String.class), new Object[0]).isEmpty()); null;
  }
{code}

Wrong here:

{color:red}
Assert.assertTrue(!mygsql.firstRow((String)ScriptBytecodeAdapter.castToType(s, String.class), new Object[0]).isEmpty()); null;
{color}",,chice,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jul 07 03:42:25 UTC 2013,,,,,,,,,,"0|i2c9w7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"21/Mar/13 04:33;chice;sorry for typo in the subject.

it should be ""in CompileStatic mode, GString & String mismatched""

;;;","01/Apr/13 03:51;pschumacher;I changed the title as per your suggestion.

@Cedric: Maybe you can take a look at this.;;;","06/Jul/13 21:41;chice;This bug seems has been fixed in 2.1.4

You can check it and may close this issue  :)

;;;","07/Jul/13 02:22;pschumacher;As I understand you already checked that the bug is fixed?

In that's the case I trust you and will just close the bug. :);;;","07/Jul/13 03:35;chice;Yes, I have checked.


In 2.1.3, this bug still exists.



In 2.1.4/2.1.5, the code works correctly.
In 2.1.4/2.1.5, the generated code:
    TestCase.assertTrue(!sql.firstRow(s).isEmpty()); null;
    TestCase.assertTrue(!mygsql.firstRow(s).isEmpty()); null;
Everything seems ok.

;;;","07/Jul/13 03:42;pschumacher;Thanks for reporting the bug and thanks for reporting that it is fixed. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"in CompileStatic mode, ""a[i] = a[j]"" won't work",GROOVY-6061,12816883,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,chice,chice,20/Mar/13 10:30,12/Apr/13 16:55,14/Jul/23 06:01,04/Apr/13 07:25,2.1.2,,,,,,,,,,,,,,,,,2.1.3,,,,Static compilation,,,,0,@CompileStatic,,,,,,"{code}
import groovy.transform.CompileStatic
import org.junit.Test

import static groovy.util.GroovyTestCase.assertEquals


class TestGroovyListBug {

    @CompileStatic
    def swapUseStatic(List<Integer> a, int i, int j) {
        int temp = a[i]
        a[i] = a[j]  //BUG HERE, a[i] = ... doesn't call ""putAt""
        a[j] = temp
    }

    @CompileStatic
    def swapUseStaticPut(List<Integer> a, int i, int j) {
        int temp = a[i]
        a.putAt(i, a[j])
        a[j] = temp
    }

    def swapNonStatic(a, i, j) {
        def temp = a[i]
        a[i] = a[j]
        a[j] = temp
    }

    @Test
    def void testCompileStaticListPut() {
        List a = new ArrayList()

        a.clear(); a.add(0); a.add(1);
        swapNonStatic(a, 0, 1)
        assertEquals(1, a[0])
        assertEquals(0, a[1])

        a.clear(); a.add(0); a.add(1);
        swapUseStaticPut(a, 0, 1)
        assertEquals(1, a[0])
        assertEquals(0, a[1])

        a.clear(); a.add(0); a.add(1);
        swapUseStatic(a, 0, 1)
        assertEquals(1, a[0])
        assertEquals(0, a[1])
    }
}
{code}",,chice,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-03-20 10:30:30.0,,,,,,,,,,"0|i2cihz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper should support URL and File variants for parse,GROOVY-6058,12818464,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,17/Mar/13 03:51,07/Apr/15 19:07,14/Jul/23 06:01,17/Mar/13 06:11,2.1.1,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,,,,,0,,,,,,,,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Mar 17 03:54:36 UTC 2013,,,,,,,,,,"0|i2cpjj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Mar/13 03:54;paulk;Proposed diff:
https://github.com/groovy/groovy-core/pull/147;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Add a Collection#combinations(Closure) method,GROOVY-6057,12816890,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,15/Mar/13 11:38,10/Jul/13 04:42,14/Jul/23 06:01,03/May/13 02:30,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,groovy-jdk,,,,0,,,,,,,"The {{combinations}} method is very useful, but in practice, it's rare that you want to limit yourself to the list of generated combinations. Often, you want to apply an action on each combination.

I suggest to add the following variant:

{code}
assert [[2, 3],[4, 5, 6]].combinations {x,y -> x*y } == [8, 12, 10, 15, 12, 18]
{code}

which avoids the working but less elegant code:

{code}
assert [[2, 3],[4, 5, 6]].combinations().collect {x,y -> x*y } == [8, 12, 10, 15, 12, 18]
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 15 11:43:17 UTC 2013,,,,,,,,,,"0|i2cafr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Mar/13 11:43;melix;Pull request: https://github.com/groovy/groovy-core/pull/146;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Lazy(soft=true) not quite right,GROOVY-6056,12818230,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,tim_yates,tim_yates,tim_yates,15/Mar/13 11:15,14/Oct/13 16:53,14/Jul/23 06:01,25/Jul/13 05:15,2.1.1,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,groovy-jdk,,,,0,,,,,,,"As discussed in this SO question:

http://stackoverflow.com/questions/15429315/how-to-build-a-reinitializable-lazy-property-in-groovy

If you have the following class:

{code}
class MyObject {
    @Lazy(soft=true) volatile String test =  {
        //initalize with network access
        println 'init'
        Thread.sleep(1000)
        'test'
    }()
}
{code}

The generated getter is:

{code}
    public java.lang.String getTest() {
        java.lang.String res = $test?.get()
        if ( res != null) {
            return res 
        } else {
            synchronized ( this ) {
                if ( res != null) {
                    return res 
                } else {
                    res = { 
                        this.println('init')
                        java.lang.Thread.sleep(1000)
                        return 'test'
                    }.call()
                    $test = new java.lang.ref.SoftReference( res )
                    return res 
                }
            }
        }
    }
{code}

This is incorrect as I believe it is missing a {{$test?.get()}} inside the synchronized block like so:

{code}
   public java.lang.String getTest() {
        java.lang.String res = $test?.get()
        if ( res != null) {
            return res 
        } else {
            synchronized ( this ) {
                res = $test?.get()
                if ( res != null) {
                    return res 
                } else {
                    res = { 
                        this.println('init')
                        java.lang.Thread.sleep(1000)
                        return 'test'
                    }.call()
                    $test = new java.lang.ref.SoftReference( res )
                    return res 
                }
            }
        }
    }
{code}",,astimony,blackdrag,paulk,pschumacher,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jul 28 06:58:28 UTC 2013,,,,,,,,,,"0|i2bu5j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Mar/13 11:17;tim_yates;https://github.com/groovy/groovy-core/pull/145;;;","15/Mar/13 14:10;astimony;The suggested solution is also incorrect.  
See ""Double Checked Locking"", for example [http://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java];;;","15/Mar/13 14:54;tim_yates;Can you post what it should be then? I'm failing to see what you mean. ;;;","16/Mar/13 12:36;astimony;The wikipedia article does a far better job of explaining this than I can.

I think this should work:

{code}
volatile java.lang.ref.SoftReference $test

public java.lang.String getTest() {
        java.lang.ref.SoftReference test = $test
       
        if ( test != null) {
            return test.get() 
        } else {
            synchronized ( this ) {
                test = $test
                if ( test != null) {
                    return test.get() 
                } else {
                    Object res = { 
                        this.println('init')
                        java.lang.Thread.sleep(1000)
                        return 'test'
                    }.call()

                    $test = test = new java.lang.ref.SoftReference( res )

                    return test.get() 
                }
            }
        }
{code}

Note that the $test declaration must be volatile.
That code is just the idiom described in the Wikipedia article as correct, applied to this situation.  It will work with JDK5 and greater.

The same considerations (double-checked locking) should be applied to @Lazy for the case where soft=false

HTH;;;","19/Mar/13 04:29;tim_yates;Out of interest, it looks like the apache commons Jexl library does it the way I had it originally:

http://svn.apache.org/repos/asf/commons/proper/jexl/tags/COMMONS_JEXL_2_0_RC3/src/main/java/org/apache/commons/jexl/util/Introspector.java;;;","01/Jul/13 12:38;pschumacher;@Tim: Like Anther Astimony said:

{quote}Note that the $test declaration must be volatile.{quote}

If you add that to your solution it should be correct.

The wikipedia articles solution is just your solution which the volatile declaration and an additional performance optimization. It's is originally from Joshua Bloch - ""Effective Java, Second Edition"", p. 283:

{quote}
If you need to use lazy initialization for performance on an instance field, use the double-check idiom. This idiom avoids the cost of locking when accessing the field after it has been initialized (Item 67). The idea behind the idiom is to check the value of the field twice (hence the name double-check): once without locking, and then, if the field appears to be uninitialized, a second time with locking. Only if the second check indicates that the field is uninitialized does the call initialize the field. Because there is no locking if the field is already initialized, it is critical that the field be declared volatile (Item 66). Here is the idiom:

{code}
// Double-check idiom for lazy initialization of instance fields
private volatile FieldType field;
FieldType getField() {
  FieldType result = field;
  if (result == null) { // First check (no locking)
    synchronized(this) {
      result = field;
      if (result == null) // Second check (with locking)
      field = result = computeFieldValue();
    }
  }
  return result;
}
{code}

This code may appear a bit convoluted. In particular, the need for the local variable result may be unclear. What this variable does is to ensure that field is read only once in the common case where it's already initialized. While not strictly necessary, this may improve performance and is more elegant by the standards applied to low-level concurrent programming. On my machine, the method above is about 25 percent faster than the obvious version without a local variable.
{quote}

Note that in the JEXL example the variable is also volatile. It just does not contain the optimization with the local variable.;;;","02/Jul/13 05:00;tim_yates;I missed the {{volatile}} bit (as I had the field marked as volatile in the example)

Should it always be volatile?  I've updated the PR to add this flag.

I guess if it should always be {{volatile}}, it means I can clean up some of the code paths (as currently it checks for and branches on volatility)

Or is it the case that only {{soft=true}} should always result in a volatile field?

Sorry, I've not had much sleep lately, and an extra (more alert) mind thinking about this stuff is probably a Very Good Thing;;;","02/Jul/13 09:30;blackdrag;Without volatile there is a minimal chance of the object referenced by the SoftReference not being fully initialized as well as the SoftReference itself not being fully initialized of course. 

For very similar reasons the field should in general be volatile I guess.;;;","03/Jul/13 06:54;paulk;The intent of leaving out volatile is that code is produced which is lazy but not thread-safe. So volatile won't be needed if {{soft}} is {{false}}. When {{soft}} is {{true}} I am unsure. In some places I read that the garbage collection of soft references will be effectively atomic but I can't find a definitive reference. If that isn't the case, the volatile would be needed for the field.;;;","03/Jul/13 08:26;tim_yates;Ok, updated the PR, now I have the following:

----

{code}
class LazyString {
    @Lazy String test = { 'test' }()
}
{code}

Generates:

{code}
public class LazyString implements groovy.lang.GroovyObject extends java.lang.Object { 

    @groovy.lang.Lazy
    private java.lang.String $test 
...
    public java.lang.String getTest() {
        if ( $test != null) {
            return $test 
        } else {
            return $test = { 
                return 'test'
            }.call()
        }
    }
}
{code}

----

{code}
class LazyVolatileString {
    @Lazy volatile String test = { 'test' }()
}
{code}

Generates:

{code}
public class LazyVolatileString implements groovy.lang.GroovyObject extends java.lang.Object { 

    @groovy.lang.Lazy
    private volatile java.lang.String $test 

...

    public java.lang.String getTest() {
        java.lang.Object $test_local = $test 
        if ( $test_local != null) {
            return $test_local 
        } else {
            synchronized ( this ) {
                if ( $test != null) {
                    return $test 
                } else {
                    return $test = { 
                        return 'test'
                    }.call()
                }
            }
        }
    }
}
{code}

----

{code}
class LazySoftString {
    @Lazy(soft=true) String test = { 'test' }()
}
{code}

Generates:

{code}
public class LazySoftString implements groovy.lang.GroovyObject extends java.lang.Object { 

    @groovy.lang.Lazy(soft = true)
    private volatile java.lang.ref.SoftReference $test 

...

    public java.lang.String getTest() {
        java.lang.String res = $test?.get()
        if ( res != null) {
            return res 
        } else {
            synchronized ( this ) {
                res = $test?.get()
                if ( res != null) {
                    return res 
                } else {
                    res = { 
                        return 'test'
                    }.call()
                    $test = new java.lang.ref.SoftReference( res )
                    return res 
                }
            }
        }
    }

    public void setTest(java.lang.String value) {
        if ( value != null) {
            $test = new java.lang.ref.SoftReference( value )
        } else {
            $test = null
        }
    }
}
{code}

----

{code}
class LazySoftVolatileString {
    @Lazy(soft=true) volatile String test = { 'test' }()
}
{code}

Generates:

{code}
public class LazySoftVolatileString implements groovy.lang.GroovyObject extends java.lang.Object { 

    @groovy.lang.Lazy(soft = true)
    private volatile java.lang.ref.SoftReference $test 

...

    public java.lang.String getTest() {
        java.lang.String res = $test?.get()
        if ( res != null) {
            return res 
        } else {
            synchronized ( this ) {
                res = $test?.get()
                if ( res != null) {
                    return res 
                } else {
                    res = { 
                        return 'test'
                    }.call()
                    $test = new java.lang.ref.SoftReference( res )
                    return res 
                }
            }
        }
    }

    public void setTest(java.lang.String value) {
        if ( value != null) {
            $test = new java.lang.ref.SoftReference( value )
        } else {
            $test = null
        }
    }
}
{code}

----

{code}
class LazyStaticString {
    @Lazy static String test = { 'test' }()
}
{code}

Generates:

{code}
public class LazyStaticString implements groovy.lang.GroovyObject extends java.lang.Object { 

    @groovy.lang.Lazy
    private static java.lang.String $test 

...

    public static java.lang.String getTest() {
        return LazyStaticString$StringHolder_test.INSTANCE
    }
}
{code}

With the helper class:

{code}
private static class LazyStaticString$StringHolder_test implements groovy.lang.GroovyObject extends java.lang.Object { 

    final private static java.lang.String INSTANCE 

...

    static { 
        INSTANCE = { 
            return 'test'
        }.call()
    }
}
{code}

----

{code}
class LazyStaticVolatileString {
    @Lazy static volatile String test = { 'test' }()
}
{code}

Generates:

{code}
public class LazyStaticVolatileString implements groovy.lang.GroovyObject extends java.lang.Object { 

    @groovy.lang.Lazy
    private static volatile java.lang.String $test 

...

    public static java.lang.String getTest() {
        return LazyStaticVolatileString$StringHolder_test.INSTANCE
    }
}
{code}

With the helper class:

{code}
private static class LazyStaticVolatileString$StringHolder_test implements groovy.lang.GroovyObject extends java.lang.Object { 

    final private static java.lang.String INSTANCE 

...

   static { 
        INSTANCE = { 
            return 'test'
        }.call()
    }
}
{code}

----

{code}
class LazySoftStaticString {
    @Lazy(soft=true) static String test = { 'test' }()
}
{code}

Generates:

{code}
public class LazySoftStaticString implements groovy.lang.GroovyObject extends java.lang.Object { 

    @groovy.lang.Lazy(soft = true)
    private static volatile java.lang.ref.SoftReference $test 

...

    public static java.lang.String getTest() {
        java.lang.String res = $test?.get()
        if ( res != null) {
            return res 
        } else {
            synchronized (LazySoftStaticString) {
                res = $test?.get()
                if ( res != null) {
                    return res 
                } else {
                    res = { 
                        return 'test'
                    }.call()
                    $test = new java.lang.ref.SoftReference( res )
                    return res 
                }
            }
        }
    }

    public static void setTest(java.lang.String value) {
        if ( value != null) {
            $test = new java.lang.ref.SoftReference( value )
        } else {
            $test = null
        }
    }
}
{code}

----

{code}
class LazySoftStaticVolatileString {
    @Lazy(soft=true) static volatile String test = { 'test' }()
}
{code}

Generates:

{code}
public class LazySoftStaticVolatileString implements groovy.lang.GroovyObject extends java.lang.Object { 

    @groovy.lang.Lazy(soft = true)
    private static volatile java.lang.ref.SoftReference $test 

...

    public static java.lang.String getTest() {
        java.lang.String res = $test?.get()
        if ( res != null) {
            return res 
        } else {
            synchronized (LazySoftStaticVolatileString) {
                res = $test?.get()
                if ( res != null) {
                    return res 
                } else {
                    res = { 
                        return 'test'
                    }.call()
                    $test = new java.lang.ref.SoftReference( res )
                    return res 
                }
            }
        }
    }

    public static void setTest(java.lang.String value) {
        if ( value != null) {
            $test = new java.lang.ref.SoftReference( value )
        } else {
            $test = null
        }
    }
}
{code}

Can someone sanity check these?  I think they are all the cases.

I have also added a very basic test (it just checks that volatile is added correctly).  Not sure how to check that DCL is being used where appropriate?;;;","03/Jul/13 08:53;blackdrag;Paul, I am less worried about the garbage collection. I am more worried about the created SoftReference. It is in theory possible, that if one thread caused the creation of the reference, another thread, that is accessing the reference may see an incomplete object, with for example null as referenced object, instead of the real one. ;;;","03/Jul/13 12:43;pschumacher;@Tim Yates: Looks good as far as I can tell. :)

I do not know if there is a way to write a unit test for double checked logging.;;;","03/Jul/13 19:18;paulk;Jochen, I think we are in agreement, not sure. If we state in our documentation that we aren't thread-safe unless you specify volatile, then we don't have a need for the SoftReference to be volatile, right? Or are you saying that you believe because GC might be in a separate thread we need volatile even for singled-threaded user code?;;;","04/Jul/13 03:40;blackdrag;Paul, its only... if we say we are not thread-safe, then why do we go through all the trouble using synchronized? 

AsI said, I think GC is no problem. There is something like a ""stop the world"" synchronization point, that should ensure the value is away completely. 

I was only worried about the initial value as well as the SoftReference itself and one of them (or both) not being fully initialized when another thread sees it. The synchronized ensures that the value will be used, if there is already one, even if the current thread did not yet see it. But instead of seeing null, the thread can also see a partially initialized SoftReference, which could for example still have null as payload, instead of the result of our Closure execution. With the volatile you avoid this.

So imho, if we go with synchronization, we should go with volatile as well. Or what is the reason you would like to avoid it?;;;","04/Jul/13 05:44;paulk;I'm suggesting that for the non-thread-safe case, e.g. when volatile isn't specified on the property definition, that we don't set the private backing field to volatile nor do we do any synchronization. I.e. as per existing behavior and the {{LazyString}} example above but not as per the {{LazySoftString}} example above. In that case, there would be no synchronization, the content of the {{getTest()}} method would just be what is shown inside the synchronized block above.

When the volatile modifier is given on the property, then the backing field is volatile and synchronization is used as required (again as per current behavior, i.e. always except for where the holder class idiom can be used). So in summary, just the double checked locking algorithm would be modified as per the suggestion.;;;","08/Jul/13 07:00;tim_yates;Did we reach a consensus on this?

Should I remove {{volatile}} from {{soft=true}} declarations where {{volatile}} is not declared in the source? (ie: the {{LazySoftStaticString}} and {{LazySoftString}} examples above)

Did the generated code above other than these 2 cases look ok?;;;","23/Jul/13 12:32;pschumacher;After reading the javadoc for [@Lazy|http://groovy.codehaus.org/gapi/groovy/lang/Lazy.html]:

{quote}
Example usage without any special modifiers just defers initialization until the first call but is not thread-safe [...]
 
If the field is declared volatile then initialization will be synchronized[...]

@Lazy(soft=true) will use a soft reference instead of the field and use the above rules each time re-initialization is required.
{quote}

I have to take back what I said before and agree with Paul.


;;;","23/Jul/13 16:26;paulk;Tim, I think the other examples are all good. I would just remove volatile from soft=true declarations where volatile is not declared in the source (as per your last comment). That improves what is currently there and we can always revamp that particular edge case if we receive more information to indicate that further synchronization is required.;;;","24/Jul/13 04:57;tim_yates;I think that's should be all in the PR now

https://github.com/groovy/groovy-core/pull/145

The {{master}} build currently seems to fail 3 tests in {{groovy.lang.MetaClassRegistryTest}} but my Lazy test passes;;;","28/Jul/13 06:58;paulk;It would no doubt belong in a separate issue (or issues) but I am wondering whether the soft setter that is generated should also potentially do synchronization (when volatile is present) and also wondering why Groovy seems to be generating getters and setters for the '$'-named private backing fields.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@DelegatesTo added by AST assumes static context,GROOVY-6055,12816899,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,musketyr,musketyr,15/Mar/13 09:22,12/Apr/13 16:55,14/Jul/23 06:01,09/Apr/13 09:29,2.1.1,,,,,,,,,,,,,,,,,2.1.3,,,,Static compilation,,,,0,,,,,,,"I wanted to add @DelegatesTo annotation to static generated method so it can be used with @CompileStatic but it looks like the method pick the proper type (QueryBuilder) but it tries to pick the missing method from static method instead of instance methods and fails because the static method doesn't exist

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Script1.groovy: 8: [Static type checking] - Non static method groovyx.gaelyk.query.QueryBuilder#where cannot be called from static context
 @ line 8, column 38.
                       MyPogo3.findAll{ where test == t }
{code}


[see how the annotation node is created|https://github.com/gaelyk/gaelyk/blob/dc5abb990d6fe01da42fde112de2da72f6ec6a49/core/src/main/groovyx/gaelyk/datastore/EntityTransformation.groovy#L98]

[see the test (need to uncomment CompileStatic(SKIP) to fail)|https://github.com/gaelyk/gaelyk/blob/dc5abb990d6fe01da42fde112de2da72f6ec6a49/core/src/test/groovyx/gaelyk/datastore/EntityTransformationSpec.groovy#L95]","java version ""1.7.0_17""
Java(TM) SE Runtime Environment (build 1.7.0_17-b02)
Java HotSpot(TM) 64-Bit Server VM (build 23.7-b01, mixed mode)
",musketyr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-03-15 09:22:24.0,,,,,,,,,,"0|i2c5c7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
context variable breaks output transformation,GROOVY-6054,12816887,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mkresse,mkresse,15/Mar/13 04:40,12/Apr/13 16:55,14/Jul/23 06:01,31/Mar/13 04:55,2.1.1,,,,,,,,,,,,,,,,,2.1.3,2.2.0-beta-1,,,Groovy Console,,,,0,,,,,,,"Executing the script: {code}context=""test""{code} in GroovyConsole breaks various functionality like output transformations and ""Inspect Variables"".

The GroovyConsole accesses the binding (context) of the internal shell via {{shell.context}}, thus leading to a call to {{shell.getProperty()}}. GroovyShell's {{getProperty()}} method however first tries to resolve against its variables. So if a variable with the name ""context"" is set, GroovyConsole uses its value, instead of the binding.

Replacing each occurence of {{shell.context}} with {{shell.getContext()}} should resolve the problem.",,mkresse,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Mar 31 04:55:21 UTC 2013,,,,,,,,,,"0|i2btzb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Mar/13 04:55;paulk;change made as per your suggestion - thanks for spotting the problem;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
++ or -- doesn't respect final modifier,GROOVY-6052,12816793,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,dsrkoc,dsrkoc,14/Mar/13 07:16,02/May/17 02:03,14/Jul/23 06:01,01/Mar/15 07:30,1.8.8,2.0.6,2.1.1,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,Compiler,,,,0,,,,,,,"Groovy respects {{final}} modifier for fields and method parameters, but using {{++}} or {{--}} is still allowed:

{code}
class A {
    final foo = 42
    def incrementField() { ++foo }
    def incrementParam(final a) { ++a }
}

def a = new A()
assert a.incrementField() == 43
assert a.incrementParam(1) == 2
{code}

However, {{a.foo++}} throws {{ReadOnlyPropertyException}}.",,dsrkoc,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Mar 01 08:56:53 UTC 2015,,,,,,,,,,"0|i2cow7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Mar/15 07:30;pschumacher;Thanks for reporting. On current master this fails with:

{code}test.groovy: 4: The parameter [a] is declared final but is reassigned
. At [4:35]  @ line 4, column 35.
       def incrementParam(final a) { ++a }
                                     ^
1 error{code};;;","01/Mar/15 08:56;dsrkoc;bq. Thanks for reporting. On current master this fails with:

Anytime ... thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE in typechecker generics inference,GROOVY-6051,12816851,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,oc,oc,13/Mar/13 17:00,19/Mar/13 05:11,14/Jul/23 06:01,14/Mar/13 05:17,2.1.2,,,,,,,,,,,,,,,,,2.1.2,,,,Static Type Checker,,,,0,,,,,,,"{noformat} 
401 /tmp> groovy -version    
Groovy Version: 2.1.2-SNAPSHOT JVM: 1.6.0_33 Vendor: Apple Inc. OS: Mac OS X
402 /tmp> <q.groovy                                
class Bar {
  public static List<String> bar(List<String> dummy) {}
}
@groovy.transform.TypeChecked class Foo extends Bar {
    static public String genericItem() {
        bar(null)[0]
    }
}
403 /tmp> groovyc -e q.groovy
null
>>> stacktrace:
java.lang.NullPointerException
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnTypeGenerics(StaticTypeCheckingVisitor.java:3100)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitStaticMethodCallExpression(StaticTypeCheckingVisitor.java:1707)
	at org.codehaus.groovy.ast.expr.StaticMethodCallExpression.visit(StaticMethodCallExpression.java:44)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:400)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1324)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1588)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1561)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1059)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:164)
	at org.codehaus.groovy.transform.StaticTypesTransformation.visit(StaticTypesTransformation.java:62)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:573)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:551)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:528)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:507)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:59)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:215)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:148)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:178)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:162)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
404 /tmp> 
{noformat} ",,oc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 13 20:25:23 UTC 2013,,,,,,,,,,"0|i2cbz3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"13/Mar/13 20:25;oc;This one might possibly be related or exactly same, the call stack top does not differ; nevertheles the cause differs completely (here it is a wrong source ""fixed"" wrongly by the typechecker so that it would crash runtime), so better to record this I guess :)

{noformat}
420 /tmp> <q.groovy 
@groovy.transform.TypeChecked(extensions='tc.groovy') class q {
    def foo() {
        q.getConstructor([]/*as Class[]*/)
    }
}
421 /tmp> <tc.groovy 
methodNotFound { receiver,name,argList,argTypes,call ->
    def mm=typeCheckingVisitor.findMethodsWithGenerated(receiver,name)
    println ""handling '$name' -> $mm""
    mm
}
422 /tmp> groovyc -e q.groovy                                                                         
handling 'getConstructor' -> [MethodNode@589646276[java.lang.reflect.Constructor getConstructor(java.lang.Class[])]]
null
>>> stacktrace:
java.lang.NullPointerException
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnTypeGenerics(StaticTypeCheckingVisitor.java:3100)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2094)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1324)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1588)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1561)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1059)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:164)
	at org.codehaus.groovy.transform.StaticTypesTransformation.visit(StaticTypesTransformation.java:62)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:573)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:551)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:528)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:507)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:59)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:215)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:148)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:178)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:162)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
423 /tmp> 
{noformat};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[Static type checking] - Inconvertible types: cannot cast java.io.Writer to SomeInterface,GROOVY-6050,12818226,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lhotari,lhotari,13/Mar/13 07:29,19/Mar/13 05:11,14/Jul/23 06:01,13/Mar/13 08:10,,,,,,,,,,,,,,,,,,2.1.2,,,,Static Type Checker,,,,0,CompileStatic,,,,,,"Similar to GROOVY-5870, but that has been marked fixed.

Compiling this code:
{code}
import groovy.transform.CompileStatic;

import java.io.IOException;

class CastingBugTest {

    
    public void testCastingToInterface() {
        Writer myWriter=MyTester.createWriter()
        MyTester.sayHelloIfSomeInterface(myWriter)
    }
}

@CompileStatic
class MyTester {
    static Writer createWriter() {
        return new MyWriter()
    }
    
    static void sayHelloIfSomeInterface(Writer writer) {
        if(writer instanceof SomeInterface) {
            ((SomeInterface)writer).sayHello()
        }
    }
}

@CompileStatic
interface SomeInterface {
    public void sayHello();
}

@CompileStatic
class MyWriter extends Writer implements SomeInterface {
    public void sayHello() {
        println ""Hello""
        
    }

    @Override
    public void write(char[] cbuf, int off, int len) throws IOException {
        
    }

    @Override
    public void flush() throws IOException {
        
    }

    @Override
    public void close() throws IOException {
        
    }
}
{code}

Causes this error:
{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
CastingBugTest.groovy: 22: [Static type checking] - Inconvertible types: cannot cast java.io.Writer to SomeInterface
 @ line 22, column 13.
               ((SomeInterface)writer).sayHello()
               ^

1 error
{code}",Java 1.7.0_17,lhotari,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"13/Mar/13 07:29;lhotari;CastingBugTest.groovy;https://issues.apache.org/jira/secure/attachment/12723169/CastingBugTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 13 08:10:24 UTC 2013,,,,,,,,,,"0|i2bzin:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"13/Mar/13 07:29;lhotari;Groovy version is 2.1.1;;;","13/Mar/13 08:10;melix;Fixed. Note that in the example above, the explicit cast wasn't needed, thanks to the use of {{instanceof}} ;);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Generated Java stub for inner interface with generics fails to compile,GROOVY-6048,12818224,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,graemerocher,graemerocher,12/Mar/13 18:42,15/Oct/15 18:19,14/Jul/23 06:01,21/Aug/13 04:33,,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Stub generator / Joint compiler,,,,0,,,,,,,"I have a Groovy class with a method signature like:

{code}
    static<T> Promise<List<T>> createPromise(List<Closure<T>> closures, List<Promise.Decorator> decorators) {
        promiseFactory.createPromise(closures, decorators)
    }
{code}

The java stub that is generated looks like

{code}
public static <T> grails.async.Promise<T> createPromise(groovy.lang.Closure<T> c, java.util.List<grails.async.Promise<T>.Decorator> decorators) { return (grails.async.Promise<T>)null;}
{code}

This fails to compile with:

{code}
[ant:groovyc] /var/folders/hl/pxmk_v3x
[ant:groovyc] 48l314rrxckj16sw0000gn/T/groovy-generated-6992284223603375969-java-source/grails/async/Promises.java:27: cannot select a static 
[ant:groovyc] class from a parameterized type
[ant:groovyc] public static <T> grails.async.Promise<java.util.List<T>> createPromise(java.util.List<groovy.la
[ant:groovyc] ng.Closure<T>> closures, java.util.List<grails.async.Promise<T>.Decorator> decorators) { return (grails.async.Promise<java.util.
[ant:groovyc] List<T>>)null;}
{code}

",,blackdrag,graemerocher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 21 04:33:25 UTC 2013,,,,,,,,,,"0|i2bwpb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Aug/13 04:33;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"typechecker NPEs on method from findMethodsWithGenerated, unknown receiver",GROOVY-6047,12816838,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,oc,oc,12/Mar/13 08:53,19/Mar/13 05:11,14/Jul/23 06:01,13/Mar/13 06:53,,,,,,,,,,,,,,,,,,2.1.2,,,,Static Type Checker,,,,0,,,,,,,"In some cases (with AST transforms and with just some methods, see below), if the ""methodNotFound"" event of a typechecking script extension returns a result of ""findMethodsWithGenerated"", the typechecker NPEs. By CÃ©dric it is caused by an unknown receiver.

Note that, if in the same case the script returns [], the compiler _does not_ report an error. It should report unknown method perhaps? I am not sure, the case is somewhat convoluted.

Test case:

{noformat}
277 /tmp> <astt.groovy                                                       
import org.codehaus.groovy.ast.*
import org.codehaus.groovy.ast.expr.*
import org.codehaus.groovy.control.*
import org.codehaus.groovy.transform.*
@GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
class astt extends ClassCodeExpressionTransformer implements ASTTransformation {
 public Expression transform(final Expression exp) {
   def e=super.transform(exp)
   if (e in PropertyExpression) {
     println ""Turning to method: $e.text""
     e=new MethodCallExpression(e.objectExpression,e.propertyAsString,MethodCallExpression.NO_ARGUMENTS)
   }
   e
 }
 SourceUnit sourceUnit
 void visit(ASTNode[] nodes, SourceUnit su) {
   (sourceUnit=su)?.ast?.classes?.each { visitClass(it) }
 }
}
278 /tmp> mkdir -p astt/META-INF/services                                                   
279 /tmp> echo astt > astt/META-INF/services/org.codehaus.groovy.transform.ASTTransformation
280 /tmp> <tc.groovy                                                                        
methodNotFound { receiver,name,argList,argTypes,call ->
   println ""unresolved method $name: $call.text""
   def mm=typeCheckingVisitor.findMethodsWithGenerated(receiver,name)
   println ""visitor -> $mm""
   mm
}
281 /tmp> <q.groovy 
@groovy.transform.TypeChecked(extensions='tc.groovy') class Foo {
   static void foo(Vector oa) {
       oa?.elements
   }
}
282 /tmp> groovyc -e -cp astt q.groovy                                                      
Turning to method: oa?.elements
unresolved method elements: oa.elements()
visitor -> [MethodNode@1152296720[java.util.Enumeration elements()]]
null
stacktrace:
java.lang.NullPointerException
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2088)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1324)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1588)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1561)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1059)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:164)
	at org.codehaus.groovy.transform.StaticTypesTransformation.visit(StaticTypesTransformation.java:62)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:573)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:551)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:528)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:507)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:59)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:215)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:148)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:178)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:162)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
283 /tmp> 

283 /tmp> <tc.groovy 
methodNotFound { receiver,name,argList,argTypes,call ->
   println ""unresolved method $name: $call.text""
   def mm=typeCheckingVisitor.findMethodsWithGenerated(receiver,name)
   println ""visitor -> $mm""
   []//mm
}
284 /tmp> groovyc -e -cp astt q.groovy
Turning to method: oa?.elements
unresolved method elements: oa.elements()
visitor -> [MethodNode@404454518[java.util.Enumeration elements()]]
285 /tmp> 
{noformat}
",,oc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-03-12 08:53:26.0,,,,,,,,,,"0|i2ctsv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
making super-call safe causes a verify error,GROOVY-6045,12816836,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,melix,oc,oc,11/Mar/13 14:47,15/Oct/15 18:19,14/Jul/23 06:01,13/Mar/13 14:15,,,,,,,,,,,,,,,,,,2.1.2,,,,Compiler,,,,0,,,,,,,"Summary says it all; simplest test case:

73 /tmp> >t.groovy
{code}
class t {
  String toString() { super?.toString() }
  static def main(av) { new t() }
}
{code}
74 /tmp> groovy t.groovy
Caught: java.lang.VerifyError: (class: t, method: toString signature: ()Ljava/lang/String;) Unable to pop operand off an empty stack
java.lang.VerifyError: (class: t, method: toString signature: ()Ljava/lang/String;) Unable to pop operand off an empty stack
75 /tmp>

Lowest priority since probability is negligible, and work-around is extremely easy.

Probably best solution would to be ignore the safe flag when compiling a super-call.

Note: the test case above hardly would happen in reality; more probable is that someone makes safe all method calls, like this:

64 /tmp> >astt.groovy
{code}
import org.codehaus.groovy.ast.*
import org.codehaus.groovy.ast.expr.*
import org.codehaus.groovy.control.*
import org.codehaus.groovy.transform.*
@GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
class astt extends ClassCodeExpressionTransformer implements ASTTransformation {
 public Expression transform(final Expression exp) {
   if (exp in MethodCallExpression) {
     println ""Making safe: $exp.text""
     exp.safe=true
   }
   exp
 }
 SourceUnit sourceUnit
 void visit(ASTNode[] nodes, SourceUnit su) {
   (sourceUnit=su)?.ast?.classes?.each { visitClass(it) }
 }
}
{code}
65 /tmp> groovyc -d astt astt.groovy                                                       
66 /tmp> mkdir -p astt/META-INF/services                                                   
67 /tmp> echo astt > astt/META-INF/services/org.codehaus.groovy.transform.ASTTransformation
68 /tmp> >t.groovy
{code}
class t {
 String toString() { super.toString() }
 static def main(av) { new t() }
}
{code}
69 /tmp> groovy -cp astt t.groovy                           
Making safe: super.toString()
Caught: java.lang.VerifyError: (class: t, method: toString signature: ()Ljava/lang/String;) Unable to pop operand off an empty stack
java.lang.VerifyError: (class: t, method: toString signature: ()Ljava/lang/String;) Unable to pop operand off an empty stack
70 /tmp> 
",,oc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-03-11 14:47:40.0,,,,,,,,,,"0|i2caf3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Change to ConfigSlurper broke non-string keys,GROOVY-6042,12816846,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,graemerocher,graemerocher,11/Mar/13 09:25,19/Mar/13 05:11,14/Jul/23 06:01,13/Mar/13 04:24,2.0.7,2.1.1,,,,,,,,,,,,,,,,2.0.8,2.1.2,,,,,,,0,,,,,,,Causing http://jira.grails.org/browse/GRAILS-9910 and http://jira.grails.org/browse/GRAILS-9900,,graemerocher,melix,slliaa,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 12 11:09:44 UTC 2013,,,,,,,,,,"0|i2cbon:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Mar/13 09:27;graemerocher;And http://jira.grails.org/browse/GRAILS-9897;;;","12/Mar/13 10:50;slliaa;Not sure if this is with intent: 
Method doMerge of groovy.util.ConfigObject.java also contains the code that caused these problems:
String key = (String) next.getKey();;;;","12/Mar/13 11:09;melix;Good catch. Reopening.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot implement method from java interface with varargs and generics,GROOVY-6041,12811937,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,11/Mar/13 04:41,15/Oct/15 18:19,14/Jul/23 06:01,13/Mar/13 03:50,2.0.7,2.1.1,,,,,,,,,,,,,,,,2.0.8,2.1.2,,,Compiler,,,,0,,,,,,,"If Java interface defines a method like

{code}
<T> Promise<java.util.List<T>> createPromise(Promise<T>...promises);
{code}

It is impossible to implement this in Groovy due to a compilation error such as

{code}
Groovyc: Can't have an abstract method in a non-abstract class. The class 'org.grails.async.factory.gpars.GparsPromiseFactory' must be declared abstract or the method 'grails.async.Promise createPromise([Lgrails.async.Promise;)' must be implemented.
{code}",,graemerocher,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/Mar/13 10:55;melix;groovy6041.tar.gz;https://issues.apache.org/jira/secure/attachment/12723123/groovy6041.tar.gz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 12 19:44:41 UTC 2013,,,,,,,,,,"0|i2bvzr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Mar/13 10:55;melix;Simple project demonstrating the issue. Compile the project using:

{code}
groovyc -j BeurkImpl.groovy IBeurk.java Promise.groovy
{code}

Produces:

{noformat} 
Note: /tmp/blah/IBeurk.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
BeurkImpl.groovy: 19: Can't have an abstract method in a non-abstract class. The class 'BeurkImpl' must be declared abstract or the method 'Promise findAll([LPromise;)' must be implemented.
 @ line 19, column 1.
   class BeurkImpl implements IBeurk {
   ^

1 error
{noformat};;;","12/Mar/13 19:44;paulk;If you need to keep the stubs, the configscript mentioned in GROOVY-4432 might prove useful.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Ability to declare inner annotation types,GROOVY-6038,12816821,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,mxm-groovy,mxm,05/Mar/13 02:01,06/Mar/18 23:25,14/Jul/23 06:01,02/May/17 02:12,,,,,,,,,,,,,,,,,,2.6.0-alpha-1,,,,syntax,,,,1,,,,,,,"{code}
@interface Upper {
  @interface Inner {} 
}
{code}",,acourtneybrown,daniel_sun,mxm,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 24 17:11:38 UTC 2017,,,,,,,,,,"0|i2cshj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Jan/17 17:11;daniel_sun;Fixed in the parrot branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Regression, Compile static does not deduce Closure Type",GROOVY-6035,12816840,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,boaznahum,boaznahum,04/Mar/13 05:20,19/Mar/13 05:11,14/Jul/23 06:01,15/Mar/13 10:11,2.1.1,,,,,,,,,,,,,,,,,2.1.2,,,,Static compilation,,,,0,compiler,compilestatic,,,,,"The code below compiled successfully in 2.0.5

in 2.1.1 we got compile error message:
{color:red}Groovyc: [Static type checking] - Cannot assign value of type java.lang.Object to variable of type CTypeTest{color}

{code}
class CTypeTest {

  @CompileStatic
  public static void test1(String[] args) {

    // Cannot assign value of type java.lang.Object to variable of type CTypeTest
    CTypeTest s1 = cache  {
      return new CTypeTest();
    }

  }


  @CompileStatic
  static <T> T cache(Closure<T> closure) {
    return closure.call();
  }


}
{code}
Of-course this prevents us from upgrading to 2.1.1 (and using full indy feature)

Thanks
Boaz
","Windows 7 64 bit, JDK 1.7.0_10",boaznahum,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-03-04 05:20:59.0,,,,,,,,,,"0|i2bp8f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compile static: report null assignments to variables with primitive types,GROOVY-6034,12811936,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mxm-groovy,mxm,01/Mar/13 06:31,17/Jun/15 20:09,14/Jul/23 06:01,06/Mar/13 05:35,2.1.1,,,,,,,,,,,,,,,,,2.1.2,,,,Static Type Checker,,,,0,,,,,,,"{code}
@CompileStatic
def foo() {
    boolean b = null  //register error here
    print b
}

foo()
{code}

I get this at runtime 
{code}
Caught: java.lang.VerifyError: (class: a/foo, method: foo signature: ()Ljava/lang/Object; ) Expecting to find integer on stack
java.lang.VerifyError: (class: a/foo, method: foo signature: ()Ljava/lang/Object; ) Expecting to find integer on stack
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
{code}

BTW quite confusing message",,mxm,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-03-01 06:31:43.0,,,,,,,,,,"0|i2cq53:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@GrabResolver information is not retained at runtime in compiled class,GROOVY-6032,12818459,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,david_syer,david_syer,28/Feb/13 09:13,19/Mar/13 05:11,14/Jul/23 06:01,02/Mar/13 15:06,2.1.0,,,,,,,,,,,,,,,,,2.1.2,2.2.0-beta-1,,,Grape,,,,0,,,,,,,"@Grab annotations are baked into the .class files and executed when the class is loaded.  They break if a custom @GrabResolver is used though because that information is lost.  It would make sense to keep it.

E.g. try and compile this

{code}
@GrabResolver(name='spring-snapshot', root='http://repo.springframework.org/snapshot')
@GrabConfig(systemClassLoader=true)
@Grab(""org.springframework:spring-context:3.2.2.BOOTSTRAP-SNAPSHOT"")
@GrabExclude(""commons-logging:commons-logging"")
@Grab(""org.slf4j:jcl-over-slf4j:1.6.1"")
@Grab(""org.slf4j:slf4j-jdk14:1.6.1"")
class BootstrapGrapes { 
}
{code}

Then blow away your {{~/.groovy/grapes/org.springframework}} and try and load the class:

{noformat}
$ mv ~/.groovy/grapes ~/tmp
$ rm -rf ~/.m2/repository/org/springframework/spring-context
$ groovysh
> ""BootstrapGrapes"" as Class
...<bang!>
{noformat}",,cbeams,dsyer,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Mar 02 15:06:18 UTC 2013,,,,,,,,,,"0|i2cibj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Mar/13 06:16;paulk;Any chance you could try a snapshot jar from the master branch build? Thanks, Paul.;;;","01/Mar/13 07:20;david_syer;How do I setup groovyc with a snapshot jar?;;;","01/Mar/13 15:20;paulk;If you are using a standard install, rename the current groovy jar in your distro to something like groovy-x.y.z.jar.bak.
Then grab the jar with the biggest timestamp from here:
http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy/2.2.0-SNAPSHOT/
and rename it to your version, e.g. groovy-x.y.z.jar
(in general, this may not work if the jump between versions is too big but should be fine in your case)

If you are using an embedded groovy, you might need instead the groovy-all jar.

If you are using an automated build (gradle, maven) you could just point to the snapshot dependency.
;;;","02/Mar/13 15:06;paulk;Proposed fix applied.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""Reference to method is ambiguous"" reported for unambiguous usage of List implementors",GROOVY-6030,12816828,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,oc,oc,27/Feb/13 14:12,19/Mar/13 05:11,14/Jul/23 06:01,06/Mar/13 03:22,2.1.1,,,,,,,,,,,,,,,,,2.1.2,,,,Static Type Checker,,,,0,,,,,,,"For List implementors which extend Object, some methods (e.g., find) are considered ambiguous, although the List implementation should win.

Test case:
{code}
86 /tmp> >q.groovy
class Mylist implements List {}
@groovy.transform.TypeChecked class t {
   def whatthe(Mylist a) {
       a.find { true }
   }
}
87 /tmp> groovyc q.groovy
{code}

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
q.groovy: 4: [Static type checking] - Reference to method is ambiguous. Cannot choose between [java.lang.Object <T> java.util.Collection <T>#find(groovy.lang.Closure), java.lang.Object java.lang.Object#find(groovy.lang.Closure)]
{noformat}",,melix,oc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 05 02:01:36 UTC 2013,,,,,,,,,,"0|i2ce4v:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"05/Mar/13 02:01;melix;Formatting tags;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GString not properly coerced to long,GROOVY-6029,12816794,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,musketyr,musketyr,27/Feb/13 00:28,01/Jun/13 06:11,14/Jul/23 06:01,29/May/13 05:11,2.1.1,,,,,,,,,,,,,,,,,2.1.4,,,,groovy-jdk,,,,0,,,,,,,"When GString is coerced to long the value is expected value + 48

e.g. following test passes
{code}
assert ""${1}"" as long == 49
assert ""${2}"" as long == 50
{code}","java version ""1.7.0_15""
Java(TM) SE Runtime Environment (build 1.7.0_15-b03)
Java HotSpot(TM) 64-Bit Server VM (build 23.7-b01, mixed mode)
Ubuntu x64",blackdrag,melix,musketyr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Feb/13 00:28;musketyr;WrongCoercionTest.groovy;https://issues.apache.org/jira/secure/attachment/12722382/WrongCoercionTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 29 04:11:45 UTC 2013,,,,,,,,,,"0|i2btjz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"27/Feb/13 01:20;blackdrag;What is wanted here I guess is that the GString version behaves the same as the String version. 

One question... why did you make the bug a blocker?;;;","27/Feb/13 02:00;musketyr;definitely. I think in a lot of situation you can't be sure if you're having String or GString.

It just felt really serious to me, but feel free to update the priority whatever you think is appropriate.;;;","29/May/13 04:11;melix;Note that using:
{code}
assert ""${42}"" as Long == 42
{code}
works as expected, so it's a primitive type issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Using short, byte, char annotation definition attribute constants should be supported",GROOVY-6025,12818516,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,25/Feb/13 17:46,06/Jul/22 22:51,14/Jul/23 06:01,06/Mar/13 04:58,2.1.1,,,,,,,,,,,,,,,,,2.1.2,2.2.0-beta-1,,,,,,,0,annotations,,,,,,"Currently this code:
{code}
import java.lang.annotation.*

@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.TYPE, ElementType.METHOD])
public @interface Foo {
    int i() default 3
    short s() default 3
    byte b() default 3
    char c1() default 65
    char c2() default 'A'
    char c3() default (char)'A'
}
{code}
generates compile time errors such as these:
{noformat}
6 compilation errors:

Attribute 's' should have type 'java.lang.Short'; but found type 'int' in @Foo
 at line: 7, column: 23

Attribute 'b' should have type 'java.lang.Byte'; but found type 'int' in @Foo
 at line: 8, column: 22

Attribute 'c1' should have type 'java.lang.Character'; but found type 'int' in @Foo
 at line: 9, column: 23

Attribute 'c2' should have type 'java.lang.Character'; but found type 'java.lang.String' in @Foo
 at line: 10, column: 23

expected '(char) A' to be an inline constant of type char in @Foo
 at line: 11, column: 23

Attribute 'c3' should have type 'java.lang.Character'; but found type 'java.lang.Object' in @Foo
 at line: -1, column: -1
{noformat}
",,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7252,GROOVY-9205,GROOVY-9206,,GROOVY-10068,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 06 22:30:05 UTC 2022,,,,,,,,,,"0|i2cntz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Feb/13 03:22;paulk;Proposed fix:

https://github.com/groovy/groovy-core/pull/143

Test cases to follow but giving time for review of the proposed solution. Basically this code now runs:
{code}
import java.lang.annotation.*

@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.TYPE, ElementType.METHOD])
public @interface Foo {
    int i1() default 0
    int i2() default (int)1
    short s1() default 2
    short s2() default (byte)3
    short s3() default (Short)4
    short s4() default (int)5
    byte b() default 6
    char c1() default 65
    char c2() default 'B'
    char c3() default 'C' as char
    char c4() default (char)'D'
}
@Foo method() {}
println getClass().getMethod('method').getAnnotation(Foo)
// => @Foo(s2=3, s1=2, b=6, c1=A, c2=B, c4=D, c3=C, s3=4, i2=1, s4=5, i1=0)
{code}
;;;","06/Jul/22 22:30;emilles;[~paulk] How important is ""short s2() default (byte)3"" or ""short s4() default (int)5""?  I have fixes for 7252, 9205, 9206 and 9366 by moving the logic of {{AnnotationConstantVisitor}} into {{ExpressionUtils#transformInlineConstants(Expression,ClassNode)}}.  But the typecast handling is much simpler if it only needs to support no cast like ""short s1() default 2"" or same-type cast like ""short s3() default (Short)4"".

https://github.com/apache/groovy/commit/5fe6fbc7dfef4df52fff6cf96a95b6d46d4fbf3c;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@DelegatesTo: static type checker misses an error,GROOVY-6021,12816829,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mxm-groovy,mxm,25/Feb/13 07:19,17/Jun/15 20:09,14/Jul/23 06:01,10/Apr/13 08:22,2.1.1,,,,,,,,,,,,,,,,,2.1.3,,,,Static compilation,Static Type Checker,,,0,,,,,,,"Consider the following example:
{code}
def with(@DelegatesTo.Target Object target, @DelegatesTo(strategy = Closure.DELEGATE_FIRST) Closure arg) {
    arg.delegate = target
    arg.setResolveStrategy(Closure.DELEGATE_FIRST)
    arg()
}

@CompileStatic
def test() {
    def obj = [1, 2]
    with(obj, {
        print(last()) //error is here
    },)
}

test()
{code}

last() is DGM for List. 

There is two ways to resolve the issue:
1. resolve 'last()' to 'obj.last()'. So the code will work
2. register an error if you think that injected methods should not be resolved in 'DelegatesTo' context 
",,mxm,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-02-25 07:19:09.0,,,,,,,,,,"0|i2ctkf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cross compilation of Groovy annotation on Java class does not work,GROOVY-6019,12817043,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,wujek.srujek,wujek.srujek,22/Feb/13 05:07,06/Jul/22 18:47,14/Jul/23 06:01,14/Jan/15 05:47,2.1.0,2.1.1,,,,,,,,,,,,,,,,2.1.2,2.2.0-beta-1,,,Compiler,,,,0,annotations,,,,,,"This annotation:
{code}
@Retention(RetentionPolicy.RUNTIME)
@Target([ElementType.TYPE, ElementType.METHOD])
@interface Tx {

    String value() default 'def'
}
{code}
on this class:
{code}
@Tx
public class PersonServiceJava {
}
{code}
results in the following failure:
{quote}
$ groovyc -j PersonServiceJava.java Tx.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Compile error during compilation with javac.
/home/wujek/Playground/annotation_test/src/main/groovy/test/PersonServiceJava.java:4: error: annotation Tx is missing value for the attribute value
@Tx
^
1 error
{quote}
I originally submitted it to Gradle (http://issues.gradle.org/browse/GRADLE-2682), but it seems to be a core groovy issue. The generated stub for the Groovy annotation look like the following:
{code}
@java.lang.annotation.Retention(value=java.lang.annotation.RetentionPolicy.RUNTIME) @java.lang.annotation.Target(value={java.lang.annotation.ElementType.TYPE,java.lang.annotation.ElementType.METHOD}) public @interface Tx
 {
 java.lang.String value();
}
{code}
The default value is missing. A sample project can be downloaded in the Gradle issue, so I won't attach it here, unless you want me to.","originally: Linux jato-rafal 3.0.0-31-generic #49-Ubuntu SMP Tue Feb 19 20:02:57 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux
reproduced on Windows 7 x64",blackdrag,paulk,wavyx,wujek.srujek,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7252,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 14 05:47:14 UTC 2015,,,,,,,,,,"0|i2c8i7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Feb/13 05:33;paulk;Proposed fix here:
https://github.com/groovy/groovy-core/pull/142
;;;","03/Mar/13 03:19;paulk;Proposed solution applied;;;","13/Jan/15 10:54;wavyx;Regarding this PR https://github.com/groovy/groovy-core/pull/143
I'm trying to use spring-data-elasticsearch annotations
{code:title=Document.java}
@Persistent
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface Document {
	String indexName();
	String type() default """";
	short shards() default 5;
	short replicas() default 1;
	String refreshInterval() default ""1s"";
	String indexStoreType() default ""fs"";
}
{code}

Using groovy 2.3.9 and java 1.8.0_25 with this annotation:
{code}
@Document(indexName = ""articles"", type = ""article"", shards = 1, replicas = 0, refreshInterval = ""-1"", indexStoreType = ""memory"")
{code}
I get the following errors:
Error:(13, 62) Groovyc: Attribute 'shards' should have type 'java.lang.Short'; but found type 'int' in @org.springframework.data.elasticsearch.annotations.Document
Error:(13, 76) Groovyc: Attribute 'replicas' should have type 'java.lang.Short'; but found type 'int' in @org.springframework.data.elasticsearch.annotations.Document

Could this be a regression?;;;","14/Jan/15 05:47;blackdrag;I created issue GROOVY-7252 for this;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE in Groovydoc,GROOVY-6017,12816810,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,asteingress,pniederw,pniederw,21/Feb/13 18:32,15/Oct/15 18:19,14/Jul/23 06:01,22/Feb/13 06:22,1.8.9,2.0.7,2.1.1,,,,,,,,,,,,,,,2.1.2,2.2.0-beta-1,,,GroovyDoc,,,,0,,,,,,,"When updating Gradle from Groovy 1.8.6 to 1.8.9, the :docs:groovydocAll task fails with an NPE:

{code}
[ant:groovydoc] java.lang.NullPointerException
[ant:groovydoc] 	at org.codehaus.groovy.tools.groovydoc.SimpleGroovyRootDoc.classNamed(SimpleGroovyRootDoc.java:48)
[ant:groovydoc] 	at org.codehaus.groovy.tools.groovydoc.SimpleGroovyClassDoc.getDocUrl(SimpleGroovyClassDoc.java:442)
[ant:groovydoc] 	at org.codehaus.groovy.tools.groovydoc.SimpleGroovyClassDoc.replaceAllTags(SimpleGroovyClassDoc.java:767)
[ant:groovydoc] 	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.replaceAllTags(GroovyRootDocBuilder.java:275)
[ant:groovydoc] 	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.replaceTags(GroovyRootDocBuilder.java:261)
[ant:groovydoc] 	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.calcThenSetPackageDescription(GroovyRootDocBuilder.java:252)
[ant:groovydoc] 	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.processPackageInfo(GroovyRootDocBuilder.java:236)
[ant:groovydoc] 	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.processFile(GroovyRootDocBuilder.java:203)
[ant:groovydoc] 	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.buildTree(GroovyRootDocBuilder.java:171)
[ant:groovydoc] 	at org.codehaus.groovy.tools.groovydoc.GroovyDocTool.add(GroovyDocTool.java:70)
[ant:groovydoc] 	at org.codehaus.groovy.ant.Groovydoc.execute(Groovydoc.java:429)
[ant:groovydoc] 	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)
[ant:groovydoc] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[ant:groovydoc] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
[ant:groovydoc] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
[ant:groovydoc] 	at java.lang.reflect.Method.invoke(Method.java:601)
[ant:groovydoc] 	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)
[ant:groovydoc] 	at groovy.util.AntBuilder.performTask(AntBuilder.java:260)
[ant:groovydoc] 	at groovy.util.AntBuilder.nodeCompleted(AntBuilder.java:220)
[ant:groovydoc] 	at org.gradle.api.internal.project.ant.BasicAntBuilder.nodeCompleted(BasicAntBuilder.java:71)
[ant:groovydoc] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[ant:groovydoc] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
[ant:groovydoc] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
[ant:groovydoc] 	at java.lang.reflect.Method.invoke(Method.java:601)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoCachedMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:230)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:53)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:55)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
[ant:groovydoc] 	at org.gradle.api.internal.project.AntBuilderDelegate.nodeCompleted(DefaultIsolatedAntBuilder.groovy:172)
[ant:groovydoc] 	at groovy.util.BuilderSupport.doInvokeMethod(BuilderSupport.java:147)
[ant:groovydoc] 	at groovy.util.BuilderSupport.invokeMethod(BuilderSupport.java:64)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeOnDelegationObjects(ClosureMetaClass.java:407)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:348)
[ant:groovydoc] 	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:877)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:46)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:145)
[ant:groovydoc] 	at org.gradle.api.tasks.javadoc.AntGroovydoc$_execute_closure2.doCall(AntGroovydoc.groovy:60)
[ant:groovydoc] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[ant:groovydoc] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
[ant:groovydoc] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
[ant:groovydoc] 	at java.lang.reflect.Method.invoke(Method.java:601)
[ant:groovydoc] 	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
[ant:groovydoc] 	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
[ant:groovydoc] 	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:877)
[ant:groovydoc] 	at groovy.lang.Closure.call(Closure.java:412)
[ant:groovydoc] 	at groovy.lang.Closure.call(Closure.java:425)
[ant:groovydoc] 	at org.gradle.api.internal.ClosureBackedAction.execute(ClosureBackedAction.java:58)
[ant:groovydoc] 	at org.gradle.util.ConfigureUtil.configure(ConfigureUtil.java:133)
[ant:groovydoc] 	at org.gradle.util.ConfigureUtil.configure(ConfigureUtil.java:94)
[ant:groovydoc] 	at org.gradle.util.ConfigureUtil$configure.call(Unknown Source)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
[ant:groovydoc] 	at org.gradle.api.internal.project.DefaultIsolatedAntBuilder.execute(DefaultIsolatedAntBuilder.groovy:112)
[ant:groovydoc] 	at org.gradle.api.internal.project.IsolatedAntBuilder$execute.call(Unknown Source)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
[ant:groovydoc] 	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
[ant:groovydoc] 	at org.gradle.api.tasks.javadoc.AntGroovydoc.execute(AntGroovydoc.groovy:58)
[ant:groovydoc] 	at org.gradle.api.tasks.javadoc.Groovydoc.generate(Groovydoc.java:75)
[ant:groovydoc] 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[ant:groovydoc] 	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
[ant:groovydoc] 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
[ant:groovydoc] 	at java.lang.reflect.Method.invoke(Method.java:601)
[ant:groovydoc] 	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
[ant:groovydoc] 	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
[ant:groovydoc] 	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1047)
[ant:groovydoc] 	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:877)
[ant:groovydoc] 	at org.gradle.api.internal.BeanDynamicObject$MetaClassAdapter.invokeMethod(BeanDynamicObject.java:216)
[ant:groovydoc] 	at org.gradle.api.internal.BeanDynamicObject.invokeMethod(BeanDynamicObject.java:122)
[ant:groovydoc] 	at org.gradle.api.internal.CompositeDynamicObject.invokeMethod(CompositeDynamicObject.java:147)
[ant:groovydoc] 	at org.gradle.api.tasks.javadoc.Groovydoc_Decorated.invokeMethod(Unknown Source)
[ant:groovydoc] 	at groovy.lang.GroovyObject$invokeMethod.call(Unknown Source)
[ant:groovydoc] 	at org.gradle.util.ReflectionUtil.invoke(ReflectionUtil.groovy:23)
[ant:groovydoc] 	at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$4.execute(AnnotationProcessingTaskFactory.java:161)
[ant:groovydoc] 	at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$4.execute(AnnotationProcessingTaskFactory.java:156)
[ant:groovydoc] 	at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:510)
[ant:groovydoc] 	at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:499)
[ant:groovydoc] 	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:64)
[ant:groovydoc] 	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:49)
[ant:groovydoc] 	at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:34)
[ant:groovydoc] 	at org.gradle.api.internal.changedetection.CacheLockHandlingTaskExecuter$1.run(CacheLockHandlingTaskExecuter.java:34)
[ant:groovydoc] 	at org.gradle.internal.Factories$1.create(Factories.java:22)
[ant:groovydoc] 	at org.gradle.cache.internal.DefaultCacheAccess.longRunningOperation(DefaultCacheAccess.java:179)
[ant:groovydoc] 	at org.gradle.cache.internal.DefaultCacheAccess.longRunningOperation(DefaultCacheAccess.java:232)
[ant:groovydoc] 	at org.gradle.cache.internal.DefaultPersistentDirectoryStore.longRunningOperation(DefaultPersistentDirectoryStore.java:142)
[ant:groovydoc] 	at org.gradle.api.internal.changedetection.DefaultTaskArtifactStateCacheAccess.longRunningOperation(DefaultTaskArtifactStateCacheAccess.java:83)
[ant:groovydoc] 	at org.gradle.api.internal.changedetection.CacheLockHandlingTaskExecuter.execute(CacheLockHandlingTaskExecuter.java:32)
[ant:groovydoc] 	at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:55)
[ant:groovydoc] 	at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:57)
[ant:groovydoc] 	at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:41)
[ant:groovydoc] 	at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:51)
[ant:groovydoc] 	at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:52)
[ant:groovydoc] 	at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:42)
[ant:groovydoc] 	at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:275)
[ant:groovydoc] 	at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.executeTask(DefaultTaskPlanExecutor.java:52)
[ant:groovydoc] 	at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.processTask(DefaultTaskPlanExecutor.java:38)
[ant:groovydoc] 	at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.process(DefaultTaskPlanExecutor.java:30)
[ant:groovydoc] 	at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:84)
[ant:groovydoc] 	at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:29)
[ant:groovydoc] 	at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
[ant:groovydoc] 	at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23)
[ant:groovydoc] 	at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:67)
[ant:groovydoc] 	at org.gradle.api.internal.changedetection.TaskCacheLockHandlingBuildExecuter$1.run(TaskCacheLockHandlingBuildExecuter.java:31)
[ant:groovydoc] 	at org.gradle.internal.Factories$1.create(Factories.java:22)
[ant:groovydoc] 	at org.gradle.cache.internal.DefaultCacheAccess.useCache(DefaultCacheAccess.java:124)
[ant:groovydoc] 	at org.gradle.cache.internal.DefaultCacheAccess.useCache(DefaultCacheAccess.java:112)
[ant:groovydoc] 	at org.gradle.cache.internal.DefaultPersistentDirectoryStore.useCache(DefaultPersistentDirectoryStore.java:134)
[ant:groovydoc] 	at org.gradle.api.internal.changedetection.DefaultTaskArtifactStateCacheAccess.useCache(DefaultTaskArtifactStateCacheAccess.java:79)
[ant:groovydoc] 	at org.gradle.api.internal.changedetection.TaskCacheLockHandlingBuildExecuter.execute(TaskCacheLockHandlingBuildExecuter.java:29)
[ant:groovydoc] 	at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
[ant:groovydoc] 	at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23)
[ant:groovydoc] 	at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:67)
[ant:groovydoc] 	at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32)
[ant:groovydoc] 	at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
[ant:groovydoc] 	at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:54)
[ant:groovydoc] 	at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:165)
[ant:groovydoc] 	at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:113)
[ant:groovydoc] 	at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:81)
[ant:groovydoc] 	at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:38)
[ant:groovydoc] 	at org.gradle.launcher.exec.InProcessGradleLauncherActionExecuter.execute(InProcessGradleLauncherActionExecuter.java:39)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.ExecuteBuild.doBuild(ExecuteBuild.java:45)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:126)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.WatchForDisconnection.execute(WatchForDisconnection.java:42)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:126)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.ResetDeprecationLogger.execute(ResetDeprecationLogger.java:24)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:126)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.StartStopIfBuildAndStop.execute(StartStopIfBuildAndStop.java:33)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:126)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.ReturnResult.execute(ReturnResult.java:34)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:126)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:70)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:68)
[ant:groovydoc] 	at org.gradle.util.Swapper.swap(Swapper.java:38)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.ForwardClientInput.execute(ForwardClientInput.java:68)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:126)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.LogToClient.doBuild(LogToClient.java:60)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:126)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.EstablishBuildEnvironment.doBuild(EstablishBuildEnvironment.java:59)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:126)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.StartBuildOrRespondWithBusy$1.run(StartBuildOrRespondWithBusy.java:45)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.DaemonStateCoordinator.runCommand(DaemonStateCoordinator.java:186)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.StartBuildOrRespondWithBusy.doBuild(StartBuildOrRespondWithBusy.java:49)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:126)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.HandleStop.execute(HandleStop.java:36)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:126)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.CatchAndForwardDaemonFailure.execute(CatchAndForwardDaemonFailure.java:32)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:126)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.exec.DefaultDaemonCommandExecuter.executeCommand(DefaultDaemonCommandExecuter.java:48)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler$ConnectionWorker.handleCommand(DefaultIncomingConnectionHandler.java:155)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler$ConnectionWorker.receiveAndHandleCommand(DefaultIncomingConnectionHandler.java:128)
[ant:groovydoc] 	at org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler$ConnectionWorker.run(DefaultIncomingConnectionHandler.java:116)
[ant:groovydoc] 	at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
[ant:groovydoc] 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
[ant:groovydoc] 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
[ant:groovydoc] 	at java.lang.Thread.run(Thread.java:722)

{code}",,asteingress,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 22 06:31:26 UTC 2013,,,,,,,,,,"0|i2bnin:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Feb/13 01:29;asteingress;The code that breaks here was added as part of GROOVY-5940 to fix wrong package prefixes in class hierarchies. I'll add a guard to fix the NP.;;;","22/Feb/13 01:30;pniederw;I've pushed a groovy-1.8.9 branch that allows to reproduce the problem. Gradle build can be debugged with {{gradlew :docs:groovydocAll --no-daemon -Dorg.gradle.debug=true}} and connecting debugger on port 5005.;;;","22/Feb/13 01:30;pniederw;Ah, read that comment too late. Thanks!;;;","22/Feb/13 01:34;pniederw;Are you saying that the NPE only occurs if there is a wrong package statement somewhere?;;;","22/Feb/13 01:38;asteingress;Thanks, Peter. I will test the bug-fix on your 1.8.9 branch.

No, I don't think it has to do with wrong package statements. GROOVY-5940 was about groovyDoc using wrong packages while resolving classes.;;;","22/Feb/13 06:22;asteingress;Peter, I fixed this issue and tested it with your 1.8.9 branch.;;;","22/Feb/13 06:31;pniederw;Thanks a lot.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Use of Class.forName breaks groovy-Eclipse,GROOVY-6015,12816752,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,werdna,werdna,21/Feb/13 12:11,19/Mar/13 05:11,14/Jul/23 06:01,06/Mar/13 10:38,,,,,,,,,,,,,,,,,,2.1.2,,,,Static compilation,,,,0,,,,,,,"In the method {{org.codehaus.groovy.transform.stc.SignatureCodecVersion1.doDecode(DataInputStream)}}, there is a call to {{Class.forName}}.  This does not work in Groovy-Eclipse since the class loader being used here is the Groovy bundle's class loader, not the class loader for the project.  Changing the call from:

{code}
ClassHelper.make(Class.forName(className)).getPlainNodeReference();
{code}

to 

{code}
ClassHelper.make(Class.forName(className, false, Thread.currentThread().getContextClassLoader())).getPlainNodeReference();
{code}

works in greclipse.  Does this work in Groovy core? If so, I would recommend making the change.

Originally reported in GRECLIPSE-1551.",,blackdrag,melix,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 06 09:44:29 UTC 2013,,,,,,,,,,"0|i2cefj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Feb/13 12:27;blackdrag;shouldn't the loader for the source unit be used here?;;;","22/Feb/13 13:12;werdna;{quote}shouldn't the loader for the source unit be used here?{quote}

Probably.  I'd be fine with that.  I just know that what we have now breaks greclipse.

Also, found two more suspicious {{Class.forName}}s.  They may be problematic for greclipse:

# in {{org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport.TypeCheckingDSL.invokeMethod(String, Object)}}
# in {{org.codehaus.groovy.transform.ASTTransformationVisitor.doAddGlobalTransforms(ASTTransformationsContext, boolean)}};;;","06/Mar/13 04:10;melix;I think Jochen is right, in general I don't think it's a good idea to use the context classloader. I need to change the codec so that it takes the source unit class loader as a constructor arg, then use it. In TypeCheckingDSL, it's used to load AST node classes, I think this is less of an issue since they are only groovy core classes.

What do you think Andrew? Would using the SU classloader be ok for you?;;;","06/Mar/13 09:44;werdna;I'd be fine with using the sourceunit's loader.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyScriptEngine disregards source encoding set on its CompilerConfiguration,GROOVY-6013,12815592,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,eddelplus,eddelplus,21/Feb/13 01:45,24/Oct/13 11:28,14/Jul/23 06:01,24/Oct/13 11:28,2.1.1,,,,,,,,,,,,,,,,,2.1.8,,,,GroovyScriptEngine,,,,0,,,,,,,"Setting the source encoding via 

// This setting does not have any effect
// Setting it to Greek Windows code page to prove it
gse.getConfig().setSourceEncoding(""Cp1253"");

does not have any effect. UTF-8 will be used on initial compilation, system file.encoding on any recompilation.
","JDK 1.6.0.37, Windows 32",eddelplus,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6012,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 24 11:28:21 UTC 2013,,,,,,,,,,"0|i2ccmn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Oct/13 11:28;pschumacher;Should also have been fixed by the pull request for [GROOVY-6012].;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"GroovyScriptEngine uses UTF-8 on initial compilation, system file.encoding on recompilation",GROOVY-6012,12816799,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,eddelplus,eddelplus,21/Feb/13 01:38,16/Nov/13 10:55,14/Jul/23 06:01,04/Oct/13 09:41,2.1.1,,,,,,,,,,,,,,,,,2.1.8,,,,GroovyScriptEngine,,,,0,,,,,,,The first time a file is complied by GSE it is always taken as UTF-8. After a change to the script the recompliation uses file.encoding system property instead. This is critical especially on Windows environments where the JVM default file.encoding to Cp1252 (or other 8-bit regional flavors).,"JDK 1.6.0.37, Windows 32 bit",blackdrag,eddelplus,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6013,,,,,,"21/Feb/13 01:38;eddelplus;GSEProblem.java;https://issues.apache.org/jira/secure/attachment/12723160/GSEProblem.java","21/Feb/13 01:38;eddelplus;UTF8Script.groovy;https://issues.apache.org/jira/secure/attachment/12722935/UTF8Script.groovy","21/Feb/13 05:49;blackdrag;a.patch;https://issues.apache.org/jira/secure/attachment/12722381/a.patch",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Nov 16 10:55:09 UTC 2013,,,,,,,,,,"0|i2bxd3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Feb/13 05:49;blackdrag;a possible patch;;;","04/Apr/13 15:50;eddelplus;Patch prepared by Blackdrag looked like the right fix to apply. Any chance to get this into 2.1.3, please?;;;","04/Apr/13 16:01;melix;Jochen, since you wrote that patch, any reason why you didn't apply it? Not sure about the fix?;;;","04/Apr/13 16:38;eddelplus;Reminder: Don't forget to explicitly set the source encoding in the compiler configuration to UTF-8 in order to maintain compatibility with the previous behavior (at least for scripts only compiled once). That was the only thing missing in the patch.;;;","05/Apr/13 15:55;blackdrag;the reason I did not apply the patch is that for one tests are missing and for two I have not yet an idea how correctly resolve the UTF-8 enconding default problem. It is legal to change the default configuration and the encoding there. But we have no way of later finding out if that had been done. If now someone wants to use the default configuration to set the encoding, it would not be reflected in GSE, since all GSE could do is set UTF-8 blindly, till somebody calls setConfig(CompilerConfiguration.DEFAULT)... which looks strange. 

Jochen and Cedric, what do you think?;;;","05/Apr/13 16:27;eddelplus;Well the fact is, that the current code will always apply UTF-8 on initial compilation, because that is already hard coded. Scripts not undergoing active changes will never be treated to anything else but UTF-8. So yes, purely by the book CompilerConfiguration.DEFAULT should somehow apply to GSE as well. But practically it has not done so for quite a while. I was able to find the setConfig() method in a futile attempt to resolve my problem, because the configuration set did not even affect the actual compiler at all. I'd value compatibility over purity and give the config, which does have an effect now, a hard coded initial encoding of UTF-8. Add a line in the JavaDoc under setConfig to convey this default behavior and suggest using that method to change it, if anybody wants or needs it differently. As for testing: Guillaume could probably deploy some bigger Gaelyk site based on the new code and not notice a difference.;;;","24/Apr/13 09:41;melix;I wouldn't change the default compiler configuration to UTF-8. It would break a lot of code running, for example, on Windows, because the default compiler configuration uses the system encoding. An idea could be that if the {{GroovyScriptEngine}} is created with {{CompilerConfiguration.DEFAULT}}, then we create a new {{CompilerConfiguration}} instead, which would make the changes to {{CompilerConfiguration.DEFAULT}} invisible (note that I think it's a bad practice to change the default configuration instance).;;;","24/Apr/13 10:11;eddelplus;Cedric,
I'm not suggesting to change the default for all instances of CompilerConfiguration. The GSE creates an instance of CompilerConfiguration in its constructor. The problem was, that that instance wasn't passed to the compiler at all, so there was no way to configure anything. The patch utilizes the CompilerConfiguration instance now. To maintain compatibility in the scope of the GSE, not in any other compiler related stuff, the GSE constructor needs to set UTF-8 on its private CompilerConfiguration. That is just replacing another hard coded UTF-8 setting in the current code.
Jochen;;;","24/Apr/13 10:13;melix;I see, makes sense.;;;","25/Apr/13 05:07;melix;I created a pull-request: https://github.com/groovy/groovy-core/pull/172

I suggest we switch over there for further comments in order to improve the fix. I had to restore the {{public ScriptClassLoader(GroovyClassLoader loader)}} constructor or GSEs created using a GroovyClassLoader wouldn't use the right compiler configuration.
;;;","16/Nov/13 10:55;eddelplus;Glad this finally made it into a release. More so that it got into a 2.1.x bug fix. Groovy 2.1.9 looks like the rock-solid tool that I like to depend on. Keep up the good work!!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyTypeCheckingExtensionSupport.safeCall() is not all that safe,GROOVY-6011,12816825,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,werdna,werdna,20/Feb/13 18:27,19/Mar/13 05:11,14/Jul/23 06:01,05/Mar/13 01:46,,,,,,,,,,,,,,,,,,2.1.2,,,,Static Type Checker,,,,0,,,,,,,"Originally reported in GRECLIPSE-1588, it seems like {{org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport.safeCall(Closure, Object...)}} is not all that safe.  There is a catch block, but it only catches {{InvokerInvocationException}}s.  If the DSL script throws any other kind of exception, the problem bubbles up and eventually crashes the compiler (or at least produces some obtuse errors.

Suggestion:

Change the catch block from catching {{InvokerInvocationException}} to {{Exception}}.",,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-02-20 18:27:23.0,,,,,,,,,,"0|i2cifz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Extension methods not recognized by Gradle,GROOVY-6008,12816717,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,20/Feb/13 01:44,19/May/14 12:03,14/Jul/23 06:01,20/Feb/13 02:27,2.0.7,2.1.1,,,,,,,,,,,,,,,,2.1.2,,,,Compiler,,,,0,,,,,,,"If you annotate a groovy class with {{@TypeChecked}} or {{@CompileStatic}} and that the code uses an extension module, then compilation fails as if the type checker doesn't find the extension classes.

Using

{{compileTestGroovy.groovyOptions.useAnt = true}}

fixes the problem.
To reproduce, first step will build and install an extension module into local maven repo.

{code}
$ git clone  https://github.com/swilliams-vmw/gemfire-groovy-extensions.git
$ cd gemfire-groovy-extensions
$ ./gradlew install
{code}
Second, download this test project: http://dl.dropbox.com/u/20288797/dive...

{code}
$ cd test
$ ./gradlew clean test
{code}

passes. Now open build.gradle, remove the useAnt=true option and the project compilation fails.

Investigation shows that the type checker should try to load the extension modules from the source unit classpath instead of using the ones from the {{MetaClassRegistry}}.
",,melix,paolodt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6806,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-02-20 01:44:06.0,,,,,,,,,,"0|i2cq5j:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@GrabResolver doesn't affect Ivy,GROOVY-6007,12818216,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,lehphyro,lehphyro,19/Feb/13 11:25,19/Mar/13 05:11,14/Jul/23 06:01,03/Mar/13 03:26,2.1.0,,,,,,,,,,,,,,,,,2.1.2,2.2.0-beta-1,,,Grape,,,,0,grabresolver,,,,,,"Ivy lists the following running a script with -Divy.message.logger.level=4:

downloadGrapes [chain] [cachedGrapes, localm2, codehaus, ibiblio, java.net2]
 return first: true
 dual: false
 -> cachedGrapes
 -> localm2
 -> codehaus
 -> ibiblio
 -> java.net2

My script begins with:
{code}
@Grapes([
    @GrabResolver(name = 'my-remote', root = 'http://server/nexus/content/groups/public'),
    @GrabConfig(systemClassLoader = true),
    @Grab(group = 'com.google.code.maven-config-processor-plugin', module = 'config-processor-maven-plugin', version = '2.4', transitive = false),
    @Grab(group = 'org.codehaus.plexus', module = 'plexus-container-default', version = '1.5.5', transitive = false),
    @Grab(group = 'commons-lang', module = 'commons-lang', version = '2.4', transitive = false),
    @Grab(group = 'xpp3', module = 'xpp3_min', version = '1.1.4c', transitive = false),
    @Grab(group = 'xerces', module = 'xercesImpl', version = '2.8.1', transitive = false),
])

import org.apache.tools.ant.taskdefs.Antlib
{code}
If I create a grapeConfig.xml file with ""my-remote"" repo, Ivy reports something like the following:

downloadGrapes [chain] [cachedGrapes, my-remote, localm2, codehaus, ibiblio, java.net2]
 return first: true
 dual: false
 -> cachedGrapes
 -> my-remote
 -> localm2
 -> codehaus
 -> ibiblio
 -> java.net2

It seems @GrabResolver is not being used.",,lehphyro,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/Feb/13 07:12;lehphyro;artifact.zip;https://issues.apache.org/jira/secure/attachment/12723046/artifact.zip","21/Feb/13 07:12;lehphyro;test.groovy;https://issues.apache.org/jira/secure/attachment/12723164/test.groovy","21/Feb/13 07:12;lehphyro;test.log;https://issues.apache.org/jira/secure/attachment/12722937/test.log",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Mar 03 03:26:00 UTC 2013,,,,,,,,,,"0|i2cm6v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Feb/13 17:00;paulk;I tried this using a cut down script:
{code}
@GrabResolver('http://nexus/content/repositories/central')
@Grab('commons-lang:commons-lang:2.4')
import org.apache.commons.lang.StringUtils

println StringUtils
{code}
This was behind a firewall, so no chance of getting directly - also .m2 and .groovy/grapes were deleted prior to running. It worked fine using Groovy 2.1.0.

The logging output is a little deceptive. At the start of the log, the nexus resolver isn't shown ""downloadGrapes [chain] [cachedGrapes, localm2, codehaus, ibiblio, java.net2]"" I presume this logging is output before we make our api calls to customise it - but later in the log it defintely goes through that resolver:
{noformat}
...
downloading http://nexus/content/repositories/central/commons-lang/commons-lang/2.4/commons-lang-2.4.jar ...
...
[SUCCESSFUL ] commons-lang#commons-lang;2.4!commons-lang.jar (342ms)
resolve done (3197ms resolve - 344ms download)
{noformat}

;;;","21/Feb/13 07:12;lehphyro;Files to reproduce the problem.;;;","21/Feb/13 07:13;lehphyro;Alright, I'll give you a set of steps to reproduce this more easily. I've updated to groovy 2.1.1 to see if it would help, but it didn't.

1. Serve artifact.zip from a local web server like nginx
2. Confirm http://127.0.0.1:8888/test/test/1.0/test-1.0.jar returns test jar file
3. Run groovy -Divy.message.logger.level=4 test.groovy
4. See how the log output never says it tries to download from 127.0.0.1

I'm attaching artifact.zip, test.groovy and test.log.

Thanks
;;;","21/Feb/13 17:48;paulk;OK, I can reproduce your bug using the old @Grapes annotation. If you remove that annotation, it should work ok, e.g.:
{code}
@GrabResolver(name = 'remote', root = 'http://127.0.0.1:8888/')
@GrabConfig(systemClassLoader = true)
@Grab(group = 'test', module = 'test', version = '1.0', transitive = false)
{code}
or
{code}
@GrabResolver('http://127.0.0.1:8888/')
@GrabConfig(systemClassLoader = true)
@Grab('test:test:1.0')
{code}
The old annotation is supposed to still work, so we still need to track down why there is a problem with the legacy style.;;;","22/Feb/13 06:45;lehphyro;It works if I remove @Grapes, thanks.;;;","22/Feb/13 14:41;paulk;add code tags, reduce priority since there is a known workaround and people tend not to use @Grapes these days though we haven't deprecated it, and it is still supposed to work, so it is still a bug;;;","02/Mar/13 00:34;paulk;Any chance you could try out a snapshot build of groovy to see if the problem is fixed for you? There was an obvious ordering issue in the Grape handling code which should be now fixed (once the CI server has finished its activities there should be a snapshot jar you could use for testing purposes).;;;","03/Mar/13 03:26;paulk;Should be fixed now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovydoc should process annotations more intelligently,GROOVY-6004,12816724,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,18/Feb/13 17:21,07/Apr/15 19:07,14/Jul/23 06:01,18/Feb/13 19:03,,,,,,,,,,,,,,,,,,2.1.2,2.2.0-beta-1,,,,,,,0,,,,,,,"See pull request:
https://github.com/groovy/groovy-core/pull/141
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 18 19:03:51 UTC 2013,,,,,,,,,,"0|i2clgf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Feb/13 19:03;paulk;Pull request 141 applied and added a small amount of other template changes to partially take advantage of the extra type information.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Method overloading behavior is non-deterministic and differs from Java behavior,GROOVY-6001,12816806,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,krasmussen,krasmussen,14/Feb/13 12:28,15/Oct/15 18:19,14/Jul/23 06:01,18/Feb/13 10:38,2.1.0,,,,,,,,,,,,,,,,,2.1.2,,,,class generator,groovy-jdk,,,0,,,,,,,"This example is based on a real world example. I've included blank interface and class implementations to simulate WebSphere's class hierarchy.

If you run the attached example (bug.groovy) repeatedly (CTRL+ENTER is easiest) in Groovy Console you will sometimes see this output:

FooApplication.onRequestStart(HttpServletRequest, HttpServletResponse)

And other times this output:

BazApplication.onRequestStart(PortletRequest, PortletResponse)
FooApplication.onRequestStart(HttpServletRequest, HttpServletResponse)

Or this:
BazApplication.onRequestStart(PortletRequest, PortletResponse
FooApplication.onRequestStart(PortletRequest, PortletResponse)

Here's a subset of the code in question

{code}

class FooApplication extends Application implements HttpServletRequestListener, PortletRequestListener{

    void onRequestStart(HttpServletRequest request, HttpServletResponse response) {
        System.out.println(""FooApplication.onRequestStart(HttpServletRequest, HttpServletResponse)"");
    }

    void onRequestEnd(HttpServletRequest request, HttpServletResponse response) {
        System.out.println(""FooApplication.onRequestEnd(HttpServletRequest, HttpServletResponse)"");
    }

    void onRequestStart(PortletRequest request, PortletResponse response) {
        System.out.println(""FooApplication.onRequestStart(PortletRequest, PortletResponse)"");
    }

    void onRequestEnd(PortletRequest request, PortletResponse response) {
        System.out.println(""FooApplication.onRequestEnd(PortletRequest, PortletResponse)"");
    }
    
}

class BazApplication extends FooApplication {

    void onRequestStart(PortletRequest request, PortletResponse response) {
        println 'BazApplication.onRequestStart(PortletRequest, PortletResponse'
        super.onRequestStart(request, response);
    }

}

{code}

Note that ResourceRequestImpl implements both HttpServletRequest and PortletRequest but PortletRequest is implemented closer in the class hierarchy. Granted this test case is a bit odd but comes from real-world example in a portlet environment running groovy with 3rd party code (IBM WebSphere) we don't control. 

As you can see the method being selected at runtime is non-deterministic. I'm no language expert but my assumption is that given a ResourceRequestImpl instance that groovy runtime should call BazApplication.onRequestStart(PortletRequest, PortletResponse) and FooApplication.onRequestStart(PortletRequest, PortletResponse) when super is invoked. 

A pure Java implementation behaves according to my assumption. If BazAppication is converted to Java it works every time (see BarApplication and BarApplicationTest in bug.zip archive). The assumption being that onRequestStart(PortletRequest request, PortletResponse response) should be called as it is the most specific method.

I've attached a gradle build script which implements both groovy (BazApplication) and java versions (BarApplication) which demonstrates that Java works according to my assumptions but the groovy one behaves non-deterministically:


$ gradle clean test

Gradle test > com.textura.BarApplicationTest.test STANDARD_OUT
    BarApplication.onRequestStart(PortletRequest, PortletResponse)
    FooApplication.onRequestStart(PortletRequest, PortletResponse)

Gradle test > com.textura.BazApplicationTest.test STANDARD_OUT
    FooApplication.onRequestStart(HttpServletRequest, HttpServletResponse)


Repeated runs BazApplicationTest yields different results:

Gradle test > com.textura.BazApplicationTest.test STANDARD_OUT
    BazApplication.onRequestStart(PortletRequest, PortletResponse
    FooApplication.onRequestStart(PortletRequest, PortletResponse)


Gradle test > com.textura.BazApplicationTest.test STANDARD_OUT

    BazApplication.onRequestStart(PortletRequest, PortletResponse)
    FooApplication.onRequestStart(HttpServletRequest, HttpServletResponse)

A co-worker of mine sent this white paper titled ""Reconciling Method Overloading and Dynamically Typed Scripting Languages"" that you might find interesting. 

https://docs.google.com/viewer?a=v&q=cache:La7ci5TSnFwJ:https://upapers.dcc.uchile.cl/index/publications/view_pdf/7979+&hl=en&gl=us&pid=bl&srcid=ADGEESiZMldG2xzVwAC7nUfDpmGkAA-brSfHaTAOQq4vfoZUoTCrUShcegjdmWJFsihVpyRT92duVIgDptelMCc--sy3RCotbH9c0OQC7PuVf2D90fYYXVoyru5KmsOxQrZXSkhX6ZUe&sig=AHIEtbSK5HwtBD8Z_nhYk2du3HzZBY_rFg

Maybe I'm mistaken but assuming what I said before about how Java resolves which method to call is accurate I don't understand why Groovy wouldn't be able to walk the tree to determine the most specific interface which should be selected in the same manner as the Java compiler. I also tried using @StaticCompile but it had no effect AFAIK.
","Don't think it matters but just in case

java version ""1.7.0_07""
Java(TM) SE Runtime Environment (build 1.7.0_07-b10)
Java HotSpot(TM) 64-Bit Server VM (build 23.3-b01, mixed mode)

Windows 7 64-bit
Microsoft Windows [Version 6.1.7601]
",blackdrag,krasmussen,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"14/Feb/13 12:28;krasmussen;ResourceRequestImpl.png;https://issues.apache.org/jira/secure/attachment/12722934/ResourceRequestImpl.png","14/Feb/13 12:28;krasmussen;bug.groovy;https://issues.apache.org/jira/secure/attachment/12723121/bug.groovy","14/Feb/13 12:28;krasmussen;bug.zip;https://issues.apache.org/jira/secure/attachment/12723122/bug.zip",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 19 14:49:51 UTC 2013,,,,,,,,,,"0|i2cq13:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Feb/13 16:07;blackdrag;It is too late today to look into this in detail, but I can say this much up front. Groovy does not have the same method selection algorithm as Java, but it should use the same method every time of course.;;;","15/Feb/13 09:41;krasmussen;Quick update. If I annotate with @StaticCopmile it does work but only if I modify both BazApplication and BazApplicationTest.

{code}

class BazApplicationTest {

    @Test
    @groovy.transform.CompileStatic
    void test() {
        BazApplication application = new BazApplication()
        PortletRequest request = new ResourceRequestImpl()
        application.onRequestStart(request, null)
    }

}

{code}


{code}

class BazApplication extends FooApplication {

    @CompileStatic
    void onRequestStart(PortletRequest request, PortletResponse response) {
        println 'BazApplication.onRequestStart(PortletRequest, PortletResponse'
        super.onRequestStart(request, response);
    }

{code}

Unfortunately we are currently only on Groovy 1.8.2 so this isn't an option for us at the moment. Also this still smells wrong to me that it doesn't work under dynamic mode. The principle of least surprise should apply right, i.e. Groovy and Java behavior should be aligned.
;;;","18/Feb/13 10:18;blackdrag;btw, I think you should be able to force method selection like this:

super.onRequestStart((PortletRequest)request, response);;;;","18/Feb/13 10:31;krasmussen;That does seem to work but why would I need to do that? It's already a PortletRequest in the method signature.

{code}
    void onRequestStart(PortletRequest request, PortletResponse response) {
        println 'BazApplication.onRequestStart(PortletRequest, PortletResponse'
        //super.onRequestStart(request, response);
        super.onRequestStart((PortletRequest)request, response);
    }
{code};;;","18/Feb/13 10:38;blackdrag;So... the bug was in the method selection algorithm. It decreased the distance value we use to find the best fit. And decreasing should never happen. Especially not to 0, since 0 means a direct match, and the internal selection assumes, that there is only one possible direct match at all times. Due to the decrease there have been two 0 valued methods and then it is random which one is selected. The fix goes further by adding a 1 distance step for going to the super class, making an interface in a direct parent class a better fit than the same interfaces two parents up. This together then fixes the issue at hand and now you always get the BazApplication.onRequestStart(PortletRequest, PortletResponse) FooApplication.onRequestStart(PortletRequest, PortletResponse) response

A question for the 1.8.x line.... do you really need this in 1.8, is upgrading to 2.1 impossible? We would prefer not releasing 1.8.10 unless it is really really needed. And not any time soon anyway.;;;","18/Feb/13 10:39;blackdrag;as I said, the cast is there to force method selection;;;","18/Feb/13 10:47;krasmussen;Ok thanks for the details. As far as upgrading goes we are stuck on JDK 1.5 for probably the next 6-8 months at least so I guess that means we need it on 1.8.x line. ;;;","18/Feb/13 11:00;melix;Hi Kirk. Groovy 2.0 still generates 1.5 bytecode, you can upgrade without problem.;;;","19/Feb/13 14:33;krasmussen;Thanks Cedric. Did you mean Groovy 2.x or Groovy 2.0.x? For some reason I thought it required JDK 1.6+.;;;","19/Feb/13 14:37;melix;You can choose any 2.x version (but better to upgrade directly on 2.1.1, there will not be any 2.0.x released);;;","19/Feb/13 14:49;krasmussen;Cool. Thanks for all your help. I'm glad you were able to figure it out so quickly.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using getter/setter without property and @DelegatesTo doesn't work,GROOVY-6000,12816784,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pred,pred,14/Feb/13 02:47,16/Feb/13 00:47,14/Jul/23 06:01,14/Feb/13 08:34,2.1.0,,,,,,,,,,,,,,,,,2.1.1,,,,Static compilation,Static Type Checker,,,0,,,,,,,"{code}
class Cheese{
 
  static void create(@DelegatesTo(strategy = DELEGATE_FIRST, value = Cheese)Closure c){

  }
  
  void setCamember(@DelegatesTo(strategy = DELEGATE_FIRST, value = Camember)Closure c){
  }
}

//..

Cheese.create{
  camember = { } //compilation fail
}

{code}",,pred,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-02-14 02:47:16.0,,,,,,,,,,"0|i2cqh3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using subscript operator on properties with a Builder and @DelegatesTo doesn't work,GROOVY-5998,12816832,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,pred,pred,14/Feb/13 01:44,20/May/14 05:31,14/Jul/23 06:01,15/May/14 15:47,2.1.0,,,,,,,,,,,,,,,,,2.3.1,,,,Static compilation,Static Type Checker,,,0,,,,,,,"We get Groovyc: [Static type checking] - The variable [attrs] is undeclared. in the following scenario:

{code}
import groovy.transform.CompileStatic
import static groovy.lang.Closure.*

@CompileStatic
class DatasourceBuilder {

    Map<String,String> attrs = [:]
}


void datasource(@DelegatesTo(strategy = DELEGATE_FIRST, value = DatasourceBuilder) Closure c) {}

@CompileStatic
void foo() {
   datasource {
       attrs['some'] = 'foo'
   }
}
{code}",,pred,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 15 15:47:32 UTC 2014,,,,,,,,,,"0|i2c2pj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/May/14 15:47;pschumacher;Fixed. Thanks for reporting.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sql#executeInsert does not return list of auto-generated keys,GROOVY-5996,12812183,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,hawleyal,hawleyal,13/Feb/13 12:46,28/Sep/14 18:26,14/Jul/23 06:01,13/Jul/14 22:14,2.0.6,,,,,,,,,,,,,,,,,2.3.2,,,,SQL processing,,,,1,breaking,executeInsert,jdbc,"oracle,","sql,",,"When using {{Sql#executeInsert}}, the documentation states the return value should be a list of auto-generated column values. In my script, the return value does not contain the correct generated ID.

This might be an Oracle problem.

http://groovy.codehaus.org/gapi/groovy/sql/Sql.html#executeInsert%28java.lang.String%29

The suggested approach to getting the generated ID is something like as follows.

{code:javascript}
def result = database.executeInsert(...)
def generated_id = result[0][0]
{code}

My insert code as follows.

{code:javascript}
def result = database.executeInsert(
    """"""\
        insert
          into buy_in (
            rid
            ,last_name
            ,first_name
            ,mi
            ,dob
            ,prog_co
            ,sex
            ,ssn
            ,ss_claim_no
            ,created_by
            ,created_on
            ,modified_by
            ,modified_on
          )
          values (
            :id
            ,:last_name
            ,:first_name
            ,:middle_initial
            ,to_date(:birthday, 'yyyy-mm-dd hh24:mi:ss')
            ,:program_county
            ,:sex
            ,:ssn
            ,:claim
            ,:created_by
            ,to_date(:created_on, 'yyyy-mm-dd hh24:mi:ss')
            ,:modified_by
            ,to_date(:modified_on, 'yyyy-mm-dd hh24:mi:ss')
          )
    """"""
    ,[
        id: 'foo'
        ,last_name: ''
        ,first_name: ''
        ,middle_initial: ''
        ,birthday: new SimpleDateFormat('yyyy-MM-dd HH:mm:ss').format(new Date())
        ,program_county: ''
        ,sex: ''
        ,ssn: ''
        ,claim: ''
        ,created_by: ''
        ,created_on: new SimpleDateFormat('yyyy-MM-dd HH:mm:ss').format(new Date())
        ,modified_by: ''
        ,modified_on: new SimpleDateFormat('yyyy-MM-dd HH:mm:ss').format(new Date())
    ]
)
{code}

My return value is as follows.

{code:javascript}
result.dump()
=> <java.util.ArrayList@3811f796 elementData=[[oracle.sql.ROWID@3811f758], null, null, null, null, null, null, null, null, null] size=1 modCount=1>

to_json(result)
=> [
  [
    {
      ""data"": [
        65,
        65,
        67,
        77,
        65,
        78,
        65,
        65,
        76,
        65,
        65,
        76,
        101,
        115,
        57,
        65,
        65,
        70
      ]
    }
  ]
]
{code}

Any ideas?

Thanks.


-AH","Windows 7
Java 1.6
Groovy 2.0.6
JDBC
Oracle 11g",astafyev,asteingress,hawleyal,lwolter,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 28 18:26:55 UTC 2014,,,,,,,,,,"0|i2cnl3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Feb/13 07:47;asteingress;The [ROWID|http://docs.oracle.com/cd/E11882_01/appdev.112/e13995/oracle/sql/ROWID.html] instance is returned by statement.getGeneratedKeys(). The Sql class has no mechanism to convert the proprietary ""id"" data representations to their corresponding JDBC types. 

In the case of Oracle's ROWID this can be done manually via

{code}
def id = result[0][0].toJdbc()
{code}

;;;","26/Feb/13 09:35;hawleyal;The representation is not the issue.

The issue is that primary key, which is generated by a sequence, is not returned to this collection. Only the Oracle rowid is returned.

In order to retrieve the row created, one cannot use the primary key, because it was not returned.

The rowid must be used.

{code}
database.firstRow(""select * from buy_in where (rowid = :row_id)"", [row_id: row_id])
{code}

This is a workaround, but it is still desired to actually return a primary key, like the documentation states.

bq. Returns: A list of the auto-generated column values for each inserted row (typically auto-generated keys)

Maybe just alter the documentation to include this kludge.;;;","27/Feb/13 01:07;asteingress;I see. According to the documentation, ROWID should not be used as key to refer to db rows. Can you provide the DDL for the buy_in table, so i can create a close test-case?;;;","27/Feb/13 07:54;hawleyal;DDL as follows.

The {{oid}} column is the primary key, and is auto-generated by the trigger & sequence. Oracle doesn't have a feature for auto-increment columns.

{code:sql}
create table buy_in (
  oid number(12,0)
  ,rid varchar2(10)
  ,last_name varchar2(24)
  ,first_name varchar2(15)
  ,mi varchar2(1)
  ,dob date
  ,prog_co varchar2(3)
  ,sex varchar2(1)
  ,ssn varchar2(9)
  ,ss_claim_no varchar2(12)
  ,created_by varchar2(30)
  ,created_on date
  ,modified_by varchar2(30)
  ,modified_on date
  ,constraint buy_in_pk primary key(oid)
);

create sequence buy_in_seq
    increment by 1
    start with 1;
    
create or replace trigger buy_in_insert
  before insert on buy_in for each row
  declare v_nextval number(12,0);
  begin
    if :new.oid is null then
      select buy_in_seq.nextval into v_nextval from dual;
      :new.oid := v_nextval;
    end if;
  end;
{code};;;","04/Feb/14 14:27;astafyev;Oracle JDBC documentation says:
""If key columns are not explicitly indicated, then Oracle JDBC drivers cannot identify which columns need to be retrieved. When a column name or column index array is used, Oracle JDBC drivers can identify which columns contain auto-generated keys that you want to retrieve. However, when the Statement.RETURN_GENERATED_KEYS integer flag is used, Oracle JDBC drivers cannot identify these columns. When the integer flag is used to indicate that auto-generated keys are to be returned, the ROWID pseudo column is returned as key. The ROWID can be then fetched from the ResultSet object and can be used to retrieve other columns.""
In other words you should use prepareStatement(String sql, String[] columnNames) and explicitly set column names which contain auto-generated keys. Otherwise ROWID is returned.
It would be helpful to add optional parameter to executeInsert* functions to indicate such columns. But since Sql is implemented in Java it can be implemented with varargs to avoid adding another set of executeInsert*. Not ideal but does it's job.;;;","24/May/14 22:06;paulk;See https://github.com/groovy/groovy-core/pull/425;;;","26/May/14 04:08;paulk;PR#425 applied. This added numerous {{executeInsert}} variants taking List<String> keyColumnNames (or String[] keyColumnNames for the existing Object[] vararg variant). Let me know if there are any problems.;;;","13/Jul/14 22:13;paulk;This change is breaking for the method {{executeInsert(String, List)}} when supplied with params of {{(GString, List sqlParams)}}. Previously, the GString would have been converted to a String but with the new {{(GString, List columnNames)}} variant, that will match now and depending on the format of the GString, various SqlExceptions are likely to occur. If using a GString without desiring the column names functionality for auto-generated keys, you can instead:
* avoid using a GString parameter (convert your GString to a String by calling .toString() or concatenate a String together manually)
* use the GString only variant of the method in which case you might need to use GString.EMPTY or Sql.expand to build up your GString;;;","21/Sep/14 06:57;lwolter;Always I get error with various tests of ""executeInsert"" under Oracle 12.1. In Oracle Support I found a clue. After the patch installation everything works.

*NullPointerException With getGeneratedKeys().getMetaData() in JDBC 12.1.0.1.0 (Doc ID 1619185.1)*

Using the 12.1.0.1.0 JDBC driver connected to an Oracle 11.2 database, the following null pointer exception is received when getting metadata from a generated key:
{code}
java.lang.NullPointerException
       at oracle.jdbc.driver.AutoKeyInfo.initMetaDataColumnIndexes(AutoKeyInfo.java:423)
       at oracle.jdbc.driver.AutoKeyInfo.initMetaData(AutoKeyInfo.java:396)
       at oracle.jdbc.driver.OracleReturnResultSet.getMetaData(OracleReturnResultSet.java:77)
{code}

The same code works with JDBC 11.2.0.3.0.

*Solution:  Apply patch 17082699 on top of JDBC 12.1.0.1.*;;;","22/Sep/14 03:46;paulk;Is this just for documentation purposes in case others also get this error? Or are you suggesting we try to guard against such NPE scenarios?;;;","25/Sep/14 12:36;lwolter;My comment is only for documentation purposes in case others also get this error. Thank you for your inquiry.;;;","28/Sep/14 18:26;paulk;OK, thanks for posting the information!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checking extensions are not initialized when used with @CompileStatic,GROOVY-5995,12816775,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,13/Feb/13 10:44,16/Feb/13 00:47,14/Jul/23 06:01,13/Feb/13 10:46,2.1.0,,,,,,,,,,,,,,,,,2.1.1,,,,Static compilation,,,,0,,,,,,,"The static compilation visitor reads the type checking extensions from the annotation, creates the extension but forgets to initialize it. Without initialization, the extension isn't loaded.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-02-13 10:44:00.0,,,,,,,,,,"0|i2bnbb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checking extensions should have access to the compile classpath,GROOVY-5994,12816797,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,13/Feb/13 04:15,16/Feb/13 00:47,14/Jul/23 06:01,13/Feb/13 10:05,2.1.0,,,,,,,,,,,,,,,,,2.1.1,,,,Static Type Checker,,,,0,,,,,,,"Currently, type checking extensions are run in a ""standalone"" mode, meaning they don't have access to classes that are defined in the compile classpath. This limits the ability to work with class nodes.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-02-13 04:15:08.0,,,,,,,,,,"0|i2cq1j:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type Checking Extensions cannot handle operator methods,GROOVY-5991,12816792,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,oc,oc,12/Feb/13 13:51,16/Feb/13 00:47,14/Jul/23 06:01,13/Feb/13 10:04,2.1.0,,,,,,,,,,,,,,,,,2.1.1,,,,Static Type Checker,,,,0,,,,,,,"The event 'methodNotFound' of a type checker extension script does not get called at all for methods to which operators are turned, like e.g.,

...[Static type checking] - Cannot find matching method java.lang.Object#leftShift(int)....
@ line 9, column 9.
          bar<<1
          ^

If the source contains explicit ""bar.leftShift 1"", it works properly.

Either a specific event for operators should be added, or the 'methodNotFound' event should be called for these methods as well. Personally, I think the latter solution is better, but as always, might be overlooking something of importance.",,oc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-02-12 13:51:57.0,,,,,,,,,,"0|i2bpuv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Map subscript operator not working with CompileStatic ,GROOVY-5988,12816747,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,musketyr,musketyr,09/Feb/13 16:37,16/Feb/13 00:47,14/Jul/23 06:01,11/Feb/13 08:47,2.1.0,,,,,,,,,,,,,,,,,2.0.7,2.1.1,,,Static compilation,,,,0,,,,,,,"When trying to use subscript operator on map within class compiled static with Groovy 2.1.0 the value is not put in the map. I need to use the Map#put method directly.

See the simple test script attached.","Ubuntu x64, Java(TM) SE Runtime Environment (build 1.6.0_38-b05)
Java HotSpot(TM) 64-Bit Server VM (build 20.13-b02, mixed mode)
 ",melix,musketyr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"09/Feb/13 16:37;musketyr;g210MapBug.groovy;https://issues.apache.org/jira/secure/attachment/12722383/g210MapBug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 11 04:06:19 UTC 2013,,,,,,,,,,"0|i2csc7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Feb/13 03:59;melix;I just ran this using Groovy 2.1.0 and it passes. Could it be that you have two versions of Groovy on classpath? What does:
{code}
println GroovySystem.version
{code}

shows?;;;","11/Feb/13 04:02;musketyr;2.1.0;;;","11/Feb/13 04:06;melix;Raising the priority to blocker, as in fact, it the assert which is failing. I thought it was a compile-time error.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JavaDoc and GroovyDoc tasks always rebuild,GROOVY-5987,12816749,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,russel,russel,09/Feb/13 04:30,14/Oct/13 16:53,14/Jul/23 06:01,10/Sep/13 05:01,,,,,,,,,,,,,,,,,,2.2.0-beta-2,,,,,,,,1,,,,,,,"It seems that the JavaDoc and GroovyDoc tasks of the GroovyCore build always cause a rebuild, they are never marked as done. This implies some erroneous dependencies? ",,melix,pschumacher,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 10 05:01:18 UTC 2013,,,,,,,,,,"0|i2bsxr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Feb/13 09:00;melix;I think the problem is related to the fact we have a ""dual"" build: normal+indy. The first build produces regular artifacts while the second one produces the indy artifacts. If you run a build twice, then the last build was indy and Gradle thinks things have changed.

But that's just a guess!;;;","09/Feb/13 09:11;russel;Seems like an excellent hypothesis to me. Is there any need to run JavaDoc and GroovyDoc tasks for both indy and old-fashioned builds  I cannot think of the old style build as normal any more!;;;","08/Sep/13 06:27;pschumacher;This seems to be fixed after blackdrags recent changes. At least I can call ""gradlew doc"" multiple times without any rebuilds.;;;","10/Sep/13 05:01;pschumacher;Closing this for now. Please reopen if this issue still occurs.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Invalid hash key ""serialVersionUID""",GROOVY-5985,12816743,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,farnham,farnham,08/Feb/13 10:37,01/Feb/17 23:18,14/Jul/23 06:01,23/Jul/16 00:50,2.1.0,,,,,,,,,,,,,,,,,2.4.8,,,,groovy-runtime,,,,1,,,,,,,"Using ""serialVersionUID"" as a hash key with bracket notation throws exception",Groovy Version: 2.1.0 JVM: 1.7.0_11 Vendor: Oracle Corporation OS: Mac OS X,blackdrag,farnham,githubbot,jwagenleitner,nobeans,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8065,,,,,,,,,,,,,"08/Feb/13 10:37;farnham;bug.groovy;https://issues.apache.org/jira/secure/attachment/12722380/bug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 23 00:50:08 UTC 2016,,,,,,,,,,"0|i2brtz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Feb/13 14:30;blackdrag;I think the reason is that Groovy tries to access the serialVersionUID field of the class that implements the map.

That would make this a MOP2 issue... interesting catch;;;","13/Oct/13 10:24;nobeans;{code}
def map = [serialVersionUID:123]
assert map[""serialVersionUID""] == 123
assert map.serialVersionUID == 123

map.put(""serialVersionUID"", 789)
assert map[""serialVersionUID""] == 789
assert map.serialVersionUID == 789
// the above codes work well.

// but using 'putAt' throws ReadOnlyPropertyExcetption
map.putAt(""serialVersionUID"", 333)
{code}

Stacktrace:
{code}
WARNING: Sanitizing stacktrace:
groovy.lang.ReadOnlyPropertyException: Cannot set readonly property: serialVersionUID for class: java.util.LinkedHashMap
	at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:2436)
	at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:3411)
	at org.codehaus.groovy.runtime.InvokerHelper.setProperty(InvokerHelper.java:196)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.putAt(DefaultGroovyMethods.java:250)
	at org.codehaus.groovy.runtime.dgm$418.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:271)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:53)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
	at ConsoleScript50.run(ConsoleScript50:9)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:257)
	at groovy.lang.GroovyShell.run(GroovyShell.java:481)
	at groovy.lang.GroovyShell.run(GroovyShell.java:163)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:955)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor222.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
	at groovy.lang.Closure.call(Closure.java:411)
	at groovy.lang.Closure.call(Closure.java:405)
	at groovy.lang.Closure.run(Closure.java:492)
	at java.lang.Thread.run(Thread.java:724)
{code}
;;;","10/Jul/16 03:22;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/365

    GROOVY-5985 - Invalid hash key serialVersionUID

    Using a map key with the same name as a read-only property on the Map
    class would throw a groovy.lang.ReadOnlyPropertyException.  The fix for
    GROOVY-3471 (commit 18f6f8271ed3bfb) moved the map handling
    below the handling for read-only properties.  In order to avoid the
    issue in GROOVY-3471 we also need to check and make sure the
    method is null so we are not in a setX call.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-5985

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/365.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #365
    
----
commit 1a081b087dd7fd9c3f7979d3c88b5783d089c5eb
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-07-08T22:05:38Z

    GROOVY-5985 - Invalid hash key serialVersionUID
    
    Using a map key with the same name as a read-only property on the Map
    class would throw a groovy.lang.ReadOnlyPropertyException.  The fix for
    GROOVY-3471 (commit 18f6f8271ed3bfb) moved the map handling
    below the handling for read-only properties.  In order to avoid the
    issue in GROOVY-3471 we also need to check and make sure the
    method is null so we are not in a setX call.

----
;;;","23/Jul/16 00:48;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/365
;;;","23/Jul/16 00:50;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@TypedChecked error when using generics,GROOVY-5981,12818212,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,rpodlas,rpodlas,07/Feb/13 02:04,06/Jun/14 04:35,14/Jul/23 06:01,15/May/14 13:56,2.1.0,,,,,,,,,,,,,,,,,2.3.1,,,,Static Type Checker,,,,0,,,,,,,"Type checking in Groovy 2.1 seems to have issues with ""extended"" Generics, see sample below, which makes use use explicit cast though we should not need to:
{code}
abstract class ComponentAdapter<Fixture extends ComponentFixture> {

	Fixture getFixture() {
        return fixture;
    }
}

abstract class ContainerAdapter<Fixture extends ContainerFixture> extends ComponentAdapter<Fixture> {

}
	
@TypeChecked	
class ButtonComponent extends ComponentAdapter<JButtonFixture> implements Clickable {	

	void setFixtureResolver(final ContainerAdapter<? extends ContainerFixture> containerAdapter) {
        final ContainerFixture containerFixture   = (ContainerFixture)containerAdapter.getFixture(); //OK
		final ContainerFixture containerFixture   = containerAdapter.getFixture(); //NOK ... see below
    }
}
{code}
{code}
[ERROR] D:\SVN\PROTECT\2200_Test_Development\cats-framework\trunk\cats-agents\cats-agent-festswing-scripting\src\main\groovy\scripts\agent\festswing\adapter\controller\component\ButtonComponent.groovy
: 102: [Static type checking] - Cannot assign value of type org.fest.swing.fixture.ComponentFixture <org.fest.swing.fixture.ContainerFixture extends org.fest.swing.fixture.ContainerFixture> to variabl
e of type org.fest.swing.fixture.ContainerFixture
[ERROR] @ line 102, column 53.
[ERROR] rFixture containerFixture   = containerA
[ERROR] ^
[ERROR]
[ERROR] 1 error
[ERROR] -> [Help 1]
{code}","JDK 1.6.0.32, MVN 3.0.3, Groovy 2.1",blackdrag,davide.cavestro,melix,pschumacher,rpodlas,stefan_leo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 06 04:35:41 UTC 2014,,,,,,,,,,"0|i2c533:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jul/13 06:11;blackdrag;should be fixed;;;","09/Oct/13 08:50;blackdrag;as of http://stackoverflow.com/questions/19229662/typechecked-failure-over-generic-type-argument I checked the issue again and it seems the issue is not fixed yet. Due to the missing parts I probably forgot to include the crucial stuff;;;","09/Oct/13 08:52;blackdrag;An variant of the code above to exhibit the failure without fest:{code:Java}
import javax.swing.*
import java.awt.*

class ComponentFixture<T extends Component> {}
class JButtonFixture extends ComponentFixture<JButton> {}
class ContainerFixture<T extends Container> extends ComponentFixture<T> {}
abstract class ComponentAdapter<Fixture extends ComponentFixture> {
    Fixture getFixture() {
        return fixture;
    }
}
abstract class ContainerAdapter<Fixture extends ContainerFixture> extends ComponentAdapter<Fixture> {}

@groovy.transform.CompileStatic
class ButtonComponent extends ComponentAdapter<JButtonFixture> {   
    void setFixtureResolver(final ContainerAdapter<? extends ContainerFixture> containerAdapter) {
        final ContainerFixture containerFixture   = containerAdapter.getFixture(); //NOK ... see below
    }
}{code}
;;;","15/May/14 13:56;pschumacher;blackdrag blackdrag variant now works. Thanks for reporting the issue.;;;","21/May/14 04:18;davide.cavestro;Is there any plan to backport the fix on 2.2 branch? we've just upgraded to 2.2.2, and upgrading to groovy 2.3 would mean switching groovy compiler feature for greclipse: that's quite invasive, as it's still set at eclipse workspace level (also I'm not sure there's a way to keep groovy 1.8 feature on latest greclipse versions, as per http://groovy.329449.n5.nabble.com/Will-GREclipse-2-9-still-support-groovy-1-8-compiler-td5719260.html );;;","21/May/14 04:25;melix;No plan to backport on 2.2 : the fixes are too complex to be backported. I'm not a greclipse expert, so I can't comment on the problem you are seeing here.;;;","06/Jun/14 04:35;davide.cavestro;I guess even the following snippet - failing in groovy 2.2.2 but not in groovy 2.3.2 - is due to this issue:
{code:title=Foo.groovy}
import groovy.transform.TypeChecked

@TypeChecked
class Foo {
    def foo () {
        java.util.List<String> l1 = ['foo'] //ERROR here, but assigning [] would work
        java.util.List<String> list = l1    //ERROR also here!
        println list
    }
}

new Foo().foo() 
{code}

However the good news are that I've been able to install GREclipse with support for groovy 2.3.2 and groovy 1.8 (see http://groovy.329449.n5.nabble.com/Repost-is-there-any-groovy-1-8-compiler-support-in-GREclipse-2-9-td5719723.html );;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Finally executes twice on NPE while casting method result,GROOVY-5980,12816764,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,asteingress,salaev,salaev,06/Feb/13 07:54,16/Feb/13 00:47,14/Jul/23 06:01,12/Feb/13 09:28,1.8.8,2.0.6,2.1.0,,,,,,,,,,,,,,,1.8.9,2.0.7,2.1.1,2.2.0-beta-1,bytecode,Compiler,,,0,,,,,,,"Follwing scriplet prints 'in finally' twice:

f();

int f() {

	try {
		return null
	} finally {
		println 'in finally'
	}
}",,asteingress,blackdrag,scf37,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 12 03:43:38 UTC 2013,,,,,,,,,,"0|i2btlr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Feb/13 16:20;asteingress;Be aware that this fix patches the symptom only: https://github.com/groovy/groovy-core/pull/139

{code}
int f() {
   try { null } finally { println 'test' }
}
f()
{code}

causes the finally block to be executed two times. When having a look at the bytecode, you can see that loading and storing the const and unboxing it to an integer is indeed separated into two code blocks by the block recorder mechanism in StatementWriter#writeReturm/#writeTryCatchFinally.

In StatementWriter#writeReturn the finally block is embedded right after loading the first code block (loading and storing the null constant):

{code}
public int f();
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=4, args_size=1
         0: invokestatic  #20                 // Method $getCallSiteArray:()[Lorg/codehaus/groovy/runtime/callsite/CallSite;
         3: astore_1      
         4: aconst_null   
         5: astore_2      
         6: nop           
         7: aload_1       
         8: ldc           #74                 // int 2
        10: aaload        
        11: aload_0       
        12: ldc           #76                 // String test
        14: invokeinterface #79,  3           // InterfaceMethod org/codehaus/groovy/runtime/callsite/CallSite.callCurrent:(Lgroovy/lang/GroovyObject;Ljava/lang/Object;)Ljava/lang/Object;
        19: pop           
        20: nop           
        21: aload_2       
        22: invokestatic  #85                 // Method org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.intUnbox:(Ljava/lang/Object;)I
        25: ireturn       
        26: goto       
...
{code}

The problem is the DefaultTypeTransformation is failing to convert null to int. As a consequence, the catchAny block - filled with the finally statement code - is executed again.

{code}
6: goto          29
        29: aload_1       
        30: ldc           #86                 // int 3
        32: aaload        
        33: aload_0       
        34: ldc           #76                 // String test
        36: invokeinterface #79,  3           // InterfaceMethod org/codehaus/groovy/runtime/callsite/CallSite.callCurrent:(Lgroovy/lang/GroovyObject;Ljava/lang/Object;)Ljava/lang/Object;
        41: pop           
        42: nop           
        43: goto          62
        46: astore_3      
        47: aload_1       
        48: ldc           #87                 // int 4
        50: aaload        
        51: aload_0       
        52: ldc           #76                 // String test
        54: invokeinterface #79,  3           // InterfaceMethod org/codehaus/groovy/runtime/callsite/CallSite.callCurrent:(Lgroovy/lang/GroovyObject;Ljava/lang/Object;)Ljava/lang/Object;
        59: pop           
        60: aload_3       
        61: athrow        
        62: ldc           #38                 // int 0
        64: ireturn       
      Exception table:
         from    to  target type
             4     7    46   any
            21    29    46   any
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
               0      62     0  this   Lbla;
      LineNumberTable:
        line 2: 4
{code}

This patch simply moves the type cast into the first block. If the cast fails, the catchAny block is executed and thus the finally code run only once.;;;","12/Feb/13 00:38;blackdrag;I think we need to find an alternative solution to this. The recorder should have the uncast value

As for the issue itself... offset 4-6 should be the try block, offset 7-25/26 the inlined finally block, offset 29-36 another finally block and offset 46-61 the normal finally block. The exception table has an entry for 4-7 to jump to 46. That looks imho right. What is totally wrong here imho is this second finally block plus the second catch entry.;;;","12/Feb/13 01:33;asteingress;No, offset 7-20 is the inlined finally block, 21-25 is the cast + return statement. And that's the crux: when unboxing fails this exception is catched by the second any catch and the finally block is executed again (after being already executed after 4-6).

And that's what looks wrong to me too. Why is the finally block inlined after 4-6? Shouldn't the call to DefaultTypeTransformation come before? In fact this is what the patch does.

;;;","12/Feb/13 01:46;asteingress;Just for the record. Here is the Java code for a similar example:

{code}
public class Test {

public static void main(String[] args) {
    System.out.println(f());
}

static int f() {

try {
    Object o = ""Test"";
    return (int) o;
} finally {
   System.out.println(""Test"");

}
}
}
{code}

{code}
static int f();
    flags: ACC_STATIC
    Code:
      stack=2, locals=3, args_size=0
         0: ldc           #5                  // String Test
         2: astore_0      
         3: aload_0       
         4: checkcast     #6                  // class java/lang/Integer
         7: invokevirtual #7                  // Method java/lang/Integer.intValue:()I
        10: istore_1      
        11: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
        14: ldc           #5                  // String Test
        16: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        19: iload_1       
        20: ireturn       
        21: astore_2      
        22: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
        25: ldc           #5                  // String Test
        27: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        30: aload_2       
        31: athrow        
      Exception table:
         from    to  target type
             0    11    21   any
            21    22    21   any
      LineNumberTable:
        line 10: 0
        line 11: 3
        line 13: 11
      StackMapTable: number_of_entries = 1
           frame_type = 85 /* same_locals_1_stack_item */
          stack = [ class java/lang/Throwable ]


{code}

It has two entries in the exception table too. Although the second entry looks a bit weird.;;;","12/Feb/13 03:09;blackdrag;Andres, I am sorry, I mixed up some things. Of course your patch is ok. Now I see why I wrote the code like this, and why I misunderstood in the beginning. I was mixing up value recorder and block recorder. The former is for asserts, the later one for handling finally blocks. Actually the comment ""// value is always saved in boxed form, so no need to have a special load routine here"" is also wrong. Since Groovy 1.8 we don't always box. type should be replaced by returnType.

Where the additional finally block comes from is also an issue though, but maybe a separate issue.

So I change to +1 ;);;;","12/Feb/13 03:43;asteingress;André - that's me! ;-)

Okay, I will remove the comment and change the type to returnType in the pull request.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy Ant task doesn't support indy/configscript/scriptbaseclass,GROOVY-5979,12816781,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,06/Feb/13 07:21,16/Feb/13 00:47,14/Jul/23 06:01,06/Feb/13 07:57,2.1.0,,,,,,,,,,,,,,,,,2.1.1,,,,Ant integration,,,,0,,,,,,,,,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-02-06 07:21:38.0,,,,,,,,,,"0|i2cnrb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
configscript not available from Groovyc class,GROOVY-5978,12816742,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,06/Feb/13 06:46,16/Feb/13 00:47,14/Jul/23 06:01,06/Feb/13 07:57,2.1.0,,,,,,,,,,,,,,,,,2.1.1,,,,,,,,0,,,,,,,"The {{configscript}} option is available in {{FileSystemCompiler}}, {{GroovyMain}} but not {{Groovyc}}.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-02-06 06:46:17.0,,,,,,,,,,"0|i2c6lr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Delegate should support including/excluding which methods are delegated to (and optionally complain if multiple exist) - simple use cases,GROOVY-5974,12812156,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,oliver_plow,oliver_plow,04/Feb/13 07:53,14/Oct/13 16:53,14/Jul/23 06:01,29/Aug/13 20:59,2.1.0,,,,,,,,,,,,,,,,,2.2.0-beta-2,,,,groovy-jdk,,,,0,,,,,,,"I have 3 delegate clases:

{code}
class CommonDelegate {
    def String value = ""CommonDelegate""
}
{code}

{code}
class CommonDelegate2 {
    def String value = ""CommonDelegate2""
}
{code}

{code}
class CommonDelegate3 {
    def String value = ""CommonDelegate3""
}
{code}

and a class Foo:

{code}
class Foo extends CommonDelegate {

    @Delegate
    def CommonDelegate2 commonDelegate2 = new CommonDelegate2()

    @Delegate
    def CommonDelegate3 commonDelegate3 = new CommonDelegate3()

}
{code}

Now, I run this code:

{code}
def Foo foo = new Foo()
println(foo.getValue())
{code}

And this prints ""CommonDelegate2""

Question is now whether @Delegate should complain about the ambiguous call to getValue() in foo.getValue() as people expect @Delegate to be type-safe",groovy-2.1.0 on Windows using IDEA IC123.139,oliver_plow,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 29 20:59:16 UTC 2013,,,,,,,,,,"0|i2c68n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Feb/13 07:56;oliver_plow;Sorry for the typo in the first line. It should be: ""I have 3 delegate classes:"";;;","04/Feb/13 12:16;pschumacher;Added code tags and fixed the typo mentioned by Oliver Plow.;;;","04/Feb/13 18:29;paulk;The current doco says:
{quote}
If multiple delegate fields are used and the same method signature occurs
in more than one of the respective field types, then the delegate will be
made to the first defined field having that signature. If this does occur,
it might be regarded as a smell (or at least poor style) and it might be
clearer to do the delegation by long hand.
{quote}
We could certainly be clearer about what would happen wrt inherited methods.

In terms of improvement, we could make it stricter, though it might become less flexible unless we also allowed for more finer grained customization ala something like Project Lombok's ""types"" and ""excludes"" interface customization for its @Delegate.;;;","05/Feb/13 02:11;oliver_plow;Something a bit more wild I have thought of is to make wrapper methods for delegate methods (methods that redirect the method call to the delegate class) selectively private or public. For example:
{code}
class Foo {
	def String foo;
}

class Bar {
	@Delegate
	def private Foo foo = new Foo()

	def bar() {		
		setFoo(""hi"") // okay, since inst var foo declared inside class
	}
}

class Test {
	def static main(String[] args) {
		def Bar bar = new Bar()
		bar.getFoo() // makes sense to allow for this?
	}
}
{code}

In Test.main bar.getFoo() can be called. Compiler won't complain singe the delegate wrapper method for Foo.getFoo() in class Bar was declared public just as Foo.getFoo(). But this breaks encapsualtion of my Bar class now. Inst var foo is private in Bar and hence I don't want foo to be accessible from outside class Bar.

Just some point I wanted to mention which struck my mind.;;;","06/Feb/13 05:31;paulk;Some interesting ideas but I am worried that this issue might lose focus in which case experience has shown that it is less likely that it will receive attention.

Is your main concern that you would like a compile error? Is there a way we can improve the doco that would change your expectations with respect to your comment: ""people expect @Delegate to be type-safe""? I can see the scope for potential confusion though I am not sure it is strictly a type-safety issue.

Would an extra boolean parameter (perhaps ""strict=true"") that forced a compile-time error for the case above suit your needs? Perhaps defaulting to false for backwards compatibility reasons?;;;","10/Feb/13 15:49;oliver_plow;Hi Paul, thanks for the effort you took to deal with this matter. About type-safety: If aFoo called a private method of CommonDelegate a compile-time error would be displayed (at least in IDEA) as only a public method of CommonDelegate could be called from aFoo. Now, if there are ambiguous calls to getValue() the user would also expect the compiler to drop a note about it.

About the other issue I mentioned in the sample with a class Foo and a class Bar: I found some interesting documentt about it: http://ecs.victoria.ac.nz/twiki/pub/Main/TechnicalReportSeries/ECSTR11-01.pdf (I managed to download it with Chrome). There it says on p.69: ""Embedding
a type publishes all of the embedded types public members, because GO has only two visibility scopes and GO does not provide an alternative mechanism for hiding members of embedded types."". This is exactly what I was refering to. In Go, there is apparently nothing that can be done about it. But the issue could be addressed in Groovy's @Delegate transformation ;-).;;;","11/Feb/13 03:19;oliver_plow;Now I found another interesting one ;-). This is valid Kotlin code that compiles an runs:

{code}
open trait Base
{

    protected fun base() : Unit {
        println(""base"")
    }
}

open class BaseImpl : Base {

}

open class C() {
    fun foo() {
        println(""foo"")
    }
}

class Derived(b : Base = BaseImpl()) : Base by b, C() {

    fun baseDerived() : Unit {
        base()
    }

}

fun main(args: Array<String>)

{
    val d = Derived()
    d.baseDerived()
}
{code}

It prints ""base"" to the console. Note that method base() in trait Base is declared protected. Nevertheless, it can be seen from within class Derived, where it is called from within baseDervied(). What I mean is that there is a point in allowing access to protected methods/vars. Something to think about for the @Delegate annotation. Just intended as some input :-).;;;","11/Feb/13 19:09;paulk;I will try to summarise what I think you are saying:
# it would be good to have some warning or error when multiple methods with the same signature are available for delegation
# it would be useful to make protected methods of delegates available as protected methods in the owner class

Wrt (1): currently methods are not carried over to the owner class if a method already exists with the same signature - hence if the owner or one of its subclasses doesn't have a particular method and multiple delegates do, the first mentioned delegate wins. Our options would be to omit an error or warning. We tend to leave warnings in the realm of IDEs and CodeNarc style tools. So, we _could_ make this a compile-time error. This would be a breaking change and hence we would typically at least have a way to turn it on/off (e.g. strict=true). Even so, I think the strict mode would not be very flexible - there is no way to control which methods come from which interfaces, e.g. suppose I want printName from Person and printAddress from Customer assuming both classes/interfaces have both methods. You can't use order in the class to achieve the desired delegation. So I would encourage long hand in that scenario. The alternative would be to provide something like Project Lombok's types and excludes options as mentioned in an earlier comment.

Wrt (2): that is certainly possible - I guess it would need to be turned on and off rather than always mandatory - so it's a case of complicating the interface for a small gain in terms of flexibility - there is a separate activity to allow traits to be defined in Groovy - my inclination is to wait and see if it addresses mixing in a protected method in this way. If it does, I would tend to leave it out of @Delegate which can then be just pure delegation.;;;","12/Feb/13 04:56;oliver_plow;{quote}suppose I want printName from Person and printAddress from Customer assuming both classes/interfaces have both methods. You can't use order in the class to achieve the desired delegation.{quote}That's right. The user would have to resolve the ambuiguity by explicitly sending prinName and printAddress to the applicable delegate.

{quote}there is a separate activity to allow traits to be defined in Groovy - my inclination is to wait and see if it addresses mixing in a protected method in this way.{quote}Would be very interested in this traits activity. Sounds cool.

{quote}If it does, I would tend to leave it out of @Delegate which can then be just pure delegation.{quote}Sure, I understand you want to keep @Delegate backwards compatible.
;;;","12/Feb/13 05:23;oliver_plow;I think another issue is that multiple delegates may result in similar problems as with mutliple inheritance. So, may be a good idea not to advance too quick here. I think I will make my private clone of @Delegate and change it for my experimental needs and this issue can be closed then.;;;","12/Feb/13 22:19;paulk;Wrt (2) above: I'll assume your request is closed.

Wrt (1) I think it might be worthwhile to have filtering similar to Project Lombok anyway, so I'll leave this issue open to achieve that goal.

Wrt ""multiple inheritance"". Different languages have different solutions to mitigating against the diamond problem (see http://en.wikipedia.org/wiki/Multiple_inheritance#Mitigation) so I don't see any issue here as long as it is clearly defined.;;;","12/Feb/13 22:21;paulk;Title updated to reflect previous comment.;;;","29/Aug/13 04:36;paulk;Created a clone to handle advanced use case - see GROOVY-6329

Advanced use cases might include introducing the following annotation parameters {{strict}}, {{includeTypes}}, {{excludeTypes}}. I'll keep the simple use cases which can be handled with {{includes}}, {{excludes}} in this issue.;;;","29/Aug/13 20:59;paulk;annotation parameters {{includes}} and {{excludes}} added.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
jarjar issue with CliBuilder/GroovyPosixParser,GROOVY-5971,12816787,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,02/Feb/13 04:42,07/Apr/15 19:07,14/Jul/23 06:01,02/Feb/13 04:49,2.1.0,,,,,,,,,,,,,,,,,2.1.1,2.2.0-beta-1,,,command line processing,,,,0,,,,,,,"Due to bugs which won't be fixed until a future version of Commons CLI, we included our own ""fixed"" parser. Unfortunately, the jarjar processing wasn't altered to account for our own class in the Commons CLI package.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Feb 02 04:49:09 UTC 2013,,,,,,,,,,"0|i2bxjb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Feb/13 04:49;paulk;Put in place a fix. This involved creating two identical classes. The first class org.apache.commons.cli.GroovyInternalPosixParser is used internally by Groovy and the package changes depending on whether it is jarjar'd into the all jar. The other class org.codehaus.groovy.cli.GroovyPosixParser is used by CliBuilder and remains with a fixed package. This latter class is also feasible for end users to use who want to avoid some of the bugs in commons CLI 1.2 but will probably be deprecated some time after CLI 1.3 is released - so should be used with care.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Exception in phase 'class generation',GROOVY-5963,12816757,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,31/Jan/13 04:40,16/Feb/13 00:47,14/Jul/23 06:01,11/Feb/13 11:00,2.1.0,,,,,,,,,,,,,,,,,2.0.7,2.1.1,,,Static compilation,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
class Test {
    public static void main(String[] args) {
        def fieldMatcher = '[x=1] [a=b] [foo=bar]' =~ ~""\\[([^=\\[]+)=([^\\]]+)\\]""
        assert fieldMatcher
        def pairs = fieldMatcher.collect { it[1..2] }
    }
}
{code}",,ddimitrov,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 11 11:00:24 UTC 2013,,,,,,,,,,"0|i2cslj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Jan/13 04:46;ddimitrov;Another (simpler) test:

{code}
@groovy.transform.CompileStatic
class Test {
    public static void main(String[] args) {
        def fieldMatcher = '[x=1] [a=b] [foo=bar]' =~ ~""\\[([^=\\[]+)=([^\\]]+)\\]""
        assert fieldMatcher
        def value = fieldMatcher[0][0]
    }
}
{code};;;","31/Jan/13 04:48;melix;Obviously, the {{collect}} method misses the type for argument {{it}} but the type checker should have complained. A workaround is to use an explicit type here:
{code}
List it -> it[1..2]
{code};;;","31/Jan/13 18:56;ddimitrov;Ok, inserting a few casts here and there fixes it, but I would think that the typechecker should have been smarter. 

In particular, this feels wrong:

{code}
def matcher = str =~ SAPPHIRE_LOG_FORMAT
assert matcher
def match = matcher[0] as String[] // <-- why ??
String logLevelNum  = match[1]
{code}

Also, does the typechecker infer the possible return types from a closure? I would have expected not to have to specify explicit types in the findAll closure and the final returned value.

{code}
def pairs = fieldMatcher.collect { List it -> it[1..2] }
                        .findAll { List it -> !FILTERED_KEYS.contains(it[0]) } as List<String[]>
{code};;;","11/Feb/13 11:00;melix;I'm marking this as fixed because now the compiler will throw an error saying that you cannot call [0] on an Object.

The reason is that {{Matcher#getAt(int)}} returns an {{Object}}. It's a pity it's not always returning a {{List}}, but it's too late to change such a widely used feature.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@TypeChecked should have a default value for extensions,GROOVY-5962,12816767,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,30/Jan/13 10:33,16/Feb/13 00:47,14/Jul/23 06:01,30/Jan/13 10:35,2.1.0,,,,,,,,,,,,,,,,,2.1.1,,,,,,,,0,,,,,,,The {{@TypeChecked}} annotation accepts an optional argument called {{extensions}} but the current definition of the annotation makes it mandatory.,,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-30 10:33:08.0,,,,,,,,,,"0|i2c607:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
switch case misbehave with @Typechecked,GROOVY-5959,12816761,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,pootow,pootow,30/Jan/13 04:00,16/Feb/13 00:47,14/Jul/23 06:01,07/Feb/13 03:31,,,,,,,,,,,,,,,,,,2.0.7,2.1.1,,,Static Type Checker,,,,0,,,,,,,"you can try this in groovyconsole

{code}
import groovy.transform.TypeChecked

@TypeChecked
def test(Map<String, String> token) {
  switch(token.type) {
    case 'case one':
      println '1'
      '1'
      break
    case 'case two':
      println '2'
      '2'
      break
    default:
      println '3'
      '3'
      break
  }
  //uncomment line below to get it right
  //'ok'
}
{code}

given
{code}test([type:'case one']){code}
the result is 
{noformat}
1
2
3
Result: 3
{noformat}

After uncomment the 'ok' line, the result is
{noformat}
1
Result: ok
{noformat}",,pootow,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-30 04:00:51.0,,,,,,,,,,"0|i2cqrr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
'Allowed Interruption' menu item is missing at GroovyConsole on MacOSX,GROOVY-5958,12816696,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,asteingress,nobeans,nobeans,29/Jan/13 23:42,05/Apr/15 14:44,14/Jul/23 06:01,30/Jan/13 04:28,2.1.0,,,,,,,,,,,,,,,,,1.8.9,2.0.7,2.1.1,2.2.0-beta-1,Groovy Console,,,,0,,,,,,,"the menu item of enabling @ThreadInterrupt is missing at MacOSX. though it exists in BasicMenuBar.groovy, it doesn't exists in MacOSXMenuBar.groovy.","MacOSX 10.8.2, Groovy 2.1.0",asteingress,nobeans,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Wed Jan 30 04:27:39 UTC 2013,,,,,,,,,,"0|i2c7tz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jan/13 23:43;nobeans;sent pull request: https://github.com/groovy/groovy-core/pull/130;;;","30/Jan/13 04:27;asteingress;Merged into master. Added a test case ensuring the same number of menu sub elements for the Mac and the basic menubar.

https://github.com/groovy/groovy-core/commit/6d69b86806d5917270769bbda64295b00dbdf70d;;;","30/Jan/13 04:27;asteingress;Thanks for the contribution!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc does not create links for non-fully qualified classes in same package,GROOVY-5957,12816744,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jeffastorey,jeffastorey,29/Jan/13 20:33,08/Jul/14 15:28,14/Jul/23 06:01,18/Jun/14 21:20,2.0.7,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,,GroovyDoc,,,,0,usertask,,,,,,"If my groovydoc link is {@link MyClass} instead of {@link com.pack.MyClass}, the link is generated with <code> tags instead of an html link, even if the class with the link is also in com.pack.

The javadoc spec allows a link to omit the full package name when the class being linked to is in the same package.",,asteingress,jeffastorey,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Jun/14 20:25;jeffastorey;gdoc.zip;https://issues.apache.org/jira/secure/attachment/12723104/gdoc.zip","16/Jun/14 20:25;jeffastorey;gdoc_html.zip;https://issues.apache.org/jira/secure/attachment/12723213/gdoc_html.zip",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 20 08:57:34 UTC 2014,,,,,,,,,,"0|i2buq7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Feb/13 09:06;asteingress;That issue should already be fixed as part of GROOVY-5940. The fix has made it into 1.8.9, 2.0.7 or 2.1.1. 

Can you verify that?;;;","26/Feb/13 09:44;jeffastorey;I tried in 2.0.7 - it still appears to be a problem. Are you seeing different results?;;;","27/Feb/13 01:03;asteingress;I asked because 2.0.7 has been released mid-February and your issue was created in January. ;;;","27/Feb/13 07:01;jeffastorey;I originally saw the issue in 2.0.5 in January, but then re-verified in 2.0.7.;;;","29/May/14 04:09;paulk;I just examined a sample groovydoc file from a recent version of Groovy:
http://beta.groovy-lang.org/docs/groovy-2.3.1/html/gapi/groovy/beans/BindableASTTransformation.html
and checked the source:
https://raw.githubusercontent.com/groovy/groovy-core/master/src/main/groovy/beans/BindableASTTransformation.java

It appears that this works now, or perhaps more information can be provided on how to reproduce the problem?;;;","16/Jun/14 20:25;jeffastorey;I tried with groovy 2.3.2 and am still seeing the problem, though it's possible it's user error here. I have a link tag to another class in the same package but the tag doesn't use the fully qualified name and no HTML link is generated. Attached are the groovy files and the resulting output.

I ran {code}groovydoc *.groovy{code};;;","18/Jun/14 16:17;paulk;Indeed that shows the problem. I'll have to investigate what difference there is between that and and files in Groovy itself.;;;","18/Jun/14 19:58;paulk;Proposed fix: https://github.com/groovy/groovy-core/pull/455;;;","18/Jun/14 21:20;paulk;I believe this is fixed but if you spot any scenarios which don't work, please reopen.;;;","20/Jun/14 08:57;jeffastorey;Thanks, once the beta2 version is available for download, I'll give this a try.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Correct slow invocation path with EMC,GROOVY-5953,12811580,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,28/Jan/13 07:16,16/Feb/13 00:47,14/Jul/23 06:01,28/Jan/13 09:10,,,,,,,,,,,,,,,,,,2.1.1,,,,,,,,0,,,,,,,If EMC is enabled the current indy implementation takes the safe and slow path for invocation. If possible the faster path should be taken. The fast path has problems for constructor calls and property get. Those need to be fixed of course,,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 28 09:10:45 UTC 2013,,,,,,,,,,"0|i2cmbz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Jan/13 09:10;blackdrag;the slow path has been corrected partially, but property gets are still done using a slow path if EMC is enabled. Our custom callsite caching has the same problem. Fixing that part is up to MOP 2 I guess;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compile static: Groovyc reports error after instanceof check,GROOVY-5951,12816779,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,asteingress,mxm-groovy,mxm,27/Jan/13 05:07,17/Jun/15 20:10,14/Jul/23 06:01,04/Feb/13 01:08,2.0.6,,,,,,,,,,,,,,,,,2.1.0,,,,Static compilation,,,,0,,,,,,,"{code}
@CompileStatic
class AnnotationCollectorChecker {
  boolean checkApplicability(PsiElement annotation) {
    final PsiElement parent = annotation.parent
    if (parent instanceof GrModifierList) {
      final collector = parent.rawAnnotations //compile error 'Access to com.intellij.psi.PsiElement#rawAnnotations'
      if (collector != null) {
        return true
      }
    }

    return false
  }
}
{code}
I created a class in IntelliJ IDEA project and Groovy fails to compile it though GrModifierList has a 'getRawAnnotations()' method.

If I replace 'rawAnnotations' with 'getRawAnnotations()' Groovyc doesn't report errors.

PsiElement source https://github.com/JetBrains/intellij-community/blob/master/platform/core-api/src/com/intellij/psi/PsiElement.java

GrModifierList source https://github.com/JetBrains/intellij-community/blob/master/plugins/groovy/src/org/jetbrains/plugins/groovy/lang/psi/api/auxiliary/modifiers/GrModifierList.java

I'm sorry but I didn't manage to reproduce the issue on simple project",,asteingress,mxm,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 29 06:45:58 UTC 2013,,,,,,,,,,"0|i2calj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Jan/13 09:16;asteingress;I assume you're using 2.0.6. This issue is fixed in 2.1.0.;;;","29/Jan/13 00:38;mxm-groovy;Seems that you are right. ;;;","29/Jan/13 00:48;asteingress;A few type checking issues were not ported back to the 2.0.x branch. If its feasible for you to use 2.1.0, it would be great, as you would be on the safe side of having these issues fixed.;;;","29/Jan/13 06:26;mxm-groovy;BTW do you know where I can get groovy-all-2.1.jar ? 
;;;","29/Jan/13 06:36;pschumacher;[http://repo1.maven.org/maven2/org/codehaus/groovy/groovy-all/2.1.0/groovy-all-2.1.0.jar];;;","29/Jan/13 06:37;asteingress;http://search.maven.org/#artifactdetails%7Corg.codehaus.groovy%7Cgroovy-all%7C2.1.0%7Cjar;;;","29/Jan/13 06:45;mxm-groovy;thanks;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
memoizeAtLeast and memoizeBetween don't cleanup garbage-collected SoftReferences,GROOVY-5948,12816679,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,rluque,rluque,25/Jan/13 15:42,15/Oct/15 18:19,14/Jul/23 06:01,05/Apr/13 03:08,2.1.0,,,,,,,,,,,,,,,,,2.1.3,2.2.0-beta-1,,,groovy-jdk,,,,0,,,,,,,"Both Closure's methods memoizeAtLeast() and memoizeBetween() try to implement a memory-sensitive cache using SoftReference to the memoized values. However studying the iplementation I've noted that the SoftReference instances are not being registered with the ReferenceQueue, so when these SoftReferences are cleared by GC are not being removed from memoization cache.",,melix,paulk,pschumacher,rluque,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 05 03:08:37 UTC 2013,,,,,,,,,,"0|i2c61z:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"25/Jan/13 15:46;rluque;You can find unit tests showing the bug and the corresponding patch in the following pull request:
https://github.com/groovy/groovy-core/pull/128

;;;","31/Mar/13 15:44;pschumacher;The patch looks good as far as I can tell.

Can a member of the groovy core team please verify this? Thank you very much!;;;","01/Apr/13 17:53;paulk;I think that patch looks good but someone else on the core team might have more experience with SoftReference's than me. The one thing which I wanted to check was whether the call {{forceSoftReferencesRecollection()}} played nicely with our slow and fragile CI server.;;;","03/Apr/13 08:53;melix;Looks fine to me too apart from {{forceSoftReferencesRecollection}}. It's in unit tests, but it's likely to make the CI server even more fragile. I don't see any very reliable way to force soft references cleared.

The discussion here shows that even that method is not reliable: http://stackoverflow.com/questions/3785713/how-to-make-the-java-system-release-soft-references

Probably better to keep the tests but disable them.;;;","05/Apr/13 03:08;pschumacher;Applied. 

Thanks to Rafael Luque for reporting the bug and creating the patch. 

Thanks to Paul and Cédric for the review.

I deactivated the tests for now because they are only sometimes successful on the build server.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Build test failures on jdk8b78,GROOVY-5947,12816759,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,blackdrag,blackdrag,25/Jan/13 10:03,16/Feb/13 00:47,14/Jul/23 06:01,29/Jan/13 07:15,,,,,,,,,,,,,,,,,,2.1.1,,,,,,,,0,,,,,,,"When building Groovy with jdk8b78 (I did not test other jdk8) I get around 60 test failures of the form {code}java.lang.IllegalArgumentException
	at org.objectweb.asm.ClassReader.<init>(Unknown Source)
	at org.objectweb.asm.ClassReader.<init>(Unknown Source)
	at org.objectweb.asm.ClassReader.<init>(Unknown Source)
	at org.codehaus.groovy.runtime.ProxyGeneratorAdapter.createClassVisitor(ProxyGeneratorAdapter.java:256)
	at org.codehaus.groovy.runtime.ProxyGeneratorAdapter.<init>(ProxyGeneratorAdapter.java:158)
	at groovy.util.ProxyGenerator.instantiateAggregate(ProxyGenerator.java:161)
	at groovy.util.ProxyGenerator.instantiateAggregate(ProxyGenerator.java:139)
	at groovy.util.ProxyGenerator.instantiateAggregate(ProxyGenerator.java:135){code}
All of them with Cedric's ProxyGenerator, which is why I assign it to him.",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-25 10:03:37.0,,,,,,,,,,"0|i2cd2v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TypeChecker: Fails with NPE when use generics in inheritance tree?,GROOVY-5943,12816770,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,graemerocher,graemerocher,23/Jan/13 09:57,25/Jan/13 23:35,14/Jul/23 06:01,23/Jan/13 11:19,2.1.0-rc-3,,,,,,,,,,,,,,,,,2.1.0,,,,,,,,0,,,,,,,"Not sure the exact way to reproduce this. It is occuring in an inheritance tree in the Grails codebase.

Exception trace is:

{code}
[ant:groovyc] java.lang.NullPointerException
[ant:groovyc] 	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnT
[ant:groovyc] ypeGenerics(StaticTypeCheckingVisitor.java:3098)
[ant:groovyc] 	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnType
[ant:groovyc] Generics(StaticTypeCheckingVisitor.java:3002)
[ant:groovyc] 	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExp
[ant:groovyc] ression(StaticTypeCheckingVisitor.java:2054)
[ant:
{code}",,graemerocher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 23 10:01:30 UTC 2013,,,,,,,,,,"0|i2cfmv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jan/13 10:01;graemerocher;This was caused by a method that had the following signature:

{code}
protected Object createInstance(Class<?> projectComponentClass, BuildSettings buildSettings)
{code}

Notice the <?> generic type argument. This code was generated by Intellij extract method refactoring, hence why i left the <?> there. Removing this fixed the problem;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic error changes when portions of app moved from groovy to java or order of compilation changed,GROOVY-5942,12818211,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,aclement,aclement,23/Jan/13 09:45,08/Mar/22 12:16,14/Jul/23 06:01,29/May/21 15:51,2.0.6,,,,,,,,,,,,,,,,,,,,,Static compilation,,,,0,,,,,,,"These 3 files:

{code}Top.groovy
package q;
public class Top {
  protected String m = ""xyz"";
}
{code}

{code}Bottom.groovy
package q;
class Bottom extends Top {}
{code}

{code}Simple.groovy
package p;

@groovy.transform.CompileStatic
public class Simple {
  public static void main(String[] argv) {
    print new Bottom().m;
  }
{code}

compile all with groovyc, returns:

{code}
groovyc Simple.groovy Top.groovy Bottom.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Simple.groovy: 7: Access to q.Bottom#m is forbidden @ line 7, column 11.
       print new Bottom().m;
             ^

1 error
{code}

If we change Top.groovy > Top.java, it will compile clean:

{code}
groovyc -j Simple.groovy Top.java Bottom.groovy
{code}

If we kept the all groovy version and change the order, it will also compile clean:

{code}
groovyc Top.groovy Bottom.groovy Simple.groovy
{code}

I believe it is due to a combination of two things.

When the code generation step runs, whether the error comes out depends on whether Bottom has been tagged with ""GroovyObject"", which the call to the verifier adds.

When compiling them in the mixed case, stub generation forces the verifier to run on Bottom, it gets GroovyObject and then things compile clean.

When compiling all as groovy, if Simple is built first then Bottom does not have GroovyObject (error comes out), if Simple is built last, Bottom does have GroovyObject (errors does not come out).

In Groovy-Eclipse I improved the situation by pulling the call to the verifier out of the classgen step in CompilationUnit and running it as an earlier verify step.  This ensures all files get verified (and GroovyObject added) before the AsmClassGenerator runs (which is what produces the message).

On top of that I think the error should probably be coming out in all cases (unless groovy allows breaking these vis rules, I'm not sure on that) but the check doesn't seem quite right:

In StaticTypesCallSiteWriter

{code}
 private static boolean isDirectAccessAllowed(FieldNode a, ClassNode receiver, boolean isSamePackage) {
   
....
....

        // no getter
        return a.isPublic() || (a.isProtected() && isSamePackage);
}
{code}

protected doesn't mean you can access it if in the same package, which I think is what that condition check implies.  Default visibility means same package.  protected means class hierarchy visibility.

There is a piece of grails-core that currently compiles cleanly because of this situation. If the error were to be switched on for all variants, grails-core will need refactoring.
",,aclement,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 29 15:51:43 UTC 2021,,,,,,,,,,"0|i2ckev:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/May/21 15:51;emilles;The access checks have been corrected.  See {{org.codehaus.groovy.classgen.AsmClassGenerator#isFieldDirectlyAccessible}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic: VerifierError calling method within findAll closure,GROOVY-5941,12816709,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,graemerocher,graemerocher,23/Jan/13 04:02,25/Jan/13 23:35,14/Jul/23 06:01,23/Jan/13 10:30,2.1.0-rc-3,,,,,,,,,,,,,,,,,2.1.0,,,,Static compilation,,,,0,,,,,,,"If you comment out the following line (enabling static compilation):

https://github.com/grails/grails-core/blob/master/grails-aether/src/main/groovy/org/codehaus/groovy/grails/resolve/maven/aether/AetherDependencyManager.groovy#L492

Then run:

./gradlew grails-aether:test

You will get an error such as:

{code}

org.codehaus.groovy.grails.resolve.maven.AetherDependencyManagerSpec > Test dependencies inherited vs dependencies not inherited FAILED
    java.lang.VerifyError at AetherDependencyManagerSpec.groovy:185
{code}

Which is caused by

{code}
java.lang.VerifyError: (class: org/codehaus/groovy/grails/resolve/maven/aether/AetherDependencyManager$_getApplicationDependencies_closure5, method: doCall signature: (Lorg/codehaus/groovy/grails/resolve/Dependency;)Ljava/lang/Object;) Expecting to find integer on stack
	at org.codehaus.groovy.grails.resolve.maven.aether.AetherDependencyManager.getApplicationDependencies(AetherDependencyManager.groovy:494)
	at org.codehaus.groovy.grails.resolve.maven.AetherDependencyManagerSpec.Test dependencies inherited vs dependencies not inherited(AetherDependencyManagerSpec.groovy:185)
{code}",,graemerocher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-23 04:02:04.0,,,,,,,,,,"0|i2cftj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc does not show class hierarchy correctly,GROOVY-5940,12812096,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,asteingress,marshals,marshals,22/Jan/13 10:39,20/Feb/13 08:34,14/Jul/23 06:01,28/Jan/13 04:32,1.8.6,2.0.6,,,,,,,,,,,,,,,,1.8.9,2.0.7,2.1.1,2.2.0-beta-1,GroovyDoc,,,,0,,,,,,,"Attachment bug1.zip contains 2 groovy projects (""foo"" and ""bar"") plus an ant project (under folder ""ant"") to perform the groovydoc.  I've tried groovydoc by:
- running ""ant"" in the ""ant"" folder (I used apache-ant-1.8.4)
- running ""build.xml"" as an Ant Build in eclipse (I used juno-4.2)
The documentation is written to the folder ""doc"".  I used ""ant"" for the attachment version.

The build.xml copies the groovy files to a separate folder before invoking groovydoc.  AFAICS this makes no difference to this problem - I get the same if I direct groovydoc to use the groovy files in their project folders.

Class bar.Deriv is defined like this:
{code:title=bar.Deriv.groovy|borderStyle=solid}
package bar
class Deriv extends Base {
}
{code}

The page for bar.Deriv (doc/bar/Deriv.html) shows the hierarchy as:
{noformat}
java.lang.Object
  foo.Base
      bar.Deriv
{noformat}
However, bar.Deriv derives from *bar*.Base, not *foo*.Base.

If you create the documentation yourself and find that groovydoc gets the hierarchy correct for bar.Deriv, try looking at the page for foo.Deriv (doc/foo/Deriv.html).  It will get that one wrong instead.

I think this is wrong: groovydoc should be able to resolve the base class to the correct package.
",Win7 64bit,andre.steingress,asteingress,marshals,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"22/Jan/13 10:39;marshals;bug1.zip;https://issues.apache.org/jira/secure/attachment/12722185/bug1.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 20 08:34:49 UTC 2013,,,,,,,,,,"0|i2bqon:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Jan/13 11:38;andre.steingress;The internal data structures (GroovyClassDoc) hold the correct super class references, just wrote a test case for it.;;;","22/Jan/13 11:40;andre.steingress;I have to investigate template rendering, maybe it messes up the inheritance path. ;;;","23/Jan/13 07:21;andre.steingress;Okay, I could reproduce the behaviour with a GroovyDocTool using the GString templates. Will provide a patch asap.;;;","23/Jan/13 07:59;marshals;Thanks for the quick response.  Which versions will be patched?  (FWIW, we use 1.8.6.);;;","23/Jan/13 14:47;asteingress;Patch is ready at https://github.com/groovy/groovy-core/pull/124 waiting for internal review.;;;","23/Jan/13 15:00;asteingress;@Simon: the patch will be included in 1.8.9, 2.0.7 and 2.1.1;;;","28/Jan/13 04:29;asteingress;Merged.;;;","20/Feb/13 08:34;marshals;fix verified in 2.0.7 - thx;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc does not show link for property type,GROOVY-5939,12816641,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,asteingress,marshals,marshals,22/Jan/13 10:29,20/Feb/13 08:34,14/Jul/23 06:01,28/Jan/13 07:54,1.8.6,2.0.6,,,,,,,,,,,,,,,,1.8.9,2.0.7,2.1.1,2.2.0-beta-1,GroovyDoc,,,,0,,,,,,,"Attachment bug1.zip contains 2 groovy projects (""foo"" and ""bar"") plus an ant project (under folder ""ant"") to perform the groovydoc.  I've tried groovydoc by:
- running ""ant"" in the ""ant"" folder (I used apache-ant-1.8.4)
- running ""build.xml"" as an Ant Build in eclipse (I used juno-4.2)
The documentation is written to the folder ""doc"".  I used ""ant"" for the attachment version.

The build.xml copies the groovy files to a separate folder before invoking groovydoc.  AFAICS this makes no difference to this problem - I get the same if I direct groovydoc to use the groovy files in their project folders.

Class foo.Deriv is defined like this:
{code:title=foo.Deriv.groovy|borderStyle=solid}
class Deriv extends Base {
	Al.Enum alias = null
	Snafu[] snafu = null
}
{code}
where foo.Snafu is another class.

The page for foo.Deriv (doc/foo/Deriv.html) shows the property ""snafu"" has type ""Snafu"" but the type is not a hyperlink.  

I think this is wrong: groovydoc should make {{Snafu}} be a hyperlink (ie, to doc/foo/Snafu.html).
",Win7 64bit,asteingress,marshals,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"22/Jan/13 10:29;marshals;bug1.zip;https://issues.apache.org/jira/secure/attachment/12722375/bug1.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 20 08:34:43 UTC 2013,,,,,,,,,,"0|i2cs5r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Jan/13 01:54;asteingress;Here is the pull request:

https://github.com/groovy/groovy-core/pull/125;;;","28/Jan/13 07:53;asteingress;Merged.;;;","20/Feb/13 08:34;marshals;fix verified in 2.0.7 - thx;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc does not document array property correctly,GROOVY-5938,12816756,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,asteingress,marshals,marshals,22/Jan/13 10:22,20/Feb/13 08:34,14/Jul/23 06:01,28/Jan/13 07:53,1.8.6,2.0.6,,,,,,,,,,,,,,,,1.8.9,2.0.7,2.1.1,2.2.0-beta-1,GroovyDoc,,,,0,,,,,,,"Attachment bug1.zip contains 2 groovy projects (""foo"" and ""bar"") plus an ant project (under folder ""ant"") to perform the groovydoc.  I've tried groovydoc by:
- running ""ant"" in the ""ant"" folder (I used apache-ant-1.8.4)
- running ""build.xml"" as an Ant Build in eclipse (I used juno-4.2)
The documentation is written to the folder ""doc"".  I used ""ant"" for the attachment version.

The build.xml copies the groovy files to a separate folder before invoking groovydoc.  AFAICS this makes no difference to this problem - I get the same if I direct groovydoc to use the groovy files in their project folders.

Class foo.Deriv is defined like this:
{code:title=foo.Deriv.groovy|borderStyle=solid}
class Deriv extends Base {
	Al.Enum alias = null
	Snafu[] snafu = null
}
{code}
where foo.Snafu is another class.

The page for foo.Deriv (doc/foo/Deriv.html) shows the property ""snafu"" has type ""Snafu"".  

I think this is wrong: groovydoc should distinguish the property as an array by using {{[]}} after the type name ""Snafu"".
",Win7 64bit,asteingress,marshals,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"22/Jan/13 10:22;marshals;bug1.zip;https://issues.apache.org/jira/secure/attachment/12723087/bug1.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 20 08:34:30 UTC 2013,,,,,,,,,,"0|i2cbg7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"23/Jan/13 17:04;asteingress;Will be fixed with GROOVY-5939.;;;","24/Jan/13 01:54;asteingress;Here is the pull request:

https://github.com/groovy/groovy-core/pull/125;;;","28/Jan/13 07:52;asteingress;Merged.;;;","20/Feb/13 08:34;marshals;fix verified in 2.0.7 - thx;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc does not document type alias for property correctly,GROOVY-5937,12812169,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,asteingress,marshals,marshals,22/Jan/13 10:14,20/Feb/13 08:34,14/Jul/23 06:01,28/Jan/13 07:55,1.8.6,2.0.6,,,,,,,,,,,,,,,,1.8.9,2.0.7,2.1.1,2.2.0-beta-1,GroovyDoc,,,,0,,,,,,,"Attachment bug1.zip contains 2 groovy projects (""foo"" and ""bar"") plus an ant project (under folder ""ant"") to perform the groovydoc.  I've tried groovydoc by:
- running ""ant"" in the ""ant"" folder (I used apache-ant-1.8.4)
- running ""build.xml"" as an Ant Build in eclipse (I used juno-4.2)
The documentation is written to the folder ""doc"".  I used ""ant"" for the attachment version.

The build.xml copies the groovy files to a separate folder before invoking groovydoc.  AFAICS this makes no difference to this problem - I get the same if I direct groovydoc to use the groovy files in their project folders.

Class foo.Deriv is defined like this:
{code:title=foo.Deriv.groovy|borderStyle=solid}
package foo
import bar.Alias as Al
class Deriv extends Base {
	Al.Enum alias = null
	Snafu[] snafu = null
}
{code}
where bar.Alias.Enum is an enum type.

The page for foo.Deriv (doc/foo/Deriv.html) shows the property ""alias"" has type ""Al"".  

I think this is wrong: groovydoc should show the property type
- as either ""Al.Enum"" or ""bar.Alias.Enum"" 
- with a link to the page for bar.Alias.Enum (ie, to doc/bar/Alias.Enum.html)",Win7 64bit,asteingress,marshals,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"22/Jan/13 10:14;marshals;bug1.zip;https://issues.apache.org/jira/secure/attachment/12723014/bug1.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 20 08:34:14 UTC 2013,,,,,,,,,,"0|i2c5mv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"24/Jan/13 03:22;marshals;thinking about it - for the first point i think it should show the property type as  ""bar.Alias.Enum"", unless groovydoc also shows on the page for foo.Deriv the file's aliases such that the reader can see that ""Al"" is an alias for ""bar.Alias"".;;;","28/Jan/13 02:25;asteingress;afaik there isn't a mechanism in groovydoc that handles class aliasing. i will patch groovydoc to link to ""bar.Alias.Enum"" ;;;","28/Jan/13 07:54;asteingress;Fixed and merged.;;;","20/Feb/13 08:34;marshals;fix verified in 2.0.7 - thx;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.OutOfMemoryError through Iterator.collectEntries and others (part 2: handle others),GROOVY-5936,12816671,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,veita,veita,21/Jan/13 05:31,02/May/17 02:03,14/Jul/23 06:01,04/Aug/16 05:40,2.0.4,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,,groovy-jdk,,,,0,,,,,,,"DGM.collectEntries(Iterator, ...) naively calls toList(Iterator<T> self) to convert the Iterator to a list. There's no need to do this since iterator suffices to collect the entries. Even worse, toList uses ArrayList what may lead to multiple reallocations when the ArrayList's capacity must be enlarged.

Error:
Caught: java.lang.OutOfMemoryError: GC overhead limit exceeded

The same problems may occur when calling other methods that internally convert Iterator to lists.",,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5934,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 04 05:40:27 UTC 2016,,,,,,,,,,"0|i2bz4n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Aug/16 11:12;paulk;Just to clarify, the remaining DGM methods on Iterator which call toList are:
{code}
Iterator<T> unique(Iterator<T> self)
Iterator<T> unique(Iterator<T> self, @ClosureParams(value=FromString.class, options={""T"",""T,T""}) Closure closure)
Iterator<T> unique(Iterator<T> self, Comparator<T> comparator)

Iterator<T> sort(Iterator<T> self)
Iterator<T> sort(Iterator<T> self, Comparator<T> comparator)
Iterator<T> sort(Iterator<T> self, @ClosureParams(value=FromString.class, options={""T"",""T,T""}) Closure closure)

Iterator<T> toSorted(Iterator<T> self, Comparator<T> comparator)

Iterator<T> dropRight(Iterator<T> self, int num)
{code}
Of these, {{sort}} and {{toSorted}} aren't likely to gain us much. The {{dropRight}} method will have only minor gains. The {{unique}} methods should be relatively easy though we already have Iterator specific {{toUnique}} methods.;;;","03/Aug/16 12:15;paulk;The {{dropRight}} method now has an iterator-backed implementation.;;;","04/Aug/16 05:00;paulk;The {{unique}} closure variant now calls through to the comparator version, so one more off the list.;;;","04/Aug/16 05:40;paulk;I removed some superfluous calls to {{toList}} from the {{unique}} methods. Since for {{unique}}, {{sort}} and {{toSorted}} we have to traverse the Iterator entirely anyway, I don't think providing additional iterator-backed implementations will gain us much, so I am going to close this issue now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.OutOfMemoryError through Iterator.collectEntries and others (part 1: handle collectEntries),GROOVY-5934,12816765,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,veita,veita,21/Jan/13 03:02,21/Jan/13 14:13,14/Jul/23 06:01,21/Jan/13 05:33,2.0.4,,,,,,,,,,,,,,,,,2.1.0,2.1.0-rc-3,,,groovy-jdk,,,,0,,,,,,,"DGM.collectEntries(Iterator, ...) naively calls toList(Iterator<T> self) to convert the Iterator to a list. There's no need to do this since iterator suffices to collect the entries. Even worse, toList uses ArrayList what may lead to multiple reallocations when the ArrayList's capacity must be enlarged.

Error:
Caught: java.lang.OutOfMemoryError: GC overhead limit exceeded

The same problems may occur when calling other methods that internally convert Iterator to lists.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5936,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 21 05:33:28 UTC 2013,,,,,,,,,,"0|i2c487:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jan/13 05:02;paulk;yes, it was done to reduce code duplication but Iterator probably deserves its own version(s);;;","21/Jan/13 05:32;paulk;handling collectEntries as part of this issue - cloned to GROOVY-5936 to search for and fix other cases;;;","21/Jan/13 05:33;paulk;improved the collectEntries variants - thanks for the suggestion;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@TypeChecked$TypeCheckingInfo is added to constructors,GROOVY-5933,12816699,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,andre.steingress,andre.steingress,20/Jan/13 14:44,21/Jan/13 14:13,14/Jul/23 06:01,21/Jan/13 03:36,2.0.6,2.1.0-rc-2,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-3,,,Compiler,,,,0,,,,,,,"{code}
class Test {

   @groovy.transform.TypeChecked
   Test() {}
}
{code}

leads to the following compilation error:

Annotation @groovy.transform.TypeChecked$TypeCheckingInfo is not allowed on element CONSTRUCTOR

The TypeChecked$TypeCheckingInfo annotation must only be applied on methods.",,andre.steingress,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jan 20 14:46:37 UTC 2013,,,,,,,,,,"0|i2cakn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jan/13 14:46;andre.steingress;ConstructorNode instances should be ignored in StaticTypeCheckingVisitor#addTypeCheckingInfoAnnotation

Here is the pull request: https://github.com/groovy/groovy-core/pull/118;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
covariant method addition causing call to abstract method,GROOVY-5932,12816673,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,18/Jan/13 06:11,18/Jan/13 16:06,14/Jul/23 06:01,18/Jan/13 07:55,,,,,,,,,,,,,,,,,,1.8.9,2.0.7,2.1.0-rc-2,,,,,,0,,,,,,,"Executing the code below
{code:Java}
            class A {}
            class B extends A {}
            interface Contract {
                A method()
            }
            abstract class AbstractContract implements Contract {}
            class ContractImpl extends AbstractContract {
                B method(String foo='default') { new B() }
            }
            new ContractImpl().method()
{code}fails because ContractImpl#super$1$method():A tries to call Contract#method.",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 18 06:16:51 UTC 2013,,,,,,,,,,"0|i2c2hj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jan/13 06:16;blackdrag;Verifier changed method nodes that don't belong to the current ClassNode causing this problem as side effect;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.util.slurpersupport.GPathResult is not java.lang.Iterable,GROOVY-5931,12816758,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,veita,veita,18/Jan/13 05:44,10/Jul/13 04:42,14/Jul/23 06:01,27/Jan/13 21:15,2.0.4,2.0.6,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,groovy-jdk,,,,0,,,,,,,"Despite it has an iterator() method, GPathResult is not Iterable.

For this reason constructs like e.g.
{code}xml.theElement.collectEntries{ /* */ }{code}
don't work.",,andre.steingress,paulk,veita,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jan 27 21:15:31 UTC 2013,,,,,,,,,,"0|i2csr3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jan/13 03:28;andre.steingress;I assume that GPathResult was implemented before java.lang.Iterable. If there isn't any (non-obvious) reason to not implement java.lang.Iterable, this would be the patch to solve this issue:

https://github.com/groovy/groovy-core/pull/117

Please note: this patch DOES NOT introduce generic types along the GPathResult#iterator() class hierarchy. It just adds java.lang.Iterable<Object> to the GPathResult interfaces.



;;;","27/Jan/13 21:15;paulk;Pull request merged into master. If there is sufficient interest and no unintended side effects observed we could also consider merging into 2_1_X (for 2.1.1).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
-baseScript option for groovy command,GROOVY-5930,12816750,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,uehaj,uehaj,18/Jan/13 02:07,18/Jan/13 16:06,14/Jul/23 06:01,18/Jan/13 08:42,2.1.0-rc-1,,,,,,,,,,,,,,,,,2.1.0-rc-2,,,,command line processing,,,,0,,,,,,,"-baseScript option can be taked on groovyc(Groovy ahead of time compiler) command but groovy command don't interprete it.

IMHO, I like -basescript then -baseScript. Considering with -configscript option, those are should be under the same naming policy.

this is similar issue of GROOVY-5917",all,melix,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 18 08:42:15 UTC 2013,,,,,,,,,,"0|i2clt3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jan/13 02:34;melix;I'm not very keen on camel case options, especially since some systems (that I won't name here ;)) are case sensitive and others not :);;;","18/Jan/13 08:42;melix;Changed from {{baseScript}} to {{basescript}};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonBuilder.toPrettyString() incorrect for zero-length String,GROOVY-5927,12816698,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,thompson2526,thompson2526,17/Jan/13 13:10,18/Jan/13 16:06,14/Jul/23 06:01,17/Jan/13 23:42,2.1.0-rc-1,,,,,,,,,,,,,,,,,2.0.7,2.1.0,2.1.0-rc-2,,groovy-jdk,,,,0,,,,,,,"JsonBuilder.toString() works correctly for both zero-length and longer strings. JsonBuilder.toPrettyString() incorrectly inserts a pair of escaped double-quotes into the output for zero-length strings.


Consider the following test case:
{code}
import groovy.json.*
import groovy.util.GroovyTestCase
class MyTest extends GroovyTestCase {
  void testStringZero() {
    def m = [ s3:'abc', s0:'' ]
    def json = new JsonBuilder( m )
    def str = json.toString()
    def pretty = json.toPrettyString()
    def prettyTrim = pretty.replaceAll( ~/\s/, '' )

    if ( false ) {
      println ''
      println 'm: '           + m
      println 'str: '         + str
      println 'pretty: '      + pretty
      println 'prettyTrim: '  + prettyTrim
    }

    assert str == prettyTrim
  }
}
{code}


Enabling the prints produces:
{code}
m: [s3:abc, s0:]
str: {""s3"":""abc"",""s0"":""""}
pretty: {
    ""s3"": ""abc"",
    ""s0"": ""\""\""""
}
prettyTrim: {""s3"":""abc"",""s0"":""\""\""""}

E
Time: 0.165
There was 1 error:
1) testStringZero(MyTest)Assertion failed:

assert str == prettyTrim
       |   |  |
       |   |  {""s3"":""abc"",""s0"":""\""\""""}
       |   false
       {""s3"":""abc"",""s0"":""""}

{code}"," > groovy --version
Groovy Version: 2.1.0-rc-1 JVM: 1.7.0_09 Vendor: Oracle Corporation OS: Windows 7
",paulk,thompson2526,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Jan/13 13:10;thompson2526;bug3.groovy;https://issues.apache.org/jira/secure/attachment/12723011/bug3.groovy","17/Jan/13 13:10;thompson2526;bug3.out;https://issues.apache.org/jira/secure/attachment/12722378/bug3.out",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 17 23:42:32 UTC 2013,,,,,,,,,,"0|i2cb5j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"17/Jan/13 15:43;paulk;possible duplicate of GROOVY-5733 ?;;;","17/Jan/13 17:29;thompson2526;Yes, you are correct.  It is the same bug.;;;","17/Jan/13 23:42;paulk;pull request #113, thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ArrayIndexOutOfBounds when calling super method in SKIP @CompileStatic section,GROOVY-5926,12816565,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,17/Jan/13 10:03,18/Jan/13 16:06,14/Jul/23 06:01,17/Jan/13 10:08,2.0.6,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-2,,,Static compilation,,,,0,,,,,,,"The following code would produce an ArrayIndexOutOfBounds, due to missing call site array:

{code}
import groovy.transform.CompileStatic
import groovy.transform.TypeCheckingMode
@CompileStatic
class Top {
    public int foo() { 123 }
}
@CompileStatic
class Bottom extends Top {
    @CompileStatic(TypeCheckingMode.SKIP)
    public int bar() {
        foo()
    }
}
def obj = new Bottom()
assert obj.bar() == 123
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-17 10:03:14.0,,,,,,,,,,"0|i2brg7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Casting map as Random results in java.lang.VerifyError,GROOVY-5925,12816706,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mecameron,mecameron,17/Jan/13 09:31,18/Jan/13 16:06,14/Jul/23 06:01,18/Jan/13 03:54,2.0.0,2.0.1,2.0.2,2.0.4,2.0.5,2.0.6,2.1.0-rc-1,,,,,,,,,,,2.0.7,2.1.0,2.1.0-rc-2,,,,,,0,,,,,,,"When trying to cast a map as {{Random}} such as: 
{code:java}
Random random = [nextInt: { x -> return 0 }] as Random
{code}

the following exception is thrown:
{noformat}
WARNING: Sanitizing stacktrace:
java.lang.VerifyError: (class: Random1_groovyProxy, method: <init> signature: (JLjava/util/Map;)V) Register 2 contains wrong type
	at java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2404)
	at java.lang.Class.getConstructor0(Class.java:2714)
	at java.lang.Class.getConstructor(Class.java:1674)
	at org.codehaus.groovy.runtime.ProxyGeneratorAdapter.<init>(ProxyGeneratorAdapter.java:167)
	at groovy.util.ProxyGenerator.instantiateAggregate(ProxyGenerator.java:161)
	at groovy.util.ProxyGenerator.instantiateAggregateFromBaseClass(ProxyGenerator.java:117)
	at groovy.util.ProxyGenerator.instantiateAggregateFromBaseClass(ProxyGenerator.java:103)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.asType(DefaultGroovyMethods.java:7511)
	at org.codehaus.groovy.runtime.dgm$48.doMethodInvoke(Unknown Source)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1076)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:906)
	at org.codehaus.groovy.runtime.InvokerHelper.invokePojoMethod(InvokerHelper.java:836)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:827)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:164)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.asType(ScriptBytecodeAdapter.java:587)
	at ConsoleScript2.run(ConsoleScript2:1)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:257)
	at groovy.lang.GroovyShell.run(GroovyShell.java:481)
	at groovy.lang.GroovyShell.run(GroovyShell.java:163)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:951)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:906)
	at groovy.lang.Closure.call(Closure.java:412)
	at groovy.lang.Closure.call(Closure.java:406)
	at groovy.lang.Closure.run(Closure.java:490)
	at java.lang.Thread.run(Thread.java:722)
{noformat}

This worked in versions earlier than groovy 2.0.0","Mac OSX 10.8.2, Java 1.7.0_08-ea",andre.steingress,mecameron,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 18 04:08:43 UTC 2013,,,,,,,,,,"0|i2crsv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jan/13 23:54;paulk;A slightly tweaked version of your example:
{code}
ProxyGenerator.INSTANCE.debug = true
Random random = [nextInt: { x -> return 0 }] as Random
println random.nextInt()   // => 0
println random.nextInt(5)  // => 0
{code}
On 1.8.8 it outputs the 0's as noted above and spits out some debug source for the generated proxy.

We tweaked the ProxyGenerator in 2.0 and perhaps did not have an example similar to yours in our test suite of ""like-for-like"" examples.
;;;","18/Jan/13 03:14;andre.steingress;The problem is that double/long are 64-bit values and therefore 2 registers are needed. Thus the computation of the index variable for ""putField"" needed to be adjusted.

Here is the pull request: https://github.com/groovy/groovy-core/pull/114;;;","18/Jan/13 03:54;paulk;pull request merged - love your work - many thanks!;;;","18/Jan/13 04:08;andre.steingress;Thanks! It's an honor to hear that from you :-);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic: long loses type when bitwise OR applied to it,GROOVY-5922,12811909,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,17/Jan/13 07:34,21/Jan/13 14:13,14/Jul/23 06:01,21/Jan/13 05:21,2.1.0-rc-1,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-3,,,Static compilation,,,,0,,,,,,,"This code:

{code}
@groovy.transform.CompileStatic
class Test {
  long[] data
  long topMask
    
  void doSomething() {
    long mask = 0
    mask = mask | 0x1L
    data[ 0 ] = data[ 0 ] | mask
  }
}

new Test()
{code}

Gives the error:

{code}
[Static type checking] - Cannot assign value of type java.lang.Number to variable of type long
{code}

A workaround is to add a cast:

{code}
    data[ 0 ] = data[ 0 ] | (long)mask
{code}

But I think that might cause GROOVY-5921 to rear its head again...

Investigating",,andre.steingress,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 21 05:02:47 UTC 2013,,,,,,,,,,"0|i2cha7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jan/13 05:02;andre.steingress;StaticTypeCheckingVisitor#getResultType(...) doesn't unwrap from java.lang.Long to long. Therefore, the inferred type of mask is java.lang.Long. (long | java.lang.Long) in the end leads to taking the return type from the DGM.or(Number, Number) method.

Here is a pull request: https://github.com/groovy/groovy-core/pull/122;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BUG! exception in phase 'class generation' while poping argument from operand stack tracker,GROOVY-5921,12812099,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,17/Jan/13 07:26,01/Jun/13 06:11,14/Jul/23 06:01,18/Apr/13 10:06,2.1.0-rc-1,,,,,,,,,,,,,,,,,2.1.4,,,,Static compilation,,,,0,,,,,,,"The following fails with the above exception:

{code}
@groovy.transform.CompileStatic
class Test {
  long[] data
  long topMask
    
  void doSomething() {
    data[ 0 ] |= 0x7ffffffl
  }
}

new Test()
{code}

changing {{doSomething}} to:

{code}
void doSomething() {
  data[ 0 ] = data[ 0 ] | 0x7ffffffl
}
{code}

is a workaround

exception:

{code}
BUG! exception in phase 'class generation' in source unit 'ConsoleScript64' Error while poping argument from operand stack tracker in class Test method void doSomething().
	at org.codehaus.groovy.classgen.asm.OperandStack.popWithMessage(OperandStack.java:79)
	at org.codehaus.groovy.classgen.asm.OperandStack.popDownTo(OperandStack.java:60)
	at org.codehaus.groovy.classgen.asm.OperandStack.pop(OperandStack.java:167)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateArrayAssignmentWithOperator(BinaryExpressionHelper.java:531)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateBinaryExpressionWithAssignment(BinaryExpressionHelper.java:547)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionMultiTypeDispatcher.evaluateBinaryExpressionWithAssignment(BinaryExpressionMultiTypeDispatcher.java:347)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:130)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:529)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:511)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:457)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:321)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:278)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:398)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1059)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$15.call(CompilationUnit.java:795)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:573)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:551)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:528)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:279)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:258)
{code}",,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 17 08:14:58 UTC 2013,,,,,,,,,,"0|i2cbnb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jan/13 07:50;tim_yates;FYI {{&=}} causes the same issue;;;","17/Jan/13 08:14;tim_yates;Some more info, it works if the variable is not an array of {{long}}

{code}
@groovy.transform.CompileStatic
class Test {
  long data
  long topMask
    
  void doSomething() {
    long mask
    data |= mask
  }
}

new Test()
{code}

Compiles fine;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type not inferred from Iterator<Data<String>>,GROOVY-5920,12818225,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,tim_yates,tim_yates,17/Jan/13 06:44,14/Oct/13 16:53,14/Jul/23 06:01,06/Aug/13 09:07,2.1.0-rc-1,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Static compilation,,,,1,,,,,,,"Given a Generic DTO

{code}
@groovy.transform.CompileStatic
@groovy.transform.Immutable( knownImmutableClasses = [T] )
class Data<T> {
  T value
}
{code}

We can then make an iterator that returns a String variant of these:

{code}
@groovy.transform.CompileStatic
class StringDataIterator implements Iterator<Data<String>> {
  boolean hasNext() { true }
  void    remove()  {}

  Data<String> next() {
    new Data<String>( value: 'tim' )
  }
}
{code}

But when we come to test this all:

{code}
@groovy.transform.CompileStatic
class Runner {
  static main( args ) {
    Data<String> elem = new StringDataIterator().next()
    println elem.value.length()
  }
}
{code}

We get:

{code}
[Static type checking] - Cannot find matching method java.lang.Object#length(). Please check if the declared type is right and if the method exists.
{code}

",,blackdrag,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 06 09:07:46 UTC 2013,,,,,,,,,,"0|i2bvuf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Aug/13 09:07;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Multiple problems with @CompileStatic and abstract inheritance,GROOVY-5919,12818209,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,graemerocher,graemerocher,17/Jan/13 03:30,18/Jan/13 16:06,14/Jul/23 06:01,17/Jan/13 03:54,2.0.6,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-2,,,Static compilation,,,,0,,,,,,,"if you checkout https://github.com/grails/grails-core/tree/list-plugins-fix

and run ./gradlew install
then use that as your Grails install and if you do:

{code}
grails create-app foo
cd foo
grails compile
{code}

You will get:

{code}
(class: org/codehaus/groovy/grails/resolve/maven/aether/AetherDependencyManager, method: super$1$resolve signature: ()Lorg/codehaus/groovy/grails/resolve/DependencyReport;) Illegal use of nonvirtual function call
java.lang.VerifyError: (class: org/codehaus/groovy/grails/resolve/maven/aether/AetherDependencyManager, method: super$1$resolve signature: ()Lorg/codehaus/groovy/grails/resolve/DependencyReport;) Illegal use of nonvirtual function call
{code}

if you open up AbstractDependencyManager and uncomment the @CompileStatic

run ./gradlew install again

you will get the strange compilation error:

{code}
[ant:groovyc] /Developer/grails-dev/grails-master/grails-aethe
[ant:groovyc] r/src/main/groovy/org/codehaus/groovy/grails/resolve/maven/aether/AetherDependencyManager.groovy: -1: You are not allowed to ove
[ant:groovyc] rride the final method pfaccess$0() from class 'org.codehaus.groovy.grails.resolve.AbstractDependencyManager'.
[ant:groovyc] ÃâÃÂ @ line -1, colum
[ant:groovyc] n -1.
[ant:groovyc] 1 error
{code}",,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 17 03:55:47 UTC 2013,,,,,,,,,,"0|i2bxbz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jan/13 03:55;melix;Fix is for ""you are not allowed to override the final method pfaccess$0"", I will create another issue for the {{VerifyError}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonBuilder.toString() fails with StackOverflowError when using Expando,GROOVY-5918,12816720,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,thompson2526,thompson2526,16/Jan/13 23:32,21/Jan/13 14:13,14/Jul/23 06:01,21/Jan/13 04:38,2.1.0-rc-1,,,,,,,,,,,,,,,,,2.0.7,2.1.0,2.1.0-rc-3,,groovy-jdk,,,,0,,,,,,,"When JsonBuilder is constructed with an Expando parameter, the toString() method fails with a StackOverflowError.  A partial workaround is to convert to use Expando.getProperties() to convert the Expando into a Map, but this fails for any nested Expandos.

Example code & output are attached.

Alan Thompson"," > groovy --version
Groovy Version: 2.1.0-rc-1 JVM: 1.7.0_09 Vendor: Oracle Corporation OS: Windows 7",paulk,thompson2526,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Jan/13 23:32;thompson2526;bug1.groovy;https://issues.apache.org/jira/secure/attachment/12723043/bug1.groovy","16/Jan/13 23:32;thompson2526;bug1.out;https://issues.apache.org/jira/secure/attachment/12722933/bug1.out",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 21 04:38:26 UTC 2013,,,,,,,,,,"0|i2cj0v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jan/13 23:38;thompson2526;Here is the source code:

{code}
#!/usr/bin/env groovy
import groovy.json.*

def info = new Expando( tst:'val' )
def infoMap = info.getProperties()
assert infoMap instanceof Map

println ''
println 'info:    ' + info
println 'infoMap: ' + infoMap

def json1 = new JsonBuilder( infoMap )
println '\n json1.toPrettyString()'
println     json1.toPrettyString()

println '\n Building...'
def json2 = new JsonBuilder( info )
println '\n json2.dump()'
println     json2.dump()
println '\n json2.toString()'
println     json2.toString()
println '\n json2.toPrettyString()'
println     json2.toPrettyString()
{code};;;","16/Jan/13 23:39;thompson2526;Here is the output:
{code}
> ./bug1.groovy

info:    {tst=val}
infoMap: [tst:val]

 json1.toPrettyString()
{
    ""tst"": ""val""
}

 Building...

 json2.dump()
<groovy.json.JsonBuilder@4675bf45 content={tst=val}>

 json2.toString()
Caught: java.lang.StackOverflowError
java.lang.StackOverflowError

>
{code};;;","20/Jan/13 13:12;tim_yates;Had a quick look, and I think this is caused by the fix to GROOVY-5494;;;","20/Jan/13 14:57;tim_yates;Pull request submitted

https://github.com/groovy/groovy-core/pull/120;;;","21/Jan/13 04:38;paulk;pull request merged, thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
-configscript option for groovy command.,GROOVY-5917,12816736,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,uehaj,uehaj,16/Jan/13 18:48,18/Jan/13 16:06,14/Jul/23 06:01,18/Jan/13 08:41,2.1.0-rc-1,,,,,,,,,,,,,,,,,2.1.0-rc-2,,,,command line processing,,,,0,,,,,,,"-configscript option can be taked on groovyc(Groovy ahead of time compiler) command but groovy command don't interprete it.

",all,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Jan/13 04:52;uehaj;patch.txt;https://issues.apache.org/jira/secure/attachment/12723118/patch.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 17 04:52:13 UTC 2013,,,,,,,,,,"0|i2cmgv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jan/13 04:52;uehaj;This is a patch for this issue.
I only tested with following two configScripts.

{code}
// compConfig.groovy
import groovy.transform.ToString
import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer

withConfig(configuration) {
  ast(ToString)
}
{code}

{code}
// compConfig2.groovy
import groovy.transform.*

withConfig(configuration) {
   source(extension: 'sgroovy') {
      ast(CompileStatic)
   }
}
{code}

with command line:
{quote}
groovy -configscript compConfig.groovy A.sgroovy
groovy -configscript compConfig2.groovy A.sgroovy
{quote}

where A.sgroovy is:

{code}
import groovy.transform.*

class A {
  int n
  void foo(x){
    println x.toString()
  }
  static main(args){
    (new A()).foo(""abc"")
    println new A().toString()
  }
}
{code}


;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TokenException returns wrong endColumn value,GROOVY-5915,12816721,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,paulk,rcruzjo,rcruzjo,16/Jan/13 11:41,18/Jan/13 16:06,14/Jul/23 06:01,16/Jan/13 20:09,2.0.6,2.1.0-rc-1,,,,,,,,,,,,,,,,2.0.7,2.1.0,2.1.0-rc-2,,,,,,0,,,,,,,"I'm having the following error. When an org.codehaus.groovy.syntax.TokenException is thrown, the value it returns when calling the getEndColumn() isn't the right one.
This issue is related with GROOVY-5635, but it seems that the solution made available there isn't working because this class overrides said method, returning always ""getStartColumn()+1"".
I believe that the solution is deleting such method, so the parent's implementation is used instead.

I would really appreciate if this issue is solved for the upcoming 2.1.0 final (and 2.0.7) release because we're integrating the compiler with an IDE and this problem prevents proper error syntax highlighting. ",,ariel.andres.morelli,guillaume,paulk,rcruzjo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Jan/13 13:39;rcruzjo;TestCase.groovy;https://issues.apache.org/jira/secure/attachment/12722543/TestCase.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 17 07:52:25 UTC 2013,,,,,,,,,,"0|i2c6if:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jan/13 12:50;guillaume;Do you have a patch with a test case?;;;","16/Jan/13 13:39;rcruzjo;TestCase added. As stated before, the solution would be to delete the method getEndColumn() from TokenException so it uses the default implementation from SyntaxException.;;;","16/Jan/13 20:09;paulk;fixed as per your suggestion, thanks;;;","17/Jan/13 06:44;ariel.andres.morelli;Can this fix be backported to 2.0.X branch?
Thanks;;;","17/Jan/13 07:12;paulk;Yes, it is already in the 2_0_X branch.;;;","17/Jan/13 07:52;ariel.andres.morelli;Thanks for fixing this quickly! :-);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@InheritConstructors fails when super class has raw constructor parameters,GROOVY-5914,12811611,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,gromopetr,gromopetr,16/Jan/13 11:00,28/Dec/14 07:40,14/Jul/23 06:01,28/Dec/14 07:40,1.8.6,,,,,,,,,,,,,,,,,2.0.6,,,,xforms,,,,0,,,,,,,"Inspired by http://youtrack.jetbrains.com/issue/IDEA-98494

Create a Java class:

{code}
import java.util.Map;

public class Super {
    public Super(Map m) {
    }
}
{code}

Compile it. After that create a Groovy class:

{code}
import groovy.transform.InheritConstructors

@InheritConstructors
class SubClass extends Super {

}
{code}

Compile it so that Super.class is in the classpath. The compilation will fail:
{noformat}
A transform used a generics containing ClassNode java.util.Map <K extends java.lang.Object -> java.lang.Object, V extends java.lang.Object -> java.lang.Object> for the constructor public void <init>(java.util.Map param0)  { ... } directly. You are not suppposed to do this. Please create a new ClassNode refering to the old ClassNode and use the new ClassNode instead of the old one. Otherwise the compiler will create wrong descriptors and a potential NullPointerException in TypeResolver in the OpenJDK. If this is not your own doing, please report this bug to the writer of the transform.
{noformat}
",,gromopetr,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 17 07:17:50 UTC 2013,,,,,,,,,,"0|i2bzzz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jan/13 20:16;paulk;code tags;;;","16/Jan/13 23:51;paulk;I can replicate what you are observing with 1.8.6 but not with 2.0.6 or on master. I haven't tried with the latest 1_8_X branch yet.;;;","17/Jan/13 07:17;paulk;And after checking, it also fails with the latest 1_8_X code. So it is something we have fixed in the 2 branch but that hasn't been back-ported.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Static compilation: Groovy doesn't fail compilation when accessing package scope methods, but fails at runtime",GROOVY-5912,12816704,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,graemerocher,graemerocher,16/Jan/13 03:43,26/Jul/18 04:38,14/Jul/23 06:01,15/May/18 15:42,2.0.6,,,,,,,,,,,,,,,,,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,,Static compilation,,,,2,,,,,,,"If you set a package scoped property from another package, this compiles but at runtime you get errors like:

{code}

tried to access method org.codehaus.groovy.grails.core.io.PluginPathAwareFileSystemResourceLoader.setSearchLocations(Ljava/util/Collection;)V from class org.codehaus.groovy.grails.project.loader.GrailsProjectLoader
java.lang.IllegalAccessError: tried to access method org.codehaus.groovy.grails.core.io.PluginPathAwareFileSystemResourceLoader.setSearchLocations(Ljava/util/Collection;)V from class org.codehaus.groovy.grails.project.loader.GrailsProjectLoader

{code}

This should not happen and be a compilation error",,daniel_sun,graemerocher,mauromol,werickson,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 15 15:42:19 UTC 2018,,,,,,,,,,"0|i2c0cf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/May/18 15:42;daniel_sun;Fixed by https://github.com/apache/groovy/commit/b1cc8a6ae14f15ad5a413f68fa946ecbeafe877e;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Non found static type checking extensions throw unexplicit NPE,GROOVY-5910,12816715,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,guillaume,guillaume,15/Jan/13 04:40,18/Jan/13 16:06,14/Jul/23 06:01,15/Jan/13 08:46,2.1.0-rc-1,,,,,,,,,,,,,,,,,2.1.0-rc-2,,,,Static Type Checker,,,,0,,,,,,,"Specifying a static type checking extension that doesn't exist or isn't found on the classpath throws a NullPointerException which doesn't give the user much clue about what happened.

Instead of throwing an NPE, I suggest we throw a compilation error instead, with an explicit message.",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-15 04:40:25.0,,,,,,,,,,"0|i2c3xb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Object.with seems to lose typing when generics are used,GROOVY-5907,12816731,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,14/Jan/13 04:39,18/Jan/13 16:06,14/Jul/23 06:01,17/Jan/13 07:45,2.1.0-rc-1,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-2,,,,,,,0,,,,,,,"The following code:

{code}
@groovy.transform.CompileStatic
class Test {
  static List<String> a( String s ) {
    s.with { String it -> [ ""$it"" ] }
  }
}

assert Test.a( 'tim' ) == [ 'tim' ]
{code}

Gives the error:

{code}

[Static type checking] - Cannot return value of type java.lang.Object on method returning type java.util.List <String>
 at line: 4, column: 5
{code}",,andre.steingress,melix,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 17 07:45:03 UTC 2013,,,,,,,,,,"0|i2c113:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jan/13 04:30;andre.steingress;Here is the pull request: https://github.com/groovy/groovy-core/pull/111

In the case of an Object#with(Closure) call, the inferred return type of the closure will be chosen as actual return type.;;;","17/Jan/13 07:45;melix;Thanks AndrÃ©! I merged your fix into {{master}} and backported it to {{2.1.0-rc-x}} and {{2.0.x}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StackOverflow with CompileStatic,GROOVY-5906,12816734,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,14/Jan/13 04:24,18/Jan/13 16:06,14/Jul/23 06:01,15/Jan/13 08:02,2.1.0-rc-1,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-2,,,,,,,0,,,,,,,"If I do this:

{code}
@groovy.transform.CompileStatic
class Element {
  String name

  static Iterator<Element> single() {
    [ new Element( name: 'single' ) ].iterator()
  }

  static Iterator<List<Element>> multi() {
    [ [ new Element( name: 'first' ), new Element( name: 'second' ) ] ].iterator()
  }

  static caller( boolean useSingle ) {
    useSingle ? single() : multi()
  }
}

println Element.caller( false ).collect()
println Element.caller( true ).collect()
{code}

I get:

{code}
java.lang.StackOverflowError
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:2936)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolve(StaticTypeCheckingVisitor.java:2912)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:2936)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolve(StaticTypeCheckingVisitor.java:2912)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:2936)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolve(StaticTypeCheckingVisitor.java:2912)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:2936)
  ...
{code}",,melix,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 15 08:02:13 UTC 2013,,,,,,,,,,"0|i2bskf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Jan/13 04:32;tim_yates;Stacktrace is wrong..  (was running 2.0.6 console) with 2.1.0-rc-1, it is:

{code}
java.lang.StackOverflowError
	at org.codehaus.groovy.ast.ClassNode.isUsingGenerics(ClassNode.java:1368)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:3036)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolve(StaticTypeCheckingVisitor.java:3018)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:3042)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolve(StaticTypeCheckingVisitor.java:3018)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:3042)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolve(StaticTypeCheckingVisitor.java:3018)
{code}

Sorry about that :-(;;;","15/Jan/13 08:02;melix;I fixed the stack overflow, however there's still an issue with proper type checking of the inferred return type against the declared return type with regards to ""nested"" generics type.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@AutoClone excludes param works correctly only for COPY_CONSTRUCTOR AutoCloneStyle,GROOVY-5901,12816719,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,joshua68it,joshua68it,11/Jan/13 13:11,18/Jan/13 16:06,14/Jul/23 06:01,15/Jan/13 06:20,1.8.8,2.0.0,,,,,,,,,,,,,,,,1.8.9,2.0.7,2.1.0,2.1.0-rc-2,,,,,0,,,,,,,"It seems the clone() method added by AST transformation due to @AutoClone annotation doesn't correctly use info inserted in 'excludes' annotation param with CLONE and SERIALIZATION AutoCloneStyle (http://groovy.codehaus.org/gapi/groovy/transform/AutoClone.html)

It correctly works only for COPY_CONSTRUCTOR AutoCloneStyle

@AutoClone(style=COPY_CONSTRUCTOR, excludes = 'last')
class Person_C {
  String first, last
}

Please refer to my testcase published at http://groovyconsole.appspot.com/script/830001



",,hubbitus,joshua68it,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 15 06:20:50 UTC 2013,,,,,,,,,,"0|i2ccxr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"13/Jan/13 00:08;paulk;This is ""by design"" in some sense.

When using the {{CLONE}} style, {{super.clone()}} is called which does a bit-wise clone if you don't have your own base class overriding the behavior in {{Object}}. Here the {{includeFields}} and {{excludes}} parameters are used to control whether additional calls to the {{clone()}} method for each property/field will occur; for {{String}} fields like in your example this is effectively just an efficiency thing - String isn't {{Cloneable}} so {{clone()}} wouldn't be called in any case but it would avoid the conditional logic which did the check for {{Cloneable}}.

When using the {{SERIALIZATION}} style, the {{includeFields}} and {{excludes}} parameters are ignored and instead you should adjust your serialization implementation to reflect what properties/fields should be cloned.

I intend to adjust the documentation to better describe these ""features"" of {{@AutoClone}}.;;;","13/Jan/13 00:28;paulk;Proposed change is in master; let me know if this makes things clearer.

In terms of the actual implementation details, we are constrained somewhat by the current Java library design. The only thing I can think of doing in addition to the current implementation would be to explicitly go and set references to null (and potentially primitive types to default values) for ""excluded"" properties (and/or fields) but I suspect that we would only be setting ourselves up to allow the creation of poorly behaving clone implementations whereas the intention behind @AutoClone is to try to make it easier to implement one of the deemed ""best practice"" implementations of cloning given the known weaknesses and pitfalls of cloning in the Java world.;;;","14/Jan/13 02:50;joshua68it;Thank you Paul.

I discovered this ""feature"" using @AutoClone on a Grails domain class which, unexpectedly for me, clones  'id' and 'version' field.

I'd appreciate the new implementation you suggest. 

Do you think would it be possible to use default class constructor before ""copy"" the not excluded fields into the new instance?

;;;","14/Jan/13 05:44;paulk;One thing we could do is to introduce another style, e.g. SIMPLE - though I am a little worried that adding another style is just making things more complex. Having said that, I haven't thought much about use of @AutoClone in a Grails context so perhaps something is required. Anyway, I think there would be several possible ways to implement such a style.

# Same as CLONE but don't call super.clone() just copy the included properties/fields and also give a compile time error if the class has a super class (as we would have no way to ""clone"" the fields of the parent class)
# Same as above but instead of giving an error, call super.clone() iff there is a super class
# Make a protected cloneAttributes() method and have the public clone() method call that method - also calling super.cloneAttributes() if there is a super class (checking the method exists by either reflection or looking for the AutoClone annotation on the parent);;;","14/Jan/13 10:41;joshua68it;IMHO, I think the third implementation way would it be the best choice for flexibility.;;;","14/Jan/13 23:34;paulk;Proposed change:
https://github.com/paulk-asert/groovy-core/commit/9afe4d53
(this assumes that if a child class implements the {{SIMPLE}} style that its parent will also implement that style or has a manually added {{cloneOrCopyMembers}} method, otherwise a {{MissingMethodException}} will be thrown at runtime);;;","15/Jan/13 06:20;paulk;SIMPLE style added as per earlier comments

NOTE: the fix version applies to the javadoc improvements. SIMPLE is only in 2.1.0-rc-2 and above.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"withObject[Output|Input]Stream - auto detect 'it' type",GROOVY-5899,12816493,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,cazacugmihai,cazacugmihai,11/Jan/13 05:37,05/Apr/14 00:00,14/Jul/23 06:01,15/Jan/14 11:14,2.1.0-rc-1,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,,Static Type Checker,,,,0,,,,,,,"This code works:

bq. new ByteArrayOutputStream().withObjectOutputStream { ObjectOutputStream oos -> oos << new Object()}

but this one, doesn't:

bq. new ByteArrayOutputStream().withObjectOutputStream { it << new Object() }

Exception:

bq. {color:red}Cannot find matching method java.lang.Object#leftShift(java.lang.Object). Please check if the declared type is right and if the method exists.{color} 
",groovy-2.1.0-rc-1,cazacugmihai,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5924,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 11 06:10:29 UTC 2013,,,,,,,,,,"0|i2chdr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jan/13 06:10;melix;This is the ""famous"" improvement that we need to implement. The type checker doesn't have enough type information in the source code of withObjectOutputStream to infer that the type of ""it"" is an {{ObjectOutputStream}}. I couldn't find any issue for this, but there are several bug reports that are related to this improvement.

see ""Closure parameter type inference"" here: http://docs.codehaus.org/display/GroovyJSR/GEP+8+-+Static+type+checking;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Sql.java throws IllegalStateException(""Failed to process query. Unterminated ' character?"") when comments contain quotes",GROOVY-5898,12816725,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,msinatl,msinatl,10/Jan/13 10:49,10/Jul/13 04:42,14/Jul/23 06:01,04/Jul/13 00:24,1.8.8,2.1.0-rc-1,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,SQL processing,,,,0,sql,,,,,,"In versions of Groovy since 1.8, when Groovy SQL prepares to execute a parameterized query, it checks the query SQL for unterminated single quotes (lines 4168 - 4188 of groovy.sql.Sql.java in the current trunk source). However, the current code doesn't recognize that when the SQL contains comments, and the comments include apostrophes or single quote characters, that the SQL is valid.

For example, this code will result in an exception:
{code}
def myQuery = """"""
  select count(*), cast(? as varchar(10))
  -- An ' apostrophe
  from art.option 
""""""

sql.eachRow(myQuery.toString(), ['1.7.5']) 
{row ->
  println row
}
{code}

Perhaps you could use a regex or string replace to remove or ignore everything found between ""--"" and ""\n"" or ""/*"" and ""*/"" before testing for unterminated quotes?",,jwagenleitner,msinatl,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 04 00:24:25 UTC 2013,,,,,,,,,,"0|i2bt47:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Jun/13 13:30;jwagenleitner;I added a pull request for this issue, https://github.com/groovy/groovy-core/pull/212.;;;","30/Jun/13 09:12;jwagenleitner;Found a bug in handling of empty quotes in my original pull request, since it has been merged already I opened another PR with the fix, https://github.com/groovy/groovy-core/pull/213.  Sorry for the trouble Paul.;;;","04/Jul/13 00:24;paulk;Added John's fix to master. This should be in 2.2.0 which should have a beta released shortly. We can backport (possibly without some non-crucial refactoring and a deprecation) to the 2_1_X branch if there is sufficient demand.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Multiple problems with static method invocations and @CompileStatic,GROOVY-5897,12816687,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,10/Jan/13 08:57,25/Aug/13 16:59,14/Jul/23 06:01,19/Aug/13 06:49,2.0.5,2.0.6,,,,,,,,,,,,,,,,2.1.0,,,,Static compilation,,,,0,,,,,,,"Not sure how to reproduce this in a smaller example, but if I uncomment the @CompileStatic from this line of code:

https://github.com/grails/grails-core/blob/0e4b23d5691fa71bf47703bfcbd31e511a036848/grails-bootstrap/src/main/groovy/org/codehaus/groovy/grails/resolve/DependencyManagerConfigurer.groovy#L133

I get the exception:

{code}

(class: org/codehaus/groovy/grails/resolve/DependencyManagerConfigurer, method: createIvyDependencyManager signature: (Lgrails/util/BuildSettings;)Lorg/codehaus/groovy/grails/resolve/IvyDependencyManager;) Expecting to find object/array on stack
java.lang.VerifyError: (class: org/codehaus/groovy/grails/resolve/DependencyManagerConfigurer, method: createIvyDependencyManager signature: (Lgrails/util/BuildSettings;)Lorg/codehaus/groovy/grails/resolve/IvyDependencyManager;) Expecting to find object/array on stack
	at grails.util.BuildSettings.configureDependencyManager(BuildSettings.groovy:1224)
	at grails.util.BuildSettings.postLoadConfig(BuildSettings.groovy:1169)
	at grails.util.BuildSettings.loadConfig(BuildSettings.groovy:1065)
	at grails.util.BuildSettings.loadConfig(BuildSettings.groovy:1047)
{code}

Possible related, in the same class if I uncomment the @CompileStatic on line:

https://github.com/grails/grails-core/blob/0e4b23d5691fa71bf47703bfcbd31e511a036848/grails-bootstrap/src/main/groovy/org/codehaus/groovy/grails/resolve/DependencyManagerConfigurer.groovy#L41

I get a compilation error:

{code}

[ant:groovyc] org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
[ant:groovyc] General error during class generation: size==0
[ant:groovyc] 
[ant:groovyc] java.lang.ArrayIndexOutOfBoundsException: size==0
[ant:groovyc] 	at org.codehaus.groovy.classgen.asm.OperandStack.doConvertAndCast(OperandStac
[ant:groovyc] k.java:312)
[ant:groovyc] 	at org.codehaus.groovy.classgen.asm.OperandStack.doGroovyCast(OperandStack.java:296)
[ant:groovyc] 	at org.codehaus.groovy.classg
[ant:groovyc] en.asm.sc.StaticInvocationWriter.loadArguments(StaticInvocationWriter.java:251)
[ant:groovyc] 	at org.codehaus.groovy.classgen.asm.InvocationW
[ant:groovyc] riter.writeDirectMethodCall(InvocationWriter.java:130)
[ant:groovyc] 	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeDirec
[ant:groovyc] tMethodCall(StaticInvocationWriter.java:185)
[ant:groovyc] 	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.jav
[ant:groovyc] a:223)
{code}",,blackdrag,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 19 06:49:36 UTC 2013,,,,,,,,,,"0|i2c8qn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Jan/13 11:22;melix;Both issues are now solved using {{master}}. The second one (ArrayOutOfBoundsException) still occurs on {{2.0.X}}. I'll see if I can track down to the fix that wasn't backported and see if it's easily doable before closing this bug.;;;","19/Aug/13 06:49;blackdrag;I close the issue since I don't think fixing it for 2.0.x is still a target. I was not sure about the fix version, so I did set 2.1.0 for now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Left shift on collection fails for list with CompileStatic,GROOVY-5894,12816713,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,09/Jan/13 06:32,16/Feb/13 00:47,14/Jul/23 06:01,11/Feb/13 03:11,2.0.6,,,,,,,,,,,,,,,,,2.1.1,,,,Static compilation,,,,0,,,,,,,"Don't think I've reported this before...

This code works fine:
{code}
@groovy.transform.CompileStatic
def List<Integer> append( Closure<Integer> method ) {
  List<Integer> ret = []
  ret << method()
}

Closure<Integer> cl = { 2 }

// prints '[2]'
println append( cl )
{code}

However, if you use a generic placeholder like so:

{code}
@groovy.transform.CompileStatic
def <T> List<T> append( Closure<T> method ) {
  List<T> ret = []
  ret << method()
}

Closure<Integer> cl = { 2 }

println append( cl )
{code}

You get:

{code}
[Static type checking] - Cannot call 
  org.codehaus.groovy.runtime.DefaultGroovyMethods#leftShift(java.util.Collection <T>, java.lang.Object)
  with arguments [java.util.List <T>, java.lang.Object] 
{code}

Shouldn't that be ok?",,aalmiray,melix,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 11 03:11:22 UTC 2013,,,,,,,,,,"0|i2brk7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jan/13 06:45;tim_yates;Getting this as well (which I believe is the same bug)

{code}
@groovy.transform.CompileStatic
class Failing {
  // Call with a String delegates to Reader method
  static <T> void doIt( String s, Closure<T> cl ) {
    doIt( new StringReader( s ), cl )
  }
  
  static <T> void doIt( Reader r, Closure<T> cl ) {
    println r.collect( cl )
  }
}

Closure<String> cl = { c -> c }
// Call it with a String
Failing.doIt( 'tim', cl )
{code}

Throws:

{code}

[Static type checking] - Cannot find matching method Failing#doIt(java.io.StringReader, groovy.lang.Closure <T>). Please check if the declared type is right and if the method exists.
 at line: 5, column: 5

[Static type checking] - Cannot find matching method java.io.Reader#collect(groovy.lang.Closure <T>). Please check if the declared type is right and if the method exists.
 at line: 9, column: 13
{code};;;","09/Jan/13 08:37;melix;Tim, can you check using {{master}}? I think it's fixed here, and backporting to 2.0.x may be complex, just let me know if you can confirm.;;;","09/Jan/13 08:51;tim_yates;Master pulled, building and testing to follow :-)

gvmtool makes it a bit harder to do this than before it seems...

I'll return with results when I find out if it works :-)  Thanks Cedric :-);;;","09/Jan/13 09:10;tim_yates;Yeah, both of these work with {{Groovy Version: 2.1.0-SNAPSHOT JVM: 1.7.0_07 Vendor: Oracle Corporation OS: Mac OS X}};;;","09/Jan/13 09:13;melix;Thanks. I'm unsure I'll be able to backport onto 2.0.x. Giving priority to other bugs.;;;","09/Jan/13 09:15;tim_yates;No worries, I can roll back to 2.0.5 until 2.1.0 comes out :-);;;","11/Feb/13 03:06;aalmiray;Works OK in 2.1.0. Should we close this issue if no further changes to 2.0.x will be posted?;;;","11/Feb/13 03:11;aalmiray;Marking the issue as resolved as it works with 2.1.0 and the fix won't be back ported to 2.0.x;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic VerifyError,GROOVY-5892,12816636,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,07/Jan/13 22:42,12/Jan/13 20:40,14/Jul/23 06:01,08/Jan/13 10:34,2.0.6,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,,Static compilation,,,,0,,,,,,,"{code}
class FailsVerification {
    static class Nested {
        @groovy.transform.CompileStatic
        static method() {
            def closure = {-> println 'foo' }
            closure()
        }
    }

    public static void main(String[] args) {
        Nested.method()
    }
}
{code}

If we call the closure through {{call()}} it works:
{code}
class Works{
    static class Nested {
        @groovy.transform.CompileStatic
        static method() {
            def closure = {-> println 'foo' }
            closure.call()
        }
    }

    public static void main(String[] args) {
        Nested.method()
    }
}
{code}",,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-07 22:42:59.0,,,,,,,,,,"0|i2c8w7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compiler wrongly infers the return type of Class<T>.cast(),GROOVY-5891,12816668,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ddimitrov,ddimitrov,07/Jan/13 20:23,14/Oct/13 16:54,14/Jul/23 06:01,19/Jul/13 06:43,2.0.6,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Static compilation,,,,0,,,,,,,"{code}
@CompileStatic
class Test {
    public <T extends Runnable> T fails(Class<T> type, def x) {
        return type.cast(x) 
    }
    public <T extends Runnable> T passes(Class<T> type, def x) {
        return type.cast(x) as T
    }
}
{code}",,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-07 20:23:22.0,,,,,,,,,,"0|i2cjzb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic resolves the 'in' operator wrongly,GROOVY-5890,12816643,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,07/Jan/13 20:12,12/Jan/13 20:40,14/Jul/23 06:01,09/Jan/13 08:23,2.0.6,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,,Static compilation,,,,0,,,,,,,"{code}
class Test {
    @CompileStatic
    static void main(String... a) {
        println('a' in String)
    }
}
{code}

From what I can understand, based on the lhs type, the compiler assumes that 'in' refers to String.contains(), while it actually refers to instanceof",,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-07 20:12:03.0,,,,,,,,,,"0|i2cn13:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler hangs on this code,GROOVY-5889,12816714,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,07/Jan/13 10:13,12/Jan/13 20:40,14/Jul/23 06:01,09/Jan/13 12:01,2.0.6,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,,Static compilation,,,,0,,,,,,,"{code}
import groovy.transform.Canonical
import groovy.transform.CompileStatic

class Test {
    @CompileStatic
    @Canonical
    static class FMessage {
        static enum LogLevel { finest, finer, fine, config, info, warning, severe }
        LogLevel logLevel
    }
}
{code}",,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-07 10:13:30.0,,,,,,,,,,"0|i2c04v:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler wrongly tries only static resolution when calling spread operator on a collection of strings,GROOVY-5888,12816670,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,07/Jan/13 09:59,12/Jan/13 20:40,14/Jul/23 06:01,10/Jan/13 01:46,2.0.6,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,,Static compilation,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
class Test {
    def passing = 'a,b,c'.split(/,/).toList()*.trim()
    static failing = 'a,b,c'.split(/,/).toList()*.trim()
}
{code}",,ddimitrov,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 09 09:12:11 UTC 2013,,,,,,,,,,"0|i2csgf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"09/Jan/13 09:12;melix;Sorry, reopening, wrong issue :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"The spread-call syntax is statically compiled for collections, but not for arrays",GROOVY-5887,12816693,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,07/Jan/13 09:51,12/Jan/13 20:40,14/Jul/23 06:01,09/Jan/13 09:12,2.0.6,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,,Static compilation,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
class Test {
    def passing = 'a,b,c'.split(/,/).toList()*.trim()
    def failing = 'a,b,c'.split(/,/)*.trim()
}
{code}",,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-07 09:51:30.0,,,,,,,,,,"0|i2cpr3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic incorrectly infers generic return type,GROOVY-5885,12816494,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ddimitrov,ddimitrov,07/Jan/13 01:00,14/Oct/13 16:53,14/Jul/23 06:01,22/Jul/13 05:58,2.0.6,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Static Type Checker,,,,0,,,,,,,"{code}
class Test {
    @groovy.transform.CompileStatic
    public <X extends Test> X castToMe(Class<X> type, Object o) {
        return type.cast(o);
    }
}
{code}

This compiles in Java, but not in Groovy",,blackdrag,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 22 05:58:52 UTC 2013,,,,,,,,,,"0|i2cc0v:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Jul/13 05:58;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic(SKIP) does not work for constructors,GROOVY-5884,12816667,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,07/Jan/13 00:38,12/Jan/13 20:40,14/Jul/23 06:01,09/Jan/13 10:46,2.0.6,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,,Static Type Checker,,,,0,,,,,,,"This fails:
{code}
@CompileStatic
class Test {
    @CompileStatic(TypeCheckingMode.SKIP)
    private Test() {
        foobar()
    }
}
{code}

This passes:

{code}
@CompileStatic
class Test<T> {
    private Test() {
        baz()
    }

    @CompileStatic(TypeCheckingMode.SKIP)
    private baz() { 
        foobar() 
    }
}
{code}",,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-07 00:38:12.0,,,,,,,,,,"0|i2bs7j:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic incorrectly inferred closure return type upper bound,GROOVY-5883,12816492,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ddimitrov,ddimitrov,07/Jan/13 00:23,14/Oct/13 16:53,14/Jul/23 06:01,22/Jul/13 05:02,2.0.6,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Static Type Checker,,,,0,,,,,,,"{code}
@CompileStatic
class Test<T> {
    def map(Closure<T> mapper) { }

    def failing(Closure<Boolean> predicate) {
        map { T it -> return predicate(it) ? it : null }
    }
    
    def passing(Closure<Boolean> predicate) {
        map { T it -> return predicate(it) ? it : (T) null }
    }

    def failingWithExplicitCast(Closure<Boolean> predicate) {
        Closure<T> c = { T it -> return predicate(it) ? it : null }
        map(c)
    }
}
{code}

In the last case, I would expect the compiler to obey the forced cast even at the risk of producing class-cast exception at runtime.",,blackdrag,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 22 05:02:14 UTC 2013,,,,,,,,,,"0|i2bz7j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Jul/13 05:02;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic breaks with generic boxed numerics,GROOVY-5882,12816686,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ddimitrov,ddimitrov,07/Jan/13 00:06,14/Oct/13 16:53,14/Jul/23 06:01,17/Jul/13 04:18,2.0.6,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Static compilation,,,,0,,,,,,,"{code}
class Test {
    @CompileStatic
    void fails1(Map<Integer, Closure<String>> markers, int i) {
        for (e in markers.entrySet()) {
            print i % e.key
        }
    }

    @CompileStatic
    void fails2(Map<Integer, Closure<String>> markers, int i) {
        for (e in markers.entrySet()) {
            int intKey = e.key
            print i % intKey
        }
    }

    @CompileStatic
    void passes(Map<Integer, Closure<String>> markers, int i) {
        for (e in markers.entrySet()) {
            print i % e.key.intValue()
        }
    }
}
{code}",,blackdrag,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 17 04:18:26 UTC 2013,,,,,,,,,,"0|i2by5j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"17/Jul/13 04:18;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic does not infer the type of caught exception,GROOVY-5880,12816566,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,06/Jan/13 23:45,16/Feb/13 00:47,14/Jul/23 06:01,11/Feb/13 09:06,2.0.6,,,,,,,,,,,,,,,,,2.1.0,,,,Static Type Checker,,,,0,,,,,,,"This fails with {{Groovyc: Access to java.lang.Object#message is forbidden}}

{code}
class Test {
    @groovy.transform.CompileStatic
    public static void main(String[] args) {
        try {
            println ""foobar""
        } catch (e) {
            println e.message
        }

    }
}
{code}

This passes:
{code}
class Test {
    @groovy.transform.CompileStatic
    public static void main(String[] args) {
        try {
            println ""foobar""
        } catch (Throwable e) {
            println e.message
        }

    }
}
{code}",,ddimitrov,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 09 09:28:51 UTC 2013,,,,,,,,,,"0|i2c6h3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"09/Jan/13 09:28;melix;This is fixed on {{master}} (2.1.x). Backporting may be considered if a 2.0.7 goes out so I keep this one open until a decision is made.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
combining the default namespace and normal namespaces with StreamingMarkupBuilder causes issues,GROOVY-5879,12816680,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,06/Jan/13 20:04,07/Apr/15 19:06,14/Jul/23 06:01,06/Jan/13 20:56,2.0.6,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,,XML Processing,,,,0,,,,,,,"See for example here:
http://stackoverflow.com/questions/9582566/groovy-xml-and-the-xml-namespace
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,2013-01-06 20:04:39.0,,,,,,,,,,"0|i2cbaf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
startGroovy breaks one-liners containing double quotes,GROOVY-5878,12816644,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,boercher,boercher,06/Jan/13 16:42,05/Apr/15 14:44,14/Jul/23 06:01,16/Jan/13 00:54,,,,,,,,,,,,,,,,,,2.0.7,2.1.0,2.1.0-rc-2,,command line processing,,,,0,,,,,,,"The issue was raised in this groovy-user discussion:

  http://groovy.329449.n5.nabble.com/How-to-properly-escape-groovy-one-liners-for-bash-tp5712274.html

The following statement is supposed to throw a MultipleCompilationErrorsException but instead if gives ""bad substitution"" message from the shell:

  groovy -e 'println ""${a.author}""' 

The problem is that on Cygwin the startGroovy script does additional processing that breaks some code that is given as an argument to the '-e' option.

The attached patch fixes this problem if the Bash is used, which in all reasonable conditions seems to be the case.","Windows/Cygwin; probably all versions affected",boercher,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/Jan/13 16:42;boercher;startGroovy.patch;https://issues.apache.org/jira/secure/attachment/12722184/startGroovy.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,,9223372036854775807,,,Wed Jan 16 00:54:26 UTC 2013,,,,,,,,,,"0|i2brbb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jan/13 16:48;boercher;I think that my patch would also fix https://jira.codehaus.org/browse/GROOVY-3419;;;","07/Jan/13 13:08;pschumacher;Hello Volker, your patch works for me:
{code}
$ /cygdrive/d/development/groovy-2.0.6/bin/groovy -e 'println ""${a.author}""'
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
script_from_command_line: 1: unexpected char: 0xFFFF @ line 1, column 21.
   println ""${a.author}
                       ^
1 error
{code}
;;;","16/Jan/13 00:54;paulk;patch applied - thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem With Arguments Passed To Static Dynamic Methods,GROOVY-5876,12816594,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,brownj,brownj,03/Jan/13 10:54,15/Nov/15 11:35,14/Jul/23 06:01,15/Nov/15 11:35,1.8.8,,,,,,,,,,,,,,,,,2.4.0,,,,groovy-runtime,,,,0,,,,,,,"If I do something like this...

{noformat}
String.metaClass.doSomething = { Object[] args ->
    println args.length
}

'Scott Gorham'.doSomething(1, 2, 3)
{noformat}

args.length is 3, which is what I would expect. 

If I do something like this...

{noformat}

String.metaClass.static.doSomething = { Object[] args ->
    println args.length
    println args[0].length
}

String.doSomething(1, 2, 3)
{noformat}

Then args.length is 1 and args[0].length is 3.  The array that contains the actual arguments (1, 2, 3) is being wrapped inside of another array.

The instance method is behaving the way I would expect.  The static method is not.  It seems like these should behave the same with respect to this.",,brownj,lhotari,pascalschumacher,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 15 11:35:38 UTC 2015,,,,,,,,,,"0|i2bwi7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Feb/13 11:01;pschumacher;Is this something for 3.0?;;;","23/Jan/15 10:28;brownj;In 2.3.9 args.length inside the static method is 1.  In 2.4.0 args.length inside of the static method is 3.  I think 3 is the correct behavior.  Is this issue eligible to be marked as fixed?;;;","15/Nov/15 11:35;pascalschumacher;Closing this issue based on Jeffs comment. Thanks Jeff.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovyc: BUG! exception in phase 'class generation' in source unit ,GROOVY-5874,12818203,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,oliver_plow,oliver_plow,03/Jan/13 05:35,12/Jan/13 20:40,14/Jul/23 06:01,08/Jan/13 09:04,2.0.6,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,,Static compilation,,,,0,iterators,list,,,,,"This code:
{code}
@CompileStatic
    static main(args)
    {
        def list = [1, 2, 3]

        def sum = 0
        list.each { int i -> sum += i }
        println(sum)

        sum = list.inject(0, { int x, int y -> x + y })
        println(sum)
    }
{code}
creates this error message:

Groovyc: BUG! exception in phase 'class generation' in source unit 'C:\Users\Oliver\IdeaProjects\GroovyForEachSum\src\org\objectscape\LambdaTestStatic.groovy' At line 20 column 30
On receiver: sum with message: plus and arguments: i
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesCallSiteWriter.makeSingleArgumentCall(StaticTypesCallSiteWriter.java:535)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeSingleArgumentCall(InvocationWriter.java:482)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateBinaryExpression(BinaryExpressionHelper.java:504)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionMultiTypeDispatcher.evaluateBinaryExpression(BinaryExpressionMultiTypeDispatcher.java:216)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionMultiTypeDispatcher.doAssignmentToLocalVariable(BinaryExpressionMultiTypeDispatcher.java:362)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionMultiTypeDispatcher.evaluateBinaryExpressionWithAssignment(BinaryExpressionMultiTypeDispatcher.java:346)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:146)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:527)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:582)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:505)
	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:455)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:319)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:276)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:396)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1059)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:786)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:803)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1027)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:564)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:542)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:519)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:44)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:129)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:112)

Also happens without @CompileStatic:

def list = [1, 2, 3]

def sum = 0
list.each { sum += it }
println(sum)

sum = list.inject(0, { x, y -> x + y })
println(sum)",IDEA 12.0 with groovy 2.0.6,melix,oliver_plow,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5893,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 08 09:04:07 UTC 2013,,,,,,,,,,"0|i2c52n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Jan/13 08:48;melix;The problem goes away if you comment out the ""sum = list.inject"" part. The reason is that the compiler infers a return type of {{Object}} in that case, so {{sum}} becomes a potential {{Object}}. As it's a closure shared variable, it should have, then, refused to let you do a ""plus"" on an {{Object}}. So there are probably two problems in one here:
# closure shared variables tests are not done if using binary expressions instead of method calls (a+b instead of a.plus(b))
# inject call should (?) infer a return type of Integer
;;;","08/Jan/13 09:04;melix;The issue which is fixed here is the fact that a closure shared variable is not rechecked if it is used in a binary expression.

The fact that {{inject}} infers an {{Object}} instead of an integer here is covered by the linked issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker does not infer generic type,GROOVY-5873,12816608,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,djh,djh,02/Jan/13 08:20,14/Oct/13 16:53,14/Jul/23 06:01,19/Jul/13 13:52,2.0.6,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,Static Type Checker,,,,1,,,,,,,"The type checker is unable to infer the type of variable _value_ in the below code:

{code}
abstract class Parent<T> {
	public T value
}

class Impl extends Parent<Integer> {

}

@CompileStatic
class Test {
	public void test() {
		Impl impl = new Impl()
		Integer i = impl.value // fails
	}
}
{code}

The compiler gives this error:

[Static type checking] - Cannot assign value of type java.lang.Object to variable of type java.lang.Integer

",,blackdrag,djh,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 19 13:52:57 UTC 2013,,,,,,,,,,"0|i2c2un:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"19/Jul/13 13:52;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
null initial value can't be inferred with generic field of a class,GROOVY-5872,12816694,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,uehaj,uehaj,02/Jan/13 02:12,19/Jan/16 18:10,14/Jul/23 06:01,07/Jan/13 06:22,2.1.0-beta-1,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,,Static Type Checker,,,,0,,,,,,,"In following code, I expect no STC error at (A).
{code}
import groovy.transform.*
@TypeChecked // or @CompileStatic
class ccc {
  List<String> list = null // (A)
  List list2 = null // OK
  String str = null // OK
  public static void main(String [] args) {
    List<String> list = null // OK
  }
}
{code}
but compiler says:

{quote}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/Users/uehaj/work/201301/gastha_magazine/ccc.groovy: 4: [Static type checking] - Incompatible generic argument types. Cannot assign java.lang.Object to: java.util.List <String>
 @ line 4, column 23.
     List<String> list = null
                         ^

1 error
{quote}

Of course I can avoid this error by modify the code to:
{code}
     List<String> list = (List<String>)null
{code}",,pascalschumacher,uehaj,vanta,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 19 18:10:18 UTC 2016,,,,,,,,,,"0|i2bybj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jan/16 21:59;vanta;The same problem is with {{null}} passed as arguments to method that takes e.g. Integer - it will fail. And its still in latest Groove version {{2.4.5}};;;","19/Jan/16 18:10;pascalschumacher;Hi Krzysztof,

thanks for reporting. It would be nice if you could open a new issue and supply a short self-contained example/testcase.

Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Grapes/@Grab not working with GroovyConsole,GROOVY-5871,12812040,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,mfortner,mfortner,01/Jan/13 13:37,19/Sep/17 18:42,14/Jul/23 06:01,05/Feb/13 13:21,1.8.6,2.0.5,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,Grape,Groovy Console,,,0,,,,,,,"On the surface this seems like a duplicate of http://jira.codehaus.org/browse/GROOVY-3851  but it's not.  If the original issue was fixed, it's broken now in 1.8.6 and 2.0.5

Here's my simple example:
{code}
@Grab(group='org.apache.commons', module='commons-vfs2',version='2.0')
import org.apache.commons.vfs2.VFS
println VFS.getManager().resolveFile(System.getProperty(""user.home""));
{code}
This example throws a ClassNotFoundException when run through the GroovyConsole, but runs just fine when you run it from the command line.

The console should read the grapesConfig.xml file on startup and use the settings there to resolve any grape references in the script.  That doesn't seem to be happening.",,burtsevyg,hubbitus,mfortner,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4877,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 19 18:42:39 UTC 2017,,,,,,,,,,"0|i2bvsv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jan/13 16:08;paulk;If I set
{code}
@GrabConfig(systemClassLoader=true)
{code}
or
{code}
@GrabConfig(initContextClassLoader=true)
{code}
your script seems to get further.

Not sure if you are seeing https://issues.apache.org/jira/browse/VFS-228 though I would expect the behavior to be the same from the console or a script.;;;","03/Jan/13 16:23;mfortner;I tried the systemClassLoader and that seems to fix the problem.  But it doesn't really explain why the script works from the command line and fails from within GroovyConsole.  There doesn't seem to be much documentation on the GroovyConfig annotation, and it would be good to know when to use it.  Does this have to do with the way that ServiceLoader works? The example points to loading JDBC drivers and I believe these are loaded using ServiceLoader.;;;","27/Jan/13 13:59;pschumacher;Lukes fix for [GROOVY-4877] would also fix this issue.;;;","05/Feb/13 13:21;pschumacher;Should work without using @GrabConfig now that [GROOVY-4877] is fixed.;;;","19/Sep/17 18:09;burtsevyg;The same issue in  groovy 2.4.8
If I set 

{code:java}
@GrabConfig(systemClassLoader=true)
{code}

issue have gone.
After one run with 

{code:java}
@GrabConfig(systemClassLoader=true)
{code}

I can remove and run without error.;;;","19/Sep/17 18:42;burtsevyg;Cannot reproduce error after remove gapes and install 2.4.12 version;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy:[Static type checking] - Inconvertible types: cannot cast javax.script.ScriptEngine to   javax.script.Invocable,GROOVY-5870,12816639,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,betak102,betak102,01/Jan/13 08:55,12/Jan/13 20:40,14/Jul/23 06:01,09/Jan/13 11:39,2.0.6,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,,Static Type Checker,,,,0,,,,,,,"Groovy:[Static type checking] - Inconvertible types: cannot cast javax.script.ScriptEngine to   javax.script.Invocable

> Invocable inv = (Invocable) engine;",jdk7,betak102,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 02 00:47:04 UTC 2013,,,,,,,,,,"0|i2br3r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jan/13 00:47;guillaume;Strictly speaking, the {{javax.script.ScriptEngine}} interface isn't extending {{javax.script.Invocable}}.
But the {{GroovyScriptEngineImpl}} implementation does implement both interfaces.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
