Summary,Issue key,Issue id,Issue Type,Status,Project key,Project name,Project type,Project lead,Project description,Project url,Priority,Resolution,Assignee,Reporter,Creator,Created,Updated,Last Viewed,Resolved,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Component/s,Component/s,Component/s,Due Date,Votes,Labels,Labels,Labels,Labels,Labels,Description,Environment,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Original Estimate,Remaining Estimate,Time Spent,Work Ratio,Σ Original Estimate,Σ Remaining Estimate,Σ Time Spent,Security Level,Inward issue link (Cloners),Inward issue link (Container),Inward issue link (Duplicate),Inward issue link (Duplicate),Outward issue link (Duplicate),Inward issue link (Incorporates),Inward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Inward issue link (Related),Inward issue link (Related),Outward issue link (Related),Outward issue link (Related),Inward issue link (Supercedes),Inward issue link (dependent),Outward issue link (dependent),Outward issue link (dependent),Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Attachment,Custom field (Affects version (Component)),Custom field (Attachment count),Custom field (Blog - New Blog Administrators),Custom field (Blog - New Blog PMC),Custom field (Blog - Write access),Custom field (Blog Administrator?),Custom field (Blogs - Admin for blog),Custom field (Blogs - Email Address),Custom field (Blogs - Existing Blog Access Level),Custom field (Blogs - Existing Blog Name),Custom field (Blogs - New Blog Write Access),Custom field (Blogs - Username),Custom field (Bug Category),Custom field (Bugzilla - Email Notification Address),Custom field (Bugzilla - List of usernames),Custom field (Bugzilla - PMC Name),Custom field (Bugzilla - Project Name),Custom field (Bugzilla Id),Custom field (Bugzilla Id),Custom field (Change Category),Custom field (Complexity),Custom field (Discovered By),Custom field (Docs Text),Custom field (Enable Automatic Patch Review),Custom field (Epic Link),Custom field (Estimated Complexity),Custom field (Evidence Of Open Source Adoption),Custom field (Evidence Of Registration),Custom field (Evidence Of Use On World Wide Web),Custom field (Existing GitBox Approval),Custom field (External issue URL),Custom field (Fix version (Component)),Custom field (Flags),Custom field (Git Notification Mailing List),Custom field (Git Repository Import Path),Custom field (Git Repository Name),Custom field (Git Repository Type),Custom field (GitHub Options),Custom field (Github Integration),Custom field (Github Integrations - Other),Custom field (Global Rank),Custom field (INFRA - Subversion Repository Path),Custom field (Initial Confluence Contributors),Custom field (Last public comment date),Custom field (Level of effort),Custom field (Machine Readable Info),Custom field (Mentor),Custom field (New-TLP-TLPName),Custom field (Original story points),Custom field (Parent Link),Custom field (Priority),Custom field (Project),Custom field (Protected Branch),Custom field (Rank),Custom field (Rank (Obsolete)),Custom field (Review Date),Custom field (Reviewer),Custom field (Severity),Custom field (Severity),Custom field (Skill Level),Custom field (Source Control Link),Custom field (Space Description),Custom field (Space Key),Custom field (Space Name),Custom field (Start Date),Custom field (Tags),Custom field (Target end),Custom field (Target start),Custom field (Team),Custom field (Test and Documentation Plan),Custom field (Testcase included),Custom field (Tester),Custom field (Workaround),Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment
ConfigObject is unexpectedly no longer Cloneable,GROOVY-5868,12816657,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,dhdaines,dhdaines,28/Dec/12 20:50,15/Oct/15 18:19,14/Jul/23 06:00,04/Apr/13 02:37,1.8.9,2.0.6,2.1.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,,,,,0,,,,,,"The reimplementation of ConfigObject is no longer Cloneable. So if your code relied on being able to clone a ConfigObject, it now throws an exception.

Sample program which used to work and doesn't anymore:
{code}
ConfigSlurper slurper = new ConfigSlurper();
ConfigObject conf = slurper.parse(""""""
foo {
   bar = ""baz""
}
"""""");
println conf.foo.bar
ConfigObject conf2 = conf.clone()
conf2.foo.bar = ""quux""
println conf2.foo.bar
{code}
",,blackdrag,dhdaines,johnrengelman,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 03 16:11:29 UTC 2013,,,,,,,,,,"0|i2clmn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Dec/12 05:57;pschumacher;created a pull request for this: [https://github.com/groovy/groovy-core/pull/94];;;","31/Dec/12 00:44;paulk;add code tags;;;","02/Jan/13 09:54;blackdrag;pull request applied;;;","19/Feb/13 07:58;johnrengelman;This bug appears to have worked it's way back into Groovy 1.8.9. 
I get this stack trace when trying to clone a ConfigObject from the console
{code}
java.lang.CloneNotSupportedException: groovy.util.ConfigObject
	at java.lang.Object.clone(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:272)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:64)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at ConsoleScript0.run(ConsoleScript0:1)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:266)
	at groovy.lang.GroovyShell.run(GroovyShell.java:517)
	at groovy.lang.GroovyShell.run(GroovyShell.java:172)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:927)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:903)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:46)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:903)
	at groovy.lang.Closure.call(Closure.java:415)
	at groovy.lang.Closure.call(Closure.java:409)
	at groovy.lang.Closure.run(Closure.java:493)
	at java.lang.Thread.run(Thread.java:680)
{code};;;","16/Mar/13 11:35;pschumacher;John Engelman:

You are right this also affects 1.8.9. Somebody with more git skills could merge my pull request into the 1_8_X branch. But I don't know if there will be any more releases for the 1_8_X branch?;;;","03/Apr/13 16:11;pschumacher;Hello John,

I merged the fix for this issue into the 1.8 branch.

Kind regards,
Pascal;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
xml:lang attribute appears to break StreamingMarkupBuilder >= 2.0.6,GROOVY-5867,12816691,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,dhdaines,dhdaines,28/Dec/12 17:10,12/Jan/13 20:40,14/Jul/23 06:00,04/Jan/13 04:28,2.0.6,2.1.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,XML Processing,,,,0,,,,,,"When using XmlSlurper to parse XML containing an xml:lang attribute and trying to write out this XML using StreamingMarkupBuilder, I get this error in 2.0.6 and 2.1.0-beta-1, which I didn't get in 2.0.5:
{noformat}
[Fatal Error] :1:19: Attribute name ""xml:"" associated with an element type ""tag0:grammar"" must be followed by the ' = ' character.
ERROR:  'Attribute name ""xml:"" associated with an element type ""tag0:grammar"" must be followed by the ' = ' character.'
Caught: groovy.lang.GroovyRuntimeException: org.xml.sax.SAXParseException; lineNumber: 1; columnNumber: 19; Attribute name ""xml:"" associated with an element type ""tag0:grammar"" must be followed by the ' = ' character.
groovy.lang.GroovyRuntimeException: org.xml.sax.SAXParseException; lineNumber: 1; columnNumber: 19; Attribute name ""xml:"" associated with an element type ""tag0:grammar"" must be followed by the ' = ' character.
	at broken-groovy-test$_run_closure2.doCall(broken-groovy-test.groovy:8)
	at broken-groovy-test.run(broken-groovy-test.groovy:8)
{noformat}

The groovy code in question is:

{code}
import groovy.xml.StreamingMarkupBuilder;
import groovy.xml.XmlUtil;

def grammar = new XmlSlurper().parse(new File(args[0]))
def builder = new StreamingMarkupBuilder()
def copier = builder.bind { mkp.yield(grammar) };
processedFile = new File(""test-out.xml"")
processedFile.withWriter{ it << XmlUtil.serialize(copier) } 
{code}

And the XML that makes it fail is:

{code:xml}
<?xml version=""1.0"" encoding=""UTF-8""?>
<grammar xml:lang=""en-us"" xmlns=""http://www.w3.org/2001/06/grammar"">
</grammar>
{code}
","java version ""1.7.0_09""
Java(TM) SE Runtime Environment (build 1.7.0_09-b05)
Java HotSpot(TM) 64-Bit Server VM (build 23.5-b02, mixed mode)
",dhdaines,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 04 04:28:01 UTC 2013,,,,,,,,,,"0|i2caa7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Dec/12 17:25;dhdaines;This is the same as the problem mentioned here:

http://stackoverflow.com/questions/9582566/groovy-xml-and-the-xml-namespace

The mkp.declarenamespace("""", namespace) fix used to work up to Groovy 2.0.5, but it stopped working in 2.0.6.

So, now I just have to work around it the other way mentioned there, by ignoring namespaces.
;;;","30/Dec/12 02:02;paulk;Looks like an unintended consequence of GROOVY-4637.

A slight variant of the problem shown above that illustrates the problem:
{code}
def xml = '''\
<?xml version=""1.0"" encoding=""UTF-8""?>
<grammar xml:lang=""en-us"" xmlns=""http://www.w3.org/2001/06/grammar"">
</grammar>
'''
def grammar = new XmlSlurper().parseText(xml)
def smb = new groovy.xml.StreamingMarkupBuilder()
println smb.bindNode(grammar)
{code}
Obviously what should be {{xml:lang='en-us'}} is being output erroneously as:
{noformat}
xml:{http://www.w3.org/XML/1998/namespace}lang='en-us'
{noformat}
;;;","04/Jan/13 04:05;paulk;Add code tags;;;","04/Jan/13 04:28;paulk;Fixed the recent breakage but just noticed that some of my test examples were still breaking and it appears we have another bug to also fix which has been around a bit longer and it doesn't appear to have an open issue AFAIK:

http://stackoverflow.com/questions/9582566/groovy-xml-and-the-xml-namespace
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
getAt(EmptyRange) not called when passing an EmptyRange to getAt(Collection),GROOVY-5865,12816685,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,epidemian,epidemian,24/Dec/12 04:36,18/Jan/13 16:06,14/Jul/23 06:00,15/Jan/13 19:49,2.0.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.0,2.1.0-rc-2,,,,,,0,,,,,,"Basically, this is an inconsistency of List#getAt(Collection). When its parameters are integer indexes and non-empty ranges, it works as expected. But when an EmptyRange is passed to it, it doesn't behave like List#getAt(EmptyRange):

{code:groovy}
def list = [1, 2, 3]
assert list[3..<3] == []        // This works
assert list[0, 2..<3] == [1, 3] // This works too
assert list[0, 3..<3] == [1]    // But this throws IndexOutOfBoundsException: toIndex = 4
{code}",,epidemian,michal.mally,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Dec/12 04:36;epidemian;emptyRangeOnGetAt.groovy;https://issues.apache.org/jira/secure/attachment/12723042/emptyRangeOnGetAt.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 15 19:49:00 UTC 2013,,,,,,,,,,"0|i2cd3z:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"15/Jan/13 16:24;michal.mally;I've pushed pull request that fixes the issue: https://github.com/groovy/groovy-core/pull/107

The root cause is the existence of getAt(List, Range) and getAt(List, EmptyRange) methods. The second one has been implemented because empty ranges require some special handling. However there is no guarantee that for EmptyRange the getAt(List, EmptyRange) is always called instead of more general getAt(List, Range).

And this is exactly what happens in case of getAt(List, Collection) method.
{code}
    public static <T> List<T> getAt(List<T> self, Collection indices) {
        List<T> answer = new ArrayList<T>(indices.size());
        for (Object value : indices) {
            if (value instanceof Range) {
                answer.addAll(getAt(self, (Range) value));
            } else if (value instanceof List) {
                answer.addAll(getAt(self, (List) value));
            } else {
                int idx = DefaultTypeTransformation.intUnbox(value);
                answer.add(getAt(self, idx));
            }
        }
        return answer;
    }
{code}

Each element of collection is tested for being a Range and if it is then the element is explicitly casted to Range and getAt(List, Range) method is called. Because EmptyRange is also a Range more general method is called which causes EmptyRange special handling (provided by getAt(List, EmptyRange)) not being executed.

Explicit casting of EmptyRange to Range is nothing improper what brings us to conclusion that the getAt(List, Range) method shall handle all the ranges - also EmptyRanges since they inherits from Range.

So the fix I pushed adds a check to getAt(List, Range) method if passed range is an instance of EmptyRange. If it is the execution is delegated to specialized method getAt(List, EmptyRange). The test case is also added to ensure proper behavior.  ;;;","15/Jan/13 18:10;epidemian;Awesome, Micha :D 

I remember i traced this bug to that particular function too (getAt(List, Collection)), but i didn't submit any patch because all the other definitions for ""getAt"" in DefaultGroovyMethods.java scared me. There are different getAt definitions for object arrays, primitive arrays, strings, etc, and i didn't know how/if they interact with each other, and adding a fix for each of those getAt version seemed like a much complicated task. 

Do you know if your pull request works for other ""getAt-able"" things? String seems to explode on Groovy 2.0.6 ({{""hello""\[0, 5..<5\]}} throws a StringIndexOutOfBoundsException), while primitive arrays seem to work ({{(\[1, 2, 3\] as int\[\])\[1, 3..<3\] == \[2\]}}). 

In case it doesn't, i think it's still a good pull request, as it fixes this particular bug, and gives a hint on how to fix the getAt implementations for other objects in case those are broken too :);;;","15/Jan/13 19:49;paulk;Thanks! Applied and tweaked - altered the calling code in getAt(Collection) rather than the called code in getAt(Range);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@AutoExternalize doesn't create no-argument constructor,GROOVY-5864,12812046,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,johann,johann,22/Dec/12 07:42,05/Apr/14 00:00,14/Jul/23 06:00,15/Jan/14 03:36,2.0.5,2.0.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,xforms,,,,0,,,,,,"@AutoExternalize doesn't create a no-argument constructor, which is required to use Externalizable.

{noformat}
>javap -classpath .;c:\Users\Johann\.m2\repository\org\codehaus\groovy\groovy\2.0.5\groovy-2.0.5.jar xyz.Stream | grep Stream
Compiled from ""Stream.groovy""
public final class xyz.Stream implements java.io.Externalizable,groovy.lang.GroovyObject {
  public xyz.Stream(java.util.HashMap);
  public xyz.Stream(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Int
eger, java.lang.Integer, java.lang.Long);
>
{noformat}

Consequently, attempts at deserializing fail:

{noformat}
classOrInstanceShouldBeSerializable[2](xyz.SerializationTest)  Time elapsed: 0.016 sec  <<< ERROR!
org.apache.commons.lang.SerializationException: java.io.InvalidClassException: xyz.Stream; no valid consuctor
        at org.apache.commons.lang.SerializationUtils.deserialize(SerializationUtils.java:168)
...
Caused by: java.io.InvalidClassException: xyz.Stream; no valid constructor
        at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.java:147)
        at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:755)
...
{noformat}",,aalmiray,blackdrag,johann,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 15 03:36:03 UTC 2014,,,,,,,,,,"0|i2crav:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Dec/12 01:37;paulk;Do you have the source to your {{Stream}} class available? It looks like you are providing some constructors yourself (directly and/or with other AST transforms). I agree that the current behavior is less than ideal but want to make sure I understand your example correctly as I look at possible improvements (i.e. do we always provide the no-args constructor or alternatively give an error if it doesn't exist). Thanks.;;;","23/Dec/12 05:23;johann;Here's the source:

{code}
package xyz

import groovy.transform.AutoExternalize
import groovy.transform.Immutable

@Immutable
@AutoExternalize
class Stream {
    
    private static final long serialVersionUID = -612566306978315215L
    
    String fnuh, guh, keks, blorg
    
    Integer pruh, ctuh
    
    Long mhhbop

}
{code}

For {{Externalizable}} you always need to have a no-argument constructor so the AST transform should add that in any cases.;;;","23/Dec/12 19:05;paulk;I am wondering though whether it makes sense to use @Immutable with @AutoExternalize. @Immutable sets backing final fields for each property which can only be set in a constructor. @AutoExternalize is going to try to set fields in the readExternal method.;;;","24/Dec/12 05:36;johann;If {{@Immutable}} marks those fields as final, then yes, those two will not work together. That still doesn't mean the two concepts (serializability/immutability) cannot work together -- see {{java.lang.String}}.

But {{@AutoExternalize}} must create an or verify the existence of a no-argument constructor in any case. :)

Also, happy Christmas.;;;","25/Dec/12 22:59;paulk;Happy Christmas to you too.

There are some tricky issues to deal with in general when dealing with final fields and serialization, e.g. see:
http://bugs.sun.com/view_bug.do?bug_id=6379948

But getting back to specific issues wrt @AutoExtermalize, we can do a little more than we do now but it is still trickier than you would think. The default constructor is added by Groovy's compiler in the class generation phase of the compilation. When the AutoExternalize transform is processing, we will have available any explicitly defined constructors in the classnode but we won't know if subsequent AST transforms add additional constructors (and hence stop Groovy adding in the default constructor later) or add a default constructor later themselves (and hence we wouldn't want to pre-emptively throw a false-positive compile time error). We might be tempted to add the no-arg constructor in early ourselves but that might confuse subsequent transforms. We also could try to sniff about and see if there are other transform annotations on the class and try to deduce what constructors they might add but that would be considered bad practice as we want AST transforms to be as independent as possible. But there are some things we could do and particularly in 2.1 with annotation aliases.

For example, we could rename the existing {{AutoExternalize}} to {{AutoExternalizePre}} or {{AutoExternalizeCanonical}} or something; add a new verifier which checked that a no-arg constructor is defined, e.g. {{AutoExternalizeVerifier}} or {{AutoExternalizePost}} or {{AutoExternalizeClassGen}} or something; then define an annotation alias (new in 2.1) something like:
{code}
@AnnotationCollector([AutoExternalizePre, AutoExternalizeVerifier])
@interface AutoExternalize { }
{code}
This would give you are nicer error message you are after. Instead of a 'no valid constructor' runtime error you would get an error such as '@AutoExternalizable requires a no-arg constructor but none found'.
;;;","26/Dec/12 03:29;paulk;Spike for this functionality here:

https://github.com/paulk-asert/groovy-core/commit/7e6ecaacd94efe4e9b642a1fe88c71adc62a87ae
https://github.com/paulk-asert/groovy-core/commit/baf23e2787f84c4aae43b183e25438538925f91d

Needs further discussion about what to call the introduced (and existing) annotations.;;;","26/Dec/12 04:45;johann;I don't see why it should be that complicated since the {{readExternal}} method should restore all serializable state. In other words, creating a no-argument constructor should not hurt?;;;","26/Dec/12 05:08;paulk;Well that's certainly one solution. In your earlier example, @Immutable would then complain with a compile error that you provided a no-arg constructor where none was allowed. Similarly there are other AST transforms that might behave in different ways when finding a no-arg constructor. These kind of interactions are to be expected but we try to minimise them when we can.;;;","26/Dec/12 15:59;paulk;Perhaps there is one other point that perhaps wasn't clear in my discussion above. Groovy will normally give you the no-arg constructor that @AutoExternalize requires. It is only if you go out of your way to override that behaviour, e.g. by using @Immutable (or some other AST transform that plays with constructors without giving you a no-arg one) or defining your own explicit constructors that you would run into trouble.;;;","27/Dec/12 01:10;blackdrag;If it were only about adding the no args constructor... we could maybe have it as private constructor. That would not prevent anything for Immutable. But setting the final fields then... ;;;","27/Dec/12 06:29;johann;This is just an interaction between {{@Immutable}} and {{@AutoExternalize}} then? That makes it harder to fix since you would need to anticipate the behaviour of all annotations. It also means the annotations are not going to be usable in all cases, which is sad since AST transforms in Groovy are so helpful.;;;","27/Dec/12 15:54;paulk;A private no-arg constructor is not good enough. You still get the same 'no valid constructor' runtime error.

@Johann, yes it is an interaction. Such interactions are to be expected. One wouldn't expect @Immutable to work with for example a @Mutable transform - one would break. Indeed, feature interaction is a well known research topic and the subject of many a PhD thesis with no known general solution. I don't regard it as 'sad'; it just means that there are times when knowing some of what goes on under the covers with a transform can't be avoided. The reason your request has generated some discussion is precisely because of the effort we go to minimising interactions when we can.

So to summarise, we have these options:
# leave things as they are - the runtime error message is perhaps not obvious
# change @AutoExternalize to add a no-arg constructor in an early phase; could potentially interact with other transforms; might need to provide various options, e.g. see force on @TupleConstructor
# change @AutoExternalize to add a np-arg constructor in a latter phase if none is found; minimises the chance of interactions but requires two transforms and an alias
# leave adding constructors to specialist transforms, e.g. @TupleConstructor but check one has been added in a later phase; requires two transforms and an alias

The two transforms and an alias variants would only be for Groovy 2.1+ and have potential implications for classes compiled with earlier versions of Groovy but running on 2.1+ (depending on what names we use for the transforms & alias).;;;","27/Dec/12 15:57;paulk;Assigning temporarily to 2.1.0-rc-1 for review, to ensure discussion before that release.;;;","11/Feb/13 03:16;aalmiray;Personally I'll leave @AutoExternalize as it is. If only @AutoExternalize is applied to a class then the code works as expected. The moment a developer adds a no-args constructor (either manually or via another AST xform) then things go south.

Checking for a no-args constructor during the processing @AutoExternalize is too early; the xform should check if such constructor exists after _all_ AST xforms have run, which is something we don't support yet as far as I recall, that is, running AST xform code in two different phases.;;;","11/Feb/13 17:07;paulk;@Andres: Re: ""running AST xform code in two different phases"" - a good use case for AnnotationCollector as per the spike. :-) But otherwise I agree with your comments.;;;","06/Apr/13 05:38;pschumacher;@Paul should we close this issue?;;;","12/Apr/13 17:18;paulk;Pascal, I would be keen to implement something like what is in the spike - it is ""just"" a matter of working out what (if any) backwards compatibility issues there night be.;;;","03/Jan/14 22:12;paulk;This might have become a non-issue since we fixed GROOVY-6473. Well, the no-arg constructor bit is a non-issue - though we might still want a verifier. The final fields part of the issue which Immutable sets up would still be an issue for AutoExternalize.;;;","15/Jan/14 03:36;paulk;I am going to close this. For Groovy 2.3, AutoExternalize uses the neat annotation collection feature to now run a verification step. The problem with mixing Immutable and AutoExternalize isn't solved - they are incompatible transforms - but now you get a clearer error message. In addition, numerous other error cases are now covered by the verifier and give better error messages. On top of that, the ExternalizeVerifier annotation can be used with your own Externalizable classes to perform various checks if you like. Also, you can use the ExternalizeMethods annotation if you don't want the verification at all.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,
ImportCustomizer for CompilerCustomizationBuilder is not added to configscript CompilerConfiguration ,GROOVY-5863,12816634,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,andre.steingress,andre.steingress,21/Dec/12 15:09,12/Jan/13 20:40,14/Jul/23 06:00,07/Jan/13 07:55,2.1.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.0-rc-1,,,Compiler,,,,0,,,,,,"whenever the -configscript option is given, the referenced script is evaluated using a GroovyShell. 

The code in FileSystemCompiler creates an ImportCustomizer for CompilerCustomizationBuilder, but that customizer is not added to the CompilerConfiguration of the GroovyShell instance.",,andre.steingress,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 07 07:55:57 UTC 2013,,,,,,,,,,"0|i2ctu7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Dec/12 15:13;andre.steingress;here is the pull request: https://github.com/groovy/groovy-core/pull/91;;;","07/Jan/13 07:55;blackdrag;merged;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect Error: type ? is not a valid substitute,GROOVY-5861,12816613,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,aclement,aclement,20/Dec/12 16:46,11/Nov/20 02:00,14/Jul/23 06:00,27/Nov/19 16:12,2.0.5,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.7,,,Compiler,,,,3,,,,,,"I marked this as in 2.0.5 but it also happens in my almost 2.0.6 build too. This code:

{code}
interface Field<T extends java.io.Serializable> {
}
class StructureBase {
    public Field<?> get(Object arg0) {
        return null;
    }
}
{code}

produces this error:

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Foo.groovy: 4: The type ? is not a valid substitute for the bounded parameter <T extends java.io.Serializable>
 @ line 4, column 9.
   	public Field<?> get(Object arg0) {
           ^

1 error
{code}

If the code is put into a .java file and compiled by javac it is fine.",,aclement,davide.cavestro,emilles,mauromol,mrtrevisan,pbetkier,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 27 16:12:34 UTC 2019,,,,,,,,,,"0|i2cu4v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Mar/13 04:48;mrctrevisan;I'm experiencing the same issue in some of my GGTS projects (Groovy-Eclipse Feature 2.8.0.xx-20130304-1200-e42). 
The problem arises even if I set the compiler level to 1.8. 
;;;","27/Nov/19 16:12;emilles;Not sure when this got fixed, but it works in current 2.5 and 3.0 branches.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Invalid generic cast generated in super constructor call in a Java stub,GROOVY-5859,12812020,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,gromopetr,gromopetr,19/Dec/12 09:13,15/Oct/15 18:19,14/Jul/23 06:00,11/Apr/13 06:53,1.8.4,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.3,,,Stub generator / Joint compiler,,,,0,,,,,,"For this Groovy class:
{code}
class TaggedsMap extends TreeMap {

    TaggedsMap() { super() }

    TaggedsMap(Comparator comparator) { super(comparator)}

    TaggedsMap(Map m) {
        super()
        putAll( m)
    }

    TaggedsMap(SortedMap m) {
        super()
        putAll (m)
    }
}
{code}
The following stub is generated:
{code}
public class TaggedsMap
  extends java.util.TreeMap  implements
    groovy.lang.GroovyObject {
public TaggedsMap
() {
super ((java.util.SortedMap<K, java.lang.Object extends V>)null);
}
public TaggedsMap
(java.util.Comparator comparator) {
super ((java.util.SortedMap<K, java.lang.Object extends V>)null);
}
public TaggedsMap
(java.util.Map m) {
super ((java.util.SortedMap<K, java.lang.Object extends V>)null);
}
public TaggedsMap
(java.util.SortedMap m) {
super ((java.util.SortedMap<K, java.lang.Object extends V>)null);
}
}
{code}
which isn't a valid Java code.

Please refer to http://youtrack.jetbrains.com/issue/IDEA-97668 for the full project to reproduce.",,gromopetr,grumpy_bear,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 10 12:15:29 UTC 2013,,,,,,,,,,"0|i2btpr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Apr/13 06:53;grumpy_bear;is this going to be fixed any time soon? every time we regenerate our (big) project we are bothered by this. workarounds necessitate that we give up automatic regeneration.... thanks (or is there a more general workaround?)
;;;","10/Apr/13 11:17;melix;I'm currently looking at it. It's not an easy fix, I'll let you know if there's any chance to have it fixed soon.;;;","10/Apr/13 12:15;melix;A potential fix: https://github.com/groovy/groovy-core/pull/160;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""string"".count('') fails",GROOVY-5858,12816682,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,james.frost,james.frost,19/Dec/12 08:14,18/Jan/13 16:06,14/Jul/23 06:00,15/Jan/13 07:23,2.0.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.7,2.1.0-rc-1,groovy-jdk,,,,0,string,,,,,"String.count() fails when passed an empty string. 

Using 2.0.2 at the moment so haven't tried with other versions.",Linux x64,james.frost,michal.mally,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 15 07:23:04 UTC 2013,,,,,,,,,,"0|i2cnn3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Dec/12 12:40;michal.mally;With Groovy in version 2.0.5 and 2.1.0-beta-1 the execution of ""string"".count('') hangs forever - it gets into endless loop.

The root cause is the bug in String.indexOf() method. I do not know if all the Java JDKs are impacted but Oracle JDK 7u10 for sure. I've even submitted a bug report to Oracle and waiting if it is going to be accepted.

Basically the bug causes String.indexOf(String str, int fromIndex) to return non-negative index which is less than fromIndex passed to it. It is against the contract that is described by String.indexOf() method javadoc. To reproduce the bug empty string has to be passed to method and fromIndex which is greater than length of the string in which we are looking for occurrences in. E.g. ""bug"".indexOf("""", 4) // 3 is returned.

And this is exactly what happens in StringGroovyMethods().count() method:
{code}
    public static int count(String self, String text) {
        int answer = 0;
        for (int idx = 0; true; idx++) {
            idx = self.indexOf(text, idx);
            if (idx >= 0) {
                ++answer;
            } else {
                break;
            }
        }
        return answer;
    }
{code}

Since Groovy has to run on wide variety of JDKs it shall not be relayed on the fact that String.indexOf() is going to be fixed. It shall run both upon ""broken"" and ""fixed"" version of String.indexOf(). So the fix shall be rather applied to Groovy codebase.

Let me know if you agree that the solution shall be applied in Groovy. If so I can invest some of my time to look into it deeper.;;;","23/Dec/12 04:10;paulk;I think adding:
{code}
if (idx == self.size()) break;
{code}
after the increment of {{answer}} would fix the problem.
It yields the result 7 for ""string.count('')"" which I think is what we want.;;;","23/Dec/12 07:03;michal.mally;I think your solution might work however it is another conditional to check within each iteration. What I was thinking about is rather replacing the 'if (idx >= 0)' with 'if (idx >= answer)':
{code}
public static int count(String self, String text) {
  int answer = 0;
  for (int idx = 0; true; idx++) {
    idx = self.indexOf(text, idx);
    if (idx >= answer) {
      ++answer;
    } else {
      break;
    }
  }
  return answer;
}
{code}

The bottom line is that at any time we can't have already found more occurrences than the actual idx value is. So as long idx is greater or equal to answer we are OK with that. If it turns -1 we break as with (idx >= 0). If answer becomes greater than idx it means we are struck with the String.indexOf() bug and we break out as well.

I have not tested it throughly but for following cases it seems to work as expected:
{code}
assert ""string"".count("""") == 7
assert """".count("""") == 1
assert ""aaa"".count(""a"") == 3
assert ""abab"".count(""a"") == 2
assert ""abbabab"".count(""ab"") == 3
assert """".count(""aaa"") == 0
assert ""aabaababaabaa"".count(""aa"") == 4
assert ""aaa"".count(""aa"") == 2
{code}

BTW. Are there any tests for String.count() method? The only test I could find is GroovyMethodsTest.testCountForString().;;;","24/Dec/12 03:46;paulk;Avoiding the extra conditional check is nice but perhaps harder to understand. I'll see if I can think of a way to tweak your solution to make it clearer to understand - it would be nice to have the best of both worlds if we can. Yes, coverage isn't great as far as tests go. There is only the {{GroovyMethodsTest.testCountForString()}} which you spotted and now {{testCountForStringEdgeCase_GROOVY5858()}} which I added.;;;","10/Jan/13 11:16;pschumacher;should have fix version 2.1.0-rc-1;;;","13/Jan/13 03:57;paulk;fix in place for 2.1.0-rc-1; potential further optimization pending;;;","15/Jan/13 07:23;paulk;Fix version applies to initial fix. A slight performance improvement is added for 2.1.0-rc-2 and above.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Annotation causes @CompileStatic to fail,GROOVY-5856,12818208,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,sdmurphy,sdmurphy,18/Dec/12 23:04,22/Dec/12 01:10,14/Jul/23 06:00,19/Dec/12 09:49,2.0.6,2.1.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Compiler,,,,1,,,,,,"If I add @CompileStatic to a class that already has an @Entity gaelyk annotation. I get a compilation error. 
{noformat}
:compileGroovy
startup failed:
General error during class generation: size==0

java.lang.ArrayIndexOutOfBoundsException: size==0
	at org.codehaus.groovy.classgen.asm.OperandStack.doConvertAndCast(OperandStack.java:312)
	at org.codehaus.groovy.classgen.asm.OperandStack.doGroovyCast(OperandStack.java:296)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:592)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:505)
	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:455)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:319)


the EntityTransformation#visit(nodes, source) method runs well but StaticCompileTransformation#visit(nodes, source) fails
{noformat}",Groovy 2.0.6 SNAPSHOT ,blackdrag,melix,musketyr,sdmurphy,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/Dec/12 23:06;sdmurphy;static-compile-fail.zip;https://issues.apache.org/jira/secure/attachment/12722542/static-compile-fail.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 19 09:15:11 UTC 2012,,,,,,,,,,"0|i2bmtz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Dec/12 23:06;sdmurphy;Gradle project to replicate problem

Using:
Gradle 1.3;;;","19/Dec/12 01:08;musketyr;code for @Entity transformation can be fínd here

https://github.com/gaelyk/gaelyk/blob/groovy2/core/src/main/groovyx/gaelyk/datastore/EntityTransformation.groovy

the transformation is called prior the @CompileStatic.

;;;","19/Dec/12 01:22;melix;I'm not 100% sure, but this might be related to this part of the transform:
{code}
block.addStatement(new ReturnStatement(new MethodCallExpression(
                new ClassExpression(helper), name,
                new ArgumentListExpression(
                        new ClassExpression(parent),
                        * parameters.collect { String n, Class cls -> new VariableExpression(n)}
                ))))
{code}
As you can see, a new {{VariableExpression}} is created, but it's both untyped (should be ok) and has no target variable associated (this one is in general problematic). For a {{VariableExpression}}, we should always set the accessed variable to the origin variable it comes from. Here, the code generates a block then a method and the variables correspond to method arguments, so accessed variables should refer to the parameters of the method. I suggest to try to change the transform code so that it generates the parameters first, then the variables and set the accessed variables accordingly:
{code}
def methodParams = parameters.collect { String n, Class cls -> new Parameter(ClassHelper.makeWithoutCaching(cls).plainNodeReference, n)}
def variables = methodParams.collect { 
   def v = new VariableExpression(it.type, it.name)
   v.accessedVariable = it
}
{code};;;","19/Dec/12 01:40;sdmurphy;Shouldn't the compiler give a bit better of an error message though?  rather than size==0?;;;","19/Dec/12 01:45;blackdrag;It means you tried to cast something that is not there. That error message wouldn't have helped you too. Doing the transformations right is the responsibility of the creator of the transformation. If you make a transformation that makes new variables, after VariableScopeVisitor is done, it is your responsibility to do it right and enter the variables in the scope as well as link the VariableExpressions to their origin.;;;","19/Dec/12 01:46;melix;It's more complicated than it seems. There are a lot of possible reasons for this to happen, but I agree that the error message is a bit cryptic. However, would it be better if it was {noformat}Compiler expected an operand on stack but the stack is empty{noformat}? I'm not convinced. The underlying reasons for this to happen can be very tricky to discover, and finding them is just about experience with the compiler: code consuming more operands than it should, code not generated at all, ...;;;","19/Dec/12 01:59;musketyr;would be nice if VariableExpression has more docs. How should I had known that origin is required since there is not single line in groovydoc about it?

Anyway, I've updated the code for parameters list but the problem is still there. How should I create proper variable expression for {{this}} object? I suppose {{new VariableExpression('this')}} might not be sufficient too, am I right?

Any chance that more context could be attached to the exception?

;;;","19/Dec/12 02:02;melix;Hi Vladimir, ""this"" as well as ""super"" are special, you don't need to refer to another class. Can you paste the code of the modified transform somewhere? Maybe I will see something else that might trigger such an error...;;;","19/Dec/12 02:04;blackdrag;please use VariableExpression.THIS_EXPRESSION. without setting any lines or origins;;;","19/Dec/12 02:05;musketyr;I've already pushed the change to the github

https://github.com/gaelyk/gaelyk/commit/38372f9f24233fcc7e3bb821ae3076988115a61a;;;","19/Dec/12 02:13;musketyr;thx! but I still got the same error.;;;","19/Dec/12 02:22;melix;Err, Jochen, people should *never* use {{VariableExpression.THIS_EXPRESSION}} directly, and especially not in AST transforms. Using internal constants causes a lot of troubles so it's definitely an error to do so. Using {{new VariableExpression(""this"")}} is the way to go, and then you should use, if you need to {{ve.isThisExpression()}} instead of an equality test. Not doing so leads to very difficult to find bugs, especially when the build behaves differently on Bamboo :);;;","19/Dec/12 09:15;melix;So there are two bugs here: one in the type checker because it doesn't try to find a method on {{GroovyObject}} if a receiver is a class node being compiled, and another one in Gaelyk.

For reference, I used the '666' trick to find the problem. You must be aware that for various reasons, errors thrown by the type checker on generated code are silent. The way the type checker finds that it's generated code is to check the line number and column number. If it's <0, then it's considered as generated code. So you can make the type checker verbose again just by ensuring, in your AST transform, that generated method calls, for example, have a line number and column number >0. In those cases, I use a dummy, easily recognizable number: 666 :D
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in the ""ClassNode"" constructor",GROOVY-5854,12811685,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,adriannistor,adriannistor,18/Dec/12 12:33,05/Apr/15 14:43,14/Jul/23 06:00,19/Dec/12 09:56,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,,,,,0,,,,,,"The problem appears in version 2.0.5 and in revision 4cf5263..  This
problem is similar to the previously fixed GROOVY-5803, GROOVY-5823,
GROOVY-5825, and GROOVY-5827.  I attached a one-line patch that fixes
it.  I will also post (in the ""Comments"" section) the URL for the
github pull request.

In the ""ClassNode"" constructor (the constructor with 5 parameters),
the loop over ""interfaces"" should break immediately after
""usesGenerics"" is set to ""true"". All the iterations after
""usesGenerics"" is set to ""true"" do not perform any useful work, at
best they just set ""usesGenerics"" again to ""true"".",,adriannistor1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/Dec/12 12:33;patch.diff;https://issues.apache.org/jira/secure/attachment/12722182/patch.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Tue Dec 18 12:37:09 UTC 2012,,,,,,,,,,"0|i2btl3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Dec/12 12:37;adriannistor;the pull request:
https://github.com/groovy/groovy-core/pull/87;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""DefaultGrailsDomainClassInjector.implementsMethod""",GROOVY-5853,12811742,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,adriannistor,adriannistor,18/Dec/12 12:00,05/Apr/15 14:44,14/Jul/23 06:00,19/Dec/12 09:57,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,,,,,0,,,,,,"The problem appears in version 2.0.5 and in revision 4cf5263..  I
attached a one-line patch that fixes it.  I will also post (in the
""Comments"" section) the URL for the github pull request.

In method ""DefaultGrailsDomainClassInjector.implementsMethod"", in the
loop over ""methods"", the statement
""boolean methodMatch = mn.getName().equals(methodName) && isZeroArg""
should be
""boolean methodMatch = isZeroArg && mn.getName().equals(methodName)"".
The second statement avoids comparing strings when ""isZeroArg"" is
""false"".

The code can be made even shorter and faster by having a fast exit (by
pulling ""isZeroArg"" out of the loop) at the beginning of the method
body; this avoids the entire method computation.  While the resulting
code is more compact than the original, the patch itself is a bit
larger (deletes 3 lines, adds 2).  I attached this patch
(patchFull.diff).",,adriannistor1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/Dec/12 12:00;patch.diff;https://issues.apache.org/jira/secure/attachment/12723085/patch.diff","18/Dec/12 12:00;patchFull.diff;https://issues.apache.org/jira/secure/attachment/12723041/patchFull.diff",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Tue Dec 18 12:02:48 UTC 2012,,,,,,,,,,"0|i2bxgv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Dec/12 12:02;adriannistor;the pull request:
https://github.com/groovy/groovy-core/pull/86;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""SimpleGroovyClassDocAssembler.extractName""",GROOVY-5851,12818455,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,adriannistor,adriannistor,17/Dec/12 18:43,07/Apr/15 19:13,14/Jul/23 06:00,20/Dec/12 17:48,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,,,,,0,,,,,,"The problem appears in version 2.0.5 and in revision 4cf5263..  I
attached a three-line patch (patch.diff) that fixes it.  I will also
post (in the ""Comments"" section) the URL for the github pull request.

In method ""SimpleGroovyClassDocAssembler.extractName"", the loop over
""importedClassesAndPackages"" keeps overriding ""typeName"" with ""name"".
Therefore, only the last written value is visible out of the loop and
all the other writes and iterations are not necessary.  The patch
iterates from the end of ""importedClassesAndPackages"" and breaks the
first time when ""typeName"" is set.

The above fix (in patch.diff) is certainly correct (it's easy to see
through code inspection), but I think we can have an even shorter
patch (one line, in patchShort.diff), described below.  There is no
Groovy test that touches this code location, so I am not 100% sure
this second patch (patchShort.diff) is correct, though it should be.

patchShort.diff is based on the fact that the condition 
""if (name.endsWith(slashName))"" (which decides if ""typeName"" is set or
not) is true at most once in the loop over
""importedClassesAndPackages"".  Even if it is true more than one time,
the ""name"" value is still legal.  Thus, the loop can just break
immediately after ""typeName"" is set.",,adriannistor1,blackdrag,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Dec/12 18:43;patch.diff;https://issues.apache.org/jira/secure/attachment/12723040/patch.diff","17/Dec/12 18:43;patchShort.diff;https://issues.apache.org/jira/secure/attachment/12722373/patchShort.diff",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Thu Dec 20 17:48:12 UTC 2012,,,,,,,,,,"0|i2ckin:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Dec/12 18:51;adriannistor;the pull request:
https://github.com/groovy/groovy-core/pull/85;;;","19/Dec/12 08:34;blackdrag;Paul, the loop in question here, can it really be that there is more than one match?;;;","19/Dec/12 15:55;paulk;Hmmm ... I presumed that this was a bug, i.e. if there was more than one that Groovy would pick the first one (or complain like Java would). But (after making the commit!) I looked into it some more and the original behavior is following what Groovy currently supports, e.g.:
{code}
import java.awt.List
import java.util.List

class FooList extends ArrayList implements List {}
def foo = new FooList()
println foo.dump()
println FooList.interfaces
{code}
Picks the {{util}} version of {{List}} for the ""implements"". I am not sure if this is intentional (some flexibility towards Groovy's scripting use cases) or an area of vagueness in the language that we have not needed to clarify before now.
;;;","20/Dec/12 01:42;paulk;I have backed out my previous ""fix""/commit - will work out the best approach to solving this after the 2.0.6/2.1.0-beta releases.;;;","20/Dec/12 17:48;paulk;Release was delayed by a day, so I had a chance to fix this before the release. After confirming the current behavior of Groovy I have applied the pull request in close to its original form and added a comment. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""StaticTypeCheckingVisitor.inferReturnTypeGenerics""",GROOVY-5850,12811737,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,adriannistor,adriannistor,17/Dec/12 17:39,05/Apr/15 14:44,14/Jul/23 06:00,27/Jan/13 07:05,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.0,,,Static Type Checker,,,,0,,,,,,"The problem appears in version 2.0.5 and in revision 4cf5263..  I
attached a one-line patch that fixes it.  I will also post (in the
""Comments"" section) the URL for the github pull request.  

There is no Groovy test that touches this code location (the entire
""else"" branch that contains this code is not touched), but I think the
patch is correct.

In method ""StaticTypeCheckingVisitor.inferReturnTypeGenerics"", the
loop over ""interfaces"" should break immediately after ""actualType"" is
set.  All the iterations after ""actualType"" is set do not perform any
useful work.",,adriannistor1,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Dec/12 17:39;patch.diff;https://issues.apache.org/jira/secure/attachment/12722180/patch.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Sun Jan 27 06:53:46 UTC 2013,,,,,,,,,,"0|i2c85b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Dec/12 17:41;adriannistor;the pull request:
https://github.com/groovy/groovy-core/pull/84;;;","27/Jan/13 06:53;pschumacher;blackdrag merged this pull request into master on 01/04/13. Therefore I'm closing this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""ClassCompletionVerifier.checkMethodForWeakerAccessPrivileges""",GROOVY-5849,12811718,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,adriannistor,adriannistor,17/Dec/12 15:51,05/Apr/15 14:43,14/Jul/23 06:00,19/Dec/12 09:59,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,,,,,0,,,,,,"The problem appears in version 1.8.4 and in revision 4cf5263..  I
attached a one-line patch (patch.diff) that fixes it.  I will also
post (in the ""Comments"" section) the URL for the github pull request.

The entire work performed in method
""ClassCompletionVerifier.checkMethodForWeakerAccessPrivileges""
produces no result when the parameter ""MethodNode mn"" represents a
public method, i.e., when ""mn.isPublic()"" is ""true"".  This condition
can be evaluated right at the beginning of the
""checkMethodForWeakerAccessPrivileges"" method body, thus avoiding the
entire method execution.

We can have this fast exist because the method
""checkMethodForWeakerAccessPrivileges"" produces results only when this
condition (in the method code):

{code:java|borderStyle=solid}
if ((mn.isPrivate() && !superMethod.isPrivate()) ||
        (mn.isProtected() && superMethod.isPublic()))
{code} 

evaluates to ""true"", which does not happen when ""mn.isPublic()"" is
""true"" (i.e., when ""!mn.isPrivate() && !mn.isProtected()"" is ""true"").

I attached a second one-line patch (patchTwoCond.diff) where I use the
condition ""!mn.isPrivate() && !mn.isProtected()"" instead of
""mn.isPublic()"", in case you prefer the longer condition.",,adriannistor1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Dec/12 15:51;patch.diff;https://issues.apache.org/jira/secure/attachment/12722374/patch.diff","17/Dec/12 15:51;patchTwoCond.diff;https://issues.apache.org/jira/secure/attachment/12723009/patchTwoCond.diff",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Mon Dec 17 16:00:27 UTC 2012,,,,,,,,,,"0|i2bzkn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Dec/12 15:59;adriannistor;the pull request: 
https://github.com/groovy/groovy-core/pull/83;;;","17/Dec/12 16:00;adriannistor;> The problem appears in version 1.8.4 and in revision 4cf5263..

I meant ""version 2.0.5"", not ""version 1.8.4"".;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
stackoverflow with compilestatic,GROOVY-5846,12812013,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,aclement,aclement,14/Dec/12 16:14,22/Dec/12 01:10,14/Jul/23 06:00,17/Dec/12 03:36,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"Reported to groovy-eclipse as https://jira.codehaus.org/browse/GRECLIPSE-1514. This code:

{code}
@CompileStatic
class C {
  def xxx(List list) {
    list.unique().each { }
  }
}
{code}

will stackoverflow

{code}
java.lang.StackOverflowError
	at java.util.HashMap.getEntry(HashMap.java:344)
	at java.util.HashMap.containsKey(HashMap.java:335)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolve(StaticTypeCheckingVisitor.java:2834)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:2862)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolve(StaticTypeCheckingVisitor.java:2838)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:2862)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolve(StaticTypeCheckingVisitor.java:2838)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:2862)
...
{code}",,aclement,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-12-14 16:14:31.0,,,,,,,,,,"0|i2cryv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Copy/paste error in EmptyBorderFactory,GROOVY-5844,12816574,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,burtbeckwith,burtbeckwith,07/Dec/12 22:46,05/Apr/15 14:44,14/Jul/23 06:00,08/Dec/12 15:58,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,2.1.0-beta-1,Swing,,,,0,,,,,,"{code}
if ((top == null) || (top == null) || (top == null) || (top == null) || attributes) {
{code}
should be
{code}
if ((top == null) || (left == null) || (bottom == null) || (right == null) || attributes) {
{code}
",,burtbeckwith,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Sat Dec 08 15:58:31 UTC 2012,,,,,,,,,,"0|i2brhr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Dec/12 15:58;paulk;Error fixed. Thanks Burt.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Runtimer error when types down match with Map and Map.Entry when using @CompileStatic,GROOVY-5842,12818210,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,oliver_plow,oliver_plow,07/Dec/12 03:57,05/Apr/14 00:00,14/Jul/23 06:00,15/Jan/14 11:15,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,Static compilation,,,,0,@CompileStatic,exception,runtime,,,"When running the follow code a runtime error occurs:
{code}
@CompileStatic
class Scratch
{

    @CompileStatic
    public static void main(String[] args)
    {
        def Map<String, Set<String>> map = new HashMap<>()
        def set = new HashSet<String>()
        set.add(""foo"")
        map.put(""bar"", set)

        map.each {
            println(it.getKey()) // Groovyc: [Static type checking] - Cannot find matching method java.lang.Object#getKey().
            def List<String> list = it.getValue() // Groovyc: [Static type checking] - Cannot find matching method java.lang.Object#getKey().
        }

        // compiles fine and created runtime error
        // Cannot cast object '[foo]' with class 'java.util.HashSet' to class 'java.util.List' due to: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: java.util.List(java.lang.String)
        map.each { Map.Entry<String, List<String>> entry ->
            println(entry.getKey())
            def List<String> list = entry.getValue()
        }
    }
}
{code}

Reason is that the type parameters for Map<String, Set<String>> and Map.Entry<String, List<String>> don't match, but the compiler doesn't reject it, although @CompileStatic is defined",IDEA IC-123.23,melix,oliver_plow,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5924,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 07 05:15:30 UTC 2013,,,,,,,,,,"0|i2bs7b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Dec/12 05:05;melix;The two static type checking errors are fine, it's the common gotcha with STC and Groovy: the {{each}} method doesn't have enough type information for us to infer the parameter types of the closure.

As for the second error, you would have them in Java too: if you specify the types in the closure and tell it's a {{List<String>}}, the compiler trusts you. If it happens that your map contains something else than a {{List}} (here a {{Set}}), you have a runtime error.;;;","07/Feb/13 05:06;oliver_plow;I just figured out that the last comment by Cedric is not correct:

Map<String, List<Integer>> map = new HashMap<String, List<Integer>>();
List<Integer> list = new ArrayList<Integer>();
list.add(1);
map.put(""1"", list);
		
for(Map.Entry<String, List<Integer>> entry : map.entrySet()) {
    Set<Integer> value = entry.getValue(); // does not compile in Java
}

Not wanting to be picky by re-openeing this issue. Only want to pass on the ""new evidence"" for reconsideration.;;;","07/Feb/13 05:15;melix;Well, yes and no. I mean that if we have the closure argument types checking, we would be capable of throwing an error, but the two codes are different. In your Java version, there's no closure involved (indeed, because Java doesn't know about them).

Anyway, I'm linking this to the issue about improvements in type checking.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Runtime error with nested classes that have parameterized type,GROOVY-5841,12812010,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,oliver_plow,oliver_plow,07/Dec/12 03:46,17/Dec/14 13:25,14/Jul/23 06:00,03/Sep/14 16:11,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,Compiler,,,,0,@CompileStatic,exception,runtime,,,"Running the code below created a runtime error:
{code}
@CompileStatic
public class InnerType<T> {
     public T value = """"
}

@CompileStatic
public class MyType<T> {

     public InnerType<T> inner = new InnerType<>()

     @CompileStatic
     public static main(args)
     {
         MyType<String> type = new MyType<>()
         // type.inner.value = ""123""
         // println(type.inner.value)
     }
}
{code}

Runtime error:
{noformat}
Groovyc: java.lang.ArrayIndexOutOfBoundsException: 0
     at 
org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.compareGenericsWithBound(GenericsType.java:344)
     at 
org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.checkGenerics(GenericsType.java:273)
     at 
org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.matches(GenericsType.java:244)
     at 
org.codehaus.groovy.ast.GenericsType.isCompatibleWith(GenericsType.java:173)
     at 
org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.typeCheckAssignment(StaticTypeCheckingVisitor.java:708)
     at 
org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitField(StaticTypeCheckingVisitor.java:1065)
     at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1048)
     at 
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
     at 
org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:222)
     at 
org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:108)
     at 
org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:58)
     at 
org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
     at 
org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
     at 
org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1027)
     at 
org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:564)
     at 
org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:542)
     at 
org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:519)
     at 
org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:44)
     at 
org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:129)
     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
     at 
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
     at 
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
     at java.lang.reflect.Method.invoke(Method.java:601)
     at 
com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:112)

{noformat}",Happens with the Groovy eclipse plugin and with IDEA using Groovy 2.0.5,melix,oliver_plow,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 03 16:11:55 UTC 2014,,,,,,,,,,"0|i2ceuv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Dec/12 05:08;melix;Still happens on {{master}}.;;;","03/Sep/14 16:11;pschumacher;Works on current master.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Typechecker does not detect shadowed generic parameter,GROOVY-5839,12816647,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ddimitrov,ddimitrov,05/Dec/12 08:32,23/Dec/15 10:10,14/Jul/23 06:00,19/Jul/13 08:41,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,Static Type Checker,,,,0,,,,,,"The typechecker does not realize that the <T> of the method shadows the <T> of the class and compiles this code without warning. The same code does not typecheck in Java.

{code}
public class GoodCodeRed<T> {
    Collection<GoodCodeRed<T>> attached

    @groovy.transform.CompileStatic
    public <T> void attach(GoodCodeRed<T> toAttach) {
        attached.add(toAttach)
    }
}
{code}

See also http://youtrack.jetbrains.com/issue/IDEA-96606",,blackdrag,ddimitrov,fpavageau,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7719,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 22 17:50:06 UTC 2015,,,,,,,,,,"0|i2c0kn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jul/13 08:41;blackdrag;fixed;;;","22/Dec/15 14:40;fpavageau;I'm not sure that's fixed actually, because the test case tests a different scenario:
{code}
public class GoodCodeRed<T> {
    Collection<GoodCodeRed<T>> attached = []
    public <T> void attach(GoodCodeRed<T> toAttach) {
        attached.add(toAttach)
   }
   static void foo() {
       def g1 = new GoodCodeRed<Long>()
       def g2 = new GoodCodeRed<Integer>()
       g1.attach(g2);
    }
}
GoodCodeRed.foo()
{code}

The point is not that it shouldn't be possible to call {{attach()}} on an instance parameterized by {{Long}} with a argument parameterized by {{Integer}}, it's that {{T}} in the context of the method is not the same as {{T}} in the context of the class.

The same class in Java (without the static method):
{code}
import java.util.ArrayList;
import java.util.Collection;
public class GoodCodeRed<T> {
    private Collection<GoodCodeRed<T>> attached = new ArrayList<>();
    public <T> void attach(GoodCodeRed<T> toAttach) {
        attached.add(toAttach);
    }
}
{code}
fails to compile the {{attach()}} method itself:
{noformat}
GoodCodeRed.java:6: error: incompatible types: GoodCodeRed<T#1> cannot be converted to GoodCodeRed<T#2>
        attached.add(toAttach);
                     ^
  where T#1,T#2 are type-variables:
    T#1 extends Object declared in method <T#1>attach(GoodCodeRed<T#1>)
    T#2 extends Object declared in class GoodCodeRed
{noformat}

It's not the compilation of the usage of {{GoodCodeRed}} which should fail, but of its implementation, as if it were written like:
{code}
public class GoodCodeRed<T> {
    Collection<GoodCodeRed<T>> attached = []
    public <U> void attach(GoodCodeRed<U> toAttach) {
        attached.add(toAttach)
   }
}
{code}
without the type shadowing. {{T}} and {{U}} are not related, neither are {{T#1}} and {{T#2}}.

Should I open a new bug?;;;","22/Dec/15 17:50;pascalschumacher;Yes, please open a new bug. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc not working (ClassNotFoundException),GROOVY-5838,12816557,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,k2s,k2s,04/Dec/12 17:05,22/Dec/12 01:10,14/Jul/23 06:00,07/Dec/12 17:07,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,GroovyDoc,,,,0,,,,,,"I am not the alone with this problem on IRC#grails.

Getting error when I execute:
# groovydoc

java.lang.ClassNotFoundException: org.codehaus.groovy.tools.groovydoc.Main
	at org.codehaus.groovy.tools.RootLoader.findClass(RootLoader.java:175)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:423)
	at org.codehaus.groovy.tools.RootLoader.loadClass(RootLoader.java:147)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:356)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:96)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
","Arch Linux 3.6.8-1-ARCH
java version ""1.7.0_09""
Java(TM) SE Runtime Environment (build 1.7.0_09-b05)
Java HotSpot(TM) 64-Bit Server VM (build 23.5-b02, mixed mode)",k2s,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 07 17:07:40 UTC 2012,,,,,,,,,,"0|i2c687:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Dec/12 17:12;k2s;same problem mentioned in comments http://stackoverflow.com/questions/12432674/groovydocs-on-eclipse;;;","05/Dec/12 06:29;paulk;There was a glitch in how we prepared the jar and the source file rather than the class file was being included for the groovydoc module. This is of course still runnable but not out of the box using the current startGroovy scripts. This has been fixed in master (so feel free to test) but before resolving the issue, I have some more cleanup work to do and possibly some kind of integration test to avoid this reoccurring. And I will push to other branches as appropriate eventually as well.;;;","05/Dec/12 06:44;k2s;thank you

could you pls. post workarround how to start it without startGroovy script ?;;;","06/Dec/12 19:45;paulk;WRT a workaround. I guess there are numerous ways. I was hoping we supported a ""jar:"" prefix when running a script from a URL but we don't support that at present.

You could type the following into GroovyConsole for instance for Groovy 2.0.5 (needs to be updated depending on your platform/installation dir):
{code}
evaluate(new URL('jar:file:/C:/devtools/groovy-2.0.5/lib/groovy-groovydoc-2.0.5.jar!/org/codehaus/groovy/tools/groovydoc/Main.groovy').text)
{code}
as a starting point (will print usage message) but it might be just as easy to extract the script manually as a once off activity.

WRT the ""affects version"". I don't see this on Groovy 1.8.8, was that a typo?;;;","07/Dec/12 02:37;k2s;I am sorry, 1.8.8 should not be listed. I am not able to edit it.
;;;","07/Dec/12 17:07;paulk;resources now better follow maven-like/gradle supported conventions which makes the problem which crept in go away;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Griffon bind using parentheses fails silently or with cryptic message,GROOVY-5837,12812009,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,aalmiray,thompson2526,thompson2526,30/Nov/12 15:25,22/Dec/12 01:10,14/Jul/23 06:00,11/Dec/12 10:41,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,,,,,0,exception,,,,,"If a Griffon user accidentally replaces curly braces {} with parentheses () in a call to bind, the error either fails silently at runtime or with a cryptic compiler error (depending on the widget type).

In the sample code (attached), the first textfield and button work correctly.  The 2nd textfield (error #1) fails silently (it is blank, no compiler warnings). If uncommented, the 2nd button (error #2) causes a cryptic runtime exception (java.lang.NullPointerException  -  see full stacktrace attached).

Sample Griffon code for project ""bug"":
{code}
-- BugView.groovy ----------------------------------------------
package bug

def makeText = { phrase ->
  textField( columns:10,    text: bind { phrase.insect  } )  // correct
  button(    ""Larvae"",   enabled: bind { phrase.enabled } )  // correct
  textField( columns:10,    text: bind ( phrase.insect  ) )  // error #1 - silent failure
  // button(    ""Larvae"",   enabled: bind ( phrase.enabled ) )  // error #2 - compiler error
}

def val = 1
application( title: 'bug', preferredSize: [320, 240], pack: true, location: [50,50],
             iconImage: imageIcon('/griffon-icon-48x48.png').image
           ) {
  borderLayout()
  panel( constraints: CENTER, border: titledBorder(title: 'Bug Test')) {
    widget( makeText( model.""data${val}"" ) )
  }
}

-- BugModel.groovy ----------------------------------------------
package bug
import groovy.beans.Bindable

@Bindable 
class BugModel {
  Map data1 = [ insect:""Buggy Text"", buggyFlag: true ] as ObservableMap
}
{code}","> griffon --version
------------------------------------------------------------
  Griffon 1.1.0
------------------------------------------------------------
   Build: 20-Sep-2012 07:25 PM
  Groovy: 1.8.8
     Ant: 1.8.4
   Slf4j: 1.7.1
  Spring: 3.1.2.RELEASE
     JVM: 1.7.0_09 (Oracle Corporation 23.5-b02)
      OS: Windows 7 6.1 amd64
",aalmiray,guillaume,melix,thompson2526,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Nov/12 15:25;thompson2526;BugController.groovy;https://issues.apache.org/jira/secure/attachment/12723084/BugController.groovy","30/Nov/12 15:25;thompson2526;BugModel.groovy;https://issues.apache.org/jira/secure/attachment/12722929/BugModel.groovy","30/Nov/12 15:25;thompson2526;BugView.groovy;https://issues.apache.org/jira/secure/attachment/12722654/BugView.groovy","30/Nov/12 15:25;thompson2526;bug.out;https://issues.apache.org/jira/secure/attachment/12723038/bug.out","30/Nov/12 15:25;thompson2526;buggy.png;https://issues.apache.org/jira/secure/attachment/12723039/buggy.png",,,,5.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 11 10:41:39 UTC 2012,,,,,,,,,,"0|i2busf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"04/Dec/12 02:50;aalmiray;Must fix {{groovy.swing.factory.BindFactory}} as it assumes the value to be of some kind (most likely candidate is sourceProperty:);;;","05/Dec/12 04:23;aalmiray;Pull request @ https://github.com/groovy/groovy-core/pull/79;;;","05/Dec/12 04:34;guillaume;The patch is for the Groovy 2.0.x branch.
Should it be merged in master and the 1.8.x branch as well?;;;","05/Dec/12 04:38;aalmiray;If master is what Groovy 2.1 will become then yes :-);;;","11/Dec/12 10:41;melix;Fixed in master and 2.0.x;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic can not resolve function,GROOVY-5836,12816556,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,03/Dec/12 20:42,22/Dec/12 01:10,14/Jul/23 06:00,04/Dec/12 10:13,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"This fails:
{code}
import groovy.transform.CompileStatic

@CompileStatic class Test<T> {
    void transform(boolean passThroughNulls, Closure<T> mapper) {}
    void transformAll(boolean passThroughNulls, Closure<T>... mappers) {
        for (m in mappers) {
            transform passThroughNulls, m
        }
    }
}
{code}

This passes:
{code}
import groovy.transform.CompileStatic

@CompileStatic class Test<T> {
    void transform(boolean passThroughNulls, Closure mapper) {}
    void transformAll(boolean passThroughNulls, Closure... mappers) {
        for (m in mappers) {
            transform passThroughNulls, m
        }
    }
}
{code}

The only difference is whether we declare the generic parameter of the closure type.",,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-12-03 20:42:52.0,,,,,,,,,,"0|i2bv7r:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Few @CompileStatic bugs,GROOVY-5835,12818202,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,03/Dec/12 20:27,22/Dec/12 01:10,14/Jul/23 06:00,04/Dec/12 03:37,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"There are multiple issues illustrated by the code below:
* compiler can not infer the type when iterating with each() over vararg argument. Iteration using for-in works fine. 
* When using explicit return from a closure inside the method, the compiler checks the method return type, rather than the closure's declared return type
* Certain types of overloading blow the compiler's stack - compare transform(mappers) with filter(predicates)

{code}
import groovy.transform.CompileStatic

public class Test<T> {

    Test<T> transform(boolean passThroughNulls=true, Closure<T> mapper) { this }

    /*@CompileStatic*/  // blows the compiler stack
    Test<T> transform(boolean passThroughNulls=true, Closure<T>... mappers) {
        mappers.each { Closure<T> it -> transform passThroughNulls, it }
        return this
    }


    @CompileStatic
    Test<T> filter(Closure<Boolean> predicate) {
        transform { T it -> 
            def retval = predicate(it) ? it : null
            /*return*/ retval // compiler thinks 'return' is for the enclosing method
        }  
        return this
    }

    @CompileStatic
    Test<T> filter(Closure<Boolean>... predicates) {
        predicates.each { Closure<Boolean> it -> // compiler can not infer the type of 'it' even we are iterating over plain array 
            filter it 
        }
        return this
    }
}
{code}",,ddimitrov,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 04 03:33:34 UTC 2012,,,,,,,,,,"0|i2bpxb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"04/Dec/12 03:14;melix;Thanks for the report. A few remarks/questions though:
* it's better to create separate bug reports for each bug as is makes isolating issues easier
* I can reproduce issue n°1 (stack overflow) using 2.0.5, but it doesn't appear on {{master}} or {{2.0.X branch}} so I think it's already fixed
* I can reproduce issue n°2 with a separate example (below) in 2.0.5, already fixes in both {{master}} and {{2.0.X}} so I just added a unit test
{code}
@TypeChecked
int enclosingMethod() {
   def cl = { return 'String' } // should not think it's a return for the enclosing method
   1
}
{code}
* last issue doesn't look like a bug, but a known limitation, if I understand well what you mean. You are expecting the compiler to understand that the {{it}} parameter of the closure, since it's called on {{each}}, is of type {{Closure<Boolean}}. Unfortunately, the signature of {{DefaultGroovyMethods#each}} doesn't have enough type information for the compiler to infer that. There are open discussions about how to fix that in future versions of Groovy.;;;","04/Dec/12 03:33;ddimitrov;Thanks, in this case you may resolve. Will submit separate issues next time.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@StaticCompile fails for regex literals,GROOVY-5834,12816624,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ddimitrov,ddimitrov,02/Dec/12 20:27,22/Dec/12 01:10,14/Jul/23 06:00,03/Dec/12 04:28,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static Type Checker,,,,0,,,,,,"Compiling the following code:

{code}
@CompileStatic
class Sample { def pattern = ~'foo|bar' }
{code}

results in the compiler throwing the following exception:

{code}
Groovyc: java.lang.NullPointerException
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBitwiseNegationExpression(StaticTypeCheckingVisitor.java:1174)
	at org.codehaus.groovy.ast.expr.BitwiseNegationExpression.visit(BitwiseNegationExpression.java:37)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitField(ClassCodeVisitorSupport.java:129)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitField(StaticTypeCheckingVisitor.java:1055)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1048)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:222)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:108)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:58)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1027)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:564)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:542)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:519)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:44)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:129)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:112)
{code}",,ddimitrov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-12-02 20:27:24.0,,,,,,,,,,"0|i2cdbj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""GroovyDocToolTest.testPlainGroovyDocTool""",GROOVY-5831,12818454,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,adriannistor,adriannistor,29/Nov/12 12:32,05/Apr/15 14:44,14/Jul/23 06:00,30/Nov/12 12:38,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,,,,,0,,,,,,"The problem appears in Groovy 2.0.5 and in revision 740ae7c..  I
attached a one-line patch that fixes it.

In method ""GroovyDocToolTest.testPlainGroovyDocTool"", the loop over
""clazz.methods()"" should break immediately after ""seenThisMethod"" is
set to ""true"".  All the iterations after ""seenThisMethod"" is set to
""true"" do not perform any useful work, at best they just set
""seenThisMethod"" again to ""true"".",,adriannistor1,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Nov/12 12:32;patch.diff;https://issues.apache.org/jira/secure/attachment/12723008/patch.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Nov 30 12:38:23 UTC 2012,,,,,,,,,,"0|i2cojr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Nov/12 13:20;adriannistor;This problem and the attached patch are similar the previously fixed
GROOVY-5803 and its patches.;;;","30/Nov/12 12:38;blackdrag;change applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""SecurityTestSupport.executeTest""",GROOVY-5830,12818451,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,adriannistor,adriannistor,29/Nov/12 12:22,05/Apr/15 14:43,14/Jul/23 06:00,30/Nov/12 12:38,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,,,,,0,,,,,,"The problem appears in Groovy 2.0.5 and in revision 740ae7c..  I
attached a one-line patch that fixes it.

In method ""SecurityTestSupport.executeTest"", the loop over
""result.errors()"" should break immediately after ""otherFailure"" is set
to ""true"".  All the iterations after ""otherFailure"" is set to ""true""
do not perform any useful work, at best they just set ""otherFailure""
again to ""true"".",,adriannistor1,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Nov/12 12:22;patch.diff;https://issues.apache.org/jira/secure/attachment/12723082/patch.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Nov 30 12:38:22 UTC 2012,,,,,,,,,,"0|i2c62v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Nov/12 13:20;adriannistor;This problem and the attached patch are similar the previously fixed
GROOVY-5803 and its patches.;;;","30/Nov/12 12:38;blackdrag;change applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""AnnotationVisitor.checkIfValidEnumConstsAreUsed""",GROOVY-5829,12818452,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,adriannistor,adriannistor,29/Nov/12 10:41,05/Apr/15 14:43,14/Jul/23 06:00,30/Nov/12 12:38,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,,,,,0,,,,,,"The problem appears in Groovy 2.0.5 and in revision 740ae7c..  I
attached a one-line patch that fixes it.

In method ""AnnotationVisitor.checkIfValidEnumConstsAreUsed"", the loop
over ""attributes.entrySet()"" should break immediately after ""ok"" is
set to ""false"".  All the iterations after ""ok"" is set to ""false"" do
not perform any useful work, at best they just set ""ok"" again to
""false"".",,adriannistor1,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Nov/12 10:41;patch.diff;https://issues.apache.org/jira/secure/attachment/12723117/patch.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Nov 30 12:38:23 UTC 2012,,,,,,,,,,"0|i2cnj3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Nov/12 13:20;adriannistor;This problem and the attached patch are similar the previously fixed
GROOVY-5803 and its patches.;;;","30/Nov/12 12:38;blackdrag;change applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
No way to tell @Immutable that you're using an Immutable List structure already,GROOVY-5828,12818201,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,tim_yates,tim_yates,29/Nov/12 10:35,22/Dec/12 01:10,14/Jul/23 06:00,02/Dec/12 01:00,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,groovy-jdk,,,,0,,,,,,"Given this class:

{code}
@Grab( 'org.clojure:clojure:1.4.0' )
import clojure.lang.PersistentList
import clojure.lang.PersistentVector

//@groovy.transform.Immutable(knownImmutableClasses=[List])
class Broken {
  List list
  
  Broken( List list ) {
    this.list = list
  }
  
  Broken cons( Object v ) {
    new Broken( list.cons( v ) )
  }
  
  String toString() {
    ""$list""
  }
}

def a = new Broken( PersistentList.EMPTY.cons( 'tim' ) )
println a.cons( 'yates' )

def b = new Broken( PersistentVector.EMPTY.cons( 'tim' ) )
println b.cons( 'yates' )
{code}

We get the output:

{code}
[yates, tim]
[tim, yates]
{code}

However, if we annotate the class as Immutable (and get rid of the constructor and the toString as would be required)

{code}
@Grab( 'org.clojure:clojure:1.4.0' )
import clojure.lang.PersistentList
import clojure.lang.PersistentVector

@groovy.transform.Immutable
class Broken {
  List list
  
  Broken cons( Object v ) {
    new Broken( list.cons( v ) )
  }
}

def a = new Broken( PersistentList.EMPTY.cons( 'tim' ) )
println a.cons( 'yates' )

def b = new Broken( PersistentVector.EMPTY.cons( 'tim' ) )
println b.cons( 'yates' )
{code}

We now get the output:

{code}
Caught: groovy.lang.MissingMethodException: No signature of method: java.util.Collections$UnmodifiableList.cons() is applicable for argument types: (java.lang.String) values: [yates]
Possible solutions: join(java.lang.String), count(groovy.lang.Closure), count(java.lang.Object), sort(), find(), any()
groovy.lang.MissingMethodException: No signature of method: java.util.Collections$UnmodifiableList.cons() is applicable for argument types: (java.lang.String) values: [yates]
Possible solutions: join(java.lang.String), count(groovy.lang.Closure), count(java.lang.Object), sort(), find(), any()
	at Broken.cons(PList3.groovy:10)
	at Broken$cons.call(Unknown Source)
	at PList3.run(PList3.groovy:15)
{code}

So the transformation has changed our List field into a UnmodifiableList, and I can no longer call the PersistentVector or PersistentList methods on it.

Changing the transformation to:

{code}
@groovy.transform.Immutable(knownImmutableClasses=[List])
{code}

Makes no change :-(

Is there (or could there be added) a way of saying that you know that a given field is an Immutable type?

Cheers,

Tim
",,paulk,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 02 01:00:30 UTC 2012,,,,,,,,,,"0|i2cksv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Dec/12 04:50;paulk;I suspect we should switch the order around between Collection and knownImmutableClass checking in {{ImmutableASTTransformation#createConstructorStatement}}. I believe this would solve your immediate problem.

Whether in addition we could support a ""knownImmutables"" attribute where we listed the names of properties that would be treated as immutable regardless of type is a further thing to ponder I guess. That would certainly be useful where you had multiple lists for instance, some of which might be Persistent/Immutable ones and others which might need UnmodifiableList treatment.;;;","02/Dec/12 01:00;paulk;Fixed by reordering the checking logic within {{ImmutableASTTransformation#createConstructorStatement}}. Now if a Collection class is specifically mentioned as a known immutable class, it is left alone.

In addition, for 2.1.0+, there is now an additional attribute {{knownImmutables}} where you can list the names of properties which are known to be immutable.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""StaticTypeCheckingVisitor.areCategoryMethodCalls""",GROOVY-5827,12818448,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,adriannistor,adriannistor,29/Nov/12 10:28,05/Apr/15 14:43,14/Jul/23 06:00,30/Nov/12 12:38,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,,,,,0,,,,,,"The problem appears in Groovy 2.0.5 and in revision 740ae7c..  I
attached a one-line patch that fixes it.

In method ""StaticTypeCheckingVisitor.areCategoryMethodCalls"", the loop
over ""foundMethods"" should break immediately after ""category"" is set
to ""false"".  All the iterations after ""category"" is set to ""false"" do
not perform any useful work, at best they just set ""category"" again to
""false"".",,adriannistor1,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Nov/12 10:28;patch.diff;https://issues.apache.org/jira/secure/attachment/12722653/patch.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Nov 30 12:38:23 UTC 2012,,,,,,,,,,"0|i2ccjj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Nov/12 13:19;adriannistor;This problem and the attached patch are similar the previously fixed
GROOVY-5803 and its patches.;;;","30/Nov/12 12:38;blackdrag;change applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""DomToGroovy.mixedContent""",GROOVY-5826,12811700,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,adriannistor,adriannistor,29/Nov/12 10:08,05/Apr/15 14:43,14/Jul/23 06:00,30/Nov/12 12:38,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,,,,,0,,,,,,"The problem appears in Groovy 2.0.5 and in revision 740ae7c..  I
attached a one-line patch (patch.diff) that fixes it.

In method ""DomToGroovy.mixedContent"", the loop over ""list"" should
break immediately after ""hasText"" and ""hasElement"" are ""true"".  All
the iterations after ""hasText"" and ""hasElement"" are ""true"" do not
perform any useful work, at best they just set ""hasText"" and
""hasElement"" again to ""true"".

Method ""addMethods"" in class ""EnumVisitor"" has a similar loop (over
""methods""), and this loop breaks immediately after both ""hasNext"" and
""hasPrevious"" are set to ""true"", just like in the proposed patch.

Similarly, method ""rootLoader"" in class ""GroovyStarter"" has a loop
that breaks when all three ""hadMain"" and ""hadConf"" and ""hadCP"" are set
to ""true"", like in the proposed patch.",,adriannistor1,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Nov/12 10:08;patch.diff;https://issues.apache.org/jira/secure/attachment/12723007/patch.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Nov 30 12:38:24 UTC 2012,,,,,,,,,,"0|i2bq4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Nov/12 13:19;adriannistor;This problem and the attached patch are similar the previously fixed
GROOVY-5803 and its patches.;;;","30/Nov/12 12:38;blackdrag;change applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""ClassCompletionVerifier.addErrorIfParamsAndReturnTypeEqual""",GROOVY-5825,12818453,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,adriannistor,adriannistor,29/Nov/12 09:50,05/Apr/15 14:44,14/Jul/23 06:00,30/Nov/12 12:38,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,,,,,0,,,,,,"The problem appears in Groovy 2.0.5 and in revision 740ae7c..  I
attached a one-line patch (patch.diff) that fixes it.

In method
""ClassCompletionVerifier.addErrorIfParamsAndReturnTypeEqual"", the loop
over ""p1"" and ""p2"" should break immediately after ""isEqual"" becomes
""false"".  All the iterations after ""isEqual"" is ""false"" do not perform
any useful work.",,adriannistor1,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Nov/12 09:50;patch.diff;https://issues.apache.org/jira/secure/attachment/12722179/patch.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Nov 30 12:38:23 UTC 2012,,,,,,,,,,"0|i2bvdb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Nov/12 13:18;adriannistor;This problem and the attached patch are similar the previously fixed
GROOVY-5803 and its patches.;;;","30/Nov/12 12:38;blackdrag;change applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""ClassCompletionVerifier.checkOverloadingPrivateAndPublic""",GROOVY-5824,12818439,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,adriannistor,adriannistor,29/Nov/12 09:25,05/Apr/15 14:44,14/Jul/23 06:00,30/Nov/12 12:38,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,,,,,0,,,,,,"The problem appears in Groovy 2.0.5 and in revision 740ae7c..  I
attached a one-line patch (patch.diff) that fixes it.

In method ""ClassCompletionVerifier.checkOverloadingPrivateAndPublic"",
the loop over ""currentClass.getMethods(...)"" should break immediately
after both ""hasPrivate"" and ""hasPublic"" are ""true"".  All the
iterations after ""hasPrivate"" and ""hasPublic"" are ""true"" do not
perform any useful work, at best they just set ""hasPrivate"" and
""hasPublic"" again to ""true"".

Method ""addMethods"" in class ""EnumVisitor"" has a similar loop (over
""methods""), and this loop breaks immediately after both ""hasNext"" and
""hasPrevious"" are set to ""true"", just like in the proposed patch.

Similarly, method ""rootLoader"" in class ""GroovyStarter"" has a loop
that breaks when all three ""hadMain"" and ""hadConf"" and ""hadCP"" are set
to ""true"".",,adriannistor1,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Nov/12 09:25;patch.diff;https://issues.apache.org/jira/secure/attachment/12723081/patch.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Nov 30 12:38:24 UTC 2012,,,,,,,,,,"0|i2bunr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Nov/12 09:59;blackdrag;Adrian, I will apply the patch... but you know, if you would make a pull request on github, then your name would appear in the file history, not mine ;);;;","29/Nov/12 10:05;adriannistor;> your name would appear in the file history, not mine

That's fine blackdrag.;;;","29/Nov/12 13:18;adriannistor;This problem and the attached patch are similar the previously fixed
GROOVY-5803 and its patches.;;;","30/Nov/12 12:38;blackdrag;change applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""GenericsType.GenericsTypeMatcher.compareGenericsWithBound""",GROOVY-5823,12818457,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,adriannistor,adriannistor,29/Nov/12 09:00,05/Apr/15 14:44,14/Jul/23 06:00,30/Nov/12 12:38,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,,,,,0,,,,,,"The problem appears in Groovy 2.0.5 and in revision 740ae7c..  I
attached a one-line patch (match.diff) that fixes it.

In method ""GenericsType.GenericsTypeMatcher.compareGenericsWithBound"",
the loop over ""redirectBoundType.upperBounds"" should break immediately
after ""match"" is set to ""false"".  All the iterations after ""match"" is
set to ""false"" do not perform any useful work, at best they just set
""match"" again to ""false"".

Similarly, in the same method
""GenericsType.GenericsTypeMatcher.compareGenericsWithBound"", the loop
over ""interfaces"" should break immediately after ""success"" is set to
""false"".  I attached a separate patch (interfaces.diff) for this loop.",,adriannistor1,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Nov/12 09:00;match.diff;https://issues.apache.org/jira/secure/attachment/12722178/match.diff","29/Nov/12 09:00;success.diff;https://issues.apache.org/jira/secure/attachment/12722928/success.diff",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Nov 30 12:38:23 UTC 2012,,,,,,,,,,"0|i2ca9z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Nov/12 13:17;adriannistor;This problem and the attached patches are similar the previously fixed
GROOVY-5803 and its patches.;;;","30/Nov/12 12:38;blackdrag;change applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[SwingBuilder] ListFactory does not use custom JList instance if items: is specified,GROOVY-5820,12818198,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,aalmiray,aalmiray,aalmiray,28/Nov/12 03:13,22/Dec/12 01:10,14/Jul/23 06:00,28/Nov/12 09:55,1.8.8,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Swing,,,,0,,,,,,"From the Griffon User list ->

Hi everyone.  I feel like the answer is staring me in the face on this one but I can't figure out what I'm doing wrong.

I have an object that extends JList:

{code}
class MyList extends JList {
     
     public MyList(){
         super()
     }

     ... custom methods ...
}
{code}

and I'm using it in my view as such:

{code}
list(new MyList(), id:'listId', items:[""item 1"",""item 2"",""etc""], valueChanged:controller.listSelectionChangedAction)
{code}

Then in my controller I have:

{code}
def listSelectionChangedAction = { evt ->
     def list = (MyList)evt.source
     ... do stuff with list ...
}
{code}

But I'm getting an error for the type casting:

{code}
2012-11-27 19:34:52,434 [pool-2-thread-2] ERROR griffon.util.GriffonExceptionHandler - Uncaught Exception
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'javax.swing.JList[listId,0,0,256x136,alignmentX=0.0,alignmentY=0.0,border=,flags=50331944,maximumSize=,minimumSize=,preferredSize=,fixedCellHeight=-1,fixedCellWidth=-1,horizontalScrollIncrement=-1,selectionBackground=com.apple.laf.AquaImageFactory$SystemColorProxy[r=42,g=91,b=213],selectionForeground=com.apple.laf.AquaImageFactory$SystemColorProxy[r=255,g=255,b=255],visibleRowCount=8,layoutOrientation=0]' with class 'javax.swing.JList' to class 'com.myproject.MyList'
{code}

Attempts to access the custom methods of my list class without the type casting also produce an error.  Anyone know what's wrong with this?  Thanks in advance. ",,aalmiray,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 28 04:39:36 UTC 2012,,,,,,,,,,"0|i2cs6n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Nov/12 04:39;aalmiray;Pull request @ https://github.com/groovy/groovy-core/pull/76;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MapStyleConstructorCall breaks Groovy-Eclipse,GROOVY-5818,12816618,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,werdna,werdna,26/Nov/12 12:55,22/Dec/12 01:10,14/Jul/23 06:00,28/Nov/12 02:16,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"The {{MapStyleConstructorCall}} ast node is used in place of a {{ConstructorCallExpression}} ast node.  However, since {{MapStyleConstructorCall}} is a sub-class of {{ByteCodeExpression}}, it is not treated as a normal ast node and AST visitors are not visiting it correctly.

This has an effect on Groovy-Eclipse in that source code operations (eg- search, refactor, type inferencing, organize imports, navigation, etc) will not work on {{MapStyleConstructorCall}}s or any of their child nodes.  

Additionally, source locations are not correct for this AST node. ",,melix,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 27 18:53:01 UTC 2012,,,,,,,,,,"0|i2bmt3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Nov/12 13:00;werdna;Proposed solution:

# add new field to {{MapStyleConstructorCall}} that contains the original {{ConstructorCallExpression}}.
# set the sloc of the {{MapStyleConstructorCall}} 
# in {{MapStyleConstructorCall.visit(GroovyCodeVisitor)}}, do something like the following:

{code}
        @Override
        public void visit(final GroovyCodeVisitor visitor) {
            if (visitor instanceof AsmClassGenerator) {
                acg = (AsmClassGenerator) visitor;
            } else {
                originalConsCallExpr.visit(visitor);
            } 
            super.visit(visitor);
        }
{code}

This would probably work for Groovy-Eclipse, but I have not tried to actually implement this.  Do you see any problems with this in using this for Groovy?;;;","27/Nov/12 13:13;melix;The change is ok for Groovy. Just let me know if it's ok for Eclipse too and I'll push the change.;;;","27/Nov/12 18:53;werdna;Thanks.  Pull request is here:

https://github.com/groovy/groovy-core/pull/74;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem with Immutable and CompileStatic,GROOVY-5814,12811886,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,21/Nov/12 07:04,22/Dec/12 01:10,14/Jul/23 06:00,28/Nov/12 08:50,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"If you try:

{code}
import groovy.transform.*

@CompileStatic
@Immutable
class Test {
  int a
  String b
}

new Test( 1, 'tim' )
{code}

You get:

{code}
4 compilation errors:

Access to java.lang.Object#a is forbidden at line: -1, column: -1

Access to java.lang.Object#a is forbidden at line: -1, column: -1

Access to java.lang.Object#b is forbidden at line: -1, column: -1

Access to java.lang.Object#b is forbidden at line: -1, column: -1
{code}

If the two are incompatible, is it possible for a better error message?",,melix,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 28 08:50:13 UTC 2012,,,,,,,,,,"0|i2cl7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Nov/12 08:50;melix;For reference, the problem was that {{@Immutable}} used {{VariableExpression}}s for which the accessed variable wasn't set. As those VEs were referencing an argument, {{args}}, of type {{HashMap}}, the inferred type was {{Object}} instead of {{HashMap}}.

Fixed in both 2.0.6 and master.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java code behaves wrong on 2.0.5 but not on 1.8.8,GROOVY-5812,12816631,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,sbglasius,sbglasius,20/Nov/12 14:02,12/Jan/13 20:40,14/Jul/23 06:00,07/Jan/13 08:34,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,primtive opts,,,,1,,,,,,"The folowing Java code:

{code}
public class HelloWorld {
	private String[] names;
	public String[] getNames() { return names; }
	public void setNames(String... names) { this.names = names; }

	public String toString() {
		return ""Hello "" + join(getNames());
	}

	private String join(String[] strings) {
		StringBuilder sb = new StringBuilder();
		String delim = """";
		for(String string : strings) {
			sb.append(delim).append(string);
			delim = "", "";
		}
		return sb.toString();
	}

	public static void main(String[] args) {
		HelloWorld helloWorld = new HelloWorld();
		helloWorld.setNames(""Morten"", ""Riccardo"", ""Anders"");
		System.out.println(helloWorld.toString());
	}
}
{code}

produces the same output when compiled in Java or in Groovy 1.8.8 (the names joined with commas), but in Groovy 2.0.5 it produces: Hello [Ljava.lang.String;@4e5a67df

Found while trying to demonstrate how to simplify Java code in Groovy (not very cool...) :-)",Mac,blackdrag,melix,sbglasius,weitzj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/Dec/12 15:29;weitzj;GROOVY-5812-test.groovy;https://issues.apache.org/jira/secure/attachment/12722377/GROOVY-5812-test.groovy","23/Dec/12 09:30;weitzj;StringArrayAccess.groovy;https://issues.apache.org/jira/secure/attachment/12723116/StringArrayAccess.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 07 08:34:10 UTC 2013,,,,,,,,,,"0|i2cgcv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Nov/12 14:29;melix;Woot, this is totally wrong! As a workaround, you can annotate {{toString}} like this:
{code}
@groovy.transform.CompileStatic
public String toString() {
    return ""Hello "" + join(getNames());
}
{code}

There is apparently something wrapping the array into a single element in dynamic groovy...;;;","21/Nov/12 01:45;sbglasius;I just tried something else, and this code works:

{code}
public String toString() {
   def n = getNames();
   return ""Hello "" + join(n);  
}
{code}

Looking stranger by the minute...;;;","23/Dec/12 09:29;weitzj;Hi Cedric, Hi Søren,

I broke the problem down to specifying the params type information. If the type is given, e.g. String[], the wrapping occurs.
If no type is given, the type will be ""Object"" => no wrapping occurs and everything works as expected.

@Søren: if you change the method signature of join to:
{code}
private String join(String[] strings) ==> private String join(strings)
{code}
everything should work as expected.

This is the reason, why Søren's solution using def n = getNames() works, since it will be of type Object.

See the attached file as a test case with three assertions. The first one works (using no type information), whilst the other two will fail. (Tested on Groovy 2.0.6, Mac OSX 10.8.2)

{code}
public class StringArrayAccess {   
    private String[] getStringArrayDirectly() { return [""string_00"", ""string_01""] }
    
    private String[] getStringArrayIndirectlyWithType(String[] stringarray) {
        return stringarray
    }
    
    private String[] getStringArrayIndirectlyWithoutType(stringarray) {
        return stringarray
    }
        
    public int getStringArrayDirectly_Length() {
        return getStringArrayDirectly().length
    }
              
    public int getStringArrayIndirectlyWithType_Length() {
        return getStringArrayIndirectlyWithType(getStringArrayDirectly()).length
    }
    
    public int getStringArrayIndirectlyWithoutType_Length() {
        return getStringArrayIndirectlyWithoutType(getStringArrayDirectly()).length
    }

    public static void main(String[] args) {
        StringArrayAccess stringArrayAccess = new StringArrayAccess()
        
        //working
        assert stringArrayAccess.getStringArrayDirectly_Length() == stringArrayAccess.getStringArrayIndirectlyWithoutType_Length()
        
        //not working if specifying the type: String[]
        assert stringArrayAccess.getStringArrayDirectly_Length() == stringArrayAccess.getStringArrayIndirectlyWithType_Length()
        assert stringArrayAccess.getStringArrayIndirectlyWithType_Length() == stringArrayAccess.getStringArrayIndirectlyWithoutType_Length()
    }
}
{code};;;","23/Dec/12 09:30;weitzj;StringArrayAccess.groovy: Failing assertions, if type information are given for dynamic groovy for String[] array.;;;","23/Dec/12 09:33;weitzj;A more dense version of the test-code:

{code}

public class StringArrayAccess {   
    private String[] getStringArrayDirectly() { [""string_00"", ""string_01""] }   
    private String[] getStringArrayIndirectlyWithType(String[] stringarray) { stringarray }    
    private String[] getStringArrayIndirectlyWithoutType(stringarray) { stringarray }
        
    public int getStringArrayDirectly_Length() { getStringArrayDirectly().length }            
    public int getStringArrayIndirectlyWithType_Length() { getStringArrayIndirectlyWithType(getStringArrayDirectly()).length }
    public int getStringArrayIndirectlyWithoutType_Length() { getStringArrayIndirectlyWithoutType(getStringArrayDirectly()).length }

    public static void main(String[] args) {
        StringArrayAccess stringArrayAccess = new StringArrayAccess()
        
        //working
        assert stringArrayAccess.getStringArrayDirectly_Length() == stringArrayAccess.getStringArrayIndirectlyWithoutType_Length()
        
        //not working if specifying the type: String[]
        assert stringArrayAccess.getStringArrayDirectly_Length() == stringArrayAccess.getStringArrayIndirectlyWithType_Length()
        assert stringArrayAccess.getStringArrayIndirectlyWithType_Length() == stringArrayAccess.getStringArrayIndirectlyWithoutType_Length()
    }
}
{code};;;","23/Dec/12 09:34;weitzj;Important for this bug to occur is the indirect access to the StringArray in order the specify the type of the params. Therefore the dumb *_Length methods were added.

Also this bug will only occur, if an instance method will call another instance method. If the indirect call is made from the static main method, this bug will not happen.;;;","23/Dec/12 15:29;weitzj;GROOVY-5812-test.groovy 
Contains more tests. Show failing test for instance method calling other instance method directly.;;;","23/Dec/12 15:38;weitzj;See the attached file: GROOVY-5812-test.groovy
It looks like this only happens, when:
 - A method of an instance of a Class (here: 'stringArrayAccess') calls another method on the same instance
AND
 - The method, which gets called, contains type-Information in it's params, e.g. String[]
AND
 - The method has to be called explicitly, e.g. getStringArrayDirectly()

It does not happen if:
 - The instance methods get called from static scope
OR
 - The method gets called implicitly via Groovy's Magic Getters, e.g. instance.getStringArrayDirectly() == instance.stringArrayDirectly
OR 
 - The method, which gets called does not contain type information in it's definition

See the attached file: GROOVY-5812-test.groovy

So, I do not know, how to debug this, since this seems to be some AST Transforming stuff, I think, and I do not know how to hook up my IntelliJ debugger to the lexer/parser.

Greetings,

Jan;;;","25/Dec/12 15:09;blackdrag;The analysis from you guys tells me strongly, that this bug is related to direct methods calls in the primopts part of the code. direct method calls are done if the types are known enough and certain conditions are met. One such condition is for example that the method is in the same class and also all types should be ""final"". I guess for String[] this is the case.;;;","07/Jan/13 08:34;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
InvokerInvocationException not being unwrapped,GROOVY-5811,12816563,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,musketyr,musketyr,20/Nov/12 12:39,22/Dec/12 01:10,14/Jul/23 06:00,27/Nov/12 08:57,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.0-beta-1,,,Static compilation,,,,0,breaking,,,,,"When methods compiled static are mixed with methods not compiled static and calling the closure, InvokerInvocationException is not unwrapped. Code depending on original Exception won't work.


See attached Groovy class.

If compiled with 2.0.5, following output should be printed

First: WRONG
Second: WRONG

If all static compilations are disabled, everything is ok

First: OK
Second: OK",Ubuntu 10.04 x64,melix,musketyr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Nov/12 12:39;musketyr;GaelykTemplateServlet.groovy;https://issues.apache.org/jira/secure/attachment/12723006/GaelykTemplateServlet.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 27 08:57:23 UTC 2012,,,,,,,,,,"0|i2cnlj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Nov/12 10:11;melix;Smaller code showing up the issue:
{code}
import groovy.transform.*

@InheritConstructors
public class MyException extends Exception {}

void foo() {
    throw new MyException()
}

@CompileStatic
void bar() {
    boolean caught = false
    try {
        def cl = { foo() }
        cl()
    } catch (MyException e) {
        caught = true
    } finally {  
        assert caught
    }
}

bar()
{code};;;","27/Nov/12 08:57;melix;The issue will only be fixed in {{2.1.0}} because it involves a change in {{Closure#call}} which may break potential code from people using {{Closure#call}} in Java and catching {{InvokerInvocationException}} by themselves.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Calling static method from subclass using super creates StackOverFlow,GROOVY-5810,12816595,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,oliver_plow,oliver_plow,20/Nov/12 09:51,22/Dec/12 01:10,14/Jul/23 06:00,30/Nov/12 06:37,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Compiler,,,,0,,,,,,"Don't know whether calling super from a static method is supposed to compile. But it does in IDEA IC-122.519 EAP using Groovy 2.0.5 and runs into an endless loop.
{code}
@CompileStatic
class A {
    public static foo() {
        print(""A"")
    }
}

@CompileStatic
class B extends A {
    public static foo() {
        A.foo() // compiles and prints ""AB""
        super.foo() // compiles and creates StackOverFlow
        print(""B"")
    }

    def static main(args)
    {
        B.foo()
    }
}
{code}",IDEA IC-122.519 EAP using Groovy 2.0.5,melix,oliver_plow,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3645,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 30 02:53:07 UTC 2012,,,,,,,,,,"0|i2br9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Nov/12 17:05;oliver_plow;At home with IntelliJ IDEA CE 122.694 EAP it does not compile. Not with Groovy 2.0.5 nor with 1.8.8. Sorry for any trouble caused if in the end it is caused by IDEA IC-122.519 EAP. The versions of IDEA 12 EAP can be downloaded from here: http://confluence.jetbrains.com/display/IDEADEV/IDEA+12+EAP;;;","30/Nov/12 02:53;melix;As as sidenote, this problem is not specific to {{@CompileStatic}}. Dynamic Groovy has the very same problem.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
.groovy files on the classpath don't work if the absolute path contains non-latin characters,GROOVY-5809,12816627,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,jimfcarroll,jimfcarroll,20/Nov/12 08:28,22/Dec/12 01:10,14/Jul/23 06:00,05/Dec/12 08:10,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,,command line processing,,,,0,,,,,,"If you have a .groovy file on the classpath when running a groovy script, imports of the classpath located file from the main script (or other places) only work when the absolute path to the .groovy file being imported doesn't contain non-latin characters.

It doesn't seem to make any difference whether or not the file to be imported is in the default package (top level) or not.

This problem is easy to reproduce. Attached is zip file with a groovy script and a single dependency in a subdirectory called 'test+test'. If you unzip this and cd to the subdirectory and run:

groovy -cp . Script.groovy

... it will fail. If you cd up a level and change the name of the directory from 'test+test' to 'test' then cd back into test and re-run it, it will work.",Verified on Windows and Linux,blackdrag,jimfcarroll,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Nov/12 08:28;jimfcarroll;test.zip;https://issues.apache.org/jira/secure/attachment/12722176/test.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 05 08:10:00 UTC 2012,,,,,,,,,,"0|i2c6on:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Nov/12 08:34;jimfcarroll;We are currently hitting this bug in the open-source media center software, XBMC. There have been several public bug reports entered in our own trac system. If you're interested, here is the latest:

trac.xbmc.org/ticket/13571
;;;","05/Dec/12 06:30;blackdrag;I changed the component to ""command line processing"", since this has nothing to do with GroovyScriptEngine. ;;;","05/Dec/12 06:35;jimfcarroll;My apologies. I thought the scripting engine used the classpath explicitly to find scripts to execute from the command line. Thank you.;;;","05/Dec/12 08:10;blackdrag;ok, I found that code we added due to GROOVY-1787 is causing this problem. The idea back then was to use URLDecoder to get the file name in the right format, but a plus in a URL is actually a placeholder for space, thus ""test+test"" became ""test test"". And since that does not exist it didn't return the found script (it did indeed find Dep.groovy). So I changed this to use URIs if possible which also does decoding and this seems to work.

I assume it is fixed now. It would be good though if it could be tested before the next release;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy 2.0.5 breaks GMock when EMC is used,GROOVY-5806,12816616,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,graemerocher,graemerocher,19/Nov/12 07:49,22/Dec/12 01:10,14/Jul/23 06:00,21/Nov/12 02:24,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,,,,,0,,,,,,"Exception is 

{code}
groovy.lang.MissingMethodException: No signature of method: org.gmock.internal.metaclass.MockProxyMetaClass$4.doCall() 
{code}

See related Grails issue

http://jira.grails.org/browse/GRAILS-9550

Sample non-Grails gradle project:

http://jira.grails.org/secure/attachment/17963/withGMock-non-grails.zip",,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 21 02:24:31 UTC 2012,,,,,,,,,,"0|i2bzgf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Nov/12 02:24;melix;I could reproduce outside of GMock. It was a call site caching bug introduced by  GROOVY-5730.

Test case:
{code}
class Groovy5806Bug extends GroovyTestCase {

    void doWork(code) {
        code.call();
    }

    void testCallSiteCachingOfCallMethod() {
        try {
            ExpandoMetaClass.enableGlobally()
            10.times {
                doWork {
                    println 'ok'
                }
            }
            doWork(new Callable() {
                def call() {
                    println 'callable'
                }
            })
        } finally {
            ExpandoMetaClass.disableGlobally()
        }

    }
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError when @CompileStatic and negate boolean with !,GROOVY-5804,12818447,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mboillod,mboillod,18/Nov/12 12:55,22/Dec/12 01:10,14/Jul/23 06:00,30/Nov/12 07:36,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"In a CompileStatic block, when a boolean is negated with ! expression, I have the following error at runtime: 

Error:
{code}
java.lang.VerifyError: 
(class: fr/manu/impl/MaClass$_retournerItems_closure2, method: doCall signature: (Ljava/lang/Object;)Ljava/lang/Object;) 
Expecting to find integer on stack
{code}


Groovy code:
{code:title=Class.groovy}
boolean b = true
if (!b) {
...
}
{code}",,boillodmanuel,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Nov/12 03:32;Groovy5804.groovy;https://issues.apache.org/jira/secure/attachment/12722930/Groovy5804.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 30 03:32:09 UTC 2012,,,,,,,,,,"0|i2c5wf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Nov/12 11:03;melix;Do you have a complete example? I can't reproduce with the snippet you've posted. Thanks!;;;","30/Nov/12 03:32;mboillod;Test case;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"wasted work in ""ClassNode.addMixin""",GROOVY-5803,12816633,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,adriannistor,adriannistor,16/Nov/12 14:42,05/Apr/15 14:44,14/Jul/23 06:00,17/Nov/12 18:09,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,2.1.0-beta-1,,,,,0,,,,,,"The problem appears in Groovy 2.0.5 and in revision 9c9cd23..  I
attached a one-line patch (addMixin.diff) that fixes it.

In method ""ClassNode.addMixin"", the loop over ""mixins"" should call
""break"" immediately after ""skip"" is set to ""true"".  All the iterations
after ""skip"" is set to ""true"" do not perform any useful work, at best
they just set ""skip"" again to ""true"".

""ClassNode.addInterface"" has a similar problem.  I attached a second
patch for it (addInterface.diff).",,adriannistor1,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Nov/12 14:42;addInterface.diff;https://issues.apache.org/jira/secure/attachment/12722927/addInterface.diff","16/Nov/12 14:42;addMixin.diff;https://issues.apache.org/jira/secure/attachment/12723036/addMixin.diff",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Sat Nov 17 18:09:50 UTC 2012,,,,,,,,,,"0|i2cg67:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Nov/12 18:09;paulk;added - thanks for spotting this inefficiency;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Exception thrown in groovyConsole,GROOVY-5802,12816626,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,werdna,werdna,16/Nov/12 11:23,10/Jul/13 04:42,14/Jul/23 06:00,12/Mar/13 19:22,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,Groovy Console,,,,0,,,,,,"Add the following snippet to an empty groovyConsole using Groovy 2.0.4:

{code}
package pkg1

import groovy.transform.TypeChecked


class ExtendedList extends ArrayList<String>{    
}

class SourceClass {
    @TypeChecked public static ExtendedList createList() { 
        return null; 
    }
}
{code}

Compile and then you get the following exception:

{code}
Exception thrown
Nov 16, 2012 9:21:19 AM org.codehaus.groovy.runtime.StackTraceUtils sanitize
WARNING: Sanitizing stacktrace:
java.lang.IllegalArgumentException: argument type mismatch
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:2402)
	at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:3330)
	at org.codehaus.groovy.runtime.InvokerHelper.setProperties(InvokerHelper.java:463)
	at org.codehaus.groovy.runtime.InvokerHelper.createScript(InvokerHelper.java:440)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:625)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:652)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:643)
	at groovy.lang.GroovyShell$parse.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at groovy.ui.Console$_compileScript_closure18.doCall(Console.groovy:997)
	at groovy.ui.Console$_compileScript_closure18.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at groovy.lang.Closure.call(Closure.java:415)
	at groovy.lang.Closure.call(Closure.java:409)
	at groovy.lang.Closure.run(Closure.java:493)
	at java.lang.Thread.run(Thread.java:680)

java.lang.IllegalArgumentException: argument type mismatch
{code}",,jwagenleitner,melix,paulk,pschumacher,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 12 19:22:18 UTC 2013,,,,,,,,,,"0|i2c60v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Nov/12 11:27;werdna;Originally found while exploring GRECLIPSE-1551.;;;","16/Nov/12 11:37;melix;I'm puzzled. {{@TypeChecked}} is normally side-effect free and I cannot reproduce, neither with {{2.0.4}} nor {{master}}. Do you run the console using Eclipse?
;;;","16/Nov/12 11:55;werdna;No.  Not related to Eclipse.  It is run from the command line using a 2.0.4 distribution.  I am actually able to reproduce the exception using just this snippet:

{code}
class ExtendedList extends ArrayList<String>{    
}
{code}

But oddly, when I use this code:

{code}
class Other {}
class ExtendedList extends ArrayList {    
}
{code}
I get no exception.  What kind of information do you need from me?;;;","16/Nov/12 11:58;melix;Weird. This could be a JDK version issue. What JDK are you using?;;;","16/Nov/12 11:59;werdna;{quote}
$ java -version
java version ""1.6.0_37""
Java(TM) SE Runtime Environment (build 1.6.0_37-b06-434-11M3909)
Java HotSpot(TM) 64-Bit Server VM (build 20.12-b01-434, mixed mode)
{quote};;;","16/Nov/12 12:50;melix;Alright, I cannot reproduce even using the same JDK...;;;","16/Nov/12 13:06;werdna;Very odd.  Are you on linux?  Maybe it is a macos thing.;;;","16/Nov/12 13:08;melix;Yes I'm on Linux. Maybe Guillaume could give it a try...;;;","17/Nov/12 01:05;paulk;I couldn't replicate on Windows for master or 2.0.4.
{noformat}
Microsoft Windows [Version 6.1.7601]
java version ""1.7.0_10""
Java(TM) SE Runtime Environment (build 1.7.0_10-b18)
Java HotSpot(TM) 64-Bit Server VM (build 23.6-b04, mixed mode)
{noformat};;;","02/Jan/13 08:07;pschumacher;I can replicate this on Windows XP SP3 using Groovy 2.0.6 and JDK:

{code}
java version ""1.7.0_09""
Java(TM) SE Runtime Environment (build 1.7.0_09-b05)
Java HotSpot(TM) Client VM (build 23.5-b02, mixed mode, sharing)
{code};;;","09/Jan/13 11:41;melix;Pascal, can you reproduce with master or 2.0.x ?;;;","09/Jan/13 14:23;pschumacher;I can reproduce with master. I haven't tried with 2.0.x yet.;;;","09/Jan/13 14:26;melix;Thanks. This one is a bit puzzling!;;;","07/Feb/13 13:38;jwagenleitner;Seems like the problem occurs anytime the first statement in the Groovy Console is a class that extends from some List implementation.

For example, the following will cause the exception if you paste into Groovy Console and then select ""Script > Compile"" (or Ctrl+L), at least for me on Groovy 2.1.0 and JDK 1.7 or 1.6:

{code}
class Foo extends ArrayList { }
{code}

{code}
class Foo extends ArrayList { }
class Bar { }
{code}

But does not occur in the following cases:

{code}
class Foo extends ArrayList { }
f = new Foo()
{code}

{code}
class Bar { }
class Foo extends ArrayList { }
{code}

{code}
class Foo extends HashMap { }
{code};;;","07/Feb/13 18:34;paulk;It fails trying to set ""_outputTransforms"". I still have to investigate but I presume the metaclass for list is a little special and is doing unexpected things.;;;","07/Feb/13 19:15;paulk;Hmmm... setting the properties on the script instead of the wrapped class makes the problem go away and the build passes but I haven't analysed if it has any further impact:
{code}
Index: src/main/org/codehaus/groovy/runtime/InvokerHelper.java
===================================================================
--- src/main/org/codehaus/groovy/runtime/InvokerHelper.java	(revision 3e1261ccfdbb7c1253d8d2d6598a839c86d8cc48)
+++ src/main/org/codehaus/groovy/runtime/InvokerHelper.java	(revision )
@@ -436,7 +436,7 @@
                             return null;
                         }
                     };
-                    setProperties(object, context.getVariables());
+                    setProperties(script, context.getVariables());
                 }
             } catch (Exception e) {
                 throw new GroovyRuntimeException(
{code};;;","14/Feb/13 19:45;paulk;I have a pull request here:
https://github.com/groovy/groovy-core/pull/140

It makes two changes:
# for the case of scripts consisting of a single class we wrap the class into a script and call setProperties which allows the class to be populated with values from the binding - I have made variables beginning with underscore now be set on the script not the wrapped object - we use ""__"", ""___"" and ""_outputTransforms"" as special variables in the context of a script
# when trying to set properties into a list, we get an IllegalArgumentException for the case of a missing property having the value of a list when the class we are dealing with is itself a list - now that case is treated the same as other missing properties and ignored;;;","12/Mar/13 19:22;paulk;I have applied pull request #140 - just to master so far as there is a very minute chance of backwards compatibility issues for anyone relying on the current bug in InvokerHelper. If this is important for 2_1_X or earlier versions let me know.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,
sql.firstRow() fetches all rows of query,GROOVY-5801,12816599,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,samp,samp,16/Nov/12 08:57,15/Oct/15 18:16,14/Jul/23 06:00,18/Sep/13 11:41,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,SQL processing,,,,1,,,,,,"We were trying to use ""sql.firstRow(...)"" but had to switch to the other sql calls because firstRow is so efficient. Looking at the code (https://github.com/groovy/groovy-core/blob/master/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java#L2109) implies it could be quickly improved:

current code:
{code}
public GroovyRowResult firstRow(String sql) throws SQLException {
    List<GroovyRowResult> rows = rows(sql);
    if (rows.isEmpty()) return null;
    return (rows.get(0));
}
{code}

suggested code:
{code}
public GroovyRowResult firstRow(String sql) throws SQLException {
    List<GroovyRowResult> rows = rows(sql, 1, 1, null);
    if (rows.isEmpty()) return null;
    return (rows.get(0));
}
{code}

This would avoid first loading all of the rows into memory, just to grab the first one and throw the rest away. For large tables, this causes us to run out of memory.",,chris.tierney,jwagenleitner,paulk,pschumacher,samp,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6353,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 11 02:59:29 UTC 2013,,,,,,,,,,"0|i2c0hz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Nov/12 10:27;samp;Oops... I meant ""firstRow is so inefficient"" ...;;;","17/Nov/12 01:24;paulk;The main reason this hasn't been done previously was that several of the older database drivers we tested with in the past threw a {{SQLFeatureNotSupportedException}} when {{ResultSet#absolute(int)}} was called, so we favored the conservative approach which will work for those drivers although it is slower. I guess we should test this again and see what the current situation is. At the moment the burden is on you to use rows(sql, 1, 1, null) to make things faster but if enough of the drivers are working correctly now, then we could put that burden on the old driver users.;;;","19/Nov/12 08:04;samp;Cool. Thanks. If some drivers still don't support this, maybe something like this would work:

{code}
public GroovyRowResult firstRow(String sql) throws SQLException {
    List<GroovyRowResult> rows = null;
    try {
        rows = rows(sql, 1, 1, null);
    } catch (SQLFeatureNotSupportedException e) {
        rows = rows(sql);
    }
    if (rows.isEmpty()) return null;
    return (rows.get(0));
}
{code};;;","07/Feb/13 13:26;jwagenleitner;+1 for adding a try/catch block and making the method faster for those with drivers that support it while letting those with drivers that don't pay a slight performance penalty with the generated exception.;;;","10/Feb/13 07:42;pschumacher;I agree and therefore created a [pull request|https://github.com/groovy/groovy-core/pull/137] out of Sams suggestion.;;;","11/Feb/13 02:59;pschumacher;Merged the pull request. Thanks to everybody who contributed to solving this issue. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Can't get 'in' to work under static compilation,GROOVY-5800,12816606,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,16/Nov/12 08:28,22/Dec/12 01:10,14/Jul/23 06:00,21/Nov/12 10:58,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"Given:

{code}
@groovy.transform.CompileStatic
boolean m( Integer i ) {
  i in [ 1, 2, 3 ]
}

println m( 1 )
{code}

We get {{false}}.

Comment out the annotation, or change it to:

{code}
@groovy.transform.CompileStatic
boolean m( Integer i ) {
  [ 1, 2, 3 ].contains( i )
}
{code}

And we get true again.",,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-11-16 08:28:16.0,,,,,,,,,,"0|i2c2sv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compile static forces 'as' when trying to make array of nulls,GROOVY-5799,12816663,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,16/Nov/12 07:45,22/Dec/12 01:10,14/Jul/23 06:00,22/Nov/12 01:39,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"The following:

{code}
@groovy.transform.CompileStatic
Integer[] m() {
  Integer[] arr = [ null, null ]
}

println m()
{code}

Throws:

{code}
[Static type checking] - Cannot assign value of type java.lang.Object into array of type [Ljava.lang.Integer;
{code}

To get it to work, either remove CompileStatic, or change the function to:

{code}
@groovy.transform.CompileStatic
Integer[] m() {
  Integer[] arr = [ null, null ] as Integer[]
}

println m()
{code}",,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-11-16 07:45:00.0,,,,,,,,,,"0|i2bnef:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic cannot cast int to char,GROOVY-5798,12816625,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,16/Nov/12 07:32,22/Dec/12 01:10,14/Jul/23 06:00,20/Nov/12 03:29,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"{code}
@groovy.transform.CompileStatic
char m( int v ) {
  char c = (char)v
  c
}

println m( 65 )
{code}

Gives:

{code}
[Static type checking] - Inconvertible types: cannot cast int to char
{code}

Removing CompileStatic or just doing:

{code}
@groovy.transform.CompileStatic
char m( int v ) {
  v
}

println m( 65 )
{code}

Works",,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5843,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-11-16 07:32:26.0,,,,,,,,,,"0|i2c9lb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic BUG with indexing map of maps,GROOVY-5797,12816629,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,16/Nov/12 07:25,22/Dec/12 01:10,14/Jul/23 06:00,20/Nov/12 07:24,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"The following code:

{code}
@groovy.transform.CompileStatic
def m( Map param ) {
  def map = [ tim:4 ]
  map[ param.key ]
}

m( [ key: 'tim' ] )
{code}

Throws

{code}
BUG! exception in phase 'class generation' in source unit 'ConsoleScript38' At line 4 column 3
On receiver: map with message: getAt and arguments: param.key
{code}
",,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-11-16 07:25:49.0,,,,,,,,,,"0|i2boxb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compilation error with method receiving a java.lang.Byte,GROOVY-5793,12816617,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,rcruzjo,rcruzjo,15/Nov/12 11:40,22/Dec/12 01:10,14/Jul/23 06:00,22/Nov/12 01:21,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,4,,,,,,"With Static Compilation enabled, if I try to call a method declared in a class that receives a parameter of type java.lang.Byte, the compilation fails, returning ""[Static type checking] - Cannot find matching method"".
The same problem occurs when calling a method from inside another method, for instance:

{code:title=Test.gvy|borderStyle=solid}

@groovy.transform.CompileStatic
void testMethod(java.lang.Byte param){
println(param)
}

@groovy.transform.CompileStatic
void run (){
testMethod(java.lang.Byte.valueOf(""123""))
}

run()

{code}

The problem seems to be in the ""isAssignableTo"" method from ""org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.java"" class, where ClassHelper.Byte_TYPE doesn't match the type received as an argument, probably because you are not using the redirect() method before comparing with the type that matters.",,ariel.andres.morelli,ebergama,melix,rcruzjo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"15/Nov/12 11:40;rcruzjo;Test.gvy;https://issues.apache.org/jira/secure/attachment/12722376/Test.gvy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 22 01:21:08 UTC 2012,,,,,,,,,,"0|i2co0v:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Nov/12 01:21;melix;This was the problem, you were correct, thank you!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
XmlNodePrinter uses quote variables for more than just attributes,GROOVY-5792,12816588,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,quidryan,quidryan,13/Nov/12 19:43,22/Dec/12 01:10,14/Jul/23 06:00,16/Nov/12 23:51,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,XML Processing,,,,0,,,,,,XmlNodePrinter.printEscaped is not checking isAttributeValue when deciding to use the quote variable for single quotes and double quotes. This means than in the body of an XML element it'll avoid quoting single or double quote if the quote variable is respectively a single or double quote. The quote variable should ONLY apply to attributes. This is causing the output to not be quoted when it should be.,,paulk,quidryan,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 16 23:51:13 UTC 2012,,,,,,,,,,"0|i2c48v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Nov/12 05:37;paulk;You are correct that the code should be checking {{isAttributeValue}} but since quotes don't need to escaped would you regard it is a weird but benign quirk of the created content? I am not saying we won't fix it but just saying that the fix might be to not quote at all for element text?;;;","14/Nov/12 12:44;quidryan;Excellent point, I got caught up with the output not matching what I thought, but you're right that it's reasonable to not escape a quote in the body.;;;","16/Nov/12 23:51;paulk;Fixed by skipping escaping for apostrophes and quotes in element text. Thanks for spotting the anomaly.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Increment operators with @CompileStatic,GROOVY-5791,12816586,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,vns,vns,13/Nov/12 02:24,22/Dec/12 01:10,14/Jul/23 06:00,21/Nov/12 09:11,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,,,,,0,,,,,,"Assume we have the script:
{code}
import groovy.transform.CompileStatic
import groovy.transform.TypeChecked

@CompileStatic
//@TypeChecked
int incInt(int n) {
    def result = n
    ++result
    result++
    return result
}
assert  incInt(5) == 7,""Must be 7 but we have 5""
{code}

Increment operations not execute when @CompileStatic and a local variable is not explicitly typed.  ",Windows 7 64bit,vns,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"13/Nov/12 02:24;vns;MyGroovyScript.groovy;https://issues.apache.org/jira/secure/attachment/12723080/MyGroovyScript.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-11-13 02:24:39.0,,,,,,,,,,"0|i2c9mn:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic changes scope of for loop variable,GROOVY-5789,12816600,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,russel,russel,10/Nov/12 09:52,22/Dec/12 01:10,14/Jul/23 06:00,21/Nov/12 09:11,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Compiler,,,,0,,,,,,"The script:

{code}
def execute() {
    for (def i = 0; i < 4; ++i) { println i }
}

execute()
{code}

works exactly as expected. However:

{code}
import groovy.transform.CompileStatic

@CompileStatic execute() {
    for (def i = 0; i < 4; ++i) { println i }
}

execute()
{code}

creates an infinite loop in which the value of i is always 0.","Debian Unstable, Groovy master/HEAD",russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-11-10 09:52:52.0,,,,,,,,,,"0|i2cjjb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Indexing map with wrong type inside closure fails with @CompileStatic,GROOVY-5787,12811969,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,ataylor284,ataylor284,07/Nov/12 22:27,22/Dec/12 01:10,14/Jul/23 06:00,21/Nov/12 01:58,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"When a map typed with Java-style generics is indexed with the wrong type inside of a closure, it fails with {{@CompileStatic}}.  The following error is generated:

{noformat}
On receiver: someMap with message: getAt and arguments: 1
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY
BUG! exception in phase 'class generation' in source unit '/home/ataylor/dev/test/bug.groovy' At line 6 column 28
On receiver: someMap with message: getAt and arguments: 1
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY
{noformat}

Here's a minimal example that triggers the bug:

{code}
@groovy.transform.CompileStatic
class Bug {
    static void main(args) {
        Map<String, Integer> someMap = ['one': 1]
        def closure = { -> someMap[1] }
    }
}
{code}
","Groovy 2.0.5, Java 1.7.0_09 (OpenJDK 64-Bit Server VM on Linux).",ataylor284,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-11-07 22:27:41.0,,,,,,,,,,"0|i2c447:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
methods defined by one eval are 'lost' over time,GROOVY-5786,12816619,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,danno,danno,07/Nov/12 10:40,28/Dec/12 15:25,14/Jul/23 06:00,17/Dec/12 08:56,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,,GroovyScriptEngine,,,,1,,,,,,"Don't suppose it's possible that a bug has been inadvertently introduced by the fix provided in GROOVY-5187 (which GC's script classes)?

Have a scenario where an eval is done, creating some classes (basically akin to including code from a separate script).  A second eval is done which depends on classes created in the first (same execution engine, obviously).  A bunch of work is done in this second eval, using lots of memory, undoubtedly invoking GC.  At a later point a method that was supposedly created by the first eval is called and is not found:

MissingMethodException: No signature of method: org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.getTRTimedParm()

Note that it isn't even trying to associate it with a script class as it should, but with the engine itself.

We were previously at version 2.0.1 which did not seem to have this problem, but I can't say for certain without going back to that version and trying this particular test case.

We are working around the problem by re-evaling the first script right before the use of the 'missing' method, which is obviously not ideal.

Is there a way to tell the engine to GC on demand?

Thanks!",64 bit IBM java 1.6 jre on AIX,blackdrag,danno,guillaume,markyo,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 28 15:25:09 UTC 2012,,,,,,,,,,"0|i2cnw7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Nov/12 05:37;danno;Some additional info.  

If I intentionally mess up the signature of the method on first invocation the error is:

MissingMethodException: No signature of method: Script5.getTRTimedParm() is applicable for argument types: (java.lang.String, java.lang.String) values: [abc, q]
Possible solutions: getTRTimedParm(java.util.Map)

'Proving' that the method did get appropriately assigned to a script class when first evaluated.

And we have confirmed that the problem does not exist in 2.0.1.;;;","08/Nov/12 07:26;blackdrag;You are right, GROOVY-5187 and this issue are conflicting. If I go and make every method available, then the class behind that won't be collected. The whole trouble with jsr223 is, that it does not provide you with means to configure the script engine. One case suitable for one person is evil for another. So if I am going to keep the functions, I am going to keep the classes, I am going to keep the classloader that defines the class, and all classes that have been compiled along with the class the method originates from. And even if I use only stubs to have the method still there as such, but not filled, I would get a problem with your use case. We could think of using a LRU list, maybe leading to a memory problem or maybe not. If we do, we have to define a number for this. I mean I already use SoftReferences, so it is not like they are collected without need of memory.

Any suggestions?;;;","10/Dec/12 17:29;markyo;Any status update on this one? I have built a framework around the feature of loaded methods sticking around, and I too had to roll back to v2.0.1 after (painfully) discovering that the cause of my problems was that described in this jira. Until this is addressed, I'm stuck on v2.0.1 indefinitely...which isn't a happy situation.

As for suggestions, could we possibly pass a special flag or option into the global context?;;;","11/Dec/12 02:01;blackdrag;I asked for suggestions and got none so far, so there has been no progress. If you tell me how to pass a special flag or option into the global context, then I will do that.;;;","11/Dec/12 10:11;markyo;I appreciate the quick response. Well, I was thinking along the lines of setting a global attribute with an agreed-on special meaning, like:

groovyEngine.getContext().setAttribute(theFlagName, theFlagValue, ScriptContext.GLOBAL_SCOPE);

Or perhaps we just set it at the script manager level like so:

ScriptEngineManager manager = new ScriptEngineManager();
		
manager.put(theFlagName, theFlagValue);

So if the engine sees this special flag, it will read the value and configure accordingly. Would something like that not work?

Maybe another way would be to pass in a groovy script to be evaluated--like any other script--except that it would be a special configuration script with options/flags like this one (but can accommodate other configuration options as well). We'd just have to figure out (agree on) a way to differentiate this ""meta"" script from other application-specific scripts.

I don't have a deep enough knowledge of the jsr spec and the internals of the implementation, so please, you tell me if what I'm suggesting is even workable.;;;","11/Dec/12 10:25;danno;Blackdrag, Sorry for the lack of suggestions.  I'm in the same camp as Mark, not knowing what the spec allows.  The 'obvious' to me is that:

1) The behavior in 2.0.1 and prior was X
2) The behavior after that is Y
3) Therefore you have control over the behavior
4) So add a method to GroovyScriptEngineImpl that lets the user pick

Perhaps something like setCollectionStrategy, which at present might have two options - NONE for the old behavior, and EAGER for the current behavior.

Regards,
Dan;;;","11/Dec/12 10:32;markyo;Agreed with Dan, if the jsr 223 interface doesn't allow for such configurability, and what I'm suggesting is not workable or desirable, then we should be able to at least configure the implementation (e.g., special property on GroovyScriptEngineImpl) to get us back to the desired behavior. It's not ideal, but still way better than being stuck on v2.0.1 indefinitely.;;;","11/Dec/12 10:36;danno;Mark,

Our problem with this only manifested itself on methods added to the base script via a secondary eval.  We have not seen it on any methods in the base script itself.  I.e. if there is only a single ScriptX class created it seems to be fine, but if there are additional classes created by other evals, it's those that go missing over time.

We have worked around it by creating our own references to those ScriptX objects, thereby keeping them from being garbage collected.  This is done by returning 'this' as the last statement in the secondary script being eval'd, and then using that reference in calls to methods in that object.

For example,

secondary script {
...
String ABC(String thing) {
do stuff
}

return this
}

main script {
...
secondScript = eval(secondary script)
...
newThing = secondScript.ABC(oldThing)
...
}

There's a bit more to it in our implementation as the eval's are actually being done by calls from Java, but hopefully that gives you the idea.

Regards,
Dan;;;","11/Dec/12 14:07;blackdrag;If there were no conflict with GROOVY-5187 I would simply revert the change and resolve the issue. But since that issue is there I have conflicting goals to handle. That is my problem. The JSR223 of course doesn't make things more easy here. ScriptContext attributes or Bindings are imho not intended to be used like this, also not through ScriptManager. Anything you put in there becomes available by the script you run. Thus the intentions is imho to interact with the script, not to configure the engine. A method on GroovyScriptEngineImpl also won't do it in Java world. To actually call the method you would then need GroovyScriptEngineImpl, not javax.script.ScriptEngine. Having a meta like script is an interesting idea. The engine provides a ScriptContext, which we could extend to aid.


Anyway... that makes three paths:
(1) provide a method on GroovyScriptEngineImpl
Pro: simple to implement
Con: invisible to Java, since you will require a cast to GroovyScriptEngineImpl. And if you have to do that, why would you not use something else in Groovy instead?
(2) use an attribute
Pro: simple to implement, simple to use
Con: these are not to be used for configuration and there is a low danger of conflicts with values for scripts
(3) use a configuration script
Pro: is independent of that JSR
Con: requires more changes plus a special ""setup"" script

Right now I see 2 as a misuse of the JSR, but at the same time for the best bet. Imho the conflict potential is not zero, but should be fairly low. What do others think?;;;","11/Dec/12 14:38;markyo;I agree that option #2 may be our best bet. As for the possibility of conflicts, I think if we pass in a key that is not a legal identifier name, that would help reduce or eliminate that. For example, scriptManager.put(""#optionName"", ""optionValue""), or whatever prefix that would make the key an illegal identifier (I just chose '#' as an example). There may be other configuration options in addition to this one, and they can all be prefixed in the same, agreed upon way. What do you think?;;;","11/Dec/12 14:46;guillaume;The lack of configurability has always bugged me with that JSR :-(
I think option 2) is our best bet.
If we do use some very specific attribute names like ""groovy.jsr233.foo"" or with some special characters, we won't risk any conflicts.
I just hope that people don't really rely on the number of attributes present, or something like that.;;;","11/Dec/12 14:47;markyo;Dan, thank you for sharing your workaround. I don't think it'll work well in my case, since what I do is load a bunch of library (which contain the various utility methods--what you're calling the secondary scripts) and configuration scripts (contain configuration options) associated with some script context (not jsr223 context, but one defined in my own object model), and only then do I run my application script (what you're calling the base script). This is how my framework is designed, and so it heavily depends on being able to load such ""library"" scripts each time before running the actual application script.;;;","11/Dec/12 15:40;danno;I don't follow why option 1 is ""invisible to Java, ... why would you not use something else in Groovy instead?""

I agree if you don't know what kind of ScriptEngine was instantiated you're kind of out of luck (but even then you can determine what the real class is), but in our case we're doing this:

  protected ScriptEngine createScriptEngine() {
    ScriptEngine eng = scriptEngineManager.getEngineByName(""groovy"");
    GroovyScriptEngineImpl engine = (GroovyScriptEngineImpl)eng;
    engine.setClassLoader(createGroovyClassLoader());
    return engine;
  }

So we do, in fact, know with certainty what kind of ScriptEngine we have.

What is the ""something else"" we should be doing in Groovy instead?

That said, I have no particular preference for option 1 vs 2 (given some relatively obscure name of the attribute to avoid conflicts as has already been suggested).;;;","11/Dec/12 15:48;danno;Mark, Agreed that our solution is difficult to manage on a large number of application and library scripts (we use exactly that same method in what I called base and secondary as you surmised).  We were able to 'install' this change relatively easily because

a) All our application scripts are stored in a database, so simple matter of doing a query to find all of them that include use of a library script (our base library provides a specific syntax for loading library scripts), and in most cases just a straight sql REPLACE to cause the script to use the new syntax
b) We have less than 10 library scripts that needed to be modified to 'return this'
c) User's complain quickly and loudly when the script gets a missing method exception, so didn't take long to find places we missed in a).

Just FWIW...;;;","12/Dec/12 04:14;blackdrag;The something else I was thinking of is the other GroovyScriptEngine, or even GroovyShell. On the other hand you still depend on the API I guess and the other two don't make the methods visible like requested here. So maybe I am wrong and they are not really options after all.

Anyway... since most agree fully I guess we go with option 2;;;","12/Dec/12 06:23;markyo;Blackdrag and Guillaume, thank you so much for the quick response to our needs. Your work is greatly appreciated, and I have to say that the more I work with Groovy the more I fall in love with how empowering it is to the Java programmer. In just a few years even it has come a long way for sure, and being able to embed scripts within our Java programs is just amazing.

I've never been involved in an open source project, though I've been feeling the urge to contribute. I'm pretty good at generic programming and tend to write more frameworks and libraries at my jobs with applications layered on top. So if there's a need somewhere in the Groovy community please let me know how I may join up and contribute.;;;","17/Dec/12 08:45;blackdrag;Mark, if you want to contribute, just take anything you don't like, maybe tell us on the dev list and then have fun fixing. We are always happy to have people contribute.

Back to the issue.. I added a ""#jsr223.groovy.engine.keep.globals"" key that is queried for before an eval in the script context. http://groovy.codehaus.org/JSR+223+Scripting+with+Groovy explains what is supported. I decided the default should be hard references, since that is what has been there before. So the people having issues here will not have to change their code and it should just work. Though testing would be nice ;);;;","17/Dec/12 08:56;blackdrag;the issue should be resolved now, testing is appreciated;;;","28/Dec/12 15:25;markyo;That's great, thank you. I'm going to switch to 2.0.6 now and will let you know within a few days whether I encounter the issue again.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic - Calling vargarg parameter GString is converted to array of strings,GROOVY-5780,12816527,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,boaznahum,boaznahum,02/Nov/12 06:12,22/Dec/12 01:10,14/Jul/23 06:00,20/Nov/12 03:14,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Compiler,Static compilation,,,0,,,,,,"OOPS... It happens again, almost the same bug as  http://jira.codehaus.org/browse/GROOVY-5703
But now we call with GString instead of String

Assume we have this method:

{code}
static void printMsgs(String ... msgs) {
    for(String s : msgs) { println s;}
}
{code}

Calling it from @CompileStatic:
{code}
@CompileStatic
    static void testCS() {
        String n1=""hello""
        //Print:
        // H
        // e
        // l
        // l
        // o
        printMsgs(""${n1}"");
    }
{code}

The string 'hello' is converted to array of strings.

Calling it from non CompileStatic works fines.
Also if the passed parameter is String and not GString then it also works fine.

The complete test case:
{code}
import groovy.transform.CompileStatic

public class CompileStaticVarArg {

    static void main(String[] args) {

        println GroovySystem.version
        println '-' * 20

        test();

        println '-' * 20

        testCS()

    }


    static void test() {
        String n1=""hello""
        // Print 'hello'
        printMsgs(""${n1}"");
    }

    @CompileStatic
    static void testCS() {
        String n1=""hello""
        //Print:
        // H
        // e
        // l
        // l
        // o
        printMsgs(""${n1}"");
    }

    //@CompileStatic
    static void printMsgs(String... msgs) {

        for (String s : msgs) {
            println s;
        }

    }

}
{code}
","Windows 7, JDK 1.7.0_09 64 bits, Groovy 2.0.5 (windows installer)",boaznahum,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-11-02 06:12:24.0,,,,,,,,,,"0|i2cdk7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checking - Color.red recognized as int,GROOVY-5779,12811694,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,lvanek,lvanek,02/Nov/12 05:41,22/Dec/12 01:10,14/Jul/23 06:00,02/Nov/12 10:24,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,Static Type Checker,,,,0,Color,TypeChecked,,,,"Code:

import groovy.transform.TypeChecked;
import java.awt.Color;

class ColorTest
{
    @TypeChecked
    static main(args)
    {
        Color black = Color.black; // ok
        Color red = Color.red;       // Groovy:[Static type checking] - Cannot assign value of type int to variable of type java.awt.Color
    }
}

This occurs only with colors: 'red', 'blue' and 'green'. ","Groovy-Eclipse plugin Version: 2.7.2.xx-20121031-1500-e42
Groovy compiler level: 2.0 ",aalmiray,flyingbird,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 02 08:02:53 UTC 2012,,,,,,,,,,"0|i2bnnr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Nov/12 08:02;aalmiray;Further info: this is a problem of static scope vs instance scope. The type checker attempts to resolve getRed() as an static property, which of course shouldn't do. The Color class has lowercase and uppercase constants for some colors, such as red, green and blue (uppercase versions are recommended, lowercase versions are there for compatibility with Java 1.0 (yay backward compatibility and all the cruft it brings!)).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Accessing static property in closure of sub-class creates a ""serious error""",GROOVY-5776,12818197,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,werdna,werdna,31/Oct/12 11:29,08/Mar/22 12:16,14/Jul/23 06:00,02/Mar/21 23:55,2.0.4,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Compiler,,,,4,,,,,,"Discovered in GRECLIPSE-1492.  Compile the following snippet in Groovy 2.0.4:

{code}
class TestappService extends ServiceBase {

	def foo = { params ->
		def param = params[TESTAPP_IDX]

		return ""Hello, ${param}""
	}
}
class ServiceBase {

	static final String TESTAPP_IDX = 'index'
}
{code}

You get this stack trace:

{quote}
>>> a serious error occurred: BUG! exception in phase 'class generation' in source unit 'foo.groovy' Trying to access private constant field [ServiceBase#TESTAPP_IDX] from inner class
>>> stacktrace:
BUG! exception in phase 'class generation' in source unit 'foot.groovy' Trying to access private constant field [ServiceBase#TESTAPP_IDX] from inner class
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitAttributeOrProperty(AsmClassGenerator.java:966)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitPropertyExpression(AsmClassGenerator.java:1052)
	at org.codehaus.groovy.classgen.AsmClassGenerator.processClassVariable(AsmClassGenerator.java:1292)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitVariableExpression(AsmClassGenerator.java:1249)
	at org.codehaus.groovy.ast.expr.VariableExpression.visit(VariableExpression.java:70)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.visitBoxedArgument(CallSiteWriter.java:239)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.makeSingleArgumentCall(CallSiteWriter.java:252)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeSingleArgumentCall(InvocationWriter.java:482)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateBinaryExpression(BinaryExpressionHelper.java:504)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:239)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:527)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:295)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitDeclarationExpression(AsmClassGenerator.java:522)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:87)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:354)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:509)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:155)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:455)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:319)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:276)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:396)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:786)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:803)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1027)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:564)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:542)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:519)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:498)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:57)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:213)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:146)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:176)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:160)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
{quote}",,asteingress,blackdrag,jjathman,mauromol,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 07 04:21:53 UTC 2014,,,,,,,,,,"0|i2cc9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Nov/12 02:28;blackdrag;This issue seems to be a result of the fix for GROOVY-5259, thus I assign it to Cedric, who fixed that one;;;","07/Aug/14 04:21;mauromol;Still present in 2.3.6. Another test case:

{code}
package E
import groovy.transform.CompileStatic;
@CompileStatic
class Base {
  static final String CONSTANT = 'foo'
}
{code}

{code}
package E
import groovy.transform.CompileStatic;
@CompileStatic
class Ext extends Base {
  void doSomething() {
	  Object o = new Object()
	  o.with {
		CONSTANT
	  }
  }
}
{code}

Please consider that this kind of problems severely impact Greclipse, because they produce ""internal compiler errors"" that prevent a full project build (not just a compilation error on the offending file).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
XmlTemplateEngine does not escape expression values (part 1),GROOVY-5775,12818195,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,xn137,xn137,31/Oct/12 05:12,13/Jan/13 04:02,14/Jul/23 06:00,13/Jan/13 04:02,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.0-rc-1,,,XML Processing,,,,0,xmltemplateengine,,,,,"I would expect the following script to run without problems, but it does not:
{code}
import groovy.text.*

def xmlEngine = new XmlTemplateEngine()
def xml = '''<?xml version=""1.0""?>
<users xmlns:gsp='http://groovy.codehaus.org/2005/gsp'>
    <gsp:scriptlet>users.each {</gsp:scriptlet>
        <user id=""${it.id}""><gsp:expression>it.name</gsp:expression></user>
        <foo1>'</foo1>
        <foo2>""</foo2>
    <gsp:scriptlet>}</gsp:scriptlet>
</users>'''
def xmlBinding = [users: [
    new Expando(id: 1, name: 'mr & "" haki'),
    new Expando(id: 2, name: ""Hub < > ' ert"")]
]
def xmlOutput = xmlEngine.createTemplate(xml).make(xmlBinding).toString()
println xmlOutput
def root = new XmlParser().parseText(xmlOutput)
{code}

Error:
{noformat}
[Fatal Error] :3:9: The entity name must immediately follow the '&' in the entity reference.

Reason: the strings from the expandos are not escaped by the XmlTemplateEngine
{noformat}",Windows 7 32 bit,melix,paulk,pschumacher,xn137,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5903,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jan 13 04:02:53 UTC 2013,,,,,,,,,,"0|i2cqcf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Oct/12 05:16;xn137;I am sorry for not using the wiki markup for the script, now I am unable to edit the description.;;;","31/Oct/12 05:20;melix;Formatting tags;;;","31/Oct/12 05:51;xn137;Thinking about it, maybe it works as intended (when I want to template on XML level i.e. if i want to use entities then i have to escape them first).
But there should be an easy way to enable escaping (since i dont want to escape every string property of the objects in the binding myself).
This could be done by setting up the XmlTemplateEngine differently or by an additional attribute on the gsp:expression tag.;;;","06/Nov/12 02:03;xn137;If I get a hint about the direction it should go, I will try to provide the patch myself.;;;","04/Jan/13 05:33;pschumacher;@Paul King:
Any hints for Chris?;;;","06/Jan/13 05:23;paulk;My suspicions are that XML escaping to cover all scenarios (Japanese characters, entities in external DTDs, surrogate pairs, control characters etc.) is probably best left to a specialist XML library. But the vast majority of times just simple escaping is probably all that is required. So I provided a couple of utility methods in XmlUtil (escapeXml and escapeControlCharacters) but didn't hard-bake these into the template engine. So for your example you would need to have (assuming static imports):
{code}
...
new Expando(id: 1, name: escapeXml('mr & "" haki')),
new Expando(id: 2, name: escapeXml(""Hub < > ' ert""))]
...
{code}
Let me know if this seems OK. My feeling is that this should resolve the issue. For people with more elaborate requirements, they would be free to use Apache Commons Lang or the Google Guava XML escaping mechanisms or roll their own - e.g. escapeXml uses StringGroovyMethods#collectReplacements(String orig, Closure transform) under the covers and a custom transform Closure could be supplied if needed.;;;","10/Jan/13 11:13;pschumacher;should probably have fix version 2.1.0-rc-1;;;","11/Jan/13 04:09;xn137;Thanks for your replies.
Of course I know that in order to ""resolve the issue"" I can somehow escape the strings in the objects myself before using them with the XmlTemplateEngine.

The question of this bug report is more why XML processing with XmlTemplateEngine requires the user to care for string escaping himself and wether it would be an improvement to be able to setup the engine to take care of simple escaping scenarios.

For me it was unexpected that I have to escape every string that is part of the binding object tree myself in order to use the XmlTemplateEngine.
In the example, if i have a bunch of user objects and I want to output their information/adresses etc. into a XML structure i dont want to escape the string properties in the objects before using the engine and i dont want to explicitly put escaping-function calls into every gsp:expression in the template.

How about

{code}
def xmlEngine = new XmlTemplateEngine()
xml.enableEscaping = true
{code}

and then something like
{code:xml}
<gsp:expression>it.name</gsp:expression>
<gsp:expression escape=""on"">it.adress</gsp:expression>
<gsp:expression escape=""off"">it.rawxml</gsp:expression>
{code}
;;;","13/Jan/13 03:58;paulk;rename in preparation of cloning another issue to handle any further work;;;","13/Jan/13 04:02;paulk;Utility method is now available to make basic escaping easier;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Project compilation fails when I put an enum in my project,GROOVY-5771,12816596,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,mauromol,mauromol,27/Oct/12 11:58,12/Apr/13 16:55,14/Jul/23 06:00,26/Mar/13 16:27,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.3,2.2.0-beta-1,,Compiler,,,,0,,,,,,"If I put the following enum class in my project source code, compilation fails for the project and a red mark is put on ""line 0"" of this enum class and on another class:

{noformat}
General error during class generation: Index: 0, Size: 0 java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 at 
 java.util.ArrayList.rangeCheck(Unknown Source) at java.util.ArrayList.get(Unknown Source) at 
 org.codehaus.groovy.classgen.asm.InvocationWriter.writeAICCall(InvocationWriter.java:459) at 
 org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeConstructor(InvocationWriter.java:430) at 
 org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorCallExpression(AsmClassGenerator.java:908) at 
 org.codehaus.groovy.ast.expr.ConstructorCallExpression.visit(ConstructorCallExpression.java:43) at 
 org.codehaus.groovy.classgen.asm.CallSiteWriter.makeCallSite(CallSiteWriter.java:301) at 
 org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:231) at 
 org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:76) at 
 org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:60) at 
 org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:336) at 
 org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:647) at 
 org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67) at 
 org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:584) at 
 org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:504) at 
 org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47) at 
 org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81) at 
 org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:454) at 
 org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69) at 
 org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:102) at 
 org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:113) at 
 org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:318) at 
 org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:275) at 
 org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:124) at 
 org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:395) at 
 org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1174) at 
 org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:51) at 
 org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:179) at 
 org.codehaus.groovy.control.CompilationUnit$6.call(CompilationUnit.java:857) at 
 org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1191) at 
 org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:623) at 
 org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:601) at 
 org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:578) at 
 org.codehaus.jdt.groovy.internal.compiler.ast.GroovyCompilationUnitDeclaration.processToPhase(GroovyCompilati
 onUnitDeclaration.java:171) at 
 org.codehaus.jdt.groovy.internal.compiler.ast.GroovyCompilationUnitDeclaration.generateCode(GroovyCompilatio
 nUnitDeclaration.java:1534) at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:986) at 
 org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1025) at 
 org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:209) at 
 org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:275) at 
 org.codehaus.jdt.groovy.model.GroovyReconcileWorkingCopyOperation.makeConsistent(GroovyReconcileWorking
 CopyOperation.java:80) at 
 org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.ja
 va:89) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) at 
 org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788) at 
 org.codehaus.jdt.groovy.model.GroovyCompilationUnit.reconcile(GroovyCompilationUnit.java:429) at 
 org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126) at 
 org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108) at 
 org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89) at 
 org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at 
 org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87) at 
 org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151) at 
 org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86) at 
 org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:
 104) at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77) at 
 org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)
{noformat}

The enum class that is giving problem is the following:

{code}
package com.utopicmusic.app.web.seo

import java.sql.SQLException

import org.hibernate.HibernateException
import org.hibernate.Session
import org.springframework.orm.hibernate3.HibernateCallback
import org.springframework.orm.hibernate3.HibernateTemplate



/**
 * Type of sitemap that can be generated.
 * 
 * @author Mauro Molinari
 */
enum SitemapType {

	/** Sitemap index. */
	INDEX {
		@Override
		Map buildModel(final int offset, final HibernateTemplate hibernateTemplate) {
			final def result = [:]
			// index for artists
			// count
			//int c = ARTISTS.countEntries(hibernateTemplate)

			return result
		}

		@Override
		String getTemplatePath() {
			getClass().package.name.replace('.', '/') + '/sitemap-index.ftl'
		}
	},

	/** Sitemap for artist public pages. */
	ARTISTS {
		@Override
		Map buildModel(final int offset, final HibernateTemplate hibernateTemplate){
		}

		@Override
		int countEntries(final HibernateTemplate hibernateTemplate) {
			hibernateTemplate.execute(new HibernateCallback<Integer>() {
						@Override
						public Integer doInHibernate(Session session) throws HibernateException, SQLException {
							return session.createQuery(""select count(artist) from Artist as artist join artist.owner as user where user.active and artist.active"").uniqueResult()
						}
					})
		}
	},

	/** Sitemap for club public pages. */
	CLUBS {
		@Override
		Map buildModel(final int offset, final HibernateTemplate hibernateTemplate){
		}
	},

	/** Sitemap for listener public pages. */
	LISTENERS {
		@Override
		Map buildModel(final int offset, final HibernateTemplate hibernateTemplate){
		}
	},

	/** Sitemap for post pages. */
	POSTS {
		@Override
		Map buildModel(final int offset, final HibernateTemplate hibernateTemplate){
		}
	},

	/** Sitemap for song pages. */
	SONGS {
		@Override
		Map buildModel(final int offset, final HibernateTemplate hibernateTemplate){
		}
	},

	/** Sitemap for album pages. */
	ALBUMS {
		@Override
		Map buildModel(final int offset, final HibernateTemplate hibernateTemplate){
		}
	},

	/** Sitemap for playlist pages. */
	PLAYLISTS {
		@Override
		Map buildModel(final int offset, final HibernateTemplate hibernateTemplate){
		}
	},

	/** Sitemap for geographic pages. */
	LOCATIONS {
		@Override
		Map buildModel(final int offset, final HibernateTemplate hibernateTemplate){
		}
	}

	/**
	 * Returns the path within the classpath of the template that can be used to
	 * generate a sitemap of this type.
	 *
	 * @return the full path within the classpath to retrieve the template
	 */
	String getTemplatePath() {
		getClass().package.name.replace('.', '/') + '/sitemap.ftl'
	}

	/**
	 * Builds the model and view for a sitemap of this type.
	 * <p>
	 * Actually, only a part of sitemap is built, containing up to 30,000 links at most.
	 *
	 * @param offset the offset for the contents to include in the requested sitemap
	 * @return the model and reference to the view name needed to generate this type of sitemap
	 */
	Map buildModel(final int offset, final HibernateTemplate hibernateTemplate) {
		throw new UnsupportedOperationException('requested sitemap unavailable')
	}

	int countEntries(final HibernateTemplate hibernateTemplate) {
		throw new UnsupportedOperationException('count not implemented for this sitemap type')
	}
}
{code}",,mauromol,paulk,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 26 16:27:16 UTC 2013,,,,,,,,,,"0|i2bru7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Oct/12 23:57;werdna;What version of Eclipse and groovy compiler are you using?;;;","28/Oct/12 00:15;werdna;No need to answer that question.

Able to get the same error using this snippet:
{code}
enum Foo {
	A {

		int x() {
			new ArrayList<Integer>() {
					}
		}
	}
}
{code}
It is a problem with generics in enums.;;;","28/Oct/12 00:16;werdna;Ahhh...not greclipse. It is coming from groovy.  I get the same problem when compiling on the command line using groovy-2.0.4.

Converting to a groovy bug.;;;","26/Mar/13 06:07;paulk;When I run the example below:
{code}
enum Foo {
  A {
    List x() { new ArrayList<Integer>() { } }
  }
}
assert Foo.A.x() == []
{code}
using 2.1.2 I get:
{noformat}
java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
...
{noformat}
but it runs fine using master. Do you think the issue is fixed?
I believe it might have been fixed as part of GROOVY-5756. Let me know if you think otherwise.
Thanks, Paul.;;;","26/Mar/13 08:14;mauromol;It's hard for me to say if it's fixed or not, since I don't have that code anymore to test.

Anyway, we may mark this as fixed for 2.1.3/2.2.0-beta-1 and I'll reopen this issue or create a new one if I still  find troubles in the future. Thank you!;;;","26/Mar/13 16:27;paulk;Should be fixed as a consequence of GROOVY-5756. Please reopen/create a new issue  if you spot any further problems.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic ignores the extra parameters when a class is parametrized,GROOVY-5770,12816470,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,carlosapc,carlosapc,26/Oct/12 08:27,31/Mar/15 06:08,14/Jul/23 06:00,20/Mar/15 09:10,2.0.5,2.3.0,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Static compilation,Static Type Checker,,,1,,,,,,"{code:title=ParamTest.groovy|borderStyle=solid}
@groovy.transform.CompileStatic
class ParamTest <T>{
    static main(String[] args) {
        ParamTest<String,Integer> pt = new ParamTest<String>()
        println ""finish""
    }
}
{code}

The code fails to throw a compilation error on line 4. It happens when the class is initialized with more parameters than it was supposed to.
The following declarations for example will not throw a compile error either:


        ParamTest<String> pt = new ParamTest<String,Integer>()
        ParamTest<String,String> pt = new ParamTest<String,Integer>()","Windows 7 64bit and Ubuntu 12.04
Groovy 2.0.5
JDK 1.7
Eclipse Juno",carlosapc,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"26/Oct/12 08:27;carlosapc;ParamTest.groovy;https://issues.apache.org/jira/secure/attachment/12723004/ParamTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 20 09:10:26 UTC 2015,,,,,,,,,,"0|i2clon:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Mar/15 09:10;melix;Closing since this works on both master and 2.4.2.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullObject leak,GROOVY-5769,12816570,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,blackdrag,blackdrag,25/Oct/12 10:10,10/Jun/23 23:14,14/Jul/23 06:00,10/Jun/23 20:48,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,4.0.13,,,Compiler,,,,0,,,,,,"{code:Java}
def b = null  
assert b == null  
def a = null.getClass().newInstance()  
println a.getClass() 
assert a == null
{code}
The program shows a leak of NullObject. newInstance will give an instance. This is problematic in multiple ways. NullObject is supposed to be almost an invisible object, as well as a singleton.
To make the program above pass we could either fix the compareEquals or we fix newInstance() to return null for NullObject. I prefer the later one.",,blackdrag,githubbot,jkemnade,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6958,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jun 10 01:01:28 UTC 2023,,,,,,,,,,"0|i2by9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Oct/12 10:11;blackdrag;see StackOverlfow discussion at http://stackoverflow.com/questions/13069108/groovy-nullobject-should-be-null-or-not;;;","13/Mar/15 15:25;melix;I think this directly relates to GROOVY-4487. Intuitively, I would be for throwing a NPE.;;;","18/May/17 10:42;jkemnade;The script runs fine with 2.4.11.;;;","18/May/17 11:10;jkemnade;Fixed in 2.4.6 via GROOVY-6958;;;","18/May/17 12:35;blackdrag;The issue author is complaining about this script working;;;","18/May/17 12:54;jkemnade;Oh, I just read the issue description, that made it sound as if the script was supposed to work.;;;","09/Jun/23 13:56;githubbot;paulk-asert opened a new pull request, #1897:
URL: https://github.com/apache/groovy/pull/1897

   (no comment)


;;;","10/Jun/23 01:01;githubbot;paulk-asert merged PR #1897:
URL: https://github.com/apache/groovy/pull/1897


;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Changes in groovy.json.JsonOutput require extensive permissions that aren't compatible with some web frameworks.,GROOVY-5766,12816373,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,sdmurphy,sdmurphy,22/Oct/12 21:58,22/Dec/12 01:10,14/Jul/23 06:00,27/Nov/12 10:08,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,JSON,,,,0,,,,,,"It seems beginning somewhere after 2.0.1 but most likely in 2.0.5 there were some changes in groovy.json.JsonOutput that make it use certain methods or libraries that are restricted in App Engine.  Perhaps it was made multi-threaded?

If Groovy is going to support App Engine, these changes will have to be rolled back or made more configurable by allowing the developer to specify wether they want to leverage multithreading or not (If multithreading is the issue).

https://github.com/glaforge/gaelyk/issues/167

",,guillaume,sdmurphy,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 27 10:08:18 UTC 2012,,,,,,,,,,"0|i2bs0f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Nov/12 13:30;sdmurphy;New link to Gaelyk issue:

https://github.com/gaelyk/gaelyk/issues/167;;;","27/Nov/12 10:08;guillaume;I made the thread local holding the date format as an independent Java class, as (for some reason still to be found) Google App Engine doesn't like that class if implemented in Groovy.

It seems some reflection the Groovy runtime is doing is not authorized by App Engine.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Enum with vararg argument to the constructor ignores everything except the first argument,GROOVY-5765,12816498,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,japettyjohn,japettyjohn,20/Oct/12 17:41,28/Dec/14 07:52,14/Jul/23 06:00,28/Dec/14 07:52,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,groovy-runtime,,,,1,,,,,,"enum with vararg argument to the constructor ignores everything except the first argument.

Included are two tests that are reproducible with groovy at the command line. Works fine using varargs as an argument for a class constructor - sample also included.",JVM: 1.6.0_24 and 1.7.0_06-icedtea ,japettyjohn,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Oct/12 17:41;japettyjohn;EnumVarargTest.groovy;https://issues.apache.org/jira/secure/attachment/12722175/EnumVarargTest.groovy","20/Oct/12 17:41;japettyjohn;WorkingVarargTest.groovy;https://issues.apache.org/jira/secure/attachment/12723034/WorkingVarargTest.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 07:52:30 UTC 2014,,,,,,,,,,"0|i2cbh3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"10/Feb/13 11:00;pschumacher;changed the title;;;","28/Dec/14 07:52;pschumacher;Thanks for reporting. Your example works for me with groovy 2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compilation runtime error when using mapped constructor,GROOVY-5762,12816532,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,werdna,werdna,17/Oct/12 08:32,22/Dec/12 01:10,14/Jul/23 06:00,21/Nov/12 10:06,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.0-beta-1,,,Static compilation,,,,0,,,,,,"Take this class

{code}
package compilestatic

import groovy.transform.Canonical;
import groovy.transform.CompileStatic;

@CompileStatic
class WTF {
	public static void main(String[] args) {
		new Person(name:""First"")
		first(new Person(name:""First""))
	}

	static Person first(Person p) {
		p
	}

}

@Canonical
class Person {
	String name
}
{code}

The following exception is thrown:
{code}
Caught: java.lang.NoSuchMethodError: compilestatic.Person.<init>(Ljava/util/Map;)V
java.lang.NoSuchMethodError: compilestatic.Person.<init>(Ljava/util/Map;)V
	at compilestatic.WTF.main(wtf.groovy:10)
{code}

Note that this exception comes from the *second* statement in the main method.  Comment out that statement and there is no exception.",,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 17 08:45:10 UTC 2012,,,,,,,,,,"0|i2crnr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Oct/12 08:45;werdna;And forgot to mention: remove the @CompileStatic and the program runs.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"@CompileStatic complains about ArrayList not being a String, but doesn't so about HashSet. Seems inconsistent.",GROOVY-5758,12816601,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,oliver_plow,oliver_plow,15/Oct/12 02:48,22/Dec/12 01:10,14/Jul/23 06:00,20/Nov/12 08:17,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Compiler,,,,0,,,,,,"{code}
@CompileStatic
class MyGroove {

    private String str = null;

    def static main(args)
    {
        MyGroove myGroove = new MyGroove();
        println myGroove.str
        myGroove.str = ""abc""
        println myGroove.str.getClass()
        myGroove.str = new HashSet<String>()    // compiles fine
        println myGroove.str    // prints ""[]"" to the console

        // does not compile: [Static type checking] - Cannot assign 
        // value of type java.util.ArrayList to variable of 
        // type java.lang.String
        myGroove.str = new ArrayList<String>()
    }

}
{code}",Hapens with eclipse-java-juno-SR1-win32 with Groovy plugin as well as with IntelliJ IDea 21 EAP with Groovy 2.0.5,melix,oliver_plow,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 20 07:26:53 UTC 2012,,,,,,,,,,"0|i2ce7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Nov/12 07:26;melix;Formatting tags;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
error during class generation: cannot define closures inside methods of an enum instance,GROOVY-5756,12818194,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,zagyvaibalazs,zagyvaibalazs,11/Oct/12 18:38,12/Apr/13 16:55,14/Jul/23 06:00,26/Mar/13 05:30,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.3,2.2.0-beta-1,,,,,,0,,,,,,"The following code fails to run:

{code}
enum MyEnum {
    INSTANCE {
        String foo() {
            def clos = {
                ""foo""
            }
            clos.call()
        }
    }

    String foo() {
    }
}

assert ""foo"" == MyEnum.INSTANCE.foo()
{code}

The Groovy runtime throws the following exception when trying to execute it:
{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during class generation: NPE while processing ClosureDefiningEnumInstanceMethodTest.groovy

groovy.lang.GroovyRuntimeException: NPE while processing ClosureDefiningEnumInstanceMethodTest.groovy
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:198)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:786)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1027)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:564)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:542)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:519)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:279)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:258)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:244)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:185)
	at groovy.lang.GroovyShell$2.run(GroovyShell.java:206)
	at groovy.lang.GroovyShell$2.run(GroovyShell.java:204)
	at java.security.AccessController.doPrivileged(Native Method)
	at groovy.lang.GroovyShell.run(GroovyShell.java:204)
	at groovy.lang.GroovyShell.run(GroovyShell.java:150)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:557)
	at groovy.ui.GroovyMain.run(GroovyMain.java:344)
	at groovy.ui.GroovyMain.process(GroovyMain.java:330)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:119)
	at groovy.ui.GroovyMain.main(GroovyMain.java:99)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.classgen.asm.ClosureWriter.createClosureClass(ClosureWriter.java:184)
	at org.codehaus.groovy.classgen.asm.ClosureWriter.getOrAddClosureClass(ClosureWriter.java:150)
	at org.codehaus.groovy.classgen.asm.ClosureWriter.writeClosure(ClosureWriter.java:77)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClosureExpression(AsmClassGenerator.java:546)
	at org.codehaus.groovy.ast.expr.ClosureExpression.visit(ClosureExpression.java:43)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:295)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitDeclarationExpression(AsmClassGenerator.java:522)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:87)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:354)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:509)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:155)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:455)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:319)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:276)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:396)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	... 25 more

1 error
ï©{noformat}

As the stacktrace suggests, the problem is caused by the closure definition in the enum instance specific foo() method.","Mac OS X 10.7.5, IntelliJ IDEA 11.1.3",paulk,zagyvaibalazs,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Oct/12 18:38;zagyvaibalazs;ClosureDefiningEnumInstanceMethodTest.groovy;https://issues.apache.org/jira/secure/attachment/12721730/ClosureDefiningEnumInstanceMethodTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 26 05:30:21 UTC 2013,,,,,,,,,,"0|i2ck1b:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"26/Mar/13 05:30;paulk;Should be fixed now - thanks for noticing the problem and raising the issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MissingPropertyException thrown when referencing an externally declared constant from a switch case in an enum instance method ,GROOVY-5755,12816584,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,zagyvaibalazs,zagyvaibalazs,11/Oct/12 10:22,12/Apr/13 16:55,14/Jul/23 06:00,26/Mar/13 05:39,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.3,2.2.0-beta-1,,,,,,0,,,,,,"For illustration see the code below:

{code}
import javax.xml.stream.XMLStreamConstants

enum MyEnum {
     INSTANCE {
        String getName(int i) {
            switch (i) {
                case javax.xml.stream.XMLStreamConstants.START_ELEMENT:
                    return ""START_ELEMENT""
                case XMLStreamConstants.END_ELEMENT:
                    return ""END_ELEMENT""
            }
        }
    }
}

println MyEnum.INSTANCE.getName(XMLStreamConstants.START_ELEMENT)
println MyEnum.INSTANCE.getName(XMLStreamConstants.END_ELEMENT)
{code}

The first invokation of getName succeeds because the constant is referenced with its fully qualified name in the first case statement. The second however fails in spite of the fact that the referenced class is imported.

Exact output of the script is:
{noformat}
START_ELEMENT
Caught: groovy.lang.MissingPropertyException: No such property: XMLStreamConstants for class: MyEnum$1
groovy.lang.MissingPropertyException: No such property: XMLStreamConstants for class: MyEnum$1
	at MyEnum$1.getName(EnumMemberMethodWithSwitchTest.groovy:9)
	at MyEnum$1$getName.call(Unknown Source)
	at EnumMemberMethodWithSwitchTest.run(EnumMemberMethodWithSwitchTest.groovy:18)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
{noformat}","Mac OS X 10.7.5, IntelliJ IDEA 11.1.3",paulk,zagyvaibalazs,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Oct/12 10:22;zagyvaibalazs;ExternalConstantReferencingSwitchCaseInEnumInstanceMethodTest.groovy;https://issues.apache.org/jira/secure/attachment/12723033/ExternalConstantReferencingSwitchCaseInEnumInstanceMethodTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 26 05:39:08 UTC 2013,,,,,,,,,,"0|i2bu6f:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"26/Mar/13 05:39;paulk;I believe this was fixed as part of GROOVY-5756. Thanks for raising the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Regression: @TypeChecked fails on ternary expression,GROOVY-5753,12817461,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,perplex79,perplex79,11/Oct/12 05:28,22/Dec/12 01:10,14/Jul/23 06:00,21/Nov/12 01:50,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static Type Checker,,,,0,,,,,,"The following code fails with Groovy 2.0.5, but worked with 2.0.0:

{code}import groovy.transform.TypeChecked

@TypeChecked
void unboxedTest() {
    double nan = Double.NaN
    double test =  true ? 1.0d : nan         // works    
    double test2 = true ? 1.0d : Double.NaN  // doesn't work
}{code}

Error message: 

{code}org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/tmp/map.groovy: 7: [Static type checking] - Cannot assign value of type java.io.Serializable or java.lang.Comparable to variable of type double
 @ line 7, column 25.
       double test2 = true ? 1.0d : Double.NaN  // doesn't work
{code}","Ubuntu 12.04 x86_64, Groovy 2.0.5, Oracle JDK 1.7.0_07",dlichtenberger,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 21 01:50:04 UTC 2012,,,,,,,,,,"0|i2bvqv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Nov/12 01:50;melix;Confirmed on 2.0.5 but cannot reproduce on {{master}} so it's likely that it has been fixed with another bug.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DelegateASTTransformation#addGetterIfNeeded doesn't take boolean isX accessors into account,GROOVY-5752,12812018,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jkuipers,jkuipers,11/Oct/12 03:53,01/Feb/17 23:19,14/Jul/23 06:00,06/Aug/16 05:03,2.0.5,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.8,,,xforms,,,,0,,,,,,"I'm using @Delegate on a field whose type includes boolean properties. The resulting byte code properly delegates non-overridden getters and setters, but not boolean isX() accessors. This is due to DelegateASTTransformation#addGetterIfNeeded not considering isX accessors. 

Right now I've fixed this like this, wrapping the existing method in a for loop iterating over both 'get' and 'is':

{code}
    private void addGetterIfNeeded(FieldNode fieldNode, ClassNode owner, PropertyNode prop, String name) {
    	for (String accessor: new String[] {""get"", ""is""}) {
    		String getterName = accessor + Verifier.capitalize(name);
    		if (owner.getGetterMethod(getterName) == null) {
    			owner.addMethod(getterName,
    					ACC_PUBLIC,
    					nonGeneric(prop.getType()),
    					Parameter.EMPTY_ARRAY,
    					null,
    					new ReturnStatement(
    							new PropertyExpression(
    									new VariableExpression(fieldNode),
    									name)));
    		}
    	}
    }
{code}

I could include a JUnit test, but the bug seems obvious enough looking at the DelegateASTTransformation code.",,githubbot,jkuipers,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6245,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 06 05:03:51 UTC 2016,,,,,,,,,,"0|i2cman:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Oct/12 06:05;paulk;Hi Joris, to confirm my understanding of what you want to achieve, can you give a simple example of what is broken now and what you are expecting the behaviour to be? I found some strange behaviour in addition to what I think you are after and just want to check I have isolated the issues. Thanks.;;;","12/Oct/12 06:35;jkuipers;Sure: I have a class written in Groovy called 'Activity' that has a boolean property 'schedulePrint'. I don't provide the property accessor methods for that myself, I rely on the default Groovy-provided implementations. Then I have a groovy class 'PlannedActivity extends Activity' with a '@Delegate private final Activity target' field, which is initialized in the constructor.
Then from a Java class I call 'isSchedulePrint()' on an instance of PlannedActivity, and I expect that call to be delegated to the target field. However, there is no delegating implementation generated for 'isSchedulePrint' as the result of the @Delegate annotation, only a 'getSchedulePrint' (which does properly delegate). Hence I end up calling the isSchedulePrint implementation that PlannedActivity inherits from Activy which returns the field of the PlannedActivity instance itself (which is always false), instead of a delegating method that returns the field from the wrapped Activity.
That's the exact case that I ran into. ;;;","12/Oct/12 07:24;paulk;Just checking ... if you swap between boolean/Boolean in Activity, do you still observe the bad behaviour?;;;","12/Oct/12 09:45;jkuipers;I don't think that a method like isSchedulePrint() is actually created when my field is of type Boolean by groovy: only a getSchedulePrint() seems to be created in the non-simple-type case. I could add it myself, but it wouldn't be a property accessor anymore but just a user-specified method, so I would expect delegation to work just fine in that case. Or am I missing something?;;;","12/Oct/12 14:33;paulk;Hi Joris, I just noticed that for this class:
{code}
class Foo {
  boolean one = true   // note: primitive type
  Boolean two = false
}
{code}
that (at least for master) Groovy is generating setters for both and ""get""-prefixed getters for both but also an ""is""-prefixed getter for one, i.e. it is creating an ""isOne"" method but not an ""isTwo"" method. This is nothing to do with @Delegate but I was just checking which of the cases was affecting you before exploring further. So it seems the second case (non-primitive) from what you say.

So to explain, I added your patch locally as an experiment but tweaked it for the ""is"" case to be applicable only for boolean typed properties but then noticed the above discrepancy and I suspect that the above needs to be looked at first before continuing with this issue.;;;","12/Oct/12 14:44;jkuipers;You're absolutely right: I didn't look at the actual method implementation properly and simply assumed it would only add delegating accessor methods if those methods actually exist in the delegate. Since I now see that that's not the case you should indeed add the isX accessor only after checking that the return type is a simple boolean. Sorry for the confusion I might have introduced ;)
BTW, it's correct behavior to only add isX accessors for the boolean simple type according to the JavaBeans spec AFAICT. 
;;;","14/Oct/12 16:20;jkuipers;FYI, this is what I'm using successfully at the moment myself:
{code}
private void addGetterIfNeeded(FieldNode fieldNode, ClassNode owner, PropertyNode prop, String name) {
	for (String accessor: new String[] {""get"", ""is""}) {
		String getterName = accessor + Verifier.capitalize(name);
		if (owner.getGetterMethod(getterName) == null) {
		    if (!""is"".equals(accessor) || prop.getOriginType().equals(ClassHelper.boolean_TYPE))
    			owner.addMethod(getterName,
    					ACC_PUBLIC,
    					nonGeneric(prop.getType()),
    					Parameter.EMPTY_ARRAY,
    					null,
    					new ReturnStatement(
    							new PropertyExpression(
    									new VariableExpression(fieldNode),
    									name)));
		}
	}
}
{code};;;","05/Aug/16 11:21;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/380

    GROOVY-5752: DelegateASTTransformation#addGetterIfNeeded doesn't take…

    … boolean isX accessors into account

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy5752

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/380.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #380
    
----
commit 28750e13ab5f1c0115f59babfccb888d5ce1d7ff
Author: paulk <paulk@asert.com.au>
Date:   2016-08-05T11:17:22Z

    GROOVY-5752: DelegateASTTransformation#addGetterIfNeeded doesn't take boolean isX accessors into account

----
;;;","06/Aug/16 00:08;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/380
;;;","06/Aug/16 05:03;paulk;Proposed PR merged and ported back to the 2_4_X branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Adding milliseconds with TimeCategory gives incorrect toString,GROOVY-5751,12816576,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,tim_yates,tim_yates,11/Oct/12 03:25,22/Dec/12 01:10,14/Jul/23 06:00,12/Oct/12 04:26,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,2.1.0-beta-1,groovy-jdk,,,,0,,,,,,"From [this question|http://stackoverflow.com/questions/12833903/groovy-timecategory-bad-millseconds-addition] on StackOverflow, doing:

{code}
def a = use(groovy.time.TimeCategory) {
  800.millisecond + 300.millisecond
}
println a
{code}

Gives the output:

{code}
0.1100 seconds
{code}

When it should show either:

{code}
1100 milliseconds
{code}

or

{code}
1.1 seconds
{code}",,paulk,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 12 07:22:52 UTC 2012,,,,,,,,,,"0|i2cs13:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Oct/12 03:22;paulk;OK, I have a patch for this. Just writing a test. The output for the example is now ""1.100 seconds"".;;;","12/Oct/12 03:32;tim_yates;I wrote a normalize method (which I posted in to that question) to take a TimeDuration and return a new instance with the wrapping figures handled:

{code}
groovy.time.TimeDuration.metaClass.normalize = { ->
  def newdmap = ['days','hours','minutes','seconds','millis'].collectEntries { 
    [ (it):delegate.""$it"" ]
  }.with { dmap ->
    [millis:1000,seconds:60,minutes:60,hours:24,days:-1].inject( [ dur:[ days:0, hours:0, minutes:0, seconds:0, millis:0 ], roll:0 ] ) { val, field ->
      val.dur.""$field.key"" = dmap.""$field.key"" + val.roll
      val.roll = val.dur.""$field.key"".intdiv( field.value )
      val.dur.""$field.key"" = field.value < 0 ?
                               val.dur.""$field.key"" :
                               val.dur.""$field.key"" % field.value
      val
    }.dur
  }
  new TimeDuration( newdmap.days, newdmap.hours, newdmap.minutes, newdmap.seconds, newdmap.millis )
}
{code}

Not sure if it's something that could (or should) be written for TimeDuration? -- obviously, it would need Javaifying;;;","12/Oct/12 04:26;paulk;Patch applied.

Tim, I think normalize() or fromMilliseconds() or millis.asDuration() would be a useful addition - over and above this fix. BaseDuration also has months and years, so it might pay to cover those too. I am thinking just providing the method - and not trying to auto apply it after operations would be the way to go at this point.;;;","12/Oct/12 04:41;tim_yates;Yeah, I stopped before months, as for days to roll into months, you'd need to know what month you're representing, which isn't known by the Duration :-/

Maybe a parameter specifying which year and month the duration is starting from for the normalize method?  But this feels like it might be more confusing than helpful?

But then again, this method you could end up with 1 month, 90 days which I guess isn't very helpful either ;-);;;","12/Oct/12 07:22;paulk;I guess just the DatumDependentDuration would get months and years but I'd have to check the code again to confirm there would be no issues.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MissingFieldException when accessing @Lazy property of outer class,GROOVY-5750,12816522,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,justin.piper@gmail.com,justin.piper@gmail.com,10/Oct/12 22:56,17/Dec/14 13:25,14/Jul/23 06:00,16/Nov/14 04:24,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,xforms,,,,0,,,,,,"If an inner class tries to access a @Lazy property of its outer class it will cause a MissingFieldException unless it either explicitly calls the getter or specifies the outer {{this}}.

{code}

class Outer
{
    @Lazy lazy   = 'lazy'
    final normal = 'normal'
    final inner  = new Inner()
    
    class Inner
    {
        def f() { normal }
        def g() { Outer.this.lazy }
        def h() { getLazy() }
        def i() { lazy }
    }
}

final outer = new Outer()

assert outer.normal == outer.inner.f()
assert outer.lazy   == outer.inner.g()
assert outer.lazy   == outer.inner.h()
assert outer.lazy   == outer.inner.i()
{code}

The expected behavior is that {{#g}}, {{#h}} and {{#i}} are equivalent.",,andre.steingress,justin.piper@gmail.com,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 16 04:24:44 UTC 2014,,,,,,,,,,"0|i2ckxj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"10/Oct/12 23:06;justin.piper@gmail.com;This is known to affect version 2.0.5.;;;","12/Oct/12 02:51;paulk;This also works (as an internal pointer for identifying the problem - not for normal usage):
{code}
def i() { Outer.this.@'$lazy' }
{code};;;","14/Jan/13 05:43;andre.steingress;The LazyASTTransformation replaces the instance field definition

{code}
@Lazy lazy = 'lazy'
{code}

with 

{code}
@Lazy
private Object $lazy = 'lazy'
{code}


@Paul: is this a general dispatching issue or should LazyASTTransformation just check for this case and change 'lazy' to 'Outer.this.lazy'?;;;","15/Jan/13 23:59;paulk;@Andre, it is a more general dispatching issue that is interacting with how {{@Lazy}} is implemented.

If you look at this code here ({{@Lazy}} free):
{code}
class Outer {
    private bar = 'bar'
    def getBar() { bar + '!' }
    private _baz = 'baz'
    def getBaz() { _baz + '?' }
    def foo() { bar + baz }
    final inner  = new Inner()
    class Inner {
        def fooi() { bar + baz }
    }
}

final outer = new Outer()
assert outer.foo() == 'barbaz?'
assert outer.inner.bar == 'bar'
assert outer.inner.fooi() == 'barbaz?' // => No such field: baz for class: Outer
{code}
When inside a class, the normal behavior is to look for the field first (hence 'bar' not 'bar!') but if not found, then look for the meta property accessor (hence 'baz?'). When searching on the inner class, if the field exists (e.g. outer.inner.bar) we are ok, but if not (e.g. no outer.inner.baz field) then the meta property accessor is being looked up just on the inner class not the outer one.;;;","16/Jan/13 02:33;andre.steingress;I see. As the MetaProperty can not be found for property 'lazy' the default behavior is to fall back to propertyMissing. As this.""$name"" can not be resolved against 'lazy' a MissingFieldException is thrown.

{code}
groovy.lang.MissingFieldException: No such field: lazy for class: Outer

	at groovy.lang.MetaClassImpl.getAttribute(MetaClassImpl.java:2504)

	at groovy.lang.MetaClassImpl.getAttribute(MetaClassImpl.java:3334)

	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.getGroovyObjectField(ScriptBytecodeAdapter.java:352)

	at Outer.this$dist$get$1(ConsoleScript1)

	at Outer$Inner.propertyMissing(ConsoleScript1)
{code};;;","16/Nov/14 04:24;pschumacher;Justin Piper example works on current master, so I'm resolving this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
glitch with TypeChecked and generics,GROOVY-5748,12811681,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,paulk,,08/Oct/12 14:49,07/Apr/15 19:07,14/Jul/23 06:00,10/Oct/12 09:14,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static Type Checker,,,,0,,,,,,"This code:
{code}
// adapted from:
// http://stackoverflow.com/questions/9383681/how-can-i-design-a-type-safe-stack-in-java-preventing-pops-from-an-empty-list

import groovy.transform.ASTTest
import groovy.transform.TypeChecked
import static org.codehaus.groovy.transform.stc.StaticTypesMarker.*
import static org.codehaus.groovy.ast.ClassHelper.*

interface IStack<T> {
    INonEmptyStack<T, ? extends IStack<T>> push(T x)
}

interface IEmptyStack<T> extends IStack<T> {
    @Override
    INonEmptyStack<T, IEmptyStack<T>> push(T x)
}

interface INonEmptyStack<T, TStackBeneath extends IStack<T>> extends IStack<T> {
    T getTop()

    TStackBeneath pop()

    @Override
    INonEmptyStack<T, INonEmptyStack<T, TStackBeneath>> push(T x)
}

class EmptyStack<T> implements IEmptyStack<T> {
    @Override
    INonEmptyStack<T, IEmptyStack<T>> push(T x) {
        new NonEmptyStack<T, IEmptyStack<T>>(x, this)
    }
}

class NonEmptyStack<T, TStackBeneath extends IStack<T>>
        implements INonEmptyStack<T, TStackBeneath> {
    private final TStackBeneath stackBeneathTop;
    private final T top

    NonEmptyStack(T top, TStackBeneath stackBeneathTop) {
        this.top = top
        this.stackBeneathTop = stackBeneathTop
    }

    @Override
    T getTop() {
        top
    }

    @Override
    TStackBeneath pop() {
        stackBeneathTop
    }

    @Override
    INonEmptyStack<T, INonEmptyStack<T, TStackBeneath>> push(T x) {
        new NonEmptyStack<T, INonEmptyStack<T, TStackBeneath>>(x, this)
    }
}

@TypeChecked
def main() {
    final IStack<Integer> stack = new EmptyStack<Integer>()

    @ASTTest(phase=INSTRUCTION_SELECTION, value={
        println 'oneInteger:' + node.getNodeMetaData(INFERRED_TYPE)
    })
    def oneInteger = stack.push(1)
    assert oneInteger.getTop() == 1

    @ASTTest(phase=INSTRUCTION_SELECTION, value={
        println 'twoIntegers:' + node.getNodeMetaData(INFERRED_TYPE)
    })
    def twoIntegers = stack.push(1).push(2)
    assert twoIntegers.getTop() == 2

    @ASTTest(phase=INSTRUCTION_SELECTION, value={
        println 'oneIntegerAgain:' + node.getNodeMetaData(INFERRED_TYPE)
    })
    def oneIntegerAgain = stack.push(1).push(2).pop()
    // assert oneIntegerAgain.getTop() == 1 // BOOM!!!!
}
{code}
Gives this output:
{noformat}
oneInteger:INonEmptyStack <java.lang.Integer, IEmptyStack> -> INonEmptyStack <T, TStackBeneath extends IStack <T> -> IStack <T>>
twoIntegers:INonEmptyStack <java.lang.Integer, INonEmptyStack> -> INonEmptyStack <T, TStackBeneath extends IStack <T> -> IStack <T>>
oneIntegerAgain:IStack <INonEmptyStack> -> IStack <T>
{noformat}
and gives this error when the last assert is uncommented:
{noformat}
1 compilation error:
[Static type checking] - Cannot find matching method IStack#getTop(). Please check if the declared type is right and if the method exists.
 at line: 79, column: 12
{noformat}
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 10 16:28:35 UTC 2012,,,,,,,,,,"0|i2cijj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Oct/12 16:28;paulk;Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
First call to Groovlet succeeds but subsequent calls return 404,GROOVY-5747,12811979,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,gjmathews1,gjmathews1,08/Oct/12 13:03,22/Dec/12 01:10,14/Jul/23 06:00,05/Dec/12 03:01,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,,GroovyScriptEngine,,,,7,,,,,,".groovy extension mapped in web.xml and .groovy script located in WEB-INF/groovy

First call to test.groovy works
http://localhost:8080/test/test.groovy

INFO: Groovy servlet initialized on groovy.util.GroovyScriptEngine@6f03de90.
Oct 8, 2012 1:52:39 PM org.apache.catalina.core.ApplicationContext log

All subsequent calls return 404
http://localhost:8080/test/test.groovy

INFO: Server startup in 773 ms
GroovyServlet Error:  script: '/test.groovy':  Script not found, sending 404.

Note the .groovy mapping works corrected in Groovy 1.8.4 through 2.0.1 but appears to have broken as 2.0.2  through 2.0.5.

Attached sample WAR removed the groovy jar which was originally packed as ""WEB-INF/lib/groovy-all-2.0.5.jar""

Related discussion can be found here:
http://stackoverflow.com/questions/8228873/groovyservlet-returning-404-on-all-requests-after-successfully-loading-once","Groovy 2.0.5
Tomcat 6.0.35
Java 1.6.0_35
Windows 7 64-bit
Also same error running in Google App Engine (GAE) 1.7.2-1",blackdrag,davidsky,gjmathews1,jsumners,ryanfb,saltnlight5,xn137,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/Dec/12 14:07;ryanfb;groovy-5747-testcase.zip;https://issues.apache.org/jira/secure/attachment/12723045/groovy-5747-testcase.zip","08/Oct/12 13:03;gjmathews1;test.war;https://issues.apache.org/jira/secure/attachment/12723005/test.war",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 05 03:01:28 UTC 2012,,,,,,,,,,"0|i2cnjj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Oct/12 09:54;davidsky;I have the same problem with the following environment:
Groovy 1.8.8
Tomcat 6.0.35
OpenJDK 1.6.0_24
CentOS 6 Linux 32-bit;;;","20/Nov/12 09:13;saltnlight5;I am not sure what version this program started, but I have tested groovy-2.0.1 it was working fine, but when switched to groovy-2.0.5, this script not found problem occurrs.;;;","30/Nov/12 09:00;gjmathews1;The GroovletServlet worked correctly through 2.0.1 and broke as of 2.0.2 so this bug was introduced in 2.0.2.;;;","03/Dec/12 09:07;blackdrag;I have a big problem reproducing this bug. I just tried 3 versions, an embedded tomcat, a vanilla tomcat with the war in webapps and the groovy lib in tomcats lib directory and the last version with the war containing the groovy lib in webapps. In all 3 cases it seems to work without problem.

I would assume that means there is a configuration that worked before and does not work now. But that is really only an assumption. I see myself unable to fix the issue without a test that actually reproduces it.;;;","03/Dec/12 14:07;ryanfb;The attached minimal testcase reproduces the problem for me (run ""gradle jettyRunWar"" then open the resulting URL twice). It looks like the gradle jetty plugin uses jetty 6.1.25. Interestingly, in writing this testcase, I found that the problem happened with groovy 2.0.2, 2.0.3, and 2.0.4, but not with 2.0.5. Perhaps some interaction with other components can cause it to still occur with 2.0.5.;;;","04/Dec/12 08:32;jsumners;In the linked StackOverflow question, I am was not using anything extra. I literally untarred Tomcat, added a configuration to serve .groovy scripts (straight out of the Groovy docs), and stuck some Groovy scripts in a web root.;;;","05/Dec/12 03:01;blackdrag;Since the issue is no longer reproducible in 2.0.6 I will resolve the issue now. The others reporting here seem to have slightly different problems. I would like anyone here to try out the current development version of either 1.8 or 2.0 and check if the issue is still there. If it is there, please fill a new bug plus test case. As for the original author of this issue, I would you like to test as well. Should it nor work for you, then I will reopen the issue. 

I hope that is ok with everybody;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Array assignment with operator does double call for index expression and array part,GROOVY-5746,12816568,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,blackdrag,blackdrag,08/Oct/12 09:22,03/Feb/22 22:32,14/Jul/23 06:00,20/Oct/21 19:59,2.0.5,2.3.0,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,4.0.0-beta-2,,,Static compilation,,,,0,,,,,,"{code:Java}
@groovy.transform.CompileStatic
class IndexTest {
    private int f = 0
    public int getIndex() {f++;0}
    def foo() {
        List<String> x = [""1"",""2""]
        x[index] += ""1""
        assert x[0] == ""11""
        assert f == 1
    }
}
def x = new IndexTest()
x.foo()
{code}
The program above shows code in which we use an operator in combination with array assignment and an index with a side effect. This code must run without calling getIndex() twice. Since the field f is incremented twice, this is not the case. Normal Groovy executed the code as wished. The probable implementation is x[index] = x[index] + ""1"", which not only evals index twice, but also x. x and index must be evaluated only once!",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 19 04:10:43 UTC 2013,,,,,,,,,,"0|i2c6o7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Aug/13 04:10;blackdrag;additional information: the array access is partially routed through the primitive opts code, which would not apply in this case, since index is no local variable or field. This means the array access part in primitive opts cannot be reused like this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Multiple assignment from Iterator skips every other element,GROOVY-5744,12816559,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,justin.piper@gmail.com,justin.piper@gmail.com,05/Oct/12 17:54,10/Oct/22 19:45,14/Jul/23 06:00,10/Oct/22 08:16,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,5.0.0-alpha-1,,,groovy-runtime,,,,0,,,,,,"If you try to assign multiple variables from an iterator Groovy will skip every other value.

Example:
{code}
final list = [1,2,3]
final iter = list.iterator()

final def (a,b,c) = list
final def (d,e,f) = iter

assert ""$a $b $c"" == ""$d $e $f""
{code}

Result:
{noformat}
Assertion failed: 

assert ""$a $b $c"" == ""$d $e $f""
         |  |  |  |    |  |  |
         1  2  3  |    1  3  null
                  false
{noformat}

The expected behavior is either that the assertion succeeds, or the assignment to (d,e,f) fails outright.

If this is fixed it would also be nice if any Iterable could be used on the RHS.",,blackdrag,githubbot,justin.piper@gmail.com,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10666,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 10 19:45:23 UTC 2022,,,,,,,,,,"0|i2bxyn:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"05/Oct/12 22:08;paulk;Just a note at this stage. Changing the problematic assignment to:
{code}
final def (d,e,f) = iter.toList()
{code}
works around the problem.

What the shorthand is currently equivalent to: 
{code}
final def (d,e,f) = [iter[0], iter[1], iter[2]]
{code}
But with {{iter}} advancing (one item being consumed) with each access.

What we would need to do (or do the toList() automatically as shown above):
{code}
final def (d,e,f) = [iter[0], iter[0], iter[0]]
{code}

Regarding support for {{Iterable}}. You can just go {{iterable.iterator()}} (albeit with the current behavior as per this issue) or we'd need to support the {{getAt(Integer)}} method for {{Iterables}}.;;;","05/Oct/12 22:33;justin.piper@gmail.com;If it's feasible it'd be nice if it effectively did:

{code}
final d = iter? iter.next() : null, e = iter? iter.next() : null, f = iter? iter.next() : null
{code}

Then if the {{Iterator}} is something that's expensive to materialize as a {{List}}, or if you just want to use the unconsumed elements later you still can.;;;","05/Oct/12 22:59;paulk;I have split the {{Iterable}} aspect out into the following issue: GROOVY-5745;;;","05/Oct/12 23:41;paulk;At the moment, the handling of multi-declarations knows nothing about the type of the right hand side. It might be that we just (better) document that iterators aren't supported or perhaps throw an error in that case - though I think there is sufficient justification to perhaps support Iterators too. Now that GROOVY-5745 is resolved, would using an {{Iterable}} work for your use case?;;;","07/Oct/12 04:05;paulk;@Justin: if we added special support for {{Iterator}} it would end up being equivalent (or at least very close) to what you suggested.;;;","07/Oct/12 05:40;blackdrag;So far def (a0,a1,a2,...,an) = x is defined as a0=x[0], a1=x[1],....,a[n]=x[n]. This works on everything that supports a getAt, if there is no getAt supported, then this fails with a missing method exception. It is implemented like a kind of compiler makro as of now. If we change it as suggested here, then we need a transformation step on the right side, that then would call a method, that basically tests if it is an Iterator, to call toList() on that and do nothing otherwise. I am a bit wondering if that really makes sense...

There would be in theory another way... why do we support Iterator#getAt? I mean... in what use case scenario does it make sense to let it[2] skip two elements, to get the one after?;;;","07/Oct/12 13:31;justin.piper@gmail.com;Honestly I think I'd try to avoid using {{getAt(Integer)}} for {{Iterable}} as it's currently implemented, unless I just wanted the first element. In that case this seems pretty convenient:

{code}
final def (first) = iterable
{code}

That does bring another option to mind, however. I notice that DGM defines {{getAt(Range)}} for some types. If {{Iterable}} and {{Iterator}} had an overload like that, you could do something like this:

{code}
final def (a,b,c) = iter[0..3]
{code}

It wouldn't be quite as efficient as supporting {{Iterator}} on the RHS directly, but it'd be livable.;;;","07/Oct/12 14:50;blackdrag;if I want to define it through a range, then I still need getAt on the result. That means for List I would return a sublist and then use getAt on it to get those elements. If not, then you need some kind of RHS transformation again.;;;","07/Oct/12 16:45;justin.piper@gmail.com;Using {{getAt}} on the sublist seems okay to me.;;;","07/Oct/12 17:53;paulk;@Justin: it depends whether iter[0..2] returns a sublist or a sub-iterator. If the latter, then we have the same problem.;;;","07/Oct/12 18:03;paulk;@Jochen: re DGM#getAt(Iterator), if I was using a library which gave me a Fibonacci iterator, or a prime number iterator, and I want to find the n'th prime/Fib number then fibIter[n] would make sense. It might not be ideal style but I would expect to find it in use in Groovy code in the wild. Also, in terms of consistency, we provide DGM methods for Iterator nearly everywhere we provide one for Collections/Arrays etc. so a developer might expect to find getAt too. Also, while adding the toList() would be the simplest change - albeit more involved than the current ""macro"" approach, it wouldn't necessarily be efficient nor work with lazy/infinite generators, e.g. the prime/Fib iterator above may never finish and rely on you ""take""ing or ""getAt""ing a limited prefix. We could also document that we don't support such rhs values but changing the code to something like (pseudo code) ""rhs instanceof Iterator ? (rhs.hasNext() ? rhs.next() : null) : DGM#getAt(rhs, idx)"" would handle all cases ... just a lot more complex than what we currently have.;;;","07/Oct/12 18:04;justin.piper@gmail.com;Well, if it returned a sub-iterator then advancing the main iterator would also advance the sub-iterator, which seems like it'd be weird.;;;","07/Oct/12 18:12;paulk;It depends on how the sub-iterator was implemented. You could eagerly exhaust the original iterator at the point where the sub-iterator was created. Obviously needing a user of Groovy to know whether an eager or lazy implementation was in play increases the burden on that user; hence one of the reasons why Iterable was introduced in the Java libraries in the first place.;;;","01/Aug/22 02:16;githubbot;eric-milles opened a new pull request, #1756:
URL: https://github.com/apache/groovy/pull/1756

   Support multi-assign for `Stream` and `Iterator`.  Improve efficiency of multi-assign for types like `Set` and `Collection` which do not support direct indexing.
   
   Translate ""def (one,two) = rhs"" into (pseudo-code):
   ```groovy
   def iter = rhs.iterator(), first
   if (iter.hasNext() && (first = iter.next()) !== rhs) {
       def one = first
       def two = iter.hasNext() ? iter.next() : null
   } else {
     def one = rhs.getAt(0)
     def two = rhs.getAt(1)
   }
   ```
   
   https://issues.apache.org/jira/browse/GROOVY-10666
   https://issues.apache.org/jira/browse/GROOVY-5744


;;;","04/Aug/22 14:01;githubbot;blackdrag commented on PR #1756:
URL: https://github.com/apache/groovy/pull/1756#issuecomment-1205300751

   I don't see changes from double quotes to single quotes as formatting change, nor do I see a change from {} to {->} as such a change. So where any of these changes required for this code change to pass?


;;;","14/Aug/22 14:25;githubbot;paulk-asert commented on PR #1756:
URL: https://github.com/apache/groovy/pull/1756#issuecomment-1214388826

   On my list to look at tomorrow.


;;;","10/Oct/22 08:15;githubbot;daniellansun merged PR #1756:
URL: https://github.com/apache/groovy/pull/1756


;;;","10/Oct/22 08:15;githubbot;daniellansun commented on PR #1756:
URL: https://github.com/apache/groovy/pull/1756#issuecomment-1272942889

   Merged. Thanks.


;;;","10/Oct/22 09:20;githubbot;paulk-asert commented on PR #1756:
URL: https://github.com/apache/groovy/pull/1756#issuecomment-1273024773

   I'll probably revert this, I have an alternative implementation which I have spoken to Eric about but I have been too busy with ApacheCon to get my PR ready for review.


;;;","10/Oct/22 09:31;githubbot;daniellansun commented on PR #1756:
URL: https://github.com/apache/groovy/pull/1756#issuecomment-1273037841

   Got it.


;;;","10/Oct/22 15:51;githubbot;eric-milles commented on PR #1756:
URL: https://github.com/apache/groovy/pull/1756#issuecomment-1273516380

   @paulk-asert Instead of revert, can you just replace the ""multiple declaration or assignment"" block?  There are some other fixups, including new test cases that I'd like to keep.


;;;","10/Oct/22 19:45;githubbot;paulk-asert commented on PR #1756:
URL: https://github.com/apache/groovy/pull/1756#issuecomment-1273739193

   @eric-milles I'll see what I can do.


;;;",,,,,,,,,,,,,,,,,,,,,,,
Typed closure as a default parameter requires cast when method is TypeChecked,GROOVY-5743,12816496,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,04/Oct/12 11:11,22/Dec/12 01:10,14/Jul/23 06:00,20/Nov/12 04:49,2.0.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,Static Type Checker,,,0,,,,,,"If you have a typed Closure as a default parameter of a method ie:

{code}
@groovy.transform.TypeChecked
Integer a( String s, Closure<Integer> b={ String it -> it.length() } ) {
  b( s )
}

a( 'tim' )
{code}

You get the exception:

{quote}
[Static type checking] - Cannot return value of type java.lang.Object on method returning type java.lang.Integer -> java.lang.Integer
{quote}

The workaround is to either cast the return:

{code}
  (Integer)b( s )
{code}

Or stop using the default parameter:

{code}
@groovy.transform.TypeChecked
Integer a( String s ) {
  Closure<Integer> b={ String it -> it.length() }
  b( s )
}

a( 'tim' )
{code}
",,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-10-04 11:11:55.0,,,,,,,,,,"0|i2c4r3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic goes into infinite loop when handling self-referential generics,GROOVY-5742,12818513,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,paulk,,03/Oct/12 21:51,07/Apr/15 19:07,14/Jul/23 06:00,16/Jul/13 08:34,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,Static compilation,Static Type Checker,,,1,,,,,,"When using @CompileStatic or @TypeChecked the StaticTypeCheckingVisitor recursively calls itself on the following example:
{code}
abstract class Base<A extends Base<A>> {}
class Done extends Base<Done> { }
class Next<H, T extends Base<T>> extends Base<Next<H, T>> {
  H head; T tail
  static Next<H, T> next(H h, T t) { new Next<H, T>(head:h, tail:t) }
  String toString() { ""Next($head, ${tail.toString()})"" }
}
import static Next.*

@groovy.transform.CompileStatic
def foo() {
  Next<Integer, Next<String, Done>> x = next(3, next(""foo"", new Done()))
}

println foo() // => Next(3, Next(foo, Done@9b3ec2))
{code}
My real example is when using Functional Java's heterogeneous list classes but the above is a cut-down equivalent. The stack trace is:
{noformat}
java.lang.StackOverflowError
...
org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolve(StaticTypeCheckingVisitor.java:2836)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:2873)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolve(StaticTypeCheckingVisitor.java:2840)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:2873)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolve(StaticTypeCheckingVisitor.java:2840)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.fullyResolveType(StaticTypeCheckingVisitor.java:2873)
{noformat}
",,blackdrag,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 16 08:34:12 UTC 2013,,,,,,,,,,"0|i2bnf3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jul/13 08:34;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compile Ok but strange Exception at runtime using @CompileStatic,GROOVY-5741,12811616,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,lguzzon,lguzzon,03/Oct/12 16:30,04/Mar/14 16:31,14/Jul/23 06:00,29/Jan/14 09:11,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Static compilation,,,,0,,,,,,"I just compile the following code with Groovy 2.0.4 and OK but when running it I got an Exception.
If I remove ""@CompileStatic"" than all goes right at compile and run time.
Thanks for the time.

{code:title=groovyXPath.groovy|borderStyle=solid}
package groovy.test.xpath

import groovy.transform.CompileStatic

import javax.xml.xpath.XPath
import javax.xml.xpath.XPathConstants
import javax.xml.xpath.XPathFactory

@CompileStatic
class groovyXPath {

	static main(args) {
		XPath lXPath = XPathFactory.newInstance().newXPath()
		println(""Hello XPath: ${lXPath}"")
	}

}
{code}

Exception
""""""
Exception in thread ""main"" java.lang.IllegalAccessException: Class groovy.test.xpath.groovyXPath can not access a member of class javax.xml.xpath.XPathFactory with modifiers ""protected""
	at sun.reflect.Reflection.ensureMemberAccess(Unknown Source)
	at java.lang.Class.newInstance0(Unknown Source)
	at java.lang.Class.newInstance(Unknown Source)
	at groovy.test.xpath.groovyXPath.main(groovyXPath.groovy:13)
""""""","Windows XP
Groovy 2.0.4",blackdrag,lguzzon,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/Oct/12 16:30;lguzzon;groovyXPath.groovy;https://issues.apache.org/jira/secure/attachment/12723079/groovyXPath.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 29 09:11:17 UTC 2014,,,,,,,,,,"0|i2bzj3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Oct/12 01:15;blackdrag;You just have to love JVM Exception, they are telling so much to the user... sigh... anyway... the only protected member in the Factory class I found is the constructor without parameters. Groovy has a DGM method, that calls the constructor if you use Class#newInstance. Now I assume that CompileStatic does this as well, but it is wrong. Class based methods are supposed to be tried if no static match is found. Here it looks like the Class based method is preferred.;;;","29/Jan/14 09:11;melix;Can't reproduce on 2.2.1 nor {{master}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot use ASTTransformationCustomizer with TimedInterrupt,GROOVY-5740,12816524,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,driscoll,driscoll,02/Oct/12 18:33,15/Oct/15 18:19,14/Jul/23 06:00,22/Nov/13 08:37,1.8.6,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.1,,,,,,,0,,,,,,"The following code will fail:
{code}
def program = ""println 'hello world'; while(true) {;}""
def config = new CompilerConfiguration()
config.addCompilationCustomizers(new ASTTransformationCustomizer([value: 1L, unit: TimeUnit.MILLISECONDS],TimedInterrupt))
GroovyShell sh = new GroovyShell(config)
Script script = sh.parse(program)
System.out.println(script.run()) // fail here
{code}
With the exception:  
{noformat}
org.codehaus.groovy.classgen.ClassGeneratorException: Cannot generate bytecode for constant: MILLISECONDS of type: java.util.concurrent.TimeUnit$3
{noformat}
Per blackdrag, this is apparently a bug in line 197 of TimedInterruptableASTTransformation, which uses ConstantExpression when it should have used PropertyExpression.

As a result of this bug, the only TimeUnit available when using TimedInterrupt is TimeUnit.SECONDS, which is the default.  This is probably not too big of an issue for most uses, which is why I've set the priority to Minor.
",,driscoll,melix,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 22 08:37:08 UTC 2013,,,,,,,,,,"0|i2c07b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Oct/12 02:15;melix;As I commented on the thread (copy below), the problem is not on the {{TimedInterrupt}} AST transformation, but rather on the AST customizer, or the way it provides annotation values to the AST transformation. This is more a limitation. Hopefully, there's a simple workaround that you can find in the answer below:

In fact I think the problem relies in the way the AST transformation customizer passes arguments to the AST transformation. In that case, it creates a constant expression with the value ""MILLISECONDS"". The bytecode generator doesn't know how to generate bytecode for constants which are not of primitive type. Ideally, we should use an AST tree of the constants used in the customizer but we have the values...

As a workaround, here is what you can do:

{code}
import groovy.transform.TimedInterrupt
import java.util.concurrent.TimeUnit
import org.codehaus.groovy.control.CompilerConfiguration
import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer
import org.codehaus.groovy.ast.expr.ConstantExpression
import org.codehaus.groovy.ast.expr.PropertyExpression

def program = ""println 'hello world'; while(true) {;}""
def config = new CompilerConfiguration()
config.addCompilationCustomizers(new MyCustomizer(TimedInterrupt))
GroovyShell sh = new GroovyShell(config)
Script script = sh.parse(program)
System.out.println(script.run())  // <-- Fails here

@groovy.transform.InheritConstructors
class MyCustomizer extends ASTTransformationCustomizer {
    void setAnnotationParameters() {
        annotationNode.addMember('value', new ConstantExpression(1L, true))
        annotationNode.addMember('unit', new PropertyExpression(ClassHelper.make(TimeUnit), 'MILLISECONDS'))
    }
}
{code}
The idea is to create a custom subclass of the AST transformation customizer which sets the annotation parameters by itself.
;;;","22/Sep/13 03:38;pschumacher;Should this be closed?;;;","23/Sep/13 14:04;driscoll;I'd argue that it should remain open - it's a significant limitation, and will effect more than the TimedInterrupt annotation.

That there's an easy workaround isn't a reason to close it.;;;","22/Nov/13 08:37;melix;Fixed by GROOVY-6432;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
performance problem in DefaultGroovyMethods.removeAll(),GROOVY-5739,12818444,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,adriannistor,adriannistor,02/Oct/12 13:33,05/Apr/15 14:44,14/Jul/23 06:00,04/Oct/12 06:16,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.5,2.1.0-beta-1,,,,,0,,,,,,"There is a performance problem in ""DefaultGroovyMethods.removeAll"".
It appears in version 2.0.4 and also in the latest revision
(f8c7f25..).  I attached a JUnit test that exposes this problem and a
one-line patch (patchRemoveAll.diff) that fixes it.  On my machine,
for this test, the patch provides a 37X speedup.

Running the JUnit test for the un-patched version is, the output is:
Time is 2040

The output for the patched version is:
Time is 54

The problem is that the current implementation of ""removeAll"" calls:

""self.removeAll(Arrays.asList(items));""

which typically (e.g., java.util.AbstractCollection and thus most
collections) calls ""contains"" on the parameter (a list) for each
element in ""self"".  ""contains"" on a list has linear complexity, which
is very slow when called many times.

The patch uses a HashSet as a parameter, which has constant complexity
for ""contains"".

""DefaultGroovyMethods.retainAll"" has a similar problem.  I attached a
second patch for it (patchRetainAll.diff)",,adriannistor1,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"02/Oct/12 13:33;TestRemoveAll.java;https://issues.apache.org/jira/secure/attachment/12723003/TestRemoveAll.java","02/Oct/12 13:33;patchRemoveAll.diff;https://issues.apache.org/jira/secure/attachment/12722926/patchRemoveAll.diff","02/Oct/12 18:49;patchRemoveAllNumberAwareComparator.diff;https://issues.apache.org/jira/secure/attachment/12722372/patchRemoveAllNumberAwareComparator.diff","02/Oct/12 13:33;patchRetainAll.diff;https://issues.apache.org/jira/secure/attachment/12723032/patchRetainAll.diff","02/Oct/12 18:49;patchRetainAllNumberAwareComparator.diff;https://issues.apache.org/jira/secure/attachment/12721728/patchRetainAllNumberAwareComparator.diff",,,,5.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Thu Oct 04 06:16:29 UTC 2012,,,,,,,,,,"0|i2cm53:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"02/Oct/12 18:49;adriannistor;Looking at the current implementation of
""DefaultGroovyMethods.intersect"" and ""DefaultGroovyMethods.disjoint"",
I see these methods avoid O(N^2) complexity by using a TreeSet with a
NumberAwareComparator.  The final code fix for GROOVY-4606 had a
similar solution.

I attached new patches for ""removeAll"" and ""retainAll""
(patchRemoveAllNumberAwareComparator.diff and
patchRetainAllNumberAwareComparator.diff).  Similarly to
""DefaultGroovyMethods.intersect"" and ""DefaultGroovyMethods.disjoint"",
my new patches avoid O(N^2) complexity by using a TreeSet with a
NumberAwareComparator.;;;","04/Oct/12 06:16;paulk;Second patch applied. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The if(instanceof) block is not inferring type in a Closure,GROOVY-5738,12816542,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,chanwit,chanwit,02/Oct/12 09:45,22/Dec/12 01:10,14/Jul/23 06:00,29/Nov/12 03:34,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.0-beta-1,,,Static compilation,,,,0,,,,,,"I expect these classes to be compiled but it won't.

{code}
import groovy.transform.*

@CompileStatic
class Greeting implements Serializable {
    String who
}
{code}

{code}
import groovy.transform.*

@CompileStatic
class GreetingActor {

  def receive = {
    if(it instanceof Greeting) {
        println ""Hello ${it.who}""
    }
  }

}
{code}

The type of variable ""it"" in the Closure receive should be inferred as type Greeting. To reproduce call

$ groovyc Greeting.groovy GreetingActor.groovy

Thank you.",,chanwit,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 28 09:05:18 UTC 2012,,,,,,,,,,"0|i2c1u7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Oct/12 09:47;chanwit;It's quite a show-stopper when trying to use Groovy2 with Akka :);;;","21/Nov/12 12:21;melix;Actually, there's something wrong with the example, because the {{it}} in the {{instanceof}} line is not the same as the {{it}} in the closure. This is something very special with Groovy that makes a special scope resolution in that case. As a workaround, you can do:

{code}
@CompileStatic
class GreetingActor {

  def receive = {
    if(it instanceof Greeting) {
        println ""Hello ${Greeting g -> g.who}""
    }
  }

}
{code};;;","28/Nov/12 08:01;chanwit;Hi Cedric,

Thank you for looking into this issue.

Your comment above is a bit incorrect. I expected that {{it}} in the {{instanceof}} is the same one down there. What you've missed here is that {{it}} in {{println}} is nothing related to a Closure. The expression a Groovy String interpolation.;;;","28/Nov/12 09:05;melix;mmm yes, and my workaround is far from being one, it cannot work at all. I need new brain cells :D;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"@Log won't compile with @CompileStatic if ""log"" is used in a Closure",GROOVY-5737,12816469,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,chanwit,chanwit,02/Oct/12 09:34,22/Dec/12 01:10,14/Jul/23 06:00,28/Nov/12 07:41,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.0-beta-1,,,Static compilation,,,,0,,,,,,"The log variable injected by the @Log annotation is not compiled if it's used inside a Closure.

{code}
import groovy.transform.*
import groovy.util.logging.*

@Log
@CompileStatic
class GreetingActor {

  def receive = {
    log.info ""test""
  }

}
{code}",,chanwit,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 28 07:41:09 UTC 2012,,,,,,,,,,"0|i2bxi7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"02/Oct/12 09:37;chanwit;To reproduce, simply call

$ groovyc GreetingActor.groovy

Thank you.
;;;","22/Nov/12 08:01;melix;There are two problems in one here:
* first, 'log' is a generated field which is marked as synthetic, and we do not generate bridge methods for synthetic fields
* second, 'log' is used in a closure, which is not an inner class at the phase the static compilation visitor is run, so bridge methods are not generated at all

Fixing this requires a rework on how we keep track of private field and private method calls from inner classes or closures.;;;","28/Nov/12 07:41;melix;Solved by having the type checker track access to private fields/methods, then the static compiler will only generate bridges for those fields/methods.

As it is a change in the way bridges are created, I will not port it to {{2.0.6}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Log4j, Commons, Slf4j ast transforms are broken in Groovy-Eclipse",GROOVY-5736,12811923,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,werdna,werdna,01/Oct/12 15:04,03/Feb/22 22:29,14/Jul/23 06:00,19/Dec/21 20:50,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.16,3.0.10,4.0.0-rc-2,Compiler,,,,0,,,,,,"Since Groovy-Eclipse moved to using the 2.0.4 compiler, the @Log4j and other log ast transformations are crashing the compiler.  This is because in GROOVY-5574, there was a move to call {{Class.forName()}} in the Log AST transformation.  In Groovy-Eclipse, you cannot use Class.forName since the classpath of the project is not on the classpath of the compiler.

The workaround is to change {{org.codehaus.groovy.transform.LogASTTransformation.AbstractLoggingStrategy.classNode(String)}}.  Instead of throwing a {{GroovyRuntimeException}}, you could simply call and return {{ClassHelper.make(name);}}. 

I know this adds code that was removed to fix GROOVY-5574, but for Groovy-Eclipse this is safe since {{ClassHelper.make(name);}} will correctly use the project's class path to generate the ClassNode and classloader issues will not happen.

If you think that this solution is not a good one because of problems that could occur outside of eclipse, then we could talk about a different solution.",,blackdrag,emilles,lhotari,melix,pschumacher,szpak,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 19 20:50:31 UTC 2021,,,,,,,,,,"0|i2cenz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Oct/12 03:37;melix;There is a problem with this approach: currently, the compiler throws an error because it you do not do so, you have a dummy class node created, which doesn't have all the expected methods. It results in errors which are difficult to understand for the end user. Throwing an exception, we tell the user that the Log4J/whatever framework is not on classpath, so the annotation cannot be run.

There are several issues like this that are specific to Groovy Eclipse that we might solve using some kind of indirection: class node comparisons, class node providers or fallbacks. For example, instead of throwing an exception, we could add one level of indirection:

{code}ClassNodeToolingFactory.getInstance().generateFallbackClassNode(name){code}

which would for regular Groovy throw an error, but in Eclipse, it could return a ClassNode.

The same for class node comparators:

{code}ClassNode comparator = ClassNodeToolingFactory().getInstance().getClassNodeComparator();
if (comparator.areEqual(cn1, cn2)) { ... } // instead of cn1.equals(cn2)
if (comparator.areSame(cn1, cn2)) { ... } // instead of cn1==cn2
{code}

Just a thought... The problem with this strategy is of course that I can't see any other use case than Eclipse for that.;;;","02/Oct/12 04:41;blackdrag;to my better understanding... there is the transform loader, which should know the slf4j stuff to create the right nodes and there is the classpath for program dependencies. From the text above I read, that the transform loader is equal to the other loader and that slf4 is supposed to be provided through different means. Is that right? If yes, then the situation is quite a mess imho

Anyway... I added this ClassNodeResolver facility. Can't we use that here instead? Imho it is a bit wrong, since the ClassNodeResolver is for resolving dependencies, that have nothing to do with the transform, but it allows our eclipse guys to do whatever they want to do and we just get back a ClassNode.;;;","02/Oct/12 05:08;melix;I don't know if I understand you properly, but the problem is not really the transform loader. The transform loader will know about {{@Log4j}} or {{@Slf4j}}, but when the transform is run, we must have the Log4J or SLF4J classes on classpath to be able to build a valid class node. Here, the transform uses the classloader of the source unit.;;;","02/Oct/12 07:41;blackdrag;I guess I am a bit confused... The problem occured because there was a move to Class#forName says Andrew. But it is not the String version, it is the version, that takes a class loader. So if the class is not found, it first means the wrong loader is used.

What was used before was the transform loader, because of Class#forName in the static constructor. What is used now is the compilation loader, the one from the SourceUnit. The earlier fallback was to use a dummy node, but that does not work because of GROOVY-5574. If a ClassNode is added to the AST and the ClassNode is already resolved, then the compiler does not care about where the class comes from and does not try to resolve it at all.

That's why I see two paths here:
(1) use the transform loader, not the compilation loader, to produce a resolved ClassNode. That way it works as long as the transform loader knows those classes. Going this path may cause similar errors like in GROOVY-5574, because it is unclear to me why it even happened. There the transform loader should have been used and it obviously didn't know the Logger class. This would need further investigation.
(2) use a dummy always and have the logger implementation classes resolved through the resolving step. 

And if I look at the implementation before it was a mix of both. The problem for me in GROOVY-5574 therefore should have been, that neither the compilation, nor the transform loader did know the Logging class, otherwise one or the other would have catched it. Only that it makes no sense like that, unless the logger actually runs after the resolving, in which case using a dummy is always wrong. but that is not the case. So if both don't know the class, then it is 100% clear, why using @Grab with systemClassLoader=true resolved the issue in GROOVY-5574. Through this a parent loader gained knowledge of that class, thus now both loaders are able to use it. 

;;;","05/May/13 06:50;pschumacher;@Andrew: Any input on this or can this issue be closed?;;;","06/May/13 00:15;werdna;In Groovy-Eclipse, we have patched around this issue and everything works for us. It would be nice if groovy core could take the patch, but Jochen still ahs reservations as described above.  Here is the {{LogASTTransformation.AbstractLoggingStrategy.classNode(String)}} method in groovy-Eclipse:

{code}
        protected ClassNode classNode(String name) {
            ClassLoader cl = loader==null?this.getClass().getClassLoader():loader;
            try {
                return ClassHelper.make(Class.forName(name, false, cl));
            } catch (ClassNotFoundException e) {
                // GRECLIPSE: old
                /*
                throw new GroovyRuntimeException(e);
                new*/
                // See https://jira.codehaus.org/browse/GROOVY-5736
                // don't throw an exception, rather just make the class from text
                return ClassHelper.make(name);
                //end
                //GRECLIPSE
            }
        }
{code}

So, essentially, if the loggers are not able to be created, we avoid throwing an exception and just create a dummy class.  At compile time, I believe this would work fine, but for compiling a script dynamically, this would cause problems. 

The problem might lie in the fact that in greclipse vs groovy the class loaders are constructed differently and so it might be that the logger classes are coming from a different loader in greclipse compared to in groovy.;;;","27/Nov/19 16:19;emilles;Patch still exists in groovy-eclipse: https://github.com/groovy/groovy-eclipse/blob/aa050514e34591f950f1ac177bff87db15354ee0/base/org.codehaus.groovy30/src/org/codehaus/groovy/transform/LogASTTransformation.java#L347;;;","19/Dec/21 20:50;emilles;https://github.com/apache/groovy/commit/aadf2cc3bcee94fa342f957c6afc85060ab55094;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Static type checking error when calling a method with generics that receives a Class<T> and a T object, and the instantiation of T is a parametric type",GROOVY-5735,12816560,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,rcruzjo,rcruzjo,01/Oct/12 09:17,22/Dec/12 01:10,14/Jul/23 06:00,23/Nov/12 09:43,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static Type Checker,,,,3,,,,,,"If I have the following code:

{code}
@groovy.transform.CompileStatic
class MyClass {

   public <T> void someMethod (java.lang.Class<T> clazz, T object) {}

   void method() {
      List<String> list = null
      someMethod(java.util.List.class, list)  
   }
}

new MyClass().method()
}
{code}

it throws this error [Static type checking] - Cannot call MyClass#someMethod(java.lang.Class <T>, java.lang.Object <T>) with arguments [java.lang.Class <java.util.List>, java.util.List <String>]


The issue here is that T is being inferred as List<String>, therefore it expects to have a Class<List<String>> (which cannot be constructed).
If instead T becomes just List, a raw type will be used in the second argument, and it should work.

As an additional note, this example used to work in Groovy 2.0.0",,ariel.andres.morelli,ebergama,r.patzelt,rcruzjo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"01/Oct/12 09:17;rcruzjo;MyClass.groovy;https://issues.apache.org/jira/secure/attachment/12722173/MyClass.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 17 07:35:16 UTC 2012,,,,,,,,,,"0|i2catb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Oct/12 07:35;r.patzelt;The same problem occurs if you create the method node yourself.

Problem scenarion:
||Summary||Description||
|method missing params|methodMissing called on 
receiver: 'net.eads.astrium.aits.groovy.unitdsl.measure.Measure <javax.measure.quantity.Length> -> net.eads.astrium.aits.groovy.unitdsl.measure.Measure <Q extends javax.measure.quantity.Quantity>' 
method name: 'plus'
arguments: '[net.eads.astrium.aits.groovy.unitdsl.measure.Measure <javax.measure.quantity.Length> -> net.eads.astrium.aits.groovy.unitdsl.measure.Measure <Q extends javax.measure.quantity.Quantity>'|
|MethodNode creation|new MethodNode(name,Opcodes.ACC_PUBLIC,receiver,[new Parameter(args[0], ""param1"")] as Parameter[], ClassNode.EMPTY_ARRAY,null)|
|error|[Static type checking] - Cannot call net.eads.astrium.aits.groovy.unitdsl.measure.Measure#plus(net.eads.astrium.aits.groovy.unitdsl.measure.Measure <javax.measure.quantity.Length>) with arguments [net.eads.astrium.aits.groovy.unitdsl.measure.Measure <javax.measure.quantity.Length>]|
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Ternary operator returning null fails with static type checking,GROOVY-5734,12816540,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,rcruzjo,rcruzjo,01/Oct/12 08:13,17/Jul/15 07:13,14/Jul/23 06:00,21/Nov/12 11:50,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,2,,,,,,"If I define:

{code}
@groovy.transform.CompileStatic
Integer someMethod() {
    (false) ? null : 8
}
{code}

this throws the following error:

[Static type checking] - Cannot return value of type java.lang.Object on method returning type java.lang.Integer -> java.lang.Integer ",,ariel.andres.morelli,ebergama,mauromol,melix,rcruzjo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"01/Oct/12 08:13;rcruzjo;someMethod.groovy;https://issues.apache.org/jira/secure/attachment/12722541/someMethod.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 17 07:13:32 UTC 2015,,,,,,,,,,"0|i2bojz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Oct/12 09:17;ariel.andres.morelli;This worked well in Groovy 2.0.0;;;","16/Jul/15 14:07;mauromol;This fails again in Groovy 2.4.3/2.4.4, while it didn't fail in Groovy 2.3.11:

{code:title=Bar.java}
package test2;

public class Bar {
}
{code}

{code:title=Foo.java}
package test2;

public class Foo {
	private Bar bar;
	
	public void setBar(Bar bar) {
		this.bar = bar;
	}
	
	public Bar getBar() {
		return bar;
	}
}
{code}

{code:title=Test.groovy}
package test2

import groovy.transform.CompileStatic;

@CompileStatic
public class Test {
	void test() {
		boolean check = true
		Foo foo = new Foo()
		foo.bar = check? new Bar(): null
	}
}
{code}

The assignment to {{foo.bar}} fails with:{{Cannot assign value of type java.lang.Object to variable of type test2.Bar}}.;;;","16/Jul/15 20:43;melix;I'm not sure it is the same issue. Would you mind creating a new ticket? Does it happen if Foo is not written in Java ?;;;","17/Jul/15 07:13;mauromol;Hi Cédric, I created GROOVY-7507. It fails even if {{Foo}} is written in Groovy instead of Java.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"JsonBuilder toPrettyString gen ""\""\"""" for emtyString it should be """"",GROOVY-5733,12816552,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,chokchai,chokchai,01/Oct/12 05:54,18/Jan/13 16:06,14/Jul/23 06:00,17/Jan/13 23:43,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.7,2.1.0,2.1.0-rc-2,JSON,,,,0,,,,,,"{code}
      def builder = new groovy.json.JsonBuilder()
        def root = builder.people {
            firstName 'Guillame'
            lastName 'Laforge'
            married true
            conferences 'JavaOne', 'Gr8conf'
            blank ''
        }
        println builder.toString()
        println builder.toPrettyString()

        String s = '""""'
        println ""$s""
        println ""${s[1..-2]}""
        println ""${StringEscapeUtils.escapeJava(s[1..-2])}""
{code}

output
{code}
{""people"":{""firstName"":""Guillame"",""lastName"":""Laforge"",""married"":true,""conferences"":[""JavaOne"",""Gr8conf""],""blank"":""""}}
{
    ""people"": {
        ""firstName"": ""Guillame"",
        ""lastName"": ""Laforge"",
        ""married"": true,
        ""conferences"": [
            ""JavaOne"",
            ""Gr8conf""
        ],
        ""blank"": ""\""\""""
    }
}
""""
""""
\""\""
{code}


I think there is a bug on file ""D:\groovy-src-2.0.4\groovy-2.0.4\subprojects\groovy-json\src\main\groovy\groovy\json\JsonOutput.groovy""

line 190-192
{code}
     } else if (token.type == STRING) {
                output.append('""' + StringEscapeUtils.escapeJava(token.text[1..-2]) + '""')
{code}
",window 7,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"01/Oct/12 06:06;chokchai;testString1.groovy;https://issues.apache.org/jira/secure/attachment/12723031/testString1.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 17 23:43:08 UTC 2013,,,,,,,,,,"0|i2bvwv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jan/13 23:43;paulk;pull request #113 applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Delegating to an abstract class hierarchy doesn't implement interfaces at a higher level,GROOVY-5732,12816558,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,prajnainc,prajnainc,28/Sep/12 11:27,04/Oct/12 17:02,14/Jul/23 06:00,29/Sep/12 02:17,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.5,2.1.0-beta-1,command line processing,,,,0,@Delegate,delegation,,,,"Given:
{code}
public interface Field {	
	public void aFieldMethod();
}
{code}
and the classes:
{code}
public abstract class AbstractBaseClass implements Field {
}

public abstract class DelegatedClass extends AbstractBaseClass {
}

class Delegator {
	@Delegate private DelegatedClass delegate
}
{code}
then
{code}
assert Field.isAssignableFrom(Delegator)
{code}
fails. If Delegator is defined as
{code}
class Delegator {
	@Delegate private AbstractBaseClass delegate
}
{code}
the test succeeds
","Mac OS X 10.6.8, Eclipse 3.7",paulk,prajnainc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Sep/12 11:27;prajnainc;AbstractBaseClass.java;https://issues.apache.org/jira/secure/attachment/12723002/AbstractBaseClass.java","28/Sep/12 11:27;prajnainc;DelegatedClass.java;https://issues.apache.org/jira/secure/attachment/12723078/DelegatedClass.java","28/Sep/12 11:27;prajnainc;DelegationTest.groovy;https://issues.apache.org/jira/secure/attachment/12722922/DelegationTest.groovy","28/Sep/12 11:27;prajnainc;Delegator.groovy;https://issues.apache.org/jira/secure/attachment/12722174/Delegator.groovy","28/Sep/12 11:27;prajnainc;Field.java;https://issues.apache.org/jira/secure/attachment/12722371/Field.java",,,,5.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Sep 29 02:17:57 UTC 2012,,,,,,,,,,"0|i2cogn:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"29/Sep/12 02:17;paulk;Yes, it was indeed a bug. Thanks for spotting the problem.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
array given spreaded to doCall method if EMC is enabled,GROOVY-5730,12816521,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,blackdrag,blackdrag,28/Sep/12 07:44,04/Oct/12 17:02,14/Jul/23 06:00,28/Sep/12 10:16,1.8.8,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.5,,,,,,0,,,,,,"{code:Java}
ExpandoMetaClass.enableGlobally()
Object[] item = [1]
def cl = {assert it.class == Object[]}
cl(item){code}
The code above fails, the item array is given to the doCall method as if it was spread. The reason is that if ClosureMetaClass is active we invoke the doCall metho, but EMC uses call(Object[]) here. Since call(Object[]) basically just makes a call to doCall with the arguments spread, we get the wrong result above. Without EMC it is working of course.

This issue is strongly related to http://jira.grails.org/browse/GRAILS-9443. The issue there surfaced because of the introduction of BooleanClosureWrapper, but the issue described here is the underlaying problem to the other issue.",,blackdrag,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 28 10:16:55 UTC 2012,,,,,,,,,,"0|i2cspr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Sep/12 10:16;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Delegation to an  interface with deprecated methods shows a compile error,GROOVY-5729,12811960,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,prajnainc,prajnainc,28/Sep/12 07:36,04/Oct/12 17:02,14/Jul/23 06:00,30/Sep/12 02:15,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.5,2.1.0-beta-1,Compiler,,,,0,,,,,,"Given an interface:
{code}
public
interface DeprecatedMethods {

    @Deprecated
    public void setHeight(float height);

}
{code}
and a delegating class:
{code}
class DelegateDeprecated {
	
    @Delegate	
    private DeprecatedMethods delegate
	
}
{code}
then the compiler shows a compilation error:
{panel}
$ groovyc DelegateDeprecated.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
DelegateDeprecated.groovy: 15: Can't have an abstract method in a non-abstract class. The class 'DelegateDeprecated' must be declared abstract or the method 'void setHeight(float)' must be implemented.
 @ line 15, column 1.
   class DelegateDeprecated {
   ^

1 error
{panel}
This happens from the command line and Eclipse, and can be made to go away by removing the @Deprecated annotation.

","Max OS X 10.6.8, Mac Java, Eclipse 3.7",blackdrag,paulk,prajnainc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 30 02:15:07 UTC 2012,,,,,,,,,,"0|i2cu7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Sep/12 02:26;paulk;So unless I hear otherwise, I will change the implementation and doco to indicate that the ""deprecated"" annotation member will be ignored if the delegation type is an interface and the ""interfaces"" member is not false.

As an aside (for a different issue/discussion) I wonder whether the ""types"" and ""excludes"" options provided by project Lombok's @Delegate would give additional finer grained control of delegated methods.;;;","29/Sep/12 03:28;blackdrag;Paul, does that mean you want the example above to pass compilation or not?;;;","29/Sep/12 04:50;paulk;There are four obvious solutions that I can see:
(1) leave implementation as is and improve the doco so such errors are perhaps less confusing
(2) make above case fail but with an improved error message; though we currently don't verify until a later stage so this could be tricky and/or involve duplicating checks
(3) make the above case pass by always ignoring the ""deprecated"" setting for interfaces (but perhaps we would need another flag to really turn it off when not required, i.e. when not implementing the interfaces)
(4) make the above case pass by ignoring the ""deprecated"" setting for interfaces but only when implementing the interface, i.e. don't ignore if interfaces=false has been set.

I am proposing (4) which would make the above pass and have the deprecated method (as well as implementing the interface). If you set interfaces=false it would also pass and not have the deprecated method. If you set interfaces=false and deprecated=true it would also pass, not implement the interface but would have the method. You would still get the existing error message if you set interfaces=false, didn't set deprecated=true and manually implemented the interface - but that seems to me to be less unexpected in that case because hopefully someone using those options would be very familiar with the various options and how they interact.
;;;","29/Sep/12 07:27;paulk;Proposed patch:
{code}
--- src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java	(revision 489913f60f5e9b1504aed1898e9b9ead84f62489)
+++ src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java	(revision )
@@ -77,7 +77,9 @@
                 fieldMethods.addAll(getAllMethods(next));
             }
             final Expression deprecatedElement = node.getMember(""deprecated"");
-            final boolean deprecated = hasBooleanValue(deprecatedElement, true);
+            final Expression interfacesElement = node.getMember(""interfaces"");
+            boolean skipInterfaces = hasBooleanValue(interfacesElement, false);
+            final boolean deprecated = hasBooleanValue(deprecatedElement, true) || (type.isInterface() && !skipInterfaces);
 
             final List<MethodNode> ownerMethods = getAllMethods(owner);
             for (MethodNode mn : fieldMethods) {
@@ -92,8 +94,7 @@
                 addSetterIfNeeded(fieldNode, owner, prop, name);
             }
 
-            final Expression interfacesElement = node.getMember(""interfaces"");
-            if (hasBooleanValue(interfacesElement, false)) return;
+            if (skipInterfaces) return;
 
             final Set<ClassNode> allInterfaces = getInterfacesAndSuperInterfaces(type);
             final Set<ClassNode> ownerIfaces = owner.getAllInterfaces();
{code}
plus doco/tests;;;","29/Sep/12 17:53;prajnainc;Paul, to confirm, (4) is exactly the behavior I would expect. Thanks for the swift response;;;","30/Sep/12 02:15;paulk;Option (4) applied. Thanks for raising the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Accessing private constructor from a static factory,GROOVY-5728,12818437,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,paulk,,28/Sep/12 04:23,31/Jan/22 18:01,14/Jul/23 06:00,24/Mar/21 14:14,2.0.4,2.4.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.16,3.0.8,4.0.0-alpha-3,groovy-runtime,,,,0,,,,,,"The following code works fine from Java but fails in Groovy:
{code}
public abstract class FooMain {
    private FooMain() {}
    public abstract String bar();
    public static FooMain factory() {
      return new FooMain() {
        public String bar() { return ""xxx""; }
      };
    }
    public static void main(String[] args) {
        System.out.println(factory().bar());
    }
}
// => java.lang.IllegalAccessError: tried to access method FooMain.<init>()V from class FooMain$1
{code}
",,daniel_sun,emilles,jwagenleitner,paulk,petermyren,,,,,,,,"eric-milles opened a new pull request #1530:
URL: https://github.com/apache/groovy/pull/1530


   https://issues.apache.org/jira/browse/GROOVY-5728


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Mar/21 15:52;githubbot;600","danielsun1106 merged pull request #1530:
URL: https://github.com/apache/groovy/pull/1530


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;24/Mar/21 14:06;githubbot;600","danielsun1106 commented on pull request #1530:
URL: https://github.com/apache/groovy/pull/1530#issuecomment-805851535


   Merged. Thanks!


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;24/Mar/21 14:07;githubbot;600",,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 19 15:48:10 UTC 2021,,,,,,,,,,"0|i2bodr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Feb/17 12:31;petermyren;Same problem with static nested class.
{code}
public abstract class FooMain {
    private FooMain() {}
    public abstract String bar();
    public static FooMain factory() {
      return new FooMainNested();
    }
    public static void main(String[] args) {
        System.out.println(factory().bar());
    }
    
   private static class FooMainNested extends FooMain{
        public String bar() { return ""xxx""; }
   }
}

{code}
This is expected, since nested static classes can't access private variables and methods. But, this also fails:
{code}
public class FooMain {

    private FooMain() {}

    public String bar(){return null;}

    public static FooMain factory() {
        return new FooMainNested(new FooMain());
    };

    public static void main(String[] args) {
        System.out.println(factory().bar());
    }

    private class FooMainNested extends FooMain{

        @Override
        public String bar() {
            return ""xxx"";
        }
    }

}
{code}

It woks with protected constructor though.
{code}
public abstract class FooMain {
    protected FooMain() {}
    public abstract String bar();
    public static FooMain factory() {
      return new FooMain() {
        public String bar() { return ""xxx""; }
      };
    }    
    public static void main(String[] args) {
        System.out.println(factory().bar());
    }   
}
{code}

Tested with groovy 2.4.8;;;","19/Mar/21 15:48;emilles;See also GROOVY-6747;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Source locations of command chain expressions,GROOVY-5726,12818193,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,werdna,werdna,25/Sep/12 16:23,23/Jul/22 16:17,14/Jul/23 06:00,07/Feb/22 18:18,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,3.0.10,4.0.1,,Compiler,,,,0,,,,,,"Source locations of command chain expressions are incorrect.  Consider the  following snippet (no whitespace before or after expression):

{code}foo bar baz{code}

Type that into the groovyConsole and inspect the AST. Expand a few sections and see that the {{this.foo(bar)}} method call has a {{columnNumber}} of 5, whic is incorrect.  Expand one more level and see that the {{foo}} constant expression has a {{columnNumber}} of 1, which is correct.

In Groovy-Eclipse, we have put a bit of a kludgy patch in to make it work.  At the end of the {{methodCallExpression(AST)}} method, immediately before the return statement, we added this text:

{code}
        // in the case of Groovy 1.8 command expressions, the slocs are incorrect for the start of the method
        if (!implicitThis && methodCallNode.getText().equals(""<command>"")) {
            ret.setStart(objectExpression.getStart());
            ret.setLineNumber(objectExpression.getLineNumber());
            ret.setColumnNumber(objectExpression.getColumnNumber());
            ret.setEnd(arguments.getEnd());
            ret.setLastLineNumber(arguments.getLastLineNumber());
            ret.setLastColumnNumber(arguments.getLastColumnNumber());
        }
{code}

I'm not particularly happy with this solution, but it works for us.  Perhaps you can come up with something better.",,blackdrag,emilles,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 07 18:18:56 UTC 2022,,,,,,,,,,"0|i2cs4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Sep/12 01:38;blackdrag;The baz part is correct? and ""foo1 bar1 foo2 bar2"" shows a correct position for the second part as well?;;;","26/Sep/12 10:58;werdna;Looks like the problem is with the MethodCallExpression that has the implicitThis.;;;","07/Feb/22 18:18;emilles;https://github.com/apache/groovy/commit/72ecf0a2eb4d055fc7d406fe2f239d06eaeb8df7;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy classes with @CompileStatic cannot use constants declared on an interface,GROOVY-5725,12816577,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,bborchardt,bborchardt,25/Sep/12 11:55,22/Dec/12 01:10,14/Jul/23 06:00,22/Nov/12 03:22,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"Compile the class below and you'll get the following compilation error:

[Static type checking] - The variable [myStringConstant] is undeclared.


import groovy.transform.CompileStatic

interface MyInterface {
	String myStringConstant = 'STRING'

	String myMethod()
}

@CompileStatic
class MyClass implements MyInterface {
	@Override String myMethod() {
		myStringConstant
	}
}
","Using JDK 6, Groovy 2.0.4.",bborchardt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"25/Sep/12 11:56;bborchardt;MyClass.groovy;https://issues.apache.org/jira/secure/attachment/12723001/MyClass.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-09-25 11:55:14.0,,,,,,,,,,"0|i2c5j3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"@TypeChecked and JUnit Test using assertThat(myTestResult, notNullValue()",GROOVY-5724,12818191,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,peti,peti,25/Sep/12 02:55,22/Dec/12 01:10,14/Jul/23 06:00,26/Nov/12 07:34,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static Type Checker,,,,0,,,,,,"This worked with Groovy 2.0.0, with 2.0.4 it doesn't 
(where is your test coverage?) ;-)

{code}
package groovy.bugs.typechecker

import static org.hamcrest.CoreMatchers.*
import static org.junit.Assert.*
import groovy.transform.TypeChecked

@TypeChecked
class AssertNotNullTypecheckerBugTest {

	@org.junit.Test
	public void sometest() throws Exception {
		// act
		String result = '12345'.substring(2)
		// assert
		assertThat(result, notNullValue())
		assertEquals('345', result)
	}
}
{code}

I get the following error in Eclipse
{code}
Description	Resource	Path	Location	Type
Groovy:[Static type checking] - Cannot call org.junit.Assert#assertThat(java.lang.Object <T extends java.lang.Object>, org.hamcrest.Matcher <T extends java.lang.Object>) with arguments [java.lang.String, org.hamcrest.Matcher <T extends java.lang.Object>] 	AssertNotNullTypecheckerBugTest.groovy	/GroovyBugs/src/groovy/bugs/typechecker	line 15	Java Problem
{code}

-> The eclipse project containing this sample is attached.
","Windows 7
Eclipse Juno
Groovy Eclipse 2.7.1",peti,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"25/Sep/12 02:55;peti;GroovyBugsEclipseProject.zip;https://issues.apache.org/jira/secure/attachment/12722925/GroovyBugsEclipseProject.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-09-25 02:55:00.0,,,,,,,,,,"0|i2cpbb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem with cached calls with GroovyServlet,GROOVY-5723,12816509,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,guillaume,guillaume,guillaume,24/Sep/12 09:56,04/Oct/12 17:02,14/Jul/23 06:00,25/Sep/12 09:51,1.8.8,2.0.2,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.5,2.1.0-beta-1,Groovlet / GSP,GroovyScriptEngine,,,0,,,,,,"A couple users reported problems since Groovy 2.0.2 with the GroovyServlet:
https://github.com/glaforge/gaelyk/issues/163

When using Gaelyk on Google App Engine, they noticed that the first hit for a certain groovlet would run fine, while all subsequent calls would fail.

This problem started appearing after the changes operated on GROOVY-5125 which fixed an issue when using scripts stored in a JAR with GroovyScriptEngine.

This problem can be fixed by amending AbstractHttpServlet.",Google App Engine with the Gaelyk framework,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 25 09:45:52 UTC 2012,,,,,,,,,,"0|i2cfx3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Sep/12 09:45;guillaume;I haven't managed yet to make a failing test case to assert that my changes work, beyond the manual testing I've done in the context of Gaelyk.

The following test cases passes with and without the changes that fix the problem:
{code}
package groovy.servlet

import javax.servlet.ServletConfig
import javax.servlet.ServletContext
import javax.servlet.http.HttpServletRequest
import javax.servlet.http.HttpServletResponse

class Groovy5723Test extends GroovyTestCase {

    void testSubsequentHitsFailing() {
        def groovletFile = File.createTempFile('myGroovlet', '.groovy')
        groovletFile << ''' out << ""Hello Groovy World!"" '''

        def ctxt = [
                log: { String msg -> println ""LOG: $msg"" },
                getRealPath: { String path ->
                    println ""getRealPath($path)""
                    if (path == '/') {
                        groovletFile.getParent()
                    } else if (path.contains('BeanInfo')) {
                        return null
                    } else {
                        groovletFile.absolutePath
                    }
                },
                getResource: { String name ->
                    println ""getResource($name)""
                    if (name.contains('BeanInfo')) {
                        return null
                    } else {
                        return groovletFile.toURI().toURL()
                    }
                }
        ] as ServletContext

        def conf = [
                getServletContext: { -> ctxt},
                getInitParameter: { String p -> null }
        ] as ServletConfig

        def request = [
                getAttribute: { String attr -> },
                getServletPath: { -> """" },
                getPathInfo: { -> ""/myGroovlet.groovy"" },
                getSession: { boolean b -> null },
                getHeaderNames: { -> [hasMoreElements: { -> false}, nextElement: { -> null }] as Enumeration },
                getParameterNames: { -> [hasMoreElements: { -> false}, nextElement: { -> null }] as Enumeration }
        ]

        def output = new StringWriter()

        def response = [
                setContentType: { String ct -> },
                sendError: { int code, String msg -> println ""Error $code: $msg""},
                getWriter: { ->
                    output = new StringWriter()
                    new PrintWriter(output)
                }
        ]


        def servlet = new GroovyServlet()
        servlet.init(conf)

        servlet.service(request as HttpServletRequest, response as HttpServletResponse)

        assert output.toString() == ""Hello Groovy World!""

        servlet.service(request as HttpServletRequest, response as HttpServletResponse)

        assert output.toString() == ""Hello Groovy World!""

        groovletFile.delete()
    }
}
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovyc assumes wrong return type when concrete class derived from generic,GROOVY-5721,12816438,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,boaznahum,boaznahum,24/Sep/12 04:56,22/Dec/12 01:10,14/Jul/23 06:00,26/Nov/12 06:12,2.0.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static compilation,,,,0,,,,,,"When a concrete class (MyList) extends  generic one (ArrayList<T>), Groovyc behave like base class is RAW type (T is summed to be obejct)

Example:

{code}
public class MyList extends ArrayList<Double> {}
{code}

{code}
@CompileStatic
  public static void f() {

    List<Double> list1 = new ArrayList<Double>();

    // OK
    Double d1 = list1.get(0);

    //---------------------------

    List<Double> list2 = new MyList<>();

    //Groovyc: [Static type checking] - Cannot assign value of type java.lang.Object to variable of type java.lang.Double
    Double d2 = list2.get(0);

    //---------------------------

    MyList list3 = new MyList();

    //Groovyc: [Static type checking] - Cannot assign value of type java.lang.Object to variable of type java.lang.Double
    Double d3 = list3.get(0);
  }
{code}",JDK 1.7.0_04,boaznahum,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-09-24 04:56:21.0,,,,,,,,,,"0|i2c28f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static Typechecking of Comparison Operations (e. g. '<') Not Strict Enough,GROOVY-5720,12816553,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,fplass,fplass,21/Sep/12 06:46,22/Dec/12 01:10,14/Jul/23 06:00,22/Nov/12 06:20,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Static Type Checker,,,,1,,,,,,"For classes implementing Comparable (e. g. String) calls to 'compareTo()' with single either directly or through operator like '<' are not detected as incorrect if the argument is on the wrong type (e. g. 'ab' < 1 is accepted).

Note: Attached test source is modification of standard test delivered with Groovy 2.0.1","Groovy 2.0.1, Java 6 VM (no indication of correction for 2.0.2 found)",fplass,r.patzelt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/Sep/12 06:46;fplass;STCnAryExpressionTest.groovy;https://issues.apache.org/jira/secure/attachment/12722370/STCnAryExpressionTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 19 04:00:20 UTC 2012,,,,,,,,,,"0|i2bwdb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"19/Oct/12 04:00;fplass;I assume that the problem is not limited to classes implmenting the 'Comparable' interface but also affects other cases of generic methods defined by an implemented interface. However, due to the special treatment of comparison operations by the DefaultTypeTransformer the simple workaround (only applicable for self defined classes anyway) of using dynamic metaprogramming for implementing the 'compareTo()' method and implementing the corresponding checks in a type checker plugin does not work. The only option would be to subclass 'StaticTypeCheckingVisitor' and add extra checks for 'compareTo()' method calls, which looks like a substantial effort for a workaround.  ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
timing problem with GroovyScriptEngine recompilation,GROOVY-5713,12816437,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,20/Sep/12 01:56,21/Sep/12 16:58,14/Jul/23 06:00,20/Sep/12 08:18,1.8.8,2.0.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.4,,GroovyScriptEngine,,,,0,,,,,,"while GROOVY-4975 fixed several things the implementation still had a flaw that was not easily showing in the tests attached to GROOVY-4975. Because of the truncation of the last modification time of the URL it was very possible to get quite random times within a 1000ms range. Partially to that, partially to other issues isSourceNewer gave wrong results. For example very new entries, that just had been compiled, return true if depending on how long after that isSourceNewer is called. This leads to dependencies not picked up right",,alessiostalla,blackdrag,sslavic,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 20 08:18:34 UTC 2012,,,,,,,,,,"0|i2c1xj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Sep/12 08:18;blackdrag;hopefully better now. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"@TypeChecked and ""Charset ISO_8859_1_CHARSET = Charset.forName(""ISO-8859-1"")"": Cannot assign value of type java.lang.Class to variable of type java.nio.charset.Charset",GROOVY-5712,12816543,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,peti,peti,19/Sep/12 03:06,22/Dec/12 01:10,14/Jul/23 06:00,22/Nov/12 02:21,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,Static Type Checker,,,,0,,,,,,"{code}
package example

import groovy.transform.TypeChecked

import java.nio.charset.Charset

@TypeChecked
class PotentialTypeCheckerIssueExample {
        private static Charset ISO_8859_1_CHARSET = Charset.forName(""ISO-8859-1"")

        static void main(String[] args) {
                new PotentialTypeCheckerIssueExample().printCharset()
        }

        def printCharset(){
                println ISO_8859_1_CHARSET
        }
}
{code}
The type checker reports
{code}
Groovy:[Static type checking] - Cannot assign value of type
java.lang.Class to variable of type
java.nio.charset.Charset        PotentialTypeCheckerIssueExample.groovy /GroovyTests/src/example        line
9       Java Problem
{code}
The code runs fine without @TypeChecked, the IDE shows the right
return type (Charset).

What's wrong here?","Windows 7
Eclipse
Groovy Eclipse 2.7.1.xx-20120915",melix,peti,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 22 02:21:10 UTC 2012,,,,,,,,,,"0|i2bqu7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Sep/12 03:54;peti;Same issue with

{code}
String fileContent = com.google.common.io.Files.toString(file, Charset.forName('ISO-8859-1'))
{code}

The type checker reports:
{code}
Groovy:[Static type checking] - Cannot find matching method java.lang.Class#toString
(java.io.File, java.lang.Class <java.lang.Object extends java.lang.Object>)	
Xyz.groovy	
...	line 69	Java Problem
{code}
;;;","22/Nov/12 02:21;melix;Due to architectural changes, the fix for 2.1.0 is different from the fix in 2.0.6;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stub generator should not use raw types when casting default return values,GROOVY-5710,12816537,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,guillaume,guillaume,18/Sep/12 02:04,21/Sep/12 16:58,14/Jul/23 06:00,18/Sep/12 02:08,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.4,2.1.0-beta-1,Stub generator / Joint compiler,,,,0,,,,,,"Currently, for methods like:
{code}
List<BuildListener> getBuildListeners() { ... }
{code}
The stub generator generates:
{code}
public List<BuildListener> getBuildListeners() { return (List)null; }
{code}
Instead of returning:
{code}
(List<BuildListeners>)null
{code}",,guillaume,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-09-18 02:04:34.0,,,,,,,,,,"0|i2co67:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"If superclass defines a readonly property, subclass may not use a private field of the same name",GROOVY-5707,12816448,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,14/Sep/12 08:30,21/Sep/12 16:58,14/Jul/23 06:00,14/Sep/12 08:33,2.0.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.4,,,Static Type Checker,,,,0,,,,,,"The following code fails because the type checker things ""testClass"" is a readonly property:

{code}
class Top {
    Class getTestClass() {}
}

@groovy.transform.TypeChecked
class Bottom extends Top {
    private Class testClass
    Bottom(Class foo) {
        this.testClass = foo
    }
}
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-09-14 08:30:23.0,,,,,,,,,,"0|i2cgrj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JSR 223 invokeFunction broken in 2.0.2 - regression,GROOVY-5706,12818189,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,benken_parasoft,benken_parasoft,13/Sep/12 19:01,27/Nov/12 03:54,14/Jul/23 06:00,17/Sep/12 09:43,2.0.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.4,,GroovyScriptEngine,,,,0,,,,,,"The below script works in Groovy 2.0.1 and earlier but stopped working in Groovy 2.0.2.  I invoke a global glosure named ""helloWorld"".  I use two different strings named ""helloWorld"".  Sometimes this works, sometimes this fails.

I suspect the problem is in GroovyScriptEngineImpl.  The globalClosures map was changed in 2.0.2.  It is no longer a java.util.Map but is some other map (ManagedConcurrentMap).  I suspect it may be a problem with the map using System.identityHashCode() is its mechanism for looking up Closures.  Obviously, any string named ""helloWorld"" should work here.

SEVERITY:
This problem causes breakage in real applications that use JSR 223 API for Groovy and other script engines.  A user would need to roll back to 2.0.1.


EXAMPLE:
{code}
import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;

public class HelloWorld {
    public static void main(String[] args) throws Exception {
        String script = ""void helloWorld() { println \""Hello World\"" }"";
        ScriptEngineManager factory = new ScriptEngineManager();
        ScriptEngine engine = factory.getEngineByName(""groovy"");
        CompiledScript compiled = ((Compilable) engine).compile(script);
        compiled.eval();
        String name = ""helloWorld"";
        String name2 = new String(name.toCharArray());
        if (!name.equals(name2)) {
            System.out.println(""should be equal!"");
        }
        ((Invocable) engine).invokeFunction(name);   // works
        ((Invocable) engine).invokeFunction(name);   // still works
        ((Invocable) engine).invokeFunction(name2);  // fails since Groovy 2.0.2
    }
}
{code}",Reproduced with Java 6 and Java 7.,benken_parasoft,blackdrag,dnie,markyo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 27 03:54:36 UTC 2012,,,,,,,,,,"0|i2br2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Sep/12 09:43;blackdrag;This has now been fixed. Thanks for the early catch and the very good analysis of the issue.;;;","23/Nov/12 00:35;dnie;This Bug has *not* been fixed in groovy-*all* 2.0.5

{code}
<dependency>
	<groupId>org.codehaus.groovy</groupId>
	<artifactId>groovy-all</artifactId>
	<version>2.0.5</version>
</dependency>
{code}

(groovy-jsr223 2.0.5 itself works fine);;;","23/Nov/12 07:39;blackdrag;Dirk, you mean the example above does not work in 2.0.5 for you if you use groovy-all, and it does work if you use the 2.0.5 version of groovy-jsr223?;;;","27/Nov/12 01:44;dnie;Thanks for responding so fast

We have automated Integration Tests for our Product, which always succeeded with groovy-all 2.0.0. After updating to 2.0.5, our Integration-Tests  showing a similar bug described in this issue. 
The Stacktrace is
{code: title=Stacktrace}
java.lang.NoSuchMethodException: No signature of method: org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.loadData() is applicable for argument types: (com.dvelop.forms.script.facade.FSInputFacade) values: [com.dvelop.forms.script.facade.FSInputFacade@12c08c7]
	at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.invokeImpl(GroovyScriptEngineImpl.java:383)
	at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.invokeFunction(GroovyScriptEngineImpl.java:179)
	at com.dvelop.forms.script.facade.FormsScriptFacade.invokeFunction(FormsScriptFacade.java:276)
	at com.dvelop.forms.model.server.datasource.script.FormsScriptInvoker.invokeMethod(FormsScriptInvoker.java:140)
	at com.dvelop.forms.model.server.datasource.script.ScriptDS.invokeScript(ScriptDS.java:246)
{code}
This happens not immediately. Out Integrations Tests consists of many invocation of many different Scripts in almost sequencial order. After some time, all Script invocations fail.
Our Scripts looks like this:
{code: title=Script}
def loadData(def form){
   // do something    	
   return null;
}
{code}
We are caching all instances of the ScriptEngine (GroovyScriptEngineImpl) and do many more than one invocations of the ""loadData""-Method on the same instance of a ScriptEngine

After some tests I have to revert that groovy-all-2.0.5 has still this issue compared to the groovy-jsr223-2.0.5
Unfortunately our roundtrip for Integration testing is very long. So testing takes some time. Until now, I made the following Tests:

||groovy-all||Joseph's example||our Integration-Test||
|2.0.0|OK|OK|
|2.0.1|OK|OK|
|2.0.2|Failed|not tested yet|
|2.0.3|OK|Failed|
|2.0.4|OK|not tested yet|
|2.0.5|OK|Failed|

Right now I am not able to debug this error, since I am not able to reproduce it outside of our automated Integration Tests on our Buildserver. All local Unit-Tests of the related package in our Product allways succeeded. But they do allways single invocations which I will fix today.
Do you need more information? Should I open an new Issue instead of using this one?;;;","27/Nov/12 03:54;blackdrag;I think your issue is a different one, so a new issue would be good. But I am wondering if your problem is related to GROOVY-5786 which is caused by the fix of GROOVY-5187. The problem in GROOVY-5786 basically is, that added functions are lost over time due to garbage collection. The MissingMethodException above sounds like the added function is lost, so it might be the same issue. My problem is that without this I will get the problem in GROOVY-5187, meaning the engine will never remove any scripts and pollute memory. I asked in GROOVY-5786 how to decide between those, but I got no answer so far. Normally I would add an option or method or something alike to the engine and let the user control this. But unfortunately I don't see how JSR 223 allows for such interaction. Do you have any idea?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC: calling a closure stored in a property yields an NPE,GROOVY-5705,12818178,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,guillaume,guillaume,12/Sep/12 05:21,21/Sep/12 16:58,14/Jul/23 06:00,13/Sep/12 10:22,2.0.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.4,2.1.0-beta-1,,Static Type Checker,,,,0,,,,,,"When you run the following example:

{code}
import groovy.transform.*

class Test {
    Closure c = { it }
    
    @TypeChecked
    void test() {
        c(""123"")
    }
}

new Test().test()
{code}

An NPE will be thrown:
{code}
java.lang.NullPointerException
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:1717)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:193)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:163)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1224)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1465)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1439)
	at org.codehaus.groovy.transform.StaticTypesTransformation.visit(StaticTypesTransformation.java:78)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1027)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:564)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:542)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:519)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)
	at groovy.lang.GroovyShell.run(GroovyShell.java:480)
	at groovy.lang.GroovyShell.run(GroovyShell.java:163)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:951)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor242.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at groovy.lang.Closure.call(Closure.java:415)
	at groovy.lang.Closure.call(Closure.java:409)
	at groovy.lang.Closure.run(Closure.java:493)
	at java.lang.Thread.run(Thread.java:680)
{code}",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-09-12 05:21:42.0,,,,,,,,,,"0|i2br4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic conues field access with property access,GROOVY-5704,12816546,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,boaznahum,boaznahum,12/Sep/12 01:11,21/Sep/12 16:58,14/Jul/23 06:00,16/Sep/12 14:24,2.0.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.4,,,Static compilation,,,,0,,,,,,"When accessing field 'x' that have the same name as property 'getX'
compiler try to access the property instead of field.

If you remove the property accessor 'getX' then error disappears

I don't know if it just compile time or also run-time.

The complete test case below demonstrates it:

{code}
class CSFieldConfuseProperty {

  private AtomicBoolean x;


  @CompileStatic
  public boolean getX() {
    return x.get();
  }

  /**
   * This one gives error:
   * Groovyc: [Static type checking] - Cannot find matching method boolean#set(boolean).
   * Please check if the declared type is right and if the method exists.
   */
  @CompileStatic
  public void setX1(boolean flag) {
    this.x.set(flag);
  }

  /**
   * This cone is compiled OK
   */
  public void setX2(boolean flag) {
    this.x.set(flag);
  }

}
{code}",JDK 1.7.0_04,boaznahum,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 16 14:24:33 UTC 2012,,,,,,,,,,"0|i2bxzz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Sep/12 08:40;melix;I think this is fixed on both {{master}} and {{2_0_X}}. Would you mind testing your use case?;;;","14/Sep/12 10:04;boaznahum;I did run on 2.0.2.
We are in new year holidays, 
I will check it again on Wednesday ;;;","14/Sep/12 10:11;boaznahum;Maybe I misunderstood you Do you want me to check one of the snapshots? ;;;","14/Sep/12 10:15;melix;Yes, the next build should have the fix in.;;;","16/Sep/12 05:06;boaznahum;Indeed groovy-all-2.0.3-20120914.152326-9 has the fix.
Boaz
;;;","16/Sep/12 14:24;melix;Excellent, thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic - Calling vargarg parameter String is converted to array of strings,GROOVY-5703,12816429,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,boaznahum,boaznahum,12/Sep/12 00:46,21/Sep/12 16:58,14/Jul/23 06:00,12/Sep/12 04:12,2.0.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.4,,,,,,,0,compiler,CompileStatic,,,,"Assume we have this method:

{code}
static void printMsgs(String ... msgs) {
    for(String s : msgs) { println s;}
}
{code}

Calling it from @CompileStatic:
{code}
@CompileStatic
  static void testCS() {
    //Print:
    // H
    // e
    // l
    // l
    // o
    printMsgs(""Hello"");
  }
{code}

The string 'hello' is converted to array of strings.

Calling it from non CompileStatic works fines.

The complete test case:
{code}
public class CompileStaticVarArg {

  static void main(String[] args) {


    test();

    println '-' * 20

    testCS()

  }


  static void test() {
    // Print 'hello'
    printMsgs(""Hello"");
  }

  @CompileStatic
  static void testCS() {
    //Print:
    // H
    // e
    // l
    // l
    // o
    printMsgs(""Hello"");
  }

  static void printMsgs(String ... msgs) {

    for(String s : msgs) {
      println s;
    }

  }

}
{code}



","Windows 7 64bits, JDK 1.7.0_04",boaznahum,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 13 02:32:36 UTC 2012,,,,,,,,,,"0|i2c47z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Sep/12 01:35;boaznahum;Need to go back to 2.0.1 - I have too many such pieces of code;;;","12/Sep/12 02:04;melix;Hi!

Looks like a serious issue. Can you confirm to me that this worked fine with 2.0.1?

Thanks!;;;","12/Sep/12 02:13;boaznahum;Yes, I just run it now. Works fine in 2.0.1 

Hello
--------------------
Hello

I don't know it is make any matter, but In both I'm using -indy
;;;","12/Sep/12 02:20;melix;Right, thanks. No, using indy should not change anything as the code is statically compiled. We'll try to fix that one soon and release early.;;;","12/Sep/12 02:22;boaznahum;Will the fix appear in the binaries snapshots ? If I watching this issue will I notified ?;;;","12/Sep/12 02:24;melix;Sure;;;","12/Sep/12 04:12;melix;I pushed the fix. Please note that the fix won't be available as a snapshot until a couple of hours, depending on the build server.;;;","13/Sep/12 02:32;boaznahum;Works like a charm.
Sorry to bother you here - can you confirm ?
  1. I took a stable release 2.0.2, 
  2. deleted all \lib\groovy-*.jar 
  3. and replace it with the groovy-all*-indy.jar

???
Thanks
Boaz
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC: checker confused by overridden method from sub interface,GROOVY-5702,12816508,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,11/Sep/12 09:34,21/Sep/12 16:58,14/Jul/23 06:00,13/Sep/12 09:57,2.0.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.4,,,Static Type Checker,,,,0,,,,,,"{code}

interface MyCloseable {
    void close()
}

interface OtherCloseable extends MyCloseable {
    void close()
}

class MyCloseableChannel implements OtherCloseable {}

@groovy.transform.TypeChecked
class Test {
    static void test() {
        def mc = new MyCloseableChannel()
        mc.close()
    }   
}

Test.test()
{code}

Here, {{OtherCloseable}} redefines {{close()}} from {{MyCloseable}}, and it seems to confuse the type checker, as it complains with:

{code}
[Static type checking] - Cannot find matching method MyCloseableChannel#close(). Please check if the declared type is right and if the method exists.
{code}

I found the case with {{java.nio.Channel}} which redefines the {{close()}} method from parent interface {{java.io.Closeable}}.",,guillaume,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 13 07:09:44 UTC 2012,,,,,,,,,,"0|i2cl2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Sep/12 07:09;melix;Guillaume, I think the problem is fixed by https://github.com/groovy/groovy-core/commit/110732487e27b5420d3ddcf00901b5a7005b2be1.

If it's ok for you, feel free to close the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC: different behavior w/ map subscript and property access when using elvis,GROOVY-5700,12816525,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,11/Sep/12 04:38,22/Aug/22 14:48,14/Jul/23 06:00,12/Sep/12 07:13,2.0.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.4,,,Static Type Checker,,,,0,,,,,,"There's a difference in behavior with static type checking between property and subscript access to map elements.

{code}
@groovy.transform.TypeChecked
class Test {
    static void test() {
        def m = [retries: 10]
        // passes
        int r1 = m['retries'] ?: 1
        // fails
        int r2 = m.retries ?: 1
    }   
}

Test.test()
{code}

Fails with:
{code}
[Static type checking] - Cannot assign value of type java.lang.Object to variable of type int
{code}",,emilles,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8788,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 22 14:48:13 UTC 2022,,,,,,,,,,"0|i2cicv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Aug/22 14:48;emilles;https://github.com/apache/groovy/commit/0914362c1be5c9789d28417dd748496570a7b34a;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC: Property inference issue with IntRange properties,GROOVY-5699,12816388,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,11/Sep/12 04:18,21/Sep/12 16:58,14/Jul/23 06:00,11/Sep/12 12:24,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.4,,,Static Type Checker,,,,0,,,,,,"The following example fails:
{code}
@groovy.transform.TypeChecked
class Test {
    static void test() {
        def range = 1..10
        int i = range.fromInt
    }   
}

Test.test()
{code}
With:
{code}
[Static type checking] - Cannot assign value of type java.lang.Object to variable of type int
{code}
Although using the getter method directly {{getFromInt()}} and the type checker is happy.",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-09-11 04:18:02.0,,,,,,,,,,"0|i2ci93:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC: problem w/ map based constructors,GROOVY-5698,12813417,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,11/Sep/12 03:32,21/Sep/12 16:58,14/Jul/23 06:00,13/Sep/12 05:05,2.0.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.4,,,Static Type Checker,,,,0,,,,,,"{code}
class CustomServletOutputStream extends OutputStream {
    OutputStream out

    void write(int i) {
        out.write(i)
    }

    void write(byte[] bytes) {
        out.write(bytes)
    }

    void write(byte[] bytes, int offset, int length) {
        out.write(bytes, offset, length)
    }

    void flush() {
        out.flush()
    }

    void close() {
        out.close()
    }
}

@groovy.transform.TypeChecked
class Test {
    static void test() {
        def csos = new CustomServletOutputStream(out: new ByteArrayOutputStream())
    }   
}

Test.test()
{code}

This fails with:
{code}
[Static type checking] - Cannot assign value of type java.io.ByteArrayOutputStream to variable of type java.io.OutputStream
{code}

However, the following spanning two lines work:
{code}
        def csos = new CustomServletOutputStream()
        csos.out = new ByteArrayOutputStream()
{code}",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-09-11 03:32:29.0,,,,,,,,,,"0|i2col3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wiki snapshot (pdf) is outdated,GROOVY-5697,12816529,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,guillaume,dd11,dd11,10/Sep/12 14:28,10/Jul/13 04:42,14/Jul/23 06:00,01/Jul/13 14:24,1.8.8,2.0.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,Documentation,,,,0,,,,,,"http://git.codehaus.org/gitweb.cgi?p=groovy-git.git;a=history;f=src/wiki-snapshot.pdf;h=5c133e0a719969a1c0f77adbf2ad127802ebe985;hb=refs/heads/GROOVY_2_0_X

Latest entry dates back to Groovy 1.7 
",src,blackdrag,dd11,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 01 14:24:47 UTC 2013,,,,,,,,,,"0|i2cke7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Dec/12 05:52;pschumacher;Is the wiki snapshot URL a ""stable"" URL?

If this is the case ""assemble.gradle"" could use 

{code}
ant.get(src:'http://docs.codehaus.org/download/attachments/63052/wiki-snapshot.pdf', dest:'wiki-snapshot.pdf')
{code}

to fetch the current snapshot when building the distribution. ;;;","04/Jan/13 08:52;blackdrag;this can be used to get the wiki as pdf, yes. But normally we don't add all pages in that. Also the so generated PDF does not really look well;;;","01/Jul/13 14:24;pschumacher;Guillaume updated the snapshot a few days ago.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
jarsigner fails because two duplicate objects exists in groovy-2.0.1.jar,GROOVY-5695,12816476,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,lwolter,lwolter,09/Sep/12 08:34,22/Dec/12 01:10,14/Jul/23 06:00,05/Nov/12 16:31,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,Ant integration,,,,1,,,,,,"two duplicate objects exists:
{code}
org/codehaus/groovy/antlib.xml
groovy/grape/defaultGrapeConfig.xml
{code}",windows 7,gredler,guillaume,lwolter,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 05 16:31:45 UTC 2012,,,,,,,,,,"0|i2cfb3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Oct/12 13:45;sdanig;This is still an issue in 2.0.5, and is preventing us from upgrading past 2.0.0:

{code}jarsigner: unable to sign jar: java.util.zip.ZipException: duplicate entry: org/codehaus/groovy/antlib.xml{code}

{code}jarsigner: unable to sign jar: java.util.zip.ZipException: duplicate entry: groovy/grape/defaultGrapeConfig.xml{code};;;","22/Oct/12 13:47;guillaume;Why exactly is it preventing you from upgrading?;;;","22/Oct/12 17:44;sdanig;We use Groovy in a Web Start / JNLP app, and one of the final build steps is to sign the dependencies so the app can run with special permissions. If we can't sign the JAR, we can't finish the build.;;;","02/Nov/12 08:24;pschumacher;In master both files are duplicated in the groovy-2.1.0-SNAPSHOT.jar, but not in the groovy-all-2.1.0-SNAPSHOT.jar.

If you remove the files from included resources e.g.:

{code:title=build.gradle|borderStyle=solid}
sourceSets {
    ...
    main {
        ...
        resources {
            srcDirs = [""src/main"", ""src/tools""]
            include ""META-INF/services/*"", ""META-INF/groovy-release-info.properties"",
                    //""groovy/grape/*.xml"",
                    ""groovy/ui/*.properties"", ""groovy/ui/**/*.png"",
                    ""groovy/inspect/swingui/AstBrowserProperties.groovy"",
                    ""org/codehaus/groovy/tools/shell/**/*.properties"",
                    ""org/codehaus/groovy/tools/shell/**/*.xml"",
                    //""org/codehaus/groovy/antlib.xml"",
                    ""org/codehaus/groovy/tools/groovydoc/gstringTemplates/**/*.*"",
                    ""org/codehaus/groovy/tools/groovy.ico""
        }
    }
...
{code}

the duplication disappears, but i think solving it this way is not what you want.;;;","03/Nov/12 09:55;pschumacher;I took another look at the problem.

The duplicates are packed into the groovy.jar, because the files are both under ""/target/classes"" and under ""/target/resources"".

As a possible solution I removed the ""copyResources"" task from ""build.gradle"".

To keep the functionality of ""copyResources"" I added the html files under ""/src"" to the main.resources sourceset and moved the filter to processResources. 
See pull request: [https://github.com/groovy/groovy-core/pull/69]



;;;","05/Nov/12 06:04;paulk;Can you see whether this commit fixes the issue for you:

https://github.com/groovy/groovy-core/commit/234da65

This probably has an equivalent end result to your proposed pull request but seemed a slightly smaller change and the antlib.xml should have really been in the groovy-ant jar anyway.

There is more resource refactoring that could be done. Feel free to continue down this path if you have some time.

Cheers, Paul.;;;","05/Nov/12 12:22;pschumacher;Hello Paul,

your commit fixed the issue. :-) 

I will chancel my pull request and submit another for resource clean up only.

Regards,
Pascal;;;","05/Nov/12 16:31;paulk;duplication removed - thanks for raising the issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unexpected behavior of CompileStatic when assigning a Closure to a new block code,GROOVY-5693,12816475,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,carlosapc,carlosapc,07/Sep/12 14:48,21/Sep/12 16:58,14/Jul/23 06:00,12/Sep/12 10:26,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.4,,,Static compilation,,,,0,,,,,,"{noformat}
@groovy.transform.CompileStatic
class Foo{
    def run(){
        Closure a ={
            int i ->
            println ""First closure ""+ i
        }
        Closure b ={
            String s ->
            println ""Second closure ""+ s
        }
        a=b
        a(""Testing!"")
    }
}
Foo f = new Foo()
f.run()
{noformat}
With CS applied the code will fail to compile with the following error:
{noformat}
[Static type checking] - Closure argument types: [int] do not match with parameter types: [java.lang.String]
at line: 13, column: 11
{noformat}
The compiler is expecting an integer but since the variable 'a' is re-assigned to a new piece of code that takes a String as a parameter this code should work",Windows 7,carlosapc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"07/Sep/12 14:48;carlosapc;closure_bug.groovy;https://issues.apache.org/jira/secure/attachment/12723030/closure_bug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-09-07 14:48:18.0,,,,,,,,,,"0|i2cms7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TypeChecked not checking generics placeholder types across arguments when a method has multiple arguments,GROOVY-5692,12818442,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,paulk,,07/Sep/12 05:37,12/Sep/22 21:53,14/Jul/23 06:00,07/Sep/12 12:34,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,,,,,0,,,,,,"{code}
import groovy.transform.TypeChecked
main()
@TypeChecked main() { printEqual(1, 'foo') }
@TypeChecked <T> void printEqual(T arg1, T arg2) { println arg1 == arg2 }
{code}",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10006,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-09-07 05:37:20.0,,,,,,,,,,"0|i2cbtj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TimeoutException immediately thrown when using both TimedInterrupt and with {} closure on a Map,GROOVY-5691,12816513,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,guillaume.cernier,guillaume.cernier,07/Sep/12 04:20,11/Sep/12 01:15,14/Jul/23 06:00,07/Sep/12 06:30,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,2.1.0-beta-1,,,,,0,,,,,,"The attached {{script.groovy}} has a very strange behaviour:
{code:title=Bar.java|borderStyle=solid}
class GroovyTimedInterruptAndWithTest {

  @groovy.transform.TimedInterrupt( 60L )
  def test() {
    
    def map = [:]
    
    map.with {
      key1 = 'foo'
      key2 = 42
    }
    
    map
  }
}

new GroovyTimedInterruptAndWithTest().test()
{code}

At runtime, the script *immediately* throws the TimeoutException (whereas the timeout's value given to the {{@TimedInterrupt}} annotation is 60 seconds) :

{code} 
java.util.concurrent.TimeoutException: Execution timed out after 60 units. Start time: null
	at GroovyTimedInterruptAndWithTest$_test_closure1.doCall(script.groovy)
	at GroovyTimedInterruptAndWithTest.test(script.groovy:8)
	at GroovyTimedInterruptAndWithTest$test.call(Unknown Source)
	at script.run(script.groovy:17)
{code} 

The {{Start time}} displayed in this stacktrace, which is {{null}}, is another strange fact.

Experienced on {{1.8.6}} but might also occur on all versions including {{@TimedInterrupt}} ({{1.8.0}}+).


This is not very critical as it's of course possible to write instead:
{code}
map['key1']='foo'
map['key2']=42
{code} 

but the thing is that the script runs fine when commenting the {{@TimedInterrupt}} annotation ; so this bug might hide another strange behaviours when using {{@TimedInterrupt}} annotation.",,guillaume.cernier,paulk,tiagofernandez,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"07/Sep/12 04:21;guillaume.cernier;script.groovy;https://issues.apache.org/jira/secure/attachment/12722540/script.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 07 06:30:18 UTC 2012,,,,,,,,,,"0|i2bwbz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Sep/12 06:30;paulk;There was a minor bug in the implementation which should be fixed in the next release. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler exception while applying to @CompileStatic and subclasses,GROOVY-5690,12811944,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,shivawu,shivawu,07/Sep/12 03:14,11/Sep/12 01:15,14/Jul/23 06:00,07/Sep/12 08:13,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Compiler,,,,0,,,,,,"An exception was thrown when try to compile two classes Subclass.groovy and Z.groovy, where Subclass extends Z. Both class are annotated with @CompileStatic

Which is really strange, is that, when you change the name Z to *a letter smaller than 'U'*, it compiles without any problem.

The source code is attached, 3 files, Z.groovy, Subclass.groovy, and P.groovy, in which P and Z is same class with different name. When Subclass extends P, it works.

The compilation command is: 
bq. groovyc *.groovy

Enviroment:

Ubuntu 12.10, 32-Bit
Groovy 2.0.1, installed from groovy-dev/groovy ppa

The exception is:
{quote}
java.lang.ArrayIndexOutOfBoundsException: size==0
	at org.codehaus.groovy.classgen.asm.OperandStack.doConvertAndCast(OperandStack.java:311)
	at org.codehaus.groovy.classgen.asm.OperandStack.doGroovyCast(OperandStack.java:296)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:592)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:505)
	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:455)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:319)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:276)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:396)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:783)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:496)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:57)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:213)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:146)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:176)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:160)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:616)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)

1 error
{quote}",,melix,shivawu,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"07/Sep/12 03:14;shivawu;bug.zip;https://issues.apache.org/jira/secure/attachment/12722611/bug.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 07 03:36:59 UTC 2012,,,,,,,,,,"0|i2bp1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Sep/12 03:20;melix;Confirmed on {{master}};;;","07/Sep/12 03:36;melix;As a side note: P.groovy is not necessary to reproduce the error. If we remove {{@CompileStatic}} from {{Z}} or {{SubClass}} the error goes away, meaning that you need to annotate both classes to trigger the error. The fact of renaming {{Z}} to {{U}} making the error go away is probably a side effect of the order of compilation.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException Double->Float with -= += operators and closures,GROOVY-5689,12816474,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,luukes,luukes,05/Sep/12 05:05,11/Sep/12 01:15,14/Jul/23 06:00,07/Sep/12 11:03,1.8.7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,,,,,,0,,,,,,"The ClassCastException is thrown only in combination of a -= (or +=) operator and a closure.
{code} 
void doesNotWork() {
  float myFloat = 40f
  myFloat -= 20f
  println ""doesNotWork() $myFloat"" // the exception is thrown here, but because of the combination of the -= and the closure
  (0..1).each { i -> // this can be any closure - doesn't matter
    println ""doesNotWork() in the closure: $myFloat""
  }
}
{code}

Did not occure with 1.8.3.","Ubuntu 12.04, SunJDK 1.6.0_u33 x64, groovy 1.8.7",blackdrag,luukes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 07 11:03:02 UTC 2012,,,,,,,,,,"0|i2c0yv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Sep/12 09:47;blackdrag;ok, a first analysis... it is unrelated to primopts directly. In Groovy if you assign a value you have to do a groovy style cast to the target type. This does not happen here. The result of the operation is just stored in the Reference. But since the result is a double and some later code, that does a jvm cast, expects a float. The type transformation is missing, thus the exception.that means a cast that was in 1.8.3 was lost somehow... or the later one was added... that is unclear.;;;","07/Sep/12 11:03;blackdrag;fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException in StaticTypeCheckingVisitor,GROOVY-5688,12816519,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,,andyg,andyg,05/Sep/12 04:30,11/Sep/12 01:15,14/Jul/23 06:00,05/Sep/12 10:59,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Compiler,,,,0,,,,,,"Upgrade from 2.0.0 to 2.0.1 produces following exception:
{noformat}
java.lang.NullPointerException
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnTypeGenerics(StaticTypeCheckingVisitor.java:2618)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:1791)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBinaryExpression(CodeVisitorSupport.java:144)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:390)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:195)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1179)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1403)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.silentlyVisitMethodNode(StaticTypeCheckingVisitor.java:1558)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:1783)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitListOfExpressions(CodeVisitorSupport.java:273)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitTupleExpression(CodeVisitorSupport.java:178)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitArgumentlistExpression(CodeVisitorSupport.java:283)
	at org.codehaus.groovy.ast.expr.ArgumentListExpression.visit(ArgumentListExpression.java:74)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:1610)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBinaryExpression(CodeVisitorSupport.java:144)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:390)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:245)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitDeclarationExpression(ClassCodeVisitorSupport.java:107)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:87)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:195)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1179)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1403)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1377)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:216)
	at org.codehaus.groovy.transform.StaticTypesTransformation.visit(StaticTypesTransformation.java:73)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:43)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:150)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:108)
{noformat}

Reverting back to 2.0.0 works fine. No other feedback is available at the moment.","Windows 7 64bit
IDEA 11.1.3",andyg,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 05 10:59:49 UTC 2012,,,,,,,,,,"0|i2cs4n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Sep/12 04:33;melix;Do you have code reproducing the issue? Can you try with the latest 2.0.2 snapshot?;;;","05/Sep/12 09:20;andyg;Working with:

groovy-all-2.0.2-20120905.114854-32.jar	05-Sep-2012 06:48 	5.9M;;;","05/Sep/12 10:59;melix;Right, so it looks like it has already been fixed. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Constants defined in an interface not visible to implementing subclass in a static context,GROOVY-5687,12811958,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,behrangsa,behrangsa,04/Sep/12 22:46,18/Sep/12 17:37,14/Jul/23 06:00,06/Sep/12 07:31,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,2.1.0-beta-1,,,,,,0,,,,,,"The following code fails to compile:

{code}
public interface DateTimeFormatConstants {
    static final SimpleDateFormat AM_PM_TIME_FORMAT = new SimpleDateFormat(""h:mma"")

    static final SimpleDateFormat MILITARY_TIME_FORMAT = new SimpleDateFormat(""HH:mm"")
}

class DateTimeUtils implements DateTimeFormatConstants {
    static String convertMilitaryTimeToAmPm(String militaryTime) {
        Date date = MILITARY_TIME_FORMAT.parse(militaryTime)
        return AM_PM_TIME_FORMAT.format(date).toLowerCase()
    }
}
{code}

The error message is:

{code}
You attempted to reference a variable in the binding or an instance variable from a static context.
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method 'AM_PM_TIME_FORMAT' but left out brackets in a place not allowed by the grammar.
 @ line 13, column 16.
           return AM_PM_TIME_FORMAT.format(date).toLowerCase()
                  ^
{code}",,behrangsa,paulk,sdidit,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 18 17:37:40 UTC 2012,,,,,,,,,,"0|i2crrr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Sep/12 07:31;paulk;Thanks for spotting the issue. Not sure when the regression occurred but it should be fixed in the upcoming release.;;;","18/Sep/12 17:37;sdidit;Could you make Groovy5687Bug.DateTimeUtils a static nested class? Else the generated Java stub does not compile because inner classes cannot have static declarations.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Accessing length of an array of arrays occurs VerifyError,GROOVY-5683,12816466,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,nagai_masato,nagai_masato,02/Sep/12 12:56,13/Apr/23 15:32,14/Jul/23 06:00,03/Sep/12 02:46,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,,,,,0,,,,,,"{code}@groovy.transform.CompileStatic
def foo() { 
    int[][] array = [[1]] as int[][]
    array[0].length 
}
{code}

throws

{noformat}
Caught: java.lang.VerifyError: (class: script_from_command_line, method: foo signature: ()Ljava/lang/Object;) Expecting to find array on stack
java.lang.VerifyError: (class: script_from_command_line, method: foo signature: ()Ljava/lang/Object;) Expecting to find array on stack
{noformat}","Groovy Version: 2.1.0-SNAPSHOT JVM: 1.7.0_07 Vendor: Oracle Corporation OS: Mac OS X
master branch (67eb7873f5a19403f5a6acf1d4942cadbe7a268d)",melix,nagai_masato,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-11011,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 03 02:16:26 UTC 2012,,,,,,,,,,"0|i2bq4n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Sep/12 02:16;melix;Formatting tags;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Anonynous inner class as default argument value throws IOOBE,GROOVY-5681,12818188,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,31/Aug/12 03:24,11/Sep/12 01:15,14/Jul/23 06:00,31/Aug/12 09:22,1.8.7,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,,,,,,0,,,,,,"The compiler doesn't allow using anonymous inner classes as default argument values.

{code}
class A {
    void bar(arg = new Runnable() { void run() {} }) {}
}
{code}

results in:

{noformat}
java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
	at java.util.ArrayList.rangeCheck(ArrayList.java:604)
	at java.util.ArrayList.get(ArrayList.java:382)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeAICCall(InvocationWriter.java:450)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeConstructor(InvocationWriter.java:430)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorCallExpression(AsmClassGenerator.java:909)
	at org.codehaus.groovy.ast.expr.ConstructorCallExpression.visit(ConstructorCallExpression.java:43)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitCastExpression(AsmClassGenerator.java:616)
	at org.codehaus.groovy.ast.expr.CastExpression.visit(CastExpression.java:66)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.loadArguments(InvocationWriter.java:185)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeDirectMethodCall(InvocationWriter.java:130)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:223)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:76)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:60)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:336)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:648)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:354)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:509)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:319)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:276)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:396)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:786)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1027)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:564)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:542)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:519)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)
{noformat}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-08-31 03:24:10.0,,,,,,,,,,"0|i2cgnr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Enclosing method is not set for anonymous inner classes,GROOVY-5679,12816490,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,30/Aug/12 11:55,11/Sep/12 01:15,14/Jul/23 06:00,31/Aug/12 09:22,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,,,,,,0,,,,,,"The enclosing method is not set for anonymous inner classes. AST transformations may rely on that information (actually, GROOVY-5647 has a workaround for this).

For example:
{code}
class A {
   void enclosingMethod() {
       Runnable r = new Runnable() { void run() {} }
   }
}
{code}

If you inspect the AST, you will see that encoding method for the anonymous runnable is {{null}}.",,blackdrag,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 30 11:59:09 UTC 2012,,,,,,,,,,"0|i2bvz3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Aug/12 11:59;blackdrag;a testcase could be produced using this code:{code:Java}class A {    
    void enclosingMethod() {  
        def r = new Runnable() { void run() {} }
        assert r.class.enclosingClass == A
        assert r.class.enclosingMethod.name == ""enclosingMethod""
    }
}{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
(primopts) increment on array not done as primopt,GROOVY-5678,12816483,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,30/Aug/12 06:41,11/Sep/12 01:15,14/Jul/23 06:00,30/Aug/12 08:13,1.8.7,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,,primtive opts,,,,0,,,,,,"be x a primtive array and i an int, then x[i]++ should be completely done in primopts, if in a primopts block. This is not the case, only the final set is done like that. The initial get and the increment are still dynamic method calls. ",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 30 08:13:54 UTC 2012,,,,,,,,,,"0|i2bx1r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Aug/12 08:13;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stub compiler expands generic-inner-class variable declaration incorrectly,GROOVY-5675,12816454,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,johansensen,johansensen,28/Aug/12 18:12,21/Sep/12 16:58,14/Jul/23 06:00,17/Sep/12 09:51,1.8.7,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.4,2.1.0-beta-1,Stub generator / Joint compiler,,,,0,,,,,,"{noformat}
@Log4j
abstract class AbstractProcessingQueue<T> extends AbstractAgent {
    ...

    protected Queue<ProcessingQueueMember<T>> items
    ...

    private class ProcessingQueueMember<E> {
        ...
    }
}
{noformat}

Produces the following line in AbstractProcessingQueue.java:

{noformat}
protected java.util.Queue<nz.ac.auckland.digitizer.AbstractProcessingQueue.ProcessingQueueMember<T>> items;
{noformat}

Which produces the following compile error:
{noformat}
[ERROR] C:\Documents and Settings\Administrator\digitizer\target\generated-sources\groovy-stubs\main\nz\ac\auckland\digitizer\AbstractProcessingQueue.java:[14,96] error: improperly formed type, type arguments given on a raw type
{noformat}

Because {{ProcessingQueueMember}} is a non-static nested class of {{AbstractProcessingQueue}} and as such is instantiated as a subclass of a given *instance* of {{AbstractProcessingQueue}}, a generic class, the fully-qualified expansion of {{Queue<ProcessingQueueMember<T>>}} needs to be {{java.util.Queue<nz.ac.auckland.digitizer.AbstractProcessingQueue<T>.ProcessingQueueMember<T>>}}, with the type parameter given to both the inner and outer classes in the declaration.",,johansensen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 28 18:33:49 UTC 2012,,,,,,,,,,"0|i2c19r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Aug/12 18:33;johansensen;And when I said 'subclass' in the above, I of course meant 'member'. Derp.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy does not detect correct Java version on Mac,GROOVY-5673,12816503,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,driscoll,driscoll,23/Aug/12 18:19,05/Apr/15 14:43,14/Jul/23 06:00,25/Jan/13 12:48,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.0,,,command line processing,,,,0,,,,,,"Groovy does not detect Oracle's Java 7 - instead, it will use only the Apple JDK6, unless JAVA_HOME is set.

I'll try to get around to doing a git pull, but for now, the solution is to change startGroovy

{code}
# Attempt to set JAVA_HOME if it's not already set.
if [ -z ""$JAVA_HOME"" ] ; then
    if $darwin ; then
        jdkhome=""`java -XshowSettings:properties 2>&1 | grep java\\.home | awk '{print $3}' | rev | cut -d '/' -f 2- | rev`""
        [ -d $jdkhome ] && export JAVA_HOME=$jdkhome
        [ -z ""$JAVA_HOME"" -a -d ""/Library/Java/Home"" ] && export JAVA_HOME=""/Library/Java/Home""
        [ -z ""$JAVA_HOME"" -a -d ""/System/Library/Frameworks/JavaVM.framework/Home"" ] && export JAVA_HOME=""/System/Library/Frameworks/JavaVM.framework/Home""
    else
{code}

I've tested this with both the Apple and Oracle JDKs as the default, and it works correctly.  My shell-fu is not strong however, and there's certainly a better way to do this.",Mac OSX 10.8 Oracle JDK 7u6,driscoll,guillaume,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Jan 25 12:48:13 UTC 2013,,,,,,,,,,"0|i2c7sf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Sep/12 04:40;guillaume;Could you create a pull request with that change?

I'm usually always using JAVA_HOME on my Mac, so I've not faced that problem myself.;;;","21/Jan/13 12:09;pschumacher;Is this still a issue with 2.1-r2/3 or has this pull request:

[https://github.com/groovy/groovy-core/pull/66/files]

fixed this issue?
;;;","25/Jan/13 12:48;driscoll;This bug is fixed in 2.1.  The latest version of Java installed is now detected.  Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovyc produces AIOOBE if @TypeChecked used with @CompileStatic in certain circumstances,GROOVY-5672,12816518,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,imi,imi,22/Aug/12 07:50,11/Sep/12 01:15,14/Jul/23 06:00,03/Sep/12 09:04,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static compilation,,,,0,,,,,,"Simple source code to reproduce the problem

{code:title=SampleClass.groovy|borderStyle=solid}
import groovy.transform.CompileStatic
import groovy.transform.TypeChecked

@TypeChecked
@CompileStatic
class SampleClass {
	def a = ""some string""
	def b = a.toString()
}
{code}
{noformat}
$ groovyc SampleClass.groovy
{noformat}
Produces java.lang.ArrayIndexOutOfBoundsException (attached full trace).

It's enough to reorder the annotations and all works fine:
{code:title=SampleClass.groovy|borderStyle=solid}
import groovy.transform.CompileStatic
import groovy.transform.TypeChecked

@CompileStatic
@TypeChecked
class SampleClass {
	def a = ""some string""
	def b = a.toString()
}
{code}
",,imi,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"22/Aug/12 07:50;imi;groovyc_AIOOBE_trace.txt;https://issues.apache.org/jira/secure/attachment/12723029/groovyc_AIOOBE_trace.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 22 08:02:38 UTC 2012,,,,,,,,,,"0|i2bxin:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Aug/12 07:53;melix;Interesting. However, you don't have to put both annotations. {{@CompileStatic}} alone does all the {{@TypeChecked}} job plus static compilation.;;;","22/Aug/12 08:02;imi;yeah, I know I don't need to put both. I just thought I would report it as ""minor"".;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compilation of calling increment operator on Integer fails,GROOVY-5671,12816484,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,peterd,peterd,22/Aug/12 06:57,11/Sep/12 01:15,14/Jul/23 06:00,30/Aug/12 08:11,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static compilation,,,,0,,,,,,"in short: calling the ++ operator on an Integer does not increment the value when using static compilation.

Example:
{code}
class IntegerIncrementStaticCompilationBug {

    Integer index = 0

    @groovy.transform.CompileStatic
    void increment() {
	index++
    }
}

def b = new IntegerIncrementStaticCompilationBug()
b.increment(); b.increment(); b.increment()

println b.index
{code}

This script should print ""3"", but it prints ""0"".
Works find when CompileStatic annotation is removed.",,melix,peterd,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 22 07:06:20 UTC 2012,,,,,,,,,,"0|i2ccy7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Aug/12 06:58;peterd;ehm, i meant: ""Works fine when CompileStatic annotation is removed."";;;","22/Aug/12 07:06;melix;Raising priority.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DOMCategory should provide name() convenience method for Node's not just Element's,GROOVY-5669,12816504,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,20/Aug/12 05:06,07/Apr/15 19:07,14/Jul/23 06:00,21/Aug/12 05:07,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,2.1.0-beta-1,,,,,,0,,,,,,"As {{Node}} is a super interface of {{Element}}, this should be a fully backward compatible change",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-08-20 05:06:11.0,,,,,,,,,,"0|i2ckn3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Input stream not closed,GROOVY-5668,12818186,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,chrisie,chrisie,20/Aug/12 04:28,11/Sep/12 01:15,14/Jul/23 06:00,22/Aug/12 16:48,1.8.7,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,2.1.0-beta-1,,,,,0,,,,,,"I am using groovy as a language for jasper reports in an enterprise application. When undeploying the application after having created one or more reports, I get a lot of warnings like the ones that follow (the stack traces are with Groovy 2.0.1; I get similar ones with Groovy 1.8.7).

[#|2012-08-20T12:20:36.250+0300|WARNING|glassfish3.1.2|javax.enterprise.system.core.classloading.com.sun.enterprise.loader|_ThreadID=78;_ThreadName=Thread-7;|Input stream has been finalized or forced closed without being explicitly closed; stream instantiation reported in following stack trace
java.lang.Throwable
	at com.sun.enterprise.loader.ASURLClassLoader$SentinelInputStream.<init>(ASURLClassLoader.java:1230)
	at com.sun.enterprise.loader.ASURLClassLoader$InternalJarURLConnection.getInputStream(ASURLClassLoader.java:1338)
	at java.net.URL.openStream(URL.java:1035)
	at org.codehaus.groovy.control.SourceExtensionHandler.getRegisteredExtensions(SourceExtensionHandler.java:44)
	at org.codehaus.groovy.control.CompilerConfiguration.getScriptExtensions(CompilerConfiguration.java:636)
	at groovy.lang.GroovyClassLoader$1$1.run(GroovyClassLoader.java:76)
	at groovy.lang.GroovyClassLoader$1$1.run(GroovyClassLoader.java:74)
	at java.security.AccessController.doPrivileged(Native Method)
	at groovy.lang.GroovyClassLoader$1.loadGroovySource(GroovyClassLoader.java:74)
	at org.codehaus.groovy.control.ResolveVisitor.resolveToScript(ResolveVisitor.java:385)
	at org.codehaus.groovy.control.ResolveVisitor.resolveToClass(ResolveVisitor.java:712)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
	at org.codehaus.groovy.control.ResolveVisitor.resolveFromModule(ResolveVisitor.java:648)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:243)
	at org.codehaus.groovy.control.ResolveVisitor.resolveOrFail(ResolveVisitor.java:227)
	at org.codehaus.groovy.control.ResolveVisitor.resolveOrFail(ResolveVisitor.java:239)
	at org.codehaus.groovy.control.ResolveVisitor.resolveOrFail(ResolveVisitor.java:235)
	at org.codehaus.groovy.control.ResolveVisitor.visitClass(ResolveVisitor.java:1276)
	at org.codehaus.groovy.control.ResolveVisitor.startResolving(ResolveVisitor.java:148)
	at org.codehaus.groovy.control.CompilationUnit$9.call(CompilationUnit.java:621)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:900)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:564)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:513)
	at net.sf.jasperreports.compilers.JRGroovyCompiler.compileUnits(JRGroovyCompiler.java:96)
	at net.sf.jasperreports.engine.design.JRAbstractCompiler.compileReport(JRAbstractCompiler.java:188)
	at net.sf.jasperreports.engine.JasperCompileManager.compileReport(JasperCompileManager.java:212)
	at net.sf.jasperreports.engine.JasperCompileManager.compileReport(JasperCompileManager.java:198)
...



[#|2012-08-20T11:05:34.432+0300|WARNING|glassfish3.1.2|javax.enterprise.system.core.classloading.com.sun.enterprise.loader|_ThreadID=73;_ThreadName=Thread-7;|Input stream has been finalized or forced closed without being explicitly closed; stream instantiation reported in following stack trace
java.lang.Throwable
	at com.sun.enterprise.loader.ASURLClassLoader$SentinelInputStream.<init>(ASURLClassLoader.java:1230)
	at com.sun.enterprise.loader.ASURLClassLoader$InternalJarURLConnection.getInputStream(ASURLClassLoader.java:1338)
	at java.net.URL.openStream(URL.java:1035)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.registerExtensionModuleFromMetaInf(MetaClassRegistryImpl.java:163)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.registerClasspathModules(MetaClassRegistryImpl.java:153)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:108)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:70)
	at groovy.lang.GroovySystem.<clinit>(GroovySystem.java:33)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:162)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:192)
	at Blank32A4_1345449884504_251660.$getStaticMetaClass(calculator_Blank32A4_1345449884504_251660)
	at Blank32A4_1345449884504_251660.<init>(calculator_Blank32A4_1345449884504_251660)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:525)
	at java.lang.Class.newInstance0(Class.java:372)
	at java.lang.Class.newInstance(Class.java:325)
	at net.sf.jasperreports.engine.design.JRAbstractJavaCompiler.loadEvaluator(JRAbstractJavaCompiler.java:98)
	at net.sf.jasperreports.engine.design.JRAbstractCompiler.loadEvaluator(JRAbstractCompiler.java:320)
	at net.sf.jasperreports.engine.JasperCompileManager.loadEvaluator(JasperCompileManager.java:237)
	at net.sf.jasperreports.engine.fill.JRFillDataset.createCalculator(JRFillDataset.java:428)
	at net.sf.jasperreports.engine.fill.JRBaseFiller.<init>(JRBaseFiller.java:363)
	at net.sf.jasperreports.engine.fill.JRVerticalFiller.<init>(JRVerticalFiller.java:77)
	at net.sf.jasperreports.engine.fill.JRVerticalFiller.<init>(JRVerticalFiller.java:87)
	at net.sf.jasperreports.engine.fill.JRVerticalFiller.<init>(JRVerticalFiller.java:57)
	at net.sf.jasperreports.engine.fill.JRFiller.createFiller(JRFiller.java:142)
	at net.sf.jasperreports.engine.fill.JRFiller.fillReport(JRFiller.java:52)
	at net.sf.jasperreports.engine.JasperFillManager.fillReport(JasperFillManager.java:417)
....","Windows 7, GlassFish 3.1.2, Java 1.7.0_03",chrisie,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 22 16:48:01 UTC 2012,,,,,,,,,,"0|i2bzyv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Aug/12 05:32;paulk;As a workaround, if you are not using Groovy++ or supplying a user modified set of extensions, you can probably just hack/remove the ""META-INF/services/org.codehaus.groovy.source.Extensions"" file from the groovy jar. It contains the ""groovy"" extension but that is the default anyway.;;;","21/Aug/12 06:02;chrisie;Thank you for the suggestion. Unfortunately this is not very practical in my case since we're using Maven to manage all the project's dependencies so this would mean having to manually install the ""patched"" jar on every machine where we need to build to project, which is a bit of a hassle...;;;","21/Aug/12 06:46;paulk;Sure, the suggestion wasn't meant as a long-term approach - more as added feedback that if we fixed the stream closing that the problem would go away for you. In any case, I have applied a fix which should be in the snapshots repos shortly once the CI server gets to do its thing - so perhaps that is more worthy of testing if temporarily pointing to the codehaus snapshots repo is viable for you. Otherwise, it will hopefully be there when we next do a release (no finalised schedule at this point).;;;","21/Aug/12 07:59;chrisie;Thanks a lot for your feedback. I tried the workaround you proposed and I no longer get the first stack trace above, but I am still getting the second one. I might also give the snapshot a try later on if we don't manage to find any other alternative.;;;","21/Aug/12 23:06;paulk;Yes, I couldn't think of a quick workaround for the second case but it shouldn't occur for the 1.8.7 jar. In any case, if you get a chance to try the 2.0.2 or 2.1.0 snapshot jars (as of a few hours ago) they should have both problems fixed.;;;","22/Aug/12 16:48;paulk;I think it should be fixed now but please provide feedback if you find any issues. Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Incorrectly finding ""where"" in query string",GROOVY-5666,12816372,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jschwartzbeck,jschwartzbeck,16/Aug/12 19:25,11/Sep/12 01:15,14/Jul/23 06:00,19/Aug/12 01:30,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,2.1.0-beta-1,SQL processing,,,,0,,,,,,"groovy.sql.Sql.findWhereKeyword returns the index once all the characters in [w,h,e,r,e] are found but not necessarily adjacently.

This causes invalid sql to be generated - null values become conditions.

example of invalid generated sql:
update tbl set wh=null, ere=null, anotherfield is null where id=1",,jschwartzbeck,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Aug/12 19:25;jschwartzbeck;test.groovy;https://issues.apache.org/jira/secure/attachment/12723028/test.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 19 01:30:47 UTC 2012,,,,,,,,,,"0|i2bxvr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"19/Aug/12 01:30;paulk;thanks for spotting that, fix added;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovyc ant task fails with nested javac when using generics,GROOVY-5665,12816465,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,bborchardt,bborchardt,13/Aug/12 17:00,21/Sep/12 16:58,14/Jul/23 06:00,18/Sep/12 08:58,1.8.7,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.4,2.1.0-beta-1,Ant integration,Stub generator / Joint compiler,,,2,ant,compiler,groovy,,,"Unzip the attached project and run the ""compile"" ant target. The following error is given:

Compile error during compilation with javac.
C:\DOCUME~1\bborcha\LOCALS~1\Temp\groovy-generated-3979570706073693155-java-source\test\MyGroovyClass.java:18: incompatible types
found   : java.lang.String
required: T
public static <T extends java.lang.String> T getLast(java.util.List<T> list) { return (java.lang.String)null;}

This error did not occur on groovy 1.8.6 or earlier versions and is preventing us from upgrading.","Tested with Windows XP, Intellij IDEA 11.1.3 with embedded Ant (1.8.2), JDK 1.6.0_31",bborchardt,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"13/Aug/12 17:00;bborchardt;GroovyGenericsBug.zip;https://issues.apache.org/jira/secure/attachment/12722609/GroovyGenericsBug.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 18 08:58:06 UTC 2012,,,,,,,,,,"0|i2cqc7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"18/Sep/12 08:58;guillaume;Fixed as part of GROOVY-5439 and GROOVY-5630;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"OSGi bundle hangs in ""starting"" state",GROOVY-5664,12816507,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,paulbakker,paulbakker,13/Aug/12 04:15,11/Sep/12 01:15,14/Jul/23 06:00,06/Sep/12 09:01,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,,,,,0,,,,,,"When using the Groovy runtime as an OSGi bundle the bundle hangs in ""starting"" state when the framework (Felix) is started:
{code}
38|Starting   |    1|Groovy Runtime (2.0.1)
{code}

Stopping and starting the bundle again seems to fix the problem.",,paulbakker,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 13 04:27:53 UTC 2012,,,,,,,,,,"0|i2ccaf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Aug/12 04:22;paulbakker;The issue seems to be caused because of the ""Bundle-ActivationPolicy: lazy"" header. This might be common in the Eclipse world, but is seen as a bad practice for general OSGi usage. Is there a specific reason to use this?

;;;","13/Aug/12 04:27;paulbakker;Pull request:
https://github.com/groovy/groovy-core/pull/61;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.VerifyError when accessing array passed to method,GROOVY-5662,12816350,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,casp,casp,09/Aug/12 09:24,29/Aug/12 10:37,14/Jul/23 06:00,29/Aug/12 10:37,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,,,,,,0,,,,,,"this code reproduces the error:

void doSomething(long[] values){
  values[1] += 5
}

results in:
Caught: java.lang.VerifyError: (class: test, method: doSomething signature: ([J)V) Expecting to find long on stack
java.lang.VerifyError: (class: test, method: doSomething signature: ([J)V) Expecting to find long on stack

(it works fine in groovy 1.6.4)","Groovy 2.0.1, Linux",blackdrag,casp,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 29 10:37:35 UTC 2012,,,,,,,,,,"0|i2cixz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Aug/12 10:37;blackdrag;should be fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonOutput Date formatting is not threadsafe,GROOVY-5660,12816455,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,johnnywey,johnnywey,06/Aug/12 18:01,11/Sep/12 01:15,14/Jul/23 06:00,07/Aug/12 15:25,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,2.1.0-beta-1,JSON,,,,0,,,,,,"JsonOutput is using a static SimpleDateFormat object. This is not a threadsafe use of that class.

See http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html#synchronization for more details.

I did create a test case for this, but these are hard cases to test and it looks pretty ugly. I will happily submit it, however, if it helps.",,guillaume,johnnywey,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"07/Aug/12 11:19;johnnywey;JsonOutput.groovy.diff;https://issues.apache.org/jira/secure/attachment/12721725/JsonOutput.groovy.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 07 15:28:59 UTC 2012,,,,,,,,,,"0|i2bu7b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Aug/12 18:55;johnnywey;Here's a krufty failing example:

{code:java}
import java.text.SimpleDateFormat
import java.util.concurrent.LinkedBlockingQueue
import java.util.concurrent.ThreadPoolExecutor
import java.util.concurrent.TimeUnit

ThreadPoolExecutor executor = new ThreadPoolExecutor(4, 4, 500, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(1000))
    1000.times {executor.execute(new KillJsonOutput())}
    while (true) {
        sleep(5000)
    }

class KillJsonOutput implements Runnable {
        private SimpleDateFormat formatterLocal = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ"", Locale.US)

        @Override
        void run() {
            formatterLocal.timeZone = TimeZone.getTimeZone('GMT')
            def date = new Date()

            sleep(new Random().nextInt(1000))
            date.setHours(new Random().nextInt(24))
            assert ""\""${formatterLocal.format(date)}\"""" == groovy.json.JsonOutput.toJson(date)

        }
    }
{code};;;","07/Aug/12 11:19;johnnywey;This should make the class threadsafe.;;;","07/Aug/12 11:19;johnnywey;Attached patch.;;;","07/Aug/12 15:25;guillaume;It'll be in 2.0.2 and beyond.
Thanks for the pull request!;;;","07/Aug/12 15:28;johnnywey;Much appreciated ... thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError when CompileStatic with Increment Array Element,GROOVY-5659,12816473,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,uehaj,uehaj,06/Aug/12 02:19,11/Sep/12 01:15,14/Jul/23 06:00,30/Aug/12 08:12,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static compilation,,,,0,,,,,,"I found errors when I use increment(prefix/postfix) operator to an element of array.
Following Code:
{code}
import groovy.transform.*

@CompileStatic
def foo()
{
  int[] p = new int[10]
  p[0]++
}

foo()

{code}

generates following error:
{quote}
$ /tool/groovy-2.0.1/target/install/bin/groovy ~/tmp/test2.groovy
Caught: java.lang.VerifyError: (class: test2, method: foo signature: ()Ljava/lang/Object;) Expecting to find array of objects or arrays on stack
java.lang.VerifyError: (class: test2, method: foo signature: ()Ljava/lang/Object;) Expecting to find array of objects or arrays on stack
{quote}
","Groovy 2.0.1, java version ""1.7.0_05"", MacOSX 10.8",melix,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 23 08:14:31 UTC 2012,,,,,,,,,,"0|i2bz1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Aug/12 08:14;melix;I wouldn't be surprised if the underlying problem is the same as in GROOVY-5671;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SC: issue with optional parameters generating an NPE,GROOVY-5658,12818185,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,01/Aug/12 18:33,11/Sep/12 01:15,14/Jul/23 06:00,29/Aug/12 03:30,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static compilation,,,,0,,,,,,"A problem which seems related to optional parameters (if you remove the optional param in the initPlugins signature, the NPE goes alway):

{code}
import groovy.transform.*

@CompileStatic
class Listener {
    void event() {
        initPlugins()
    }
    static initPlugins(ignoreBinary = false) {}
}

def l = new Listener()
l.event()
{code}
Yields:
{code}
2 ao?t 2012 01:31:47 org.codehaus.groovy.runtime.StackTraceUtils sanitize
ATTENTION: Sanitizing stacktrace:
java.lang.NullPointerException
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.loadArguments(StaticInvocationWriter.java:274)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeDirectMethodCall(InvocationWriter.java:129)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeDirectMethodCall(StaticInvocationWriter.java:188)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:221)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:76)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.makeCall(StaticInvocationWriter.java:406)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:60)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:334)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:648)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:509)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:455)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:319)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:276)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:396)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:783)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)
	at groovy.lang.GroovyShell.run(GroovyShell.java:480)
	at groovy.lang.GroovyShell.run(GroovyShell.java:163)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:951)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor239.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:404)
	at groovy.lang.Closure.run(Closure.java:488)
	at java.lang.Thread.run(Thread.java:680)
2 ao?t 2012 01:31:47 org.codehaus.groovy.runtime.StackTraceUtils sanitize
ATTENTION: Sanitizing stacktrace:
groovy.lang.GroovyRuntimeException: NPE while processing ConsoleScript173
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:198)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:783)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)
	at groovy.lang.GroovyShell.run(GroovyShell.java:480)
	at groovy.lang.GroovyShell.run(GroovyShell.java:163)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:951)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor239.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:404)
	at groovy.lang.Closure.run(Closure.java:488)
	at java.lang.Thread.run(Thread.java:680)
Caused by: java.lang.NullPointerException
{code}",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-08-01 18:33:05.0,,,,,,,,,,"0|i2ciwf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SC: Unable to pop operand off an empty stack with default/optional paramaters,GROOVY-5657,12816510,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,01/Aug/12 18:03,11/Sep/12 01:15,14/Jul/23 06:00,29/Aug/12 05:16,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static compilation,,,,0,,,,,,"Here's an simplified example of what's in Gaelyk:
{code}
import groovy.transform.*
import org.codehaus.groovy.ast.ClassHelper
import org.codehaus.groovy.ast.ASTNode
import org.codehaus.groovy.ast.AnnotationNode
import org.codehaus.groovy.ast.ClassNode
import org.codehaus.groovy.ast.MethodNode
import org.codehaus.groovy.control.SourceUnit
import org.codehaus.groovy.transform.ASTTransformation
import org.codehaus.groovy.control.CompilePhase
import org.codehaus.groovy.transform.GroovyASTTransformation

@CompileStatic
@GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
class EntityTransformation implements ASTTransformation {
    void visit(ASTNode[] nodes, SourceUnit source) {
        ClassNode parent = (ClassNode) nodes[1]
        parent.addMethod(addStaticDelegatedMethod([:]))
    }
    private MethodNode addStaticDelegatedMethod(Map params, ClassNode returnType = ClassHelper.DYNAMIC_TYPE) {}
}

def et = new EntityTransformation()
{code}
At runtime, we get the following problem:
{code}
Exception thrown

java.lang.VerifyError: (class: EntityTransformation, method: visit signature: ([Lorg/codehaus/groovy/ast/ASTNode;Lorg/codehaus/groovy/control/SourceUnit;)V) Unable to pop operand off an empty stack
	at ConsoleScript119.run(ConsoleScript119:23)
{code}
It seems to be related to the fact the method addStaticDelegatedMethod has an default parameter at the end. It also depends on the first parameter being a map (for instance it won't fail if the first parameter is a string). It also works if we explicitly give the optional parameter.",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 01 18:35:02 UTC 2012,,,,,,,,,,"0|i2cg6v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Aug/12 18:35;guillaume;I think the following example is the same occurrence of the problem with parameters with default values:
{code}
import groovy.transform.*

@Singleton
class PluginsHandler {
    void initPlugins(ignoreBinary = false) {}
}

@CompileStatic
class Listener {
    void contextInitialized(String s) {
        PluginsHandler.instance.initPlugins()
    }
}

def l = new Listener()
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC: non ambiguous constructor reference when subclass is used,GROOVY-5656,12816482,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,01/Aug/12 17:17,11/Sep/12 01:15,14/Jul/23 06:00,29/Aug/12 09:08,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,,,,,0,,,,,,"{code}
import groovy.transform.*

class Expr {}
class VarExpr extends Expr {}

class TupList {
    TupList(Expr e1) {}
    TupList(Expr[] es) {}
}

class ArgList extends TupList {
    ArgList(Expr e1) { super(e1) }
    ArgList(Expr[] es) { super(es) }
}

@TypeChecked
class Bug4 {
    void test() {
        new ArgList(new VarExpr())
    }
}

new Bug4().test()
{code}

Yields:
{code}
[Static type checking] - Reference to method is ambiguous. Cannot choose between [MethodNode@745724997[void <init>(Expr)], MethodNode@685460687[void <init>(Expr[])]]
 at line: 19, column: 9
{code}

It's happening somehow because VarExpr is a child of Expr.
In the case of just creating and passing an Expr, things are fine.",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-08-01 17:17:15.0,,,,,,,,,,"0|i2c6gf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SC: byte[] and Byte[] typecasting issue,GROOVY-5655,12816499,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,01/Aug/12 16:36,11/Sep/12 01:15,14/Jul/23 06:00,03/Aug/12 04:54,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static compilation,,,,0,,,,,,"{code}
import groovy.transform.*

@CompileStatic
class Bug3 {
    String test() {
        def b = ""foo"".bytes
        new String(b)
    }
}

new Bug3().test()
{code}
Static compilation is not happy with the above, thinking b is a Byte[] instead of byte[], yielding the following error:
{code}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object '[B@727a9fa7' with class '[B' to class 'byte'
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToNumber(DefaultTypeTransformation.java:146)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.byteUnbox(DefaultTypeTransformation.java:46)
	at Bug3.test(ConsoleScript34:7)

{code}
Whereas, if you explicitly type the variable with {{byte[]}} it's okay.",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-08-01 16:36:25.0,,,,,,,,,,"0|i2cl1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SC: Problem accessing a Map string key with property notation,GROOVY-5654,12816345,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,01/Aug/12 16:22,11/Sep/12 01:15,14/Jul/23 06:00,28/Aug/12 06:32,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static compilation,,,,0,,,,,,"{code}
import groovy.transform.*

@CompileStatic
class Bug2 {
    void test() {
        Map<String, Integer> m = ['abcd': 1234]
        assert m['abcd'] == 1234
        assert m.abcd == 1234
    }
}

new Bug1().test()
{code}

The code above works fine with static type checking.
But it's not happy with static compilation for the last line, where we're using the property notation for

{code}
1 compilation error:

Access to java.util.Map <java.lang.String, java.lang.Integer>#abcd is forbidden at line: 8, column: 16
{code}

Note that an assignment {{m.abcd = 1234}} seems to be okay though.
",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-08-01 16:22:58.0,,,,,,,,,,"0|i2bvkv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC: non ambiguous method call reported ambiguous,GROOVY-5653,12816488,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,01/Aug/12 16:11,11/Sep/12 01:15,14/Jul/23 06:00,29/Aug/12 09:08,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static Type Checker,,,,0,,,,,,"{code}
import groovy.transform.*

@TypeChecked
class Bug1 {
    void m(byte[] bytes) {}
    void m(byte[] bytes, int i1, int i2) {}
    void test() {
        m(""foo"".bytes, 1, 2)
    }
}

new Bug1().test()
{code}

In the example above, STC believes the call is ambiguous, although it doesn't really appear to be. This yields the following compilation error:

{code}
[Static type checking] - Reference to method is ambiguous. Cannot choose between [MethodNode@18204363[void m([B, int, int)], MethodNode@864642116[void m([B)]]
 at line: 8, column: 9
{code}",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-08-01 16:11:21.0,,,,,,,,,,"0|i2c9on:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Semicolon required after coercing to a parameterized (generic) type containing a parameterized (generic) type as its only or last type argument when there is no space between the ending "">>""",GROOVY-5652,12818184,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,adastragrl,adastragrl,01/Aug/12 15:58,06/Mar/18 23:25,14/Jul/23 06:00,02/May/17 02:12,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.6.0-alpha-1,,,parser-antlr2,,,,0,,,,,,"It seems that after coercing an object to a parameterized (generic) type containing a parameterized (generic) type as its only or last type argument without putting any space between the ending "">>"", a semicolon is needed.

Example:

$ groovy -v
Groovy Version: 1.8.6 JVM: 1.6.0_30 Vendor: Sun Microsystems Inc. OS: Linux
$ groovy -e ""def list = [1,2,3,4] as List<Integer>
println list
println 'bye'"" # This works fine.
[1, 2, 3, 4]
bye
$ groovy -e ""def list = [[1,2],[3,4]] as List<List<Integer>>
println list
println 'bye'"" # This should work fine, but does not.
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
script_from_command_line: 2: expecting EOF, found 'println' @ line 2, column 1.
   println list
   ^

1 error

$ groovy -e ""def list = [[1,2],[3,4]] as List<List<Integer> >
println list
println 'bye'"" # After adding a space between "">>"", this works fine.
[[1, 2], [3, 4]]
bye
$ groovy -e ""def list = [[1,2],[3,4]] as List<List<Integer>>;
println list
println 'bye'"" # Or, after adding a semicolon, this works fine.
[[1, 2], [3, 4]]
bye
$
",,adastragrl,daniel_sun,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7972,,GROOVY-8015,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 20 01:58:29 UTC 2017,,,,,,,,,,"0|i2bnvb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Aug/12 16:24;adastragrl;Also, I confirmed that GROOVY-2725 is indeed fixed when I try out the exact test case in there, so I'm curious why whatever fixed that didn't fix this...;;;","27/Apr/14 07:20;paulk;My guess is the "">>"" operator is picked up in the parsing and there is nothing after the "">>"" which wouldn't be valid after a real "">>"". It would be nice if we could tweak the grammar guards/priorities to avoid this.;;;","20/Jan/17 01:58;daniel_sun;Fixed in the parrot branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy 2.0.1: Regression in generic type inference,GROOVY-5650,12818433,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,perplex79,perplex79,01/Aug/12 02:38,11/Sep/12 01:15,14/Jul/23 06:00,22/Aug/12 07:43,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static Type Checker,,,,0,,,,,,"The following Groovy code compiles with @TypeChecked in 2.0.0, but not in 2.0.1:

JavaClass.java
{code}import java.util.List;
import java.util.ArrayList;
import java.util.Collection;

public class JavaClass {

    public static class Container<T> {
    }

    public static class StringContainer extends Container<String> {
    }

    public static <T> List<T> unwrap(Collection<? extends Container<T>> list) {
        return null;
    }

    public static void main(String[] args) {
        final List<StringContainer> containers = new ArrayList<>();
        final List<String> strings = unwrap(containers);
    }
}{code}

GroovyClass.groovy
{code}import groovy.transform.TypeChecked;

@TypeChecked
class GroovyClass {

    public static void javaCall() {
        final List<JavaClass.StringContainer> containers = new ArrayList<>();
        containers.add(new JavaClass.StringContainer()); 
        final List<String> strings = JavaClass.unwrap(containers);
    }

    public static void main(String[] args) { 
        javaCall();
    }
}{code}


Groovy 2.0.0 compiles the code without errors or warnings, but 2.0.1 gives the following error message:

{noformat}/home/.../GroovyClass.groovy: 8: [Static type checking] - Incompatible generic argument types. Cannot assign java.util.List <JavaClass> to: java.util.List <String>
 @ line 8, column 38.
           final List<String> strings = JavaClass.unwrap(containers);
                                        ^

1 error{noformat}

Somehow Groovy infers the type to the static method's class, instead of the container's type argument.
",,dlichtenberger,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-08-01 02:38:53.0,,,,,,,,,,"0|i2c1yv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stack overflow when property accessor is annoated with @CompileStatic,GROOVY-5649,12816461,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,boaznahum,boaznahum,31/Jul/12 10:26,11/Sep/12 01:15,14/Jul/23 06:00,28/Aug/12 06:06,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static compilation,,,,0,compilestatic,,,,,"{code}
class HaveOption {

  private String helpOption;


  @CompileStatic
  public void setHelpOption(String helpOption) {
    this.helpOption = helpOption
  }

}
{code}
Calling setHelpOption cause stack overflow
{code}
Exception in thread ""main"" java.lang.StackOverflowError
	at utils.tests.HaveOption.setHelpOption(HaveOption.groovy:15)
	at utils.tests.HaveOption.setHelpOption(HaveOption.groovy:15)
	at utils.tests.HaveOption.setHelpOption(HaveOption.groovy:15)
	at utils.tests.HaveOption.setHelpOption(HaveOption.groovy:15)
	at utils.tests.HaveOption.setHelpOption(HaveOption.groovy:15)
{code}

",Windows 7 64 bit. JDK 1.7.04 32 bit,boaznahum,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-31 10:26:25.0,,,,,,,,,,"0|i2c42v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SKIP is not honored when an inner class is defined in a SKIP method,GROOVY-5647,12816449,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,sdmurphy,sdmurphy,30/Jul/12 12:37,11/Sep/12 01:15,14/Jul/23 06:00,30/Aug/12 11:17,2.0.2,2.1.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Compiler,,,,0,,,,,,"{code}
    @CompileStatic(TypeCheckingMode.SKIP)
    static Closure memoize(MemcacheService memcache, Closure closure) {
        return new Closure(closure.owner) {
            Object call(Object[] args) {
                // a closure call is identified by its hashcode and its call argument values
                def key = [
                        closure: closure.hashCode(),
                        arguments: args.toList()
                ]
                // search for a result for such a call in memcache
                def result = memcache.get(key)
                if (result != null) {
                    // a previous invocation exists
                    return result
                } else {
                    // no previous invocation, so calling the closure and caching the result 
                    result = closure(* args)
                    put(memcache, key, result, Expiration.byDeltaSeconds(60), SetPolicy.SET_ALWAYS)
                    return result
                }
            }
        }
    }
{code}

results in

{code}
/glaforge-gaelyk/core/src/main/groovyx/gaelyk/GaelykCategory.groovy: 1687: [Static type checking] - The spread operator cannot be used as argument of method or closure calls with static type checking because the number of arguments cannot be determined at compile time
 @ line 1687, column 38.
                       result = closure(* args)
                                        ^

1 error
{code}

yet it has been annotated with
@CompileStatic(TypeCheckingMode.SKIP)",,sdmurphy,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 30 12:42:41 UTC 2012,,,,,,,,,,"0|i2bysf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Jul/12 12:42;sdmurphy;https://github.com/glaforge/gaelyk/tree/groovy2;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic cause inconsistent compilation error when varargs super method called (reference to method is ambiguous),GROOVY-5645,12818181,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,topr,topr,30/Jul/12 07:32,11/Sep/12 01:15,14/Jul/23 06:00,03/Aug/12 08:45,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Compiler,,,,0,,,,,,"Consider an example base class:
{code:java}
class BaseObject {
    void trace(Integer logLevel, Object... args) { /* ... */ }
    void trace(Object... args) { /* ... */ }
}
{code}
and the extending class:
{code:java}
@CompileStatic
class ChildObject extends BaseObject {
    void doSomething() {
        trace('test2')          // OK
        super.trace('test2')    // OK
        trace(1, 'test1')       // OK
        super.trace(1, 'test1') // compilation error
    }
}
{code}

When a type checked compilation is enabled following error appears on the last line of 2nd example class:
{code}[Static type checking] - Reference to method is ambiguous. Cannot choose between [MethodNode@1022828757[void trace([Ljava.lang.Object;)], MethodNode@76324664[void trace(java.lang.Integer, [Ljava.lang.Object;)]]{code}

I've come across this problem when extending closed library class which has methods of such signatures. Only difference is no Integer passed, but some custom class object of the library API as the 1st param. Compilation error is the same.
Pay attention to the fact, that the +error is thrown only when 'super' keyword preceding method call+.","Linux 3.2.0-27-generic #43-Ubuntu SMP Fri Jul 6 14:25:57 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux
",topr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-30 07:32:03.0,,,,,,,,,,"0|i2clr3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
UFO Operator(<=>) errors with CompileStatic and TypeChecked,GROOVY-5644,12818180,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,uehaj,uehaj,29/Jul/12 02:39,11/Sep/12 01:15,14/Jul/23 06:00,21/Aug/12 09:27,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static compilation,Static Type Checker,,,0,,,,,,"When I use UFO operator in following code:
{code}
@groovy.transform.CompileStatic
def main() {
  Closure c = { Integer l, Integer r -> l <=> r }
  // Closure c = { Integer l, Integer r -> l.compareTo(r) } // OK
  println([7, 4, 1, 2, 3].sort(c))
}
main()
{code}
reports:
{quote}
Caught: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'ufo@7067f21' with class 'ufo' to class 'java.lang.Comparable'
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'ufo@7067f21' with class 'ufo' to class 'java.lang.Comparable'
	at ufo$_main_closure1.doCall(ufo.groovy)
	at ufo.main(ufo.groovy:6)
	at ufo.run(ufo.groovy:8)
{quote}
and I found another case, i don't know the relation of above case.
When running:
{code}
@groovy.transform.TypeChecked
def main() {
  Integer x = 3
  Integer y = 4
  println (x <=> y)
}
main()
{code}
Static type checker claims:
{quote}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/tool/ufo2.groovy: 6: [Static type checking] - Reference to method is ambiguous. Cannot choose between [MethodNode@2142220333[int compareTo(java.lang.Object)], MethodNode@153838582[int compareTo(java.lang.Integer)]]
 @ line 6, column 12.
     println (x <=> y)
              ^

1 error
{quote}","MacOSX 10.8
java version ""1.7.0_05""
Java(TM) SE Runtime Environment (build 1.7.0_05-b06)
Java HotSpot(TM) 64-Bit Server VM (build 23.1-b03, mixed mode)",melix,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 21 09:27:46 UTC 2012,,,,,,,,,,"0|i2conz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Aug/12 09:27;melix;Actually there were two bugs in one. Thanks for the report!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
array length is not correct with CompileStatic'd code.,GROOVY-5643,12816422,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,uehaj,uehaj,28/Jul/12 21:02,11/Sep/12 01:15,14/Jul/23 06:00,27/Aug/12 10:40,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Compiler,,,,0,,,,,,"In following code, the second assert fails.

{code}
@groovy.transform.CompileStatic
def main(){
  boolean[] flags1 = new boolean[10]
  assert flags1.class == boolean[]
  assert flags1.size() == 10 // OK

  def flags2 = new boolean[10] // dynamic type
  assert flags2.class == boolean[]
  assert flags2.size() == 10 // LHS is 1(not expected)
}

main()
{code}

I tried also int[] instead of boolean[]
{code}
@groovy.transform.CompileStatic
def main(){
  int[] flags1 = new int[10]
  assert flags1.class == int[]
  assert flags1.size() == 10 // OK

  def flags2 = new int[10]  // dynamic type
  assert flags2.class == int[]
  assert flags2.size() == 10 // Caught: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object '[I@3b845321' with class '[I' to class 'int'
}

main()

{code}

When remove CompileStatic annotation, above are no problem.
Using @TypeChecked instead of @CompileStatic claims nothing.
I think it is a problem about the code generated by CompileStatic or type inference.
","Mac OX X 10.7.4
java version ""1.7.0_04""
Java(TM) SE Runtime Environment (build 1.7.0_04-b21)
Java HotSpot(TM) 64-Bit Server VM (build 23.0-b21, mixed mode)",melix,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 27 10:40:14 UTC 2012,,,,,,,,,,"0|i2cp3j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Aug/12 10:40;melix;Doesn't happen on master, probably fixed as part of GROOVY-5655;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"TypeChecked/CompileStatic says ambiguous about calling PrintWriter.write(byte[],int,int)",GROOVY-5642,12816447,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,uehaj,uehaj,28/Jul/12 20:36,11/Sep/12 01:15,14/Jul/23 06:00,03/Aug/12 09:00,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Compiler,,,,0,,,,,,"I tried TypeChecked/CompileStatic with calling PrintWriter.write(byte[], int, int) in following code:
{code}
//@groovy.transform.CompileStatic

@groovy.transform.TypeChecked
def main() {
  byte[] data = [1,2,3] as byte[]
  System.out.write((byte[])data, (int)0, (int)0)
}

main()
{code}

raises following static type check error:
{quote}
m.groovy: 11: [Static type checking] - Reference to method is ambiguous. Cannot choose between [MethodNode@1587779925[void write([B, int, int)], MethodNode@1727501758[void write([B)], MethodNode@957941600[void write([B)], MethodNode@902239314[void write([C)]]
 @ line 11, column 3.
     System.out.write((byte[])data, (int)0, (int)0)
     ^

1 error
{quote}
When tried without cast operator( System.out.write(data,0,0) ), the result was similar.
When I tried to call method which i defined, no error detected:
{code}
@groovy.transform.TypeChecked
def foo(byte[] c, int a, int b)
{}

@groovy.transform.TypeChecked
def main() {
  byte[] data = [1,2,3] as byte[]
  foo((byte[])data, (int)0, (int)0)
}

main()
{code}
","MacOS X, ",melix,uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 03 09:00:52 UTC 2012,,,,,,,,,,"0|i2bn07:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Aug/12 09:00;melix;Duplicate of GROOVY-5645;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
for variable omitted type makes Caught: BUG! exception in phase 'class generation',GROOVY-5641,12816464,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,uehaj,uehaj,28/Jul/12 09:30,11/Sep/12 01:15,14/Jul/23 06:00,29/Aug/12 10:25,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,class generator,Compiler,,,0,,,,,,"Following code:
{code}
@groovy.transform.CompileStatic
def foo() {
    int[] perm = new int[10]
    for (i in 0..<10) {
      println(perm[i-0])
    }
}

{code}
generates error message:

{quote}Caught: BUG! exception in phase 'class generation' in source unit '/private/tmp/f.groovy' At line 13 column 20
On receiver: i with message: minus and arguments: 0
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY
BUG! exception in phase 'class generation' in source unit '/private/tmp/f.groovy' At line 13 column 20
On receiver: i with message: minus and arguments: 0
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY
{quote}

following is ok
{code}
@groovy.transform.CompileStatic
def foo() {
    int[] perm = new int[10]
    for (int i in 0..<10) {
      println(perm[i-0])
    }
}

{code}","Mac OS X
 java version ""1.6.0_33""
Java(TM) SE Runtime Environment (build 1.6.0_33-b03-424-11M3720)
Java HotSpot(TM) 64-Bit Server VM (build 20.8-b03-424, mixed mode)",uehaj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 28 09:36:04 UTC 2012,,,,,,,,,,"0|i2boxr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Jul/12 09:36;uehaj;with code:
{code}
@groovy.transform.CompileStatic
def foo() {
    int[] perm = new int[10]
    for (i in 0..<10) {
      print(perm[i] + 1)
    }
}
{code}
generates:
{quote}
Caught: java.lang.VerifyError: (class: f, method: foo signature: ()Ljava/lang/Object;) Expecting to find array of objects or arrays on stack
java.lang.VerifyError: (class: f, method: foo signature: ()Ljava/lang/Object;) Expecting to find array of objects or arrays on stack
{quote}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static type checking fails in for-each loops,GROOVY-5640,12818179,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,wujek.srujek,wujek.srujek,28/Jul/12 08:05,11/Sep/12 01:15,14/Jul/23 06:00,27/Aug/12 09:38,2.0.0,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static Type Checker,,,,0,,,,,,"I have some code that fail to compile with type checking. The example is not contrived, it comes from a real-life project that uses neo4j. The Node_ class is called Node, and I changed it here so that we exclude the possibility that Groovy somehow treats it as its Node class (which it doesn't anyways). The following code:

{code}
package test

import groovy.transform.TypeChecked

@TypeChecked
class Test {

    public void traverse() {
        println new Node_().class.name
        for (/*Object*/Node_ node : new MyTraverser().nodes()) {
            println node.class.name
        }
    }
}

class Node_ {}

interface Traverser {

    Iterable<Node_> nodes();
}

class MyTraverser implements Traverser {

    @Override
    Iterable<Node_> nodes() {
        []
    }
}
{code}

does not compile with the following error:

{noformat}
$ groovyc Test.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Test.groovy: 12: [Static type checking] - Cannot loop with element of type test.Node -> test.Node with collection of type java.util.List <java.lang.Object> -> java.util.List <E extends java.lang.Object -> java.lang.Object>
 @ line 12, column 9.
           for (/*Object*/Node node : new MyTraverser().nodes()) {
{noformat}

It compiles fine when the iteration uses Object instead of Node_, and when there is no type checking.","$ uname -a
Linux studio 3.2.0-25-generic #40-Ubuntu SMP Wed May 23 20:30:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux

$ java -version
java version ""1.7.0_04""
Java(TM) SE Runtime Environment (build 1.7.0_04-b20)
Java HotSpot(TM) 64-Bit Server VM (build 23.0-b21, mixed mode)",wujek.srujek,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-28 08:05:56.0,,,,,,,,,,"0|i2cc93:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Spurious ""Closure shared variable has been assigned with various type"" exception",GROOVY-5639,12811610,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,mpierce,mpierce,27/Jul/12 17:16,11/Sep/12 01:15,14/Jul/23 06:00,21/Aug/12 11:07,2.0.0,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static Type Checker,,,,0,,,,,,"Compiling this fails:

{code}
import groovy.transform.TypeChecked

@TypeChecked
class Foo {

    private void doIt() {
        Closure<Void> c = {
            List<String> list = new ArrayList<String>()
            String s = ""foo""
            10.times {
                list.add(s)
            }
        }
    }
}
{code}

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Foo.groovy: 11: [Static type checking] - A closure shared variable [list] has been assigned with various types and the method [add(java.lang.Object <E>)] does not exist in the lowest upper bound of those types: [java.util.ArrayList <java.lang.String>]. In general, this is a bad practice (variable reuse) because the compiler cannot determine safely what is the type of the variable at the moment of the call in a multithreaded context.
 @ line 11, column 17.
                   list.add(s)
                   ^

1 error
{noformat}




The error only occurs when a closure is involved. The following works fine:

{code}
import groovy.transform.TypeChecked

@TypeChecked
class Bar {
    void doIt() {
        List<String> list = new ArrayList<String>()
        String s = ""foo""
        10.times {
            list.add(s)
        }
    }
}
{code}",64-bit Linux JDK 1.7.0.5,melix,mpierce,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 21 11:07:41 UTC 2012,,,,,,,,,,"0|i2ctmf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Aug/12 11:07;melix;The problem was that the type checker didn't use the real argument types in the second pass, but the argument types of the potential method. In that case, it tried to find a method {{List#add(Object)}} instead of {{List#add(String)}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static compiler fails with bug massage for method call in loop increment,GROOVY-5638,12816278,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,blackdrag,blackdrag,27/Jul/12 14:59,11/Sep/12 01:15,14/Jul/23 06:00,03/Aug/12 11:36,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,Static compilation,,,,0,,,,,,"This code{code:Java}
@CompileStatic
class X {
    static void bar(){
        for (int i=0;i<1000000; i+=foo()){}
    }
    static foo(){1}
}{code}
may not make so much sense, but should at least not fail during compilation with a GroovyBugError. The message complains about the method call in the i+=foo() part",,blackdrag,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 03 09:44:01 UTC 2012,,,,,,,,,,"0|i2cfzz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Aug/12 09:44;melix;The problem doesn't seem to be related to the loop increment, but with the fact of calling a static method as an argument of plus:
{code}
static foo() { 1 }
1+foo()
{code}
produces:
{noformat}
On receiver: 1 with message: plus and arguments: TestScripttestMethodCallInForLoopIncrement9.foo()
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesCallSiteWriter.makeSingleArgumentCall(StaticTypesCallSiteWriter.java:519)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeSingleArgumentCall(InvocationWriter.java:480)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateBinaryExpression(BinaryExpressionHelper.java:504)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionMultiTypeDispatcher.evaluateBinaryExpression(BinaryExpressionMultiTypeDispatcher.java:216)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:142)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:527)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:582)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:505)
	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:455)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:319)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:276)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:396)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:783)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:625)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:516)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:556)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:537)
	at groovy.lang.GroovyShell$evaluate.call(Unknown Source)
	at groovy.transform.stc.StaticTypeCheckingTestCase.assertScript(StaticTypeCheckingTestCase.groovy:62)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:272)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:52)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at groovy.transform.stc.LoopsSTCTest.testMethodCallInForLoopIncrement(LoopsSTCTest.groovy:165)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:157)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:76)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:195)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:63)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
{noformat};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.ArrayIndexOutOfBoundsException: size==0,GROOVY-5636,12818171,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,guillaume,sdmurphy,sdmurphy,27/Jul/12 00:25,11/Sep/12 01:15,14/Jul/23 06:00,30/Jul/12 08:24,2.0.1,2.0.2,2.1.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,2.1.0-beta-1,,Compiler,,,,0,,,,,,"Problem compiling a Groovy class using the @CompileStatic annotation

https://github.com/glaforge/gaelyk/tree/groovy2

:core:compileGroovy
index problem in /glaforge-gaelyk/core/src/main/groovyx/gaelyk/GaelykCategory.groovy
startup failed:
General error during class generation: size==0

java.lang.ArrayIndexOutOfBoundsException: size==0
	at org.codehaus.groovy.classgen.asm.OperandStack.getTopOperand(OperandStack.java:717)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:297)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesBinaryExpressionMultiTypeDispatcher.evaluateEqual(StaticTypesBinaryExpressionMultiTypeDispatcher.java:97)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:78)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:527)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:509)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:455)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeIfElse(StatementWriter.java:296)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitIfElse(AsmClassGenerator.java:471)
	at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:41)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:455)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:319)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:276)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:396)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:783)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:496)
	at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:109)
	at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:39)
	at org.gradle.api.internal.tasks.compile.daemon.CompilerDaemonServer.execute(CompilerDaemonServer.java:52)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.messaging.remote.internal.TypeCastDispatch.dispatch(TypeCastDispatch.java:30)
	at org.gradle.messaging.remote.internal.WorkerProtocol.handleIncoming(WorkerProtocol.java:53)
	at org.gradle.messaging.remote.internal.WorkerProtocol.handleIncoming(WorkerProtocol.java:31)
	at org.gradle.messaging.remote.internal.ProtocolStack$ProtocolStage.handleIncoming(ProtocolStack.java:167)
     rg.gradle.messaging.remote.internal.ProtocolStack$BottomStage.handleIncoming(ProtocolStack.java:277)
	at org.gradle.messaging.remote.internal.ProtocolStack$BottomConnection$1.run(ProtocolStack.java:299)
	at org.gradle.messaging.remote.internal.ProtocolStack$ExecuteRunnable.dispatch(ProtocolStack.java:120)
	at org.gradle.messaging.remote.internal.ProtocolStack$ExecuteRunnable.dispatch(ProtocolStack.java:116)
	at org.gradle.messaging.dispatch.AsyncDispatch.dispatchMessages(AsyncDispatch.java:132)
	at org.gradle.messaging.dispatch.AsyncDispatch.access$000(AsyncDispatch.java:33)
	at org.gradle.messaging.dispatch.AsyncDispatch$1.run(AsyncDispatch.java:72)
	at org.gradle.messaging.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:680)

1 error
",,guillaume,sdmurphy,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 30 08:24:05 UTC 2012,,,,,,,,,,"0|i2cr67:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Jul/12 08:24;guillaume;So the problem was about spread arguments.
Spread arguments like in foo(*args) are not allowed in static type checking and compilation, as it's impossible to infer the number of arguments in the final call of the method (depends on runtime knowledge).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"SyntaxException.getEndColumn() returns ""getStartColumn() + 1""",GROOVY-5635,12816392,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,ariel.andres.morelli,ariel.andres.morelli,26/Jul/12 14:37,05/Apr/15 14:44,14/Jul/23 06:00,27/Jul/12 23:38,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,2.1.0-beta-1,,Compiler,,,,1,,,,,,"The exception {{org.codehaus.groovy.syntax.SyntaxException.getEndColumn()}} returns always {{getStartColumn() + 1}}.
(you can check that in the source code)

I'm trying to integrate the compiler to an IDE (JDeveloper) and I cannot get the error length to underline it properly.

I'm sending you a patch that obtains the error length from all the ASTNode's.
In the patch, I haven't deleted any unused constructor (even if it isn't used any more by the compiler) to maintain API backward compatibility.

I would really appreciate if you could fix it from groovy 2.0.2 on.",,ariel.andres.morelli,blackdrag,ebergama,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Jul/12 08:01;ariel.andres.morelli;0001-GROOVY-5635.-SyntaxException.getEndColumn-returns-ge.patch;https://issues.apache.org/jira/secure/attachment/12722920/0001-GROOVY-5635.-SyntaxException.getEndColumn-returns-ge.patch","26/Jul/12 14:37;ariel.andres.morelli;SyntaxExceptionLastColumn.patch;https://issues.apache.org/jira/secure/attachment/12722172/SyntaxExceptionLastColumn.patch","27/Jul/12 08:06;ariel.andres.morelli;git_diff.patch;https://issues.apache.org/jira/secure/attachment/12722537/git_diff.patch",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Mon Jul 30 07:48:14 UTC 2012,,,,,,,,,,"0|i2c5g7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jul/12 14:40;ariel.andres.morelli;Reading the Priority descriptions, Blocker seems excessive. 
I tried to change it, but I'm unable to do it.;;;","27/Jul/12 03:37;blackdrag;Ariel, the patch you show contains a lot of text and not all of that is really part of the patch, but of stuff idea added. It would be very good if you could either make a pull request, or use ""git diff"" to make the patch. Is that possible?;;;","27/Jul/12 08:01;ariel.andres.morelli;Patch using ""git format-patch"" in branch GROOVY_2_0_X;;;","27/Jul/12 08:06;ariel.andres.morelli;Attaching patch using ""git diff"";;;","27/Jul/12 09:26;blackdrag;The patch looks like it makes a compatible change, nice. If I nitpick I could say that getLineLast and getColumnLast should be getLastLine and getLastColumn, since we used it in that style already.;;;","27/Jul/12 23:26;paulk;Added to master;;;","30/Jul/12 07:48;ariel.andres.morelli;Thanks! :-);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
indy transformation for receiver missing,GROOVY-5633,12816468,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,26/Jul/12 07:14,11/Sep/12 01:15,14/Jul/23 06:00,26/Jul/12 07:21,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,,,,,0,indy,,,,,"This code:{code}
import static java.lang.Math.*

  R = 1;  C1 = 0.4; C2 = 0.9;  C3 = 6


//niters = getInt(""How many iterations of the Ikeda map"");
niters = 200000
x = new double[niters]
y = new double[niters]
x[0]=0.12; y[0]=0.2

k=1
km=0
  tau=0.0;  sintau=0.0;  costau=0.0

while  (k< niters)  {
   km=k-1
   tau = C1-C3/(1+x[km]*x[km]+y[km]*y[km])
   sintau = sin(tau); costau = cos(tau);
   x[k] = R+C2*(x[km]*costau-y[km]*sintau)
   y[k] = C2*(x[km]*sintau+y[km]*costau)

   k++
}
{code}
fails with a cast exception complaining it cannot cast BigDecimal to double. The reason is that C1 - (C3/(1+x[km]*x[km]+y[km]*y[km])) is a BigDecimal-Double operation, for which a double,double method will be selected. This requires a transformation of the receiver from BigDecimal to double. The current code does this only for the arguments.
",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 26 07:21:13 UTC 2012,,,,,,,,,,"0|i2c0tb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jul/12 07:21;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closure default params can cause BUG! exception in phase 'class generation',GROOVY-5632,12818174,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,tim_yates,tim_yates,26/Jul/12 02:56,12/Jan/13 20:40,14/Jul/23 06:00,08/Jan/13 11:10,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,Compiler,,,,0,,,,,,"Default parameters for methods can be used in further default parameters, ie:

{code}
def f( int x, fn={ -> x } ) {
  fn()
}

f( 10 )
{code}
(outputs 10)

However, if I give {{x}} a default value:

{code}
def f( int x=3, fn={ -> x } ) {
  fn()
}

f( 10 )
{code}

We get:

{code}
BUG! exception in phase 'class generation' in source unit 'ConsoleScript96' tried to get a variable with the name x as stack variable, but a variable with this name was not created
	at org.codehaus.groovy.classgen.asm.CompileStack.getVariable(CompileStack.java:280)
	at org.codehaus.groovy.classgen.asm.ClosureWriter.loadReference(ClosureWriter.java:131)
	at org.codehaus.groovy.classgen.asm.ClosureWriter.writeClosure(ClosureWriter.java:102)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClosureExpression(AsmClassGenerator.java:546)
	at org.codehaus.groovy.ast.expr.ClosureExpression.visit(ClosureExpression.java:43)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitCastExpression(AsmClassGenerator.java:616)
	at org.codehaus.groovy.ast.expr.CastExpression.visit(CastExpression.java:66)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.loadArguments(InvocationWriter.java:183)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeDirectMethodCall(InvocationWriter.java:129)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:221)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:76)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:60)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:334)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:648)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:582)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeReturn(OptimizingStatementWriter.java:316)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:505)
	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:319)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:276)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:396)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:783)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)
	at groovy.lang.GroovyShell.run(GroovyShell.java:480)
	at groovy.lang.GroovyShell.run(GroovyShell.java:163)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:951)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor218.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:404)
	at groovy.lang.Closure.run(Closure.java:488)
	at java.lang.Thread.run(Thread.java:680)
{code}
","Groovy Version: 2.0.1 JVM: 1.6.0_33 Vendor: Apple Inc. OS: Mac OS X
",andre.steingress,blackdrag,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 08 11:10:03 UTC 2013,,,,,,,,,,"0|i2bukv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Dec/12 06:45;andre.steingress;I just stumbled across the same issue. I guess the problem is caused by the generated non-parameter method f() which in fact creates (invalid) code similar to

{code}
def f() {
    this.f((Object) 3, (Object) { -> x })
}
{code};;;","11/Dec/12 06:54;andre.steingress;I guess the Verifier generating the default value methods should handle this situation. I see if I can provide a fix.;;;","11/Dec/12 16:22;andre.steingress;Here is the pull request: https://github.com/groovy/groovy-core/pull/80 ;;;","12/Dec/12 04:08;blackdrag;A possible alternative path to the pull request could be that for ""f( int x=3, fn={ -> x } )"" we create f(){ f(3) }, f(int x) { f(x,{-> x}}, f(x,fn){fn()}. Right now there are direct calls to the two argument function. With many default parameters though this could lead more easily to a StackOverflowException.;;;","08/Jan/13 11:10;blackdrag;pull request merged;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java stub generator generates wrong cast for return value of generic method,GROOVY-5630,12818183,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,guillaume,pniederw,pniederw,25/Jul/12 17:18,21/Sep/12 16:58,14/Jul/23 06:00,18/Sep/12 06:32,1.8.7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.4,2.1.0-beta-1,Stub generator / Joint compiler,,,,0,,,,,,"From org/gradle/util/HelperUtil.groovy:

{code}
class HelperUtil {
    ...
    static <T extends Task> T createTask(Class<T> type) {
        ...
    }
    ...
}
{code}

Generated method stub in Groovy 1.8.6:

{code}
public static <T extends org.gradle.api.Task> T createTask(java.lang.Class<T> type) { return (T)null;}
{code}

This stub compiles fine.

Generated method stub in Groovy 1.8.7:

{code}
public static <T extends org.gradle.api.Task> T createTask(java.lang.Class<T> type) { return (org.gradle.api.Task)null;}
{code}

This stub gives the following compile error:

{noformat}
/swd/prj/gradle/subprojects/core/build/tmp/groovy-java-stubs/org/gradle/util/HelperUtil.java:22: error: incompatible types
public static <T extends org.gradle.api.Task> T createTask(java.lang.Class<T> type) { return (org.gradle.api.Task)null;}
                                                                                             ^
  required: T
  found:    Task
  where T is a type-variable:
    T extends Task declared in method <T>createTask(Class<T>)
{noformat}",,andreasgorges,armsargis,guillaume,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 21 11:40:48 UTC 2012,,,,,,,,,,"0|i2c9en:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jul/12 14:00;andreasgorges;i've got a similar warning (groovy 2.0.1) in a different situation:

{code}
package problem;

class Problem {

    final Map<String, String> test = new HashMap<String, String>();
    
}
{code}

{code}
groovyc -j -F ""Xlint:unchecked"" --sourcepath src src/problem/*
/var/folders/pq/gbxmjp0n7ls8jxq4w6xq794c0000gn/T/groovy-generated-1435919399539896163-java-source/problem/Problem.java:18: warning: [unchecked] unchecked conversion
public final  java.util.Map<java.lang.String, java.lang.String> getTest() { return (java.util.Map)null;}
                                                                                   ^
  required: Map<String,String>
  found:    Map
1 warning
{code}

i hope it's the same error!
;;;","18/Sep/12 06:32;guillaume;I fixed that as part of GROOVY-5710 actually.;;;","21/Sep/12 11:08;pniederw;Thanks Guillaume. When is 1.8.9 coming? Gradle is still stuck at 1.8.6 due to this bug.;;;","21/Sep/12 11:11;guillaume;I'm releasing 2.0.4 today, but 1.8.9 hasn't yet been scheduled.
But considering Gradle is looking forward to it, we can try to get that done perhaps next week if you will.;;;","21/Sep/12 11:17;pniederw;Gradle itself doesn't have any issues with 1.8.6, but it's definitely good to keep moving (also for our users, their plugins, etc.).;;;","21/Sep/12 11:30;pniederw;bq. I'm releasing 2.0.4 today

Is that 2.0.4 or 2.0.3? Will there also be -indy Jars (I can see the regular 2.0.3 Jars on Maven Central but not the -indy ones)?;;;","21/Sep/12 11:40;guillaume;It's 2.0.4, as there was a problem with the 2.0.3 release which was indeed missing the indy ones.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
new JsonBuilder('<complex xml string>').toPrettyPrint() throws StackOverflowException,GROOVY-5628,12816517,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,crykal79,crykal79,25/Jul/12 11:25,26/Jul/12 14:45,14/Jul/23 06:00,26/Jul/12 14:45,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,,,JSON,,,,0,,,,,,"When we run the following, 
{code}
new JsonBuilder('<a a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\"" a=\\""\\""/>').toPrettyPrint()
{code}
we get a StackOverflowException
{code}
 java.lang.StackOverflowError
	at java.lang.Character.codePointAt(Character.java:2335)
	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3344)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3760)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
        ...
{code}
We have made a basic change to fix the problem as an override/temporary solution as follows...
{code}
JsonTokenType.STRING.validator = Pattern.compile('""(?>[^""\\\\]+|\\\\[""\\\\bfnrt\\/]|\\\\u[0-9a-fA-F]{4})*""', Pattern.DOTALL)
{code}
The main change is the addition of ?> and the change from * to +.","Windows 7, Java 6, IntelliJ IDEA",crykal79,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 26 12:45:21 UTC 2012,,,,,,,,,,"0|i2byqn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Jul/12 12:17;guillaume;Could you please try with Groovy 1.8.7 (just released) or Groovy 2.0.1 just released as well?
There were some changes related to that in 1.8.7 and beyond.;;;","25/Jul/12 12:19;guillaume;Also please post a valid sample reproducing the problem.;;;","25/Jul/12 12:30;guillaume;Using this example worked fine for me with Groovy 2.0.1:
{code}
def txt = '<a ' + ('a=\\""\\""' * 100) + '/>'
new groovy.json.JsonBuilder(txt).toPrettyString()
{code};;;","26/Jul/12 12:45;crykal79;Thanks Guillaume!  I ran your example only with 1000 instead of 100 and it definitely fails prior to 1.8.7 but works in 1.8.7 and beyond.  We'll just upgrade to that version!  Thanks again!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problems with categories when using invoke dynamic,GROOVY-5627,12816371,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,guillaume,guillaume,25/Jul/12 05:21,11/Sep/12 01:15,14/Jul/23 06:00,25/Jul/12 17:57,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,,,,,,,0,,,,,,"If you have a call site, that has been visited before, it will not be updated with the category. 

If the callsite has been visited first with the category, it will not be invalidated once the category is not available anymore. 

And if Thread x uses a category, Thread y may see it as well although it shouldn't.",When using the indy jars of groovy,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-25 05:21:06.0,,,,,,,,,,"0|i2clgv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"collection's ""each"" fails if compiled with @CompileStatic",GROOVY-5623,12816415,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,nplekhanov,nplekhanov,24/Jul/12 02:13,26/Jul/12 16:49,14/Jul/23 06:00,24/Jul/12 02:22,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,,,,0,,,,,,"{code}
@Test
@CompileStatic
void test() {
    int n = 0;
    String.getDeclaredFields().each {n++}
    assert n > 0
}
{code}

failed in runtime with

{noformat}
java.lang.VerifyError: (class: EachByClosureTest, method: test signature: ()V) Register 1 contains wrong type
        at java.lang.Class.getDeclaredMethods0(Native Method)
        at java.lang.Class.privateGetDeclaredMethods(Class.java:2427)
        at java.lang.Class.getMethod0(Class.java:2670)
        at java.lang.Class.getMethod(Class.java:1603)
        at org.apache.maven.surefire.util.ReflectionUtils.tryGetMethod(ReflectionUtils.java:57)
        at org.apache.maven.surefire.common.junit3.JUnit3TestChecker.isSuiteOnly(JUnit3TestChecker.java:65)
        at org.apache.maven.surefire.common.junit3.JUnit3TestChecker.isValidJUnit3Test(JUnit3TestChecker.java:60)
        at org.apache.maven.surefire.common.junit3.JUnit3TestChecker.accept(JUnit3TestChecker.java:55)
        at org.apache.maven.surefire.common.junit4.JUnit4TestChecker.accept(JUnit4TestChecker.java:52)
        at org.apache.maven.surefire.util.DefaultDirectoryScanner.locateTestClasses(DefaultDirectoryScanner.java:80)
        at org.apache.maven.surefire.junit4.JUnit4Provider.scanClassPath(JUnit4Provider.java:174)
        at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:83)
        ... 9 more
{noformat}","java version ""1.7.0_05"" 
Java(TM) SE Runtime Environment (build 1.7.0_05-b05) 
Java HotSpot(TM) 64-Bit Server VM (build 23.1-b03, mixed mode) 

Windows 7 Home Premium",melix,nplekhanov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Jul/12 02:13;nplekhanov;EachByClosureTest.groovy;https://issues.apache.org/jira/secure/attachment/12722608/EachByClosureTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 24 02:22:53 UTC 2012,,,,,,,,,,"0|i2bnen:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"24/Jul/12 02:22;melix;Duplicate of GROOVY-5570;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Cannot loop using foreach or ""for in"" in @TypeChecked code",GROOVY-5622,12816420,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,nplekhanov,nplekhanov,24/Jul/12 00:06,26/Jul/12 16:49,14/Jul/23 06:00,24/Jul/12 02:48,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,0,loop,TypeChecked,,,,"{code:java}
    @Test
    @TypeChecked
    void testForEach() {
        int i = 0;
        for (Field field : String.class.declaredFields) {
            i++;
        }
        assert i > 0
    }
{code}

fails on compile time with
{quote}[Static type checking] - Cannot loop with element of type java.lang.reflect.Field -> java.lang.reflect.Field with collection of type java.lang.ref.SoftReference <T extends java.lang.Object -> java.lang.Object>
{quote}","java version ""1.7.0_05""
Java(TM) SE Runtime Environment (build 1.7.0_05-b05)
Java HotSpot(TM) 64-Bit Server VM (build 23.1-b03, mixed mode)

Windows 7 Home Premium",melix,nplekhanov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Jul/12 00:06;nplekhanov;IteratorTest.groovy;https://issues.apache.org/jira/secure/attachment/12722536/IteratorTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 24 02:48:38 UTC 2012,,,,,,,,,,"0|i2ckuv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"24/Jul/12 02:48;melix;The type checker was incorrectly choosing the field {{declaredFields}} from class {{Class}} which is indeed of type {{SoftReference}}. This is now fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Spread-safe operator unsupported on LHS of assignments,GROOVY-5620,12816281,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,23/Jul/12 09:42,26/Jul/12 16:49,14/Jul/23 06:00,23/Jul/12 13:10,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,,,,0,,,,,,"Using the spread safe operator on the LHS of assignements is not supported for statically compiled code. For example:

{code}
@CompileStatic(List<A> list) {
   list*.foo = 1
}
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-23 09:42:47.0,,,,,,,,,,"0|i2ccxz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compiler calls setter even with attribute notation,GROOVY-5619,12816413,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,20/Jul/12 10:55,26/Jul/12 16:49,14/Jul/23 06:00,24/Jul/12 02:51,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,,,,0,,,,,,"If compiled with {{@CompileStatic}}, in the following example, we use the attribute notation, so the static compiler should perform a direct field access. However, it calls the setter:

{code}
class A {
    boolean setterCalled = false

    protected int x
    public void setX(int a) {
        setterCalled = true
        x = a
    }
}
class B extends A {
    void m() {
        this.@x = 2
    }
}
B b = new B()
b.m()
assert b.isSetterCalled() == false
{code}",,brownj,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 20 12:43:05 UTC 2012,,,,,,,,,,"0|i2c2rb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jul/12 12:43;brownj;We are currently working around this in Grails by removing @CompileStatic from the relevant method (https://github.com/grails/grails-core/commit/26db6c31ac39fd0ee80fa18f69ef481bdf7c245a).  Once this is resolved we need to revert that.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker throws No such property: value for class: java.lang.Object ,GROOVY-5618,12816440,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,20/Jul/12 10:53,26/Jul/12 16:49,14/Jul/23 06:00,24/Jul/12 02:51,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,0,,,,,,"In the following example:
{code}
class MyUtility {
    protected String value

    @groovy.transform.TypeChecked
    void foo() {
        this.@value = 'new value'
    }
}
{code}
The compiler doesn't find the attribute. Removing ""@"" works.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-20 10:53:44.0,,,,,,,,,,"0|i2bt4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
strange behavior with lists involving generics,GROOVY-5617,12818435,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,paulk,,20/Jul/12 04:39,07/Apr/15 19:06,14/Jul/23 06:00,20/Jul/12 07:46,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,0,,,,,,"this works fine:
{code}
@groovy.transform.TypeChecked
def test() {
    List<GString> dates = [""${new Date()-1}"", ""${new Date()}"", ""${new Date()+1}""]
    List<String> upper = dates*.toUpperCase()
}
test()
{code}
but this fails:
{code}
@groovy.transform.TypeChecked
def test() {
    List<GString> dates = [""${new Date()-1}"", ""${new Date()}"", ""${new Date()+1}""]
    List<GString> copied = []
    copied.addAll(dates)
    List<String> upper = copied*.toUpperCase()
}
test()
{code}
with this error message:
{noformat}
2 compilation errors:

[Static type checking] - Cannot find matching method groovy.lang.GString#toUpperCase(). Please check if the declared type is right and if the method exists.
 at line: 6, column: 26

[Static type checking] - Incompatible generic argument types. Cannot assign java.util.List <java.lang.Object> to: java.util.List <String>
 at line: 6, column: 5
{noformat}
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-20 04:39:17.0,,,,,,,,,,"0|i2csxb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compile static failing to allow cast of groovy type to GroovyObject,GROOVY-5616,12816409,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,aclement,aclement,19/Jul/12 16:25,26/Jul/12 16:49,14/Jul/23 06:00,20/Jul/12 08:50,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,,,,0,,,,,,"I tried to see if this was already fixed or covered by another issue, but I couldn't find something like it...  Here is the code:

{code}
class Foo {
    @groovy.transform.CompileStatic
    public void blah() {
        ((GroovyObject)this);
    }
}
{code}

This is currently causing me an issue when trying to build grails-core in STS (it has a snippet somewhat similar to this, but obviously it does a bit more).  For some reason it works through the gradle build on the command line, but not if I just run groovy 2.0.0 groovyc against that class above.  I also grabbed a snapshot and tried it, which seemed to give the same result.

Oh, the error is:

{code}
> groovyc Foo.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Foo.groovy: 4: [Static type checking] - Inconvertible types: cannot cast Foo to groovy.lang.GroovyObject
 @ line 4, column 3.
   		((GroovyObject)this);
     ^

1 error
{code}
",,aclement,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 20 07:50:56 UTC 2012,,,,,,,,,,"0|i2cgbr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jul/12 07:50;melix;Reason is that the {{GroovyObject}} interface is added after the type checker is run, so the class node doesn't have {{GroovyObject}} in its interface list. I should implement a special case for this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
var.getProperties() cannot be invoked as var.properties when using @CompileStatic,GROOVY-5615,12816424,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ariel.andres.morelli,ariel.andres.morelli,19/Jul/12 09:18,26/Jul/12 16:49,14/Jul/23 06:00,19/Jul/12 11:27,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,1,,,,,,"
{code}
@groovy.transform.CompileStatic
class MyClass {

 void method() {
    String var = ""Hola""
    println this.pepe
    println var.getProperties()    
    
    println var.properties  //Works without @CompileStatic, but it doesn't with it
 }
 
 
 String getPepe() {
 return ""Hola Pepe"";
 }
 
}

new MyClass().method()
{code}",,ariel.andres.morelli,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 19 11:27:03 UTC 2012,,,,,,,,,,"0|i2c3zz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jul/12 09:19;ariel.andres.morelli;The error obtained is:

[Static type checking] - No such property: properties for class: java.lang.String
 at line: 9, column: 13
;;;","19/Jul/12 11:27;melix;Already fixed, probably a duplicate of GROOVY-5589;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Diamond Inference broken with Static Compilation,GROOVY-5614,12814235,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,richardwarburton,richardwarburton,19/Jul/12 08:07,26/Jul/12 16:49,14/Jul/23 06:00,20/Jul/12 07:44,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,0,,,,,,"Example program:

{code}
package example

import groovy.transform.TypeChecked

@TypeChecked
class Rules {

    private final Map<String, String> bindings = new HashMap<>();

}
{code}

Causes Stacktrace:

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during instruction selection: 0

java.lang.ArrayIndexOutOfBoundsException: 0
        at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:130)
        at org.codehaus.groovy.ast.tools.GenericsUtils.parameterizeInterfaceGenerics(GenericsUtils.java:166)
        at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.compareGenericsWithBound(GenericsType.java:301)
        at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.checkGenerics(GenericsType.java:261)
        at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.matches(GenericsType.java:228)
        at org.codehaus.groovy.ast.GenericsType.isCompatibleWith(GenericsType.java:153)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.typeCheckAssignment(StaticTypeCheckingVisitor.java:647)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitField(StaticTypeCheckingVisitor.java:951)
        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1048)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:216)
        at org.codehaus.groovy.transform.StaticTypesTransformation.visit(StaticTypesTransformation.java:70)
        at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
        at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:496)
        at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:57)
        at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:213)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:146)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:176)
        at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:160)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)

1 error
{code}

This was using the 2.1.0-SNAPSHOT built from 333084c467c18f2afc9460e58d48c43909ad8d1a of git MASTER.  The problem disappears if you provide type arguments to the HashMap constructor or if you remove @TypeChecked.",Groovy Version: 2.1.0-SNAPSHOT JVM: 1.6.0_32 Vendor: Sun Microsystems Inc. OS: Linux,melix,richardwarburton,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5601,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 20 07:44:31 UTC 2012,,,,,,,,,,"0|i2cngf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"19/Jul/12 08:29;guillaume;It might be related to GROOVY-5601, or a similar fix should be generalized.;;;","20/Jul/12 07:44;melix;The problem was that no diamond inference was triggered on fields.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic - Caught: java.lang.VerifyError - Inconsistent stack height 1 != 2,GROOVY-5613,12816400,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,syepes,syepes,19/Jul/12 04:27,26/Jul/12 16:49,14/Jul/23 06:00,19/Jul/12 07:07,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Compiler,,,,0,compiler,CompileStatic,VerifyError,,,"Hello,

I am trying to build an application and I am getting some âInconsistent stack heightâ errors, I donât really know if itâs an error in the libraries I am using or a Groovy bug.
I have managed the reproduce the error with the minimum code and I have also attached all the needed files to reproduce the error.


Note:
 - We donât get the Verify Error if we use âimport staticâ and change âmsg?.â with âmsg.â
 - We donât get the Verify Error if we use âimportâ and with âmsg?.â
 - We donât get the Verify Error if we run the code with @TypeChecked


{code}
import groovy.transform.CompileStatic
import groovy.transform.TypeChecked

import com.hp.openview.ib.api.jopc.JOpcServerMessage
import com.hp.openview.ib.api.jopc.JOpcMessage
import static com.hp.openview.ib.api.jopc.JOpcHelper.*  // Uncomment for example VerifyError and Works
//import com.hp.openview.ib.api.jopc.JOpcHelper  // Uncomment for example Works2


//@TypeChecked // All the examples work is we use TypeChecked instead of CompileStatic
@CompileStatic
class ErrorReproduction {
  JOpcServerMessage msg

  ErrorReproduction() {
    String VerifyError = long2EventType(msg?.getEventFlag())
    //String Works = long2EventType(msg.getEventFlag())  // This work if we remove the ""?""
    //String Works2 = JOpcHelper.long2EventType(msg?.getEventFlag()) // This work if we dont use the ""import static""
  }

  static void main(String[] args) {
    ErrorReproduction m = new ErrorReproduction()
  }
}
{code} 

{code}
Caught: java.lang.VerifyError: (class: ErrorReproduction, method: <init> signature: ()V) Inconsistent stack height 1 != 2
java.lang.VerifyError: (class: ErrorReproduction, method: <init> signature: ()V) Inconsistent stack height 1 != 2
{code}
","Groovy Version: 2.0.0 JVM: 1.7.0_05 Vendor: Oracle Corporation OS: Linux
CentOS release 6.3 (Final) x86_64
CentOS release 5.8 (Final) x86_64",melix,syepes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"19/Jul/12 04:27;syepes;GroovyErrorReproduction.zip;https://issues.apache.org/jira/secure/attachment/12722924/GroovyErrorReproduction.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 19 08:13:43 UTC 2012,,,,,,,,,,"0|i2cedb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jul/12 07:07;melix;The problem was that the null safe operator pushed the constant {{null}} on stack even if the return type was of primitive type.

Thanks for reporting this!

https://github.com/groovy/groovy-core/commit/97b905654df7dbb0d46c2c71e72b4c933185b997;;;","19/Jul/12 08:13;syepes;Thanks Cedric for the fix. Now i just have to wait for 2.0.1 ;-);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Fix ""gradle idea"" task",GROOVY-5612,12816410,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,18/Jul/12 14:45,26/Jul/12 16:49,14/Jul/23 06:00,18/Jul/12 14:47,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,,,,,0,,,,,,"The ""gradle idea"" task doesn't generate a project that works out of the box.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-18 14:45:24.0,,,,,,,,,,"0|i2co8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Annotating a method with @CompileStatic when the class is already annotated leads to errors,GROOVY-5611,12816418,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,18/Jul/12 04:51,26/Jul/12 16:49,14/Jul/23 06:00,18/Jul/12 07:18,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,Static Type Checker,,,0,,,,,,"If a method is annotated with {{@CompileStatic}} while its owner class is also annotated, the type checker reports incorrect errors.
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-18 04:51:49.0,,,,,,,,,,"0|i2bmuv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checking of method calls using generics and default values is not supported,GROOVY-5610,12816295,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,melix,melix,17/Jul/12 14:41,14/Oct/13 16:54,14/Jul/23 06:00,16/Jul/13 10:12,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,Static Type Checker,,,,1,,,,,,"Imagine a method with the following signature:
{code}
def foo(List<? extends A> arg, String value='default')
{code}

And a method call:

{code}
foo(a)
{code}

Then in that case, the type checker will not verify that for argument {{a}}, the generics match the signature (only that {{a}} is a {{List}}).

A method call with all arguments set will not have this limitation.",,blackdrag,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 16 10:12:54 UTC 2013,,,,,,,,,,"0|i2bv2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jul/13 10:12;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checking of generic argument types of extension methods on abstract classes using generics,GROOVY-5609,12816419,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,melix,melix,17/Jul/12 14:37,08/Mar/22 12:16,14/Jul/23 06:00,09/Jun/21 15:10,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Static Type Checker,,,,1,,,,,,"If an extension method is using an abstract class or an array as the first argument and that argument makes use of a generic type defined in the signature of the extension method, the type checker won't be able to type check a method call properly.

Example:
{code}
// <T> is used in the first argument
public static <T> void foo(AbstractList<T> list, T[] elems)
// <T> is used in an array of the first argument
public static <T> void foo(T[] list, T[] elems)
{code}

Note that the limitation doesn't exist if the method is defined on an interface.",,emilles,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"09/Jun/21 15:11;emilles;image-2021-06-09-10-11-28-435.png;https://issues.apache.org/jira/secure/attachment/13026615/image-2021-06-09-10-11-28-435.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 09 15:10:59 UTC 2021,,,,,,,,,,"0|i2bmsn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jun/21 15:10;emilles;Appears to be working properly in Groovy 2.5:

!image-2021-06-09-10-11-28-435.png!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic casting problem,GROOVY-5608,12816408,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,gordon277,gordon277,16/Jul/12 21:20,26/Jul/12 16:49,14/Jul/23 06:00,19/Jul/12 04:57,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,2.1.0-beta-1,,Static compilation,,,,0,,,,,,"Don't know if this bug has been reported before (didn't find anything while looking)
{code}
@CompileStatic
class M
{
	public void r()
	{
		List<Integer> a = [1, 3, 5]
		List<Integer> b = (List<Integer>)a[1..2]
	}
}

(new M()).r()
{code}

fails with
{code}
D:\dev\eclipse_workspace\groovy_test\src\Test2.groovy: 13: [Static type checking] - Inconvertible types: cannot cast java.lang.Integer to java.util.List
 @ line 13, column 21.
   		List<Integer> b = (List<Integer>)a[1..2]
                       ^
{code}
Thinks that the sublist is a single Integer

Removing @CompileStatic fixes the problem
","Windows 7 x64, Java 7 x64",gordon277,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-16 21:20:00.0,,,,,,,,,,"0|i2cqpb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Compile static Sql.newInstance,GROOVY-5607,12816444,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,gordon277,gordon277,16/Jul/12 21:17,26/Jul/12 16:49,14/Jul/23 06:00,17/Jul/12 05:27,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,2.1.0-beta-1,,Static compilation,,,,0,,,,,,"Don't know if this bug has been reported before (didn't find anything while looking)
{code}
@CompileStatic
class M
{
	public void r()
	{
	     Sql sql = Sql.newInstance(""jdbc:mysql://localhost/dummy"", ""dummy"", ""dummy"", ""com.mysql.jdbc.Driver"")
	}
}

(new M()).r()
{code}
fails with
{code}
Caught: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: groovy.sql.Sql(java.lang.String, java.lang.String, java.lang.String, java.lang.String)
groovy.lang.GroovyRuntimeException: Could not find matching constructor for: groovy.sql.Sql(java.lang.String, java.lang.String, java.lang.String, java.lang.String)
	at M.r(Test2.groovy:11)
	at M$r.call(Unknown Source)
	at Test2.run(Test2.groovy:18)
{code}

Looks like DefaultGroovyMethods.newInstance get's called instead.

Removing @CompileStatic fixes the problem
","Windows 7 x64, Java 7 x64",gordon277,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5573,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 17 02:41:00 UTC 2012,,,,,,,,,,"0|i2cizb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jul/12 02:41;melix;Looks like a duplicate of GROOVY-5573. I'm going to check but I think it's already fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem with CompileStatic,GROOVY-5606,12816396,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,16/Jul/12 19:44,26/Jul/12 16:49,14/Jul/23 06:00,17/Jul/12 14:46,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Compiler,,,,0,,,,,,"The following code compiles with 2.0.0 but not with the current 2.0.1-SNAPSHOT.

{code:title=src/main/groovy/com/demo/MyUtility.groovy|borderStyle=solid}
package com.demo

import groovy.transform.CompileStatic

class MyUtility {
    @CompileStatic
    def methodOne() {
        def someFiles = new ArrayList<File>()
        def someString = ''
        methodTwo someString, someFiles
    }

    @CompileStatic
    def methodTwo(String s, List<File> files) {}
}
{code}

Extract the attached project and execute the following command to see the error:

{noformat}
$ ./gradlew clean compileGroovy
:clean
:compileJava UP-TO-DATE
:compileGroovy
startup failed:
/Users/jeff/t/compilestatic/src/main/groovy/com/demo/MyUtility.groovy: 10: [Static type checking] - Cannot call com.demo.MyUtility#methodTwo(java.io.File) with arguments [java.lang.String, java.util.ArrayList <File>] 
 @ line 10, column 9.
           methodTwo someString, someFiles
           ^

1 error


FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileGroovy'.
> Compilation failed; see the compiler error output for details.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 3.453 secs
{noformat}

If you edit build.gradle and change 2.0.1-SNAPSHOT to 2.0.0 the code does compile.",,brownj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Jul/12 19:44;brownj;compilestatic.zip;https://issues.apache.org/jira/secure/attachment/12721726/compilestatic.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 16 19:46:02 UTC 2012,,,,,,,,,,"0|i2csd3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jul/12 19:46;brownj;This is a problem for Grails.  See http://hudson.grails.org/view/Grails%202.2.x/job/groovy_2_0_grails_joint_build/91/console.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
" Class Cast Exception when using Groovy 2.0 Indy=""true"" and using an integer with a double.",GROOVY-5605,12813399,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,jimclarke5,jimclarke5,16/Jul/12 06:56,26/Jul/12 16:49,14/Jul/23 06:00,19/Jul/12 08:55,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,groovy-jdk,,,,0,exception,indy,,,,"The following code causes a Class Cast Exception.
{code}
import java.awt.geom.Point2D;

def width = 240.0
def radius = width / 3.0
 
new Point2D.Double(x: 0, y: radius * 2 / 4)
{code}
{code}
Exception in thread ""main"" java.lang.ClassCastException: java.lang.Integer cannot be cast to java.math.BigInteger
	at org.codehaus.groovy.runtime.dgm$364.invoke(Unknown Source)
	at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
	at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:681)
	at Main.run(Main.groovy:7)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1074)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:848)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:831)
	at org.codehaus.groovy.runtime.InvokerHelper.runScript(InvokerHelper.java:407)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1307)
	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1293)
	at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L3(MethodHandleImpl.java:1138)
	at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:681)
	at Main.main(Main.groovy)
{code}

If you change the Groovy code to:
{code}
import java.awt.geom.Point2D;

def width = 240.0
def radius = width / 3.0
 
new Point2D.Double(x: 0, y: radius * 2D / 4D)
{code}
it works ok.","groovy 2.0.x
java version ""1.7.0_04""
Java(TM) SE Runtime Environment (build 1.7.0_04-b21)
Java HotSpot(TM) 64-Bit Server VM (build 23.0-b21, mixed mode)
Mac OS X 10.7.4",blackdrag,jimclarke5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Jul/12 06:56;jimclarke5;Main.groovy;https://issues.apache.org/jira/secure/attachment/12722171/Main.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 19 08:55:26 UTC 2012,,,,,,,,,,"0|i2buwf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jul/12 08:55;blackdrag;should be also fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static type checker NPE when instantiating generic interface (with and without diamond),GROOVY-5601,12818173,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,wujek.srujek,wujek.srujek,14/Jul/12 06:27,26/Jul/12 16:49,14/Jul/23 06:00,16/Jul/12 03:47,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,0,exception,,,,,"{code}
package compile

import groovy.transform.TypeChecked

interface Mapper<F, T> {
    T to(F from)
}

@TypeChecked
class Main {
    static void main(String[] args) {
        Mapper<String, Integer> mapper = new Mapper<String, Integer>() { //        Mapper<String, Integer> mapper = new Mapper<>() {
            Integer to(String from) {
                17
            }
        };
    }
}
{code}
Results in:

{code}
$ ~/Apps/groovy/bin/groovyc -e compile/Mapper.groovy 
null
>>> stacktrace:
java.lang.NullPointerException
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferDiamondType(StaticTypeCheckingVisitor.java:456)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:394)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:245)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitDeclarationExpression(ClassCodeVisitorSupport.java:107)
        at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:87)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:195)
        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)
        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1051)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1252)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1226)
        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
        at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:216)
        at org.codehaus.groovy.transform.StaticTypesTransformation.visit(StaticTypesTransformation.java:70)
        at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
        at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:496)
        at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:57)
        at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:213)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:146)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:176)
        at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:160)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
{code}

It doesn't matter if I explicitly specify the parameters during creation, or whether I let the diamong operator kick in. Without @TypeChecked, it works fine. I am not sure whether the problem happens only with anonymous inner classes or is more general.","$ java -version
java version ""1.7.0_04""
Java(TM) SE Runtime Environment (build 1.7.0_04-b20)
Java HotSpot(TM) 64-Bit Server VM (build 23.0-b21, mixed mode)

$ uname -a
Linux studio 3.2.0-25-generic #40-Ubuntu SMP Wed May 23 20:30:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux",guillaume,melix,wujek.srujek,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5614,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 16 03:43:19 UTC 2012,,,,,,,,,,"0|i2chl3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"16/Jul/12 02:31;melix;The example above already works using {{master}} or {{GROOVY_2_0_X}}. However, using an anonymous inner class and the diamond operator leads to an error (NPE or AIOOB):

{code}
Map<String,Date> map = new HashMap<>() {}
{code}

{noformat}
TestScripttestInferDiamondUsingAIC0.groovy: 2: The class java.util.HashMap refers to the class java.util.HashMap and uses 0 parameters, but the referred class needs 2
 @ line 2, column 40.
               Map<String,Date> map = new HashMap<>() {}
                                          ^
{noformat};;;","16/Jul/12 03:37;guillaume;With the suggested sample from the issue, I get the following error:
{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during instruction selection: 0

java.lang.ArrayIndexOutOfBoundsException: 0
	at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:130)
	at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:109)
	at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.compareGenericsWithBound(GenericsType.java:327)
	at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.compareGenericsWithBound(GenericsType.java:302)
	at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.checkGenerics(GenericsType.java:261)
	at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.matches(GenericsType.java:228)
	at org.codehaus.groovy.ast.GenericsType.isCompatibleWith(GenericsType.java:153)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.typeCheckAssignment(StaticTypeCheckingVisitor.java:633)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:404)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:245)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitDeclarationExpression(ClassCodeVisitorSupport.java:107)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:87)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:195)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1129)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:1344)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:1318)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:216)
	at org.codehaus.groovy.transform.StaticTypesTransformation.visit(StaticTypesTransformation.java:70)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:132)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:176)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:625)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:516)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:556)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:537)
	at groovy.lang.GroovyShell$evaluate.call(Unknown Source)
	at groovy.transform.stc.StaticTypeCheckingTestCase.assertScript(StaticTypeCheckingTestCase.groovy:62)
	at sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:272)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:52)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at groovy.transform.stc.GenericsSTCTest.testDiamondInference(GenericsSTCTest.groovy:619)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at junit.framework.TestCase.runTest(TestCase.java:168)
	at junit.framework.TestCase.runBare(TestCase.java:134)
	at junit.framework.TestResult$1.protect(TestResult.java:110)
	at junit.framework.TestResult.runProtected(TestResult.java:128)
	at junit.framework.TestResult.run(TestResult.java:113)
	at junit.framework.TestCase.run(TestCase.java:124)
	at junit.framework.TestSuite.runTest(TestSuite.java:243)
	at junit.framework.TestSuite.run(TestSuite.java:238)
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:55)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:42)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:75)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at $Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:101)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.messaging.remote.internal.TypeCastDispatch.dispatch(TypeCastDispatch.java:30)
	at org.gradle.messaging.remote.internal.WorkerProtocol.handleIncoming(WorkerProtocol.java:53)
	at org.gradle.messaging.remote.internal.WorkerProtocol.handleIncoming(WorkerProtocol.java:31)
	at org.gradle.messaging.remote.internal.ProtocolStack$ProtocolStage.handleIncoming(ProtocolStack.java:167)
	at org.gradle.messaging.remote.internal.ProtocolStack$BottomStage.handleIncoming(ProtocolStack.java:277)
	at org.gradle.messaging.remote.internal.ProtocolStack$BottomConnection$1.run(ProtocolStack.java:299)
	at org.gradle.messaging.remote.internal.ProtocolStack$ExecuteRunnable.dispatch(ProtocolStack.java:120)
	at org.gradle.messaging.remote.internal.ProtocolStack$ExecuteRunnable.dispatch(ProtocolStack.java:116)
	at org.gradle.messaging.dispatch.AsyncDispatch.dispatchMessages(AsyncDispatch.java:132)
	at org.gradle.messaging.dispatch.AsyncDispatch.access$000(AsyncDispatch.java:33)
	at org.gradle.messaging.dispatch.AsyncDispatch$1.run(AsyncDispatch.java:72)
	at org.gradle.messaging.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
	at java.lang.Thread.run(Thread.java:722)

1 error

	at org.codehaus.groovy.control.ErrorCollector.failIfErrors(ErrorCollector.java:302)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1051)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:625)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:516)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:556)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:537)
	at groovy.lang.GroovyShell$evaluate.call(Unknown Source)
	at groovy.transform.stc.StaticTypeCheckingTestCase.assertScript(StaticTypeCheckingTestCase.groovy:62)
	at sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:272)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:52)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:49)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at groovy.transform.stc.GenericsSTCTest.testDiamondInference(GenericsSTCTest.groovy:619)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at junit.framework.TestCase.runTest(TestCase.java:168)
	at junit.framework.TestCase.runBare(TestCase.java:134)
	at junit.framework.TestResult$1.protect(TestResult.java:110)
	at junit.framework.TestResult.runProtected(TestResult.java:128)
	at junit.framework.TestResult.run(TestResult.java:113)
	at junit.framework.TestCase.run(TestCase.java:124)
	at junit.framework.TestSuite.runTest(TestSuite.java:243)
	at junit.framework.TestSuite.run(TestSuite.java:238)
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:55)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:42)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:75)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at $Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:101)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.messaging.remote.internal.TypeCastDispatch.dispatch(TypeCastDispatch.java:30)
	at org.gradle.messaging.remote.internal.WorkerProtocol.handleIncoming(WorkerProtocol.java:53)
	at org.gradle.messaging.remote.internal.WorkerProtocol.handleIncoming(WorkerProtocol.java:31)
	at org.gradle.messaging.remote.internal.ProtocolStack$ProtocolStage.handleIncoming(ProtocolStack.java:167)
	at org.gradle.messaging.remote.internal.ProtocolStack$BottomStage.handleIncoming(ProtocolStack.java:277)
	at org.gradle.messaging.remote.internal.ProtocolStack$BottomConnection$1.run(ProtocolStack.java:299)
	at org.gradle.messaging.remote.internal.ProtocolStack$ExecuteRunnable.dispatch(ProtocolStack.java:120)
	at org.gradle.messaging.remote.internal.ProtocolStack$ExecuteRunnable.dispatch(ProtocolStack.java:116)
	at org.gradle.messaging.dispatch.AsyncDispatch.dispatchMessages(AsyncDispatch.java:132)
	at org.gradle.messaging.dispatch.AsyncDispatch.access$000(AsyncDispatch.java:33)
	at org.gradle.messaging.dispatch.AsyncDispatch$1.run(AsyncDispatch.java:72)
	at org.gradle.messaging.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
	at java.lang.Thread.run(Thread.java:722)
{code}
With the following test method added:
{code}

    void testDiamondInference() {
        assertScript '''
            package compile

            import groovy.transform.TypeChecked

            interface Mapper<F, T> {
                T to(F from)
            }

            @TypeChecked
            class Main {
                static void main(String[] args) {
                    // without diamond works
                    Mapper<String, Integer> mapper1 = new Mapper<String, Integer>() {
                        Integer to(String from) {
                            17
                        }
                    };

                    // with diamond fails
                    Mapper<String, Integer> mapperé = new Mapper<>() {
                        Integer to(String from) {
                            17
                        }
                    };
                }
            }

            Main.main(null)
        '''
    }
{code}
Tested with master.;;;","16/Jul/12 03:43;melix;The compiler should fail with the same error as Java does: cannot use diamond with anonymous inner classes.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot use @CompileStatic with Thread.start method,GROOVY-5598,12816344,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,graemerocher,graemerocher,12/Jul/12 08:32,26/Jul/12 16:49,14/Jul/23 06:00,13/Jul/12 06:25,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,2.1.0-beta-1,,Static compilation,,,,0,,,,,,"Example:

{code}

@groovy.transform.CompileStatic
def foo() {
  Thread.start {
      println ""boo""
  }
}

foo()
{code}

Produces

{code}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'class java.lang.Thread' with class 'java.lang.Class' to class 'java.lang.Thread'
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:360)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:599)

{code}",,graemerocher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-12 08:32:10.0,,,,,,,,,,"0|i2bsz3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker doesn't fully infer Map.Entry type,GROOVY-5595,12816367,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,12/Jul/12 04:52,26/Jul/12 16:49,14/Jul/23 06:00,12/Jul/12 06:55,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,0,,,,,,"If you have a map:
{code}Map<Date,Integer>{code}
and that you use the {{entrySet()}} method, the inferred type is:
{code}Set<Map.Entry<K,V>>{code}
but it should be:
{code}Set<Map.Entry<Date,Integer>>{code}

(multiple levels of generics)

Here's the test case:
{code}
Map<Date, Integer> map

@ASTTest(phase=INSTRUCTION_SELECTION, value={
    def infType = node.getNodeMetaData(INFERRED_TYPE)
    assert infType == make(Set)
    def entryInfType = infType.genericsTypes[0].type
    assert entryInfType == make(Map.Entry)
    assert entryInfType.genericsTypes[0].type == make(Date)
    assert entryInfType.genericsTypes[1].type == Integer_TYPE
})
def entries = map?.entrySet()
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5587,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-12 04:52:19.0,,,,,,,,,,"0|i2c6f3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker doesn't infer property type if coming from a generified getter,GROOVY-5594,12816300,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,12/Jul/12 04:31,26/Jul/12 16:49,14/Jul/23 06:00,12/Jul/12 06:55,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,0,,,,,,"If someone uses the property notation to get the key or the value of a map entry, the property type is not inferred properly. The workaround is to use a getter instead.

Test case:
{code}
Map.Entry<Date, Integer> entry

@ASTTest(phase=INSTRUCTION_SELECTION, value={
    assert node.getNodeMetaData(INFERRED_TYPE) == make(Date)
})
def k = entry?.key

@ASTTest(phase=INSTRUCTION_SELECTION, value={
    assert node.getNodeMetaData(INFERRED_TYPE) == Integer_TYPE
})
def v = entry?.value
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5587,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-12 04:31:43.0,,,,,,,,,,"0|i2bsxj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy-all-2.0.0 does not work with JDK 1.5,GROOVY-5593,12816271,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,pniederw,pniederw,11/Jul/12 20:35,26/Jul/12 16:49,14/Jul/23 06:00,13/Jul/12 02:59,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,,,,,0,,,,,,"I assume this is not intended? The problem is that org.codehaus.groovy.jsr223.ScriptExtensions gets loaded, which uses JDK 1.6 classes. For example I get ""java.lang.NoClassDefFoundError: javax/script/ScriptEngine"". Seems like this makes groovy-all-2.0.0 unusable with JDK 1.5.",,melix,paulk,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 13 02:58:55 UTC 2012,,,,,,,,,,"0|i2cgbb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Jul/12 11:51;melix;{{ScriptExtensions}} gets loaded as a module extension. Can you paste a full trace? I was thinking that even if a module cannot be loaded, Groovy should still run fine.;;;","12/Jul/12 18:23;pniederw;{noformat}
MyGroovyTestCase > junit.framework.TestSuite$1.warning FAILED
    junit.framework.AssertionFailedError: Exception in constructor: testSomething (java.lang.NoClassDefFoundError: javax/script/ScriptEngine
        at java.lang.Class.getDeclaredMethods0(Native Method)
        at java.lang.Class.privateGetDeclaredMethods(Class.java:2395)
        at java.lang.Class.getDeclaredMethods(Class.java:1763)
        at org.codehaus.groovy.reflection.CachedClass$3$1.run(CachedClass.java:84)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.codehaus.groovy.reflection.CachedClass$3.initValue(CachedClass.java:81)
        at org.codehaus.groovy.reflection.CachedClass$3.initValue(CachedClass.java:79)
        at org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:46)
        at org.codehaus.groovy.util.LazyReference.get(LazyReference.java:33)
        at org.codehaus.groovy.reflection.CachedClass.getMethods(CachedClass.java:250)
        at org.codehaus.groovy.runtime.m12n.SimpleExtensionModule.createMetaMethods(SimpleExtensionModule.java:100)
        at org.codehaus.groovy.runtime.m12n.SimpleExtensionModule.getMetaMethods(SimpleExtensionModule.java:89)
        at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.registerExtensionModuleFromProperties(MetaClassRegistryImpl.java:185)
        at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.registerExtensionModuleFromMetaInf(MetaClassRegistryImpl.java:167)
        at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.registerClasspathModules(MetaClassRegistryImpl.java:153)
        at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:108)
        at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.<init>(MetaClassRegistryImpl.java:70)
        at groovy.lang.GroovySystem.<clinit>(GroovySystem.java:33)
        at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:152)
        at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:182)
        at MyGroovyTestCase.$getStaticMetaClass(MyGroovyTestCase.groovy)
        at MyGroovyTestCase.<init>(MyGroovyTestCase.groovy)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:501)
        at junit.framework.TestSuite.createTest(TestSuite.java:61)
        at junit.framework.TestSuite.addTestMethod(TestSuite.java:294)
        at junit.framework.TestSuite.addTestsFromTestCase(TestSuite.java:150)
        at junit.framework.TestSuite.<init>(TestSuite.java:129)
        at org.junit.internal.runners.JUnit38ClassRunner.<init>(JUnit38ClassRunner.java:71)
        ...
{noformat};;;","13/Jul/12 02:20;melix;Ok I see, so it's not the module loading that is failing, but the generation of meta methods. Thanks for the trace!;;;","13/Jul/12 02:58;paulk;Not a final solution but I am pondering workarounds. If you add the ""org.livetribe:livetribe-jsr223:2.0.6"" dependency to your classpath, does the problem go away?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
No recent snapshot for 2.0.1 available from http://snapshots.repository.codehaus.org,GROOVY-5592,12816246,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pniederw,pniederw,11/Jul/12 19:20,26/Jul/12 16:49,14/Jul/23 06:00,13/Jul/12 13:46,2.0.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,,,,,0,,,,,,"Latest snapshot is from June 26th, which is before 2.0.0 was released. Having access to the latest snapshot would help a lot, e.g. for Gradle development.",,melix,paulk,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 13 13:46:53 UTC 2012,,,,,,,,,,"0|i2buvz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Jul/12 11:55;melix;Paul, didn't you setup a Bamboo build for the 2.0.x branch?;;;","12/Jul/12 16:35;paulk;There are 1.6 and 1.7 basic builds but no release build - will add that;;;","13/Jul/12 13:46;melix;Snapshots are now online. Thanks Paul!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy-all-2.0.0-sources.jar is missing lots of source files,GROOVY-5591,12816254,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,pniederw,pniederw,11/Jul/12 18:36,26/Jul/12 16:49,14/Jul/23 06:00,13/Jul/12 17:06,2.0.0,2.1.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,2.1.0-beta-1,,,,,,0,,,,,,"Not sure if this is known already, but I couldn't find anything on it in Jira or mailing list. The groovy-all-2.0.0-sources.jar as published to Maven Central seems to be missing lots of source files. For example, the only file under groovy/lang is GroovyLogTestCase.",,paulk,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 13 17:06:17 UTC 2012,,,,,,,,,,"0|i2bna7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jul/12 19:16;pniederw;Latest 2.1.0 snapshot has the same problem. Please also fix for 2.0.x.;;;","13/Jul/12 17:06;paulk;Should be fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Caused by: org.codehaus.groovy.runtime.InvokerInvocationException: java.io.IOException: Cannot run program ""find"": java.io.IOException: error=24, Too many open files",GROOVY-5590,12811898,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,balor123,balor123,11/Jul/12 15:29,05/Apr/15 14:43,14/Jul/23 06:00,27/Jul/12 23:47,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.2,2.1.0-beta-1,,groovy-jdk,,,,0,,,,,,"A script I wrote starts many processes but all within a common GPars pool so no more than a few are running at a time. It fails with the following error:

Caught: java.util.concurrent.ExecutionException: org.codehaus.groovy.runtime.InvokerInvocationException: org.codehaus.groovy.runtime.InvokerInvocationException: java.io.IOException: Cannot run program ""find"": java.io.IOException: error=24, Too many open files

I verified that the problem is fixed by calling process.out.close() after every Process finishes. However, this solution is undesirable for a few two reasons. First, it adds an extra possibly avoidable line. Second, it prevents usage of convenience methods like getText(), where the Process might not have been exposed.

The fix works because the Process remains open as long as STDIN is open. I see that STDOUT and STDERR are closed already so probably someone tried to fix this problem in the past but closed the wrong streams. To fix the problem, I propose that the STDIN (out) stream be closed as well where those streams are already closed. Additionally, I propose adding the close() calls to getText() as well.

I've attached a diff with the change for review. I rebuilt Groovy and verified that the script no longer fails with these changes. A unit test is still needed but haven't delved into that part of Groovy source quite yet :)",,balor123,guillaume,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Jul/12 15:29;balor123;diff.log;https://issues.apache.org/jira/secure/attachment/12722652/diff.log",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Jul 27 23:47:00 UTC 2012,,,,,,,,,,"0|i2bqfz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jul/12 17:23;paulk;Just reopening to remind myself to fix up the comments to reflect the latest code changes - I'm not online at the moment or would have done it directly.

The other nagging feeling I have is that the STDIN (out) stream wasn't closed on purpose as it was causing IOExceptions (either Stream Closed or Broken Pipe) when piping between processes on some platforms. A consequence of this decision was that you did indeed need to close the stream in the first (last?) process in your pipeline by hand. But I can't remember all the details to reproduce in the time I had available to play just now. I imagine this also impacts getText().

I am not saying that a change isn't desirable or indeed that the proposed change isn't the correct one but I am flagging that we have had problems in this area before that might not be covered by unit tests and that I can't remember all the specifics of.;;;","23/Jul/12 02:18;guillaume;Should we revert back the changes for now?;;;","23/Jul/12 03:34;paulk;Let's leave it for now, I will continue trying to find time to reproduce the problem - it may only occur on old legacy platforms/versions of Java?;;;","27/Jul/12 23:47;paulk;The change was in 2.0.1 and I haven't been able to replicate the problem I was worried about. I have updated the javadoc in 2.0.2 to match the code change. We will no doubt have another jira raised if the problem does indeed surface again.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker doesn't allow property notation as LHS when only a setter exists,GROOVY-5589,12816405,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,11/Jul/12 11:25,26/Jul/12 16:49,14/Jul/23 06:00,11/Jul/12 11:45,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,0,,,,,,"If a class has only a setter, but no getter:
{code}
class A {
   void setFoo(String arg) {}
}
{code}
Then the type checker doesn't allow the property notation for assignments:
{code}
def a = new A()
a.foo = 'bar'
{code}
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-11 11:25:30.0,,,,,,,,,,"0|i2cdof:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Multidimensional Arrays: Incompatible argument to function,GROOVY-5588,12816395,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,casp,casp,11/Jul/12 11:11,14/Aug/12 07:25,14/Jul/23 06:00,12/Jul/12 14:42,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0.1,,,,,,0,,,,,,"Hey, starting with Groovy 1.8.x, and now as well with Groovy 2.0, the following code produces an error

int[][] x = new int[10][10]
x[1][1] += 5

Error is:
Caught: java.lang.VerifyError: (class: test, method: run signature: ()Ljava/lang/Object;) Incompatible argument to function
java.lang.VerifyError: (class: test, method: run signature: ()Ljava/lang/Object;) Incompatible argument to function

(there were some issues with multidimensional arrays in earlier versions but it still seems to be a problem in the new version)","Linux, Groovy 2.0, Java 7",blackdrag,casp,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 14 07:25:18 UTC 2012,,,,,,,,,,"0|i2cdkv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Jul/12 14:42;blackdrag;should be fixed now;;;","12/Jul/12 15:50;casp;thanks! it might not be the right place to ask, but whats the best way to get a snapshot of the 2.0.1 version? the last snapshot build (for 2.0.1) is from 26th of june. thanks again!;;;","13/Jul/12 05:29;blackdrag;Philipp, please see GROOVY-5592;;;","14/Aug/12 07:25;casp;I found a similar error, which is imho pretty much related to this one.. Please see 
https://jira.codehaus.org/browse/GROOVY-5662;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Map.Entry<K,V>#key and #value fail to infer type correctly under @StaticCompile",GROOVY-5587,12818124,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,blendmaster,blendmaster,11/Jul/12 10:57,26/Jul/12 16:49,14/Jul/23 06:00,12/Jul/12 06:55,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,,,,0,,,,,,"{code}
import groovy.transform.CompileStatic
@CompileStatic
class BrokenCompileStaticTest extends GroovyTestCase {
  void testMapForEachAttribute() {
    def result = """"
    def sum = 0
    for ( Map.Entry<String, Integer> it in [a:1, b:3].entrySet() ) {
       result += it.key
       sum += it.value
    }
    assert result == ""ab""
    assert sum == 4
  }
}
{code}

fails to infer the type of Map.Entry#key and #value, regardless of the proper generic type in the for-in loop definition.

Message:

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/home/steven/BrokenCompileStaticTest.groovy: 9: [Static type checking] - Cannot find matching method int#plus(java.lang.Object <V>)
 @ line 9, column 8.
          sum += it.value
          ^

1 error
{code}

Also, shouldn't groovy report both static type errors, instead of just the first?","Ubuntu 12.04, Oracle JVM 1.7.0_05",blendmaster,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5595,GROOVY-5594,"11/Jul/12 10:57;blendmaster;BrokenCompileStaticTest.groovy;https://issues.apache.org/jira/secure/attachment/12722998/BrokenCompileStaticTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 12 01:51:57 UTC 2012,,,,,,,,,,"0|i2ck5r:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Jul/12 10:59;blendmaster;Oh, on second look, groovy only fails to infer the type of Map.Entry#value. weird.;;;","11/Jul/12 12:42;melix;Change {{def result=""""}} to {{int result=0}} and you will see that the type checker fails in both cases. It's just that in the first case, anything can be assigned to a {{String}} so it works.
;;;","11/Jul/12 21:42;blendmaster;so {{result += }} coerces its argument to a string? I suppose that can be useful, but it doesn't really help with the missing #key and #value types.;;;","12/Jul/12 01:51;melix;Steven, my comment was there to say there wasn't a difference between the treatment of {{key}} and {{value}}, nothing more :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Canonical class causes compile-time NPE under @StaticCompilation,GROOVY-5586,12818199,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,blendmaster,blendmaster,11/Jul/12 10:45,26/Jul/12 16:49,14/Jul/23 06:00,12/Jul/12 14:47,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,,,,0,,,,,,"{code}
import groovy.transform.*
@CompileStatic
class CanonicalStaticTest extends GroovyTestCase {
  @Canonical class Thing {
    String stuff
  }

  void testCanonical() {
    def thing = new Thing()
  }
}
{code}

fails to compile with the message:

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during class generation: NPE while processing CanonicalStaticTest.groovy

groovy.lang.GroovyRuntimeException: NPE while processing CanonicalStaticTest.groovy
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:199)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:783)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:260)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:244)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:185)
	at groovy.lang.GroovyShell$2.run(GroovyShell.java:206)
	at groovy.lang.GroovyShell$2.run(GroovyShell.java:204)
	at java.security.AccessController.doPrivileged(Native Method)
	at groovy.lang.GroovyShell.run(GroovyShell.java:204)
	at groovy.lang.GroovyShell.run(GroovyShell.java:150)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:557)
	at groovy.ui.GroovyMain.run(GroovyMain.java:344)
	at groovy.ui.GroovyMain.process(GroovyMain.java:330)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:119)
	at groovy.ui.GroovyMain.main(GroovyMain.java:99)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.classgen.asm.BytecodeHelper.getTypeDescription(BytecodeHelper.java:163)
	at org.codehaus.groovy.classgen.asm.BytecodeHelper.getTypeDescription(BytecodeHelper.java:126)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitAttributeOrProperty(AsmClassGenerator.java:1013)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitPropertyExpression(AsmClassGenerator.java:1052)
	at org.codehaus.groovy.ast.expr.PropertyExpression.visit(PropertyExpression.java:55)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeDirectMethodCall(InvocationWriter.java:115)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.writeDirectMethodCall(StaticInvocationWriter.java:188)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:221)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:76)
	at org.codehaus.groovy.classgen.asm.sc.StaticInvocationWriter.makeCall(StaticInvocationWriter.java:383)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:60)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:334)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:649)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:510)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:456)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:320)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:277)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:397)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:181)
	... 25 more

1 error
{noformat}","Ubuntu 12.04, Oracle JVM 1.7.0_05-b05",blendmaster,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Jul/12 10:45;blendmaster;CanonicalStaticTest.groovy;https://issues.apache.org/jira/secure/attachment/12721727/CanonicalStaticTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 12 14:47:30 UTC 2012,,,,,,,,,,"0|i2bumf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Jul/12 11:47;melix;This doesn't seem to happen using {{master}} or {{GROOVY_2_0_X}}. I think I've fixed it as part of another bug. Any chance you can confirm?;;;","11/Jul/12 21:38;blendmaster;I built master from github, but I get an even weirder error:

{noformat}
.E
Time: 0.001
There was 1 error:
1) testCanonical(CanonicalStaticTest)java.lang.VerifyError: (class: CanonicalStaticTest$Thing, method: toString signature: ()Ljava/lang/String;) Incompatible object argument for function call
	at CanonicalStaticTest.testCanonical(test.groovy:9)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1307)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:874)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:78)
	at groovy.lang.GroovyShell.runJUnit3Test(GroovyShell.java:352)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:272)
	at groovy.lang.GroovyShell.run(GroovyShell.java:220)
	at groovy.lang.GroovyShell.run(GroovyShell.java:150)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:557)
	at groovy.ui.GroovyMain.run(GroovyMain.java:344)
	at groovy.ui.GroovyMain.process(GroovyMain.java:330)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:119)
	at groovy.ui.GroovyMain.main(GroovyMain.java:99)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)

FAILURES!!!
Tests run: 1,  Failures: 0,  Errors: 1
{noformat}
{noformat}
> groovy -v
Groovy Version: 2.1.0-SNAPSHOT JVM: 1.7.0_05 Vendor: Oracle Corporation OS: Linux
{noformat}
;;;","12/Jul/12 12:02;melix;Seems to be a problem with having an inner class.;;;","12/Jul/12 14:47;melix;The problem was in {{@ToString}} which generated a {{MethodCallExpression}} without setting {{implicitThis}} to {{false}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
interface.property not recognized by type checker if property is of Object,GROOVY-5585,12816286,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,11/Jul/12 06:34,26/Jul/12 16:49,14/Jul/23 06:00,11/Jul/12 06:45,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,,,,,0,,,,,,"The type checker fails to recognize properties like {{.class}} on an interface if the property is defined in the Object class.

{code}
Class test(Serializable arg) {
    Class<?> clazz = arg.class
    clazz
}
assert test('foo') == String
{code}
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-11 06:34:54.0,,,,,,,,,,"0|i2bv33:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"@CompileStatic fails to compile Map.each { key, value -> } form",GROOVY-5584,12816290,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,blendmaster,blendmaster,10/Jul/12 17:05,26/Jul/12 16:49,14/Jul/23 06:00,11/Jul/12 05:12,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,,,,0,compilestatic,,,,,"The following code (from Map#each documentation in the Groovy JDK) fails under static compilation:

{code}
import groovy.transform.CompileStatic

@CompileStatic def test() {
    def result = """"
    [a:1, b:3].each { key, value -> result += ""$key$value"" }
    assert result == ""a1b3""
}
test()
{code}

with the message:
{code}
Caught: groovy.lang.MissingMethodException: No signature of method: mapeach$_test_closure1.doCall() is applicable for argument types: (java.util.LinkedHashMap$Entry) values: [a=1]
Possible solutions: doCall(java.lang.Object, java.lang.Object), findAll(), findAll(), isCase(java.lang.Object), isCase(java.lang.Object)
groovy.lang.MissingMethodException: No signature of method: mapeach$_test_closure1.doCall() is applicable for argument types: (java.util.LinkedHashMap$Entry) values: [a=1]
Possible solutions: doCall(java.lang.Object, java.lang.Object), findAll(), findAll(), isCase(java.lang.Object), isCase(java.lang.Object)
	at mapeach.test(mapeach.groovy:5)
	at mapeach.run(mapeach.groovy:8)
{code}","Ubuntu 12.04, Oracle JDK 1.7.0_05-b05",blendmaster,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Jul/12 17:05;blendmaster;BrokenCompileStaticTest.groovy;https://issues.apache.org/jira/secure/attachment/12723026/BrokenCompileStaticTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 11 05:12:20 UTC 2012,,,,,,,,,,"0|i2cqpz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Jul/12 05:12;melix;https://github.com/groovy/groovy-core/commit/7ac73d83d5b9817c05b025cc72d4d04ef1b9cd06;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Parsing problem of number literal 0x8000000000000000L,GROOVY-5583,12816287,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,khmarbaise,khmarbaise,10/Jul/12 15:34,26/Jul/12 16:49,14/Jul/23 06:00,11/Jul/12 11:58,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,2.1.0-beta-1,,Compiler,,,,0,,,,,,"I have the following small part of a java class:
{code}
    public class GBitMaskTest {
    
        @Test
        public void checkFirstBitTest() {
            BitMask bm = new BitMask(0x8000000000000000L);
            assertEquals(true, bm.isBitSet(63));
        }
    
    ...
    }
{code}
which should be compilable in Groovy as well cause it's valid Java code. But i get the following:
{code}
    Groovy Bug --- exception in phase 'conversion' in source unit '/home/g-ut-example/src/test/groovy/com/soebes/training/maven/simple/GBitMaskTest.groovy' For input string: ""8000000000000000""
    BUG! exception in phase 'conversion' in source unit '/home/g-ut-example/src/test/groovy/com/soebes/training/maven/simple/GBitMaskTest.groovy' For input string: ""8000000000000000""
{code}
This has happened with Groovy 2.0 in relationship with Maven. It's this example https://github.com/khmarbaise/maui/tree/master/src/main/resources/g-ut-example which produces this problem. I'm compiling with the following part:
{code}
      <build>
        <plugins>
          <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <configuration>
              <compilerId>groovy-eclipse-compiler</compilerId>
              <compilerArgument>nowarn</compilerArgument>
              <verbose>true</verbose>
            </configuration>
            <dependencies>
              <dependency>
                <groupId>org.codehaus.groovy</groupId>
                <artifactId>groovy-eclipse-compiler</artifactId>
                <version>2.7.0-01</version>
              </dependency>
              <dependency>
                <groupId>org.codehaus.groovy</groupId>
                <artifactId>groovy-eclipse-batch</artifactId>
                <version>2.0.0-01</version>
              </dependency>
            </dependencies>
          </plugin>
        </plugins>
      </build>
{code}
The rest of the error message (EXception):
{code}
    GBitMaskTest.groovy' For input string: ""8000000000000000""
    	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:1001)
    	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:624)
    	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:600)
    	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:577)
    	at org.codehaus.jdt.groovy.internal.compiler.ast.GroovyCompilationUnitDeclaration.processToPhase(GroovyCompilationUnitDeclaration.java:171)
    	at org.codehaus.jdt.groovy.internal.compiler.ast.GroovyParser.dietParse(GroovyParser.java:455)
    	at org.codehaus.jdt.groovy.integration.internal.MultiplexingParser.dietParse(MultiplexingParser.java:44)
    	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:775)
    	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:395)
    	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:485)
    	at org.eclipse.jdt.internal.compiler.batch.Main.performCompilation(Main.java:3829)
    	at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1682)
    	at org.codehaus.groovy.eclipse.compiler.GroovyEclipseCompiler.compile(GroovyEclipseCompiler.java:243)
    	at org.apache.maven.plugin.AbstractCompilerMojo.execute(AbstractCompilerMojo.java:678)
    	at org.apache.maven.plugin.TestCompilerMojo.execute(TestCompilerMojo.java:161)
    	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101)
    	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209)
    	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
    	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
    	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)
    	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)
    	at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)
    	at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)
    	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:320)
    	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)
    	at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)
    	at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)
    	at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)
    	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    	at java.lang.reflect.Method.invoke(Method.java:597)
    	at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)
    	at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)
    	at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)
    	at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)
    Caused by: java.lang.NumberFormatException: For input string: ""8000000000000000""
    	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:48)
    	at java.lang.Long.parseLong(Long.java:422)
    	at org.codehaus.groovy.syntax.Numbers.parseInteger(Numbers.java:215)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.integerExpression(AntlrParserPlugin.java:3184)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:2153)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:2018)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:2008)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:2046)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:2018)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:2008)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.addArgumentExpression(AntlrParserPlugin.java:3071)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.arguments(AntlrParserPlugin.java:2994)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.constructorCallExpression(AntlrParserPlugin.java:2932)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:2069)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:2018)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:2008)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.declarationExpression(AntlrParserPlugin.java:1776)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.variableDef(AntlrParserPlugin.java:1792)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.statement(AntlrParserPlugin.java:1513)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.statementListNoChild(AntlrParserPlugin.java:1599)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.statementList(AntlrParserPlugin.java:1574)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.methodDef(AntlrParserPlugin.java:1045)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.objectBlock(AntlrParserPlugin.java:800)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.innerClassDef(AntlrParserPlugin.java:783)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.classDef(AntlrParserPlugin.java:677)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.convertGroovy(AntlrParserPlugin.java:361)
    	at org.codehaus.groovy.antlr.AntlrParserPlugin.buildAST(AntlrParserPlugin.java:269)
    	at org.codehaus.groovy.control.SourceUnit.convert(SourceUnit.java:302)
    	at org.codehaus.groovy.control.CompilationUnit$3.call(CompilationUnit.java:706)
    	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:992)
    	... 35 more
{code}",All,ataylor284,guillaume,khmarbaise,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 11 05:39:10 UTC 2012,,,,,,,,,,"0|i2cddb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jul/12 03:27;tim_yates;I guess this could be fixed by replacing

{code}
case 'l':
  return new Long( Long.parseLong(text, radix) );
{code}

with

{code}
case 'l':
  return new Long( new BigInteger( text, radix ).longValue() );
{code}

in [org.codehaus.groovy.syntax.Numbers.parseInteger|https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/syntax/Numbers.java#L209]

But I always worry I've missed some sort of breaking change with low level stuff like this.

BTW:  [Andrew Taylor's answer|http://stackoverflow.com/a/11419877/6509] to this question on Stackoverflow has links to the relevant part of the Java spec that allows this;;;","11/Jul/12 04:35;guillaume;Just for further look at the issue, just this simple example fails parsing in Groovy (no need for using Maven and/or the Eclipse compiler as indicated in the stacktrace):
{code}
long longNumber = 0x8000000000000000L
{code};;;","11/Jul/12 04:48;guillaume;Something that puzzles me... this number can't be a long, can it?
It won't fit in a long, so you'll get an overflow, and the number you actually get is some negative long number like -9223372036854775808.
Shouldn't Java and Groovy disallow that?;;;","11/Jul/12 04:53;tim_yates;The Java Specification [specifically allows it though|http://docs.oracle.com/javase/specs/jls/se7/html/jls-3.html#jls-3.10.1]

{quote}
The most negative hexadecimal, octal, and binary literals of type long - each of which represents the decimal value -9223372036854775808L (-2^63^) - are respectively:

0x8000_0000_0000_0000L, and

010_0000_0000_0000_0000_0000L, and

0b1000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000L
{quote};;;","11/Jul/12 04:54;guillaume;Actually Java allows that overflow, so I guess we should just do the same.;;;","11/Jul/12 04:57;guillaume;I'll go with your proposed change Tim.;;;","11/Jul/12 05:06;tim_yates;My proposed change might go too far as won't it allow:

{code}
long longNumber = 9223372036854775808L
// -9223372036854775808
{code}
?

Wheras Java would give:

{code}
long num = 9223372036854775808L ;
// EXCEPTION: Integer number too large
{code}

;;;","11/Jul/12 05:10;guillaume;Do you have a better suggestion?;;;","11/Jul/12 05:15;tim_yates;Not without doing something like:

{code}
return radix == 10 ? 
                  new Long( Long.parseLong(text) ) :
                  new Long( new BigInteger(text, radix).longValue() ) ;
{code}

Or maybe Groovy should just handle overflows more leniently than Java?;;;","11/Jul/12 05:21;guillaume;Yeah, it should allow at least what Java allows, and if it accepts more, it's okay I believe.;;;","11/Jul/12 05:22;guillaume;Is there a similar change we should be doing to the integer case as well btw?;;;","11/Jul/12 05:28;tim_yates;Yeah, doing this:

{code}
int a = 0x80000000 // -2147483648
{code}

Works, but specifying an int in the number:

{code}
int a = 0x80000000i // BUG! exception in phase 'conversion'
{code}

Same problem...  I guess here we'd need to parse as a Long and then drop it back to an Integer

My only concern is that I have a history of coming up with _*solutions*_ like this, to later be shown by Paul or Jochen that the solution breaks existing stuff for a reason I didn't consider ;-);;;","11/Jul/12 05:39;tim_yates;Would a neater solution be to change [the switch at line 209|https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/syntax/Numbers.java#L209] to:

{code}
BigInteger value = new BigInteger( text, radix );

switch (type)
{
    case 'i':
        return Integer.valueOf( value.intValue() );
    case 'l':
        return new Long( value.longValue() );
    case 'g':
        return value ;
    default:
        // If not specified, we will return the narrowest possible
        // of Integer, Long, and BigInteger.
        if( value.compareTo(MAX_INTEGER) <= 0 && value.compareTo(MIN_INTEGER) >= 0 )
        {
            return Integer.valueOf(value.intValue());
        }
        else if( value.compareTo(MAX_LONG) <= 0 && value.compareTo(MIN_LONG) >= 0 )
        {
            return new Long(value.longValue());
        }
        return value;
}
{code}

But as I said above, this will make the Groovy numeric specification more lenient with regards overflow than the Java one.

PS:  Not sure why {{Integer.valueOf}} is used for Integers, but {{new Long}} for Longs (rather than {{Long.valueOf}} in the existing code (I have duplicated this style here as I assume there's a reason);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
An AIC cannot extend a non static inner class,GROOVY-5582,12816393,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,melix,melix,10/Jul/12 07:02,08/Jul/14 15:28,14/Jul/23 06:00,03/Jul/14 05:18,1.8.6,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.3.4,,,Compiler,,,,0,,,,,,"Groovy doesn't support anonymous inner classes if they extend a *non static* inner class. For example:

{code}
class Outer {
    int outer() { 1 }
    abstract class Inner {
        abstract int inner()
    }
    int test() {
        Inner inner = new Inner() {
            int inner() { outer() }
        }
        inner.inner()
    }
}
assert new Outer().test() == 1
{code}",,blackdrag,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 03 05:18:33 UTC 2014,,,,,,,,,,"0|i2cryn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jul/14 05:18;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic doesn't support interfaces extending other interfaces,GROOVY-5580,12818169,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,scoreunder,scoreunder,06/Jul/12 20:54,26/Jul/12 16:49,14/Jul/23 06:00,09/Jul/12 10:24,2.0-rc-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,Static Type Checker,,,0,,,,,,"[Major is the default priority, sorry if I'm supposed to assign to another]
This code fails during static type checking:
{noformat}
interface A {
    String getName();
}

interface B extends A {
    void foo();
}

@groovy.transform.CompileStatic
class C {
    String name
    void bar(B b)
    {
        b.foo()
        name = b.name
    }
}
new C()
{noformat}

With this error:
{noformat}
[Static type checking] - No such property: name for class: B
{noformat}

Changing the code to use getName() works, as does casting b to A.

I also encountered a related issue, in which the getName() workaround fails:
{noformat}
interface A {
    String getName();
}

interface A2 {
    String getName();
}

interface B extends A,A2 {
    void foo();
}

@groovy.transform.CompileStatic
class C {
    String name
    void bar(B c)
    {
        c.foo()
        name = c.getName()
    }
}
new C()
{noformat}
The casting workaround still works, but otherwise the error given is:
{noformat}
[Static type checking] - Reference to method is ambiguous. Cannot choose between [MethodNode@1813166140[java.lang.String getName()], MethodNode@877270685[java.lang.String getName()]]
{noformat}
","Windows 7 x64, Java 7",scoreunder,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-06 20:54:38.0,,,,,,,,,,"0|i2cn4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compiler sometimes use setProperty where it could make direct access,GROOVY-5579,12816394,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,06/Jul/12 08:37,26/Jul/12 16:49,14/Jul/23 06:00,16/Jul/12 10:44,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,,,,0,,,,,,"Take the following code:
{code}
@groovy.transform.CompileStatic
class Test {
    A a = new A()
    void foo() {
        a.x = 1
    }
}
class A { 
    int x
}

new Test().foo()
{code}
The static compiler sets the ""x"" variable from A using {{ScriptBytecodeAdapter.setProperty}} although it could use {{A#setX}}.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-06 08:37:34.0,,,,,,,,,,"0|i2c3zj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot use default map constructor with Java classes and type checking,GROOVY-5578,12816374,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,06/Jul/12 07:19,26/Jul/12 16:49,14/Jul/23 06:00,09/Jul/12 11:52,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,0,,,,,,"Example:

{code}
@GrabResolver('http://repo.grails.org/grails/core')
@Grab(group='org.grails', module='grails-bootstrap', version='2.0.4')
import org.codehaus.groovy.grails.resolve.SnapshotAwareM2Resolver

@groovy.transform.CompileStatic
def foo() {
 def url = ""blah""
 def resolver = new SnapshotAwareM2Resolver(name: url, root: url, m2compatible: true, changingPattern: "".*SNAPSHOT"")
}
{code}

Results in:

{code}

[Static type checking] - Cannot find matching method org.codehaus.groovy.grails.resolve.SnapshotAwareM2Resolver#<init>(java.util.Map <java.lang.String, java.io.Serializable>)
 at line: 8, column: 17
{code}",,graemerocher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-06 07:19:37.0,,,,,,,,,,"0|i2c98v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Log4j annotation causes class generation BUG!,GROOVY-5574,12812113,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,04/Jul/12 05:36,26/Jul/12 16:49,14/Jul/23 06:00,06/Jul/12 03:00,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,class generator,Compiler,,,1,,,,,,"Running this script:

{code}
import groovy.util.logging.Log4j

@Log4j
class Test {
  void doit() {
    log.debug( 'woo' )
  }
  
  static main( args ) {
    new Test().doit()
  }
}
{code}

Causes:

{code}
BUG! exception in phase 'class generation' in source unit 'log4jannotation.groovy' ClassNode#getTypeClass for org.apache.log4j.Logger is called before the type class is set 
	at org.codehaus.groovy.ast.ClassNode.getTypeClass(ClassNode.java:1327)
	at org.codehaus.groovy.classgen.asm.BytecodeHelper.box(BytecodeHelper.java:596)
	at org.codehaus.groovy.classgen.asm.OperandStack.box(OperandStack.java:205)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.prepareSiteAndReceiver(CallSiteWriter.java:233)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.prepareSiteAndReceiver(CallSiteWriter.java:221)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.makeCallSite(CallSiteWriter.java:270)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:229)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:76)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:60)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:334)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:649)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:354)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:510)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:155)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:456)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:320)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:277)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:397)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:181)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:783)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)
	at groovy.lang.GroovyShell.run(GroovyShell.java:480)
	at groovy.lang.GroovyShell.run(GroovyShell.java:163)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:931)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:404)
	at groovy.lang.Closure.run(Closure.java:488)
	at java.lang.Thread.run(Thread.java:680)
{code}",,melix,nobeans,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5557,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 04 07:33:26 UTC 2012,,,,,,,,,,"0|i2c53j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Jul/12 05:59;tim_yates;Actually, I guess this is the same thing as:

https://jira.codehaus.org/browse/GROOVY-5557

Which is a report for the Slf4j logging annotation doing the same thing...;;;","04/Jul/12 07:15;tim_yates;It seems to be in the static initialiser of {{groovy.util.logging.Log4j}}

https://github.com/groovy/groovy-core/blob/master/src/main/groovy/util/logging/Log4j.java#L65

If the calls to:

{code}
tmp1 = ClassHelper.make(Class.forName(""org.apache.log4j.Logger""));
tmp2 = ClassHelper.make(Class.forName(""org.apache.log4j.Priority""));
{code}

fail, then it catches the exception and runs:

{code}
tmp1 = ClassHelper.make(""org.apache.log4j.Logger"");
tmp2 = ClassHelper.make(""org.apache.log4j.Priority"");
{code}

Which produces an invalid classfile for some reason...

When running the current master branch (2.1.0-SNAPSHOT) and adding:

{code}
@GrabConfig( systemClassLoader=true )
@Grab( 'log4j:log4j:1.2.17' )
{code}

To the top of the script in this report, it seems to work, so I guess this is a classpath issue...
;;;","04/Jul/12 07:33;melix;Yes, this is most likely the problem. In that case, we should problably not use static fields but instance ones, and pickup the classes from the right classloader. Now I'm usure what happens if using @Grab and an AST transform for which we need to know the classloader being used by @Grab.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker incorrectly selecting DGM return type instead of actual return type,GROOVY-5573,12816257,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,03/Jul/12 07:36,26/Jul/12 16:49,14/Jul/23 06:00,05/Jul/12 14:43,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,0,,,,,,"The following code:

{code}
import java.lang.reflect.Array

@groovy.transform.CompileStatic
def arrayTest() {
   Object[] joinedArray = (Object[]) Array.newInstance(Integer.class, 10);
}
{code}

Results in 

{code}
[Static type checking] - Inconvertible types: cannot cast java.lang.reflect.Array to [Ljava.lang.Object;
 at line: 5, column: 27
{code}

The DGM newInstance method is being used instead of http://docs.oracle.com/javase/6/docs/api/java/lang/reflect/Array.html#newInstance(java.lang.Class,%20int)",,graemerocher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5607,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-03 07:36:24.0,,,,,,,,,,"0|i2cra7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Invalid behaviour of ?: operator within an 'if' statement in closure,GROOVY-5572,12816397,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,dmovchinn,dmovchinn,03/Jul/12 07:11,26/Jul/12 16:49,14/Jul/23 06:00,10/Jul/12 09:36,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,ast builder,Compiler,,,0,closure,if,operator,ternary,,"The invalid result appears only in 2.0.0 version of Groovy:

dm@dmc:~/bin/groovy-2.0.0/bin> ./groovysh
Groovy Shell (2.0.0, JVM: 1.6.0_29)
Type 'help' or '\h' for help.
---------------------------------------------
groovy:000> def c = {def s; if (it.y == null) s = true; else s = it.z < it.x - 1 ? null : true; s}; c(z: 0, y: 2, x: 3)
===> false
groovy:000>

In Groovy 1.8.6 the result is correct.

dm@dmc:~/bin/groovy-1.8.6/bin> ./groovysh
Groovy Shell (1.8.6, JVM: 1.6.0_29)
Type 'help' or '\h' for help.
----------------------------------------------
groovy:000> def c = {def s; if (it.y == null) s = true; else s = it.z < it.x - 1 ? null : true; s}; c(z: 0, y: 2, x: 3)
===> null
groovy:000> 

It can be fixed by replacing the ternary operator with 'else if' and 'else'.","OpenSUSE 11.4 x86_64, Oracle Java SE 1.6 Update 29",blackdrag,dmovchinn,melix,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/Jul/12 07:11;dmovchinn;testCase.groovy;https://issues.apache.org/jira/secure/attachment/12722170/testCase.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 10 08:26:40 UTC 2012,,,,,,,,,,"0|i2bp7r:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"03/Jul/12 13:46;blackdrag;to make it more clear... the problem is not a wrongly taken branch in there somewhere, but that in 1.8.6 returns a null and in 2.0.0 false, which is most probably Groovy truth applied on the null.;;;","03/Jul/12 22:58;dmovchinn;Groovy is a dynamic language, therefore the types of variables are not defined at the moment of compilation. So, Groovy doesn't know a type of the variable 's' within my closure. There are no annotations @CompileStatic or new features such as a type inference in my code. That's why I don't see a 'truth' applied on the null. However, that behavior of the ternary operator within the 'if' statement can affect the code targeted to older versions of Groovy that breaks the backward compatibility.;;;","10/Jul/12 02:29;dmovchinn;Another simplified example: {{true ? null : true}} produce {{false}} instead of {{null}};;;","10/Jul/12 08:26;melix;Raising priority;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Missing or wrong osgi headers since 2.0-rc1,GROOVY-5571,12816252,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,amergey,amergey,03/Jul/12 03:24,26/Jul/12 16:49,14/Jul/23 06:00,26/Jul/12 09:58,2.0.0,2.0-rc-1,2.0-rc-2,2.0-rc-3,2.0-rc-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,,,,,0,,,,,,"Since 2.0-rc1 osgi import-package and export-package headers are not correct anymore so groovy-all.jar is not really usable in osgi environment anymore.
Previous version were fine.
Those headers are extracted in attached file, beta3 version seems the correct one, and some are missing in release.

Also groovy.jar is osgified, but none of modules groovy-xxx.jar are, so they probably should in order to be able to use them in osgi environment
",,amergey,bbrooks,guillaume,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/Jul/12 03:26;amergey;export-package_2.0.0.txt;https://issues.apache.org/jira/secure/attachment/12721723/export-package_2.0.0.txt","03/Jul/12 03:27;amergey;export-package_beta3.txt;https://issues.apache.org/jira/secure/attachment/12722538/export-package_beta3.txt","03/Jul/12 03:28;amergey;import-package_2.0.0.txt;https://issues.apache.org/jira/secure/attachment/12722361/import-package_2.0.0.txt","03/Jul/12 03:30;amergey;import-package_beta3.txt;https://issues.apache.org/jira/secure/attachment/12722607/import-package_beta3.txt",,,,,4.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 26 09:59:07 UTC 2012,,,,,,,,,,"0|i2bxrr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jul/12 19:20;paulk;Is there any chance you can test out the 2.1.0-SNAPSHOT artifacts from here: http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-xxx/2.1.0-SNAPSHOT/
The modules should now have OSGi information. The all jar still doesn't have groovy.text - so there is still some work to do before we can close the issue - but having some early feedback can only help.;;;","07/Jul/12 01:55;paulk;Just for historical interest, beta3 was deployed using the now defunct ant build. Subsequent builds have used gradle. The gradle OSGi support doesn't support creation of an uber jar in a straight-forward way when both jarjar and OSGi are in play.

To fix the all jar perhaps we need to use (or follow the ideas in): https://bitbucket.org/vayana/gradle-bnd-plugin/overview ;;;","09/Jul/12 04:08;amergey;osgi headers from module are still not correct because of invalid char in version.

For example for groovy-template, following headers:

Export-Package: groovy.text;version=""2.1.0-SNAPSHOT""
Bundle-Version: 2.1.0-SNAPSHOT

should be replaced with

Export-Package: groovy.text;version=""2.1.0""
Bundle-Version: 2.1.0.qualifier;;;","09/Jul/12 20:03;paulk;The version number should be well-formatted now.;;;","10/Jul/12 09:34;bbrooks;Will this ticket also address http://jira.codehaus.org/browse/GROOVY-5474?  The MANIFEST.MF in groovy-all-2.0.0-indy.jar final release still lacks OSGi entries (e.g. Import-Package , Export-Package, etc.).;;;","10/Jul/12 09:38;melix;@Brian: Those are separate issues. The lack of support of osgi in the indy jar is related to the bnd tool, which isn't out yet in a JDK 7 compatible version.;;;","11/Jul/12 04:03;amergey;Just a detail but ""Eclipse-LazyStart: true"" header is deprectated and should be replaced wit:
Bundle-ActivationPolicy: lazy;;;","11/Jul/12 04:20;guillaume;Arnaud, this one is an easy fix, I'm gonna apply the change.
I noticed there's another ""eclipse"" attribute: ""Eclipse-BuddyPolicy"".
It's again specific to Eclipse somehow, has it been deprecated too?

Currently, the fixed attributes we set in our Gradle build file looks like this:
{code}
ext.allManifest = manifest {
    attributes(""Built-By"": System.properties['user.name'],
            ""Extension-Name"": 'groovy',
            ""Specification-Title"": 'Groovy: a powerful, dynamic language for the JVM',
            ""Specification-Version"": project.version,
            ""Specification-Vendor"": 'The Codehaus',
            ""Implementation-Title"": 'Groovy: a powerful, dynamic language for the JVM',
            ""Implementation-Version"": project.version,
            ""Implementation-Vendor"": 'The Codehaus',
            ""Bundle-ManifestVersion"": '2',
            ""Bundle-Name"": 'Groovy Runtime',
            ""Bundle-Description"": 'Groovy Runtime',
            ""Bundle-Version"": groovyBundleVersion,
            ""Bundle-Vendor"": 'The Codehaus',
            ""Bundle-ClassPath"": '.',
            ""Bundle-RequiredExecutionEnvironment"": 'J2SE-1.5',
            ""Eclipse-BuddyPolicy"": 'dependent',
            ""Bundle-ActivationPolicy"": 'true',
            ""DynamicImport-Package"": '*',
            ""Main-class"": 'groovy.ui.GroovyMain')
}
{code};;;","11/Jul/12 04:40;amergey;The Eclipse-LazyStart is deprecated and it is better to replace it with Bundle-ActivationPolicy, because it will be understood across various OSGI Framework implementation.

Eclipse-BuddyPolicy is not deprecated,  it is used to specify the buddy classloading policies for a bundle, it is Eclipse specific and OSGi does not know anything about this (It will be ignored for other implementation than equinox)

Also I just noticed something strange in groovy.jar manifest, there are a bunch of compiler.xxx packages in Export-Package and I am not sure it should be here.;;;","11/Jul/12 04:44;amergey;In your gradle it should be ""Bundle-ActivationPolicy"": 'lazy' not ""Bundle-ActivationPolicy"": 'true';;;","11/Jul/12 04:52;guillaume;Ok, I made that change as well.;;;","13/Jul/12 17:08;paulk;The ""compiler.xxx"" packages should be gone now too;;;","25/Jul/12 06:40;paulk;It would be great if you could try out 2.0.1 - it should be in the maven repo in the next couple of hours. It should have all of the above fixes and hopefully a fixed groovy-all jar too.;;;","26/Jul/12 09:55;amergey;2.0.1 seems to be good now, thanks;;;","26/Jul/12 09:59;guillaume;Glad it works for you!
Thanks for reporting back to us.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CompileStatic gives VerifyError: Register 1 contains wrong type,GROOVY-5570,12818172,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,02/Jul/12 08:56,26/Jul/12 16:49,14/Jul/23 06:00,09/Jul/12 09:32,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,,,,0,,,,,,"If you enter the following into the GroovyConsole:

{code}
import groovy.transform.*

@CompileStatic
class Test {
  List<Integer> elements
  
  public Test( List<Integer> elements ) {
    this.elements = elements
  }
  
  void regularEach() {
    int idx = 0
    elements.each { Integer elem ->
      ""$elem:${idx++}""
    }
  }
}

new Test( [1,2,3] )
{code}

You get the Error:

{code}
java.lang.VerifyError: (class: Test, method: regularEach signature: ()V) Register 1 contains wrong type
	at java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2389)
	at java.lang.Class.getDeclaredConstructors(Class.java:1836)
	at org.codehaus.groovy.reflection.CachedClass$2$1.run(CachedClass.java:69)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.codehaus.groovy.reflection.CachedClass$2.initValue(CachedClass.java:66)
	at org.codehaus.groovy.reflection.CachedClass$2.initValue(CachedClass.java:64)
	at org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:46)
	at org.codehaus.groovy.util.LazyReference.get(LazyReference.java:33)
	at org.codehaus.groovy.reflection.CachedClass.getConstructors(CachedClass.java:258)
	at groovy.lang.MetaClassImpl.<init>(MetaClassImpl.java:185)
	at groovy.lang.MetaClassImpl.<init>(MetaClassImpl.java:189)
	at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createNormalMetaClass(MetaClassRegistry.java:157)
	at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.createWithCustomLookup(MetaClassRegistry.java:147)
	at groovy.lang.MetaClassRegistry$MetaClassCreationHandle.create(MetaClassRegistry.java:130)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:165)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:182)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:302)
	at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:767)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallConstructorSite(CallSiteArray.java:84)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:190)
	at ConsoleScript6.run(ConsoleScript6:19)
        ...

{code}
","* Groovy: 2.0.0
* JVM: Java HotSpot(TM) 64-Bit Server VM (20.6-b01-415, Apple Inc.)
    * JRE: 1.6.0_31
* OS: Mac OS X (10.6.8, x86_64) ",melix,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 06 09:38:54 UTC 2012,,,,,,,,,,"0|i2cmcf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jul/12 09:25;tim_yates;I'm guessing it's a problem with the {{each}} call manipulating the {{idx}} variable inside the loop...

Which is fair enough :-)  (but I guess the error message could be nicer);;;","06/Jul/12 09:38;melix;I can reproduce the problem, and it seems related to having a primitive type as a closure shared variable. This minimal example is sufficient to reproduce the {{VerifyError}} (if used in a {{@CompileStatic}} section:

{code}
  int idx = 0
  def cl = { idx }
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Can't call method with concrete map implementation and generic arguments,GROOVY-5569,12816369,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,02/Jul/12 07:39,26/Jul/12 16:49,14/Jul/23 06:00,12/Jul/12 11:48,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,0,,,,,,"Example:

{code}

import java.util.concurrent.*

class Foo {
    
    private static ThreadLocal<Map<Integer, String>> cachedConfigs = new ThreadLocal<Map<Integer, String>>()
    @groovy.transform.CompileStatic
    static foo() {
           def configs = new ConcurrentHashMap<Integer, String>()
           cachedConfigs.set configs

    }
}

{code}

Error

{code}
[Static type checking] - Cannot call java.lang.ThreadLocal#set(java.util.Map <Integer, String>) with arguments [java.util.concurrent.ConcurrentHashMap <Integer, String>] 
 at line: 9, column: 12
{code}",,graemerocher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-02 07:39:31.0,,,,,,,,,,"0|i2cf07:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DGM properties not available in interfaces?,GROOVY-5568,12816381,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,02/Jul/12 07:29,09/Nov/22 14:41,14/Jul/23 06:00,05/Jul/12 12:07,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,,,,0,,,,,,"Example:

{code}
class Foo {
    
    @groovy.transform.CompileStatic
    static foo() {
        InputStream input
        println input.text
    }
}
{code}

Produces:

{code}

[Static type checking] - No such property: text for class: java.io.InputStream
 at line: 8, column: 17
{code}",,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6738,,,,,,GROOVY-10815,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 05 09:34:16 UTC 2012,,,,,,,,,,"0|i2bmy7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jul/12 09:34;melix;As a workaround, {{input.getText()}} works.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Types not inferred correctly for static fields,GROOVY-5567,12816379,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,02/Jul/12 07:22,26/Jul/12 16:49,14/Jul/23 06:00,05/Jul/12 14:06,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,,,,0,,,,,,"Example:

{code}
import org.apache.commons.logging.LogFactory

class Foo {
    private static final LOG = LogFactory.getLog(this)
    
    @groovy.transform.CompileStatic
    static foo() {
        def bar = 1
        LOG.debug ""number is $bar""
    }
}
{code}

Produces

{code}
[Static type checking] - Cannot find matching method java.lang.Object#debug(groovy.lang.GString)
 at line: 9, column: 9
{code}",,blackdrag,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 05 14:06:47 UTC 2012,,,,,,,,,,"0|i2c68f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jul/12 07:27;melix;This is not a bug: only method {{foo}} is statically compiled (thus type checked). So ""LogFactory.getLog(this)"" is a dynamic call and as it is not visited (type checked), the type checker knows nothing about its type.;;;","02/Jul/12 07:31;graemerocher;Hmm, I would still consider it a bug, as a user how am I to know what calls were visited or not? I would suggest if this is not fixed a better error message is reported;;;","02/Jul/12 07:35;melix;We only visit what is within the scope of the annotation, so if you annotate a method, only that method is type checked. Anything beyond is not type checked. I am unsure how we can improve the error message here, since there's no difference between this and the fact of mixing ""dynamic"" code with type checked code, using some methods annotated with @TypeChecked and some others not.
;;;","03/Jul/12 03:04;blackdrag;The method debug is not found, because LOG is declared as being of type Object (def), thus has no debug method. Either the field is declared to be of type Log, then the checker will not have a problem and find the method, or the class needs to be annotated so that the type checker can infer the type.

As for a better error message - in case it is on Object I would suggest this:
Cannot find matching method java.lang.Object#debug(groovy.lang.GString). Try changing the declared receiver type.

Or for a general approach:
Cannot find matching method java.lang.Object#debug(groovy.lang.GString). Please check if the declared type is right and if the method exists.
;;;","05/Jul/12 14:06;melix;Solved by improving the error message. The message is the ""general approach"" suggestion from Jochen.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
possible bug when applying static typing to AIC referencing an outer local variable,GROOVY-5566,12811684,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,paulk,,02/Jul/12 06:22,07/Apr/15 19:07,14/Jul/23 06:00,10/Jul/12 08:25,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,,,,,0,,,,,,"compiling this code:
{code}
@groovy.transform.TypeChecked
def foo() {
    List things = []
    Serializable s = new Serializable() {
      def size() {
        things.size()
      }
    }
    s.size()
}

println foo()
{code}
yields this error:
{noformat}
[Static type checking] - Cannot find matching method ConsoleScript51$1#<init>(ConsoleScript51, java.util.List)
 at line: 4, column: 22
{noformat}
If you make the {{things}} list be something more specific, e.g. {{['a', 'b']}}, then the error message becomes more specific:
{noformat}
[Static type checking] - Cannot find matching method ConsoleScript54$1#<init>(ConsoleScript54, java.util.List <java.lang.String>)
 at line: 4, column: 22
{noformat}
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-02 06:22:38.0,,,,,,,,,,"0|i2cth3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE when using TypeChecking and AIC with field,GROOVY-5565,12818429,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,paulk,,02/Jul/12 06:16,07/Apr/15 19:06,14/Jul/23 06:00,10/Jul/12 07:15,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,,,,,0,,,,,,"compiling this code:
{code}
@groovy.transform.TypeChecked
def foo() {
    Serializable s = new Serializable() { List things = [] }
    println s.things.size()
}

foo()
{code}
yields:
{noformat}
java.lang.NullPointerException
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferDiamondType(StaticTypeCheckingVisitor.java:456)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:394)
    at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:245)
    ...
{noformat}",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-07-02 06:16:03.0,,,,,,,,,,"0|i2clsv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic(SKIP) throws an error,GROOVY-5564,12816366,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,02/Jul/12 02:23,26/Jul/12 16:49,14/Jul/23 06:00,11/Jul/12 12:34,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static compilation,,,,0,,,,,,"If you annotate a class with @CompileStatic, then use @CompileStatic(SKIP) on a method, then calling that method throws an error. However, annotating each method separately with @CompileStatic works.

Example:
{code}
import groovy.transform.CompileStatic
import static groovy.transform.TypeCheckingMode.SKIP

@CompileStatic
class A {
    @CompileStatic(SKIP)
    void m() {}
}

new A().m()
{code}

throws:

{noformat}
java.lang.NoSuchMethodError: A.$getCallSiteArray()[Lorg/codehaus/groovy/runtime/callsite/CallSite;
	at A.m(ConsoleScript0)
	at A$m.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at ConsoleScript0.run(ConsoleScript0:10)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:257)
	at groovy.lang.GroovyShell.run(GroovyShell.java:481)
	at groovy.lang.GroovyShell.run(GroovyShell.java:163)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:951)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:404)
	at groovy.lang.Closure.run(Closure.java:488)
	at java.lang.Thread.run(Thread.java:722)

{noformat}",,guillaume,hircus,mauromol,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 12 03:24:30 UTC 2012,,,,,,,,,,"0|i2c0i7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jul/12 08:46;hircus;Guillaume recommends I join the discussion on this issue, as I'm interested in whether @CompileStatic is sufficient for building Groovy-based Android projects -- looking at the issue in detail, I don't think @CompileStatic(SKIP) is relevant to Android - where the goal is to avoid any dynamic recompilation - of course, ""I am but an egg"";;;","11/Jul/12 12:34;melix;Resolved by always generating the call site array. A better solution would be to check if the class is fully statically compiled. If we go that far, an even better solution would be to remove some of the MOP methods which are generated too and will never be used by the static version of a Groovy class.;;;","11/Jul/12 13:05;guillaume;Perhaps worth creating a dedicated issue for a better fix?;;;","12/Jul/12 03:24;melix;@Guillaume, sure, feel free to create one :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"GroovyFX - Class Cast Exception on BigDecimal to double when using Groovy 2.0 Indy=""true""",GROOVY-5562,12818165,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,jimclarke5,jimclarke5,29/Jun/12 09:21,26/Jul/12 16:49,14/Jul/23 06:00,10/Jul/12 15:52,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,groovy-jdk,,,,0,exception,,,,,"Setting indy=""true"" causes JavaFX binds to fail on failure to convert
BigDecimal to double. This works ok when indy=""false""

=====
""hourAngleProperty.bind((hours() * 30.0) + (minutes() * 0.5))""

this actually translates to this:
hourAngleProperty.bind(hours().multiply(30.0).add(minutes().multiply(0.5)));

where hourAngleProperty, hours() and minutes() are type javafx.beans.property.DoubleProperty.

The problem is the 30.0 and 0.5 are treated as BigDecimal
and with Indy, there seems to be no unboxing of BigDecimal to ""double"".

If i do this:
hourAngleProperty.bind((hours() * (double)30.0) + (minutes() * (double)0.5))

it works. 

But this error is all over the GroovyFX code base.

======
java.lang.ClassCastException: Cannot cast java.math.BigDecimal to java.lang.Double
	at java.lang.Class.cast(Class.java:3005)
	at sun.invoke.util.ValueConversions.primitiveConversion(ValueConversions.java:236)
	at sun.invoke.util.ValueConversions.unboxDouble(ValueConversions.java:118)
	at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
	at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:684)
	at Time.<init>(AnalogClockDemo.groovy:38)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:525)
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
	at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:186)
	at AnalogClockDemo$_run_closure1.doCall(AnalogClockDemo.groovy:64)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:809)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:792)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeClosure(InvokerHelper.java:95)
	at groovyx.javafx.GroovyFX.start(GroovyFX.java:35)
	at com.sun.javafx.application.LauncherImpl$5.run(LauncherImpl.java:319)
	at com.sun.javafx.application.PlatformImpl$5.run(PlatformImpl.java:206)
	at com.sun.javafx.application.PlatformImpl$4.run(PlatformImpl.java:173)
	at com.sun.glass.ui.InvokeLaterDispatcher$Future.run(InvokeLaterDispatcher.java:76)
Exception in Application start method
Exception in thread ""main"" java.lang.RuntimeException: Exception in Application start method
	at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:403)
	at com.sun.javafx.application.LauncherImpl.access$000(LauncherImpl.java:47)
	at com.sun.javafx.application.LauncherImpl$1.run(LauncherImpl.java:115)
	at java.lang.Thread.run(Thread.java:722)
Caused by: java.lang.ClassCastException: Cannot cast java.math.BigDecimal to java.lang.Double
	at java.lang.Class.cast(Class.java:3005)
	at sun.invoke.util.ValueConversions.primitiveConversion(ValueConversions.java:236)
	at sun.invoke.util.ValueConversions.unboxDouble(ValueConversions.java:118)
	at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
	at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:684)
	at Time.<init>(AnalogClockDemo.groovy:38)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:525)
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
	at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:186)
	at AnalogClockDemo$_run_closure1.doCall(AnalogClockDemo.groovy:64)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:809)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:792)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeClosure(InvokerHelper.java:95)
	at groovyx.javafx.GroovyFX.start(GroovyFX.java:35)
	at com.sun.javafx.application.LauncherImpl$5.run(LauncherImpl.java:319)
	at com.sun.javafx.application.PlatformImpl$5.run(PlatformImpl.java:206)
	at com.sun.javafx.application.PlatformImpl$4.run(PlatformImpl.java:173)
	at com.sun.glass.ui.InvokeLaterDispatcher$Future.run(InvokeLaterDispatcher.java:76)
Java Result: 1","Groovy 2.0

java version ""1.7.0_04""
Java(TM) SE Runtime Environment (build 1.7.0_04-b21)
Java HotSpot(TM) 64-Bit Server VM (build 23.0-b21, mixed mode)

Max OS X 10.7.4 Intel",blackdrag,jimclarke5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Jun/12 09:21;jimclarke5;AnalogClockDemo.groovy;https://issues.apache.org/jira/secure/attachment/12722362/AnalogClockDemo.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 10 15:52:50 UTC 2012,,,,,,,,,,"0|i2bx3j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Jul/12 15:52;blackdrag;should be fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker should treat gstrings as strings for generic collections,GROOVY-5559,12816265,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,29/Jun/12 08:44,15/Jan/13 08:47,14/Jul/23 06:00,20/Jul/12 07:47,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Static Type Checker,,,,0,,,,,,"Following code:

{code}
@groovy.transform.TypeChecked
def test() {
    def bar = 1
    List<String> list = [""foo"", ""$bar"" ]
}
{code}

Produces

{code}

[Static type checking] - Incompatible generic argument types. Cannot assign java.util.List <java.io.Serializable> to: java.util.List <String>
 at line: 5, column: 5
{code}",,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5908,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 20 07:47:41 UTC 2012,,,,,,,,,,"0|i2cdl3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jul/12 03:11;melix;Reopening. For reason, see: http://groovy.329449.n5.nabble.com/About-GROOVY-5559-td5710746.html;;;","20/Jul/12 07:47;melix;Fixed by improving the error message.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Slf4j throws error in Groovy 2.0,GROOVY-5557,12818166,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,cholick,cholick,28/Jun/12 21:34,26/Jul/12 16:49,14/Jul/23 06:00,06/Jul/12 03:00,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,,,,,3,,,,,,"groovyc throws a stacktrace compiling a class with the @Slf4j in Groovy 2.0. The same source compiles in 1.8.6.

Source file:
{code}
import groovy.util.logging.Slf4j
@Slf4j
class Test {
    Test() { log.debug ""Here"" }
}
{code}

groovyc output:

{noformat}
>>> a serious error occurred: BUG! exception in phase 'class generation' in source unit 'Test.groovy' ClassNode#getTypeClass for org.slf4j.Logger is called before the type class is set 
>>> stacktrace:
BUG! exception in phase 'class generation' in source unit 'Test.groovy' ClassNode#getTypeClass for org.slf4j.Logger is called before the type class is set 
	at org.codehaus.groovy.ast.ClassNode.getTypeClass(ClassNode.java:1327)
	at org.codehaus.groovy.classgen.asm.BytecodeHelper.box(BytecodeHelper.java:596)
	at org.codehaus.groovy.classgen.asm.OperandStack.box(OperandStack.java:205)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.prepareSiteAndReceiver(CallSiteWriter.java:233)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.prepareSiteAndReceiver(CallSiteWriter.java:221)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.makeCallSite(CallSiteWriter.java:270)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:229)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:76)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:60)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:334)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:649)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:354)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:510)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:155)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:456)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:320)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:277)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:119)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructor(AsmClassGenerator.java:392)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1052)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:181)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:783)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1024)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:562)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:540)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:517)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:496)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:57)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:213)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:146)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:176)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:160)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
{noformat}","Linux
java version ""1.7.0_03""
Java(TM) SE Runtime Environment (build 1.7.0_03-b04)
Java HotSpot(TM) 64-Bit Server VM (build 22.1-b02, mixed mode)",cholick,guillaume,owahlen,padcom,wolfmanjm,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5574,,,,,,"28/Jun/12 21:34;cholick;Test.groovy;https://issues.apache.org/jira/secure/attachment/12722168/Test.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 06 04:21:00 UTC 2012,,,,,,,,,,"0|i2bypr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jun/12 03:46;padcom;Confirmed on JDK 1.6.0_32.;;;","06/Jul/12 04:11;padcom;Is there any indication when 2.0.1 is going to be released?;;;","06/Jul/12 04:17;guillaume;We haven't yet decided on the date of release of 2.0.1, and we have a few more issues we'd like to close before releasing it.
But in any case, that won't be very long, just a few weeks away.
Thanks for your patience and sorry for the inconvenience.;;;","06/Jul/12 04:21;owahlen;Hello Cedric,
I ran into the same issue however not with the @Slf4j but with the @Log4j annotation.
I guess your fix resolves my issue, too?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GAPI on codehaus doesn't appear to have subproject groovydoc (check gradle build dist target),GROOVY-5556,12811682,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,28/Jun/12 10:21,07/Apr/15 19:07,14/Jul/23 06:00,02/Jul/12 07:56,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,,,,,0,,,,,,,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 02 07:56:11 UTC 2012,,,,,,,,,,"0|i2cqvb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Jun/12 10:28;paulk;GROOVY-5555 was created to fix the online doco. This issue is to double check whether the build file needs fixing to automate correct production of the appropriate doco.;;;","01/Jul/12 17:28;paulk;fixed on master and the 2.0.1 snapshot branch;;;","02/Jul/12 07:56;paulk;2.0.0 artifacts were manually fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.sql is missing from the 2.0 api docs online and in the docs .zip file,GROOVY-5555,12816530,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,dannyturns,dannyturns,28/Jun/12 10:10,13/Jul/12 17:11,14/Jul/23 06:00,13/Jul/12 17:11,2.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.0,,,Documentation,,,,0,Documentation,gapi,,,,"The groovy API documents at http://groovy.codehaus.org/gapi/ do not have the groovy.sql package, nor is this package in the download groovy-docs-2.0.0.zip:

{noformat}
/Xfer/Groovy$ unzip -l groovy-docs-2.0.0.zip | grep sql
        0  06-28-2012 08:48   groovy-2.0.0/html/groovy-jdk/java/sql/
     6185  06-28-2012 08:48   groovy-2.0.0/html/groovy-jdk/java/sql/Timestamp.html
     8608  06-28-2012 08:48   groovy-2.0.0/html/groovy-jdk/java/sql/Date.html
     5246  06-28-2012 08:48   groovy-2.0.0/html/groovy-jdk/java/sql/ResultSetMetaData.html
     5183  06-28-2012 08:48   groovy-2.0.0/html/groovy-jdk/java/sql/ResultSet.html
      950  06-28-2012 08:48   groovy-2.0.0/html/groovy-jdk/java/sql/package-frame.html
/Xfer/Groovy$ 
{noformat}

",any ,dannyturns,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Jun/12 10:10;dannyturns;Screenshot.png;https://issues.apache.org/jira/secure/attachment/12722995/Screenshot.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 28 20:21:12 UTC 2012,,,,,,,,,,"0|i2brsv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Jun/12 10:28;melix;I'm reuploading the api docs right now. You can find the docs in Maven, though, with the groovy-all artifact: http://central.maven.org/maven2/org/codehaus/groovy/groovy-all/2.0.0/

More specifically, download the groovydoc jar.;;;","28/Jun/12 11:06;melix;Gapi reuploaded. Thanks for pointing this out.;;;","28/Jun/12 13:32;dannyturns;Cedric, I think something is still not quite right.  When I click on groovy.sql, groovy.swing, to name two, in the overview-summary.html, I get 404 pages:

404 Unknown page gapi/groovy/sql/package-summary.html
/groovy.codehaus.org/gapi/groovy/sql/package-summary.html was not found on this server.

Resin-3.0.14 (built Tue, 05 Jul 2005 11:03:36 PDT) 


404 Unknown page gapi/groovy/swing/package-summary.html
/groovy.codehaus.org/gapi/groovy/swing/package-summary.html was not found on this server.

Resin-3.0.14 (built Tue, 05 Jul 2005 11:03:36 PDT) 

That was after clearing my cache and reloading the page.
;;;","28/Jun/12 20:21;paulk;Tried again - hopefully working this time.

And just to elaborate on Cédric's point. The sql docs aren't in the {{groovy}} groovydoc artifact but are in the {{groovy-sql}} and {{groovy-all}} artifacts. We do need to fix the zip still I believe. I'll cover that off in GROOVY-5556.

If building from source, you can use the {{groovydocAll}} task to generate all the docs.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stackoverflow in JsonSlurper.parseText,GROOVY-5552,12816356,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,guillaume,jonnoerrelykke,jonnoerrelykke,27/Jun/12 07:02,26/Jul/12 16:49,14/Jul/23 06:00,10/Jul/12 09:10,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0.0,,JSON,,,,0,,,,,,"Jun 27, 2012 1:59:43 PM org.codehaus.groovy.runtime.StackTraceUtils sanitize
WARNING: Sanitizing stacktrace:
{code}
java.lang.StackOverflowError
	at java.lang.Character.codePointAt(Character.java:2335)
	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3344)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3760)
	at java.util.regex.Pattern$Curly.match(Pattern.java:3744)
	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)
	at java.util.regex.Pattern$Curly.match0(Pattern.java:3782)
{code}
This will reproduce the error in the console (the first few times, then i starts to work for no reason):
{code}
def url = new URL(""http://vip.regionh.dk/VIP/Redaktoer/133007.nsf/aLoadInfoDokRead?OpenAgent&id=XCA7E63D0762F1706C125791E0045E51B"")
def jsonStr = url.getText(""UTF-8"")
def slurper = new groovy.json.JsonSlurper()
slurper.parseText(jsonStr)
{code}",Groovy Version: 1.8.6 JVM: 1.6.0_33 Vendor: Apple Inc. OS: Mac OS X,guillaume,jonnoerrelykke,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 11 04:04:31 UTC 2012,,,,,,,,,,"0|i2crwn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Jul/12 09:06;guillaume;There might be something odd... but here, even the first time, it's working.
Can you still reproduce the problem?;;;","10/Jul/12 09:10;guillaume;Actually, I tried with Groovy 2.0 and it worked there.
This is probably related to one of the similar problems I've worked around already. The fix is available in the 2.0 release, and will also be present in the 1.8.7 version that we haven't released yet.

If it's still happening when we release 1.8.7, please reopen the issue.;;;","10/Jul/12 15:59;jonnoerrelykke;Just downloaded 2.0 and the script works now every time. Problem solved. Thanks.;;;","11/Jul/12 04:04;guillaume;Glad it works for you!
I tried your example, and the other examples from the other issue I mentioned. I used different JDKs. And could not reproduce the problem either.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy RC release zip download contains duplicate files,GROOVY-5547,12816378,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,marco.vermeulen,marco.vermeulen,24/Jun/12 11:41,08/Jul/12 04:51,14/Jul/23 06:00,27/Jun/12 16:26,2.0-rc-1,2.0-rc-2,2.0-rc-3,2.0-rc-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.0,,,,,,,0,,,,,,"When unzipping the download archive, the command line reports duplicate files to be overwritten. On closer examination, the following two files are duplicated inside the archive:
groovy-2.0.0-rc-4.jar
groovy.icns

To replicate, simply run the following on cli:
unzip groovy-binary-2.0.0-rc-4.zip",Tested on Ubuntu Linux Precise.,marco.vermeulen,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 27 16:26:25 UTC 2012,,,,,,,,,,"0|i2c10v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Jun/12 17:45;paulk;changing summary to better reflect problem at hand - zips aren't corrupt - just contain wasteful duplicates;;;","25/Jun/12 18:15;paulk;fixed in master;;;","27/Jun/12 16:26;paulk;since this is _just_ a packaging issue, we merged the change to the RC branch for the pending 2 release;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Grab a Module Extension fails to match Map objects,GROOVY-5543,12816337,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,tim_yates,tim_yates,22/Jun/12 04:53,26/Jul/12 16:49,14/Jul/23 06:00,25/Jun/12 09:35,2.0-rc-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.1,,,Grape,groovy-jdk,,,0,,,,,,"There seems to be an issue with Modular Extensions not selecting the correct classes to decorate when @Grabbed

In my groovy-stream project, I define my extension class as:

{code}
package groovy.stream ;

import groovy.lang.Closure ;
import java.util.* ;

public class StreamExtension {
  public static Stream toStream( Closure delegate ) {
    return Stream.from( delegate ) ;
  }

  public static Stream toStream( Iterator delegate ) {
    return Stream.from( delegate ) ;
  }

  public static Stream toStream( Iterable delegate ) {
    return Stream.from( delegate ) ;
  }

  public static Stream toStream( Map delegate ) {
    return Stream.from( delegate ) ;
  }
}
{code}

If you then run a test class:

{code}
def m = [ x:1..3, y:5..7 ].toStream().where { x + 4 == y }
assert [[x:1,y:5],[x:2,y:6],[x:3,y:7]] == m.collect()
{code}

With {{groovy -cp groovy-stream-0.3-map.jar testscript.groovy}}, it all works fine, however if you push the jar to a maven repo, and change the test script to:

{code}
@GrabResolver( name='bloidonia', root='https://raw.github.com/timyates/bloidonia-repo/master' )
@Grab('com.bloidonia:groovy-stream:0.3-map')
import groovy.stream.Stream 

def m = [ x:1..3, y:5..7 ].toStream().where { x + 4 == y }
assert [[x:1,y:5],[x:2,y:6],[x:3,y:7]] == m.collect()
{code}

Then running {{groovy testscript.groovy}}, you get the exception:

{code}
Caught: groovy.lang.MissingMethodException: No signature of method: java.util.LinkedHashMap.toStream() is applicable for argument types: () values: []
Possible solutions: toString(), toString(), toString(), toString(), toSpreadMap(), spread()
{code}

If I change the extension class so that the Map function is replaced with:

{code}
  public static Stream toStream( LinkedHashMap delegate ) {
    return Stream.from( delegate ) ;
  }
{code}

Then running:

{code}
@GrabResolver( name='bloidonia', root='https://raw.github.com/timyates/bloidonia-repo/master' )
@Grab('com.bloidonia:groovy-stream:0.3')
import groovy.stream.Stream 

def m = [ x:1..3, y:5..7 ].toStream().where { x + 4 == y }
assert [[x:1,y:5],[x:2,y:6],[x:3,y:7]] == m.collect()
{code}

Works.",Snow Leopard OS X with Java 1.6,melix,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 25 09:35:20 UTC 2012,,,,,,,,,,"0|i2cj5z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jun/12 04:55;tim_yates;Original user list mails are here:

http://groovy.329449.n5.nabble.com/Strange-Bug-With-2-0-Module-Extension-and-Grab-td5710306.html;;;","22/Jun/12 08:38;tim_yates;Had to add ArrayList to my extension methods (I believe for the same issue);;;","25/Jun/12 09:35;melix;https://github.com/groovy/groovy-core/commit/47200caea23b4b53a190c2213a6a755d375019b9;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AstBrowser doesn't show any labels,GROOVY-5541,12816347,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,20/Jun/12 15:03,21/Jun/12 17:03,14/Jul/23 06:00,20/Jun/12 15:04,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Groovy Console,,,,0,,,,,,The AST browser doesn't show any label in the tree anymore.,,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-20 15:03:27.0,,,,,,,,,,"0|i2cpz3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compiler doesn't choose the right method in hierarchy,GROOVY-5540,12813384,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,20/Jun/12 12:15,21/Jun/12 17:03,14/Jul/23 06:00,20/Jun/12 14:01,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static compilation,,,,0,,,,,,"Using the following code seems to indicate the compiler forgets a method in the middle of the hierarchy!

{code:title=foo/Parent.groovy}
package foo

@groovy.transform.CompileStatic
class Parent {
   protected void getChildren() { throw new UnsupportedOperationException() }
}
{code}

{code:title=foo/Child.groovy}
package foo

@groovy.transform.CompileStatic
class Child extends Parent {
   public void getChildren() {   
    throw new UnsupportedOperationException('Child')
   }
}
{code}

{code:title=foo/SubChild.groovy}
package foo

@groovy.transform.CompileStatic
class SubChild extends Child {
}
{code}

{code:title=Usage.groovy}
import foo.*

@groovy.transform.CompileStatic
class Usage {
    public static void main(String... args) {
       def child = new SubChild()
       child.getChildren()
    }
}
{code}

Then it fails with:
{{Caught: java.lang.IllegalAccessError: tried to access method foo.Parent.getChildren()V from class Usage
java.lang.IllegalAccessError: tried to access method foo.Parent.getChildren()V from class Usage}}


",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-20 12:15:34.0,,,,,,,,,,"0|i2cl9r:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@CompileStatic throws verify error using power operator,GROOVY-5539,12813340,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,20/Jun/12 09:47,21/Jun/12 17:03,14/Jul/23 06:00,20/Jun/12 09:51,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static compilation,,,,0,,,,,,"The following code produces a {{VerifyError}}

{code}
int squarePlusOne(int num) {
   num ** num + 1
}
assert squarePlusOne(2) == 5
{code}

The reason is that the helper {{power}} method takes a {{Long}} as first argument, but we call it with an {{Integer}}:

{code}
squarePlusOne(I)I
00000 LTestScripttestPowerShouldNotThrowVerifyError0; I  :  :     ILOAD 1
00001 LTestScripttestPowerShouldNotThrowVerifyError0; I  : I  :     INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
00002 LTestScripttestPowerShouldNotThrowVerifyError0; I  : Integer  :     ILOAD 1
00003 LTestScripttestPowerShouldNotThrowVerifyError0; I  : Integer I  :     INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
00004 LTestScripttestPowerShouldNotThrowVerifyError0; I  : Integer Integer  :     INVOKESTATIC org/codehaus/groovy/runtime/DefaultGroovyMethods.power (Ljava/lang/Long;Ljava/lang/Integer;)Ljava/lang/Number;
00005 ?     :     ICONST_1
00006 ?     :     INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
00007 ?     :     INVOKESTATIC org/codehaus/groovy/runtime/dgmimpl/NumberNumberPlus.plus (Ljava/lang/Number;Ljava/lang/Number;)Ljava/lang/Number;
00008 ?     :     INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.intUnbox (Ljava/lang/Object;)I
00009 ?     :     IRETURN
00010 ?     :     LDC 0
00011 ?     :     IRETURN
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-20 09:47:34.0,,,,,,,,,,"0|i2c8mf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using @CompileStatic produces NoSuchMethodError,GROOVY-5538,12816368,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,20/Jun/12 04:08,21/Jun/12 17:03,14/Jul/23 06:00,20/Jun/12 09:21,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static compilation,,,,0,,,,,,"The following code:

{code}
@GrabResolver('http://repo.grails.org/grails/core')
@Grab(group='org.grails', module='grails-bootstrap', version='2.0.4')
import org.codehaus.groovy.grails.plugins.*
import org.springframework.core.io.*
import groovy.transform.*



@CompileStatic
List<GrailsPluginInfo> getCompileScopedSupportedPluginInfos() {
    def basicInfo = new BasicGrailsPluginInfo(new FileSystemResource(new File("""")))
    basicInfo.name = ""foo""
    def compilesScopedInfo = new BasicGrailsPluginInfo(new FileSystemResource(new File("""")))
    compilesScopedInfo.name = ""bar""
    GrailsPluginInfo[] pluginInfos = [basicInfo] as GrailsPluginInfo[]
    def compileScopePluginInfos = []
    compileScopePluginInfos.add compilesScopedInfo 
    compileScopePluginInfos = compileScopePluginInfos.findAll { GrailsPluginInfo info -> pluginInfos.any { GrailsPluginInfo it -> it.name == info.name } }
}
    
    
getCompileScopedSupportedPluginInfos()
{code}

Results in 

{code}
ava.lang.NoSuchMethodError: java.lang.Object.any(Lgroovy/lang/Closure;)Z
	at ConsoleScript20$_getCompileScopedSupportedPluginInfos_closure1.doCall(ConsoleScript20:18)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:423)
	at org.c
{code}

I also find it odd that there are some MOP calls inside the stack trace since the method is supposed to be statically compiled?",,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 20 04:49:11 UTC 2012,,,,,,,,,,"0|i2c3p3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jun/12 04:49;melix;I just tested with master and the error has disappeared. I think I fixed it as part of GROOVY-5529.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Using @CompileStatic results in ""Illegal use of nonvirtual function call""",GROOVY-5537,12816354,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,20/Jun/12 03:55,21/Jun/12 17:03,14/Jul/23 06:00,20/Jun/12 11:02,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static compilation,,,,0,,,,,,"Uncommenting the following @CompileStatic declaration:

https://github.com/grails/grails-core/blob/master/grails-bootstrap/src/main/groovy/grails/util/PluginBuildSettings.groovy#L840

Results in the following error message:

{code}
Error executing script Compile: (class: grails/util/PluginBuildSettings$_resolvePluginResourcesAndAdd_closure27, method: doCall signature: (Lorg/springframework/core/io/Resource;)Ljava/lang/Object;) Illegal use of nonvirtual function call
{code}

I couldn't reproduce this outside of Grails, but have attached the compiled byte code ",,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Jun/12 03:55;graemerocher;PluginBuildSettings-bytecode.zip;https://issues.apache.org/jira/secure/attachment/12722923/PluginBuildSettings-bytecode.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 20 11:02:32 UTC 2012,,,,,,,,,,"0|i2ck9r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jun/12 11:02;melix;Fixed (side effect of GROOVY-5529);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using @CompileStatic causes VerifierError,GROOVY-5536,12816218,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,graemerocher,graemerocher,20/Jun/12 03:44,21/Jun/12 17:03,14/Jul/23 06:00,20/Jun/12 09:21,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static compilation,,,,0,,,,,,"The following code:

{code}
import groovy.transform.*

@CompileStatic
URL getDescriptorForPlugin(File pluginDir) {
    URL descriptor = null
    File baseFile = pluginDir.canonicalFile
    File basePluginFile = (File)baseFile.listFiles().find {  File it -> it.name.endsWith(""GrailsPlugin.groovy"")}

    if (basePluginFile?.exists()) {
         descriptor = new URL(""http://grails.org"")
    }
    return descriptor
}
{code}

Results in 

{code}

java.lang.VerifyError: (class: ConsoleScript6, method: getDescriptorForPlugin signature: (Ljava/io/File;)Ljava/net/URL;) Expecting to find integer on stack
	at java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2389)
	at java.lang.Class.getConstructor0(Class.java:2699)
{code}",,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 20 06:39:04 UTC 2012,,,,,,,,,,"0|i2bwlr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jun/12 04:51;melix;Confirmed on {{master}}. May be related to GROOVY-5534.;;;","20/Jun/12 06:39;melix;Not directly related to GROOVY-5534, but definitely related to null dereferencing. I could reduce the example to this:

{code}
import groovy.transform.*

@CompileStatic
void getDescriptorForPlugin(File pluginDir) {   
    if (pluginDir?.exists()) {}
}
{code}

If I remove the null check, no {{VerifyError}} is thrown.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
When variable is not initialized @CompileStatic can fail compilation,GROOVY-5535,12816326,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,20/Jun/12 03:43,21/Jun/12 17:03,14/Jul/23 06:00,20/Jun/12 10:10,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static compilation,,,,0,,,,,,"The following code:

{code}
import groovy.transform.*

@CompileStatic
URL getDescriptorForPlugin(File pluginDir) {
    URL descriptor = null
    File baseFile = pluginDir.canonicalFile
    File basePluginFile = (File)baseFile.listFiles().find {  File it -> it.name.endsWith(""GrailsPlugin.groovy"")}

    if (basePluginFile?.exists()) {
         descriptor = null
    }
    return descriptor
}
{code}

Fails with an error:

{code}

[Static type checking] - Cannot return value of type java.lang.Object on method returning type java.net.URL -> java.net.URL
 at line: 12, column: 12
{code}

Initializing to null shouldn't cause this problem",,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 20 09:58:50 UTC 2012,,,,,,,,,,"0|i2cttr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jun/12 09:58;melix;Problem arises if you assign {{null}} inside an {{if}} statement:
{code}
URL getDescriptorForPlugin() {
    URL descriptor = null
    if (true) {
         descriptor = null
    }
    return descriptor
}
{code}
produces the same error. Remove the {{if}} and it's perfectly fine.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static Compilation: Groovy @CompileStatic doesn't support safe dereference,GROOVY-5534,12816253,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,graemerocher,graemerocher,20/Jun/12 03:26,21/Jun/12 17:03,14/Jul/23 06:00,20/Jun/12 06:35,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static compilation,,,,0,,,,,,"Following code:

{code}
import groovy.transform.*

@CompileStatic
def foo() {
   File bar
   println bar?.name
} 

foo()
{code}

Produces a NPE",,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 20 06:35:02 UTC 2012,,,,,,,,,,"0|i2c5on:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jun/12 04:17;graemerocher;I'm raising this one to critical, I think as a minimum there should be a compilation error or warning if safe dereference is not going to be supported;;;","20/Jun/12 04:45;melix;This is critical, it should be supported.;;;","20/Jun/12 06:35;melix;Fixed. Note that the problem only occurred with the ""property as getter"" notation.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compiler doesn't write valid bytecode for list.property,GROOVY-5533,12816240,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,19/Jun/12 16:05,21/Jun/12 17:03,14/Jul/23 06:00,19/Jun/12 16:24,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static compilation,,,,0,,,,,,"Given the following code:
{code}
class Elem { int value }
List<Elem> list = new LinkedList<Elem>()
list.add(new Elem(value:123))
list.add(new Elem(value:456))
assert list.value == [ 123, 456 ]
{code}

The static compiler doesn't produce bytecode for the {{list.value}} call.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-19 16:05:14.0,,,,,,,,,,"0|i2c31j:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compilation complains when accessing a property with a property notation inside a named arg ctor inside a closure inside a @CompileStatic class,GROOVY-5532,12812139,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,19/Jun/12 13:37,21/Jun/12 17:03,14/Jul/23 06:00,20/Jun/12 04:44,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static Type Checker,,,,0,,,,,,"Similarly to GROOVY-5531, I'm facing another problem with the same sample.
Static type checking the class is fine, but I get a compilation error coming from StaticTypesCallSiteWriter#makeGetPropertySite() when trying to access the closure's parameter property.

The offending sample:
{code}
import groovy.transform.CompileStatic

class User {
    String login
}

interface Row<R> {
    R getKey()
}

class RowImpl<R> implements Row<R> {
    R getKey() { null }
}

@CompileStatic
class UserRepository implements Serializable {
    Collection<User> getUsers() {
        def rows = [new RowImpl<String>()]

        return rows.collect { Row<String> row ->
            new User(login: row.key)
        }
    }
}

def rep = new UserRepository()
rep.getUsers()
{code}

Error I get:
{code}
Access to java.lang.Object#key is forbidden at line: 21, column: 29
{code}",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5531,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-19 13:37:20.0,,,,,,,,,,"0|i2cmdz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem accessing closure parameter inside named arg constructor values inside a closure in a @CompileStatic class,GROOVY-5531,12813341,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,19/Jun/12 13:30,21/Jun/12 17:03,14/Jul/23 06:00,20/Jun/12 04:44,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static compilation,,,,0,,,,,,"The following example passes static type checking fine.
But at runtime, the generated bytecode seems to have some issue, as I get:
{code}
groovy.lang.MissingPropertyException: No such property: row for class: UserRepository
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:50)
	at UserRepository$getUsers.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at ConsoleScript20.run(ConsoleScript20:27)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:257)
	at groovy.lang.GroovyShell.run(GroovyShell.java:481)
	at groovy.lang.GroovyShell.run(GroovyShell.java:163)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:931)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:404)
	at groovy.lang.Closure.run(Closure.java:488)
	at java.lang.Thread.run(Thread.java:680)
{code}

Here's the offending class:
{code}
import groovy.transform.CompileStatic

class User {
    String login
}

interface Row<R> {
    R getKey()
}

class RowImpl<R> implements Row<R> {
    R getKey() { null }
}

@CompileStatic
class UserRepository implements Serializable {
    Collection<User> getUsers() {
        def rows = [new RowImpl<String>()]

        return rows.collect { Row<String> row ->
            new User(login: row.getKey())
        }
    }
}

def rep = new UserRepository()
rep.getUsers()
{code}",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5532,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 19 13:38:12 UTC 2012,,,,,,,,,,"0|i2c17r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jun/12 13:38;guillaume;Both issues are related and are using the same base example, with one variant.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
No compilation error for GString values in named parameter consturctors for String fields,GROOVY-5530,12816297,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,19/Jun/12 12:47,21/Jun/12 17:03,14/Jul/23 06:00,20/Jun/12 09:37,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static Type Checker,,,,0,,,,,,"The static type checker currently complains about constructors taking named parameters when a value is a GString for a field which is a String. It should coerce transparently.

Here's an example showing the problem:
{code}
import groovy.transform.CompileStatic

class User {
    String login
    String username
    String domain
    String firstName
    String lastName
}

@CompileStatic
class UserNamedParameterIssueWithStaticCompilation {
    List<User> getUsers() {
        [1, 2, 3].collect { Number num ->
             new User(
                    login:      ""login$num"",
                    username:   ""username$num"",
                    domain:     ""domain$num"",
                    firstName:  ""first$num"",
                    lastName:   ""last$num""
            )
        }
    }
}

def service = new UserNamedParameterIssueWithStaticCompilation()
service.getUsers()
{code}",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-19 12:47:40.0,,,,,,,,,,"0|i2bw9r:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closure not statically compiled and owner access issue,GROOVY-5529,12816279,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,19/Jun/12 09:24,21/Jun/12 17:03,14/Jul/23 06:00,19/Jun/12 16:25,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static compilation,,,,0,,,,,,"{code}
import groovy.transform.CompileStatic

interface Row {
    int getKey()
}

class RowImpl implements Row {
    int getKey() { 1 }
}

@CompileStatic
def test() {
    def rows = [new RowImpl(), new RowImpl(), new RowImpl()]
    
    rows.each { Row row ->
        println row.key
    }
}

test()
{code}
When executing the above script, with the statically compiled test() method, I get an exception saying that the owner property could not be found:
{code}
groovy.lang.MissingPropertyException: No such property: owner for class: ConsoleScript47
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:50)
	at org.codehaus.groovy.runtime.callsite.PogoGetPropertySite.getProperty(PogoGetPropertySite.java:49)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGroovyObjectGetProperty(AbstractCallSite.java:231)
	at ConsoleScript47$_test_closure1.doCall(ConsoleScript47:19)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:423)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1323)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1295)
	at ConsoleScript47.test(ConsoleScript47:17)
{code}
Furthermore, if you look closely at the stacktrace, it seems strange to see some call sites appearing, as if the closure wasn't compiled statically.",,guillaume,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 19 09:31:57 UTC 2012,,,,,,,,,,"0|i2cqnr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jun/12 09:31;guillaume;Removing the println make it work.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
wrong generics check for classes extending another class and giving through the generics parameter,GROOVY-5528,12816313,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,blackdrag,blackdrag,19/Jun/12 06:43,21/Jun/12 17:03,14/Jul/23 06:00,19/Jun/12 09:39,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static Type Checker,,,,0,,,,,,"This fails to compile, while it should:
{code:Java}
class MyList<T> extends LinkedList<T> {}
@groovy.transform.CompileStatic
def foo() {
	List<String> list = new MyList<String>()
}
{code}
",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-19 06:43:19.0,,,,,,,,,,"0|i2cpbr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError using @CompileStatic and assertEquals,GROOVY-5526,12816312,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,18/Jun/12 09:21,21/Jun/12 17:03,14/Jul/23 06:00,19/Jun/12 03:44,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,,,,,0,,,,,,"The following code produces a VerifyError:

{code}

import static org.junit.Assert.*;
import groovy.transform.CompileStatic;

@CompileStatic
class CompilerBugs {

  public static void main(String[] args) {
    int expected = 0
    assertEquals(expected, args.length)
  }

}
{code}

Bytecode shows that the selected method is incorrect:

{code}
public static void main(java.lang.String[]);
  Code:
   0:   iconst_0
   1:   istore_1
   2:   iload_1
   3:   pop
   4:   iload_1
   5:   invokestatic    #41; //Method
java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
   8:   ldc     #43; //class ""[Ljava/lang/Object;""
   10:  invokestatic    #49; //Method
org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType:(Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;
   13:  checkcast       #43; //class ""[Ljava/lang/Object;""
   16:  iconst_1
   17:  anewarray       #4; //class java/lang/Object
   20:  dup
   21:  iconst_0
   22:  aload_0
   23:  arraylength
   24:  aastore
   25:  invokestatic    #55; //Method
org/junit/Assert.assertEquals:([Ljava/lang/Object;[Ljava/lang/Object;)V
   28:  aconst_null
   29:  pop
   30:  return
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-18 09:21:57.0,,,,,,,,,,"0|i2cfm7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker doesn't find a method defined in Arrays,GROOVY-5525,12816311,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,18/Jun/12 09:20,21/Jun/12 17:03,14/Jul/23 06:00,18/Jun/12 12:23,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,,,,,0,,,,,,"The following code produces a type checking error:

{code}

import groovy.transform.TypeChecked
import java.util.Arrays

@TypeChecked
class ArrayCopying {

    public static void main(String[] args) {
        def acopy = Arrays.copyOf(args, 1)
    }

}
{code}

Error:
{{Cannot find matching
method java.lang.Class#copyOf([Ljava.lang.String;, int)}}

The type checker doesn't seem to be aware that copyOf is defined on {{Arrays}}.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-18 09:20:02.0,,,,,,,,,,"0|i2ctlj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
rcurry fails using with closures and default parameters,GROOVY-5524,12816325,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,guindous,guindous,18/Jun/12 06:39,01/Jan/15 09:58,14/Jul/23 06:00,01/Jan/15 09:58,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,groovy-jdk,,,,0,,,,,,"Next code fails (ArrayOutOfBoundException):

{code}
def log = {String msg, arg0 = null, arg1 = null, String level ->
    println ""Doing $level $msg $arg0 $arg1""
}

def trace = log.rcurry('TRACE')

trace('Trace world')
{code}

If I change parameters order (using ""level"" as first parameter) and use curry instead of rcurry this example works.",,guindous,pschumacher,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 01 09:58:38 UTC 2015,,,,,,,,,,"0|i2bzef:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jan/15 09:58;pschumacher;Thanks for reporting. The example works when using groovy-2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static Type Checker: Ternary operator doesn't allow nulls,GROOVY-5523,12816310,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,14/Jun/12 09:31,21/Jun/12 17:03,14/Jul/23 06:00,18/Jun/12 05:20,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,,,,,0,,,,,,"Following code:

{code}
import groovy.transform.CompileStatic
@CompileStatic
File findFile() {
    String str = """"
    File f = str ? new File(str) : null
}
{code}

Produces:

{code}
[Static type checking] - Cannot assign value of type java.lang.Object to variable of type java.io.File
 at line: 8, column: 5
{code}",,graemerocher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-14 09:31:11.0,,,,,,,,,,"0|i2cg2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Add array DGM variants for find and findAll to assist Static Type Checker,GROOVY-5522,12811814,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,graemerocher,graemerocher,14/Jun/12 09:25,21/Jun/12 17:03,14/Jul/23 06:00,19/Jun/12 08:05,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static Type Checker,,,,0,,,,,,"Following code:

{code}
import groovy.transform.CompileStatic

@CompileStatic
File findFile() {
    new File(""user.home"").listFiles().find { File f -> f.hidden } 
}
{code}

Produces

{code}

[Static type checking] - Cannot return value of type java.lang.Object on method returning type java.io.File -> java.io.File
 at line: 7, column: 5
{code}

Since listFiles() returns a File[] I would expect the call to find { } to infer the type",,graemerocher,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 19 07:50:58 UTC 2012,,,,,,,,,,"0|i2br07:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jun/12 07:51;paulk;There is a limitation with the current DGM methods here but it isn't really a static type checker issue.

Currently we have a {{find}} DGM method for {{Collection<T>}} and {{Object}} but not {{T[]}} so in your example it falls back onto the {{Object}} version - so the type checker is in fact doing the right thing here. If we add a {{T[]}} version your example will work - and it makes sense to do that - alternatively, you can add a {{toList()}} as a workaround.

So I suggest this issue changes to adding the {{T[]}} variant for find? Does that sound OK?;;;","18/Jun/12 08:02;melix;Yes, adding a {{T[]}} variant sounds right to me.;;;","18/Jun/12 19:14;paulk;updating summary to reflect recent discussion;;;","18/Jun/12 19:48;paulk;added to master;;;","18/Jun/12 23:00;paulk;I added array versions for find and findAll and array and collection versions for grep. I didn't try to play with the String-related findXXX methods nor grep for things like Map. I think the demand for these would be rarer and {{toList()}} would be your friend in those cases.;;;","19/Jun/12 07:50;melix;Reassign to me as there is still a method selection issue if the variants are added.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static Type Checker: Type not inferred from maps with generics,GROOVY-5521,12816333,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,14/Jun/12 09:08,21/Jun/12 17:03,14/Jul/23 06:00,18/Jun/12 08:10,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static Type Checker,,,,0,,,,,,"Following code:
{code}
@GrabResolver('http://repo.grails.org/grails/core')
@Grab(group='org.grails', module='grails-bootstrap', version='2.0.4')
import org.codehaus.groovy.grails.plugins.*
import groovy.transform.CompileStatic



@CompileStatic
GrailsPluginInfo getPluginName(String pluginName) {
    Map<String, GrailsPluginInfo> pluginInfosMap = new HashMap<String, GrailsPluginInfo>()
    return pluginInfosMap[pluginName]
}
{code}

Produces:

{code}


[Static type checking] - Cannot return value of type java.lang.Object on method returning type org.codehaus.groovy.grails.plugins.GrailsPluginInfo -> org.codehaus.groovy.grails.plugins.GrailsPluginInfo
 at line: 11, column: 12
{code}",,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 18 07:45:47 UTC 2012,,,,,,,,,,"0|i2c713:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jun/12 07:45;melix;As a workaround, you can use the {{get}} method instead of the square brackets:

{code}
return pluginInfosMap.get(pluginName) // works fine
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static Type Checker: Cannot check for null against a Java interface ,GROOVY-5520,12816328,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,14/Jun/12 09:00,21/Jun/12 17:03,14/Jul/23 06:00,18/Jun/12 04:32,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static Type Checker,,,,0,,,,,,"Following code:

{code}
@GrabResolver('http://repo.grails.org/grails/core')
@Grab(group='org.grails', module='grails-bootstrap', version='2.0.4')
import org.codehaus.groovy.grails.plugins.*
import groovy.transform.CompileStatic

@CompileStatic
def foo() {
   GrailsPluginInfo gpi = null
   
   if(gpi != null) {
       println ""good""
   }
}
{code}

Results in 

{code}

[Static type checking] - Cannot find matching method org.codehaus.groovy.grails.plugins.GrailsPluginInfo#equals(<unknown parameter type>)
 at line: 10, column: 7
{code}",,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 14 09:25:37 UTC 2012,,,,,,,,,,"0|i2cinj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Jun/12 09:25;melix;A minimal example reproducing the problem:
{code}
@groovy.transform.TypeChecked
def foo() {
   Serializable gpi = null
   
   if(gpi != null) {
       println ""good""
   }
}
{code}

Basically, it will fail for every interface which doesn't define the {{equals}} method by itself.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static Type Checker: Exception type not inferred for catch blocks,GROOVY-5519,12811806,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,14/Jun/12 08:22,21/Jun/12 17:03,14/Jul/23 06:00,18/Jun/12 07:25,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,Static Type Checker,,,,0,,,,,,"The following code:

{code}
import groovy.transform.CompileStatic

@CompileStatic
File foo() {
   try {
   
   } catch(e) {
       handleError(e)
   }
}

def handleError(Throwable e) {
  println e.message
}
{code}

Fails to compile with:

{code}

[Static type checking] - Cannot find matching method ConsoleScript2#handleError(java.lang.Object)
 at line: 8, column: 8
{code}",,graemerocher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-14 08:22:05.0,,,,,,,,,,"0|i2bzon:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type inference doesn't work with a Java class and a static property,GROOVY-5517,12816296,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,14/Jun/12 07:58,11/Sep/22 14:10,14/Jul/23 06:00,19/Jun/12 07:22,2.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,,,,,0,,,,,,"Example:

{code}

@Grab(group='org.grails', module='grails-bootstrap', version='2.0.4')
import grails.util.Metadata
import groovy.transform.CompileStatic

@CompileStatic
def foo() {
   Metadata m = Metadata.current
}
{code}

Results in:

{code}
[Static type checking] - Cannot assign value of type java.lang.Object to variable of type grails.util.Metadata
 at line: 7, column: 4
{code}

The class Metadata has a Java static method that looks roughly like:

{code}
public static Metadata getCurrent() { ... }
{code}",,graemerocher,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10540,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 14 09:28:11 UTC 2012,,,,,,,,,,"0|i2caaf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Jun/12 09:28;melix;The problem is related to the fact that {{Metadata}} implements {{Map}} so the type checker believes we call {Metadata.get('current')}. Obviously, in that particular case, it should not think so because it's a static property.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker fails verification of generic types with addAll,GROOVY-5516,12816285,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,14/Jun/12 03:50,15/Jun/12 22:56,14/Jul/23 06:00,14/Jun/12 04:07,2.0-rc-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-3,,,Static Type Checker,,,,0,,,,,,"The following code produces an error:
{code}
List<String> list = ['a','b','c']
Collection<String> e = list.findAll { it }
list.addAll(e)
{code}
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-14 03:50:30.0,,,,,,,,,,"0|i2cu0v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[NPE] Creating a range in an inner class using @CompileStatic,GROOVY-5512,12816316,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,13/Jun/12 02:28,15/Jun/12 22:56,14/Jul/23 06:00,13/Jun/12 02:37,2.0-rc-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-3,,,Compiler,,,,0,,,,,,"The following code causes an NPE during compilation, with 2.0.0-rc-2:

{code}
class Outer {
                static class Inner {
                    @groovy.transform.CompileStatic
                    int m() {
                        int x = 0
                        for (int i in 1..10) {x++}
                        x
                    }
                }
            }
{code}",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-13 02:28:03.0,,,,,,,,,,"0|i2c8xr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Verifier fails to check property types with covariant override,GROOVY-5508,12816298,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,aalmiray,aalmiray,08/Jun/12 02:28,26/Jul/12 16:49,14/Jul/23 06:00,22/Jun/12 14:47,1.8.6,2.0-rc-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0.1,,Compiler,,,,0,,,,,,"The following code Does not throw an compiler exception

{code:java}
interface Addon {
   Map getFactories()
}

class AddonImpl implements Addon {
    Map factories
}

class SubAddon extends AddonImpl {
    def factories = [a:1]
}
{code}

whereas the method call will output the correct compiler error

{code:java}
interface Addon {
   Map getFactories()
}

class AddonImpl implements Addon {
    Map getFactories() { [:] }
}

class SubAddon extends AddonImpl {
    def getFactories() { [:] }
}
{code}

the error being

{code}
The return type of java.lang.Object getFactories() in SubAddon is incompatible with java.util.Map getFactories() in AddonImpl
{code}
",,aalmiray,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 22 14:47:41 UTC 2012,,,,,,,,,,"0|i2c50v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Jun/12 08:19;blackdrag;fix: https://github.com/groovy/groovy-core/pull/52;;;","22/Jun/12 14:47;blackdrag;should be fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
rcurry for overloaded MethodClosure throws an exception,GROOVY-5507,12816308,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,zhaber,zhaber,07/Jun/12 15:59,15/Jun/12 22:56,14/Jul/23 06:00,10/Jun/12 16:56,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-rc-3,,,,,,0,,,,,,"def a(b,c){}
def a(b,c,d){}
b = (this.&a).rcurry(0) 
b(1,2) // works
b(1) // throws ArrayIndexOutOfBoundsException",,paulk,russel,zhaber,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 10 16:56:42 UTC 2012,,,,,,,,,,"0|i2c45j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jun/12 01:14;paulk;An expanded version of the above example:
{code}
def a(Integer b, Integer c, Integer d){ ""3Int: $b $c $d"" }
def a(b,c,d){ ""3Obj: $b $c $d"" }
def a(b,c){ ""2Obj: $b $c"" }
def b = (this.&a).rcurry(0)
def c = (this.&a).curry(0)
assert c(1,2) == '3Int: 0 1 2'
assert c(""foo"",2) == '3Obj: 0 foo 2'
assert c(1) == '2Obj: 0 1'
assert b(1,2) == '3Int: 1 2 0'
assert b(""foo"",2) == '3Obj: foo 2 0'
assert b(1) == '2Obj: 1 0'
// throws java.lang.ArrayIndexOutOfBoundsException
//    at java.lang.System.arraycopy(Native Method)
//    at org.codehaus.groovy.runtime.CurriedClosure.getUncurriedArguments(CurriedClosure.java:104)
{code}
There are some different assumptions between the logic for working out the maximum number of parameters in a method closure and the right currying logic. The AIOBE shouldn't be thrown as illustrated by the curry case. The implementation though isn't perfectly symmetrical unfortunately so we might have to handle this as a special case.;;;","10/Jun/12 16:56;paulk;should be fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyBugError thrown when it shouldn't be,GROOVY-5500,12816264,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,werdna,werdna,05/Jun/12 16:14,15/Jun/12 22:56,14/Jul/23 06:00,10/Jun/12 16:58,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-rc-3,,,,,,0,,,,,,"The following code throws a {{GroovyBugError}}:
{code}
print ""Foo"" ===~ "".*""
{code}
but this seems wrong to me.  A {{GroovyBugError}}, as I understand it, is supposed to be only thrown for internal compiler errors, meaning that there is a bug in the compiler.  This seems to me to be a candidate for a {{SyntaxError}}.

It seems that there is a simple fix. In the default block of {{org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpression)}}, change {{throws new GroovyBugError(..)}} to {{throws new SyntaxException(..)}}.

I only tried this on Groovy 2.0.0 beta 3 and Groovy 1.8.6.  ",,blackdrag,paulk,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 10 16:58:02 UTC 2012,,,,,,,,,,"0|i2ca8f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jun/12 16:15;werdna;Originally reported in GRECLIPSE-1420.;;;","05/Jun/12 17:29;paulk;Well, I guess there are several ways to make the problem go away. Firstly, the tilde isn't needed so either of these will also reproduce the problem:
{code}
print ""Foo"" === "".*""
print ""Foo"" !== "".*""
{code}
Both {{COMPARE_IDENTICAL}} and {{COMPARE_NOT_IDENTICAL}} were added as a hack for the benefit of Groovy++ but the code in BEH.eval assumes that all operators are covered within switch branches and the code wasn't updated when the hack was added. So we could consider using {{SyntaxException}} but it might be nicer to either drop support for those two operators or add proper support in. As an interim measure, we should at least add branches for those two cases - which could just throw the {{SyntaxException}} for now.;;;","05/Jun/12 17:47;paulk;Proposed interim patch:
{code}
@@ -241,6 +244,12 @@ public class BinaryExpressionHelper {
             evaluateCompareExpression(isCaseMethod, expression);
             break;

+        case COMPARE_IDENTICAL:
+        case COMPARE_NOT_IDENTICAL:
+            Token op = expression.getOperation();
+            Throwable cause = new SyntaxException(""Operator "" + op + "" not supported"", op.getStartLine(), op.getStartColumn());
+            throw new GroovyRuntimeException(cause);
+
         default:
             throw new GroovyBugError(""Operation: "" + expression.getOperation() + "" not supported"");
         }
{code}
For the folks in CPH, perhaps the longer term solution can be discussed at the GDC if you read this before you are finished?

I also wonder whether the {{RuntimeException}} throw in {{evaluateInstanceOf}} should also be a wrapped {{SyntaxException}} for consistency? However, I am not sure the grammar even allows this case any longer.;;;","05/Jun/12 22:15;werdna;This looks fine to me.  The situation in Groovy-Eclipse is workable now and it isn't relying on a fix in groovy-oore (although having one would be nice). Groovy-Eclipse now simply catches the GroovyBugError and adds it as a compiler warning as well as logging it appropriately.  Much better, of course, would be if GBErrors aren't thrown unless there really is an internal compiler error.

Thanks for the quick turn around on this!;;;","06/Jun/12 06:26;blackdrag;Andrew, this is an internal bug, thus the GroovyBugError is the right thing. It showed us the lacking implementation and this fix is the right reaction to it ;) Whenever a GroovyBugError appears, there is something to be fixed.;;;","06/Jun/12 18:12;paulk;Interim patch added to master.;;;","09/Jun/12 06:04;blackdrag;I think we should add it to 1.8 as well;;;","10/Jun/12 16:58;paulk;proposed interim patch applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type check reports an error when accessing some property,GROOVY-5498,12816315,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ariel.andres.morelli,ariel.andres.morelli,05/Jun/12 13:19,15/Jun/12 22:56,14/Jul/23 06:00,11/Jun/12 07:07,2.0-rc-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-3,,,Static Type Checker,,,,1,,,,,,"{code}
@groovy.transform.CompileStatic
class Test {
 
  List getListVar() {
    new ArrayList()
  }
 
  void someMethod() {
     def t = new Object()
     t = this
     
     t.getListVar()     //No error here
     t.listVar          //error is being reported here
  } 
}
{code}


1 compilation error:

Access to java.lang.Object#listVar is forbidden at line: 13, column: 6
",,ariel.andres.morelli,ebergama,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 05 13:21:20 UTC 2012,,,,,,,,,,"0|i2buzb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jun/12 13:21;ariel.andres.morelli;In this case, an error is being reported when accessing
{code}
t.listVar
{code}

If the variable ""t"" is initialized directly to ""this"", the issue does not occur.
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Returning ""null"" in a function reports an invalid type checking error",GROOVY-5497,12816322,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ariel.andres.morelli,ariel.andres.morelli,05/Jun/12 13:14,15/Jun/12 22:56,14/Jul/23 06:00,11/Jun/12 04:35,2.0-rc-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-3,,,Static Type Checker,,,,0,,,,,,"The following code is valid, but it reports some compilation errors:

{code}
@groovy.transform.CompileStatic
class Test {
 
  List getList() {
    null
  }
  
}
{code}


1 compilation error:

[Static type checking] - Cannot return value of type java.lang.Object on method returning type java.util.List -> java.util.List <E extends java.lang.Object -> java.lang.Object>
 at line: 5, column: 5
",,ariel.andres.morelli,ebergama,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-05 13:14:54.0,,,,,,,,,,"0|i2cmyv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@TypeChecked and @CompileStatic is not aware of interfaces hierarchy,GROOVY-5495,12818162,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,filus,filus,05/Jun/12 09:24,15/Jun/12 22:56,14/Jul/23 06:00,10/Jun/12 10:30,2.0-rc-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-3,,,,,,,0,,,,,,"@TypeChecked and @CompileStatic doesn't compile code which use interface hierarchy. It only checks methods defined in used interface, not inherited from ancestors.

Example:
{code:java}
import groovy.transform.TypeChecked

class ClassUnderTest {

    @TypeChecked
    void methodFromString(SecondInterface si) {
        si.methodFromSecondInterface();
        si.methodFromFirstInterface();
    }
}

interface FirstInterface {
    void methodFromFirstInterface();
}

interface SecondInterface extends FirstInterface {
    void methodFromSecondInterface();
}
{code}

Compiler throws an error:
bq. [Static type checking] - Cannot find matching method SecondInterface#methodFromFirstInterface()

For class hierarchy it works and code below compiles:
{code:java}
import groovy.transform.TypeChecked

class ClassUnderTest {

    @TypeChecked
    void methodFromString(SecondInterface si) {
        si.methodFromSecondInterface();
        si.methodFromFirstInterface();
    }
}

class FirstInterface {
    void methodFromFirstInterface() { };
}

class SecondInterface extends FirstInterface {
    void methodFromSecondInterface() { };
}
{code}
",,filus,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-05 09:24:55.0,,,,,,,,,,"0|i2clrj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonOutput.toJson(def) fails with MissingMethodException if the object defines getProperties(),GROOVY-5494,12816275,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,sukhyun.cho,sukhyun.cho,04/Jun/12 15:15,21/Jan/13 04:36,14/Jul/23 06:00,21/Jan/13 04:36,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,,,JSON,,,,0,,,,,,"If an object defines {{getProperties()}}, {{JsonOutput.toJson(def)}} fails with the following:

{noformat}
groovy.lang.MissingMethodException: No signature of method: com.foo.FileProperties.remove() is applicable for argument types: (java.lang.String) values: [class]
Possible solutions: getAt(java.lang.String)
...
	at groovy.json.JsonOutput.toJson(JsonOutput.groovy:131)
...
{noformat}

Repro:

{noformat}
class MyClass { String properties }
groovy.json.JsonOutput.toJson(new MyClass(properties: 'properties'))
{noformat}",,blackdrag,paulk,pschumacher,sukhyun.cho,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 21 04:36:36 UTC 2013,,,,,,,,,,"0|i2cfon:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"05/Jun/12 17:26;sukhyun.cho;Changing {{def properties = object.properties}} to {{def properties = DefaultGroovyMethods.getProperties(object)}} fixes this.;;;","01/Jul/12 03:23;sukhyun.cho;Note that an object declaring {{properties}} field or {{getProperties()}} method of (return) type {{Map}} will result in an incorrect result (namely, the {{toJson()}} result of the object's declared {{properties/getProperties()}}, rather than the entire object).

Commit [17ea853|https://github.com/choey/groovy-core/commit/17ea8538764e3811ba3fbf8b9cb89d30f34e1116] unit-tests and fixes this. There is also a [pull request|https://github.com/groovy/groovy-core/pull/56] for this in the {{GROOVY_1_8_X}} branch.;;;","10/Nov/12 08:53;pschumacher;The pull request [https://github.com/groovy/groovy-core/pull/56] was merged and closed, so I guess this issue can be closed too.;;;","10/Nov/12 13:07;blackdrag;Guillaume, it seems you merged the request, 4 months ago already and forgot to close that. Since I don't know the fix versions I will not close it for you, can you please?;;;","21/Jan/13 04:36;paulk;updated fix version and closed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
HashMap subclass property access inconsistent,GROOVY-5491,12815696,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,mrfritz379,mrfritz379,04/Jun/12 13:16,25/Jan/22 18:21,14/Jul/23 06:00,25/Jan/22 18:21,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,5.0.0-alpha-1,,,groovy-runtime,,,,0,,,,,,"Creating a subclass of java.util.HashMap with properties defined results in inconsistent and confusing behavior. 
{code:java}
class MapSub extends HashMap {
  def foo
  
}

// Using dot notation to get the property results in a map key lookup.
def m = new MapSub(foo: 'bar')
println m.foo    // prints 'null'
println m.getFoo() // prints 'bar'

// Using same dot notation to set the property results in property setter.
m.foo = 'baz'
println m.foo // still prints 'null'
println m.getFoo() // prints 'baz'
{code}
This behavior results in subtle and hard to track bugs. I saw another Jira that stated that a design decision was made that Map dot property getters always resulted in a map key lookup. For consistency, I think either the same policy should be applied to Map property setters or the original design decision should be reconsidered to first check for property existence.
",,emilles,mrfritz379,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5001,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 25 18:21:24 UTC 2022,,,,,,,,,,"0|i2buef:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Jan/22 15:20;emilles;MetaClassImpl performs this just after static handling for getProperty:
{code:java}
        //----------------------------------------------------------------------
        // turn getProperty on a Map to get on the Map itself
        //----------------------------------------------------------------------
        if (!isStatic && this.isMap) {
            return ((Map) object).get(name);
        }
{code}

setProperty does this near the end:
{code:java}
        //----------------------------------------------------------------------
        // turn setProperty on a Map to put on the Map itself
        //----------------------------------------------------------------------
        if (method == null && !isStatic && this.isMap) {
            ((Map) object).put(name, newValue);
            return;
        }
{code};;;","07/Jan/22 15:22;emilles;[~paulk]  I'd expect get and set to be aligned.  In light of this and GROOVY-5001, would you expect Map#get to have lower precedence or Map#put to have higher precedence?;;;","07/Jan/22 20:45;emilles;https://github.com/apache/groovy/pull/1674;;;","25/Jan/22 18:21;emilles;https://github.com/apache/groovy/commit/051d3cf3ef29a521137b9d6b71cb8097d077d46b;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy-all pom doesn't include modules dependencies,GROOVY-5488,12816283,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,01/Jun/12 10:55,15/Jun/12 22:56,14/Jul/23 06:00,01/Jun/12 15:55,2.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-2,,,,,,,0,,,,,,"The generated {{groovy-all}} pom should add dependencies from modules, but it doesn't.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-01 10:55:11.0,,,,,,,,,,"0|i2ckzj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
jarjar task in Gradle doesn't exclude some classes,GROOVY-5487,12812124,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,01/Jun/12 06:35,15/Jun/12 22:56,14/Jul/23 06:00,01/Jun/12 15:54,2.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-2,,,,,,,0,,,,,,"After switching to Gradle, some classes that were previously excluded are no longer excluded, which causes a problem to existing framework relying on the normal path of classes.
",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-01 06:35:39.0,,,,,,,,,,"0|i2ceav:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Distribution misses some dependencies,GROOVY-5486,12812127,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,melix,melix,01/Jun/12 06:34,15/Jun/12 22:56,14/Jul/23 06:00,01/Jun/12 15:54,2.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-2,,,,,,,0,,,,,,"The distribution misses several jars that were bundled in the distribution before:

* ant-antlr
* ant-junit
* ant-launcher
* bsf
* commons-logging
* hamcrest-core
* jsp-api
* junit
* servlet-api

",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-06-01 06:34:33.0,,,,,,,,,,"0|i2c4gf:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type inference on lists,GROOVY-5482,12812118,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,rgarcia,rgarcia,31/May/12 05:46,15/Jun/12 22:56,14/Jul/23 06:00,12/Jun/12 12:35,2.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-3,,,Static Type Checker,,,,0,,,,,,"{code}
@TypeChecked
class StaticGroovy2 {

    def bar() {

        def foo = [new Date(), 1, new C()]
        foo.add( 2 ) // Compiles
        foo.add( new Date() )
        foo.add( new C() )

        foo = [new Date(), 1]
        foo.add( 2 ) // Does not compile
    }
}
class C{
}
{code}

This code fails to compile on the last line foo.add(2) with the error:
Groovy:[Static type checking] - Cannot find matching method
java.util.List#add(int)    ",,melix,rgarcia,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 11 07:19:44 UTC 2012,,,,,,,,,,"0|i2c2xj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jun/12 07:19;melix;Just to amend the description, there are two issues in one, here:

Using

{code}
def foo = [new Date(), 1]
foo.add( 2 )
{code}

we shouldn't throw any error. Second, this should throw an error, according to our flow typing implementation:

{code}
def foo = [new Date()]
foo.add(1)
{code}

as well as
{code}
def foo = [1]
foo = [new Date()]
foo.add(1)
{code}

So basically, there's only one problem to be fixed here, which is the error with the type inference engine not recognizing that an integer may be added to the list.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@TypeChecked type inference does not work with closure,GROOVY-5480,12816280,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,rgarcia,rgarcia,31/May/12 04:05,07/Aug/13 12:23,14/Jul/23 06:00,12/Jun/12 08:25,2.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-3,,,Static Type Checker,,,,0,,,,,,"The following code when annotated with @TypeChecked:
{code}
List<Integer> foo = [1, 2, 3]
Integer bar = foo.find { it == 2 }
^
{code}
Will not compile with the error message:
Groovy:[Static type checking] - Cannot assign value of type java.lang.Object
to variable of type java.lang.Integer	 on the second line.",,cesarizu,melix,rgarcia,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 07 12:23:16 UTC 2013,,,,,,,,,,"0|i2bpfj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Jun/12 08:25;melix;The problem was that the {{find}} method is defined in {{DefaultGroovyMethods}} and makes use of a generic type. The type checker wasn't able to ""align"" generic types properly in that case.;;;","07/Aug/13 11:50;cesarizu;This is still happening:

{code:title=x.groovy}
@groovy.transform.TypeChecked
class x {
    static void main(String... args) {
        File.createTempFile(""abc"", ""abc"").withWriter {
            it.write(""test"");
        }
    }
}

{code} 

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/home/cesar/tmp/x.groovy: 5: [Static type checking] - Cannot find matching method java.lang.Object#write(java.lang.String). Please check if the declared type is right and if the method exists.
 @ line 5, column 5.
       it.write(""test"");
       ^

1 error
{code} ;;;","07/Aug/13 12:16;melix;@César, this is not a bug but a limitation, see GROOVY-5924 and related issues.;;;","07/Aug/13 12:23;cesarizu;Thanks a lot @Cedric, I'll check those issues.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
indy looses safe navigation flag,GROOVY-5479,12812090,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,29/May/12 13:27,29/May/12 14:11,14/Jul/23 06:00,29/May/12 14:11,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-1,,,,,,,0,indy,,,,,"for the following script:{code:Java}
class X {
    def value
}
def m(x) {
    x?.getValue()
}
def x = new X(value:1)
m(x)
m(null)
{code}
Indy fails to keep the safeNavigation flag and causes a NPE for the getValue() call on the m(null) invocation",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-05-29 13:27:27.0,,,,,,,,,,"0|i2crfj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy-all-2.0.0-beta-3-indy.jar invoke dynamic jar lacks osgi attributes,GROOVY-5474,12812088,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,bbrooks,bbrooks,25/May/12 09:49,10/Jul/13 04:42,14/Jul/23 06:00,04/Jul/13 10:34,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,,,,0,,,,,,"We would like to embed groovy into our OSGi-based server running on Java 7. However, as discussed on the groovy-2.0.0-beta-3 announcement thread

http://groovy.markmail.org/message/5t5hmvb36b3v5hl3

The 2.0.0 beta 3 lacks the OSGI MANIFEST.MF entries because 'bnd' doesn't
understand invokedynamic byte codes.",osgi,bbrooks,guillaume,melix,paulk,pschumacher,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 08 07:15:03 UTC 2013,,,,,,,,,,"0|i2c06n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/May/12 10:46;bbrooks;A more direct link to the 'bnd' post is http://groovy.markmail.org/message/gaudveiskkvcoplv;;;","25/May/12 12:41;bbrooks;Current root cause is the 'bnd' tool.  This ticket [1] has been opened against 'bnd' in hopes of a resolution.  If you're impacted by this issue, please comment on the 'bnd' ticket.

[1] https://github.com/bndtools/bnd/issues/179;;;","10/Jul/12 09:37;bbrooks;The MANIFEST.MF in groovy-all-2.0.0-indy.jar final release lacks OSGi entries (e.g. Import-Package , Export-Package, etc.).  Some OSGi MANIFEST.MF header development activity is happening here http://jira.codehaus.org/browse/GROOVY-5571 but Cédric Champeau clarified Arnaud's ticket (5571) will not add the OSGi manifest headers to the indy JARs.  That task will be tracked under this ticket.;;;","06/Sep/12 10:38;melix;Oops, didn't meant to close it!;;;","09/Oct/12 04:52;paulk;remove incorrect fix version of 2.0.1;;;","24/Dec/12 03:51;paulk;removed 2.x, assigning to 2.1.0-rc-1 for review - if not possible we should move to 3.x;;;","01/Apr/13 05:35;pschumacher;I tried to update bnd to 1.50.0 (the version used by Gradle 1.5). This version should contain the invoke dynamic fix, but I am still unable to build ""jarAllWithIndy"", dune to:

{code}
java.lang.ArrayIndexOutOfBoundsException: 15
        at aQute.lib.osgi.Clazz.parseClassFile(Clazz.java:448)
        at aQute.lib.osgi.Clazz.parseClassFile(Clazz.java:369)
        at aQute.lib.osgi.Clazz.parseClassFileWithCollector(Clazz.java:359)
        at aQute.lib.osgi.Clazz.parseClassFile(Clazz.java:349)
        at aQute.lib.osgi.Analyzer.analyzeJar(Analyzer.java:1725)
        at aQute.lib.osgi.Analyzer.analyzeBundleClasspath(Analyzer.java:1595)
        at aQute.lib.osgi.Analyzer.analyze(Analyzer.java:124)
        at aQute.lib.osgi.Analyzer.calcManifest(Analyzer.java:301)
        at org.gradle.api.internal.plugins.osgi.DefaultOsgiManifest.getEffectiveManifest(DefaultOsgiManifest.java:73)
        at org.gradle.api.internal.plugins.osgi.DefaultOsgiManifest_Decorated.getEffectiveManifest(Unknown Source)
        at org.gradle.api.java.archives.internal.DefaultManifest.writeTo(DefaultManifest.java:154)
        at org.gradle.api.java.archives.internal.DefaultManifest.writeTo(DefaultManifest.java:38)
        at org.gradle.api.java.archives.Manifest$writeTo.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
        at org.gradle.api.tasks.bundling.Jar$_closure1_closure3.doCall(Jar.groovy:48)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:877)
        at groovy.lang.Closure.call(Closure.java:412)
        at groovy.lang.Closure.call(Closure.java:425)
        at org.gradle.api.internal.file.collections.MapFileTree$FileVisitDetailsImpl.copyTo(MapFileTree.java:151)
        at org.gradle.api.internal.file.AbstractFileTreeElement.copyFile(AbstractFileTreeElement.java:88)
        at org.gradle.api.internal.file.AbstractFileTreeElement.copyTo(AbstractFileTreeElement.java:65)
        at org.gradle.api.internal.file.collections.MapFileTree$FileVisitDetailsImpl.getFile(MapFileTree.java:133)
        at org.gradle.api.internal.file.AbstractFileTree$1.visitFile(AbstractFileTree.java:39)
        at org.gradle.api.internal.file.AbstractFileTree$FilteredFileTree$1.visitFile(AbstractFileTree.java:145)
        at org.gradle.api.internal.file.collections.MapFileTree$Visit.visit(MapFileTree.java:103)
        at org.gradle.api.internal.file.collections.MapFileTree.visit(MapFileTree.java:70)
        at org.gradle.api.internal.file.collections.FileTreeAdapter.visit(FileTreeAdapter.java:96)
        at org.gradle.api.internal.file.AbstractFileTree$FilteredFileTree.visit(AbstractFileTree.java:136)
        at org.gradle.api.internal.file.AbstractFileTree.getFiles(AbstractFileTree.java:37)
        at org.gradle.api.internal.file.CompositeFileCollection.getFiles(CompositeFileCollection.java:39)
        at org.gradle.api.internal.file.AbstractFileCollection.iterator(AbstractFileCollection.java:60)
        at org.gradle.api.internal.changedetection.DefaultFileSnapshotter.snapshot(DefaultFileSnapshotter.java:42)
        at org.gradle.api.internal.changedetection.InputFilesChangedUpToDateRule.create(InputFilesChangedUpToDateRule.java:35)
        at org.gradle.api.internal.changedetection.CompositeUpToDateRule.create(CompositeUpToDateRule.java:35)
        at org.gradle.api.internal.changedetection.DefaultTaskArtifactStateRepository$HistoricExecution.calcCurrentState(DefaultTa
skArtifactStateRepository.java:80)
        at org.gradle.api.internal.changedetection.DefaultTaskArtifactStateRepository$HistoricExecution.isUpToDate(DefaultTaskArti
factStateRepository.java:88)
        at org.gradle.api.internal.changedetection.DefaultTaskArtifactStateRepository$TaskArtifactStateImpl.isUpToDate(DefaultTask
ArtifactStateRepository.java:128)
        at org.gradle.api.internal.changedetection.ShortCircuitTaskArtifactStateRepository$ShortCircuitArtifactState.isUpToDate(Sh
ortCircuitTaskArtifactStateRepository.java:77)
        at org.gradle.api.internal.changedetection.FileCacheBroadcastTaskArtifactStateRepository$1.isUpToDate(FileCacheBroadcastTa
skArtifactStateRepository.java:37)
        at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:44)
        at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:57)
        at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:
41)
        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:51)
        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:52)
        at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:42)
        at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:275)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.executeTask(DefaultTaskPlanExecutor.java:52)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.processTask(DefaultTaskPlanExecutor.java:38)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.process(DefaultTaskPlanExecutor.java:30)
        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:84)
        at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:29)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
        at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23)
        at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:67)
        at org.gradle.api.internal.changedetection.TaskCacheLockHandlingBuildExecuter$1.run(TaskCacheLockHandlingBuildExecuter.jav
a:31)
        at org.gradle.internal.Factories$1.create(Factories.java:22)
        at org.gradle.cache.internal.DefaultCacheAccess.useCache(DefaultCacheAccess.java:124)
        at org.gradle.cache.internal.DefaultCacheAccess.useCache(DefaultCacheAccess.java:112)
        at org.gradle.cache.internal.DefaultPersistentDirectoryStore.useCache(DefaultPersistentDirectoryStore.java:134)
        at org.gradle.api.internal.changedetection.DefaultTaskArtifactStateCacheAccess.useCache(DefaultTaskArtifactStateCacheAcces
s.java:79)
        at org.gradle.api.internal.changedetection.TaskCacheLockHandlingBuildExecuter.execute(TaskCacheLockHandlingBuildExecuter.j
ava:29)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
        at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23)
        at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:67)
        at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:54)
        at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:166)
        at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:113)
        at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:81)
        at org.gradle.api.tasks.GradleBuild.build(GradleBuild.java:112)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1047)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:877)
        at org.gradle.api.internal.BeanDynamicObject$MetaClassAdapter.invokeMethod(BeanDynamicObject.java:216)
        at org.gradle.api.internal.BeanDynamicObject.invokeMethod(BeanDynamicObject.java:122)
        at org.gradle.api.internal.CompositeDynamicObject.invokeMethod(CompositeDynamicObject.java:147)
        at org.gradle.api.tasks.GradleBuild_Decorated.invokeMethod(Unknown Source)
        at groovy.lang.GroovyObject$invokeMethod.call(Unknown Source)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
        at groovy.lang.GroovyObject$invokeMethod.call(Unknown Source)
        at org.gradle.util.ReflectionUtil.invoke(ReflectionUtil.groovy:23)
        at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$4.execute(AnnotationProcessingTaskFactory.j
ava:161)
        at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$4.execute(AnnotationProcessingTaskFactory.j
ava:156)
        at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:510)
        at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:499)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:64)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:49)
        at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.jav
a:34)
        at org.gradle.api.internal.changedetection.CacheLockHandlingTaskExecuter$1.run(CacheLockHandlingTaskExecuter.java:34)
        at org.gradle.internal.Factories$1.create(Factories.java:22)
        at org.gradle.cache.internal.DefaultCacheAccess.longRunningOperation(DefaultCacheAccess.java:179)
        at org.gradle.cache.internal.DefaultCacheAccess.longRunningOperation(DefaultCacheAccess.java:232)
        at org.gradle.cache.internal.DefaultPersistentDirectoryStore.longRunningOperation(DefaultPersistentDirectoryStore.java:142
)
        at org.gradle.api.internal.changedetection.DefaultTaskArtifactStateCacheAccess.longRunningOperation(DefaultTaskArtifactSta
teCacheAccess.java:83)
        at org.gradle.api.internal.changedetection.CacheLockHandlingTaskExecuter.execute(CacheLockHandlingTaskExecuter.java:32)
        at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:55)
        at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:57)
        at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:
41)
        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:51)
        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:52)
        at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:42)
        at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:275)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.executeTask(DefaultTaskPlanExecutor.java:52)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.processTask(DefaultTaskPlanExecutor.java:38)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.process(DefaultTaskPlanExecutor.java:30)
        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:84)
        at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:29)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
        at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23)
        at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:67)
        at org.gradle.api.internal.changedetection.TaskCacheLockHandlingBuildExecuter$1.run(TaskCacheLockHandlingBuildExecuter.jav
a:31)
        at org.gradle.internal.Factories$1.create(Factories.java:22)
        at org.gradle.cache.internal.DefaultCacheAccess.useCache(DefaultCacheAccess.java:124)
        at org.gradle.cache.internal.DefaultCacheAccess.useCache(DefaultCacheAccess.java:112)
        at org.gradle.cache.internal.DefaultPersistentDirectoryStore.useCache(DefaultPersistentDirectoryStore.java:134)
        at org.gradle.api.internal.changedetection.DefaultTaskArtifactStateCacheAccess.useCache(DefaultTaskArtifactStateCacheAcces
s.java:79)
        at org.gradle.api.internal.changedetection.TaskCacheLockHandlingBuildExecuter.execute(TaskCacheLockHandlingBuildExecuter.j
ava:29)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
        at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23)
        at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:67)
        at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:54)
        at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:166)
        at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:113)
        at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:81)
        at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:38)
        at org.gradle.launcher.exec.InProcessGradleLauncherActionExecuter.execute(InProcessGradleLauncherActionExecuter.java:39)
        at org.gradle.launcher.daemon.server.exec.ExecuteBuild.doBuild(ExecuteBuild.java:45)
        at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)
        at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
        at org.gradle.launcher.daemon.server.exec.WatchForDisconnection.execute(WatchForDisconnection.java:42)
        at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
        at org.gradle.launcher.daemon.server.exec.ResetDeprecationLogger.execute(ResetDeprecationLogger.java:24)
        at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
        at org.gradle.launcher.daemon.server.exec.StartStopIfBuildAndStop.execute(StartStopIfBuildAndStop.java:33)
        at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
        at org.gradle.launcher.daemon.server.exec.ReturnResult.execute(ReturnResult.java:34)
        at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
        at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:70)
        at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:68)
        at org.gradle.util.Swapper.swap(Swapper.java:38)
        at org.gradle.launcher.daemon.server.exec.ForwardClientInput.execute(ForwardClientInput.java:68)
        at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
        at org.gradle.launcher.daemon.server.exec.LogToClient.doBuild(LogToClient.java:60)
        at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)
        at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
        at org.gradle.launcher.daemon.server.exec.EstablishBuildEnvironment.doBuild(EstablishBuildEnvironment.java:59)
        at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)
        at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
        at org.gradle.launcher.daemon.server.exec.StartBuildOrRespondWithBusy$1.run(StartBuildOrRespondWithBusy.java:45)
        at org.gradle.launcher.daemon.server.DaemonStateCoordinator.runCommand(DaemonStateCoordinator.java:186)
        at org.gradle.launcher.daemon.server.exec.StartBuildOrRespondWithBusy.doBuild(StartBuildOrRespondWithBusy.java:49)
        at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)
        at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
        at org.gradle.launcher.daemon.server.exec.HandleStop.execute(HandleStop.java:36)
        at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
        at org.gradle.launcher.daemon.server.exec.CatchAndForwardDaemonFailure.execute(CatchAndForwardDaemonFailure.java:32)
        at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)
        at org.gradle.launcher.daemon.server.exec.DefaultDaemonCommandExecuter.executeCommand(DefaultDaemonCommandExecuter.java:48
)
        at org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler$ConnectionWorker.handleCommand(DefaultIncomingConnec
tionHandler.java:155)
        at org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler$ConnectionWorker.receiveAndHandleCommand(DefaultInco
mingConnectionHandler.java:128)
        at org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler$ConnectionWorker.run(DefaultIncomingConnectionHandle
r.java:116)
        at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
        at java.lang.Thread.run(Thread.java:722)
{code}

Maybe we have to wait till the Gradle osgi plugin updates to Bnd 2.0.0?;;;","04/Jul/13 10:34;pschumacher;This should be fixed since [Guillaumes commit|https://github.com/groovy/groovy-core/commit/f67e447d01f6994c806409439e78e1d8fedc7248].;;;","06/Jul/13 03:34;pschumacher;It would be nice if someone has the time to test if everything is o.k. with [the latest 2.2-Snapshot|http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all/2.2.0-SNAPSHOT/groovy-all-2.2.0-20130704.224257-202-indy.jar].;;;","06/Jul/13 03:43;russel;How would that be done? I build Groovy most mornings from master/HEAD and then switch out the old artefacts and switch in the indy ones to the standard installation, so I am set up to run any tests. Except that I have no idea when OSGi would be used or useful.;;;","06/Jul/13 04:41;pschumacher;I guess you have to use the indy jar in an osgi container like Apache Felix.;;;","08/Jul/13 07:15;guillaume;Paul Bakker on twitter tested our Groovy all JAR indy, and reported that it worked fine.
https://twitter.com/pbakker/status/353482954623819779 

So hopefully we're good now :-);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovysh 2.0.0-beta-3 ERROR java.lang.ClassCastException: required class java.lang.Class but encountered class org.fusesource.jansi.AnsiRenderer,GROOVY-5473,12812112,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,bbrooks,bbrooks,24/May/12 13:42,12/Jan/13 20:40,14/Jul/23 06:00,07/Jan/13 06:19,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.7,2.1.0-rc-1,,Groovysh,,,,1,exception,groovysh,,,,"Guillaume requested the I create a ticket for this issue originally reported on the groovy-user mailing list...

I'm trying out the invoke dynamic (indy) version of groovy.  When running groovysh 2.0.0-beta-3 with Java 1.7u4, the following error is continuously printing to the console 

C:\>groovysh 
Groovy Shell (2.0.0-beta-3, JVM: 1.7.0_04) 
Type 'help' or '\h' for help. 
------------------------------------------------------------------------------- 
ERROR java.lang.ClassCastException: required class java.lang.Class but encountered class org.fusesource.jansi.AnsiRenderer 

I'm running this on Windows XP SP3. 

I followed CÃÆÃâÃâÃÂ©dric Champeau's instructions to copy the indy jar to the lib and rename it (http://groovy.329449.n5.nabble.com/ANN-Groovy-2-0-0-beta-3-td5691151.html).  groovyConsole starts without these errors. ",Windows XP SP3,bbrooks,blackdrag,geofflane,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"04/Jan/13 11:01;pschumacher;groovysh-indy-logging-output.txt;https://issues.apache.org/jira/secure/attachment/12722183/groovysh-indy-logging-output.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 08 13:15:39 UTC 2013,,,,,,,,,,"0|i2cmxz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Jul/12 16:44;geofflane;Confirmed on Windows 7 as well. Also tried with Groovy 2.0.0 and 2.0.1.;;;","26/Jul/12 04:34;paulk;Thread dump during infinite loop/hang:
{noformat}
""Thread-2"" daemon prio=6 tid=0x04b4b000 nid=0x3248 in Object.wait() [0x04e6f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x2f228a78> (a java.util.LinkedList)
        at java.lang.Object.wait(Object.java:503)
        at java.util.prefs.AbstractPreferences$EventDispatchThread.run(AbstractPreferences.java:1476)
        - locked <0x2f228a78> (a java.util.LinkedList)

""Service Thread"" daemon prio=6 tid=0x00495400 nid=0x3530 runnable [0x00000000]
   java.lang.Thread.State: RUNNABLE

""C1 CompilerThread0"" daemon prio=10 tid=0x00491000 nid=0x47c8 waiting on condition [0x00000000]
   java.lang.Thread.State: RUNNABLE

""Attach Listener"" daemon prio=10 tid=0x0048f000 nid=0x40f8 runnable [0x00000000]
   java.lang.Thread.State: RUNNABLE

""Signal Dispatcher"" daemon prio=10 tid=0x0048c000 nid=0x26d4 waiting on condition [0x00000000]
   java.lang.Thread.State: RUNNABLE

""Finalizer"" daemon prio=8 tid=0x00478c00 nid=0x428c in Object.wait() [0x0441f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x2ee50288> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:135)
        - locked <0x2ee50288> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:151)
        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:177)

""Reference Handler"" daemon prio=10 tid=0x00473c00 nid=0x4554 in Object.wait() [0x0429f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x2ee50310> (a java.lang.ref.Reference$Lock)
        at java.lang.Object.wait(Object.java:503)
        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:133)
        - locked <0x2ee50310> (a java.lang.ref.Reference$Lock)

""main"" prio=6 tid=0x01fcbc00 nid=0x310c runnable [0x0032d000]
   java.lang.Thread.State: RUNNABLE
        at java.lang.Throwable.getStackTraceElement(Native Method)
        at java.lang.Throwable.getOurStackTrace(Throwable.java:826)
        - locked <0x2c9f1ae0> (a java.lang.ClassCastException)
        at java.lang.Throwable.getStackTrace(Throwable.java:815)
        at org.codehaus.groovy.runtime.StackTraceUtils.sanitize(StackTraceUtils.java:101)
        at org.codehaus.groovy.runtime.StackTraceUtils.deepSanitize(StackTraceUtils.java:187)
        at sun.reflect.GeneratedMethodAccessor16.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1307)
        at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1293)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at org.codehaus.groovy.tools.shell.Groovysh.maybeRecordError(Groovysh.groovy:297)
        at org.codehaus.groovy.tools.shell.Groovysh.this$3$maybeRecordError(Groovysh.groovy)
        at sun.reflect.GeneratedMethodAccessor27.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:361)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L3(MethodHandleImpl.java:1138)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at org.codehaus.groovy.tools.shell.Groovysh$_closure2.doCall(Groovysh.groovy:341)
        at sun.reflect.GeneratedMethodAccessor24.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L3(MethodHandleImpl.java:1138)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at org.codehaus.groovy.tools.shell.Groovysh.displayError(Groovysh.groovy:388)
        at org.codehaus.groovy.tools.shell.Groovysh.this$3$displayError(Groovysh.groovy)
        at sun.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1074)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:941)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
        at groovy.lang.Closure.call(Closure.java:410)
        at groovy.lang.Closure.call(Closure.java:423)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
        at org.codehaus.groovy.tools.shell.ShellRunner.run(ShellRunner.groovy:66)
        at org.codehaus.groovy.tools.shell.InteractiveShellRunner.super$2$run(InteractiveShellRunner.groovy)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1074)
        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:128)
        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuper0(ScriptBytecodeAdapter.java:148)
        at org.codehaus.groovy.tools.shell.InteractiveShellRunner.run(InteractiveShellRunner.groovy:66)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L1(MethodHandleImpl.java:1122)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:652)
        at org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:463)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:652)
        at org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:402)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:652)
        at org.codehaus.groovy.tools.shell.Main.main(Main.groovy:131)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)
{noformat}
;;;","27/Dec/12 03:37;pschumacher;I just tried this on Windows XP SP3, Groovy 2.0.6, JDK 1.7.0_09 and it worked:

{code}
D:\development\groovy-2.0.6\bin>groovy --indy -e ""println 2.0""
2.0
{code}

{code}
Groovy Shell (2.0.6, JVM: 1.7.0_09)
Type 'help' or '\h' for help.
-----------------------------------------------------------------------------------------------------------------------
groovy:000> exit
{code};;;","27/Dec/12 20:59;paulk;Pascal, are you sure you replaced all of the normal jars with the indy jars?

I still get the error when starting groovysh:
{noformat}
> groovysh
Groovy Shell (2.0.6, JVM: 1.7.0_10)
Type 'help' or '\h' for help.
-----------------------------------------------------------------------------------------------------------------------
ERROR org.codehaus.groovy.GroovyBugError:
BUG! Unknown transformation for argument org.fusesource.jansi.AnsiRenderer@190d004 at position 0 with class org.fusesour
ce.jansi.AnsiRenderer for parameter of type class java.lang.Class
...
ERROR org.codehaus.groovy.GroovyBugError:
BUG! Unknown transformation for argument org.fusesource.jansi.AnsiRenderer@1517a05 at position 0 with class org.fusesour
ce.jansi.AnsiRenderer for parameter of type class java.lang.Class
ERROR org.codehaus.groovy.GroovyBugError:
BUG! Unknown transformation for argument org.fusesource.jansi.AnsiRenderer@1517a05 at position 0 with class org.fusesour
ce.jansi.AnsiRenderer for parameter of type class java.lang.Class
2012-12-28 12:56:47
Full thread dump Java HotSpot(TM) Client VM (23.6-b04 mixed mode, sharing):

""Thread-2"" daemon prio=6 tid=0x0319a000 nid=0xa90 in Object.wait() [0x0347f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x2d907230> (a java.util.LinkedList)
        at java.lang.Object.wait(Object.java:503)
        at java.util.prefs.AbstractPreferences$EventDispatchThread.run(AbstractPreferences.java:1476)
        - locked <0x2d907230> (a java.util.LinkedList)

""Service Thread"" daemon prio=6 tid=0x02a54400 nid=0xc58 runnable [0x00000000]
   java.lang.Thread.State: RUNNABLE

""C1 CompilerThread0"" daemon prio=10 tid=0x02a46400 nid=0xc54 waiting on condition [0x00000000]
   java.lang.Thread.State: RUNNABLE

""Attach Listener"" daemon prio=10 tid=0x02a44800 nid=0xc40 runnable [0x00000000]
   java.lang.Thread.State: RUNNABLE

""Signal Dispatcher"" daemon prio=10 tid=0x02a43400 nid=0xc34 waiting on condition [0x00000000]
   java.lang.Thread.State: RUNNABLE

""Finalizer"" daemon prio=8 tid=0x02a34800 nid=0xc28 in Object.wait() [0x02c7f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x2d530288> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:135)
        - locked <0x2d530288> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:151)
        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:177)

""Reference Handler"" daemon prio=10 tid=0x02a2f800 nid=0xc18 in Object.wait() [0x02c2f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x2d530310> (a java.lang.ref.Reference$Lock)
        at java.lang.Object.wait(Object.java:503)
        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:133)
        - locked <0x2d530310> (a java.lang.ref.Reference$Lock)

""main"" prio=6 tid=0x003b8c00 nid=0x2d0 runnable [0x0090e000]
   java.lang.Thread.State: RUNNABLE
        at java.io.FileOutputStream.writeBytes(Native Method)
        at java.io.FileOutputStream.write(FileOutputStream.java:318)
        at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)
        at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)
        - locked <0x2d53dbe0> (a java.io.BufferedOutputStream)
        at java.io.PrintStream.write(PrintStream.java:451)
        - locked <0x2d537e18> (a java.io.PrintStream)
        at org.fusesource.jansi.AnsiOutputStream.write(AnsiOutputStream.java:82)
        at java.io.FilterOutputStream.write(FilterOutputStream.java:125)
        at java.io.PrintStream.write(PrintStream.java:480)
        - locked <0x2d74e048> (a java.io.PrintStream)
        at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)
        at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)
        at sun.nio.cs.StreamEncoder.implFlush(StreamEncoder.java:295)
        at sun.nio.cs.StreamEncoder.flush(StreamEncoder.java:141)
        - locked <0x2d7aac40> (a java.io.OutputStreamWriter)
        at java.io.OutputStreamWriter.flush(OutputStreamWriter.java:229)
        at java.io.BufferedWriter.flush(BufferedWriter.java:254)
        - locked <0x2d7aac40> (a java.io.OutputStreamWriter)
        at java.io.PrintWriter.newLine(PrintWriter.java:482)
        - locked <0x2d78b540> (a java.io.BufferedWriter)
        at java.io.PrintWriter.println(PrintWriter.java:629)
        at java.io.PrintWriter.println(PrintWriter.java:740)
        - locked <0x2d78b540> (a java.io.BufferedWriter)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at org.codehaus.groovy.tools.shell.Groovysh$_closure2.doCall(Groovysh.groovy:339)
        at sun.reflect.GeneratedMethodAccessor24.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L3(MethodHandleImpl.java:1138)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at java.lang.invoke.MethodHandle.invokeExact(MethodHandle.java)
        at org.codehaus.groovy.tools.shell.Groovysh.displayError(Groovysh.groovy:388)
        at org.codehaus.groovy.tools.shell.Groovysh.this$3$displayError(Groovysh.groovy)
        at sun.reflect.GeneratedMethodAccessor23.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1076)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:943)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:906)
        at groovy.lang.Closure.call(Closure.java:412)
        at groovy.lang.Closure.call(Closure.java:425)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
        at org.codehaus.groovy.tools.shell.ShellRunner.run(ShellRunner.groovy:66)
        at org.codehaus.groovy.tools.shell.InteractiveShellRunner.super$2$run(InteractiveShellRunner.groovy)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1076)
        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:128)
        at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuper0(ScriptBytecodeAdapter.java:148)
        at org.codehaus.groovy.tools.shell.InteractiveShellRunner.run(InteractiveShellRunner.groovy:66)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L1(MethodHandleImpl.java:1122)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:732)
        at org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:463)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:732)
        at org.codehaus.groovy.tools.shell.Groovysh.run(Groovysh.groovy:402)
        at java.lang.invoke.MethodHandleImpl$GuardWithCatch.invoke_L2(MethodHandleImpl.java:1130)
        at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:732)
        at org.codehaus.groovy.tools.shell.Main.main(Main.groovy:131)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)

""VM Thread"" prio=10 tid=0x02a2e000 nid=0xc04 runnable

""VM Periodic Task Thread"" prio=10 tid=0x02a67c00 nid=0xc3c waiting on condition

JNI global references: 178

Heap
 def new generation   total 7424K, used 4694K [0x2aa90000, 0x2b290000, 0x2d530000)
  eden space 6656K,  70% used [0x2aa90000, 0x2af24798, 0x2b110000)
  from space 768K,   0% used [0x2b1d0000, 0x2b1d1330, 0x2b290000)
  to   space 768K,   0% used [0x2b110000, 0x2b110000, 0x2b1d0000)
 tenured generation   total 16256K, used 10355K [0x2d530000, 0x2e510000, 0x32a90000)
   the space 16256K,  63% used [0x2d530000, 0x2df4cfa8, 0x2df4d000, 0x2e510000)
 compacting perm gen  total 12288K, used 5247K [0x32a90000, 0x33690000, 0x36a90000)
   the space 12288K,  42% used [0x32a90000, 0x32fafcc0, 0x32fafe00, 0x33690000)
    ro space 10240K,  45% used [0x36a90000, 0x36f15e50, 0x36f16000, 0x37490000)
    rw space 12288K,  54% used [0x37490000, 0x37b18f78, 0x37b19000, 0x38090000)

ERROR org.codehaus.groovy.GroovyBugError:
BUG! Unknown transformation for argument org.fusesource.jansi.AnsiRenderer@1517a05 at position 0 with class org.fusesour
ce.jansi.AnsiRenderer for parameter of type class java.lang.Class
...
{noformat};;;","28/Dec/12 01:44;pschumacher;Sorry about that. I just copied the groovy-2.0.6.jar not all the other jars. If I copy all the jars I get the same error.;;;","04/Jan/13 08:55;blackdrag;Pascal, you could help with this issue if you set groovy.indy.logging to true and then execute again. The logging output from can be huge, but could give me a hint about what goes wrong;;;","04/Jan/13 09:09;pschumacher;How do I set groovy.indy.logging to true?

I tried
{code}
groovysh.bat -Dgroovy.indy.logging=true
{code}

or setting it as environment variable, but did not see any difference.;;;","04/Jan/13 09:40;blackdrag;you need to set a system property. If the above does not work, then using an environment variable JAVA_OPTS containing what you want to give the java command, so here ""-Dgroovy.indy.logging=true"";;;","04/Jan/13 10:59;pschumacher;I set JAVA_OPTS, ran groovysh.bat and uploaded the output.;;;","04/Jan/13 13:19;blackdrag;thanks Pascal. From the log output I assume that there is still a hole in the indy implementation and that is for calling static methods in a nonstatic way. This is quite surprising to me since I thought this case was handled. Well, I will take a look at this monday;;;","07/Jan/13 06:03;blackdrag;Pascal... you did not check this against master, did you? Because the trace you attached  has ""INFO: meta method is category type method: false"", but is missing ""INFO: meta method is static category type method: false"", which is logged right after the line above.;;;","07/Jan/13 06:05;blackdrag;I was just able to confirm, the bug is only on GROOVY_2_0_X, not on master
;;;","07/Jan/13 06:19;blackdrag;fixed now;;;","07/Jan/13 21:30;paulk;confirmed working for me on 2_0_X and master;;;","08/Jan/13 13:05;pschumacher;a small detail: fix version should be 2.0.7 instead of 2.0.6;;;","08/Jan/13 13:15;blackdrag;fix version corrected;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Add ""indy"" option to Groovy Console",GROOVY-5471,12816233,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,melix,melix,24/May/12 03:13,02/May/17 02:03,14/Jul/23 06:00,22/Jan/17 19:53,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,Groovy Console,,,,0,,,,,,"If ""invokedynamic"" support is available, the groovy console should show an option allowing the scripts written in the console to be compiled with indy support too.

Otherwise, the user might think that because he's using a ""indy"" jar, the Groovy Console will compile scripts with indy activated, but in reality, only core groovy classes will use indy.",,githubbot,jwagenleitner,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jan 22 19:28:36 UTC 2017,,,,,,,,,,"0|i2ccbb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Jul/12 10:56;melix;Just commenting on this issue, this is a more general problem for indy, which is also how to run tests while being sure that indy is on despite they use things like {{assertScript}}.
;;;","04/Jan/17 05:53;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/475

    GROOVY-5471: Add ""indy"" option to Groovy Console (and AstBrowser)

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy groovy5471

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/475.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #475
    
----
commit 8a8fd94a09491f24c692df5aa132de9c34bed70d
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-01-03T06:42:21Z

    GROOVY-5471: Add ""indy"" option to Groovy Console (and AstBrowser)

----
;;;","22/Jan/17 19:15;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/475
;;;","22/Jan/17 19:28;jwagenleitner;{quote}Just commenting on this issue, this is a more general problem for indy, which is also how to run tests while being sure that indy is on despite they use things like assertScript.{quote}

It looks like since this comment [commit 40b02bca|https://github.com/apache/groovy/commit/40b02bcadce3c3d0768bcc35b3920f04322ea004] added the {{groovy.target.indy}} System property to provide a mechanism to ensure indy is enabled for such things as {{assertScript}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@TypeChecked Closure methods/properties not recognized inside closure defition,GROOVY-5470,12811980,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,rgarcia,rgarcia,24/May/12 02:47,15/Jun/12 22:56,14/Jul/23 06:00,12/Jun/12 15:21,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-3,,,Compiler,Static Type Checker,,,0,,,,,,"The compiler fails to recognize the delegate variable and getOwner method on the class definition below:

{code}
@TypeChecked
class StaticGroovy {
    def bar() {
        def foo = {[ this, delegate, getOwner()]}
    }
}
{code}",,rgarcia,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-05-24 02:47:13.0,,,,,,,,,,"0|i2bqdz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Documentation error for ExpandoMetaClass,GROOVY-5468,12811705,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,krasmussen,krasmussen,23/May/12 15:27,22/Dec/12 01:10,14/Jul/23 06:00,15/Dec/12 00:32,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,2.1.0-beta-1,Documentation,,,,0,,,,,,"
The following javadoc has a warning that was true under Grails from way back but I don't believe applies anymore when this functionality was ported to Groovy 1.1:

http://groovy.codehaus.org/api/groovy/lang/ExpandoMetaClass.html

{quote}
WARNING: This MetaClass uses a thread-bound ThreadLocal instance to store and retrieve properties. In addition properties stored use soft references so they are both bound by the life of the Thread and by the soft references. The implication here is you should NEVER use dynamic properties if you want their values to stick around for long periods because as soon as the JVM is running low on memory or the thread dies they will be garbage collected.
{quote}

It is also mentioned here:

http://groovy.codehaus.org/ExpandoMetaClass+-+Properties

{quote}
However, using this technique the property is stored in a ThreadLocal, WeakHashMap so don't expect the value to stick around forever!
{quote}


My guess is when Expando was ported into Groovy 1.1 the javadocs weren't updated appropriately to reflect the changes as discussed here:

http://groovy.329449.n5.nabble.com/Adding-properties-failed-with-ExpandoMetaClass-td343953.html

It was added here:

http://jira.codehaus.org/browse/GROOVY-1720

Using ThreadLocale wouldn't be amiable to server side RIA frameworks such as Vaadin where objects live beyond the request/response cycle.

This test case clearly shows that it isn't bound to a ThreadLocale or this would fail:

{code}
String.metaClass.swapCase = {->
      def sb = new StringBuffer()
      delegate.each {
           sb << (Character.isUpperCase(it as char) ? Character.toLowerCase(it as char) : 
                   Character.toUpperCase(it as char))
      }
      sb.toString()
}


println 'THIS IS A TEST'.swapCase()

new Thread(new Runnable() {
   
    void run() {
        println 'ANOTHER'.swapCase()
    }
}).start()

Thread.sleep(1000L)

{code}
",,krasmussen,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Dec 15 00:32:24 UTC 2012,,,,,,,,,,"0|i2c0x3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Nov/12 14:04;pschumacher;Took a look at the code and didn't find any occurrences of WeakHashMap or ThreadLocal so I created pull request [https://github.com/groovy/groovy-core/pull/70] which removes the groovy doc comment. I also deleted the warning from the wiki page.;;;","15/Dec/12 00:32;paulk;Spurious comment removed. Thanks for the issue and analysis Kirk and the pull request Pascal.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
catch Exception from loading from a jar to avoid BUG! message and do proper error reporting,GROOVY-5467,12818129,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,juljanmay,juljanmay,23/May/12 06:13,06/Aug/16 09:52,14/Jul/23 06:00,06/Aug/16 09:52,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,xforms,,,,0,,,,,,"I have a testsuite within a soapui project which runs perfectly using soapUI (4.5.0). Trying to run the testsuite in a JUnit test fails: ""java.lang.AssertionError: expected:<FINISHED> but was:<FAILED>"".

I Assume its due to the error message i get in the console:
""ERROR [SoapUI] An error occured [BUG! exception in phase 'semantic analysis' in source unit 'Script1.groovy' Invalid index], see error log for details
BUG! exception in phase 'semantic analysis' in source unit 'Script1.groovy' Invalid index""

This i my code:
{code}
@Test
public void allTestCases() throws Exception {
  WsdlProject project = new WsdlProject(""someproject.xml"");
  List<TestSuite> testSuites = project.getTestSuiteList();
  for (TestSuite suite : testSuites) {
    List<TestCase> testCases = suite.getTestCaseList();
    for (TestCase testCase : testCases) {
      TestRunner runner2 = testCase.run(new PropertiesMap(), false);
      assertEquals(Status.FINISHED, runner2.getStatus());
    }
  }
}
{code}
At first i was using groovy-all-1.8.0 and I also tried it with 1.8.6. afterwards.Nothing changed...

I only get this error message when I'm using groovy scripts in my testsuite.","Windows 7, 64 bit",blackdrag,juljanmay,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 06 09:52:34 UTC 2016,,,,,,,,,,"0|i2cka7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/May/12 07:17;paulk;The error message says to check the error log for details. Do you have access to this error log. Does it have a stacktrace or any other details? Thanks.;;;","23/May/12 07:18;blackdrag;Since I see Script1 I assume you create some scripts at runtime. It seems one of them is causing the compiler to fail in an unpredicted way, which then shows as that BUG! message. I don't know soapUI myself, but it seems to me that they create some stubs or something alike at runtime for soap communication. One of those created scripts seems to have that error.

The problem is, without the script we cannot fix this error. A full stack trace of the reported error would maybe help a little.;;;","23/May/12 08:06;juljanmay;this is from the error log:

2012-05-23 14:41:48,734 ERROR [errorlog] BUG! exception in phase 'semantic analysis' in source unit 'Script1.groovy' Invalid index
BUG! exception in phase 'semantic analysis' in source unit 'Script1.groovy' Invalid index
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:843)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:544)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:493)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:287)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:731)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:743)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:770)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:761)
	at com.eviware.soapui.support.scripting.groovy.SoapUIGroovyScriptEngine.compile(SoapUIGroovyScriptEngine.java:148)
	at com.eviware.soapui.support.scripting.groovy.SoapUIGroovyScriptEngine.run(SoapUIGroovyScriptEngine.java:93)
	at com.eviware.soapui.impl.wsdl.teststeps.WsdlGroovyScriptTestStep.run(WsdlGroovyScriptTestStep.java:148)
	at com.eviware.soapui.impl.wsdl.support.AbstractTestCaseRunner.runTestStep(AbstractTestCaseRunner.java:232)
	at com.eviware.soapui.impl.wsdl.testcase.WsdlTestCaseRunner.runCurrentTestStep(WsdlTestCaseRunner.java:48)
	at com.eviware.soapui.impl.wsdl.support.AbstractTestCaseRunner.internalRun(AbstractTestCaseRunner.java:141)
	at com.eviware.soapui.impl.wsdl.support.AbstractTestCaseRunner.internalRun(AbstractTestCaseRunner.java:42)
	at com.eviware.soapui.impl.wsdl.support.AbstractTestRunner.run(AbstractTestRunner.java:135)
	at com.eviware.soapui.impl.wsdl.support.AbstractTestRunner.start(AbstractTestRunner.java:77)
	at com.eviware.soapui.impl.wsdl.testcase.WsdlTestCase.run(WsdlTestCase.java:631)
	at com.eviware.soapui.impl.wsdl.testcase.WsdlTestCase.run(WsdlTestCase.java:71)
	at com.hlr.pos.test.ecqrf.WebserviceTestLocal2.fullControl(WebserviceTestLocal2.java:174)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
	at org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
Caused by: sun.misc.InvalidJarIndexException: Invalid index
	at sun.misc.URLClassPath$JarLoader.getResource(URLClassPath.java:858)
	at sun.misc.URLClassPath$JarLoader.getResource(URLClassPath.java:765)
	at sun.misc.URLClassPath.getResource(URLClassPath.java:169)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:194)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:295)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:295)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:696)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:295)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:696)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:564)
	at org.codehaus.groovy.control.ResolveVisitor.resolveToClass(ResolveVisitor.java:709)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
	at org.codehaus.groovy.control.ResolveVisitor.resolveFromStaticInnerClasses(ResolveVisitor.java:441)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
	at org.codehaus.groovy.control.ResolveVisitor.resolveFromStaticInnerClasses(ResolveVisitor.java:441)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
	at org.codehaus.groovy.control.ResolveVisitor.resolveFromStaticInnerClasses(ResolveVisitor.java:441)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
	at org.codehaus.groovy.control.ResolveVisitor.resolveFromStaticInnerClasses(ResolveVisitor.java:441)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
	at org.codehaus.groovy.control.ResolveVisitor.visitClass(ResolveVisitor.java:1235)
	at org.codehaus.groovy.control.ResolveVisitor.startResolving(ResolveVisitor.java:148)
	at org.codehaus.groovy.control.CompilationUnit$8.call(CompilationUnit.java:601)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:839)
	... 45 more
2012-05-23 14:43:32,495 ERROR [errorlog] BUG! exception in phase 'semantic analysis' in source unit 'Script1.groovy' Invalid index
BUG! exception in phase 'semantic analysis' in source unit 'Script1.groovy' Invalid index
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:843)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:544)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:493)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:287)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:731)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:743)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:770)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:761)
	at com.eviware.soapui.support.scripting.groovy.SoapUIGroovyScriptEngine.compile(SoapUIGroovyScriptEngine.java:148)
	at com.eviware.soapui.support.scripting.groovy.SoapUIGroovyScriptEngine.run(SoapUIGroovyScriptEngine.java:93)
	at com.eviware.soapui.impl.wsdl.teststeps.WsdlGroovyScriptTestStep.run(WsdlGroovyScriptTestStep.java:148)
	at com.eviware.soapui.impl.wsdl.support.AbstractTestCaseRunner.runTestStep(AbstractTestCaseRunner.java:232)
	at com.eviware.soapui.impl.wsdl.testcase.WsdlTestCaseRunner.runCurrentTestStep(WsdlTestCaseRunner.java:48)
	at com.eviware.soapui.impl.wsdl.support.AbstractTestCaseRunner.internalRun(AbstractTestCaseRunner.java:141)
	at com.eviware.soapui.impl.wsdl.support.AbstractTestCaseRunner.internalRun(AbstractTestCaseRunner.java:42)
	at com.eviware.soapui.impl.wsdl.support.AbstractTestRunner.run(AbstractTestRunner.java:135)
	at com.eviware.soapui.impl.wsdl.support.AbstractTestRunner.start(AbstractTestRunner.java:77)
	at com.eviware.soapui.impl.wsdl.testcase.WsdlTestCase.run(WsdlTestCase.java:631)
	at com.eviware.soapui.impl.wsdl.testcase.WsdlTestCase.run(WsdlTestCase.java:71)
	at com.hlr.pos.test.ecqrf.WebserviceTestLocal2.fullControl(WebserviceTestLocal2.java:174)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)
	at org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
Caused by: sun.misc.InvalidJarIndexException: Invalid index
	at sun.misc.URLClassPath$JarLoader.getResource(URLClassPath.java:858)
	at sun.misc.URLClassPath$JarLoader.getResource(URLClassPath.java:765)
	at sun.misc.URLClassPath.getResource(URLClassPath.java:169)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:194)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:295)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:295)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:696)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:295)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:696)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:564)
	at org.codehaus.groovy.control.ResolveVisitor.resolveToClass(ResolveVisitor.java:709)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
	at org.codehaus.groovy.control.ResolveVisitor.resolveFromStaticInnerClasses(ResolveVisitor.java:441)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
	at org.codehaus.groovy.control.ResolveVisitor.resolveFromStaticInnerClasses(ResolveVisitor.java:441)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
	at org.codehaus.groovy.control.ResolveVisitor.resolveFromStaticInnerClasses(ResolveVisitor.java:441)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
	at org.codehaus.groovy.control.ResolveVisitor.resolveFromStaticInnerClasses(ResolveVisitor.java:441)
	at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
	at org.codehaus.groovy.control.ResolveVisitor.visitClass(ResolveVisitor.java:1235)
	at org.codehaus.groovy.control.ResolveVisitor.startResolving(ResolveVisitor.java:148)
	at org.codehaus.groovy.control.CompilationUnit$8.call(CompilationUnit.java:601)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:839)
	... 45 more


I have several groovy scripts in this testsuite. But when i run this testsuite in soapUI everything works fine. no error message shows up. 
;;;","23/May/12 12:49;blackdrag;now this trace tells a different story: sun.misc.InvalidJarIndexException: Invalid index

Normally that means one of your jars has an invalid META-INF/INDEX.LIST and probably that jar is used only in your test suite.;;;","23/May/12 19:36;paulk;It won't fix Juljan May's problem but we should no doubt not throw a ""BUG! exception"" but instead catch this and re-throw as some kind of Compilation exception I guess - ideally in a way which makes the original error slightly more obvious.;;;","22/Jan/13 15:15;pschumacher;I guess this should be renamed if it is still planed to change the error message / error thrown or else it should be closed.;;;","06/Aug/16 09:52;paulk;I am going to close this issue. We could try to catch the exception as per below:
{code}
--- src/main/groovy/lang/GroovyClassLoader.java	(revision a1e97f17da156c26e9ede58bbf7bcb9c7987256d)
+++ src/main/groovy/lang/GroovyClassLoader.java	(revision )
@@ -685,6 +685,8 @@
             } else {
                 throw ncdfe;
             }
+        } catch (sun.misc.InvalidJarIndexException ijie) {
+            throw new RuntimeException(""Index error loading loading class '"" + name + ""', possible corrupt jar?"", ijie);
         }
{code}
but then we reference an internal class that is subject to change.

From searching the error it seems to have mainly occurred in the past when buggy build tools were used to build corrupt jars. The popular tools seem to have fixed previous issues. In any case we are very limited in what we can do to solve the problem given how and where it is occurring.

If it crops up more frequently, we can reopen and apply some kind of fix like above.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Invalid code crashes the compiler,GROOVY-5466,12816238,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,hudi1,hudi1,22/May/12 09:30,26/Jul/12 16:49,14/Jul/23 06:00,13/Jul/12 10:56,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.7,2.0.1,,,,,0,,,,,,"here is piece of code which return bug

BUG! exception in phase 'class generation' in source unit 'Script7.groovy' tried to get a variable with the name number as stack variable, but a variable with this name was not created

if (false)
    int number = 0

1..3.each{
    println number
}
",,blackdrag,rgarcia,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 13 10:56:30 UTC 2012,,,,,,,,,,"0|i2cgsv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jul/12 10:56;blackdrag;should be fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovyc Ant task fails to compile any transform if includeAntRuntime=false,GROOVY-5465,12812084,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,pniederw,pniederw,22/May/12 07:50,08/Mar/22 12:16,14/Jul/23 06:00,28/May/21 18:06,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Ant integration,,,,0,,,,,,"I stumbled over this during my work on Gradle Groovy integration. It's not a big deal for Gradle, but I thought I'd let you know. It's a class loading problem.",,emilles,melix,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 28 18:06:36 UTC 2021,,,,,,,,,,"0|i2cb6v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/May/12 07:58;melix;Peter, can it be the same issue as GROOVY-5044?;;;","22/May/12 08:05;pniederw;Yes, it's the same issue. Class loading in the Ant groovyc task is pretty weird. The reason why transforms work with includeAntRuntime=false (or fork=true) is that the compile dependencies are put on the same class loader as the compiler itself. (There is a separate class loader for compile dependencies, but in fact all compile dependencies are loaded from its parent, which is the class loader that loads the compiler itself.) Same for command line compiler. Especially for the latter (which doesn't seem to be using groovy-all), I wonder how risky that is.;;;","28/May/21 18:06;emilles;We have been using groovyc ant task with this setting for years:
{code:xml}
        <!-- Create the compiler toolchain under the task name ""compile"" -->
        <taskdef name=""groovyc"" classname=""org.codehaus.groovy.ant.Groovyc"">
            <classpath>
                <fileset file=""${dir.libraries}/build/groovy-ant-*.jar"" />
                <fileset file=""${dir.libraries}/master/groovy-*.jar"" />
            </classpath>
        </taskdef>
        <presetdef name=""compile"">
            <groovyc configscript=""config.groovy"" fork=""true"" includeantruntime=""false"" targetBytecode=""1.8"">
                <javac debug=""true"" source=""1.8"" target=""1.8"" />
            </groovyc>
        </presetdef>
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""Caught: BUG! exception in phase 'class generation'""  when @CompileStatic present on class definition",GROOVY-5463,12816247,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,jboone,jboone,21/May/12 11:35,21/Jun/12 17:03,14/Jul/23 06:00,20/Jun/12 11:04,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-4,,,,,,,0,,,,,,"Receive the following error when I attempt to run the attached file (Find.groovy):

Caught: BUG! exception in phase 'class generation' in source unit '/home/jboone/scripts/Find.groovy' operand stack contains 4 elements, but we expected only 5
BUG! exception in phase 'class generation' in source unit '/home/jboone/scripts/Find.groovy' operand stack contains 4 elements, but we expected only 5

Also, when the static members are refactored as instance members I receive the same error (see Find2.groovy).

Both files compile and execute correctly when the @CompileStatic annotation is removed.
",groovy-2.0.0-beta-3 / jdk1.7.0_04 (32-bit) / Crunchbang Linux (statler),jboone,melix,rgarcia,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/May/12 11:35;jboone;Find.groovy;https://issues.apache.org/jira/secure/attachment/12722994/Find.groovy","21/May/12 11:35;jboone;Find2.groovy;https://issues.apache.org/jira/secure/attachment/12722919/Find2.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 20 11:04:40 UTC 2012,,,,,,,,,,"0|i2cfqn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jun/12 11:04;melix;Some type checking errors were ""swallowed"" so the example wasn't properly compiled. The compiler will not report errors properly.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
grape command and help is wrong command line structure,GROOVY-5459,12811974,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,russel,russel,18/May/12 01:15,28/Apr/14 19:30,14/Jul/23 06:00,25/Apr/14 18:39,2.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.3.0-rc-2,,,Grape,,,,0,,,,,,"The grape command treats help as an option and not a command, which I would claim to be the wrong thing.
{code}
grape help
{code}
should be they way of getting help. To have to type:
{code}
grape --help
{code}
confuses the role of the tokens in the command line.","Debian Unstable Linux; Groovy master/HEAD 2012-05-17",melix,paulk,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 25 18:39:28 UTC 2014,,,,,,,,,,"0|i2bn3j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Jul/12 10:58;melix;Just changing the fix version. As a breaking change, should not be in a minor release.;;;","25/Apr/14 18:39;paulk;I have added the ""help"" command but left the existing variants, i.e.:
{noformat}
--help
-h
{noformat}
While it is appropriate for us to have consistency in the roles as suggested by this issue, I suspect not all users have a consistent model in their head of how all the groovy commands/options are structured, so providing the existing variants as aliases seems fine to me. In any case, feel free to reopen if you strongly disagree.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The example code in the docs of Closure class regarding OWNER_ONLY resolution strategy is wrong,GROOVY-5457,12816201,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,shailendra,shailendra,17/May/12 02:49,15/Jun/12 22:56,14/Jul/23 06:00,17/May/12 23:50,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-rc-1,,GroovyDoc,,,,0,closure,documentation,resolution,strategy,,"In the docs of Closure (groovy.lang.Closure), for the resolution strategy OWNER_ONLY, the example code is wrong.
The line def cl = { y = x + y } should be def cl = { y = x + y + z} which would throw the exception as mentioned later in the example. The current example runs fine without exception and hence does not explain the concept correctly.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 17 23:50:01 UTC 2012,,,,,,,,,,"0|i2bs8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/May/12 23:50;paulk;Fixed. Thanks for spotting the anomaly.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type compiler failure when defining a closure using the / operator,GROOVY-5456,12816196,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,rgarcia,rgarcia,16/May/12 18:09,15/Jun/12 22:56,14/Jul/23 06:00,12/Jun/12 14:07,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-3,,,Static Type Checker,,,,0,,,,,,"The following class definition results in the error:

{code}
@CompileStatic
class StaticGroovy2 {
    def foo(Closure cls) {}
    def bar() {	foo{ it / 2 } }
}
{code}

>>> a serious error occurred: BUG! exception in phase 'class generation' in source unit '../src/StaticGroovy2.groovy' At line 10 column 8
On receiver: it with message: div and arguments: 2
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY

It seem to fail only with the /, because it works with other operators like: + - *
",,rgarcia,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 31 02:52:46 UTC 2012,,,,,,,,,,"0|i2bwjz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/May/12 02:23;melix;Formatting tags. Assigned to me.;;;","18/May/12 06:49;melix;See https://github.com/groovy/groovy-core/commit/970a4e62dc24855230d3845eb814419bb8eabfca;;;","31/May/12 02:52;rgarcia;I've tested the example and it works fine. However it will fail if you change the order i.e. foo{ 2 / it } or use the operator %;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checker reports ambiguous method call on DGM method,GROOVY-5454,12811973,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,16/May/12 07:21,15/Jun/12 22:56,14/Jul/23 06:00,18/May/12 02:24,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-1,,,Static Type Checker,,,,0,,,,,,"The following code produces a static type checking error:

{code}
(0..10).find { int i -> i<5 }
{code}

It reports an ambiguous call between two ""find"" methods from DGM, one defined on {{Object}}, the other one defined on {{Collection}}.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 16 07:41:17 UTC 2012,,,,,,,,,,"0|i2c3gn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/May/12 07:41;melix;Fixed by https://github.com/groovy/groovy-core/commit/9943dde06743dac0357906a4c6893376897afc0e;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect resolve of category property for String,GROOVY-5453,12815676,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mxm-groovy,mxm,16/May/12 06:39,22/Apr/22 19:48,14/Jul/23 06:00,03/Jun/21 20:34,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,3.0.9,4.0.0-beta-1,,Compiler,,,,0,,,,,,"Assume you have two category methods with String and CharSequence as first parameters respectively. The bug is that Groovy prefers the 'CharSequence' method for String qualifier. 
The bug is reproduced only for String and CharSequence types.
Direct accessor invoking returns correct result.

{code}
class Cat {
  static getFoo(String s) {'String'}
  static getFoo(CharSequence s) {'CharSequence'}
}

use (Cat) {
  assert 'abc'.getFoo() == 'String'   //works
  assert 'abc'.foo      == 'String'   //fails
}
{code}",,emilles,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10214,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 03 17:01:53 UTC 2021,,,,,,,,,,"0|i2cb0f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jun/21 17:01;emilles;{{groovy.lang.MetaClassImpl#getCategoryMethodGetter}} and {{groovy.lang.MetaClassImpl#getCategoryMethodSetter}} are where the selection is made.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException in compiler when using @Immutable,GROOVY-5449,12816215,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,jans70,jans70,14/May/12 14:40,01/Jun/13 06:11,14/Jul/23 06:00,25/Apr/13 08:41,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.4,,,Compiler,,,,2,,,,,,"When using @Immutable with a certain combination of properties, I get a NullPointerException as shown in the stack trace below.

The most basic way I've found to reproduce this is with the two classes.  Note that if I remove the 'final' keyword from properties, or don't include an implementation of toString() in the TestBean class, then the error goes away.

java.lang.NullPointerException
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:179)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeExpressionTransformer.visitIfElse(ClassCodeExpressionTransformer.java:80)
	at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:41)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:102)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:113)
	at org.codehaus.groovy.ast.ClassCodeExpressionTransformer.visitConstructorOrMethod(ClassCodeExpressionTransformer.java:50)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:120)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1166)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:51)
	at org.codehaus.groovy.control.OptimizerVisitor.visitClass(OptimizerVisitor.java:49)
	at org.codehaus.groovy.control.CompilationUnit$6.call(CompilationUnit.java:778)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1122)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:594)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:572)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:549)
	at org.codehaus.jdt.groovy.internal.compiler.ast.GroovyCompilationUnitDeclaration.processToPhase(GroovyCompilationUnitDeclaration.java:171)
	at org.codehaus.jdt.groovy.internal.compiler.ast.GroovyCompilationUnitDeclaration.generateCode(GroovyCompilationUnitDeclaration.java:1526)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:831)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)
	at java.lang.Thread.run(Thread.java:680)
","Mac OS/X Lion, Java 1.6.0_29",hulabula,melix,paulk,youri,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"14/May/12 14:41;jans70;OtherBean.groovy;https://issues.apache.org/jira/secure/attachment/12723024/OtherBean.groovy","14/May/12 14:41;jans70;TestBean.groovy;https://issues.apache.org/jira/secure/attachment/12722918/TestBean.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 25 08:41:11 UTC 2013,,,,,,,,,,"0|i2c8db:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"14/May/12 18:54;paulk;Can you provide a few more details on how you are invoking the compiler?

Running the following script in groovyConsole seemed fine:
{code}
package bug

import groovy.transform.Immutable

@Immutable class TestBean {
    final String value
    final OtherBean other
    String toString() { ""Something"" }
}

@Immutable class OtherBean {
    enum Type { One, Two, Three }
    final Integer value
    final Type type
}

println new TestBean('foo', new OtherBean(30, OtherBean.Type.One))
// => Something
{code}
Also, running:
{noformat}
> groovyc bug/TestBean.groovy
{noformat}
Seemed to work fine using your two source files.

So far I have just tried Groovy 1.8.6 and Java 1.6.0_31 (32-bit) on Windows.
;;;","15/May/12 02:05;jans70;I was compiling this in Eclipse (3.7,1), using the Groovy plugin (2.6.1.xx-20120301-1000-e37-RELEASE).
;;;","15/May/12 03:56;paulk;Any chance you can also try on the command line or groovyConsole? That would help us narrow down our search. Thanks.;;;","15/May/12 14:30;jans70;I've tried both the command line and groovyConsole as well and they work fine.  But I can still reproduce this consistently when compiling in Eclipse.  I realise now that it's behaving strangely - when I get the error, I can change something insignificant, i.e. the string returned trom TestBean.toString(), and then the error goes away.  When I try to do another insignificant change and build again, the error happens again.

Does this mean it's actually a bug in the groovy plugin's interaction with the compiler?

FWIW I have no such problems after changing my classes to use @Canonical instead of @Immutable.
;;;","22/May/12 07:47;hulabula;I'm experiencing the same issue here. Spring STS 2.9, Groovy 1.8.6 and Java 7 (OpenJDK) on Ubuntu.
Adding @Immutable results in a NullPointerException and Eclipse shows an error in another groovy-class that's annotated with @ToString and @Validateable (grails).
Removing @Immutable lets everything work as normal again. Using other annotations (e.g. @Canonical) works fine..;;;","17/Jan/13 15:58;paulk;Can anyone try with the latest versions of Eclipse/STS? Thanks.;;;","26/Mar/13 05:42;paulk;Is anyone still facing this problem or should I close it?;;;","30/Mar/13 07:25;paulk;Please reopen if you can reproduce this error - preferably standalone but with Eclipse if that is the only way. Ideally also with recent versions of Groovy and Eclipse.;;;","25/Apr/13 08:19;youribonnaffe;It is seems to be reproducible with Groovy Version: 2.1.3 JVM: 1.7.0_21 Vendor: Oracle Corporation OS: Linux
A sample snippet to reproduce it 
{code}@groovy.transform.Immutable
class Person {
    def name
}{code}

It was tested in demo by Guillaume Laforge himself :);;;","25/Apr/13 08:41;melix;Good catch. The NPE occurred when the type of a field is considered mutable (here, {{def}} is {{Object}} and the compiler cannot consider it immutable).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Dead links for 2.0.0-beta-3 release,GROOVY-5447,12811972,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,igosuki,igosuki,13/May/12 07:48,15/Jun/12 22:56,14/Jul/23 06:00,14/May/12 09:19,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,"The following URLs are dead :
http://dist.groovy.codehaus.org/distributions/groovy-src-2.0.0-beta-3.zip
http://dist.groovy.codehaus.org/distributions/groovy-docs-2.0.0-beta-3.zip

Consequently, one has to check out the repo to get them.",groovy website,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon May 14 09:19:44 UTC 2012,,,,,,,,,,"0|i2c4j3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/May/12 11:06;blackdrag;what page are these links from?;;;","13/May/12 11:42;igosuki;http://groovy.codehaus.org/Download?nc;;;","14/May/12 09:19;melix;Thanks for pointing that out!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Message ""This method should not have been called"" on script with nested loops and @CompileStatic",GROOVY-5444,12818111,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,willpiasecki,willpiasecki,12/May/12 10:49,15/Jun/12 22:56,14/Jul/23 06:00,18/May/12 06:48,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-1,,,class generator,,,,0,compiler,compilestatic,,,,"I was creating a small benchmarking for BigDecimal operations under @CompileStatic and after a nested loop the following message came:

{noformat}
Caught: BUG! exception in phase 'class generation' in source unit '/media/CHRONICLES/info/groovy/scripts/BugG2b3.groovy' At line 13 column 13
On receiver: curr.call() with message: minus and arguments: t0
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY
BUG! exception in phase 'class generation' in source unit '/media/CHRONICLES/info/groovy/scripts/BugG2b3.groovy' At line 13 column 13
On receiver: curr.call() with message: minus and arguments: t0
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at http://jira.codehaus.org/browse/GROOVY
{noformat}


Happens with or without --indy, and with or without indy jar. 
Happens only with @CompileStatic.


Commenting the {{5.times {}} ""solves"" the problem.

Swapping the ""5.times"" by 
{{for (int i = 0; i < 5; i++)}}
or by
{{for (i in 1..5)}}
or
{{(1..5).each}}
doesn't solve the problem.

","Linux Xubuntu 12.04.
java version ""1.7.0_04""
Java(TM) SE Runtime Environment (build 1.7.0_04-b20)
Java HotSpot(TM) Client VM (build 23.0-b21, mixed mode)
Groovy Version: 2.0.0-beta-3 JVM: 1.7.0_04 Vendor: Oracle Corporation OS: Linux",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/May/12 10:49;willpiasecki;BugG2b3.groovy;https://issues.apache.org/jira/secure/attachment/12722606/BugG2b3.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 18 06:48:31 UTC 2012,,,,,,,,,,"0|i2cd1j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/May/12 06:48;melix;See https://github.com/groovy/groovy-core/commit/96576e4b5bdb5dbf302623e5f944373147fda451;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checking not working for fields assigment,GROOVY-5443,12816194,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,rgarcia,rgarcia,08/May/12 16:33,15/Jun/12 22:56,14/Jul/23 06:00,09/May/12 04:14,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-1,,,Static Type Checker,,,,0,,,,,,"The following classes should fail to compile:

{code:java} 
@TypeChecked
class StaticGroovy1 {
  Date foo = """"
}
{code}
{code:java}
@TypeChecked
class StaticGroovy2 {
    Closure<List> cls = { Date aDate ->  aDate.getTime() }
}
{code}
{code:java}
@TypeChecked
class StaticGroovy3 {
    
    static Closure<Long> cls = { Date aDate ->  aDate.getTime() }
    
    def bar() {
        cls("""")
    }
}
{code}

[See discussion associated to this bug|http://groovy.329449.n5.nabble.com/TypeChecked-and-StaticCompile-usage-td5692547.html]



",,rgarcia,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-05-08 16:33:06.0,,,,,,,,,,"0|i2bn8f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
using dataset queries not supported in groovyConsole,GROOVY-5440,12816620,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,gon,gon,04/May/12 03:29,08/Nov/13 10:53,14/Jul/23 06:00,08/Nov/13 10:53,1.8.6,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-rc-1,,,Groovy Console,SQL processing,,,0,,,,,,"Running the script it is ok, but executing in groovyConsole not.
{code}
def cc = new DataSet(sql, 'cc')
cc.each{println(it)} // works fine
cc.findAll{ it.prg_ordine > 0 }.findAll{it.prg_ordine > 0} // works fine
cc.findAll{ it.prg_ordine > 0 }.each{println(it)} throws 
{code}
{noformat}
Exception thrown
May 04, 2012 10:22:24 AM org.codehaus.groovy.runtime.StackTraceUtils sanitize
WARNING: Sanitizing stacktrace:
groovy.lang.GroovyRuntimeException: Could not find the ClassNode for MetaClass: org.codehaus.groovy.runtime.metaclass.ClosureMetaClass@118a6e8[class ConsoleScript2$_run_closure1]
	at groovy.sql.DataSet.visit(DataSet.java:278)
	at groovy.sql.DataSet.getSqlWhereVisitor(DataSet.java:261)
	at groovy.sql.DataSet.getSqlWhere(DataSet.java:208)
	at groovy.sql.DataSet.getSql(DataSet.java:235)
	at groovy.sql.DataSet.each(DataSet.java:198)
	at groovy.sql.DataSet$each.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at ConsoleScript2.run(ConsoleScript2:7)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:266)
	at groovy.lang.GroovyShell.run(GroovyShell.java:517)
	at groovy.lang.GroovyShell.run(GroovyShell.java:172)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:924)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:884)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:884)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:404)
	at groovy.lang.Closure.run(Closure.java:488)
	at java.lang.Thread.run(Thread.java:722)

groovy.lang.GroovyRuntimeException: Could not find the ClassNode for MetaClass: org.codehaus.groovy.runtime.metaclass.ClosureMetaClass@118a6e8[class ConsoleScript2$_run_closure1]
	at ConsoleScript2.run(ConsoleScript2:7)
{noformat}
","debian 5.0.10, jdk1.7.0",paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Oct 26 08:48:42 UTC 2013,,,,,,,,,,"0|i2cgwf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/May/12 23:48;paulk;Did you add the source directory to the classpath of your groovyConsole instance (under the Script menu)? Incidentally, you should get an improved error message once we release 1.8.7 or 2.0.;;;","07/May/12 02:42;gon;There is no source directory. It's just that snippet of code (I have only omitted the database connection line). Thank you!;;;","07/May/12 03:02;paulk;add code tags;;;","07/May/12 03:05;paulk;I'd normally expect to see something like the following in your script then:
{code}
class cc {
    Integer prg_ordine
    // other fields ...
}
{code}
So that the DataSet logic can map your query results to a POGO.;;;","07/May/12 07:47;gon;Also adding a POGO class results in the same failure as before (I have added the source to the groovyConsole cp). Always the problem is in calling the `each` closure on the dataset object returned from the `findAll`.  Running the same code in a script works fine.;;;","07/May/12 14:05;paulk;Yes, DataSets are lazily evaluated. Calling 'findAll' stores away the query conditions. Not until you try to use the result (e.g. using 'each' in your example) does the database actually get hit.

Can you try the following self-contained example:
{code}
@Grab('hsqldb:hsqldb:1.8.0.10')
@GrabConfig(systemClassLoader=true)
import groovy.sql.Sql
import org.codehaus.groovy.runtime.DefaultGroovyMethods as DGM

def db = [url:'jdbc:hsqldb:mem:testDB', user:'sa', password:'', driver:'org.hsqldb.jdbcDriver']
def ignoreErrors = { Closure c ->
    try {
        c()
    } catch (java.sql.SQLException se) {
        System.err.println ""Ignoring: "" + se.message
    }
}
Sql.withInstance(db.url, db.user, db.password, db.driver) { sql ->
    ignoreErrors {
        sql.execute ""drop table PROJECT""
    }
    sql.execute '''
    create table PROJECT (
        id integer not null,
        name varchar(50),
        url varchar(100)
    )
    '''

    def params = [10, 'Groovy', 'http://groovy.codehaus.org']
    sql.execute 'insert into PROJECT (id, name, url) values (?, ?, ?)', params

    def map = [id:20, name:'Grails', url:'http://grails.codehaus.org']
    sql.execute ""insert into PROJECT (id, name, url) values ($map.id, $map.name, $map.url)""

    def newUrl = 'http://grails.org'
    def project = 'Grails'
    sql.executeUpdate ""update PROJECT set url=$newUrl where name=$project""

    def projects = sql.dataSet('Project')
    projects.add(id: 30, name: 'Griffon', url: 'http://griffon.codehaus.org')
    projects.add(id: 40, name: 'Gradle', url: 'http://gradle.org')

    println 'Some GR8 projects:'
    sql.eachRow('select * from PROJECT') { row ->
        println ""${row.name.padRight(10)} ($row.url) ${DGM.dump(row)}""
    }
}

class Project {
    Integer id
    String name
    String url
}
{code}
Just cut and paste the whole thing into a groovyConsole on a machine with Internet access.

Let us know how it goes. Alternatively, if you can provide some more of your example, we could try to debug it a little further.;;;","08/May/12 02:36;gon;I executed your code in groovyConsole, an exception is thrown: 

Exception thrown May 08, 2012 9:14:10 AM org.codehaus.groovy.runtime.StackTraceUtils sanitize 
WARNING: Sanitizing stacktrace: groovy.lang.MissingMethodException: No signature of method: static groovy.sql.Sql.withInstance() is applicable for argument types: (java.lang.String, java.lang.String, java.lang.String, java.lang.String, ConsoleScript0$_run_closure2) values: [jdbc:hsqldb:mem:testDB, sa, , org.hsqldb.jdbcDriver, ...] 
... cut... 

In order to run I slightly modified the code in: 

def sql = Sql.newInstance(db.url, db.user, db.password, db.driver) 
sql.execute ""drop table PROJECT if exists"" 
sql.execute ''' create table PROJECT ( id integer not null, name varchar(50), url varchar(100) ) ''' 

and eventually that's what came out:
 
Some GR8 projects: Groovy (http://groovy.codehaus.org) <$Proxy10@150c73c h=groovy.sql.GroovyResultSetProxy@17e524b> 
Grails (http://grails.org) <$Proxy10@150c73c h=groovy.sql.GroovyResultSetProxy@17e524b> 
Griffon (http://griffon.codehaus.org) <$Proxy10@150c73c h=groovy.sql.GroovyResultSetProxy@17e524b> 
Gradle (http://gradle.org) <$Proxy10@150c73c h=groovy.sql.GroovyResultSetProxy@17e524b> 



;;;","08/May/12 02:57;gon;Changing the code this way: 

// println 'Some GR8 projects:' 
// sql.eachRow('select * from PROJECT') { row -> 
// println ""${row.name.padRight(10)} ($row.url) ${DGM.dump(row)}"" 
// } 

println(""Printing `each` on projects dataset"") 
projects.each {println(it)} 
def results = projects.findAll{name == 'Griffon'} 
println(""Printing `each` on results dataset returned from findAll"") 
results.each {println(it)} 

and running in the console here is the output: 

Printing `each` on projects dataset 
[ID:10, NAME:Groovy, URL:http://groovy.codehaus.org] 
[ID:20, NAME:Grails, URL:http://grails.org] 
[ID:30, NAME:Griffon, URL:http://griffon.codehaus.org] 
[ID:40, NAME:Gradle, URL:http://gradle.org] 
Printing `each` on results dataset returned from findAll 
Exception thrown May 08, 2012 9:52:35 AM org.codehaus.groovy.runtime.StackTraceUtils sanitize WARNING: Sanitizing stacktrace: groovy.lang.GroovyRuntimeException: Could not find the ClassNode for MetaClass: org.codehaus.groovy.runtime.metaclass.ClosureMetaClass@ba2d07[class ConsoleScript8$_run_closure3] at groovy.sql.DataSet.visit(DataSet.java:278) at groovy.sql.DataSet.getSqlWhereVisitor(DataSet.java:261) at groovy.sql.DataSet.getSqlWhere(DataSet.java:208) at groovy.sql.DataSet.getSql(DataSet.java:235) at groovy.sql.DataSet.each(DataSet.java:198) at groovy.sql.DataSet$each.call(Unknown Source) at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116) at ConsoleScript8.run(ConsoleScript8:50) at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:266) at groovy.lang.GroovyShell.run(GroovyShell.java:517) at groovy.lang.GroovyShell.run(GroovyShell.java:172) at groovy.lang.GroovyShell$run.call(Unknown Source) at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:924) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90) at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233) at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272) at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:884) at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66) at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141) at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90) at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233) at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272) at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:884) at groovy.lang.Closure.call(Closure.java:410) at groovy.lang.Closure.call(Closure.java:404) at groovy.lang.Closure.run(Closure.java:488) at java.lang.Thread.run(Thread.java:722) groovy.lang.GroovyRuntimeException: Could not find the ClassNode for MetaClass: org.codehaus.groovy.runtime.metaclass.ClosureMetaClass@ba2d07[class ConsoleScript8$_run_closure3] at ConsoleScript8.run(ConsoleScript8:50);;;","08/May/12 18:17;paulk;Sorry, ""withInstance"" is only available in the very latest versions of Groovy, not 1.8.4. But getting back to your main point, I think this is a limitation of the groovyConsole. I'll alter the issue description to include ""groovyConsole"" in it.;;;","26/Oct/13 08:48;pschumacher;With Groovy 2.2 I can run Pauls example with groovyConsole, so I guess we can close this?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
error: incompatible types on Java stubs returning generics,GROOVY-5439,12816171,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,guillaume,rgarcia,rgarcia,03/May/12 17:32,21/Sep/12 16:58,14/Jul/23 06:00,18/Sep/12 07:28,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.4,2.1.0-beta-1,Stub generator / Joint compiler,,,,1,,,,,,"The following class definition fails to compile the Java stubs:
{code:java}
class GenericReturn {
    public <T extends List> T foo() {
        null
    }
}
{code}

Error:
{noformat}
tmp/groovy-java-stubs/GenericReturn.java:16: error: incompatible types
public <T extends java.util.List> T foo() { return (java.util.List)null;}
                                                   ^
  required: T
  found:    List
  where T is a type-variable:
    T extends List declared in method <T>foo()

{noformat}

It compiles with no errors on 2.0-beta-2 and 1.8.6","2.0.0-beta-3-SNAPSHOT, JDK 1.7",davide.cavestro,guillaume,johansensen,rgarcia,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 18 07:28:05 UTC 2012,,,,,,,,,,"0|i2co3b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Aug/12 19:08;johansensen;I am also getting this error on 1.8.7.

This code:
{noformat}
class Schedule<T extends ScheduleItem> extends HashSet<T> {
    (...)
    T getCurrentItem() {
        (...)
    }
}
{noformat}
Gives the error:
{noformat}
[ERROR] [...]\groovy-stubs\main\nz\ac\auckland\digitizer\scheduler\Schedule.java:[26,50] error: incompatible types
[ERROR] required: T
[ERROR] found:    ScheduleItem
[ERROR] where T is a type-variable:
[ERROR] T extends ScheduleItem declared in class Schedule
{noformat}
The offending line in the stub:
{noformat}
public  T getCurrentItem() { return (nz.ac.auckland.digitizer.scheduler.ScheduleItem)null;}
{noformat}

Doing a clean and rebuild in 1.8.6 with the same sources works fine.;;;","02/Aug/12 16:44;johansensen;(also, the component for this issue should be stub generator, not compiler);;;","10/Sep/12 23:18;johansensen;Please note: the version field for this issue is misleading. This bug affects all versions of Groovy since 1.8.7, including 1.8.8 and 2.0.2. I am currently unable to upgrade to a newer version than 1.8.6 because my code will not compile in anything newer.;;;","18/Sep/12 07:28;guillaume;Covered also by GROOVY-5710 and GROVY-5630;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Node is missing documentation,GROOVY-5433,12816169,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,balor123,balor123,02/May/12 08:40,22/Dec/12 01:10,14/Jul/23 06:00,23/Nov/12 15:47,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,2.1.0-beta-1,GroovyDoc,,,,0,,,,,,"The Groovy class Node is missing a lot of documentation:

http://groovy.codehaus.org/api/groovy/util/Node.html

Take, for example, the parent() method. What does it return for the root Node? Is it null or this?",,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 23 15:47:51 UTC 2012,,,,,,,,,,"0|i2coov:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/May/12 09:24;balor123;As is a bunch of other XML classes, such as GPathResult.;;;","03/May/12 05:49;paulk;Agreed. Obviously something that we should do. Contributions welcome of course! :-);;;","03/May/12 11:28;balor123;I guess I'm filing enough issues at this point to do so :) First step is still to open issues to identify work and for discussion.;;;","13/May/12 03:49;paulk;So, I guess we never answered the original question. The parent() method returns null for the root node.;;;","11/Nov/12 08:22;pschumacher;Submitted pull request [https://github.com/groovy/groovy-core/pull/71] with additional java doc for groovy.util.Node. ;;;","23/Nov/12 15:47;paulk;pull request applied - thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Performance problem: ClassCastExceptions are created in normal execution flow which kills performance,GROOVY-5428,12816228,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,lhotari,lhotari,28/Apr/12 00:55,04/May/12 10:47,14/Jul/23 06:00,04/May/12 10:47,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,,,,,0,,,,,,"This problem is a major performance bottleneck in Grails 2.0 applications. 
Currently this problem shows up when resources plugin has been installed and used in a Grails app. (see attached screenshot)

Exceptions are relatively heavy weight in Java. Filling the stacktrace takes most of the time. Normal execution flow should never throw exceptions.
(it is possible to disable filling the stacktrace like has been done for MissingMethodExceptionNoStack, in that case the performance overhead is usually acceptable.)

The problem shows up whenever there is 2 classes sharing the same base class and when the other class is a Java class and the other one is a Groovy class (GroovyObject). 

I was able to reproduce the problem with this code. Run this code in a debugger and make a breakpoint for the construction of ClassCastException.
In this example the base class is java.util.Map , the Java class is LinkedHashMap and the Groovy class is MyMap (extends LinkedHashMap).

{code}
class ClassCastProblem {
    def doCalls() {
        def m1=[abc:'test']
        def m2=new MyMap()
        doSomething(m1)
        doSomething(m2)
        doSomething(m1)
        doSomething(m2)
        doSomething(m1)
    }
    
    void doSomething(m) {
        m.remove('test')
    }

    public static void main(String[] args) {
        def ccp=new ClassCastProblem()
        ccp.doCalls()
    }
}

class MyMap extends LinkedHashMap {
    
}
{code}

In a Grails app the 2 different java.util.Map implementations usually triggering this problem are LinkedHashMap and GrailsParameterMap (GroovyObject).

In Grails core I've worked around some of the problem with this type of hack:
https://github.com/grails/grails-core/commit/62626921ebd80e3cdeb9776fd79be7eb92f88763
At that time I didn't have time to investigate the reason that caused the problem and just made some changes until the problem went away.

",Grails 2.0.3 + Groovy 1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/May/12 22:51;lhotari;0001-Fix-for-GROOVY-5428-Eliminate-ClassCastExceptions.patch;https://issues.apache.org/jira/secure/attachment/12722650/0001-Fix-for-GROOVY-5428-Eliminate-ClassCastExceptions.patch","28/Apr/12 00:55;lhotari;Debug - org.codehaus.groovy.runtime.callsite.CallSiteArray - SpringSource Tool Suite - -home-lari-workspace-grails _030.jpg;https://issues.apache.org/jira/secure/attachment/12722993/Debug+-+org.codehaus.groovy.runtime.callsite.CallSiteArray+-+SpringSource+Tool+Suite+-+-home-lari-workspace-grails+_030.jpg","28/Apr/12 00:55;lhotari;IsolatedTomcat-2012-04-27-shutdown.snapshot [-home-lari-Snapshots] - YourKit Java Profiler 9.0.9_027.jpg;https://issues.apache.org/jira/secure/attachment/12723023/IsolatedTomcat-2012-04-27-shutdown.snapshot+%5B-home-lari-Snapshots%5D+-+YourKit+Java+Profiler+9.0.9_027.jpg",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 04 10:47:14 UTC 2012,,,,,,,,,,"0|i2c3cf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Apr/12 03:43;lhotari;Example with Lists & find:

{code}
class ClassCastProblem2 {
    def doCalls() {
        def l1=['a','b','c']
        def l2=new MyList()
        doSomething(l1)
        doSomething(l2)
        doSomething(l1)
        doSomething(l2)
        doSomething(l1)
    }
    
    void doSomething(l) {
        l.find { 
            it
        }
    }

    public static void main(String[] args) {
        def ccp=new ClassCastProblem2()
        ccp.doCalls()
        println('done')
    }
}

class MyList extends ArrayList {
    
}
{code}

The problem shows up also with DGM methods.
;;;","30/Apr/12 07:56;blackdrag;The code in the checkCall method more or less is that:{code:Java}
            return usage.get() == 0
               && ((GroovyObject)receiver).getMetaClass() == metaClass // metaClass still be valid
               && MetaClassHelper.sameClasses(params, args); {code}
If that is causing a ClassCastException, then because receiver is no longer a GroovyObject. In cases in which the receiver does not change all the time from Groovy class to Java class and back, this code is surely better than having and additional instanceof in there. With a more sophisticated caching we could recognize this case and add such a check only in the all so often changing case, maybe even keeping the old callsite and switching between those two. That would surely improve performance. But the caching does not give that kind of logic. If we include the check all method invocations based on GroovyObject will be slower, but that is not all. Even with the check your program has a problem, since it will cause the creation of a new call site every time. What I am trying to tell you is, that even if we add that check the performance of that program will stay bad. The Call site generation takes much more time than the ClassCastException.;;;","30/Apr/12 10:16;lhotari;I've previously provided 2 code examples where the receiver changes from Groovy class to Java class and back.

This happens very often in Grails applications. Usually it happens in Grails with java.util.Map methods (Map implementations LinkedHashMap, GroovyPageAttributes and GrailsParameterMap). The popular Grails resources plugin reproduces this problem too.

{quote}The Call site generation takes much more time than the ClassCastException.{quote}

So the call site generation might be even a larger bottleneck? I hope this issue gets fixed asap since it affects all Grails 2.0 applications that use the resources plugin.;;;","02/May/12 18:08;blackdrag;call site generation means a certain overhead, if you do it all the time, then it becomes a performance problem. The problem is, there is no fast fix for this issue.;;;","03/May/12 00:34;lhotari;I think we could eliminate the ClassCastException. That's causing the overhead in this case and that could be fixed. The call site generation is only instantiating a pre-generated call site class and I don't believe that's expensive. The old call site instance gets replaced also when one of the parameter class changes so that's business as usual. :)

I'd replace ""((GroovyObject)receiver).getMetaClass() == metaClass"" with ""receiver.getClass() == metaClass.getTheClass()"" (used in PojoMetaMethodSite). Do you think that's ok?



;;;","03/May/12 12:57;lhotari;This isn't a major performance issue. I did some benchmarking.

{code}

class ClassCastProblem {
    def doCalls() {
        def m1=[abc:'test']
        def m2=new MyMap()

	println ""Warmup...""
        for(int i=0;i < 100000;i++) {	
           doSomething(m1)
           doSomething(m2)
	}
	println ""Starting...""
	long start=System.currentTimeMillis()
	for(int i=0;i < 10000000;i++) {
           doSomething(m1)
           doSomething(m2)
	   if(i%1000==0) print "".""
        }
	long duration=System.currentTimeMillis()-start
	println ""Duration ${duration} ms""
    }
    
    void doSomething(m) {
        m.remove('test')
    }

    public static void main(String[] args) {
        def ccp=new ClassCastProblem()
        ccp.doCalls()
    }
}

class MyMap extends LinkedHashMap {
    
}
{code};;;","03/May/12 18:36;blackdrag;the generated call site is kept? I forgot that... and it does not go through method selection anymore then? Lari, as for your test... with what do you compare these numbers?

Then about comparing the class instead of the meta class. The call site becomes invalid if the receiver meta class is not what we expect. GroovyObject means per instance meta classes are supported and that can mean any receiver can have a different meta class, even the same receiver at a later point. That's why ensuring the meta class is the same is a requirement. ;;;","03/May/12 22:51;lhotari;Yes, it's kept in CachedMethod:
{code}
private SoftReference<Constructor> pogoCallSiteConstructor, pojoCallSiteConstructor, staticCallSiteConstructor;
{code}

I benchmarked against a version of checkCall where I added ""receiver.getClass() == metaClass.getTheClass()"" to prevent the ClassCastException:
{code}
              return !GroovyCategorySupport.hasCategoryInCurrentThread()
+               && receiver.getClass() == metaClass.getTheClass()
                && ((GroovyObject)receiver).getMetaClass() == metaClass // metaClass still be valid
                && MetaClassHelper.sameClasses(params, args);
{code}

The timings were 6500ms (1.8.6) compared to 5250ms (patched) so this is not a performance bottleneck . That's with 10 million iterations. It will improve performance, but it's not a big change.

I'll also attach a patch if anyone wants to apply it.
;;;","03/May/12 22:56;lhotari;The generated call sites can get GCed since it's a SoftReference in CachedMethod that keeps the reference of a generated call site. That might be a problem under memory pressure.

;;;","04/May/12 05:01;blackdrag;The performance improvement will be much less if you replace the cast with an instanceof and cast, followed by getting the metaclass, instead of calling the intrinsic getClass() method.

Even if the methods are cached, there is still the issue with having to go through method selecton every time. I was asking what you compare with, because the reference should be the case with cached method calls (ie only m2 and no m1). And there I expect like half the time needed, if not less.;;;","04/May/12 06:18;blackdrag;Lari, I added the instanceof check for now. Should we close the issue with that?;;;","04/May/12 07:00;lhotari;Yes it's ok to close this one.

btw. I wonder if the SoftReference pogoCallSiteConstructor and pojoCallSiteConstructor fields of CachedMethod could get GCed under memory pressure and that would cause CachedMethod to generate a new callsite class (bytecode) for the same method (if the callsite gets swapped). I've never seen that happen but that possible problem came into mind.



;;;","04/May/12 10:46;blackdrag;can they be GCed? well.... in a test like yours unlikely, because there is no or almost no object creation between the method calls and during the method call it surely will not happen, since the object is ""in use"". But after a while, or after lots of memory usage this can happen, yes. And yes, the swapped out call site is even more likely to be collected. But without the SoftReference the ChachedClass object would just become bigger and then we would not only have to create the call site again, we would also have to create the cached class again.;;;","04/May/12 10:47;blackdrag;fixed with the instanceof check only;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ObjectRange doesn't have BigInteger optimisation for size(),GROOVY-5425,12816134,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,tim_yates,tim_yates,tim_yates,27/Apr/12 10:45,16/Feb/13 00:47,14/Jul/23 06:00,05/Feb/13 06:26,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.7,2.1.1,groovy-jdk,,,,1,,,,,,"The ObjectRange.size() method has optimisations for BigDecimal, Integer and Long, but not BigInteger

https://github.com/groovy/groovy-core/blob/master/src/main/groovy/lang/ObjectRange.java#L262

This means that calling:

{code}
(1G..2147483647G).size()
{code}

Takes ages

Could we change:

{code}
} else if (from instanceof BigInteger || to instanceof BigInteger) {
{code}

to

{code}
} else if (from instanceof BigDecimal ||
           to   instanceof BigDecimal ||
           from instanceof BigInteger ||
           to   instanceof BigInteger ) {
{code}

To catch this?",,blackdrag,pschumacher,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 04 05:56:27 UTC 2013,,,,,,,,,,"0|i2cexz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jan/13 05:24;pschumacher;Can somebody answer Tims question? Thanks :)!;;;","27/Jan/13 07:11;blackdrag;yes, that change can be done;;;","03/Feb/13 07:27;pschumacher;Tim, I'm assigning this to you because I believe you want to commit the enhancement you suggested.;;;","04/Feb/13 05:56;tim_yates;https://github.com/groovy/groovy-core/pull/134;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong Method Being Invoked - Related To Static Imports,GROOVY-5423,12818163,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,brownj,brownj,26/Apr/12 09:17,03/Feb/22 22:51,14/Jul/23 06:00,28/May/21 15:45,1.8.6,2.4.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.1,,,Compiler,,,,1,compiler,,,,,"When a static import brings in a method which conflicts with a method defined in a class' super class Java invokes the method from the super class but Groovy invokes the method from the static import.

{code:title=src/main/java/com/demo/Utils.java|borderStyle=solid}
package com.demo;

public class Utils {
    
    public static String getValue() {
        return ""Utils.getValue"";
    }
}
{code}

{code:title=src/main/java/com/demo/MyBaseClass.java|borderStyle=solid}
package com.demo;

public class MyBaseClass {
    
    public static String getValue() {
        return ""MyBaseClass.getValue"";
    }
}
{code}

{code:title=src/main/java/com/demo/JavaSubClass.java|borderStyle=solid}
package com.demo;

import static com.demo.Utils.*;

public class JavaSubClass extends MyBaseClass {
    
    public String retrieveValue() {
        return getValue();
    }
}
{code}

{code:title=src/main/groovy/com/demo/GroovySubClass.groovy|borderStyle=solid}
package com.demo

import static com.demo.Utils.*

class GroovySubClass extends MyBaseClass {
    
    String retrieveValue() {
        getValue()
    }
}
{code}


{code:title=src/test/groovy/com/demo/ImportTests.groovy|borderStyle=solid}
package com.demo

class ImportTests extends GroovyTestCase {
    
    void testJava() {
        def subClass = new JavaSubClass()
        def result = subClass.retrieveValue()
        assertEquals 'MyBaseClass.getValue', result
    }
    
    void testGroovy() {
        def subClass = new GroovySubClass()
        def result = subClass.retrieveValue()
        assertEquals 'MyBaseClass.getValue', result
    }
}
{code}

The Java test passes but the Groovy test fails.

To run the code download the attached project (staticimport.zip) and run ""./gradlew test"".",,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"26/Apr/12 09:17;brownj;staticimport.zip;https://issues.apache.org/jira/secure/attachment/12722602/staticimport.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 28 15:45:50 UTC 2021,,,,,,,,,,"0|i2bua7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"26/Apr/12 09:19;brownj;FYI... http://jira.grails.org/browse/GRAILS-9057 was caused by this behavior.;;;","28/May/21 15:45;emilles;fixed under GROOVY-8389;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compilation error with covariant return types (incompatible types),GROOVY-5418,12818456,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,rherzog,rherzog,25/Apr/12 05:11,21/Sep/12 16:58,14/Jul/23 06:00,17/Sep/12 07:48,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.4,,Compiler,,,,2,,,,,,"Given the following files:

{code:title=pkg/Base.java}
package pkg;
public interface Base {
    Base doSomething();
}
{code}

{code:title=pkg/Child.java}
package pkg;
public interface Child extends Base {
    Child doSomething();
}
{code}

{code:title=pkg/GChild.groovy}
package pkg;
class GChild implements Child {
    Child doSomething() {
        return this
    }
}
{code}

When I try to compile this, groovyc complains about incompatible return types:

{noformat}
$ javac pkg/*.java
$ groovyc pkg/*.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
pkg/GChild.groovy: 3: The return type of pkg.Child doSomething() in pkg.GChild is incompatible with pkg.Base doSomething() in pkg.Base
. At [3:2]  @ line 3, column 2.
        Child doSomething() {
    ^

1 error

$ javac -version
javac 1.6.0_31
$ groovyc -version
Groovy compiler version 1.8.6
Copyright 2003-2011 The Codehaus. http://groovy.codehaus.org/

$
{noformat}

A very similar (almost identical) issue has already been reported here: https://jira.codehaus.org/browse/GROOVY-2829 (marked as fixed in 1.5.7 and 1.6-beta2)","Linux, jdk 1.6.0u31 (also reproducible with 1.7)",abnaxos,jstoneham,kaxelson,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 13 17:19:07 UTC 2012,,,,,,,,,,"0|i2btrj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Apr/12 08:24;rherzog;Playing around with the example, I found that really needs to be *this* situation to reproduce the problem:

* Using classes instead of interfaces: Works
* Using Number/Integer instead of Base/Child as return types: Works
* And, interesting: Returning GChild instead of Child in GChild.groovy: Works

As a workaround, I can do the following if returning GChild isn't an option:

{code:title=pkg/AbstractChild.java}
package pkg;
public abstract class AbstractChild implements Child {
    protected abstract Object doIt();
    public Child doSomething() {
        return (Child)doIt();
    }
}
{code}

{code:title=pkg/GChild.groovy}
package pkg;
class GChild extends AbstractChild {
    // NOTE: including ""implements Child"" above will reproduce the problem!
    Object doIt() {
        return null
    }
}
{code};;;","13/Sep/12 17:19;kaxelson;I'm having the same problem.  See sample code below.  If you compile and run with Java it works and prints ""this should work"".  If you compile and run with Groovy (tried with 1.8.6 and 2.0.2), you get 
\\
\\
{color:red}
The return type of java.util.List doSomething() in BugExample$C is incompatible with java.lang.Iterable doSomething() in BugExample$A
. At [13:9]  at line: 13, column: 9
{color}
\\
\\
{code:title=BugExample.java/groovy}
import java.util.List;

public class BugExample {
    static interface A {
        Iterable doSomething();
    }

    static interface B extends A {
        List doSomething();
    }

    static class C implements B {
        public List doSomething() {
            System.out.println(""this should work"");
            return null;
        }
    }

    public static void main(String[] args) {
        new C().doSomething();
    }
}
{code}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Transform loaded by wrong class loader when @GroovyASTTransformationClass(classes = ...) is used,GROOVY-5416,12816168,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,pniederw,pniederw,21/Apr/12 22:09,13/May/12 03:32,14/Jul/23 06:00,13/May/12 03:32,1.8.6,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,Compiler,,,,0,,,,,,"When @GroovyASTTransformationClass(classes = ...) is used, the transform will be loaded by CompilationUnit.classLoader rather than CompilationUnit.transformLoader. This may cause the transform not to work in environments (like Gradle) where transformLoader != classLoader.

Pull request will follow.",,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Apr 21 22:31:32 UTC 2012,,,,,,,,,,"0|i2co5r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Apr/12 22:31;pniederw;See https://github.com/groovy/groovy-core/pull/45;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static Type checker reporting invalid error,GROOVY-5415,12816123,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,mmrath,mmrath,21/Apr/12 18:53,13/May/12 03:30,14/Jul/23 06:00,02/May/12 09:45,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"{code:title=ClassA.java}

public class ClassA<T> {
    <X> Class<X> foo(Class<X> classType){
        return classType;
    }
}
{code}

{code:title=ClassB.groovy}

import groovy.transform.CompileStatic

@CompileStatic
class ClassB {
    void bar() {
        def ClassA<Long> a = new ClassA<Long>();
        a.foo(this.getClass());
    }
}
{code}

  ClassB.groovy: 13: [Static type checking] - Cannot find matching method ClassA#foo(java.lang.Class <java.lang.Object extends java.lang.Object>)
 @ line 13, column 9.
             a.foo(this.getClass());
             ^










","java 7, groovy 2.0-beta-3-snapshot",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 02 09:45:43 UTC 2012,,,,,,,,,,"0|i2c8jr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/May/12 09:45;melix;Fixed by https://github.com/groovy/groovy-core/commit/57f81009f037eb3c50376da760f4ee43662f6ef4;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovyc should emit errors when @Override is not respected,GROOVY-5413,12816222,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,btiernay,btiernay,20/Apr/12 19:51,09/Apr/14 18:40,14/Jul/23 06:00,07/Apr/14 18:58,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.3.0-beta-1,,,Compiler,,,,2,,,,,,"The following compiles without warning or error:

{code}
class OverrideAnnotatationTest {
    @Override
    def notOverriden() {}
}
{code}",,blackdrag,djh,guillaume,paulk,pschumacher,rgarcia,tweissin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5011,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 27 11:27:05 UTC 2014,,,,,,,,,,"0|i2bpf3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Apr/12 03:28;paulk;Linking to existing issue wrt properties;;;","21/Apr/12 04:01;paulk;The other question is whether to support a ""Java 5"" type mode where @Override wouldn't be allowed for interfaces but just super classes. I think we should avoid unless someone has a compelling reason.;;;","21/Apr/12 04:38;paulk;Proposed fix:
https://github.com/paulk-asert/groovy-core/commit/b7e9cd648cd13d6f88803ed556b49ddc4e18d3da
;;;","23/Apr/12 02:30;blackdrag;I don't think we need a Java5 mode. As for the patch... I think covariant returns should be ok in ExtendedVerifier. What I wonder about are generics. I think it will not work like this form them;;;","04/Jul/12 11:26;tweissin;What really is troublesome about this is, let's say you changed the base class method declaration without changing the corresponding subclass (or subclasses).  You will have no idea what method has the problem.  You also can't determine what line in the Groovy file had the problem.  You end up having to open the Java stub to work your way back to determine what Groovy function is wrong.

Here's what you may see:

[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:2.3.2:compile (default-compile) on project bar: Compilation failure: Compilation failure:
[ERROR] /foo/bar/target/generated-sources/groovy-stubs/main/com/trw/FooBar.java:[28,0] method does not override or implement a method from a supertype
;;;","06/Nov/12 07:06;djh;Any progress on this?;;;","06/Nov/12 07:20;blackdrag;@Henri does it solve the issue for you?

@Paul I think we can maybe just add this. There may be issues, but we can work them out later;;;","06/Nov/12 07:44;djh;@blackdrag This feature would make detecting refactoring issues much easier, plus one might expect Java-like behavior in this case. I don't have the means to test the patch but I assume it works as intended.;;;","27/Jan/13 05:34;pschumacher;Shouldn't we add Pauls fix?;;;","27/Jan/13 07:22;blackdrag;I assign it to Paul;;;","29/Jan/13 15:50;paulk;The other point that perhaps hasn't been clarified before is how to deal with optional parameters:
{code}
@Override
def method(int firstArg, String secondArg = 'some default') {
    ...
}
{code}
Under the covers Groovy will expand this roughly into:
{code}
@Override
def method(int firstArg) {
    method(firstArg, 'some default')
}
@Override
def method(int firstArg, String secondArg) {
    ...
}
{code}
The intention being that @Override is added to both methods. Currently there is no way to limit the annotation to occur on just one of the methods and I don't think it is in the scope of this issue to consider such cases.;;;","24/Jul/13 20:50;paulk;The proposed solution didn't handle various generics cases properly. We have since done some tidying up in that space, it might pay to rework and apply now. The optional parameters issue hasn't been discussed further.;;;","27/Mar/14 06:50;paulk;I revised the earlier solution to handle some basic generics. It is merged into master since I think it should backwards compatible in the cases it doesn't handle. It needs further work if we want it to handle all generics use cases and if we find any non b/c behavior it might be reverted. Comments welcome in the meantime.;;;","27/Mar/14 10:07;guillaume;Jeff noted the following fails (ie. compilation error), although I believe it should be allowed:
{code}
interface Foo {
    void doit(String s)
}

class MyFoo implements Foo {
    @Override
    void doit(String s = null)
}
{code};;;","27/Mar/14 11:27;blackdrag;normally we said an annotation used on methods with default arguments are used on all of the generated methods. Based on that, an error message about doit() not overriding anything would be right.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker doesn't seem to realise a non-static method won't satisfy a call from a static context,GROOVY-5411,12816207,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,aclement,aclement,17/Apr/12 14:43,13/May/12 03:30,14/Jul/23 06:00,26/Apr/12 11:08,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"Just got the 2.0 compiler into groovy-eclipse, so testing things out:

{code}
import groovy.transform.TypeChecked;


@TypeChecked
class TC {

	public static void main(String[] args) {
		foo();
	}
	
	public void foo() {}
}

{code}

No type checking error is reported here - I presume there should be one? (Since foo is not static)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 26 02:38:07 UTC 2012,,,,,,,,,,"0|i2but3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Apr/12 02:38;melix;This is indeed a stupid bug. I'm raising the priority to blocker for the next beta.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy classes can't see package-local properties from a super class,GROOVY-5396,12818157,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,tim_yates,tim_yates,05/Apr/12 04:54,01/Feb/17 23:18,14/Jul/23 06:00,26/Aug/16 00:09,1.8.6,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.8,,,Compiler,,,,0,,,,,,"If I have a standard gradle project setup (attached):

{code}
build.gradle
src/
  main/
    java/
      test/
        AbstractBase.java
        SamePackageJavaBase.java
    groovy/
      test/
        GroovyBase.groovy
        GroovyBaseWithSuper.groovy
{code}

I have a single Abstract base class:

{code:title=AbstractBase.java}
package test ;

public abstract class AbstractBase {
  int base ;

  public AbstractBase( int base ) {
    this.base = base ;
  }

  public abstract int mult( int n ) ;
}
{code}

And a class {{GroovyBase}} that extends this class:

{code:title=GroovyBase.groovy}
package test

public class GroovyBase extends AbstractBase {
  public GroovyBase( int n ) {
    super( n )
  }

  public int mult( int n ) {
    n * base
  }

  static main( args ) {
    println new GroovyBase( 10 ).mult( 3 )
  }
}
{code}

When running this (using the Gradle script in the attachment), I get the exception:

{code}
Exception in thread ""main"" groovy.lang.MissingPropertyException: No such property: base for class: test.GroovyBase
Possible solutions: class
{code}

Changing the line
{code}
    n * base
{code}

to

{code}
    n * super.base
{code}

Or making the {{base}} field public in the {{AbstractBase}} class makes it work.

It's as if the classes are considered to be in different packages for some things, but not for others.

Thinking about it, not sure if this is a Gradle bug or a Groovy cross compiler one.

To run the tests, unpack the attachment, and run:

{code}
# Test the above failing example
gradle -Pmain=test.GroovyBase
# Test the addition of super.base
gradle -Pmain=test.GroovyBaseWithSuper
# Test the Java extension of the Abstract class
gradle -Pmain=test.SamePackageJavaBase
{code}

You can change the groovy version from 1.8.6 by passing (for example) {{-Pgroovy=groovy=2.0.0-beta-2}}",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"05/Apr/12 04:54;tim_yates;FailingAbstractSuper.tgz;https://issues.apache.org/jira/secure/attachment/12722991/FailingAbstractSuper.tgz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 26 00:09:38 UTC 2016,,,,,,,,,,"0|i2cm67:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Aug/16 10:30;paulk;Not gradle related. Creating the java class file by hand leads to the same problem as does creating an equivalent groovy class file using @PackageScope for the field. And even in the same source unit as per below:
{code}
class GroovyBase extends AbstractBase {
  GroovyBase(int n) { super(n) }
  int mult(int n) { n * base }
  static main(args) { println new GroovyBase(10).mult(3) }
}

abstract class AbstractBase {
  @groovy.transform.PackageScope int base
  AbstractBase(int base) { this.base = base }
  abstract int mult(int n)
}
{code};;;","25/Aug/16 12:33;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/396

    GROOVY-5396: Groovy classes can't see package-local properties from a…

    … super class

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy5396

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/396.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #396
    
----
commit ef76efce7aa71f1e4c01cbaaa37a2f62a2fb0f3a
Author: paulk <paulk@asert.com.au>
Date:   2016-08-25T12:32:23Z

    GROOVY-5396: Groovy classes can't see package-local properties from a super class

----
;;;","26/Aug/16 00:08;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/groovy/pull/396
;;;","26/Aug/16 00:09;paulk;Finally fixed! Thanks for spotting the issue!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Grape's Grab ignores 'ext' when classifier is not set,GROOVY-5394,12816157,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,malyvelky,malyvelky,02/Apr/12 16:08,19/Sep/12 04:40,14/Jul/23 06:00,19/Sep/12 04:40,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,2.1.0-beta-1,Grape,,,,1,,,,,,"The value of ext (and also type) in Grab is only taken into account if classifier is set, I believe this to be a mistake. For example Grape cannot be used to retrieve the following artifact, which has packaging=orbit but an artifact with the extension .jar:
{code}
@Grab(group='org.eclipse.jetty.orbit', module='javax.servlet', version='3.0.0.v201112011016', ext='jar')
{code}
Therefore Grab should respect the value of ext even if classifier is not set. (And in any case it should at least report that there are some arguments that are ignored.)

Steps to reproduce:
{code}
$ groovysh
groovy:000> org.apache.ivy.util.Message.setDefaultLogger(new org.apache.ivy.util.DefaultMessageLogger(org.apache.ivy.util.Message.MSG_DEBUG));
groovy:000> groovy.grape.Grape.grab(autoDownload: true, group: 'org.eclipse.jetty.orbit', module: 'javax.servlet', version: '3.0.0.v201112011016', ext: 'jar')
{code}
See https://github.com/groovy/groovy-core/blob/master/src/main/groovy/grape/GrapeIvy.groovy#L298",,deas,malyvelky,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 19 04:40:20 UTC 2012,,,,,,,,,,"0|i2c8qv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Sep/12 16:46;paulk;fixed, thanks for raising the issue;;;","19/Sep/12 02:19;malyvelky;Hi Paul, thank you for fixing. Takk!;;;","19/Sep/12 02:20;malyvelky;BTW the ticket has no ""fix version"" set; in which version of Grape is this fixed?;;;","19/Sep/12 04:40;paulk;update fix versions;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Website code samples do not display,GROOVY-5388,12814822,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,guillaume,alpheratz,alpheratz,31/Mar/12 18:41,13/May/12 03:30,14/Jul/23 06:00,02/Apr/12 10:51,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,"*I* would rate this as MAJOR/BLOCKER.

In IE8 (either plain or compatibility modes) and Firefox 7.0.1, when I browse to ANY page with code examples, I see no code. 

See attached.

I can't even copy/paste hidden text. The code IS in the source...just not shown. 

I note that the code blocks are wrapped in <script type=""syntaxhilighter""> tags so a javascript bug?

It was pointed out to me when I sent a colleague to look at:

http://groovy.codehaus.org/Reading+XML+using+Groovy's+XmlSlurper

With IE8 this is an issue for nearly all code examples on the site...except on the front page, which are formatted differently!

In Recent FF/Safari 5/IE 9.0.8xxx (native mode) all is OK. But of course, IE8 (recently updated from IE6) is the corporate standard for the organisation I am currently at...

Thus my comment about the bug being major/blocker priority. As my colleagues throw at me: ""Why adopt a technology from a group that can't even make a working website?"" Not my words. And yes, harsh. Makes my evangelising rather hard/futile.

Thought I'd seen this happen before...in the early days of the last site makover. Thought it was fixed? my recollection says that it is something that the mysterious ""Codehaus Site Administrators"" have to take a look at?

I posted at http://groovy.329449.n5.nabble.com/Website-code-samples-missing-td5602131.html but heard nothing, hence opened this JIRA.

Cheers,

BOB

","IE8, FF7.0.1, IE9 (compat mode)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"31/Mar/12 18:41;alpheratz;nocode.png;https://issues.apache.org/jira/secure/attachment/12723021/nocode.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 03 04:40:34 UTC 2012,,,,,,,,,,"0|i2c64f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Apr/12 10:51;guillaume;I think I've fixed the issue for now.
I've tested that on a Windows 7 VM with Internet Explorer 8.
I'm gonna close the issue, but please reopen if the problem persist.
I've made a check for the browser, and blindly check if it's IE, but perhaps IE 9 doesn't need that, so I perhaps need a smarter IE version check than I've implemented.
Please IE users, tell me how it goes on different versions of IE.
Thanks.;;;","02/Apr/12 18:13;paulk;At one customer site with IE8 (on Windows Server 2008 R2) I still get:
{noformat}
Webpage error details

User Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET4.0C; .NET4.0E; .NET CLR 3.5.30729; .NET CLR 3.0.30729)
Timestamp: Mon, 2 Apr 2012 23:11:25 UTC

Message: 'jQuery' is undefined
Line: 12
Char: 1
Code: 0
URI: http://groovy.codehaus.org/js/jquery.jBreadCrumb.1.1.js

Message: Object expected
Line: 4
Char: 1
Code: 0
URI: http://groovy.codehaus.org/js/pageLookup.js
{noformat};;;","03/Apr/12 04:40;guillaume;It looks as if the jQuery library isn't being loaded.
Perhaps there's a proxy issue or some security setting which disallow loading javascript scripts from remote locations.
I was using the Google hosting of JavaScript libraries, and now switched to serving my own jQuery library right from the Groovy server instead.
Could you please check if it's working any better now?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Delegate - sometimes compilation fails for generic types,GROOVY-5386,12816202,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,andre.steingress,andre.steingress,29/Mar/12 05:55,28/May/14 03:04,14/Jul/23 06:00,22/May/14 06:29,1.8.6,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.5,,,Compiler,,,,0,,,,,,"we have some classes using @Delegate on generic classes:

@Commons
class FilterList {

@Delegate List<Map<Dimension, List<String>>> filterList = []

...
}

Sometime compilation fails with compiler errors like 

BUG! exception in phase 'class generation' in source unit '/Users/andre/Development/Projects/Adternity/grf/grails-app/jobs/com/grf/reports/ScheduledReportExecutionJob.groovy' Type is null. Most probably you let a transform reuse existing ClassNodes with generics information, that is now used in a wrong context. (Use --stacktrace to see the full trace)

I assume this has to do with DelegateASTTransformation#nonGeneric handling of generic types, which is setting the generic type to null, but it's hard to reproduce the error in a determined way.",JVM: 1.6.0_29 Vendor: Apple Inc. OS: Mac OS X,dilbert99,melix,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/May/14 17:56;dilbert99;delegate-bug.zip;https://issues.apache.org/jira/secure/attachment/12723179/delegate-bug.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 22 06:37:16 UTC 2014,,,,,,,,,,"0|i2c15b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Mar/12 07:55;andre.steingress;I've just seen that DelegateASTTransformation uses a new ClassNode instance, so the compiler error above shouldn't come from that place, am I right?;;;","29/Mar/12 10:28;melix;What is the {{@Commons}} annotation? Is it an AST xform too?;;;","29/Mar/12 10:34;andre.steingress;Yep, http://groovy.codehaus.org/api/groovy/util/logging/Commons.html;;;","29/Mar/12 10:38;andre.steingress;I did a simple lookup to find all the usages of setGenericTypes in groovy-core. The only two ast xforms directly calling this method are:

DelegateASTTransformation
ListenerListASTTransformation

Hm, I think the error above did not occur before introducing @Delegate - but of course I could be wrong and it is caused by some Grails xform.;;;","29/Mar/12 10:59;melix;Does it happen in a plain Groovy project too? Grails also performs transparent AST transformations which could be in action here.;;;","09/May/12 08:33;andre.steingress;I'll try to reproduce it in a standalone Groovy project as we're running into this issue now regularly, which is pain because the programmer (including me ;)) needs to clean and recompile the Grails project.

{code}

| Packaging Grails application
| Packaging Grails application.
| Packaging Grails application..
| Packaging Grails application...
| Packaging Grails application....
| Packaging Grails application.....
| Compiling 11 source files
| Compiling 11 source files.
| Error Fatal error during compilation org.apache.tools.ant.BuildException: BUG! exception in phase 'class generation' in source unit '/super/secret/XXX.groovy' Type is null. Most probably you let a transform reuse existing ClassNodes with generics information, that is now used in a wrong context. (Use --stacktrace to see the full trace)
{code};;;","09/May/12 08:34;andre.steingress;It seems to me that this issue occurs when recompiling classes with a reference to already compiled @Delegate classes. But as I've said before, I'll try to reproduce it...;;;","09/May/12 09:04;andre.steingress;Here is the full stracktrace, just for the record:

{code}
	at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:96)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureTypeArguments(Java5.java:157)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureParameterizedType(Java5.java:137)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:88)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeClassNode(Java5.java:384)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeInterfaceTypes(Java5.java:365)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:348)
	at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:262)
	at org.codehaus.groovy.ast.ClassNode.getUnresolvedSuperClass(ClassNode.java:974)
	at org.codehaus.groovy.ast.ClassNode.getUnresolvedSuperClass(ClassNode.java:969)
	at org.codehaus.groovy.ast.ClassNode.getSuperClass(ClassNode.java:963)
	at org.codehaus.groovy.ast.ClassNode.getPlainNodeReference(ClassNode.java:1369)
	at org.codehaus.groovy.classgen.asm.ClosureWriter.createClosureClass(ClosureWriter.java:262)
	at org.codehaus.groovy.classgen.asm.ClosureWriter.getOrAddClosureClass(ClosureWriter.java:144)
	at org.codehaus.groovy.classgen.asm.ClosureWriter.writeClosure(ClosureWriter.java:71)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClosureExpression(AsmClassGenerator.java:540)
	at org.codehaus.groovy.ast.expr.ClosureExpression.visit(ClosureExpression.java:43)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.makeCallSite(CallSiteWriter.java:301)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:187)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:89)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:73)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:292)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:657)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:75)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:599)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:354)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:503)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:80)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:155)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:449)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeTryCatchFinally(StatementWriter.java:315)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitTryCatchFinally(AsmClassGenerator.java:473)
	at org.codehaus.groovy.ast.stmt.TryCatchStatement.visit(TryCatchStatement.java:42)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:80)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:155)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:449)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:313)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:270)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:390)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:174)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:767)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:967)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:546)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:524)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:501)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:480)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:60)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:216)
	at org.codehaus.groovy.ant.Groovyc.compile(Groovyc.java:909)
{code};;;","11/May/14 05:55;pschumacher;Does this error still occur with recent versions of groovy? Or can we close this?;;;","20/May/14 06:31;dilbert99;Issue is still occurring in Groovy 2.3.0

Exception in thread ""main"" BUG! exception in phase 'class generation' in source unit 'SimpleTemplateScript1.groovy' Type is null. Most probably you let a transform reuse existing ClassNodes with generics information, that is now used in a wrong context.
	at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:122)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureTypeArguments(Java5.java:183)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureParameterizedType(Java5.java:163)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:114)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeClassNode(Java5.java:411)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeInterfaceTypes(Java5.java:392)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:375)
	at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:258)
	at org.codehaus.groovy.ast.ClassNode.getInterfaces(ClassNode.java:353)
	at org.codehaus.groovy.ast.ClassNode.declaresInterface(ClassNode.java:945)
	at org.codehaus.groovy.ast.ClassNode.implementsInterface(ClassNode.java:925)
	at org.codehaus.groovy.ast.ClassNode.isDerivedFromGroovyObject(ClassNode.java:915)
	at org.codehaus.groovy.classgen.AsmClassGenerator.isGroovyObject(AsmClassGenerator.java:1111)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitPropertyExpression(AsmClassGenerator.java:1066)
	at org.codehaus.groovy.ast.expr.PropertyExpression.visit(PropertyExpression.java:55)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitGStringExpression(AsmClassGenerator.java:1884)
	at org.codehaus.groovy.ast.expr.GStringExpression.visit(GStringExpression.java:50)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.makeCallSite(CallSiteWriter.java:301)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCachedCall(InvocationWriter.java:245)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:329)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:76)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:60)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:382)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:650)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:64)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:604)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:354)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:511)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:81)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:155)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:457)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:321)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:278)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:398)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1055)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:180)
	at org.codehaus.groovy.control.CompilationUnit$15.call(CompilationUnit.java:794)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1036)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:572)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:550)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:527)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:279)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:258)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:613)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:625)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:652)
	at groovy.text.SimpleTemplateEngine.createTemplate(SimpleTemplateEngine.java:123)
	at groovy.text.TemplateEngine.createTemplate(TemplateEngine.java:38)
	at groovy.text.TemplateEngine$createTemplate.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at net.clockworkcode.ps.ReportGenerator.generate(ReportGenerator.groovy:20)
	at net.clockworkcode.ps.ReportGenerator$generate.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
	at net.clockworkcode.ps.RunSubAnalyser.process(RunSubAnalyser.groovy:135)
	at net.clockworkcode.ps.RunSubAnalyser$process.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
	at net.clockworkcode.ps.RunSubAnalyser.main(RunSubAnalyser.groovy:120)
;;;","20/May/14 06:43;blackdrag;I fixed a generics issue for @Delegate in 2.3.1. Could you test that one?;;;","20/May/14 07:02;paulk;Any chance you could try 2.3.1? There was one additional generics fix for @Delegate in that release.;;;","20/May/14 07:03;paulk;Oops, yes what blackdrag said.;;;","20/May/14 08:27;dilbert99;I still get the same error with groovy 2.3.1

The error does arise using SimpleTemplateEngine to create some html...;;;","20/May/14 08:35;dilbert99;One thing though, I get the error when I am doing a maven package running tests in Intellij, but don't get the error when running the test directly via Intellij.;;;","20/May/14 17:56;dilbert99;Hi Paul, 

I've attached a sample project that generates the delegate bug
;;;","21/May/14 00:56;paulk;Changing to {{@Delegate(interfaces=false)}} seems to avoid the problem (hinting where the issue lies) and indeed it looks like the very last added interface (which is {{List}} in your case) isn't corrected for generics. However, I fixed that and the problem remains. We'll need to explore further.;;;","21/May/14 04:35;paulk;I made the obvious change alluded to in my last comment. If you get a chance to try a snapshot version, it would be interesting to see if you get anything different. In my system it still failed but perhaps I didn't manipulate the maven environment appropriately. I was using a SNAPSHOT version and perhaps some caching of the artifacts came into play.;;;","21/May/14 06:10;dilbert99;Tried 2.3.2-SNAPSHOT (and 2.4.0-SNAPSHOT) and got the same error.
Adding @Delegate(interfaces=false) made the error go away. (But also stops left shift operator for adding to list from compiling)
(Well went away for the sample class I attached to this card, but not in my real program using SimpleTemplateEngine);;;","21/May/14 06:27;melix;The 2.4 build which includes the latest changes from Paul finished 16 minutes ago and there's still no 2.3.X snapshot including the fix available, so worth double checking by invalidating the cache...

(for reference http://ci.groovy-lang.org/viewType.html?buildTypeId=Groovy_BintrayIntegration_UploadSnapshots&guest=1);;;","21/May/14 06:48;dilbert99;Was looking at the snapshots for groovy-all via - https://oss.jfrog.org/oss-snapshot-local/org/codehaus/groovy/groovy-all/

and pulling them in using maven repo <url>http://oss.jfrog.org/artifactory/oss-snapshot-local</url>;;;","21/May/14 06:58;dilbert99;Deleted the snapshot so that It would download again and cleared out the target folder

...
Downloading: http://oss.jfrog.org/artifactory/oss-snapshot-local/org/codehaus/groovy/groovy-all/2.4.0-SNAPSHOT/groovy-all-2.4.0-20140521.103323-16.jar
...
xception in thread ""main"" BUG! exception in phase 'class generation' in source unit '/Users/david/work_temp/runsub/zips/code/delegate-bug/src/test/groovy/net/clockworkcode/ps/DelegateTest.groovy' Type is null. Most probably you let a transform reuse existing ClassNodes with generics information, that is now used in a wrong context.
	at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:96)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureTypeArguments(Java5.java:157)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureParameterizedType(Java5.java:137)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:88)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeClassNode(Java5.java:384)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeInterfaceTypes(Java5.java:365)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:348)
	at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:262)
	at org.codehaus.groovy.ast.ClassNode.getInterfaces(ClassNode.java:356)
	at org.codehaus.groovy.ast.ClassNode.declaresInterface(ClassNode.java:946)
	at org.codehaus.groovy.ast.ClassNode.implementsInterface(ClassNode.java:926)
	at org.codehaus.groovy.ast.ClassNode.isDerivedFromGroovyObject(ClassNode.java:916)
	at org.codehaus.groovy.classgen.AsmClassGenerator.isGroovyObject(AsmClassGenerator.java:1090)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitPropertyExpression(AsmClassGenerator.java:1047)
	at org.codehaus.groovy.ast.expr.PropertyExpression.visit(PropertyExpression.java:55)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.prepareSiteAndReceiver(CallSiteWriter.java:232)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.prepareSiteAndReceiver(CallSiteWriter.java:221)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.makeCallSite(CallSiteWriter.java:270)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:187)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:89)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:73)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:292)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:655)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:75)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:599)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:354)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:501)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:80)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:155)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:447)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:311)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:268)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:388)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:172)
	at org.codehaus.groovy.control.CompilationUnit$14.call(CompilationUnit.java:767)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:967)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:546)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:524)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:501)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:480)
	at org.codehaus.gmaven.runtime.v1_8.ClassCompilerFeature$ClassCompilerImpl.compile(ClassCompilerFeature.java:148)
	at org.codehaus.gmaven.plugin.compile.AbstractCompileMojo.compile(AbstractCompileMojo.java:211)
	at org.codehaus.gmaven.plugin.compile.AbstractCompileMojo.process(AbstractCompileMojo.java:175)
	at org.codehaus.gmaven.plugin.ComponentMojoSupport.doExecute(ComponentMojoSupport.java:60)
	at org.codehaus.gmaven.plugin.compile.TestCompileMojo.doExecute(TestCompileMojo.java:90)
	at org.codehaus.gmaven.plugin.MojoSupport.execute(MojoSupport.java:71)
	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:106)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:317)
	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:152)
	at org.apache.maven.cli.MavenCli.execute(MavenCli.java:555)
	at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:214)
	at org.apache.maven.cli.MavenCli.main(MavenCli.java:158)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)
	at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)
	at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)
	at org.codehaus.classworlds.Launcher.main(Launcher.java:46)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)


Wonder why the above fails when testing via maven but running test via Intellij's runner passes?;;;","22/May/14 02:47;blackdrag;David, I looked a bit more closely at this last stacktrace and AsmClassGenrator line 1090 is not the method isGroovyObject in 2.4. The line org.codehaus.gmaven.runtime.v1_8.ClassCompilerFeature$ClassCompilerImpl.compile let's me believe you are actually using Groovy 1.8 here;;;","22/May/14 03:57;dilbert99;That would explain why it works in intellij which is using the maven dependency from the main section of the pom
but fails to work when using maven to do the compile it is using the gmaven plugin which has a provider set to 1.8, I can change this to 2.0 but still get the bug.

Is there a gmaven plugin that supports later versions of groovy than 2.0 or an alternative to graven plugin?;;;","22/May/14 04:56;dilbert99;I was able to get the code compiled with groovyc rather than gmaven-plugin and the code compiles and runs successfully using 2.4.0-SNAPSHOT

For info, you can replace your gmaven-plugin with:

{code:xml}
            <plugin>
                <artifactId>maven-antrun-plugin</artifactId>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <configuration>
                            <tasks>
                                <taskdef name=""Groovydoc"" classname=""org.codehaus.groovy.ant.Groovydoc"">
                                    <classpath>
                                        <path refid=""maven.compile.classpath""/>
                                    </classpath>
                                </taskdef>

                                <Groovydoc destdir=""target/apidocs"" sourcepath=""src/main/groovy"" packagenames=""**.*""
                                           use=""true""
                                           windowtitle=""Groovydoc"" private=""false""/>
                            </tasks>
                        </configuration>
                        <goals>
                            <goal>run</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>compile</id>
                        <phase>compile</phase>
                        <configuration>
                            <tasks>
                                <mkdir dir=""${basedir}/src/main/groovy""/>
                                <taskdef name=""groovyc""
                                         classname=""org.codehaus.groovy.ant.Groovyc"">
                                    <classpath refid=""maven.compile.classpath""/>
                                </taskdef>
                                <mkdir dir=""${project.build.outputDirectory}""/>
                                <groovyc destdir=""${project.build.outputDirectory}""
                                         srcdir=""${basedir}/src/main/groovy/"" listfiles=""true"">
                                    <classpath refid=""maven.compile.classpath""/>
                                </groovyc>
                            </tasks>
                        </configuration>
                        <goals>
                            <goal>run</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>test-compile</id>
                        <phase>test-compile</phase>
                        <configuration>
                            <tasks>
                                <mkdir dir=""${basedir}/src/test/groovy""/>
                                <taskdef name=""groovyc""
                                         classname=""org.codehaus.groovy.ant.Groovyc"">
                                    <classpath refid=""maven.test.classpath""/>
                                </taskdef>
                                <mkdir dir=""${project.build.testOutputDirectory}""/>
                                <groovyc destdir=""${project.build.testOutputDirectory}""
                                         srcdir=""${basedir}/src/test/groovy/"" listfiles=""true"">
                                    <classpath refid=""maven.test.classpath""/>
                                </groovyc>
                            </tasks>
                        </configuration>
                        <goals>
                            <goal>run</goal>
                        </goals>
                    </execution>

                </executions>
            </plugin>
{code};;;","22/May/14 05:18;dilbert99;For me at least, I find that the following bug
{noformat}BUG! exception in phase 'class generation' in source unit 'SimpleTemplateScript1.groovy' Type is null. Most probably you let a transform reuse existing ClassNodes with generics information, that is now used in a wrong context.{noformat}
was fixed in 2.0.5
The issue I was having seems to be with gmaven only supporting compilation up to version 2.0.0;;;","22/May/14 06:37;pschumacher;@David:

You can use gmavenplus or the groovy-eclipse-batch compiler instead of gmaven.;;;",,,,,,,,,,,,,,,,,,
"StackOverflow Exception when calling super.method, which returns an instance of the corresponding class. ",GROOVY-5385,12818155,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,stefan_leo,stefan_leo,29/Mar/12 05:51,15/Oct/15 18:19,14/Jul/23 06:00,20/Nov/13 08:09,1.7.10,1.8.6,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.1,,,groovy-jdk,,,,2,,,,,,"You get a StackOverflow Exception when running following code:

{code:title=A.groovy|borderStyle=solid}
abstract class A {
    A attach(){
        System.out.println( ""A does something else"");
        return this;
    }
}
{code}
{code:title=B.groovy|borderStyle=solid}
class B extends A {
    @Override
    B attach(){
        System.out.println(""B does something else"");
        return (B) super.attach();
    }
}
{code}
{code:title=C.groovy|borderStyle=solid}
class C extends B {
    @Override
    C attach(){
        System.out.println(""C does something else"");
        return (C) super.attach();
    }
}
{code}

{code:title=Test.groovy|borderStyle=solid}
C c = new C(); c.attach();
{code}

This bug only occurs when the depth of the class hierarchy exceeds two classes.
Moreover this bug seems depend on the method name! If you try {{attachMe()}} as method name the Stackoverflow Exception won't be raised.
The whole ErrorOutput can be found attached.

{code:title=Error.output|borderStyle=solid}
C does something else
C does something else
C does something else
C does something else
Exception in thread ""main"" java.lang.StackOverflowError
	at groovy.lang.MetaClassImpl.getMetaProperty(MetaClassImpl.java:2441)
	at groovy.lang.MetaClassImpl.getMetaProperty(MetaClassImpl.java:2415)
	at groovy.lang.MetaClassImpl.getProperty(MetaClassImpl.java:1510)
	at groovy.lang.MetaClassImpl.getProperty(MetaClassImpl.java:3308)
	at org.codehaus.groovy.runtime.callsite.ClassMetaClassGetPropertySite.getProperty(ClassMetaClassGetPropertySite.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGetProperty(AbstractCallSite.java:227)
	at C.attach(C.groovy:20)
	at C.attach(C.groovy)
	at B.attach(B.groovy)
	at C.super$3$attach(C.groovy)
	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1047)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:128)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuper0(ScriptBytecodeAdapter.java:148)
{code}




","Windows 7, IntelliJ IDEA",andrewrs,blackdrag,evox,paulk,stefan_leo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Mar/12 05:51;stefan_leo;erroroutput.txt;https://issues.apache.org/jira/secure/attachment/12722605/erroroutput.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 24 11:22:29 UTC 2014,,,,,,,,,,"0|i2ca93:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Mar/12 23:18;paulk;Had a quick look at this. Groovy is creating bridge methods for each covariant return type, e.g. for class C, the methods ""A attach()"", ""B attach()"" are added in addition to the one in the class itself, i.e. ""C attach()"". Depending on the order these are placed in the file, you will get strange behaviour. The workaround is to have A as your return type everywhere for the ""attach"" method.;;;","30/Mar/12 07:57;stefan_leo;Thank you for the reply.
We already make use of this workaround. Nevertheless we do not want to force the users of our classes to work with explicit casts everytime.
Will this one be fixed?;;;","01/Apr/12 14:50;paulk;Yes, the intention is to fix it - it may overlap with GROOVY-5352, so fixing one might fix the other if we do the fix right.;;;","19/Nov/13 09:47;blackdrag;I compared with Java and Java also creates those two bridge methods. So it must be something else.;;;","19/Nov/13 10:10;blackdrag;looking at this more the problem is the following: C.super$3$attach does INVOKESPECIAL B.attach ()LA; and B.attach()LA; is correctly doing an invokevirtual for attach, which will pick up the version of C. The super$3$attach method has instead to invoke B.attach()LB;, never the bridge method. Then the stack overflow will not happen;;;","20/Nov/13 08:09;blackdrag;fixed;;;","24/May/14 11:22;evox;Hi guys,

I have exactly the same issue by using Groovy 2.2.2.. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Type checker doesn't infer generics properly,GROOVY-5384,12811949,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,28/Mar/12 14:18,13/May/12 03:30,14/Jul/23 06:00,29/Mar/12 10:23,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,,,,,0,,,,,,"In the following code, the computed lowest upper bound of the list doesn't have the correct type.

{code}
class Test {
    static test2() {
        if (new Random().nextBoolean()) {
            def a = new ArrayList<String>()
            a << ""a"" << ""b"" << ""c""
            return a
        } else {
            def b = new LinkedList<Number>()
            b << 1 << 2 << 3
            return b
        }
    }

    static test() {
        def result = test2()
        result[0].toInteger()
        //result[0].toString()
    }
}
new Test()
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 29 10:23:44 UTC 2012,,,,,,,,,,"0|i2chlz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Mar/12 10:23;melix;Fixed by commits:
* https://github.com/groovy/groovy-core/commit/25c2a19a36e927c268898bd181df0920b52ec970
* https://github.com/groovy/groovy-core/commit/5d2cdfd86813217e5ca8d05f503e008fea059f66
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@ListenerList changes the ArrayList classnode generics,GROOVY-5383,12816120,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,28/Mar/12 14:14,13/May/12 03:30,14/Jul/23 06:00,29/Mar/12 10:24,1.8.6,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,,,,,0,,,,,,"The {{@ListenerList}} AST transformation changes the generic types associated to the cached ArrayList class node. This is wrong because it has side effects on the subsequent compîlations.

This

{code}
def listenerListType = ClassHelper.make(ArrayList)
listenerListType.setGenericsTypes(types)
{code}

must be replaced with:

{code}
def listenerListType = ClassHelper.make(ArrayList).plainNodeReference
listenerListType.setGenericsTypes(types)
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 29 10:24:07 UTC 2012,,,,,,,,,,"0|i2bo1b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Mar/12 10:24;melix;Commit https://github.com/groovy/groovy-core/commit/715ce09cedbb46244682dc3146ebc3c36541ef26;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CLONE - Incomprehensible Error Message Passing Partial Evaluated Lambda Function (improved error message for normal closure not on classpath case),GROOVY-5377,12816166,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,russel,russel,21/Mar/12 03:00,04/May/12 23:58,14/Jul/23 06:00,04/May/12 23:58,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,SQL processing,,,,0,,,,,,"When executing the code:
{code}
#! /usr/bin/env groovy

import groovy.sql.DataSet
import groovy.sql.Sql

@Grab ( 'org.xerial:sqlite-jdbc:3.7.2' )
@GrabConfig ( systemClassLoader = true )
def database
final words = [ ]
try {
  database = Sql.newInstance ( 'jdbc:sqlite:database.db' , 'org.sqlite.JDBC' )
  final wordsTable = new DataSet ( database , 'words' )
  ( 0 ..< 4 ).each { i ->
    words << wordsTable.findAll ( { j , item -> item.id == j }.curry ( i ) ).firstRow ( ).word
  }
}
finally {
  database?.close ( )
}
println words.join ( '' )
{code}
the result is the error:
{quote}
Caught: groovy.lang.GroovyRuntimeException: Could not find the ClassNode for MetaClass: groovy.lang.MetaClassImpl@6c1826dc[class org.codehaus.groovy.runtime.CurriedClosure]
groovy.lang.GroovyRuntimeException: Could not find the ClassNode for MetaClass: groovy.lang.MetaClassImpl@6c1826dc[class org.codehaus.groovy.runtime.CurriedClosure]
{quote}
which doesn't really tell the programmer anything useful about the executed code they wrote.
",,paulk,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5376,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 04 23:58:47 UTC 2012,,,,,,,,,,"0|i2bonr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Mar/12 06:42;paulk;So, I was going to propose the current error message changes as per the example below. Assume you have some closure where the source is not available:
{code}
def closure = new GroovyShell().evaluate(""def c = { p -> p.lastname == 'Smith' }; c"")
println people.findAll(closure).sql
{code}
which currently reports the following error:
{noformat}
Could not find the ClassNode for MetaClass: org.codehaus.groovy.runtime.metaclass.ClosureMetaClass@1fe571f[class Script1$_run_closure1]
{noformat}
I propose it would become:
{noformat}
DataSet unable to evaluate expression. AST not available for closure: Script1$_run_closure1. Is the source code on the classpath?
{noformat}
;;;","21/Mar/12 07:42;blackdrag;+1;;;","21/Mar/12 08:07;russel;As an error message it certainly works better.

Is there any way of avoiding this situation being a thing Groovy cannot cope with?;;;","21/Mar/12 14:35;paulk;We have tried various ways of storing away the AST and the simple ways run into problems like 64K String limitations and such. I am sure it can be done and it is something we'd like to do but it hasn't yielded to simple solutions so far. (I thought there was an existing Jira issue but couldn't find it just now with a very quick search.);;;","21/Mar/12 17:59;paulk;error message added;;;","23/Mar/12 02:46;russel;Seems to works as anticipated.;;;","04/May/12 23:58;paulk;added ""Component"" to improve future searching ease;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@TypeChecked does not recognize @Log annotation,GROOVY-5374,12816065,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,hamletdrc,hamletdrc,20/Mar/12 04:29,15/Nov/12 00:21,14/Jul/23 06:00,20/Mar/12 06:50,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,,,,,0,,,,,,"@TypeChecked rejects code that uses the @Log annotation. It should not. 


This code does not compile but should: 
{code}

import groovy.util.logging.Log
import groovy.transform.TypeChecked

@Log
class Example1 {

    @TypeChecked
    void method(String message) {
      log.info(message)
    }
}
{code}",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 15 00:21:57 UTC 2012,,,,,,,,,,"0|i2bwun:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Mar/12 05:37;melix;Fix should come soon. Actually, the problem is in the various @Log transformations, which do not create class nodes the proper way.;;;","20/Mar/12 06:50;melix;Fixed by changing the way the various @Log transforms load the class nodes.

See https://github.com/groovy/groovy-core/commit/e547a7c31904b0dc6af9e1a6f53c429c5007e37c;;;","15/Nov/12 00:21;sworisbreathing;The fixes for this issue don't appear to have made it into the groovy-all-2.0.5.jar in maven central.  Were they overwritten somewhere along the way?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sql DataSet fails to work with non-literals in queries (fix error message/doco),GROOVY-5371,12818154,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,russel,russel,17/Mar/12 06:24,23/Mar/12 02:47,14/Jul/23 06:00,19/Mar/12 18:19,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,,,,,0,,,,,,"All the examples of using _findAll_ in the _Sql_ _DataSet_ class use literals for the search values of queries. Using free variables causes failure as Groovy does not implement lexical closure automatically.  However this can be realized using the Closure delegate field. I therefore believe that the following example fails because the _Sql.SqlWhereVisitor_ fails to lookup variables but assumes that all query values are literals.
{code}
import groovy.sql.DataSet
import groovy.sql.Sql

@Grapes ( [    
            @Grab ( 'org.xerial:sqlite-jdbc:3.7.2' ),
            @GrabConfig ( systemClassLoader = true )
          ] )
def database
final words = [ ]
try {
  database = Sql.newInstance ( 'jdbc:sqlite:database.db' , 'org.sqlite.JDBC')
  final wordsTable = new DataSet ( database , 'words' )
  ( 0 ..< 4 ).each { i ->
    final query = { item -> item.id == i }
    query.delegate = { i : i }
    query.resolveStrategy = Closure.DELEGATE_FIRST 
    words << wordsTable.findAll ( query ).firstRow ( ).word
  }
}
finally {
  database?.close ( )
}
println words.join ( '' )
{code}",,paulk,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5373,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 23 02:47:59 UTC 2012,,,,,,,,,,"0|i2cg1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Mar/12 00:33;paulk;Just a small aside: You don't need the @Grapes annotation in your example above - just the @Grab and @GrabConfig should suffice.;;;","18/Mar/12 01:13;paulk;I think this issue conflates two aspects. It seems to me that I can ""resolve"" the issue by detecting when non-literals are used in the right-hand side of DataSet findAll statements and generate an appropriate warning indicating that such expressions aren't supported. If you are trying to solve the bigger issue about Closures, then I would rename the issue and give other simpler examples which illustrate the point. Given that DataSet has limitations, it doesn't really help much as an example in this discussion.;;;","18/Mar/12 09:07;russel;So when is @Grapes needed?;;;","18/Mar/12 09:10;russel;I am not sure right-hand and left-hand is important here --  ""it.id == x"" and ""x == it.id"" should behave the same.

I think the above example is independent of the general Closure debate, since it provides a delegate that should resolve the ""free variable"".  I think the point here is that the findAll evaluator doesn't do resolution at all, it assumes that the value is a literal.  Isn't this just wrong? ;;;","19/Mar/12 07:40;paulk;Re: ""{{@Grapes}}"": I would like to say {{@Grapes}} is never needed now but that isn't quite true. There are two reasons for its existence.

One is to do with JVM limitations regarding having multiple Grab annotations of the same name, e.g. in {{java.lang.Class#getAnnotation(Class)}} a single annotation is returned. We have worked around that limitation for now.

The second reason is to do with eventually supporting fine-grained control over {{Grab}} settings, e.g. you might want {{GrabResolver}} or {{GrabConfig}} to apply to just one of your {{Grab}}'s not all of them. This is where {{Grapes}} would come in, however at the moment, all of those settings are global across all {{Grab}}'s.;;;","19/Mar/12 08:19;blackdrag;As for the query. Russel, how we construct this atm is by getting the AST from source for this, evaluate the ast to a sql query and execute that query. This translation cannot and will probably never handle complex expressions. The case at hand here though is about a local variable being used. And such a case should be supported. But that doesn't make this a critical bug, but a RFE. If anything here is a bug, than that unhandled cases are silently accepted. imho that should cause an exception.;;;","19/Mar/12 08:30;paulk;_Re: ""right-hand vs left-hand"":_

You are correct, it shouldn't be important though the current implementation makes a distinction - don't have time to try it tonight - I suspect it may just produce an expression with an unneeded set of brackets in one case.

_Re: ""I think the point here is that the findAll evaluator doesn't do resolution at all, it assumes that the value is a literal. Isn't this just wrong?""_

I guess I am just saying ""wrong"" is in the eye of the beholder. Groovy can provide a limited functionality DataSet if it wants. It will probably still cover many of the typical queries that people do but obviously not all. What we currently have though is a limited functionality mechanism with some secondary issues (poor error messages and inadequate documentation). I tend to agree with you that we do want to fix this properly but am reminding myself that perhaps removing the secondary issues in the meantime might also be a useful step forward.
;;;","19/Mar/12 16:47;paulk;OK, just confirmed my suspicions, there is a slight different treatment of left- and right-hand sided literals but it makes no practical difference. Here is an example:
{code}
def found1 = projects.findAll{ it.id < 35 && it.id > 15 }
println found1.sql // => select * from project where (id < ? and id > ?)
def found2 = projects.findAll{ 35 > it.id && it.id > 15 }
println found2.sql // => select * from project where ((? > id) and id > ?)
{code}
So we can remove this difference in treatment if we want.;;;","19/Mar/12 18:07;paulk;Issue cloned and split out into ""fix current error message/doco"" and ""do the enhancement"".;;;","19/Mar/12 18:17;paulk;Currently, DataSet produces invalid Sql and silently continues on resulting in the user getting a strange error message at some point in the future. If we currently don't support particular expressions which cause such behaviour, we should produce a suitable error message at the point where the unsupported expression is discovered.;;;","19/Mar/12 18:19;paulk;Error message added and doco tweaked. Please continue discussions about the desired DataSet enhancement on GROOVY-5373. Thanks.;;;","20/Mar/12 07:46;russel;The error message works for me.;;;","23/Mar/12 02:47;russel;Seems to work as anticipated.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closure property in Binding used as Closure delegate cannot be called,GROOVY-5367,12816161,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,wujek,wujek,15/Mar/12 15:03,29/Jan/22 18:39,14/Jul/23 06:00,27/May/21 22:40,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,3.0.10,4.0.0-beta-1,,groovy-runtime,,,,1,,,,,,"In a script, this works:

c = { println 'works' }
c()

whereas this one doesn't:

def bind = new Binding(c: { println 'does not work' })
def t = { c() }
t.delegate = bind
t()

They both define a 'c' property in the binding which happens to be a closure. In the first case, the closure get's called as Groovy apparently tries to get the binding property and invoke it if it's a closure; in the latter, the delegate of the closure is a binding with a property 'c' that is a closure, but c() still doesn't work.

I debugged this and there is actually an if in MetaClassImpl that checks if the 'this' object is a Script, and if so, a property with the name is retrieved and a call() method is called. (MetaClassImpl#invokePropertyOrMissing:1089 in Groovy 1.8.6-all from maven central).",,blackdrag,jboone,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 31 17:01:12 UTC 2012,,,,,,,,,,"0|i2cez3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"15/Mar/12 15:04;wujek;Here is a short conversation and a bug request from the mailing list:
http://groovy.329449.n5.nabble.com/Binding-Closure-property-not-called-as-method-td5562137.html;;;","31/Jul/12 13:59;jboone;There is a workaround for this issue.  It's a bit of a hack but is valid in most cases.  Simply bind the closures to the Binding.metaClass (see below):

CODE:
Binding.metaClass.c = {exclamation -> println ""$a Yipee $exclamation "" }

def t = { c(' !!! :) ') }
t.delegate = [a : 'It works'] as Binding
t()

OUTPUT:
It works Yipee  !!! :);;;","31/Jul/12 17:01;blackdrag;from debugging the code I can now see, that this kind of operation is only allowed of the delegate is a GroovyObject, and even then only for normal properties, getProperty or missingProperty won't be called.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
unable to add assertions via compile time transform,GROOVY-5366,12816121,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ldaley,ldaley,15/Mar/12 09:46,18/Jan/13 16:06,14/Jul/23 06:00,17/Jan/13 15:32,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.7,2.1.0,2.1.0-rc-2,ast builder,,,,0,contrib,,,,,See: http://groovy.329449.n5.nabble.com/Problem-with-implicit-assertion-transform-td5568080.html,,andre.steingress,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 17 15:32:02 UTC 2013,,,,,,,,,,"0|i2ce7r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Mar/12 02:38;andre.steingress;AssertionWriter breaks whenever assertStatement.messageExpression != ConstantExpression.NULL and no sourcePosition has been set via assertStatement.sourcePosition.

Without a sourcePosition this line

{code}
assertionTracker.sourceText = new SourceText(statement, controller.getSourceUnit(), janitor);
{code}

in AssertionWriter fails, thus sourceText stays null. Although AssertionWriter failed to get the sourceText it seems its still called at further compilation points with AssertionWriter.record => this leads to the NP Luke described.

;;;","16/Mar/12 07:17;melix;André, since you're working on this issue, it would be great if you could take a look at the tutorial I wrote here: http://groovy.329449.n5.nabble.com/The-Canonical-Groovy-Way-td5468968.html#a5469607

There's a problem if you use a power assert and I suspect this is the same issue. If your fix could be tested against that too, it would be perfect!
;;;","17/Jan/13 07:16;andre.steingress;Sorry for the late reply, totally forgot about this issue.

I reproduced this issue. Whenever an AssertStatement without a source position is added via an AST transform, the exception mentioned above appears if the Boolean expression has variable references (triggering AssertionWriter#record() which fails with a NP).

Here is the pull request: https://github.com/groovy/groovy-core/pull/112;;;","17/Jan/13 15:32;paulk;pull request merged, thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static property reference from static context in script does not compile,GROOVY-5364,12816044,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,btiernay,btiernay,13/Mar/12 19:10,18/Feb/22 22:14,14/Jul/23 06:00,28/May/21 15:00,1.8.6,2.4.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.16,3.0.10,4.0.0-beta-1,Compiler,,,,0,,,,,,"The following script:
{code}
static getStaticProperty() {}
static staticMethod() { staticProperty }
{code}

Does not compile and produces the following error:
{noformat}
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method 'staticProperty' but left out brackets in a place not allowed by the grammar.
 @ line 4, column 25.
   static staticMethod() { staticProperty }
                           ^

1 error
{noformat}",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10078,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-03-13 19:10:35.0,,,,,,,,,,"0|i2cps7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
XmlParser and XmlSlurper should support XML Schema validation,GROOVY-5361,12816179,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,russel,russel,12/Mar/12 12:14,22/Jan/13 16:33,14/Jul/23 06:00,22/Jan/13 16:33,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.0,,,XML Processing,,,,0,,,,,,"XmlSlurper and XmlParser both support a validation capability, but this only works for DTDs. It should work for XMLSchemas as well.",,boillodmanuel,paulk,riggs,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 22 16:33:09 UTC 2013,,,,,,,,,,"0|i2cmnb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Mar/12 07:05;paulk;They both do support XML Schema validation. So for clarification, my understanding is that you want simpler configuration when turning on such validation rather than configuring your own SAXParser.;;;","13/Mar/12 07:49;paulk;So basically we currently have this for validating against internal XSDs:
{code}
def factory = SAXParserFactory.newInstance()
factory.validating = true
factory.namespaceAware = true
SAXParser sax = factory.newSAXParser()
sax.setProperty(""http://java.sun.com/xml/jaxp/properties/schemaLanguage"", XMLConstants.W3C_XML_SCHEMA_NS_URI)
def parser = new XmlParser(sax)
{code}
which could be shortened to something like:
{code}
def parser = new XmlParser(XmlUtil.defaultSchemaValidatingParser())
{code}
Incidentally, we still need an error handler in either case:
{code}
parser.errorHandler = { e -> println e.message } as ErrorHandler
{code}
;;;","13/Mar/12 07:54;paulk;For validating against an external XSD we currently have:
{code}
def schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI)
def factory = SAXParserFactory.newInstance()
factory.validating = false
factory.namespaceAware = true
factory.schema = schemaFactory.newSchema([new StreamSource(""mySchema.xsd"")] as Source[])
def parser = new XmlParser(factory.newSAXParser())
{code}
which might become something like this:
{code}
def parser = new XmlParser(XmlUtil.schemaValidatingParserFromSources(new StreamSource(""mySchema.xsd"")))
{code}
With DTD validation off, this doesn't need a special error handler - the default one when not validating just sends error messages to {{System.err}}.
;;;","13/Mar/12 07:57;paulk;Or we could provide a Map style constructor:
{code}
def parser = new XmlParser(validating: true, schemaValidation: true, schemaSources:[new StreamSource(""mySchema.xsd"")])
{code}
Or something like that - though it won't necessarily support easy IDE completion.;;;","13/Mar/12 11:16;russel;I did indeed mean that using an XML Schema should be easier.  The above proposal seem to take us on the right direction.  Without trying the out, it is difficult to say more.

Why does there have to be explicit mention of an error handler?

What about folks using Relax NG?
;;;","13/Mar/12 11:22;russel;I didn't have to specify an error handler using the first segment, it just worked.;;;","13/Mar/12 16:00;paulk;Re: ""I didn't have to specify an error handler using the first segment, it just worked.""

If I have validating set to true I get the warning to stderr you mentioned on the mailing list:
{noformat}
Warning: validation was turned on but an org.xml.sax.ErrorHandler was not
set, which is probably not what is desired.  Parser will use a default
ErrorHandler to print the first 10 errors.  Please call
the 'setErrorHandler' method to fix this.
{noformat}
If you are not seeing it perhaps it is JVM version specific.
;;;","13/Mar/12 16:54;paulk;For relaxng, with Jing in my classpath I needed the following as the long-hand for an external schema source (couldn't get the internal one working in the time I had available):
{code}
// Jing jar doesn't seem to have META-INF to be found automatically by JAXP
// so manually set it here - pick one of compact or xml syntax variants
System.setProperty(SchemaFactory.name + "":"" + RELAXNG_NS_URI,
//    ""com.thaiopensource.relaxng.jaxp.CompactSyntaxSchemaFactory"")
    ""com.thaiopensource.relaxng.jaxp.XMLSyntaxSchemaFactory"")

SchemaFactory schemaFactory = SchemaFactory.newInstance(RELAXNG_NS_URI)
def factory = SAXParserFactory.newInstance()
factory.validating = false
factory.namespaceAware = true
factory.schema = schemaFactory.newSchema([new StreamSource(""mySchema.rng"")] as Source[])
def parser = new XmlParser(factory.newSAXParser())
{code}
so perhaps this could become:
{code}
// I'd propose leaving the ugly System.setProperty here as it is Jing specific
// and hopefully will go away in future versions of the library anyway

def parser = new XmlParser(XmlUtil.schemaValidatingParserFromSources(RELAXNG_NS_URI, new StreamSource(""mySchema.rng"")))
{code}
and if we don't default to XML Schema, then the earlier example for XML Schema might need to become:
{code}
def parser = new XmlParser(XmlUtil.schemaValidatingParserFromSources(W3C_XML_SCHEMA_NS_URI, new StreamSource(""mySchema.xsd"")))
{code}
;;;","14/Mar/12 09:30;russel;""If you are not seeing it perhaps it is JVM version specific.""

I see the error message when I set the validate parameter true in the XmlParser constructor call but I don't have a DTD.  When I use the SAX parser constructor to XmlParser I do not see the error message.  This would imply the error message comes from the default DTD validating SAX parser used by XmlParser.  Since this is not used when specifying a given SAX parser the default error handler is clearly fine?;;;","14/Mar/12 09:31;russel;I agree with the thinking about support for RelaxNG except that there should be a way of allowing the incoming document to specify the schema against which validation happens.;;;","15/Mar/12 07:40;paulk;@Russel

Re: ""the default error handler is clearly fine"". Yes, when creating your own SAX parser, if you don't tell it to also validate against DTDs - which you don't need to in your examples from what you have said, then the default is fine AFAIK.

Re: ""there should be a way of allowing the incoming document to specify the schema against which validation happens"". Agreed! But I haven't found anything definitive on how to do this long hand in Java - hence providing a Groovy shorthand currently evades me.;;;","15/Mar/12 07:41;paulk;An example with imports etc. in case anyone is trying to actually run the snippets above:
{code}
import javax.xml.transform.Source
import javax.xml.transform.stream.StreamSource
import javax.xml.validation.SchemaFactory
import javax.xml.XMLConstants
import javax.xml.parsers.SAXParserFactory

def xml_g = '<person><first>James</first><last>Kirk</last></person>'
def xml_b = '<person><first>James</first><middle>T.</middle><last>Kirk</last></person>'
def xsd = '''<xs:schema xmlns:xs=""http://www.w3.org/2001/XMLSchema"">
  <xs:element name=""person"">
    <xs:complexType>
      <xs:sequence>
        <xs:element name=""first"" type=""xs:NCName""/>
        <xs:element name=""last"" type=""xs:NCName""/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>'''
def schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI)
def factory = SAXParserFactory.newInstance()
factory.validating = false
factory.namespaceAware = true
factory.schema = schemaFactory.newSchema([new StreamSource(new StringReader(xsd))] as Source[])
def parser = new XmlParser(factory.newSAXParser())
[xml_g, xml_b].each {
    def p = parser.parseText(it)
    println ""${p.last.text()}, ${p.first.text()}""
}
{code};;;","15/Mar/12 16:28;paulk;Here is what I propose to add to XmlUtil:
{code}
public static SAXParser schemaParser(String schemaLanguage, boolean namespaceAware, boolean validating, File schema)
public static SAXParser schemaParser(String schemaLanguage, boolean namespaceAware, boolean validating, URL schema)
public static SAXParser schemaParser(String schemaLanguage, boolean namespaceAware, boolean validating, Source... schemas)
{code}
So, the above example becomes (assuming the xsd is in a local file called 'person.xsd'):
{code}
import static javax.xml.XMLConstants.*
import static groovy.xml.XmlUtil.*

def xml_g = '<person><first>James</first><last>Kirk</last></person>'
def xml_b = '<person><first>James</first><middle>T.</middle><last>Kirk</last></person>'
def parser = new XmlParser(schemaParser(W3C_XML_SCHEMA_NS_URI, true, false, 'person.xsd' as File))
[xml_g, xml_b].each {
    def p = parser.parseText(it)
    println ""${p.last.text()}, ${p.first.text()}""
}
{code}
I guess we could also create variants with default values for the booleans - I'd go with validating=false and namespaceAware=true as per our defaults for XmlSlurper and XmlParser.

We could also have a default schema language but (despite the poor support for RelaxNG on the JVM at present) I am inclined not to at this stage - it can always be added later.;;;","15/Mar/12 16:35;paulk;There is also the question of the best name for the utility methods. I have used ""schemaParser"" above but perhaps ""newSAXParser"" is better.

And also the question of whether it is worth back-porting to 1.8.7? It doesn't alter any existing API, so I don't see the harm. It depends on how kind we want to be to stragglers in the Groovy ecosystem.;;;","15/Mar/12 17:40;paulk;added as newSAXParser with and w/o boolean variants and backported to 1.8.7;;;","15/Mar/12 18:59;russel;On the one hand I am a huge fan of debug releases, i.e. changes in the z of the x.y.z, only having bug fixes. On the other hand this could be considered a bug fix -- and Groovy does have a history of slipping in some new bits as bug fixes. So as long as there are no breaking changes 1.8.6 -> 1.8.7 I am content to see this stuff in.

I wonder if ""validatingParser"" rather than ""schemaParser"" would be more descriptive.

I guess we still need to work on a validating parser that reads the schema specification from the root node rather than being given it separately.;;;","15/Mar/12 19:09;paulk;Re: the name: I ended up going with ""newSAXParser"" which is a little lower level than I would normally like but with a view to making it obvious that you are producing something which feeds into the SAXParser constructor of XmlParser/Slurper. I didn't go with ""validatingParser"" since you could create one with the (DTD) validating flag set to false and that might be counter-intuitive at first glance. And if the eventual goal is to have a higher-level API over the top, then all of this would be hidden anyway.

Re: autodetecting the schema language: yes, that would be much nicer. It should really be fixed at the JVM-library level but if that looks unlikely to happen any time soon, Groovy could try to value add in the meantime.
;;;","15/Mar/12 19:31;paulk;Example of usage can be seen in XmlUtilTest#testSchemaValidationUtilityMethod:

https://github.com/groovy/groovy-core/blob/master/src/test/groovy/xml/XmlUtilTest.groovy

The test doesn't use a file which looks neater but on the other hand, the test is self-contained.;;;","23/Mar/12 11:24;russel;Just a note that:

XMLConstants

but:

XmlUtils

the inconsistency really is annoying.;;;","23/Mar/12 12:42;russel;It seems that the default behaviour of XmlUtil.newSAXParser is not to validate even though it is required to provide a schema.  Or have I missed something?;;;","23/Mar/12 12:51;russel;XmlParser reports trimWhitespace as the property to set to control whitespace, it has the wrong default of true.  XmlParser reports keepWhitespace as the property to control whitespace, it has the wrong default of false.;;;","23/Mar/12 17:21;paulk;Re: XMLConstants vs XmlUtils: XMLConstants, SAXParser, SQLException etc. come from Java. XmlParser, XmlSlurper, XmlUtil, JsonBuilder, Sql, etc. come from Groovy. Not nice but there has been a history behind both - unfortunate that sometimes the Java apis leak through to the Groovy ones. I guess in theory we could always hide them but ...;;;","23/Mar/12 17:28;paulk;Re: default behaviour is to not validate: yes, the defaults are the same as for XmlSlurper and XmlParser and that flag is related to DTD validation only. Schema validation will be on. Perhaps the doco needs a bit of finessing to make that clearer?;;;","23/Mar/12 17:45;paulk;Re: trimWhitespace vs keepWhitespace: it turns out the XmlSlurper's keepWhitespace and XmlParser's trimWhitespace are totally different beasts/concepts!

Firstly, XmlParser's trimWhitespace: it causes "".trim()"" to be called on element text values (but not attributes!). It really does have the wrong default value but would break legacy code if we changed it. I would nearly support changing it anyway as a breaking change in 2.0. But given that we want to put a new api over the top (and potentially rework some of the internals) do we break user's code once or twice? It is well documented and easy to turn off - so the current thinking is to leave it until we make the api changes - but feel free to debate further - though it isn't really part of this issue per say.

Secondly, XmlSlurper's keepWhitespace: this is about preserving layout of XML documents. So if we have this XML fragment:
{code:xml}
...
    <foo>content</foo>
    <bar>content</bar>
...
{code}
when the flag is off, parsing this will return two elements, ""foo"" and ""bar"". When the flag is on, this will return a ""foo"" element, then a ""text node"" containing a newline and 4 spaces, then the ""bar"" element. If you want to process the document content, the ""whitespace text nodes"" are just unwanted noise. But if you want to preserve the original layout of the document after making some changes to the content, then keeping the flag on can be useful. From memory, XmlSlurper may not allow full round-tripping anyway as it may not keep everything intact, e.g. processing instructions, XML comments etc. (but I haven't checked the code just now so don't quote me on this - we have made it cover more of these things over time);;;","24/Mar/12 04:29;russel;Re: XMLConstants vs XmlUtils: I think the Groovy naming is inconsistent with the policy for Groovy properties where getXMLThingy ( ) goes to XMLThingy in order to preserve the upper caseness.  No matter the history, it would be good for Groovy to have a consistent approach to acronym case.
;;;","24/Mar/12 04:30;russel;Re validation.  I found that using the two parameter newSAXParser (note not newSaxParser, see above ;-) I did not get any XML Schema validation, I had to switch it on by using the four parameter version.;;;","24/Mar/12 04:32;russel;Re XmlParser's trimWhiteSpace: I suggest that the default is wrong and that Groovy 2 should have the right default.  Legacy code should expect breaking changes 1.8 -> 2.0. Perhaps take this back to the mailing list to get wider debate?;;;","24/Mar/12 04:35;russel;Re XmlSlurper keepWhitespace: It seems that the use case you are explaining has little to do with the one we started with -- unless I am missing something. Is it that XmlSlurper is using the same flag for multiple disjoint purposes? If so then a new flag should be introduced to cover the second case.

If XmlSlurper cannot round-trip then isn't it broken?;;;","24/Mar/12 23:19;paulk;Re XmlSlurper keepWhitespace and XmlParser trimWhitespace: yes, they are totally different use cases with totally different flags that unfortunately overlap by 10 common characters. Perhaps they should have different names (breaking change): preserveWhitespace, autoTrimElementText;;;","24/Mar/12 23:25;paulk;Re newSAXParser vs newSaxParser: SAXParser is a Java class that leaks through the Groovy api. When thinking of Groovy as value add to Java, I don't mind these differences too much. If you want to treat Groovy as a Java replacement then such differences are annoying. Don't think the getXMLThingy is relevant since xmlThingy would be the property for XmlThingy?;;;","24/Mar/12 23:30;paulk;Re flipping trimWhitespace default: feel free to continue debate in user mailing list - if there is unanimous support I will be happy to help implement the change - if there is a wide divergence of opinion, I don't have heaps of time at present to contribute to persuading the masses - what little time I do have I'd prefer to invest in a future XML module with quite a few things fixed. But agree with you that the current default is very anti common practice.;;;","24/Mar/12 23:32;paulk;Re two param vs four param newSAXParser: does XmlUtilTest#testSchemaValidationUtilityMethod work for you? It uses the two param version and seems to work?;;;","01/Apr/12 21:52;paulk;Russel, does {{XmlUtilTest#testSchemaValidationUtilityMethod}} not work for you? Or did you reopen this in relation to the {{keepWhitespace}} / {{trimWhitespace}} issue? I guess it is working for me with the test cases I have so I am looking for another example. Thanks.;;;","05/Jan/13 20:07;paulk;Russel, I have lost track of what else you require for this issue to be closed? Can you remember?;;;","22/Jan/13 16:33;paulk;I am going to mark this as closed as I believe the Schema Validation part has been adequately addressed. If we need to tweak other defaults, we should use a fresh issue to create more focus around any required changes/discussion.;;;",,,,,,,,,,
Different ways of extending a class functionality esp. adding getProperty inconsistent,GROOVY-5358,12816172,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,oc,oc,11/Mar/12 15:19,03/Feb/22 22:35,14/Jul/23 06:00,25/Jan/22 10:19,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,4.0.0,,,groovy-runtime,,,,0,,,,,,"When getProperty is used e.g., to mimic a Map behaviour, the result differs depending on whether getProperty was defined directly in the class, added through a mixin, or through a metaclass.

{code}
class FooWorksAsMap { // class names the same length as LinkedHashMap to make output pretty
 def getProperty(String foo) { ""OK:FooWorksAsMap.$foo"" }
}
class BarWorksAsMap {}
class BaxWorksAsMap {}
@Category(BarWorksAsMap) class C {
 def getProperty(String foo) { ""OK:BarWorksAsMap.$foo"" }
}
BarWorksAsMap.mixin C
BaxWorksAsMap.metaClass.getProperty = { foo -> ""OK:BaxWorksAsMap.$foo"" }
def maps = [new FooWorksAsMap(), new BarWorksAsMap(), new BaxWorksAsMap(),
           [foo:'OK:LinkedHashMap.foo', class:'OK:LinkedHashMap.class']]
for (def prop in ['foo','class']) {
 for (def m in maps) {
   def op = ""${m.getClass().getSimpleName()}.$prop""
   try { println ""$op -> "" + m.""$prop"" }
   catch (t) { println ""$op -> FAIL:$t"" }
 }
}
{code}",,emilles,paulk,,,,,,,,,,,"eric-milles opened a new pull request #1676:
URL: https://github.com/apache/groovy/pull/1676


   https://issues.apache.org/jira/browse/GROOVY-5358


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;15/Jan/22 18:36;githubbot;600","paulk-asert closed pull request #1676:
URL: https://github.com/apache/groovy/pull/1676


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;17/Jan/22 05:31;githubbot;600","paulk-asert commented on pull request #1676:
URL: https://github.com/apache/groovy/pull/1676#issuecomment-1014157117


   Merged, thanks!


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;17/Jan/22 05:31;githubbot;600",,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 25 10:19:49 UTC 2022,,,,,,,,,,"0|i2cbq7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"15/Jan/22 18:08;emilles;The category mixin case isn't working because the check for GroovyObject methods in MetaClassImpl misses the kind of meta method:
{code:java}
    protected final void checkIfGroovyObjectMethod(MetaMethod metaMethod) {
        if (metaMethod instanceof ClosureMetaMethod || metaMethod instanceof MixinInstanceMetaMethod) { // NewInstanceMetaMethod
            if (isGetPropertyMethod(metaMethod)) {
                getPropertyMethod = metaMethod;
            } else if (isInvokeMethod(metaMethod)) {
                invokeMethodMethod = metaMethod;
            } else if (isSetPropertyMethod(metaMethod)) {
                setPropertyMethod = metaMethod;
            }
        }
    }
{code}

https://github.com/apache/groovy/pull/1676;;;","15/Jan/22 18:43;emilles;Even with this fix, the Bar and Bax cases will not do what you expect for ""class"" or ""metaClass"".  See {{ExpandoMetaClass}}:
{code:java}
    private boolean hasOverrideGetProperty(String name) {
        return getPropertyMethod != null && !name.equals(META_CLASS_PROPERTY) && !name.equals(CLASS_PROPERTY);
    }
{code};;;","17/Jan/22 14:29;paulk;I added a {{setProperty}} test case. I haven't closed yet. I think we should think about whether any consistency for class/metaClass is possible or at least check whether we have any documentation.;;;","17/Jan/22 18:28;emilles;So if you allow ""class"" or ""metaClass"" to go through getProperty or setProperty, what are the implications?  I haven't looked at the code history to see why those checks were installed.;;;","25/Jan/22 10:19;paulk;[~emilles] I propose we close this and clarify further ""class""/""metaClass"" behavior as a separate issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
When using Grab concurrently the underlying ivy library can lock a metadata file causing grab failure,GROOVY-5356,12817866,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,08/Mar/12 16:20,14/Jul/15 10:46,14/Jul/23 06:00,13/Jul/15 23:08,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.0,,,Grape,,,,1,,,,,,"This doesn't occur very often - seems to be a problem on heavily used slow machines, e.g. CI servers. When the issue does occur, there will be a FileNotFoundException (Access is denied) as one process has ""~/.groovy/grapes/resolved-caller-all-caller-working.properties"" locked when the other also tries to write to it.

Proposal is to add a couple of digits from System.currentTimeMillis into the name of the metadata file plus also wrap the call to Ivy with a MAX_TRIES wait loop to allow the first Grab to finish - to handle the rare case where two process attempt a grab within the same millisecond.",,pascalschumacher,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 13 23:08:46 UTC 2015,,,,,,,,,,"0|i2cl4n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jul/15 18:55;pascalschumacher;Does this still occur with recent versions of ivy?;;;","13/Jul/15 23:08;paulk;Actually, a partial fix was implemented a long time ago:
https://github.com/apache/incubator-groovy/blob/master/src/main/groovy/grape/GrapeIvy.groovy#L405
It was left open awaiting further feedback which was never forthcoming. But we haven't had the same issue reported again as far as I know.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ICO file in distribution is broken/missing,GROOVY-5349,12816145,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,pschumacher,vampire,vampire,07/Mar/12 07:57,14/Jun/13 05:10,14/Jul/23 06:00,09/Jun/13 03:15,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.5,2.2.0-beta-1,,Documentation,,,,0,ant,build,,,,"The groovy.ico file in the distributions (source zip, binary zip and also Windows installer) is broken.
The one from https://fisheye.codehaus.org/browse/~raw,r=9382/groovy/trunk/groovy/groovy-core/src/tools/org/codehaus/groovy/tools/groovy.ico is fine though.
Comparing a hexdump of both files it seems there are Unicode replace characters inserted.
I guess you use a <copy> task with nested <filterset> or with some implicit filter from a stand-alone <filter> task to copy that file. This is not according to the <copy> tasks documentation, which states that filter may only be used with text files and will destroy binary files.

{quote}
Note: If you employ filters in your copy operation, you should limit the copy to text files. Binary files will be corrupted by the copy operation. This applies whether the filters are implicitly defined by the filter task or explicitly provided to the copy operation as filtersets. See encoding note. 
{quote}",,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 09 03:15:44 UTC 2013,,,,,,,,,,"0|i2c4af:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Nov/12 13:29;pschumacher;in the zip files created by current master (2.1), the icon is o.k.;;;","09/Jun/13 03:08;pschumacher;The current release 2.1.4 is missing the ""groovy.ico"" file. I updated the title to reflect this.;;;","09/Jun/13 03:15;pschumacher;fixed, see: [https://github.com/groovy/groovy-core/commit/6ea29c30e13fc1072e3554cf5d9fed6daf82718b];;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractQueryCommand constructor should be protected for subclassing,GROOVY-5340,12818160,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,spannjp,spannjp,01/Mar/12 03:55,13/May/12 03:30,14/Jul/23 06:00,05/Mar/12 06:02,1.8.4,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,SQL processing,,,,0,,,,,,"To customize the behavior of groovy.sql.Sql we override ""protected groovy.sql.Sql.createQueryCommand(String)"". Next, we attempt to implement the inner class groovy.sql.Sql.AbstractQueryCommand. Its only constructor ""AbstractQueryCommand(String sql)"" is package-protected. therefore subclassing is impossible unless we put our code into package ""groovy.sql"" which is against best practice.

As a side note, AbstractQueryCommand is non-static, therefore requires an instance of groovy.sql.Sql for instantiation. 
I guess one would only want to subclass AbstractQueryCommand after subclassing Sql first, so this won't be an issue. Still, an instance of Sql could be provided on the constructor explicitly and let the inner class be static.",,paulk,spannjp,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 05 06:02:31 UTC 2012,,,,,,,,,,"0|i2c2ef:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Mar/12 04:59;paulk;The constructor for AbstractQueryCommand now has protected visibility allowing for extension in combination with extending groovy.sql.Sql.

It would also be possible to make AbstractQueryCommand static - or indeed a top-level class - but that seems like a lower priority change to me and we currently don't have a strong example/use case/justification driving that change. I am at this stage inclined to close this issue and leave such changes to be done if/when other refactoring takes place in the future. Do you agree or instead have further use cases/examples to be considered?;;;","05/Mar/12 02:13;spannjp;Thanks for the quick action -- I agree there's no need to make AbstractQueryCommand static or top-level, as the class would offer little or no benefit outside the context of an instance of groovy.sql.Sql.;;;","05/Mar/12 06:02;paulk;OK, we'll ignore the static inner class suggestion for now. Marking resolved, but please reopen if upon any further testing you spot any issues.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.sql.Sql.executeQuery(String) should be non-final for extension,GROOVY-5339,12816154,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,spannjp,spannjp,01/Mar/12 02:53,13/May/12 03:30,14/Jul/23 06:00,05/Mar/12 06:31,1.8.4,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,SQL processing,,,,0,,,,,,"The method ""protected groovy.sql.Sql.executeQuery(String sql) throws SQLException"" is intended for extensibility and would indeed be a useful extension point, but marked as ""final"".
From the method's JavaDoc: ""Hook to allow derived classes to access ResultSet returned from query.""",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 05 06:31:47 UTC 2012,,,,,,,,,,"0|i2bquv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Mar/12 05:13;paulk;Do you have an example where you would need to overwrite the functionality of executeQuery (or executePreparedQuery which has the same properties)?

I guess the wording ""hook to allow derived classes..."" could suggest a fairly generic extension point when in reality the design allows for overwriting ""createQueryCommand"" (or ""createPreparedQueryCommand"" in the case of executePreparedQuery) and then making use of executeQuery (or executePreparedQuery) as a building block within your enhanced Sql class. I believe this is still a ""hook"" but perhaps there is better wording that could be used. Alternatively, if you have a use case where the current design doesn't meet your purposes, then we could look further at the current design.;;;","05/Mar/12 02:18;spannjp;Thanks! Marking executeQuery non-final would achieve very much the same goal as making the constructor of AbstractQueryCommand protected (GROOVY-5340). One of either developments suffices IMHO.
I would suggest to remove the misleading JavaDoc comment ""Hook to allow derived..."" though.;;;","05/Mar/12 06:31;paulk;ok, given that GROOVY-5340 has been addressed, I have tweaked the doc to hopefully be clearer and will resolve this issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Map<String,Integer> is recognized as Map<String,String> by the type checker",GROOVY-5332,12816130,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,27/Feb/12 06:50,13/May/12 03:30,14/Jul/23 06:00,27/Feb/12 06:51,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"The following code fails:
{code}
Map<String,Integer> foo = new HashMap<String,Integer>()
foo.put('foo', 1)
{code}

because the type checker aligns the V placeholder in <K,V> with {{String}} instead of {{Integer}}.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-02-27 06:50:58.0,,,,,,,,,,"0|i2bsef:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Typo in exception message at JsonSlurper.parseObject(),GROOVY-5330,12816035,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,guillaume,goeh,goeh,24/Feb/12 12:40,13/May/12 03:30,14/Jul/23 06:00,24/Feb/12 13:17,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,JSON,,,,0,,,,,,"groovy.json.JsonException: Expected a string key on line: 1, column: 2. Bug got '42' instead.
at groovy.json.JsonSlurper.parseObject(JsonSlurper.java:187)

Message is misspelled: ""Bug"" should be ""But"".",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-02-24 12:40:57.0,,,,,,,,,,"0|i2cbbj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonOutput.prettyPrint breaks escaped special characters,GROOVY-5323,12816135,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,jakub.neubauer,jakub.neubauer,23/Feb/12 06:07,13/May/12 03:30,14/Jul/23 06:00,24/Feb/12 10:48,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,JSON,,,,0,,,,,,"I suppose that json text filtered with groovy.json.JsonOutput.prettyPrint should produce again valid JSON string. Try this example/testcase and see how prettyPrint breaks escaped characters:

{code}
String json = new groovy.json.JsonBuilder('a': 'x""y').toString()
String pretty = groovy.json.JsonOutput.prettyPrint(json)

// comment this println in final test case
println json
println pretty

def slurper = new groovy.json.JsonSlurper()
// this is OK in 1.8.6
try {
  def test1 = slurper.parseText(json)
  assert 'x""y' == test1.a
} catch(Exception e) {
  assert false, ""parsing generated JSON failed""
}
// this fails in 1.8.6
try {
  def test = slurper.parseText(pretty)
  println test.a
} catch(Exception e) {
  assert false, ""parsing pretty printed JSON failed""
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 23 06:29:11 UTC 2012,,,,,,,,,,"0|i2cg9r:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"23/Feb/12 06:29;jakub.neubauer;Here is a patch. For its simplicity I put it in the comment:

{noformat}
--- a/main/groovy/json/JsonOutput.groovy
+++ b/main/groovy/json/JsonOutput.groovy
@@ -183,6 +183,8 @@ class JsonOutput {
                 output.append(' ' * indent)
             } else if (token.type == COLON) {
                 output.append(': ')
+            } else if (token.type == STRING) {
+                output.append(toJson(token.value));
             } else {
                 output.append(token.text)
             }
{noformat};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MinimumRecompilationInterval is not used as an interval in GroovyScriptEngine,GROOVY-5322,12816128,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mattiasr,mattiasr,22/Feb/12 07:55,11/Sep/12 01:15,14/Jul/23 06:00,15/Aug/12 14:24,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,,GroovyScriptEngine,,,,1,,,,,,"Example:

If I set minimumRecompilationInteval to 60 seconds, GroovyScriptEngine will load the script on first access (as expected).
It will then skip checking the script for modifications for 60 seconds (as expected).

After the 60 seconds has passed it will check the the script for modifications EVERY time it's accessed.
I would expect that the source file would be left alone for another 60 seconds after it has been checked once again.

Is the current behaviour correct, or is it a bug?",,blackdrag,mattiasr,sslavic,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"14/Mar/12 08:35;mattiasr;GROOVY-5322.patch;https://issues.apache.org/jira/secure/attachment/12722530/GROOVY-5322.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 15 14:24:38 UTC 2012,,,,,,,,,,"0|i2cdx3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Mar/12 08:35;mattiasr;Suggestion of fix for this bug.;;;","15/Aug/12 14:24;blackdrag;patch applied, sorry for the long wait.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyScriptEngine getResourceConnection treats resourceName argument as URI path spec,GROOVY-5321,12818146,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,denvercoder9,denvercoder9,21/Feb/12 13:12,11/Sep/12 01:15,14/Jul/23 06:00,14/Aug/12 09:41,1.8.4,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,,GroovyScriptEngine,,,,0,,,,,,"If a script name that begins with a leading ""/"" is passed to GroovyScriptEngie.run, then getResourceConnection may fail. The resulting output message will indicate some invalid path that (intuitively) seems like it should not have been constructed by groovy. (This makes it extremely difficult to debug some issues like dynamic script names).

I am currently running embedded groovy running in java application. Problem observed when groovy scripts (.groovy) are stored within a jar file with the application, but the issue is probably not be limited to this case.

Example roots provided to groovy:
""jar:file:/home/user/blah.jar!/org/someFolder"" (which actually contains groovy scripts)
""jar:file:/home/user/blah.jar!/org/someOtherFolder"" (which also contains groovy scripts)

If I incorectly pass ""/coolscript.groovy"" to GroovyScriptEngine.run instead of ""coolscript.groovy"" then I will receive an exception to the effect:
""Cannot open URL: file:/home/user/blah.jar!/coolscript.groovy""

The fix (for user application) is to, of course, remove the leading ""/"". The hope is that groovy can indicate that it is not a well formed name for a script, and throw some more meaningful exception. The alternative of continuing to use the name when it is not well formed (as though it was a path), leaves the possibility of obscure bugs.

This is caused by the constructor for URL used in GroovyScriptEngine.getResourceConnection as described in the following javadoc:
http://docs.oracle.com/javase/6/docs/api/java/net/URL.html#URL(java.net.URL, java.lang.String)",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 14 09:41:33 UTC 2012,,,,,,,,,,"0|i2byyv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Feb/12 13:16;denvercoder9;The most similar types of issues I saw while looking for a fix for this were errors that couldn't be reproduced in the past, Like http://jira.codehaus.org/browse/GROOVY-5125 . This could be a potential cause for those simliar issues.;;;","14/Aug/12 09:41;blackdrag;the issue is unrelated to GROOVY-5125. Instead it was the URL spec RFC2396. It ays, that if a absolute path is used, like with /x.groovy, that the previously existing path is to be removed. so a /com/foo//x.groovy turns into a /x.groovy. The exception text will now prin /com/foo//x.groovy instead

;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovyc ant task cannot compile Servlet using Java EE 6 reference API libaries (results in ClassFormatError Missing Code attribute),GROOVY-5320,12816079,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,krasmussen,krasmussen,20/Feb/12 15:01,24/Jul/22 15:04,14/Jul/23 06:00,22/May/22 15:42,1.8.6,2.4.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.0,,,Compiler,,,,0,ant,ClassFormatError,groovyc,sevlet,,"
Compiling a simple servlet against the Java EE 6 reference APIs results in a groovyc compilation failure. I have attached a project with both a Java Servlet and a Groovy Servlet.

The Java compiler works ok but the groovyc fails. Using Maven's eclipse-groovy-plugin also works ok. It seems that the groovyc compiler is introspecting the class in a different way than the maven eclipse-groovy-compiler.

{code}

Buildfile: X:\workspaces\test\krasmussen\GroovyBug\GroovyBug\build.xml

clean:

init:

compile:
    [mkdir] Created dir: X:\workspaces\test\krasmussen\GroovyBug\GroovyBug\build\classes\main
    [javac] Compiling 1 source file to X:\workspaces\test\krasmussen\GroovyBug\GroovyBug\build\classes\main
    [javac] X:\workspaces\test\krasmussen\GroovyBug\GroovyBug\src\main\java\com\acme\test\servlet\JavaServlet.java
  [groovyc] Compiling 1 source file to X:\workspaces\test\krasmussen\GroovyBug\GroovyBug\build\classes\main
  [groovyc] X:\workspaces\test\krasmussen\GroovyBug\GroovyBug\src\main\groovy\com\acme\test\servlet\GroovyServlet.groovy

  [groovyc] >>> a serious error occurred: javax/servlet/ServletException : Missing Code attribute
  [groovyc] >>> stacktrace:
  [groovyc] java.lang.ClassFormatError: javax/servlet/ServletException : Missing Code attribute
  [groovyc]     at java.lang.ClassLoader.defineClass1(Native Method)
  [groovyc]     at java.lang.ClassLoader.defineClassCond(ClassLoader.java:631)
  [groovyc]     at java.lang.ClassLoader.defineClass(ClassLoader.java:615)
  [groovyc]     at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)
  [groovyc]     at java.net.URLClassLoader.defineClass(URLClassLoader.java:283)
  [groovyc]     at java.net.URLClassLoader.access$000(URLClassLoader.java:58)
  [groovyc]     at java.net.URLClassLoader$1.run(URLClassLoader.java:197)
  [groovyc]     at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
  [groovyc]     at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
  [groovyc]     at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
  [groovyc]     at java.lang.ClassLoader.loadClass(ClassLoader.java:295)
  [groovyc]     at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:696)
  [groovyc]     at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:564)
  [groovyc]     at org.codehaus.groovy.control.ResolveVisitor.resolveToClass(ResolveVisitor.java:709)
  [groovyc]     at org.codehaus.groovy.control.ResolveVisitor.resolve(ResolveVisitor.java:275)
  [groovyc]     at org.codehaus.groovy.control.ResolveVisitor.visitClass(ResolveVisitor.java:1241)
  [groovyc]     at org.codehaus.groovy.control.ResolveVisitor.startResolving(ResolveVisitor.java:148)
  [groovyc]     at org.codehaus.groovy.control.CompilationUnit$9.call(CompilationUnit.java:605)
  [groovyc]     at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:843)
  [groovyc]     at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:548)
  [groovyc]     at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:497)
  [groovyc]     at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:480)
  [groovyc]     at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:60)
  [groovyc]     at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:216)
  [groovyc]     at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:149)
  [groovyc]     at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.j
ava:179)
  [groovyc]     at org.codehaus.groovy.ant.FileSystemCompilerFacade.main(FileSystemCompilerFacade.java:27)

BUILD FAILED
X:\workspaces\test\krasmussen\GroovyBug\GroovyBug\build.xml:42: Forked groovyc returned error code: 1
{code}


Maven build

{code}
X:\workspaces\test\krasmussen\GroovyBug>mvn clean compile
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building CPMS Parent Module 3.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-clean-plugin:2.4.1:clean (default-clean) @ parent-pom ---
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 0.760s
[INFO] Finished at: Mon Feb 20 14:58:45 CST 2012
[INFO] Final Memory: 28M/64M
[INFO] ------------------------------------------------------------------------
X:\workspaces\test\krasmussen\GroovyBug>mvn clean compile
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building CPMS Parent Module 3.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-clean-plugin:2.4.1:clean (default-clean) @ groovy-bug ---
[INFO]
[INFO] --- maven-resources-plugin:2.4.3:resources (default-resources) @ groovy-bug ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory X:\workspaces\test\krasmussen\GroovyBug\src\main\resources
[INFO]
[INFO] --- maven-compiler-plugin:2.3.2:compile (default-compile) @ groovy-bug ---
[INFO] Using Groovy-Eclipse compiler to compile both Java and Groovy files
[INFO] Compiling 2 source files to X:\workspaces\test\krasmussen\GroovyBug\target\classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.421s
[INFO] Finished at: Mon Feb 20 14:59:20 CST 2012
[INFO] Final Memory: 15M/64M
[INFO] ------------------------------------------------------------------------
X:\workspaces\test\krasmussen\GroovyBug>
{code}

",N/A,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Feb/12 15:01;krasmussen;GroovyBug.zip;https://issues.apache.org/jira/secure/attachment/12722600/GroovyBug.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 22 15:42:52 UTC 2022,,,,,,,,,,"0|i2chxr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Feb/12 15:54;paulk;Wondering if these are relevant:
http://stackoverflow.com/questions/3424207/testing-against-java-ee-6-api
http://www.adam-bien.com/roller/abien/entry/trouble_with_crippled_java_ee

What happens if you move groovyPath after the javaee-api jar in your compilePath?;;;","20/Feb/12 16:22;krasmussen;Hi Paul,

Moving groovyPath after javaee-api jar in compilePath doesn't help. However replacing the reference APIs with a real Java EE implementation such as Glassfish does work but it smells bad IMHO. 

It seems to me that this case is revealing a deeper issue with the groovy compiler as demonstrated by the behavior differences with the Maven Eclipse-Groovy-Compiler vs GroovyC. I *should* be able to use the reference APIs for compiling purposes. It's possible that there could be other issues like this lurking out there...

This is impacting my ability to use Gradle as our build system using the reference APIs for example.
;;;","22/Feb/12 06:43;blackdrag;The difference between the eclipse-groovy compiler and groovyc is, that the eclipse-groovy compiler is file based and uses the eclipse infrastructure to inspect the classes. That means it looks at the bytecode. Normal groovyc is not solely for the file usage and uses reflection to inspect the classes. That means that while the eclipse introspection is ok with the class and maybe more tolerant to wrong formats, the reflection based approach uses the full force of the verifier and cannot load classes that have an incorrect class format. That means at least one class in the JavaEE6 reference APIs you use,  or nay other library you use, has an illegal class file format, thus producing this error.

Going by the stack overflow error Paul gave I strongly assume they produced method headers without body, even for non abstract classes. This is normally not legal in bytecode, thus the ClassFormatError. 

I tend to close the issue as ""Won't Fix"". Groovyc by itself is not capable of loading such classes. But afaik there is a eclipse-groovy-compiler you can use in gradle as well as from the command line. You will have to use that one instead then.;;;","22/Feb/12 15:25;krasmussen;Thanks for the detailed explanation. That makes a lot of sense. However this seems to be a common requirement for Java EE development, i.e. wouldn't you normally use the reference libraries for *building* your application? I mean if you want to do integration testing then you would need an actually implementation. 

The javac compiler has no problem using these reference libraries. Is it possible to ignore certain types of failures in the reflection analysis that groovyc is doing?;;;","10/Mar/17 05:31;paulk;Reducing to Major priority based on comment.;;;","22/May/22 15:42;emilles;Starting in Groovy 2.5, classes are resolved through ASM before traditional class loading.  This allows {{groovyc}} to compile against this {{servlet-api}} artifact.

Tested against Groovy 1.8.6, 2.0.8, 2.1.9, 2.2.2, 2.3.11, 2.4.21 and 2.5.16;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
generic types in fully-qualified class names parsing error,GROOVY-5318,12816013,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,gavingrover,gavingrover,18/Feb/12 20:49,02/May/17 02:03,14/Jul/23 06:00,24/Jan/17 06:13,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,parser,,,,0,,,,,,"The following code compiles and runs in Groovy 1.8.6...

{code}
def a= new java.util<Integer>.ArrayList<ArrayList<Integer>>()
{code}

The parser allows a generic type after each name in the fully-qualified class name. The generic type should only be after the final name.

The relevant part of the Antlr parser that needs fixing is:

{code}
typeParameters: LT typeParameter (COMMA typeParameter)* (typeArgumentsOrParametersEnd)?
typeParameter: IDENT (typeParameterBounds)?
typeParameterBounds: ""extends"" classOrInterfaceType (BAND! classOrInterfaceType)*
{code}
",Groovy 1.8.6 on Java 7,daniel_sun,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jan 28 07:07:15 UTC 2017,,,,,,,,,,"0|i2bqwn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jan/17 02:51;daniel_sun;the new parser Parrot can parse the following code:
{{def a= new java.util.ArrayList<ArrayList<Integer>>()}}

Generics for package? Groovy does not support the syntax...
{{java.util<Integer>}};;;","23/Jan/17 22:36;paulk;@daniel_sun The issue is that the old parser doesn't give an error in this case. It ignores the first generic part - so doesn't produce weird code that knows about generics on the package name - but should really give an error.;;;","24/Jan/17 06:12;daniel_sun;Hi Paul,

When parrot parses the following code, 
{code}
def a= new java.util<Integer>.ArrayList<ArrayList<Integer>>()
{code}
it will give the following error message:
{{Unexpected input: 'newjava.util<Integer>.' at line: 1, column: 30}}

As to the error message 'newjava.util<Integer>.' has not any separator(we expect 'new java.util<Integer>.' ), I've filed an issue(https://github.com/tunnelvisionlabs/antlr4/issues/21). Sam Harwell, the core developer of antlr4, promised to look into it soon.
;;;","24/Jan/17 06:13;daniel_sun;Fixed in the parrot branch;;;","25/Jan/17 11:16;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/479

    GROOVY-5318: generic types in fully-qualified class names parsing error

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy5318

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/479.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #479
    
----
commit 27ac1f90f51e5e4da8c84cb3cc30eba0be201727
Author: paulk <paulk@asert.com.au>
Date:   2017-01-25T11:15:17Z

    GROOVY-5318: generic types in fully-qualified class names parsing error

----
;;;","25/Jan/17 11:20;paulk;@daniel_sun I added a PR to put in an extra check in AntlrParserPlugin for the error case. It seemed easier than trying to get the antlr2 grammar to handle that case. The current plan is to merge that just into the 2.5.x stream. You won't need that merge into the parrot branch since the grammar catches it earlier. I presume you already have test coverage. Assuming I merge, I'll adjust the fix version.;;;","28/Jan/17 07:04;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/479
;;;","28/Jan/17 07:07;paulk;I merged the PR for the 2.5.x stream and updated fix version appropriately. Not for inclusion in parrot branch which tackles the issue in the grammar. We'll have a slightly different error message at that point but I think that is acceptable.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong line/col info for SpreadMapExpressions,GROOVY-5313,12816124,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,guillaume,guillaume,16/Feb/12 04:39,06/Mar/18 23:25,14/Jul/23 06:00,02/May/17 02:12,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.6.0-alpha-1,,,parser-antlr2,,,,0,,,,,,"{code}
def m = [a  :1  , b: 2 ]
def map = [abc: 1, bcd: 2, *:m , cde: 3]
{code}
The SpreadMapExpression highlights just the star *, and the m variable is highlighted till the comma, instead of just the m character (ie. including further whitespace).",,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3437,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 20 01:31:29 UTC 2017,,,,,,,,,,"0|i2cenr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jan/17 01:31;daniel_sun;Fixed in the parrot branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong line/col info for MapEntryExpressions,GROOVY-5312,12815988,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,guillaume,guillaume,16/Feb/12 04:38,06/Mar/18 23:25,14/Jul/23 06:00,02/May/17 02:12,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.6.0-alpha-1,,,parser-antlr2,,,,0,,,,,,"Whenever there's a map entry, a named parameter, etc, a MapEntryExpression is used, but the line / col of MapEntryExpression is just surrounding the column, instead of the whole key + colon + value.

Another problem with MEE is that the value goes up to the next comma or closing square bracket (including all potential whitespace), instead of just stopping at the end of the expression or constant.",,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3437,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 20 01:29:43 UTC 2017,,,,,,,,,,"0|i2bzaf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Feb/12 09:51;guillaume;LineColumnCheck possible test:
{code}
###mapEntryExpression:::
foo ( a : 1 , b : 3,   c:   4   )
:::[MapEntryExpression,(1:7),(1:12)][ConstantExpression,(1:7),(1:8)][ConstantExpression,(1:11),(1:12)];
[MapEntryExpression,(1:15),(1:20)][ConstantExpression,(1:15),(1:16)][ConstantExpression,(1:19),(1:20)];
[MapEntryExpression,(1:24),(1:30)][ConstantExpression,(1:24),(1:25)][ConstantExpression,(1:29),(1:30)]
{code};;;","20/Jan/17 01:29;daniel_sun;Fixed in the parrot branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong line/col info for GStrings,GROOVY-5311,12816117,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,guillaume,guillaume,16/Feb/12 04:38,06/Mar/18 23:25,14/Jul/23 06:00,02/May/17 02:12,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.6.0-alpha-1,,,parser-antlr2,,,,0,,,,,,"GStrings have problems with their various sub parts: the constant strings and the variables interpolated.
With this example:
{code}
def gs1 = ""-$a-${b}-${->c}-""
{code}
The first constant string represents ""-$ instead of just the minus sign.
The second and third constant are -$ instead of just the minus sign again.
And the last constant is -"", instead of just the minus sign, it's going one character too far.
Now on to the variables.
Variable a is okay.
Varible b is actually {b} and I think it should be just b
And the closure expression is jut right too.",,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3437,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 20 01:57:32 UTC 2017,,,,,,,,,,"0|i2bt07:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jan/17 01:57;daniel_sun;Fixed in the parrot branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong line/col info for statements with whitespace before EOL,GROOVY-5310,12816037,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,guillaume,guillaume,16/Feb/12 04:36,06/Mar/18 23:25,14/Jul/23 06:00,02/May/17 02:12,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.6.0-alpha-1,,,parser-antlr2,,,,0,,,,,,"If there are spaces at the end of a line statement, the space is also accounted in the lin / col info, instead of being the last (non-whitespace) character of the statement",,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3437,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 19 12:55:01 UTC 2017,,,,,,,,,,"0|i2c15z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Feb/12 09:44;guillaume;Example test for the LineColumnChecker:

{code}
###excludeExtraWhitespaceInStatements:::
1 + 2 + 3    // bar
:::[ExpressionStatement,(1:1),(1:10)][BinaryExpression,(1:1),(1:10)]
{code};;;","19/Jan/17 12:55;daniel_sun;Fixed in the parrot branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong line/col info for binary expressions,GROOVY-5309,12816114,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,guillaume,guillaume,16/Feb/12 04:34,06/Mar/18 23:25,14/Jul/23 06:00,02/May/17 02:12,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.6.0-alpha-1,,,parser-antlr2,,,,0,,,,,,"{code}
assert annotationsOfIdField[0]    instanceof Id
{code}

The binary expression between the assert and instanceof: the end of the line / col info is right before instance of, instead of being after the last closing square bracket",,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3437,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 20 01:06:12 UTC 2017,,,,,,,,,,"0|i2cek7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jan/17 01:06;daniel_sun;Fixed in the parrot branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Caught: BUG! exception in phase 'conversion' in source unit '${file}' null,GROOVY-5308,12818151,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,metasyntax,metasyntax,15/Feb/12 13:55,13/May/12 03:30,14/Jul/23 06:00,13/May/12 03:26,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Compiler,,,,0,,,,,,"I'm new to Groovy, so I simply stumbled upon the following, which indicated it was a bug. I couldn't find it as an existing issue.

Source (Test.groovy):
foo = new String[] [ ""x"" ]

$ groovy -d Test.groovy
Caught: BUG! exception in phase 'conversion' in source unit '/home/taylor/Test.groovy' null
BUG! exception in phase 'conversion' in source unit '/home/taylor/Test.groovy' null
        at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:847)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:548)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:524)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:501)
        at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:283)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:267)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:197)
        at groovy.lang.GroovyShell$2.run(GroovyShell.java:215)
        at groovy.lang.GroovyShell$2.run(GroovyShell.java:213)
        at java.security.AccessController.doPrivileged(Native Method)
        at groovy.lang.GroovyShell.run(GroovyShell.java:213)
        at groovy.lang.GroovyShell.run(GroovyShell.java:159)
        at groovy.ui.GroovyMain.processOnce(GroovyMain.java:550)
        at groovy.ui.GroovyMain.run(GroovyMain.java:337)
        at groovy.ui.GroovyMain.process(GroovyMain.java:323)
        at groovy.ui.GroovyMain.processArgs(GroovyMain.java:120)
        at groovy.ui.GroovyMain.main(GroovyMain.java:100)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:616)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:108)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130)
Caused by: java.lang.NullPointerException
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:1652)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1636)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1632)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.arraySizeExpression(AntlrParserPlugin.java:2512)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.arraySizeExpression(AntlrParserPlugin.java:2510)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.constructorCallExpression(AntlrParserPlugin.java:2463)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:1673)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1636)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1632)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.binaryExpression(AntlrParserPlugin.java:2265)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:1794)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1636)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1632)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:1655)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1636)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1632)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.statement(AntlrParserPlugin.java:1259)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.convertGroovy(AntlrParserPlugin.java:304)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.buildAST(AntlrParserPlugin.java:241)
        at org.codehaus.groovy.control.SourceUnit.convert(SourceUnit.java:272)
        at org.codehaus.groovy.control.CompilationUnit$11.call(CompilationUnit.java:622)
        at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:843)
        ... 23 more","$ uname -a
Linux fw-its-kt209a-2 3.2.5-1-ARCH #1 SMP PREEMPT Tue Feb 7 08:34:36 CET 2012 x86_64 Intel(R) Core(TM) i7 CPU 870 @ 2.93GHz GenuineIntel GNU/Linux

$ java -version
java version ""1.6.0_24""
OpenJDK Runtime Environment (IcedTea6 1.11) (ArchLinux-6.b24_1.11-1-x86_64)
OpenJDK 64-Bit Server VM (build 20.0-b12, mixed mode)

$ groovy -version
Groovy Version: 1.8.6 JVM: 1.6.0_24 Vendor: Sun Microsystems Inc. OS: Linux
",paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 13 03:26:09 UTC 2012,,,,,,,,,,"0|i2bttz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"24/Feb/12 06:55;paulk;Possible patch:
{noformat}
--- src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java	(revision 3d898f3f6b151bb4943a897e4a8d8dc04a3245ca)
+++ src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java	(revision )
@@ -2528,7 +2528,11 @@
             } else {
                 size = ConstantExpression.EMPTY_EXPRESSION;
             }
-            list = arraySizeExpression(node.getFirstChild());
+            AST child = node.getFirstChild();
+            if (child == null) {
+                throw new ASTRuntimeException(node, ""No expression for the array constructor call"");
+            }
+            list = arraySizeExpression(child);
         } else {
             size = expression(node);
             list = new ArrayList();
{noformat}
;;;","13/May/12 03:26;paulk;proposed patch was applied as part of commit 8070e6bb;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc output html does not specify character encoding,GROOVY-5304,12815943,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ldaley,ldaley,14/Feb/12 03:18,13/May/12 03:30,14/Jul/23 06:00,15/Feb/12 06:04,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 15 06:41:09 UTC 2012,,,,,,,,,,"0|i2c1gf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Feb/12 06:04;paulk;Hi Luke, wasn't sure if you were planning to commit yourself but in any case, I committed your change and also added a parameter to allow manual override of the charset as per javadoc.;;;","15/Feb/12 06:41;ldaley;Cheers paul.
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"page title on groovydoc index page is ""{todo.title}""",GROOVY-5303,12816078,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,ldaley,ldaley,ldaley,14/Feb/12 03:13,13/May/12 03:30,14/Jul/23 06:00,15/Feb/12 06:06,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,GroovyDoc,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 15 06:06:24 UTC 2012,,,,,,,,,,"0|i2bvf3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Feb/12 06:06;paulk;your pull request has been applied - actually not sure whether it makes more sense to be windowTitle or docTitle but settled on the former for now - many people (including the groovy build) often set them to the same value anyway.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checker cannot choose between two covariant return type methods,GROOVY-5295,12816060,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,10/Feb/12 10:48,13/May/12 03:30,14/Jul/23 06:00,10/Feb/12 10:51,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"The following code fails because {{getMethods}} returns two covariant return type methods:

{code}
StringBuffer sb = new StringBuffer()
sb.append('string')
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-02-10 10:48:53.0,,,,,,,,,,"0|i2c9av:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
This reference is null during construction of object of abstract class implemented as closure map,GROOVY-5294,12816118,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,almo,almo,10/Feb/12 05:39,13/May/12 03:30,14/Jul/23 06:00,16/Feb/12 08:02,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,,,,,0,,,,,,"The following code produces NPE when the second object is created:

{code}
abstract class C {
    public abstract String f(Object o);

    private void g(Object val) { 
        println f(val) // NPE when 'y' is created !!!
    }

    public C() {this('DEF')}

    public C(Object val) { g(val) }
}

class D extends C {
    public String f(Object o) { return o ? 'Not null' : 'Is null' }
}

def x = new D()

def y = [ 'f' : { it -> return '123' + it } ] as C
{code}

Somehow 'this' becomes null when 'f' is invoked in 'g'.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 16 02:42:01 UTC 2012,,,,,,,,,,"0|i2ch4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Feb/12 02:36;melix;I fear we cannot fix that in 1.8.x. Groovy 2.0 provides a new proxy generator which will be capable of handling this though. Let me explain, in 1.x, proxies are generated using a code template. In this case, the code looks like this:
{code}
class C_groovyProxy extends C {
    private closureMap
    C_groovyProxy(map) {
        super()
        this.closureMap = map
    }
    java.lang.String f(java.lang.Object p0) { this.@closureMap['f'] (p0)    }
}
new C_groovyProxy(map)
{code}

The problem is that we call {{super()}} before setting the closure delegate map. The {{super}} call will eventually reach the {{g}} method which will lookup the implementation of {{f}} into the map. At this point, the map is still null, leading to the error you've seen. We would need a way of setting the closure delegate map before calling {{super}}. This is not allowed in Java, nor in Groovy. However, we can do this in bytecode, which explains why a fix could be made available in 2.0. Meanwhile, if possible, I'd recommand not using calls to delegated methods in the construction of the object.
;;;","16/Feb/12 02:42;almo;I see. Thanks for the explanation. I've alerady refactored methods so they are not invoked in constructor.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ASTTransformationVisitor not closing URL streams,GROOVY-5293,12816036,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,piotrek@mente.pl,piotrek@mente.pl,10/Feb/12 04:11,13/May/12 03:30,14/Jul/23 06:00,27/Feb/12 11:58,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,Compiler,,,,0,,,,,,"I'm using Groovy as a script language in EJB in Glassfish 3.1 
After using GroovyShell, when i'm shutting down the server i'm getting a lot of 'open stream' errors. 
I've tested this bug with Groovy 1.8.5, 1.9 and 2 beta 2  - still the same

There's a line in ASTTransformationVisitor.java - line 202 in 2.0 beta 2
BufferedReader svcIn = new BufferedReader(new InputStreamReader(service.openStream()));

Looks like that stream is never closed ? 


Below stack trace:

WARNING: Input stream has been finalized or forced closed without being explicitly closed; stream instantiation reported in following stack trace
java.lang.Throwable
	at com.sun.enterprise.loader.ASURLClassLoader$SentinelInputStream.<init>(ASURLClassLoader.java:1230)
	at com.sun.enterprise.loader.ASURLClassLoader$InternalJarURLConnection.getInputStream(ASURLClassLoader.java:1338)
	at java.net.URL.openStream(URL.java:1010)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.doAddGlobalTransforms(ASTTransformationVisitor.java:202)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.addGlobalTransforms(ASTTransformationVisitor.java:190)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.addPhaseOperations(ASTTransformationVisitor.java:154)
	at org.codehaus.groovy.control.CompilationUnit.<init>(CompilationUnit.java:187)
	at org.codehaus.groovy.control.CompilationUnit.<init>(CompilationUnit.java:118)
	at groovy.lang.GroovyClassLoader.createCompilationUnit(GroovyClassLoader.java:436)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:271)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:638)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:650)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:677)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:668)

","Windows XP, java 1.6.0_30 , glassfish 3.1",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-02-10 04:11:51.0,,,,,,,,,,"0|i2c9vr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stub generation doesn't handle 'protected' multi-line String correctly.,GROOVY-5292,12818418,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,rumour,rumour,09/Feb/12 14:51,13/May/12 03:30,14/Jul/23 06:00,10/Feb/12 16:19,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,Stub generator / Joint compiler,,,,0,,,,,,"When using the groovyc joint compilation feature, the generated stub is incorrect when the groovy source includes a protected (possibly affects public too, I didn't test) multi-line String 'constant'.

For example,

class Example {
  protected static final String CONSTANT_VALUE = """"""
    I am a constant value
    Thank you
  """"""
} 

would generate a stub:

public Example extends java.lang.Object implements groovy.lang.GroovyObject {
protected static final java.lang.String CONSTANT_VALUE = ""
I am a constant value
Thank you
"";
}

This is a syntactically incorrect Java statement.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5150,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 10 16:19:15 UTC 2012,,,,,,,,,,"0|i2cjdb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Feb/12 14:55;rumour;I apologize, the formatting wasn't preserved.
Sample code:
{code:title=Example.groovy}
class Example {
  protected static final String CONSTANT_VALUE = """"""
I am a constant value
Thank you
""""""
}
{code}

Generating stub:
{code:title=Example.java}
public Example extends java.lang.Object implements groovy.lang.GroovyObject { 
protected static final java.lang.String CONSTANT_VALUE = ""
I am a constant value
Thank you
"";
}
{code};;;","10/Feb/12 16:09;paulk;I think this is an edge case left over from GROOVY-5150;;;","10/Feb/12 16:19;paulk;Your suspicions were correct. This affected both public and protected fields but should be fixed now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using GroovyServlet deployed to Tomcat with a multi-level context causes 404 errors,GROOVY-5289,12816089,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,dmikusa,dmikusa,08/Feb/12 14:18,22/Dec/12 01:10,14/Jul/23 06:00,05/Dec/12 02:52,1.8.3,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,,Groovlet / GSP,,,,1,,,,,,"When deploying an application which use the GroovyServlet to Tomcat with a simple context, there are no problems.  However, when deploying the same application to the same Tomcat instance using a multi-level context a 404 error is returned.

Attaching a sample application which demonstrates this behavior.  Simply run ""mvn package"" to create a WAR from the project.  Take the ""groovyweb.war"" file from the ""target"" directory and deploy it to a Tomcat server.  This will work just fine.  Now take the same WAR file, rename it to ""apps#groovyweb.war"" and deploy it to Tomcat.  Now a 404 is presented and in the log, a message indicates that the groovy script cannot be found.

----------------

Looking into this, it appears that the ""#"" in the name is causing the problem.  In the ""loadScriptName"" method of GroovyScriptEngine, it is calling ""conn.getURL().getPath()"" on the URLConnection to the resource.  Because there is a ""#"" character in the URL, this only returns the part of the URL up to the ""#"" character.

{code:title=GroovyScriptEngine.java|borderStyle=solid}
public Class loadScriptByName(String scriptName) throws ResourceException, ScriptException {
    URLConnection conn = rc.getResourceConnection(scriptName);
    String path = conn.getURL().getPath();
    ScriptCacheEntry entry = scriptCache.get(path);
    Class clazz = null;
    if (entry != null) clazz = entry.scriptClass;
    try {
        if (isSourceNewer(entry)) {
            try {
                String encoding = conn.getContentEncoding() != null ? conn.getContentEncoding() : ""UTF-8"";
                clazz = groovyLoader.parseClass(DefaultGroovyMethods.getText(conn.getInputStream(), encoding), path);
            } catch (IOException e) {
                throw new ResourceException(e);
            }
        }
    } finally {
        forceClose(conn);
    }
    return clazz;
}
{code}","Ubuntu Linux, Tomcat 7",blackdrag,jcwuerfl,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"15/Feb/12 12:49;dmikusa;AbstractHttpServlet.java.patch;https://issues.apache.org/jira/secure/attachment/12722913/AbstractHttpServlet.java.patch","15/Feb/12 12:49;dmikusa;AbstractHttpServletTest.groovy.patch;https://issues.apache.org/jira/secure/attachment/12722988/AbstractHttpServletTest.groovy.patch","08/Feb/12 14:18;dmikusa;groovyweb.tar.gz;https://issues.apache.org/jira/secure/attachment/12722159/groovyweb.tar.gz",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 05 02:52:12 UTC 2012,,,,,,,,,,"0|i2bpev:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Feb/12 08:51;blackdrag;I have the tendency to close this issue as ""Won't fix"", since I think we cannot really do anything about the limitation of URL#getPath. But before doing that... what is does ""multi-level context"" mean here?;;;","13/Feb/12 08:57;blackdrag;CARGO-734 seems to be a related issue from a different project;;;","13/Feb/12 09:00;jcwuerfl;Example:

/groovyweb        <- single level
/apps/groovyweb   <- multi-level


Where the groovy application is a sub-url 

This used to work in 1.6.5 version of Groovy until changes were made in 1.7 it looks like.   Under Tomcat autodeploy naming rules / contexts both are allowed see:


http://tomcat.apache.org/tomcat-7.0-doc/config/context.html#Naming


To me this is actually a huge issue that I would like to get resolved with GroovyScript.   Otherwise I have to define many different applications in our proxy for each application vs. just specifying a multi-level application aka : under /apps/myappname

Thanks!



;;;","13/Feb/12 11:02;blackdrag;Since 1.7 there is a new GroovyScriptEngine that uses the GroovyClassLoader and URLs instead of only path names, yes. But reenabling that is very difficult, the current design does not really allow for that and you would need a almost completely new GSE. You see the ""bug"" is actually the url logic in which # is used for other purposes. For the usage in an URL, you would normally have to ""encode"" it. My time with tomcat is quite a while back already, but wasn't there a way to rewrite the paths before the servlet gets those? If that exists, wouldn't that be an option for you?;;;","13/Feb/12 11:13;jcwuerfl;I'm dealing with this from an Operations/Infrastructure perspective and there is not an easy way to rewrite the paths before the servlet gets it that I'm aware of.   

However, wouldn't GSE need to conform to the TC Naming Context Rules ?   In other words I don't think this is a Tomcat issue ?  Why was it changed to include both URLs and path names in 1.7 vs. just the path names ?






;;;","13/Feb/12 11:26;dmikusa;I took a further look into this today and I think that my initial assessment was off a bit.  After further review, I believe that the GroovyScriptEngine#loadScriptByName method is not causing this problem, but it is the AbstractHttpServlet#getResourceConnection method which could be improved.

{code}
    public URLConnection getResourceConnection(String name) throws ResourceException {
        String basePath = servletContext.getRealPath(""/"");
        if (name.startsWith(basePath)) name = name.substring(basePath.length());

        name = name.replaceAll(""\\\\"", ""/"");

        //remove the leading / as we are trying with a leading / now
        if (name.startsWith(""/"")) name = name.substring(1);

        /*
        * Try to locate the resource and return an opened connection to it.
        */
        try {
            String tryScriptName = ""/"" + name;
            URL url = servletContext.getResource(tryScriptName);
            if (url == null) {
                tryScriptName = ""/WEB-INF/groovy/"" + name;
                url = servletContext.getResource(""/WEB-INF/groovy/"" + name);
            }
            if (url == null) {
                throw new ResourceException(""Resource \"""" + name + ""\"" not found!"");
            } else {
                url = new URL(""file"", """", servletContext.getRealPath(tryScriptName));
            }
            return url.openConnection();
        } catch (IOException e) {
            throw new ResourceException(""Problems getting resource named \"""" + name + ""\""!"", e);
        }
    }
{code}

Would it be possible to change this implementation to use a URI, which handles escaping invalid characters?  

I successfully tested this in the sample application by subclassing GroovyServlet and overriding getResourceConnection with the following code.

{code}
    public URLConnection getResourceConnection(String name) throws ResourceException {
        String basePath = servletContext.getRealPath(""/"");
        
        try {
            URI nameUri = new URI(name);
            name = nameUri.getPath();
        } catch (URISyntaxException ex) {
            // ignore and use existing name
        }
        
        if (name.startsWith(basePath)) name = name.substring(basePath.length());

        name = name.replaceAll(""\\\\"", ""/"");

        //remove the leading / as we are trying with a leading / now
        if (name.startsWith(""/"")) name = name.substring(1);

        /*
        * Try to locate the resource and return an opened connection to it.
        */
        try {
            String tryScriptName = ""/"" + name;
            URL url = servletContext.getResource(tryScriptName);
            if (url == null) {
                tryScriptName = ""/WEB-INF/groovy/"" + name;
                url = servletContext.getResource(""/WEB-INF/groovy/"" + name);
            }
            if (url == null) {
                throw new ResourceException(""Resource \"""" + name + ""\"" not found!"");
            } else {
            	URI realPath = new URI(""file"", """", servletContext.getRealPath(tryScriptName), """");
                url = realPath.toURL();
            }
            return url.openConnection();
        } catch (IOException e) {
            throw new ResourceException(""Problems getting resource named \"""" + name + ""\""!"", e);
        } catch (URISyntaxException e) {
            throw new ResourceException(""Problems getting resource named \"""" + name + ""\""!"", e);
	}
    }
{code};;;","13/Feb/12 11:55;blackdrag;ah, Daniel, I think this is a nice catch. Yes, this looks like it is possible. All you added is {code:Java}
        try {
            URI nameUri = new URI(name);
            name = nameUri.getPath();
        } catch (URISyntaxException ex) {
            // ignore and use existing name
        }
{code}
right?;;;","13/Feb/12 12:38;dmikusa;Two changes...

1.) At the top

{code}
        try {
            URI nameUri = new URI(name);
            name = nameUri.getPath();
        } catch (URISyntaxException ex) {
            // ignore and use existing name
        }
{code}

2.) Prior to the return

{code}
     URI realPath = new URI(""file"", """", servletContext.getRealPath(tryScriptName), """");
     url = realPath.toURL();
{code}

Sorry, I should have submitted a patch.;;;","13/Feb/12 13:43;guillaume;A patch attached to the JIRA issue, or a GitHub pull request would be awesome :-)
We always love contributions!;;;","15/Feb/12 10:35;jcwuerfl;Daniel, where you able to submit the patch then? or Guillaume were you going to do that then?

Thanks;;;","15/Feb/12 10:56;dmikusa;Working on it.  Should have it posted shortly.;;;","15/Feb/12 12:49;dmikusa;Attaching two patches against Groovy 1.8.6.

The first is a patch with the change that I proposed to the AbstractHttpServlet#getResourceConnection method.

The second is a patch to the test cases for AbstractHttpServlet.  With the change applied to AbstractHttpServlet, there are a few tests which will fail.  These seem to fail because the mock implementation of ""getRealPath"" is returning a relative path.  I've simply changed the mock implementation to return a full path (i.e. one that starts with ""/"").;;;","03/Dec/12 10:18;blackdrag;Daniel, first sorry for not coming back to this much earlier. It is nice to have a patch, but without the changes to the tests, the tests fail. This means it is not compatible with older versions, a breaking change. Such a change has no big chance to get into 1.8.x or 2.0.x. ;;;","03/Dec/12 12:16;jcwuerfl;So who normally creates the ""changes to the tests"" so that they do not fail? We need to get this done to make sure it will work with future versions.  Sorry, I'm an end user not a developer but following this but because deploying applications with autodeploy using the standard tomcat naming was breaking my applications.

Thank you to whomever can add the new test cases to get this resolved for future versions.;;;","03/Dec/12 14:56;blackdrag;I can change them, that in itself is not the problem. Changes to existing tests have to be justified. There are there to avoid regression and to avoid a breaking change is done accidentally. 

In an ideal world the patch would not require those test to be changed.

In the meantime I made several changes to AbstractHttpServlet, see https://github.com/groovy/groovy-core/blob/master/subprojects/groovy-servlet/src/main/java/groovy/servlet/AbstractHttpServlet.java#L170 We are now using URI in the beginning, so I see a chance your changes may not be required anymore. Though your patch goes further then just using the servlet base path, and I assume that is what is required for you as well. I wonder if we can go with a ""new File(servletContext.getRealPath(tryScriptName)).toURI().toURL().toExternalForm()"" and not break the tests;;;","05/Dec/12 02:52;blackdrag;James, I did a commit that for me works. I was able to use the multilevel context as well as not getting a 404 on the second try. I am marking the issue as resolved for now. I would like you to try out the change and confirm it is working for you as well. If it does not, we will have to open the issue again;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
invalid cast of null to int,GROOVY-5288,12816071,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,blackdrag,blackdrag,08/Feb/12 04:15,08/Feb/12 06:17,14/Jul/23 06:00,08/Feb/12 06:17,1.8.3,1.8.4,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,,,,,0,,,,,,"the program{code:Java}
ExpandoMetaClass.enableGlobally()
def proceed(){}
def checkResponse() {return null}

Integer responseCode = checkResponse()
if (responseCode == 200) {1.8.4 running in Grails 2.0.0     
 proceed()
}
{code}
will cause a ClassCastException because it tries to case null to in in a Groovy cast. This is due to responseCode being tried to inbox illegally using a GroovyCast. Instead no such cast should happen.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 08 06:17:08 UTC 2012,,,,,,,,,,"0|i2bptz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Feb/12 06:17;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
invalid unboxing in compare and other operations if primopts are enabled,GROOVY-5287,12816094,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,blackdrag,blackdrag,08/Feb/12 04:12,08/Feb/12 06:17,14/Jul/23 06:00,08/Feb/12 06:17,1.8.2,1.8.3,1.8.4,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,primtive opts,,,,0,,,,,,"the program{code:Java}
def proceed(){}
def checkResponse() {return null}

Integer responseCode = checkResponse()
if (responseCode == 200) {1.8.4 running in Grails 2.0.0     
 proceed()
} 
{code}
fails with a NPE in the == operation because it tries to unbox the response code, where it should have instead boxed the constant to do the dynamic compare.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 08 06:17:29 UTC 2012,,,,,,,,,,"0|i2cgkn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Feb/12 06:17;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Constant pool is used for not final fields too,GROOVY-5286,12818141,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,melix,melix,08/Feb/12 03:31,12/Feb/12 04:03,14/Jul/23 06:00,08/Feb/12 10:41,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,,,,,0,,,,,,"As a side effect to GROOVY-5150, the class constant pool is used for non final fields too:

I have this class:
{code}
public class A {
  public static int i = 5;
}
{code}
compile it with javac and you get the following related to i (using javap):

{code}
public static int i;

static {};
  Code:
   Stack=1, Locals=0, Args_size=0
   0:   iconst_5
   1:   putstatic       #2; //Field i:I
   4:   return
{code}

Compile it with groovyc and these days I seem to get this:
{code}
public static int i;
  Constant value: int 5
{code}
Now I thought the 'constant value' attribute for field objects was for proper constants (i.e. final fields), not for initialization values.  That seems to be what it indicates here: 
===
4.7.2 The ConstantValue Attribute

The ConstantValue attribute is a fixed-length attribute used in the attributes table of the field_info (§4.5) structures. A ConstantValue attribute represents the value of a constant field that must be (explicitly or implicitly) static;
===

Indeed javac will only use that attribute if I make the field final.

Now the JVM doesn't seem to be particularly strict here and the static does get the right value initially and allow it to be changed (at least on the VM version I'm using, haven't tried any others).  It just seems to be a slight abuse of the meaning of constant value.  I guess I just wanted to check it was deliberate.

thanks,
Andy
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-02-08 03:31:06.0,,,,,,,,,,"0|i2bybb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
super.setMetaClass() generates StackOverflowError when there is no base class,GROOVY-5285,12816105,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,hojerst,hojerst,07/Feb/12 05:29,13/May/12 03:30,14/Jul/23 06:00,17/Feb/12 03:29,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,,,,,0,breaking,,,,,"The following code will generate a StackOverflowError. It seems ""setMetaClass(MetaClass)"" is called recursivly, although ""super.setMetaClass(MetaClass)"" is used. Note that this problem only occures when ""Test"" has no base class.

{code}
class Test {
    void setMetaClass(MetaClass metaClass) {
        super.setMetaClass(metaClass)
    }
}

def obj = new Test()
obj.metaClass = obj.metaClass
{code}

On the other hand, the following code works just fine:

{code}
class Base {}

class Test extends Base {
    void setMetaClass(MetaClass metaClass) {
        super.setMetaClass(metaClass)
    }
}

def obj = new Test()
obj.metaClass = obj.metaClass
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 17 03:29:36 UTC 2012,,,,,,,,,,"0|i2c45r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Feb/12 08:30;melix;This occurs because in {{Test}}, super.setMetaClass is compiled as invokeMethodOnSuperN. As the super class is Object, it ends up with DGM#setMetaClass, which, if the object is a {{GroovyObject}}, calls {{setMetaClass}} on the object itself. In that case, {{Test}} is a {{GroovyObject}}, so the method is called recursively, leading to the stack overflow error.;;;","17/Feb/12 03:29;melix;This will only be fixed in the 2.0 release because of a potential breakage. Now, the {{DGM#setMetaClass}} method will not check for an object to be a {{GroovyObject}}. This prevents from the stack overflow, but we had to introduce a new ""delegating"" helper method in {{MetaClassHelper}} to reproduce the old behaviour where it was necessary (3 instances in the code base).

See https://github.com/groovy/groovy-core/commit/c146b063b0ca7a82b3d664007f8525262558e8d3;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DOMCategory: NullPointerException in setValue() when element has no text,GROOVY-5280,12816058,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,dbwhitaker,dbwhitaker,04/Feb/12 01:17,12/Feb/12 04:03,14/Jul/23 06:00,05/Feb/12 00:28,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,XML Processing,,,,0,,,,,,"NullPointerException at groovy.xml.dom.DOMCategory.setValue(DOMCategory.java:261) if setting value on element that has no text. 

Example is to modify input in the example shown on the ""Updating XML with DOMCategory"" page (http://groovy.codehaus.org/Updating+XML+with+DOMCategory) to include an empty<item/>  element, like this: 

 ...
      <category type=""groceries"">
          <item>Chocolate</item>
          <item>Coffee</item>
          <item/>
      </category>
 ...

 This modification to input causes NullPointerException at this line in the
 example:

          g.value = 'Luxury ' + g.text() ",any,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Feb 05 00:28:56 UTC 2012,,,,,,,,,,"0|i2cp5z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Feb/12 00:28;paulk;Fixed. Thanks for the suggestion Brad.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovysh holds a grudge - ,GROOVY-5279,12816104,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,jfager,jfager,03/Feb/12 12:44,12/Feb/12 04:03,14/Jul/23 06:00,06/Feb/12 15:47,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,Groovysh,,,,0,,,,,,"Make a simple typo (in this case, opening a string with a doublequote and closing it with a singlequote) and groovysh holds it against you for the rest of the session, refusing to do anything except remind you of your mistake:


jasonf-mbp:~ jasonf$ groovysh
Groovy Shell (1.8.5, JVM: 1.6.0_29)
Type 'help' or '\h' for help.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
groovy:000> println ""hello""
hello
===> null
groovy:000> println ""hello'
groovy:001> println ""hello""
ERROR org.codehaus.groovy.control.MultipleCompilationErrorsException:
startup failed:
groovysh_parse: 1: expecting anything but ''\n''; got it anyway @ line 1, column 16.
   println ""hello'
                  ^

1 error

        at java_lang_Runnable$run.call (Unknown Source)
groovy:001> println ""hello""
ERROR org.codehaus.groovy.control.MultipleCompilationErrorsException:
startup failed:
groovysh_parse: 1: expecting anything but ''\n''; got it anyway @ line 1, column 16.
   println ""hello'
                  ^

1 error

        at java_lang_Runnable$run.call (Unknown Source)
groovy:001> 
",Mac OS X 10.6.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 06 04:56:38 UTC 2012,,,,,,,,,,"0|i2c29r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Feb/12 14:52;jwagenleitner;You can use the {{clear}} command to exist that buffer and return to the {{groovy:000>}} prompt.;;;","03/Feb/12 15:26;jfager;Thank you, that works.  The documentation on clear could stand to be fleshed out a bit to make it obvious that it's useful for this sort of situation - 'Clear the current buffer' isn't very enlightening, especially in the context of what clearing a buffer means for some other shells.    ;;;","04/Feb/12 04:25;blackdrag;if you have a suggestion of what exactly it should say, then we could change the text ;;;","05/Feb/12 21:16;jfager;What about something like ""Clears the current buffer, resetting the prompt counter to 000.  Can be used to recover from compilation errors.""? ;;;","06/Feb/12 04:56;blackdrag;Guillaume will see to it;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy allows top-level classes be marked as private,GROOVY-5278,12816056,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,02/Feb/12 14:28,14/Feb/12 07:55,14/Jul/23 06:00,14/Feb/12 07:55,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,,,,,0,breaking,,,,,"Groovy allows to make a class like this: private class X{}.
The result is a top level class, that will be having the private modifier set. But the JVM spec does not include this modifier in the allowed modifiers for classes. Instead this modifier is supposed to be a reserved flag for future use. The violation of this causes internal errors when using indy.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 14 07:55:13 UTC 2012,,,,,,,,,,"0|i2csx3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Feb/12 04:19;blackdrag;I reduced the priority a bit because I found it was not this, that causes the indy internal error. The same issue happens with package scoped classes. Also those private classes are quite a bit in use it seems. It would maybe be better to provide an implementation for example as static inner class or such;;;","13/Feb/12 05:09;blackdrag;we decided to make it fail at compilation for now;;;","14/Feb/12 07:55;blackdrag;I implemented the compiler check, which will now throw an exception if it encounters a private top level class;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SecureASTCustomizer doesn't check class methods,GROOVY-5277,12816100,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,michael971,michael971,02/Feb/12 10:16,12/Feb/12 04:03,14/Jul/23 06:00,06/Feb/12 05:03,1.8.4,1.8.5,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,GroovyScriptEngine,,,,0,,,,,,"The ""call"" - method in SecureASTCustomzer doesn't check class methods content
Instead of 
{code}
  BlockStatement bstmt = ast.getStatementBlock();
  bstmt.visit(new SecuringCodeVisitor());
{code}
should be:
{code}
 BlockStatement bstmt = ast.getStatementBlock();
        SecuringCodeVisitor visitor = new SecuringCodeVisitor();
        bstmt.visit(visitor);
        for (ClassNode clNode : ast.getClasses()) {
            for ( MethodNode methodNode : clNode.getMethods()) {
                if (methodNode.getCode() instanceof BlockStatement) {
                    BlockStatement blst = (BlockStatement) methodNode.getCode();
                    blst.visit(visitor);
                }
            }
{code}",does not matter,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 06 05:03:28 UTC 2012,,,,,,,,,,"0|i2bt3z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Feb/12 10:58;melix;Can you attach a test case which demonstrates the problem? Thanks!;;;","06/Feb/12 05:03;melix;https://github.com/groovy/groovy-core/commit/dda7e0a0f5de7fdd676a83d482dbdd5ae4f82f7f;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CLONE - Problem with @InheritConstructors with multiple level of inheritance,GROOVY-5274,12816096,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ronan_michaux,ronan_michaux,02/Feb/12 03:04,12/Feb/12 04:03,14/Jul/23 06:00,06/Feb/12 19:47,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,Compiler,,,,0,,,,,,"See test eclipse project attached.

- Class Hierarchy : A <-- inherit -- B <-- inherit -- C

- A define constructor public A(String dummy){...}

- B and C use  @InheritConstructors.

- In the main(...) : C.class.newInstance(""tata"")

- Result : Exception in thread ""main"" groovy.lang.GroovyRuntimeException: Could not find matching constructor for: data.C(java.lang.String)
	at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1474)
	at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1390)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeConstructorOf(InvokerHelper.java:824)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.newInstance(DefaultGroovyMethods.java:17689)
	at org.codehaus.groovy.runtime.dgm$511.doMethodInvoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.invoke(StaticMetaMethodSite.java:43)
	at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.call(StaticMetaMethodSite.java:88)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at Main.MainLaunch.main(MainLaunch.groovy:7)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5221,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 06 19:48:32 UTC 2012,,,,,,,,,,"0|i2bxav:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"02/Feb/12 03:06;paulk;this issue is the actual fix whereas GROOVY-5221 is to fix the doco in the meantime;;;","06/Feb/12 03:51;blackdrag;assigned to Paul;;;","06/Feb/12 19:48;paulk;This should now be resolved and the temporary warning about the limitations has been removed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Intermittant/random incorrect resolution of sub-interface constant values,GROOVY-5272,12818140,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ssummer,ssummer,31/Jan/12 07:54,13/May/12 03:30,14/Jul/23 06:00,13/Feb/12 03:27,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,groovy-jdk,,,,0,,,,,,"If a constant in a sub-interface replaces/shadows a constant in a super interface (both Java), when trying to access the sub-interface's constant value from Groovy, the behaviour is intermittantly incorrect - sometimes the sub-interface's value is returned (correct) and sometimes the super interface's value is returned (incorrect).
In Java the sub-interface's value is always returned, as expected.

See source code below that demonstrates this: InterfaceA.java, InterfaceB.java, ShowBugGroovy.groovy, ShowBugJava.java
If ShowBugGroovy is repeatedly run, sometimes the assertion fails, sometimes it passes (randomly?). I believe the behaviour is the same for concrete implementations of the sub-interface.

{code}
package groovybug;

public interface InterfaceA {
    String FOO=""Foo A"";
}
{code}

{code}
package groovybug;

public interface InterfaceB extends InterfaceA {
    String FOO=""Foo B"";
}
{code}

{code}
package groovybug

class ShowBugGroovy {
    static main(args) {
        println(""Interface A: "" + InterfaceA.FOO);
        println(""Interface B: "" + InterfaceB.FOO);

        // Fails randomly
        assert(InterfaceA.FOO!=InterfaceB.FOO)
    }
}
{code}

{code}
package groovybug;

public class ShowBugJava {
    public static void main(String[] args) {
        System.out.println(""Interface A: "" + InterfaceA.FOO);
        System.out.println(""Interface B: "" + InterfaceB.FOO);

        // Always passes
        assert(!InterfaceA.FOO.equals(InterfaceB.FOO));
    }
}
{code}
",Windows XP and LINUX,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5335,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 06 11:03:00 UTC 2012,,,,,,,,,,"0|i2ckbz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"06/Feb/12 03:26;blackdrag;that should be a sorting issue somewhere, where we depend on the VM sorting, which is not guaranteed. ;;;","06/Feb/12 08:49;melix;Thanks for reporting this. It's also interesting to notice that Groovy will now enforce deterministic behaviour to return the same value in case of ambiguous static field, like in the example below:

{code}
public interface InterfaceA {
    String FOO=""Foo A"";
}
public interface InterfaceB extends InterfaceA {
    String FOO=""Foo B"";
}
public interface InterfaceC extends InterfaceA {
    String FOO=""Foo C"";
}

class A implements InterfaceB, InterfaceC {
}

assert A.FOO == 'Foo C'
{code}

https://github.com/groovy/groovy-core/commit/7928038221f88b12db6d23f2d12a53e78a3cd52d;;;","06/Feb/12 11:03;melix;Reopening because the fix introduces a regression in Grails.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
getting java.lang.VerifyError depending on some simple method content,GROOVY-5267,12816097,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,jprobichaud,jprobichaud,27/Jan/12 09:53,12/Feb/12 04:03,14/Jul/23 06:00,31/Jan/12 10:54,1.7.10,1.8.0,1.8.4,1.8.5,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,Compiler,,,,0,,,,,,"This is a very strange issue.  Everything was working but then I added some very basic code in a method and I'm now seeing this issue with 1.7.10, 1.8.0 & 1.8.4:  The openStore() method is throwing java.lang.VerifyError when I activate line 104 below but it works if I comment 104 and activate 103.

I've attached a zip file with lucene jars, two groovy files and one runme.sh script.

Thanks for looking into this!

BTW, I'm seeing the same issue with groovy-2.0.0-beta-2

In LuceneStore.groovy (attached)
{code}
    97          /* FIXME: Bug triggers here
    98             with this line, everything works:
    99                  writer.setRAMBufferSizeMB(400);
   100             with this line, we get the java.lang.VerifyError
   101                 writer.setRAMBufferSizeMB(defaultRamBufferSize());
   102          */       
   103         // writer.setRAMBufferSizeMB(400);
   104         writer.setRAMBufferSizeMB(defaultRamBufferSize());
{code}","linux 64bit, sun jvm 1.6.0.29, ",jprobichaud,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Jan/12 09:53;jprobichaud;bugreport.zip;https://issues.apache.org/jira/secure/attachment/12722166/bugreport.zip","27/Jan/12 09:53;jprobichaud;bugreport.zip;https://issues.apache.org/jira/secure/attachment/12722647/bugreport.zip","27/Jan/12 10:51;melix;verifyerror.groovy;https://issues.apache.org/jira/secure/attachment/12722597/verifyerror.groovy",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jan 28 04:05:08 UTC 2012,,,,,,,,,,"0|i2bto7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"27/Jan/12 10:26;melix;confirmed on 1.8.5 and master too;;;","27/Jan/12 10:35;melix;The problem is most likely due to the fact you've written {{writer.setRAMBufferSizeMB(defaultRamBufferSize())}} instead of {{writer.setRAMBufferSizeMB(defaultRamBufferSize)}} (defaultRamBufferSize is an int, not a method nor a closure). However, a VerifyError should not happen.=;;;","27/Jan/12 10:51;melix;Attached a simpler example which triggers the same error (on 1.8.X, not on master, where an NPE is thrown instead).;;;","27/Jan/12 10:53;melix;Stripped down:
{code}
class Bar {
   int defaultValue = 40
   void m() {
    defaultValue()
   }
}
new Bar().m()
{code};;;","27/Jan/12 11:11;jprobichaud;oh, wow, good catch :) removing this typo (not sure why I ended up with that, I'm currently re-factoring some code) makes everything working properly now.

I guess a ""no such method"" exception would have been better :)

Thanks!;;;","28/Jan/12 04:05;blackdrag;I set it as critical bug for 1.8,so we don't forget about this one;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem currying null parameters,GROOVY-5262,12818135,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,brownj,brownj,25/Jan/12 08:51,12/Feb/12 04:03,14/Jul/23 06:00,06/Feb/12 04:52,1.8.0,1.8.1,1.8.2,1.8.3,1.8.4,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,,,,,0,,,,,,"When I apply the spread operator to a List containing a single null and use the result of that as an argument to .curry, an NPE is thrown with 1.8.x but not with 1.7.10.

{noformat:borderStyle=solid|title=script1.groovy}
c = { x ->
    println ""X is ${x}""
}

args = [42]

c = c.curry(*args)

c()
{noformat}

{noformat:borderStyle=solid|title=script2.groovy}
c = { x, y ->
    println ""X is ${x}""
    println ""Y is ${y}""
}

args = [42, 2112]

c = c.curry(*args)

c()
{noformat}

{noformat:borderStyle=solid|title=script3.groovy}
c = { x, y ->
    println ""X is ${x}""
    println ""Y is ${y}""
}

args = [null, null]

c = c.curry(*args)

c()
{noformat}

(This next script is the problematic one...)

{noformat:borderStyle=solid|title=script4.groovy}
c = { x ->
    println ""X is ${x}""
}

args = [null]

c = c.curry(*args)

c()
{noformat}

With Groovy 1.7.10:

{noformat}
curry $ groovy -version
Groovy Version: 1.7.10 JVM: 1.6.0_29
curry $ 
curry $ groovy script1
X is 42
curry $ 
curry $ groovy script2
X is 42
Y is 2112
curry $ 
curry $ groovy script3
X is null
Y is null
curry $ 
curry $ groovy script4
X is null
curry $
{noformat}

With Groovy 1.8.5:

{noformat}
curry $ groovy -version
Groovy Version: 1.8.5 JVM: 1.6.0_29 Vendor: Apple Inc. OS: Mac OS X
curry $ groovy script1
X is 42
curry $ groovy script2
X is 42
Y is 2112
curry $ groovy script3
X is null
Y is null
curry $ groovy script4
Caught: java.lang.NullPointerException
java.lang.NullPointerException
	at script4.run(script4.groovy:7)
{noformat}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 06 04:52:35 UTC 2012,,,,,,,,,,"0|i2ch27:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jan/12 09:52;brownj;A slightly more simple script which demonstrates what I think is the same problem:

{code:borderStyle=solid|title=script5.groovy}
c = { x ->
    println ""X is ${x}""
}


c = c.curry(null)

c()
{code}

With Groovy 1.7.10:

{noformat}
curry $ groovy -version
Groovy Version: 1.7.10 JVM: 1.6.0_29
curry $ 
curry $ groovy script5
X is null
{noformat}

With Groovy 1.8.5:

{noformat}
curry $ groovy -version
Groovy Version: 1.8.5 JVM: 1.6.0_29 Vendor: Apple Inc. OS: Mac OS X
curry $ 
curry $ groovy script5
Caught: java.lang.NullPointerException
java.lang.NullPointerException
	at script5.run(script5.groovy:6)
{noformat}
;;;","26/Jan/12 09:55;melix;Paul, if you read this: I was working on GROOVY-5262. Using git bisect, I found that the fix on master is from  GROOVY-4954 (be7e76536e8aec62e08a527143fe8a1998dc1dfb) but it wasn't on groovy 1.8.x branch. cherry picking lead me to a merge problem, where I found this comment in ClosureCurryTestCase: {{""/* reverted  for the sake of Grails""}}. Does it mean the fix introduces a bug in Grails ?
;;;","27/Jan/12 08:04;melix;I backported the change (https://github.com/groovy/groovy-core/commit/6344429b8db756caf4f036e2d84dceb8337becb5). I'll keep this ticket open until we make sure that this doesn't trigger any problem in Grails anymore. If it does, please comment on that ticket to give us more hints about the problem.;;;","05/Feb/12 05:52;paulk;Hi Cédric, yes as per GROOVY-4954 there was apparently some problem at the time wrt Grails. I didn't have visibility to what the problem was or whether it has been subsequently fixed.;;;","06/Feb/12 04:52;blackdrag;since the fix is now in 1.8 and 2.0 I am closing the issue now. I put in Paul as assignee, since it was his commit. 

Anyway, if there are problems we can reopen the issue of course;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
A static method call inside a static closure bypasses closure delegate behavior,GROOVY-5261,12816067,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,graemerocher,graemerocher,25/Jan/12 07:30,01/Jul/14 02:53,14/Jul/23 06:00,15/Aug/13 09:42,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.7,2.2.0-beta-2,,,,,,1,,,,,,"Given the following code:

{code}

class Website {
    Long id
    String url
    Load load
    
    static constraints = {
        Website.load 1
        load nullable:true
        url url:true
    }
    
    static Website load(Long id) {
        Website.get(id)
    }
}

class Load {
    Long id
    Integer connections
}
{code}

The call to:

{code}
load nullable:true
{code}

Will not go through the closure and instead dispatch directly as a static method call. This means it is impossible to control DSL definition. At the AST level the above call seems to be a StaticMethodCallExpression. This is strange because:

{code}
Website.load 1
{code}

Is a normal method call expression. Method calls defined in static closures should never be StaticMethodCallExpression instances otherwise a DSL author cannot control the method dispatch.",,blackdrag,bond_,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6883,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 15 09:42:34 UTC 2013,,,,,,,,,,"0|i2cphj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jan/12 06:59;graemerocher;Example in script http://groovyconsole.appspot.com/script/624002;;;","26/Jan/12 07:24;blackdrag;an addition to the example: if there is no bar method or if the bar method has more or less parameters than what the block request, then it works. For example if bar takes no parameters it works. It works too if there is no bar at all in FOO.;;;","26/Jan/12 07:24;blackdrag;IMHO this speaks for some code trying to match by the number of arguments only;;;","11/May/12 04:30;graemerocher;Are there any plans to fix this yet? ;;;","07/Oct/12 14:23;bond_;A Note:
Blocked Grails issue: http://jira.grails.org/browse/GRAILS-8669;;;","15/Aug/13 09:42;blackdrag;fixed in 8231c0ba60d99a3e66e361f51bf66a75ddca1fd4;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovyc stub generation doesn't handle all primitive types properly,GROOVY-5260,12818428,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,rumour,rumour,24/Jan/12 14:17,12/Feb/12 04:03,14/Jul/23 06:00,25/Jan/12 04:41,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,Ant integration,Stub generator / Joint compiler,,,0,,,,,,"The problem manifests when a long value is effectively being changed to an 'int' and results in an exception during compilation.

Example class:
{code}
class AnObject {
    public static final long serialVersionUID = -5239748510188117876L
}
{code}
Using groovy 1.8.5, the generated stub (during joint compilation using the 'Groovyc' ant taskdef) looks like (sans imports):

{code}
public class AnObject implements
    groovy.lang.GroovyObject {
public static final long serialVersionUID = -5239748510188117876;
}
{code}

The problem is that this yields a compilation exception 'integer number too large'.

If you exclude the 'public' keyword on the member definition and re-compile, the stub instead looks like:
{code}
public class AnObject implements
    groovy.lang.GroovyObject {
public static final  long getSerialVersionUID() { return (long)0;}
}
{code}

This can then compile successfully. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 25 01:55:28 UTC 2012,,,,,,,,,,"0|i2bzjj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Jan/12 01:55;blackdrag;So the difference between the two is, that the first one is a field, the second one a property (no public modifier given) and that we give in the value for the field directly, because Java wants that sometimes. It is imho not wrong to do so, but what is missing is the L at the end of the number to identify it as a long, since Java does not do autopromotion for literal numbers.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError - cannot access outer class static final fields from an inner class,GROOVY-5259,12816063,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,rumour,rumour,24/Jan/12 12:38,12/Feb/12 04:03,14/Jul/23 06:00,25/Jan/12 16:29,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,Compiler,,,,0,,,,,,"Trying to access an outer class 'constant' (i.e. static final) from within an inner class results in a java.lang.VerifyError.  

The problem only manifests if the inner class is extending something; if it is not extending another class, access to the outer class member will work.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"25/Jan/12 05:15;melix;Groovy5259Bug.groovy;https://issues.apache.org/jira/secure/attachment/12722365/Groovy5259Bug.groovy","24/Jan/12 12:38;InnerAccessOuter.groovy;https://issues.apache.org/jira/secure/attachment/12722910/InnerAccessOuter.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 25 16:30:32 UTC 2012,,,,,,,,,,"0|i2bonz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"25/Jan/12 05:15;melix;Attaching an alternate test case showing that the problem is more likely related to the inner class constructor.;;;","25/Jan/12 16:30;melix;See https://github.com/groovy/groovy-core/commit/26d4ad70154b14e2ea5e45099bc77ae5f11305c7;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checker incorrectly handles assignments of variables used as parameters in control structures,GROOVY-5258,12816034,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,23/Jan/12 07:37,13/May/12 03:30,14/Jul/23 06:00,23/Jan/12 07:44,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,,,,,0,,,,,,"Imagine the following code:
{code}
Double foo(Integer x) { x+1 }
Integer foo(Double x) { x+1 }
def x = 0
for (int i=0;i<10;i++) {
   // there are two possible target methods. This is not a problem for STC, but it is for static compilation
   x = foo(x)
}
{code}

The type checker should not allow this to compile. There are more cases (even more complex) like this in the patch ({{groovy.transform.stc.LoopsSTCTest}}).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-01-23 07:37:03.0,,,,,,,,,,"0|i2c05z:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Node.ReplaceNode method fails cannot remove itself,GROOVY-5257,12815900,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,escalope,escalope,21/Jan/12 02:46,12/Feb/12 04:03,14/Jul/23 06:00,02/Feb/12 03:02,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,XML Processing,,,,0,,,,,,"Perhaps this is not a frequent operation, but replaceNode method fails because of a nullpointer exception. The case corresponds to removing a root node from a xml document. This node has no parent (parent==null) and that is the point where the error is triggered. This may be considered a bad programming, but, anyway, the code should return something different from an exception.","ubuntu 11.04, eclipse 3.6, groovy eclipse plugin2.6.0.xx-20111212-0800-e36-RELEASE",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/Jan/12 02:46;escalope;RemoveNodeFailureTest.groovy;https://issues.apache.org/jira/secure/attachment/12722646/RemoveNodeFailureTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 02 03:02:03 UTC 2012,,,,,,,,,,"0|i2brpz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"21/Jan/12 06:01;paulk;It might be appropriate to return an Exception but probably not the NPE currently seen - possibly an {{UnsupportedOerationException}} with a clearer message. Incidentally, just noticed that the same applies to the {{plus(Closure)}} method as well.;;;","22/Jan/12 02:53;escalope;I agree. A minimum should be an exception signalling ""you cannot remove the document's root node"". Nevertheless, this restriction may constraint too much the kind of traversal you make over a DOM tree.

In my example, I removed the node. However, if one intends to modify the root node, the same exception happens. Then, operations like removing an attribute or adding an attribute to a DOM tree cannot be programmed if they imply to modify the root node. 

I think it is possible a more generic still robust solution, but need to study further the sources.;;;","22/Jan/12 02:54;escalope;Sorry, when I meant ""adding an attribute"" I should have said ""replacing the node by another having different attributes"" which is what the replaceNode is for. ;;;","23/Jan/12 05:23;paulk;Given that attempting to ""replace"" the root node currently fails, I am inclined to return an UnsupportedOperationException for now until some better semantics is defined.

It would certainly be possible to define the semantics for XmlParser and probably the DOM Category as well so that if the building closure returned a single node that it was returned as a ""root"" node. However, given that in other cases the replaceNode method mutates some existing data structure whereas the new semantics would just return a new node in the case of being a root node, then it might be a little unexpected.

Just on the use case of changing a node's attributes, for both XmlParser and XmlSlurper you can get access to the attributes() map and make changes that way. For XmlSlurper this is actually kind of cheating because for nearly all other cases we treat the tree as mostly immutable and have changes kept as a tree of closure updates - so we may fix that hole in a future version of XmlSlurper.
;;;","23/Jan/12 06:06;escalope;You are more than right. 

I am not a groovy expert, but the behavior I suggested may contradict the replaceNode semantics when the root node is regarded. ReplaceNode requests are delivered because a there is a reference to the DOM root you are using. It replaceNode creates a new node for root, then the reference to the root node you were using becomes invalid and it is not possible to retrieve by regular means unless some additional programming is inserted. This happens as well with intermediate nodes, but those cases are not extreme since references to the new nodes can always be retrieved if there is a reference to the DOM root node. 

Thus, it makes sense to warn developers that, when replaceNode affects a root node of a DOM, an exception will be raised and make this the default behaviour in the API. ;;;","02/Feb/12 03:02;paulk;This is fixed for XmlParser and DOMCategory (and the underlying groovy.util.Node) by returning an {{UnsupportedOperationException}} but not so for XmlSlurper which attempts to allow you to create XML fragments at any place including (conceptually) the root.

Arguably, replaceNode should actually return the replaced node not the last node added while replacing - but that should be raised as a separate issue with appropriate feedback from the mailing list.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong generation of stubs with Generics,GROOVY-5256,12814764,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,rnd,rnd,19/Jan/12 04:27,13/May/12 03:30,14/Jul/23 06:00,13/Feb/12 05:09,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,Stub generator / Joint compiler,,,,0,,,,,,"When a Groovy class uses generics and is based on classes from other modules which use generics as well, the compiler generates wrong method signatures in the stub.  When all classes are located in the same module, the stub is generated correctly.

The attached archive contains a Maven2 project with two sub-modules, where module2 contains a Groovy class and depends on module1.  During {{mvn clean install}}, a Groovy stub with the following constructor declaration is generated in {{module2/target}}:
{code}
public Hl7v3ContinuationAwareProducer
(module1.cont.Hl7v3ContinuationAwareEndpoint endpoint, module1.core.JaxWsClientFactory clientFactory) {
super ((module1.core.AbstractWsEndpoint<ComponentType extends module1.core.AbstractWsComponent<java.lang.Object extends java.lang.Object>>)null, (module1.core.JaxWsClientFactory)null, (java.lang.Class<InType>)null, (java.lang.Class<OutType>)null);
}
{code}
","Windows XP 5.1.2600, JDK 1.6.0_21, Groovy 1.8.5",davide.cavestro,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"19/Jan/12 04:27;rnd;stubtest.zip;https://issues.apache.org/jira/secure/attachment/12722909/stubtest.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 13 05:09:36 UTC 2012,,,,,,,,,,"0|i2cbpj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Feb/12 05:09;paulk;should be fixed, thanks for reporting the issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Avoid unnecessary locking in ClassInfo.getMetaClass,GROOVY-5249,12816086,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,snekoval,snekoval,12/Jan/12 15:15,06/Feb/18 11:34,14/Jul/23 06:00,02/Apr/14 07:31,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.3,2.3.0-beta-1,,groovy-runtime,,,,13,,,,,,"We have a Grails application serving hundreds of requests per second and this seems to be the most critical hot spot for us. Under high load, most threads are blocked in the following call stack:
{code}
""http-apr-8080""-exec-144
sun.misc.Unsafe.park(Native Method)
java.util.concurrent.locks.LockSupport.park(LockSupport.java:158)
java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811)
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:842)
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1178)
org.codehaus.groovy.util.LockableObject.lock(LockableObject.java:34)
org.codehaus.groovy.reflection.ClassInfo.lock(ClassInfo.java:268)
org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:193)
org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:214)
org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:747)
org.codehaus.groovy.runtime.InvokerHelper.invokePojoMethod(InvokerHelper.java:780)
org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:772)
org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToBoolean(DefaultTypeTransformation.java:156)
org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.booleanUnbox(DefaultTypeTransformation.java:65)
{code}

Grails uses {{InvokerHelper}} a lot, which calls {{ClassInfo.getMetaClass}} which uses locking. This is stop-the-world lock affecting all threads (they all hit the same {{ClassInfo}} instance). Note that 99,999% of time the locking is useless as nothing is modified (typically all metaclasses getting modified on startup). 

There are several related tickets: GROOVY-3557 and GROOVY-5059, not really solving the issue.

The solution could be to use more fine-grained locks (ReadWriteLock) or Atomics. Should be easy to implement, but need to isolate modification part from read-only parts.

Doing so can be a good boost to overall Grails performance.","Linux 64-bit, Java 1.6, Tomcat, Grails",alexkra,blackdrag,bura,fedotxxl,jgritman,jsondow,KenLiu,lhotari,mtg.ken.lam,snekoval,tim_yates,tty,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Jan/12 05:27;blackdrag;mc.patch;https://issues.apache.org/jira/secure/attachment/12723019/mc.patch","13/Jan/12 16:15;blackdrag;mc.patch;https://issues.apache.org/jira/secure/attachment/12721724/mc.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 06 11:34:39 UTC 2018,,,,,,,,,,"0|i2cm0v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jan/12 04:09;blackdrag;If I look at the locking I see that it is done on a per ClassInfo instance base. That means it is possible to get multiple meta classes at the same time even with this locking. The reason why it is a ""stop the world lock"" for you is probably that all your threads go the boolean#asType path. That means all many of your threads request one and the same ClassInfo instance to then block each other until they are served one-by-one. 

A meta class change relevant for this locking can happen in two cases. 
(1) the older instance was garbage collected (which cannot happen with a modified meta class) 
(2) you changed the meta class manually

While you say you do (2) at the beginning we have to try to design the core to enable (2) all the time atm. 


;;;","13/Jan/12 04:10;lhotari;Serge, could you provide a test case that shows the problem? I know it's easy to reproduce, but it helps getting this one fixed if you can provide a simple test case the shows the problem. You could also write a test case in pure Java that shows the performance difference to the Groovy version.
I'd prefer a standalone test class instead of a Grails app that shows the problem. In Grails, ExpandoMetaClass.enableGlobally() is used, so your Groovy test case should probably do that too.
;;;","13/Jan/12 04:28;blackdrag;let us think about a Read-WriteLock.... what currently calls lock should do the write lock. Then we can use the internal code to do the read locks.;;;","13/Jan/12 05:32;snekoval;bq. is probably that all your threads go the boolean#asType path. That means all many of your threads request one and the same ClassInfo instance to then block each other until they are served one-by-one. 

That's right. We have lots of calls similar to the following:
{code}
translations.any { it.toLowerCase().contains(text) }
{code}
(sometimes even nested). I guess it will request {{getClassInfo(Boolean.class)}} inside a long loop.

From what I see in {{ClassInfo}} there are actually two different methods:
# {{getMetaClass()}}
# {{getMetaClass(Object obj)}} - checks if instance has an instance-level metaclass assigned, then locks.

{{InvokerHelper}} goes to the *second* one. Since objects _rarely_ have instance-level metaclasses assigned, there's a high chance to get blocked here.;;;","13/Jan/12 16:15;blackdrag;Serge, could you test if this patch makes a difference for you?;;;","26/Jan/12 07:35;snekoval;Hello. I've tried to patch groovy 1.7.10 and got the same problem.
I see your patch applies to {{ClassInfo.getMetaClass()}} while the most critical execution path is {{ClassInfo.getMetaClass(obj)}}.;;;","27/Jan/12 05:27;blackdrag;Sorry for the mistake, here is the correct version;;;","26/Mar/12 11:16;juanformoso;Did the fixed patch work? Is it going to be included in a future version?;;;","26/Mar/12 15:06;snekoval;Hi, we've upgraded to Grails 2.0 recently, which resolved some of our issues. I will try to squeeze the patch into Grails 2.0 production (it's somewhat tricky) and see how it affects our performance graphs. This will take about a week.;;;","09/Apr/12 15:20;jsondow;FYI, Netflix's internal Grails-based tooling is running into this bug pretty often now. We're rewriting the worst bottleneck parts of our code as needed until the fix comes out. Mostly we're reducing use of find() or any() or findAll() in frequently-called nested closures or nested iterations.;;;","10/Apr/12 04:09;blackdrag;Joe, Serge seems not to have the time to test it yet. Can you test the patch?;;;","13/Apr/12 19:17;jgritman;Hi, I work with Joe at Netflix. We're no longer seeing this problems as frequently after tweaking a few places where we were doing nested find() calls while iterating over a large collection.

I'll try to test the patch if I get a chance. Since it's somewhat tricky to reproduce the problems, it might be a while before I get to it. Prior to those fixes, this problem was causing our Grails app to become unresponsive almost daily.;;;","20/Apr/12 09:15;lhotari;There is a thread on Grails mailing list that has interesting findings of performance of calling private helper methods in a closure:
http://grails.1312388.n4.nabble.com/Thread-Blocking-at-Groovy-ExpandoMetaclass-method-in-a-Grails-App-tp4572990p4574077.html
(the FilterConfig performance problem is a grails problem, but the later introduced StoryDao example is interesting from Groovy performance point of view)

Surprisingly a workaround is to call the helper method on ""thisObject"" prefix. Based on the stacktrace this seems to be some problem in ExpandoMetaClass which is enabled globally in Grails. There seems to be a bug in ExpandoMetaClass's addSuperMethodIfNotOverridden . It only handles ClosureMetaMethod instances. 
;;;","28/Apr/12 03:32;lhotari;Joe & Jason, GROOVY-5428 explains the bad performance of find(), any() or findAll() in certain cases. Have you monitored if a large number of Exceptions (ClassCastExceptions) are created?;;;","05/Jun/12 08:05;snekoval;We've managed to test a patch, trying it about 2 weeks in production, using Grails 2.0.3 + Groovy 1.8.6 + patch.
Two things to mention:
# Number of busy threads sometimes lowered a bit, but not significantly.
# No difference in CPU usage looking at graphs...

So the patch does, in fact, work. However in our case its effect is fairly minor compared to Grails + Groovy (1.8.x) upgrade.
I think GROOVY-5059 actually had more impact considering how our code is written.;;;","24/Aug/12 05:19;tty;I encountered performance issue caused by locking in ClassInfo.getMetaClass with groovy 1.8.7 when using following construction concurrently:
{code}
            switch (node.name()) {
                case ['b','s','p','para','sect']:
...
{code}

Stacktrace is following:
{code}
	  at sun.misc.Unsafe.park(Unsafe.java:-1)
	  at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)
	  at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:811)
	  at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:842)
	  at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1178)
	  at org.codehaus.groovy.util.LockableObject.lock(LockableObject.java:34)
	  at org.codehaus.groovy.reflection.ClassInfo.lock(ClassInfo.java:268)
	  at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:193)
	  at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:231)
	  at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:747)
	  at org.codehaus.groovy.runtime.InvokerHelper.invokePojoMethod(InvokerHelper.java:780)
	  at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:772)
	  at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:164)
	  at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.isCase(ScriptBytecodeAdapter.java:667)
{code}

{code}
invokeMethodN(caseExpression.getClass(), caseExpression, ""isCase"", new Object[]{switchValue})
{code}
is locked on ClassInfo for ArrayList, because it uses invokePojoMethod which calls ClassInfo.getMetaClass(obj).;;;","24/Aug/12 05:47;blackdrag;What I get out of this thread is that we have a general problem with the performance of Groovy-truth from Java code. As a method call from Groovy it would be not such a big problem, since the method would be cached, and not every call will go through getMetaClass in ClassInfo. But in this last trace for example isCase does this, since it is an uncached dynamic call

has someone reading in this thread any idea how to prevent that? I could apply some logic from the primitive optimizations, but EMC is disabling that. I could try hand made call site caching in the Java code... that would help in some cases maybe... in JDK 1.7 I could leverage ClassValue and avoid the locking probably... But that doesn't help in Groovy 1.8 and not on pre jdk7 vms;;;","06/Sep/12 08:56;blackdrag;I added several changes that should help with the usage of Groovy Truth in internal iterating methods such as any, find and grep. The changes I did will not help with the switch-case Timur reported. What I did was adding a caching for the meta methods involved, especially Closure#call and asBoolean. The logic for Groovy-Truth is unchanged, only faster I hope ;)

I guess for the switch-case we need to think a bit more about what to do. But for example Serge should see an inprovement.;;;","05/Mar/13 05:18;lhotari;This is also a problem in Grails 2.2.0 / Groovy 2.0.5 . See Grails mailing list thread for more details: http://grails.1312388.n4.nabble.com/Grails-performance-restriction-tt4642061.html . It looks like [InvokerHelper.getProperty|https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/runtime/InvokerHelper.java#L173] triggers this problem when POJOs are used. Making POJOs extend GroovyObjectSupport (or implement GroovyObject) is one workaround for this problem before this issue gets fixed.;;;","05/Mar/13 07:24;lhotari;Graeme suggested another workaround in the [Grails mailing list thread|http://grails.1312388.n4.nabble.com/Grails-performance-restriction-tp4642061p4642080.html]: ""GroovySystem.keepJavaMetaClasses = true"" setting might help. @CompileStatic does too.;;;","06/Mar/14 09:10;lhotari;PR https://github.com/groovy/groovy-core/pull/342;;;","06/Mar/14 12:18;lhotari;PR updated, patch available at url https://github.com/groovy/groovy-core/pull/342.patch if someone wants to test the patch with other groovy version branches.;;;","07/Mar/14 02:09;lhotari;patch backported to Groovy 2.0.8 : https://github.com/lhotari/groovy-core/compare/GROOVY_2_0_8...GROOVY-5249-backport.patch , commits: https://github.com/lhotari/groovy-core/compare/GROOVY_2_0_8...GROOVY-5249-backport
;;;","02/Apr/14 06:09;fedotxxl;Hi. We have applied this patch on our production server and it works much, much better;;;","02/Apr/14 06:12;blackdrag;you mean the change from github?;;;","02/Apr/14 06:16;fedotxxl;this one -> https://github.com/lhotari/groovy-core/compare/GROOVY_2_0_8...GROOVY-5249-backport.patch
but it doesn't really differ from unofficial one - https://jira.codehaus.org/secure/attachment/58665/mc.patch - it also works. Just it breaks 1 of 6000 groovy tests;;;","02/Apr/14 07:31;blackdrag;I applied the patch in a slightly modified version;;;","05/Feb/18 08:15;mtg.ken.lam; Is it possible to back port the following 5 revisions to Groovy 1.7.5?

SHA-1: 3893a91dd3cdd4fdbcb873d1359f6479ef570e1a

SHA-1: f78a90de0512c37ff09d417a549723596a862288

SHA-1: 937cd2d9c0bc537e1b16614cae42a416c6ae8f31

SHA-1: 0938de11c6b2661d891f6bb9c8d67cd372f9b869

SHA-1: c7c7ed6784a349f1e6180c97c0658a40141763b3

 

All these revisions only modify this file:

src\main\org\codehaus\groovy\reflection\ClassInfo.java

 

Can I do it safely and rebuild the jar for use in Grails 1.3.5?;;;","06/Feb/18 11:34;blackdrag;I think just cherry-picking them and not having conflicts will not work. If it is save or not... well.. 1.7.5 is 8 years old. I can understand that you are maybe stuck with Grails 1.3.5, but if applying those commits will solve your issue and not produce new ones is something nobody here can really answer I think. Did you every try using a new Groovy with that Grails version? It may just work (once you rename the jar). But even in the 1.7 line we have a lot of fixes newer than 1.7.5;;;",,,,,,,,,,,,,,,,
call site caching missing null check,GROOVY-5248,12818134,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,12/Jan/12 12:24,13/Jan/12 08:55,14/Jul/23 06:00,13/Jan/12 08:55,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.6,2.0-beta-3,,,,,0,,,,,,"Luke brought GRADLE-2045 to my attention and I was able to reproduce the problem using this program:
{code:Java}
class Cat {
  public static findAll(Integer x, Closure cl) {1}   
}

 def foo(x) {
     x.findAll {}
 }
 
 use (Cat) {
     println foo(1)
     println foo(null)
 }
{code}
It should actually not matter what method or base class the category uses, important is more that a PojoMetaClassSite will be produced. The code here does this because the receiver in foo is the Pojo integer and since categories are active, the normal way of getting a MetaMethod and using that will not be applied. Instead the fallback action with the long path through the MetaClassImpl will be chosen. PojoMetaClassSite has, as all of those, a check for invalidation which includes meta class changes and a check for the receiver being still of the same class. But the class check requires a non-null receiver, which is not the case anymore at the time that foo is called the second time.",,ldaley,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 13 08:55:44 UTC 2012,,,,,,,,,,"0|i2cpa7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Jan/12 12:25;blackdrag;Using 
{code:Java}
--- a/src/main/org/codehaus/groovy/runtime/callsite/PojoMetaClassSite.java
+++ b/src/main/org/codehaus/groovy/runtime/callsite/PojoMetaClassSite.java
@@ -51,7 +51,8 @@ public class PojoMetaClassSite extends MetaClassSite{
     }
 
     protected final boolean checkCall(Object receiver) {
-        return receiver.getClass() == metaClass.getTheClass()
-            && version == classInfo.getVersion(); // metaClass is still valid
+        return  receiver!=null &&
+                receiver.getClass() == metaClass.getTheClass() &&
+                version == classInfo.getVersion(); // metaClass is still valid
     }
 }
{code}
seems to fix the issue;;;","13/Jan/12 08:55;blackdrag;fix applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sorting a map then passing it to JsonBuilder results in a NullPointerException only in 1.8.5,GROOVY-5247,12815904,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,fxg,fxg,12/Jan/12 09:43,12/Feb/12 04:03,14/Jul/23 06:00,13/Jan/12 08:28,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,,,,,4,,,,,,"
{code}
import groovy.json.*

aMap = [a:1, b:2, c:3]
new JsonBuilder(aMap) // works as expected

aMap = [a:1, b:2, c:3].sort()
new JsonBuilder(aMap) // fails with a NullPointerException in 1.8.5. Works as expected in 1.8.4
{code}
",Mac OSX Lion,fxg,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 13 08:28:06 UTC 2012,,,,,,,,,,"0|i2cfdz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Jan/12 13:50;jwagenleitner;I believe this issue may be related to [commit c5456c808f0af5a|https://github.com/jwagenleitner/groovy-core/blob/c5456c808f0af5a19e14c0f781bf430a07fd271f/src/main/groovy/json/JsonOutput.groovy#L142].  The {{sort()}} call returns a {{TreeMap}} and that is the root issue here, same error occurs for {{Hashtable}} (and {{Properties}}).  A call to {{containsKey}} with a {{null}} key will throw a NPE for those Map implementations (unless used with a comparator that handles {{null}} keys).

{code}
import groovy.json.*

def m = new TreeMap()
m.a = 1

JsonOutput.toJson(m)
{code};;;","12/Jan/12 16:56;jwagenleitner;In case it might be useful, I opened a pull request for this issue at https://github.com/groovy/groovy-core/pull/12.;;;","13/Jan/12 08:28;guillaume;Thanks for the pull request!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inconsistency with accessing issers as properties,GROOVY-5245,12816022,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,werdna,werdna,10/Jan/12 12:00,28/Jul/22 15:24,14/Jul/23 06:00,10/Jun/21 20:26,1.8.4,2.4.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,4.0.0-beta-1,,,groovy-runtime,,,,1,,,,,,"In the following snippet, the first two statements work as expected,
but the last one throws a MissingPropertyException.  It seems to me
that no exceptions should be thrown.  This is on Groovy 1.8.4.

{code}
class Isser {
   boolean isWorking() { true }
}
class IsserCat {
   static boolean getWorking2(Isser b) { true }
   static boolean isNotWorking(Isser b) { true }
}

use (IsserCat) {
   println new Isser().working
   println new Isser().working2
   println new Isser().notWorking  // Missing property exception...why?
}

{code}
",,jwagenleitner,,,,,,,,,,,,"danielsun1106 commented on pull request #1592:
URL: https://github.com/apache/groovy/pull/1592#issuecomment-857647278


   +1


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Jun/21 12:20;githubbot;600","eric-milles merged pull request #1592:
URL: https://github.com/apache/groovy/pull/1592


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jun/21 20:26;githubbot;600",,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,GROOVY-10708,GROOVY-10707,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-01-10 12:00:34.0,,,,,,,,,,"0|i2c4x3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MarkupBuilderHelper#comment() Javadoc not up to date - wrong info,GROOVY-5244,12818137,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,,wujek,wujek,09/Jan/12 17:21,10/Nov/12 13:02,14/Jul/23 06:00,10/Nov/12 13:02,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,"The API says:
To create an element with the name 'comment', you need to supply empty attributes, e.g.:

 comment('hello1')
 
or
 mkp.comment('hello1')
 
will produce:
 <!-- hello1 -->
 
while:
 comment('hello2', [:])
 
will produce:
 <comment>hello2</comment>


This doesn't seem to be the case, as the code:

new MarkupBuilder().root {
   mkp.comment('rafal')
}
produces:
<root>
  <comment>cmt</comment>
</root>
as expected. The Javadoc might be a remnant from the past, where this didn't work.",,pschumacher,wujek.srujek,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Nov 10 07:14:10 UTC 2012,,,,,,,,,,"0|i2bxfr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"09/Jan/12 21:25;roshandawrani;Just tried it on groovy web console: http://groovyconsole.appspot.com/edit/623002
{code}
mkp.comment('rafal')
{code}
does produce
{noformat}
<root><!-- rafal --></root>
{noformat};;;","10/Nov/12 07:02;pschumacher;{code}
StringWriter sw = new StringWriter()
new MarkupBuilder(sw).root { mkp.comment('rafal') }

assert sw.toString() == '<root><!-- rafal --></root>'
{code}

Also works for me, so I guess this issue can be closed.;;;","10/Nov/12 07:14;wujek.srujek;Yes, I've just checked it and it works fine now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Canonical @TupleConstructor can't handle Object or Map properties,GROOVY-5243,12816026,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,gjoseph,gjoseph,09/Jan/12 05:08,25/Oct/22 16:49,14/Jul/23 06:00,12/Apr/13 04:05,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.3,2.2.0-beta-1,,,,,,0,annotation,,,,,"Given the following code, I would expect the assertions to pass. They currently don't. However, if the {{a}} and {{b}} properties are typed to String, for example, everything goes as expected.

It might be challenging to get this to work properly for more complex types, but it would make the annotations *really* transparent. The way it currently behaves is very unsettling (a is set with a Map containing both a and b with their respective values, while b is not set to anything)

{code}
import groovy.transform.Canonical

def weird = new CanonicalIsWeird(a: 'first letter', b: 'second letter')
println ""a: ${weird.a}""
println ""b: ${weird.b}""

assert weird.a == 'first letter'
assert weird.b == 'second letter'

@Canonical
class CanonicalIsWeird {
    def a, b
}
{code}
https://gist.github.com/1565938",,hubbitus,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10796,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 12 04:05:07 UTC 2013,,,,,,,,,,"0|i2cstb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"09/Jan/12 05:09;gjoseph;Unrelated, but I can't seem to be able to edit the issue. Forgot to check the ""testcase submitted"" box (although said test case is very minimal);;;","05/Apr/13 05:16;paulk;Just for further explanation, by using @TupleConstructor, the following constructors are generated:
{code}
CanonicalIsWeird(Object a, Object b)
CanonicalIsWeird(Object a)
CanonicalIsWeird()
{code}
Normally when using named parameters (i.e. {{new CanonicalIsWeird(a: 'foo', b:' bar')}}) it is represented by storing the named args in a Map which is then (roughly) translated into calling the no-arg constructor followed by setting the properties - approximately what you see below:
{code}
def obj = new CanonicalIsWeird(Map args)
{code}
translated into:
{code}
def obj = new CanonicalIsWeird()
obj.setA('foo')
obj.setB('bar')
{code}
but in your case, the single Object constructor matches the Map and alters the desired behavior.
;;;","12/Apr/13 04:05;paulk;OK, it turns out not to be easy to cover all cases since for some scenarios supporting Groovy's named arguments could be in conflict with a user trying to use Map properties. But the good news is cases like yours can and should be supported. So your example and similar ones should now work unless the first property happens to be a LinkedHashMap or there is only one property of Map, HashMap, AbstractMap or LinkedHashMap. The doco has been updated to reflect this limitation.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checker confuses Class and type,GROOVY-5240,12815853,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,06/Jan/12 09:46,13/May/12 03:30,14/Jul/23 06:00,09/Jan/12 10:53,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"When compiling the following code:

{code}
@groovy.transform.TypeChecked
class Container {
    static lookup(Class clazz) { }
    static m() {
        lookup(Date)
    }
}

Container.m()
{code}

The static type checker complains with:
{code}
[Static type checking] - Cannot find matching method Container#lookup(java.util.Date)
 at line: 5, column: 9
{code}

Although it shouldn't complain here, since we're passing the Date.class as argument to the lookup method, which is correct.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-01-06 09:46:06.0,,,,,,,,,,"0|i2c6w7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Statically imported method vs other methods with the same name,GROOVY-5239,12816066,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mxm-groovy,mxm,06/Jan/12 06:16,25/Feb/22 20:38,14/Jul/23 06:00,08/Jun/21 15:48,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.16,3.0.10,4.0.0-beta-1,Compiler,,,,0,,,,,,"Assume you have a class test.Foo:
{code}
package test

class Foo {
  static foo() {'foo'}
}
{code}


Let's consider some code snippets. IMHO Groovy incorrectly resolves reference 'foo' to statically imported method in all of these cases. 

{code} 
import static test.Foo.foo

class Bar {
  def foo() {'bar'}

  class Inner {
    def abc() {
      assert foo() == 'bar' //statically imported method will be invoked here
    }
  }

}
{code}

{code} 
import static test.Foo.foo

class Bar {
  def foo() {'bar'}
}

new Bar().with {
  assert foo() == 'bar' //statically imported method will be executed
}
{code}

{code} 
import static test.Foo.foo

class Base {
  def foo(){'base'}
}

class Bar extends Base {
  def abc() {
    assert foo() == 'base' //statically imported method will be executed 
  }
}
{code}",,emilles,,,,,,,,,,,,"eric-milles opened a new pull request #1586:
URL: https://github.com/apache/groovy/pull/1586


   This resolves 2 of 3 cases raised by 5239
   
   https://issues.apache.org/jira/browse/GROOVY-5239


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;27/May/21 20:31;githubbot;600","danielsun1106 commented on pull request #1586:
URL: https://github.com/apache/groovy/pull/1586#issuecomment-850810233


   LGTM


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;29/May/21 10:26;githubbot;600","danielsun1106 merged pull request #1586:
URL: https://github.com/apache/groovy/pull/1586


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;30/May/21 13:45;githubbot;600","danielsun1106 commented on pull request #1586:
URL: https://github.com/apache/groovy/pull/1586#issuecomment-851002800


   Merged. Thanks!


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;30/May/21 13:45;githubbot;600",,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 27 17:25:40 UTC 2021,,,,,,,,,,"0|i2bulz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jan/12 06:34;mxm-groovy;I found another case. Assume you have default groovy method 'is' and statically imported 'org.hamcrest.CoreMatchers.is'. I don't know what is more relevant.;;;","27/May/21 17:25;emilles;{{StaticImportVisitor}} makes these replacements.  Once ""foo()"" is converted to {{StaticMethodCallExpression}}, classgen translates it to ""invoke static method"" which stops the search for instance methods.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Methods belonging to a different source unit get visited and report errors at the wrong place,GROOVY-5238,12816074,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,06/Jan/12 06:02,13/May/12 03:30,14/Jul/23 06:00,06/Jan/12 08:13,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"If a method call expression references a method from another class, the method called gets visited (if it is statically checked) even if the class doesn't belong to the same source unit. This triggers incorrect error reporting (errors in the wrong file).

Fixing completely this requires a large amount of work, so return type inference will only work for methods in the same source unit at first.

See TODO in StaticTypeCheckingVisitor.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 06 08:13:47 UTC 2012,,,,,,,,,,"0|i2c3vr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jan/12 08:13;melix;Partially resolved, see https://github.com/groovy/groovy-core/commit/455b8a10b1790a53f8f6b0c9ba808769c885302c

Especially the TODO. Copy of a discussion by mail:


The general problem to be solved is that one:
{code}
@AnnotationTriggeringTypeChecking
class A {
   def foo() { ... b.bar() ... }
}
@AnotherAnnotationTriggeringTypeChecking
class B {
   def bar() { ... a.foo() ...}
}
{code}
In most situations, both annotations will either be {{@TypeChecked}} or {{@CompileStatic}}, but you can have a mix, or custom annotations (including {{@TypeChecked}} or {{@CompileStatic}} with custom plugin factories). When class A is visited, it eventually discovers a call to b.bar(). B is not defined in the same source unit and we need to infer the return type of b.bar(). It is necessary to determine the return type of bar() at the time of the visit of foo() because the result operation can be chained. Without recursion, think of :

{code}
class A { def foo() { b.bar().toUpperCase() } }
class B { def bar() { 'bar' } }
{code}

Also, the return type of bar() may include generic type information that must be inferred at that time too. Note that type inference must be triggered if, and only if, the target method is itself type checked. This means that when b.bar() is checked, we must:

    - determine if method bar() is type checked
    - launch type checking, and only type checking, at that moment

We cannot use the visitor used by A for two reasons:
    - as the annotations for A and B can be different, there's no reason why A and B should be type checked the same way. Worse, it may introduce failures.
    - error reporting will not use the correct source unit

The second point can easily be solved. The first one is the trickiest. Imagine B uses {{@CompileStatic}}. The visitor from A could check every annotation bar() or its declaring class (as well as possible outer classes), and verify that the transformation class used by this annotation is derived from StaticTypesTransformation. This is the case, for example, of the {{@CompileStatic}} annotation, which defines its own transformation class extending StaticTypesTransformation. This transformation does multiple things:
    - add node metadata (static compilation flags, custom writer factory)
    - override  protected StaticTypeCheckingVisitor newVisitor(final SourceUnit unit, final ClassNode node, final TypeCheckerPluginFactory pluginFactory) to provide a static compilation visitor which performs type checking and specialized checks for static compilation
    - performs AST modifications in order to facilitate static compilation

If the transformation does not extend StaticTypesTransformation but uses a type checking visitor (that's possible), then there's not much we can do...

Obviously, there are things that must *not* be done by a transformation triggered from a type checking only step. We need a way to separate those operations and this is not always easy to do. For example, if the static type checker only called the newVisitor() method on the AST transformation class, it would get a visitor which does exactly what's needed, but also checks that every method call has a target method set... More, the visitor from A cannot know by advance what parameters should be provided to newVisitor(), especially the plugin factory part, because the logic of that is in the {{public void visit(final ASTNode[] nodes, final SourceUnit source)}} method of the AST transformation.

We could imagine that we forget this and use the same visitor as the visitor from A. That would help:
    - detecting cycles (as every visited method is remembered)
    - doing type checking only

But we would have a type checking result different from what we would obtain if we compiled B alone, with its own annotation... Another problem is that performing type checking on a node (be it a class node or a method node) ""pollutes"" it with type checking meta data. If the visitor which is used is not correct, or not instantiated with the correct configuration, then the AST of B will contain erroneous type information. Second (and this is a problem which exists in any case), the type checking step will be started a second time when the compiler will compile class B. If type information is already present in the AST of B, the result of type checking is very likely to be wrong. To be short, we need either a way of remembering the state of the AST before the visitor from A generates a visitor for B and adds metadata, or we need to work on a clone of the AST of B, so that when the visit ends, even if, for example, the @CompileStatic annotation transforms the AST, the original AST of B remains untouched. Unfortunately, cloning an AST is not necessarily easy...

Last but not least, we must also consider the case where the AST of B represents a precompiled node. In that case, the code of method will be empty, and type inference would fail. This means that we must add type inference metadata at the bytecode level (in any encoded form) which can be used in that situation.

As the problem is complex, I will only commit a ""hotfix"" for now, which should be suitable for most situations, which implies only methods from the same source unit can have their return type inferred (which is not perfect). This shouldn't be a problem in most situations, and as I will have some work on presentations to do, it will let me some time to work on more critical bugs.
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checker complains on assignment on generics fields,GROOVY-5237,12815781,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,06/Jan/12 05:42,13/May/12 03:30,14/Jul/23 06:00,06/Jan/12 08:00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"The static type checker complains on the following class:
{code}
@groovy.transform.TypeChecked
class Container<T> {
    private T initialValue
    Container(T initialValue) { this.initialValue = initialValue }
    T get() { initialValue }
}
{code}
With the message:
{code}
[Static type checking] - Incompatible generic argument types. Cannot assign java.lang.Object <T> to: java.lang.Object <T>
 at line: 4, column: 33
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 06 08:00:00 UTC 2012,,,,,,,,,,"0|i2bw4v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jan/12 05:47;paulk;see also lines 85-88 of {{org.codehaus.groovy.ast.GenericsType}} which might be fixed by a solution to this problem - running stub generator tests should verify whether fixed after removing lines 85-88;;;","06/Jan/12 08:00;melix;Resolution is not related to the lines GenericsType#85-88 though.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static compilation of method call expressions with missing default parameters,GROOVY-5235,12816006,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,05/Jan/12 14:34,13/May/12 03:30,14/Jul/23 06:00,17/Feb/12 03:57,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,The static compiler won't compile method call expressions for which some default parameters are missing properly.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5231,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 14 04:35:38 UTC 2012,,,,,,,,,,"0|i2c5dr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Feb/12 04:35;melix;Implemented on {{experimental-static-compiler}} branch. Waiting for fix version before closing.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checker has problems with args coerced to arrays,GROOVY-5233,12816030,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,05/Jan/12 12:05,13/May/12 03:30,14/Jul/23 06:00,09/Jan/12 10:52,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"{code}
import groovy.transform.*

@TypeChecked
def m() {
    try {
        throw new Exception()
    } catch (Throwable t) {
        def newTrace = []
        def clean = newTrace.toArray(newTrace as StackTraceElement[])
    }
}

m()
{code}

Given the above program which works when not type checked, the checker complains with:

{code}
[Static type checking] - Cannot call java.util.List#toArray([Ljava.lang.Object;) with arguments [[Ljava.lang.StackTraceElement; -> [Ljava.lang.StackTraceElement;]
 at line: 9, column: 21
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-01-05 12:05:43.0,,,,,,,,,,"0|i2bwkv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checking fails on setter call,GROOVY-5232,12815492,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,05/Jan/12 09:43,13/May/12 03:30,14/Jul/23 06:00,06/Jan/12 08:42,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"The setter generated by Groovy properties doesn't seem to be recognized by the type checker.

Given the following example:

{code}
import groovy.transform.*

@TypeChecked
class Person {
    String name
    
    static Person create() {
        def p = new Person()
        p.setName(""Guillaume"")
        // but p.name = ""Guillaume"" works
        return p
    }
}

Person.create()
{code}

It complains with:
{code}
[Static type checking] - Cannot find matching method Person#setName(java.lang.String)
 at line: 9, column: 9
{code}

Note that using the property notation for setting the property works, but the plain setter call fails.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-01-05 09:43:26.0,,,,,,,,,,"0|i2ceen:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem with @TupleConstructor with static type checking,GROOVY-5231,12816021,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,05/Jan/12 09:22,13/May/12 03:30,14/Jul/23 06:00,05/Jan/12 14:36,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"When using the @TupleConstructor with the static type checking, it doesn't like when a constructor without all the fields is used.
Consider the following example:
{code}
import groovy.transform.*

@TupleConstructor
@TypeChecked
class Person {
    String name, city
    static Person create() {
        new Person(""Guillaume"")
    }
}

Person.create()
{code}
The type checker complains because it could not find a zero-arg constructor:
{code}
[Static type checking] - Cannot find matching method Person#<init>(java.lang.String)
 at line: 8, column: 9
{code}
But actually, @TupleConstructor allows to use less args than all the declared.
Person can be instantiated with new Person(""Guillaume"", ""Paris""), new Person(""Guillaume""), or even new Person()",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5235,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 05 11:59:13 UTC 2012,,,,,,,,,,"0|i2clzj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jan/12 11:59;melix;The underlying problem is default argument values: the type checker doesn't verify that a call is possible with ""missing"" arguments.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Some properties are not recognized as properties by the type checker,GROOVY-5229,12816050,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,04/Jan/12 16:10,13/May/12 03:30,14/Jul/23 06:00,04/Jan/12 16:12,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"Some class define ""implicit"" properties by defining a getter and a setter. If the class is a Java class, like {{java.util.Date}} and the {{time}} property, the type checker fails to recognize the property properly, thinking it's a read-only property.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-01-04 16:10:43.0,,,,,,,,,,"0|i2by0f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Prefix/Postfix operations are not type checked,GROOVY-5228,12816025,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,04/Jan/12 10:36,13/May/12 03:30,14/Jul/23 06:00,04/Jan/12 10:39,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"Instructions like:

{code}
i++
date++
object++
++i
++date
++object
{code}

are not type checked.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-01-04 10:36:52.0,,,,,,,,,,"0|i2cehb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Variables which type is determined thanks to instanceof checks should be usable as arguments without casts,GROOVY-5226,12816020,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,03/Jan/12 12:27,13/May/12 03:30,14/Jul/23 06:00,03/Jan/12 12:34,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"The current implementation of the type checker allows to use methods of an object without the need of an explicit cast if it is wrapped in a proper {{instanceof}} check:

{code}
class A {
   void foo() {}
}
def o
...
if (o instanceof A) {
   o.foo()
}
{code}

But it doesn't work if the object is used as an argument:

{code}
class A {}
void m(A a) { ... }
def o
...
if (o instanceof A) {
   m(o) // requires m((A) o) which should not be necessary
}
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2012-01-03 12:27:54.0,,,,,,,,,,"0|i2bokv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.util.Node plus operator assuming all children are not strings,GROOVY-5224,12816024,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,escalope,escalope,02/Jan/12 13:34,12/Feb/12 04:03,14/Jul/23 06:00,21/Jan/12 01:07,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,XML Processing,,,,0,,,,,,"The attached code triggers a class cast exception because in the groovy.util.Node plus operator, lines 179-180
https://github.com/groovy/groovy-core/blob/fc33b105f172629fc99d5b62da9e3c1adafff85c/src/main/groovy/util/Node.java

it is assumed that all children are nodes, but the parser does not seem to create textnodes but keeping them as string, either that or some strange conversion is happening because in 179 a class cast exception is raised for a java.lang.String to groovy.util.Node illegal conversion. 

The proof of concept is the attached junit code. If the commented line is uncommented, the cast exception appears. If the text in the xml is removed, the failure does not show.

XMLParser is being used.","linux, eclipse, ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"02/Jan/12 13:34;escalope;XMLParserFailure.groovy;https://issues.apache.org/jira/secure/attachment/12723017/XMLParserFailure.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jan 21 01:07:58 UTC 2012,,,,,,,,,,"0|i2clvz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"19/Jan/12 13:53;jwagenleitner;I opened a github pull request for this issue, https://github.com/groovy/groovy-core/pull/18.;;;","21/Jan/12 01:07;paulk;I applied the pull request from John Wagenleitner. Thanks for spotting and reporting the error and to John for the fix.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Casts to subclasses should not be caught as errors by the type checker,GROOVY-5222,12816059,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,29/Dec/11 10:21,13/May/12 03:30,14/Jul/23 06:00,29/Dec/11 10:21,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"The following expression causes an incompatible type error at compile time, although it's valid:

{code}
Object o = null
try {
   ((Integer)o).intValue()
} catch (NullPointerException e) {
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-29 10:21:12.0,,,,,,,,,,"0|i2ca47:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem with @InheritConstructors with multiple level of inheritance (part 1 of 2 - document the current limitation),GROOVY-5221,12818139,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,paulk,ronan_michaux,ronan_michaux,28/Dec/11 12:03,12/Feb/12 04:03,14/Jul/23 06:00,02/Feb/12 03:28,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.6,2.0-beta-3,Compiler,,,,0,,,,,,"See also GROOVY-5274 which will be the actual fix, changing the focus of this issue to updating the doco to outline the current limitations.

=======================

See test eclipse project attached.

- Class Hierarchy : A <-- inherit -- B <-- inherit -- C

- A define constructor public A(String dummy){...}

- B and C use  @InheritConstructors.

- In the main(...) : C.class.newInstance(""tata"")

- Result : Exception in thread ""main"" groovy.lang.GroovyRuntimeException: Could not find matching constructor for: data.C(java.lang.String)
	at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1474)
	at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1390)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeConstructorOf(InvokerHelper.java:824)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.newInstance(DefaultGroovyMethods.java:17689)
	at org.codehaus.groovy.runtime.dgm$511.doMethodInvoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.invoke(StaticMetaMethodSite.java:43)
	at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.call(StaticMetaMethodSite.java:88)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at Main.MainLaunch.main(MainLaunch.groovy:7)
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5274,,,,,,,,"28/Dec/11 12:03;ronan_michaux;InheritConstructorTest.zip;https://issues.apache.org/jira/secure/attachment/12721722/InheritConstructorTest.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 02 03:28:06 UTC 2012,,,,,,,,,,"0|i2c5rz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"28/Dec/11 16:52;blackdrag;I assume that happens because C is visited before B is. Then the transform for C can simply not see the constructor added to B, because that did not yet happen. I guess @InheritConstructors would have to either run this transform on B first - out of the normal order - or delay evaluation of C, till B is done. The later could be done using the node meta data.;;;","02/Jan/12 01:06;paulk;It would be nice to fix this but I wouldn't necessarily call it a blocker issue. If we don't fix it before the next release I guess we should at least update the doco indicating that it isn't currently supported before the next release.;;;","02/Feb/12 03:28;paulk;Current limitation documented - it would be nice to fix the actual issue shortly but just in case this doesn't happen before the next release, at least the limitation will be more appararent;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FactoryBuilderSupport doesn't register methods in a predictable order,GROOVY-5219,12816038,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,28/Dec/11 04:37,12/Feb/12 04:03,14/Jul/23 06:00,28/Dec/11 05:07,1.8.5,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,,,,,0,,,,,,"Many build failures on jdk 1.7.0_02 are due to the fact that this version of the JDK doesn't return declared methods in a predictable order, while other JDKs do. This leads to random build failures, as the {{Class#getDeclaredMethods}} method _may_ return the methods in the expected order, but not always.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-28 04:37:39.0,,,,,,,,,,"0|i2bt4v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Calls to closures declared as fields are not type checked properly,GROOVY-5217,12816017,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,27/Dec/11 12:01,13/May/12 03:30,14/Jul/23 06:00,27/Dec/11 12:13,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"If a class contains a field declared as a closure and that you use that closure as a method, the type checker throws a missing method error.

{code}
class FibUtil {
                private Closure<Integer> fibo
                FibUtil() {
                    fibo = { int x-> x<1?x:fibo(x-1)+fibo(x-2) }
                }

                int fib(int n) { fibo(n) }
            }
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-27 12:01:21.0,,,,,,,,,,"0|i2bnw7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"groovy.sql.Sql.newInstance(Map<String, Object>) remove params",GROOVY-5216,12815966,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,aaaia,aaaia,27/Dec/11 07:34,12/Feb/12 04:03,14/Jul/23 06:00,13/Jan/12 22:41,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.6,2.0-beta-3,SQL processing,,,,1,Sql.newInstance,,,,,"method groovy.sql.Sql.newInstance(Map<String, Object>) can be nicely used with ConfigSlurper, the problem is that it removes parameters from method call argument, so source code:
{code}
def res = new ConfigSlurper().parse(new File('resource/Resources.groovy').toURI().toURL())

files.each {
		def sql = Sql.newInstance(res.db)
		//do something
		sql.close()
}
{code}
fails on second iteration due to parameters had been removed from res.db map and param ""url"" can not be found

the solution may be changing args.remove to args.get in procedure groovy.sql.Sql.newInstance(Map<String, Object>)","Windows XP SP2, JDK 1.6.0_27",aaaia,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jan 14 04:56:27 UTC 2012,,,,,,,,,,"0|i2c1nr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jan/12 20:09;jwagenleitner;It seems reasonable for the caller to assume the Map would be handled non-destructively.  I have done a github pull request for this issue, https://github.com/groovy/groovy-core/pull/13 in case it may be of use.;;;","13/Jan/12 22:40;paulk;add code tags;;;","13/Jan/12 22:41;paulk;applied pull request from jwagenleitner (John Wagenleitner)
thanks to all involved;;;","14/Jan/12 04:56;paulk;Updated fix versions;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Linenumber information is missing for Enums in AST,GROOVY-5215,12816046,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,bodiam,bodiam,27/Dec/11 07:04,05/Apr/15 14:44,14/Jul/23 06:00,27/Dec/11 08:03,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,,,,,,,0,,,,,,"In the AST for enums, the linenumber information is not available. This causes some errors in CodeNarc, which uses that information to report on.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5214,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,2011-12-27 07:04:37.0,,,,,,,,,,"0|i2ctvb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Source location incorrect for enums,GROOVY-5214,12816008,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,26/Dec/11 23:22,07/Apr/15 19:07,14/Jul/23 06:00,26/Dec/11 23:34,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,,,,,0,,,,,,"As per:
https://github.com/groovy/groovy-core/pull/10",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5215,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 26 23:34:12 UTC 2011,,,,,,,,,,"0|i2bqw7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Dec/11 23:34;paulk;Applied - thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inner classes are not type checked,GROOVY-5213,12812067,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,26/Dec/11 10:30,13/May/12 03:30,14/Jul/23 06:00,26/Dec/11 10:32,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,Static Type Checker,,,,0,,,,,,"The static type checker forgets to visit inner classes, which are therefore not type checked.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-26 10:30:26.0,,,,,,,,,,"0|i2cnyv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compilation problem for java enums defined as groovy classes,GROOVY-5212,12818131,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,armsargis,armsargis,26/Dec/11 00:24,12/Feb/12 04:03,14/Jul/23 06:00,26/Dec/11 03:43,1.8.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,Ant integration,,,,0,,,,,,"Hi, I have following groovy class TransactionStatus.groovy with code:

package com.webbfontaine.twm.accounting.epaylog.emess.model.response

public enum TransactionStatus {
  OK, ERROR
}

and compilation of this class using groovy 1.8.4 was ok but after  migrating to 1.8.5 I have following:

groovy.compile:
    [mkdir] Created dir: /home/sargis/projects/twm3.git/modules/accounting/Server/classes
  [groovyc] Compiling 186 source files to /home/sargis/projects/twm3.git/modules/accounting/Server/classes
  [groovyc] org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
  [groovyc] Compile error during compilation with javac.
  [groovyc] warning: [options] bootstrap class path not set in conjunction with -source 1.6
  [groovyc] /tmp/groovy-generated-3682106614822967278-java-source/com/webbfontaine/twm/accounting/epaylog/emess/model/response/TransactionStatus.java:10: error: modifier final not allowed here
  [groovyc] public final enum TransactionStatus
  [groovyc]              ^
  [groovyc] Note: Some input files use or override a deprecated API.
  [groovyc] Note: Recompile with -Xlint:deprecation for details.
  [groovyc] Note: Some input files use unchecked or unsafe operations.
  [groovyc] Note: Recompile with -Xlint:unchecked for details.
  [groovyc] 1 error
  [groovyc] 1 warning
  [groovyc] 
  [groovyc] 
  [groovyc] 1 error


I am using

        <taskdef name=""groovyc"" classname=""org.codehaus.groovy.ant.Groovyc"">
 
        </taskdef>

to compile groovy codes of my project.","sargis@sargis:~/projects/twm3.git/modules/accounting> java -version
java version ""1.7.0_02""
Java(TM) SE Runtime Environment (build 1.7.0_02-b13)
Java HotSpot(TM) 64-Bit Server VM (build 22.0-b10, mixed mode)

sargis@sargis:~/projects/twm3.git/modules/accounting> groovy --version
Groovy Version: 1.8.5 JVM: 1.7.0_02 Vendor: Oracle Corporation OS: Linux
sargis@sargis:~/projects/twm3.git/modules/accounting> 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 03 08:07:31 UTC 2012,,,,,,,,,,"0|i2cnjz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Dec/11 02:14;melix;Enums cannot be extended, so the {{final}} modifier here is not allowed. Just remove the {{final}} modifier and it will be ok. Groovy now behaves like Java in that situation.;;;","26/Dec/11 02:18;armsargis;But in groovy code I dont have final its Groovy compiler generating for /tmp/groovy-generated-3682106614822967278-java-source/com/webbfontaine/twm/accounting/epaylog/emess/model/response/TransactionStatus.java:10, here is my groovy code:

public enum TransactionStatus { OK, ERROR };;;","26/Dec/11 02:21;armsargis;And the same code was ok with 1.8.4;;;","26/Dec/11 02:27;melix;Ok, this is a different issue from what I thought and must be related to the stub generator.;;;","26/Dec/11 03:48;melix;Commit https://github.com/groovy/groovy-core/commit/5e2c99d43a9452564f28ebb28c611fb718fbfdd3;;;","03/Feb/12 07:46;genie;Is there any workaround that can be used before Groovy 1.8.6 is released?;;;","03/Feb/12 08:07;guillaume;If you can't wait for a week for the release, you can write that enum in Java, obviously.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Method dispatch error with @Delegate,GROOVY-5211,12816000,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,roshandawrani,roshandawrani,24/Dec/11 21:57,12/Apr/13 16:55,14/Jul/23 06:00,05/Apr/13 05:06,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.3,2.2.0-beta-1,,,,,,0,,,,,,"Looks like there is some mix-up of the method parameter 'a' in A.foo() with the field 'a' in class B. In the example below if I rename the method parameter or the field, the code goes through.
{code}
class A {
	def foo(a){}
}

class B {
  @Delegate A a = new A()
}

new B().foo(10)
{code}

fails with:
{noformat}
Caught: groovy.lang.MissingMethodException: No signature of method: java.lang.Integer.foo() is applicable for argument types: (java.lang.Integer) values: [10]
{noformat}",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 05 05:06:28 UTC 2013,,,,,,,,,,"0|i2clg7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Apr/13 05:06;paulk;A unique param name should now be generated. Thanks for raising the issue Roshan.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem converting primitive array to a Set,GROOVY-5210,12818132,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,brownj,brownj,22/Dec/11 18:20,24/Dec/11 03:08,14/Jul/23 06:00,23/Dec/11 02:18,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.5,2.0-beta-2,,,,,0,,,,,,"When I try to convert a primitive array to java.util.Set using the ""as"" operator, it looks like Groovy tries to create an instance of java.util.Set (as opposed to creating an instance of some class which implements java.util.Set).

{code:title=demo.groovy|borderStyle=solid}
def intArray = [1, 2, 3] as int[]
def setOfInt = intArray as Set
println setOfInt
{code}

{noformat}
conversion_problem $ groovy -version
Groovy Version: 1.8.4 JVM: 1.6.0_29
conversion_problem $ groovy demo.groovy 
Caught: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Could not instantiate instance of: java.util.Set. Reason: java.lang.InstantiationException: java.util.Set
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Could not instantiate instance of: java.util.Set. Reason: java.lang.InstantiationException: java.util.Set
	at demo.run(demo.groovy:2)
{noformat}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-22 18:20:35.0,,,,,,,,,,"0|i2c9an:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect line numbers in code using optimized primitive operations,GROOVY-5208,12816011,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,gromopetr,gromopetr,21/Dec/11 06:54,11/May/14 06:01,14/Jul/23 06:00,22/Jun/12 14:46,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0.1,,bytecode,,,,9,,,,,,The visible problem is that debugger doesn't stop on the lines containing only primitive value operations. See more details in http://youtrack.jetbrains.net/issue/IDEA-77107.,,bborchardt,blackdrag,gromopetr,jasona@blazetrail.ca,michal.capo,rattigan,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5369,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 22 14:46:06 UTC 2012,,,,,,,,,,"0|i2ce1b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Dec/11 07:53;melix;Hi Peter,

The following code does produce line number info:
{code}
int i = 5*5
i++
println 1+1
i += 2
{code}

Here's the result:
{code}
public run()Ljava/lang/Object;
L0
INVOKESTATIC script.$getCallSiteArray ()[Lorg/codehaus/groovy/runtime/callsite/CallSite;
ASTORE 1
INVOKESTATIC org/codehaus/groovy/runtime/BytecodeInterface8.isOrigInt ()Z
IFEQ L1
GETSTATIC script.__$stMC : Z
IFNE L1
INVOKESTATIC org/codehaus/groovy/runtime/BytecodeInterface8.disabledStandardMetaClass ()Z
IFNE L1
GOTO L2
L1
LINENUMBER 1 L1
ALOAD 1
LDC 1
AALOAD
ICONST_5
INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.box (I)Ljava/lang/Object;
CHECKCAST java/lang/Integer
ICONST_5
INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.box (I)Ljava/lang/Object;
CHECKCAST java/lang/Integer
INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.intUnbox (Ljava/lang/Object;)I
ISTORE 2
L3
ILOAD 2
POP
L4
LINENUMBER 2 L4
ILOAD 2
DUP
ISTORE 3
ALOAD 1
LDC 2
AALOAD
SWAP
INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.box (I)Ljava/lang/Object;
CHECKCAST java/lang/Integer
INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;)Ljava/lang/Object;
DUP
INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.intUnbox (Ljava/lang/Object;)I
ISTORE 2
POP
ILOAD 3
POP
L5
LINENUMBER 3 L5
ALOAD 1
LDC 3
AALOAD
ALOAD 0
ALOAD 1
LDC 4
AALOAD
ICONST_1
INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.box (I)Ljava/lang/Object;
CHECKCAST java/lang/Integer
ICONST_1
INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.box (I)Ljava/lang/Object;
CHECKCAST java/lang/Integer
INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.callCurrent (Lgroovy/lang/GroovyObject;Ljava/lang/Object;)Ljava/lang/Object;
POP
L6
LINENUMBER 4 L6
ALOAD 1
LDC 5
AALOAD
ILOAD 2
INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.box (I)Ljava/lang/Object;
CHECKCAST java/lang/Integer
ICONST_2
INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.box (I)Ljava/lang/Object;
CHECKCAST java/lang/Integer
INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
DUP
INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.intUnbox (Ljava/lang/Object;)I
ISTORE 2
ARETURN
L7
GOTO L8
L2
LINENUMBER 1 L2
ICONST_5
ICONST_5
IMUL
ISTORE 4
L9
ILOAD 4
POP
L10
LINENUMBER 2 L10
ILOAD 4
DUP
ISTORE 5
ICONST_1
IADD
DUP
ISTORE 4
POP
ILOAD 5
POP
L11
LINENUMBER 3 L11
ALOAD 1
LDC 6
AALOAD
ALOAD 0
ICONST_1
ICONST_1
IADD
INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.box (I)Ljava/lang/Object;
CHECKCAST java/lang/Integer
INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.callCurrent (Lgroovy/lang/GroovyObject;Ljava/lang/Object;)Ljava/lang/Object;
POP
L12
LINENUMBER 4 L12
ILOAD 4
ICONST_2
IADD
DUP
ISTORE 4
INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.box (I)Ljava/lang/Object;
CHECKCAST java/lang/Integer
ARETURN
L8
ACONST_NULL
ARETURN
LOCALVARIABLE this Lscript; L0 L8 0
LOCALVARIABLE i I L3 L7 2
LOCALVARIABLE i I L9 L8 4
MAXSTACK = 5
MAXLOCALS = 6
}
{code}

{{L1}} corresponds to the start label of ""slow path"" and is correctly linked to line 1 : {{LINENUMBER 1 L1}}.
{{L2}} corresponds to the start label of optimized bytecodeand is correctly linked to line 1: {{LINENUMBER 1 L2}}.

I'm using master for tests, maybe this has already been fixed, but I'm surprised because there doesn't seem to be differences in source code regarding that part.;;;","21/Dec/11 08:01;gromopetr;Hi Cedric, thanks for looking at the issue. For some reason javap shows only one bytecode instruction per line number, and you have two of them. Is this allowed at all? The JVM (HotSpot 1.6.0_26-b03) seems to ignore the L2 mapping as well.;;;","21/Dec/11 08:18;melix;Yes, either it is not supported by the JVM, or ASM doesn't produce a correct line number table in that situation... I'm investigating, but I can't find explicit documentation about that.;;;","21/Dec/11 08:24;gromopetr;Interestingly, http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html
bq. Furthermore, multiple LineNumberTable attributes may together represent a given line of a source file; that is, LineNumberTable attributes need not be one-to-one with source lines.

Can there be a problem with ASM writing just one line number?;;;","13/Jan/12 17:08;jasona@blazetrail.ca;I am also having the problem with Groovy 1.8.5.   Breakpoints are being missed in very many places in code/large project.  Usually we can workaround by putting in a println and then breaking on that, but it is very cumbersome.  

Is there are compiler option in 1.8.5 to turn off these optimizations ?;;;","12/Apr/12 11:02;gromopetr;We're constantly getting bug reports to IDEA because of this issue, today already 3 of them. That's quite tiresome.;;;","12/Apr/12 11:13;jasona@blazetrail.ca;I'm totally surprised that there has been 0 activity, updates or prioritizing this bug since it was logged last year.

It's like the Groovy maintainers have disappeared, or are focused on Groovy conferences? (sorry subjective but this user is feeling abandoned).

Day to day, using Groovy has become bad joke because you can't debug it, our code coverage tools are useless as well because line #s don't match executed bytecode.

Again, it is in Groovy 1.8.6 which is production.  This is NOT just a 2.0 prototype issue.;;;","12/Apr/12 12:23;blackdrag;Peter and Jason, we are aware of the problem, the question is how the bytecode must look to satisfy the debuggers you are using. If you can answer this question, then we can fix the issue quite fast. Also I think almost all 1.8 versions should have that problem since I suspect it is tied to primitive optimizations. I can only suspect and not know, since Cedric already proofed that the information is there, only not picked up by the debugger. primtive optimizations are most likely, since they are the biggest bytecode change since 1.7. To disable them for the groovy command use ""--disableopt=all"" and for groovyc there is no option to disable them atm.;;;","12/Apr/12 12:45;jasona@blazetrail.ca;JDK 1.6 on OS/X, IntelliJ 11.x.  But also occurres on STS, Eclipse, JDK 7 on OS/X and other platforms.  I hav not used plain jdb in over a decade, and debugger APIs are standard part of JVMs. This should be reproduceable with any language that generates JVM byte code with debug info.  No idea on what the byte code should look like, I think most end users would see that as all black box in compilers.;;;","12/Apr/12 13:06;gromopetr;The bytecode could look like the one of this:

{noformat}
boolean optimize = ...
int i;
if (optimize) { //line 1
  i = 5*5
} else {
  i = compute5x5Dynamically()
}
if (optimize) { //line 2
  i++
} else {
  i = incrementDynamically(i)
}
{noformat}
and so on;;;","12/Apr/12 13:15;blackdrag;if we do that JIT will not optimize the code anymore enough. Before going that route it is better to remove the primitive optimizations;;;","12/Apr/12 14:08;gromopetr;Jochen, are you sure? How does one check that? JIT could be smart enough to see that 'optimize' value doesn't change, merge all optimized and non-optimized branches together in two big branches (just like you do now) and then apply all other optimizations. But that's just speculation, I don't know JIT internals.

What do you mean by removing primitive optimizations? I thought this was a major performance improvement of Groovy 1.8 and one of its killer features.;;;","12/Apr/12 18:39;blackdrag;With Hotspot you can never be sure, but my experiments with primitive optimization in the past showed no good results for such cases. It is maybe also related to the code size and the number of jumps it includes. I won't say JIT cannot optimize that as well at some point. But reaching it requires many many more steps than right now. And since a certain threshold has to be met each time, it is questionable if there is still some practical benefit in the end.

And yes, that is a major performance improvement in 1.8 for quite some cases. Actually what we see is a common bug in those debuggers. Because as we have found here already, it is allowed to have multiple line number attributes for the same line of code. The problem is that Java usually doesn't do that. And because Java does not, nobody thought about implementing that ""right"". But I don't see a way around this bug without giving up either line numbers or the current structure. 
;;;","13/Apr/12 09:29;jasona@blazetrail.ca;It's hard to justify performance optimizations over functionality. imo, being able to use a debugger on Groovy should be first priority and sacred requirement.  

I can't emphasize enough how much of a negative impact this bug has when you set a breakpoint in a large Groovy project, spend time setting up program, run it only to find that it ignored your breakpoint and kept running past because of this issue.  Using println and assert to cause a breakpoint as a debugging technique is akin to the stone age.   Code coverage tools are broken too.

If bytecode experiments are done, perhaps on 2.x would be more appropriate.   If bug is found in 1.8.x maybe it's time to roll back those changes until they can be made in a safer way.
;;;","13/Apr/12 17:16;blackdrag;I think there is no need to revert the change fully, just a new option to turn it off in groovyc should be enough. But for the time being...

I assume that the debugger falsely works only on one branch, thus if you don't get into that branch, the debugger will not work. Now the question is which one that is. Jason, do you use it for Grails? I am trying to find out if you use the primopts branch or the other one.;;;","13/Apr/12 17:54;jasona@blazetrail.ca;Yes I use Groovy with Grails 2.x and dev build of Grails 2.1.  Also standalone gooovy outside Grails with same groovyall jar 1.8.6 that is from Grails.;;;","14/Apr/12 03:36;gromopetr;Jochen, have you experimented with putting different branches into different (synthetic) methods? Not sure this really helps but I've seen javac generating duplicate line numbers in different methods, and the debugger stopped on both of those lines.;;;","14/Apr/12 06:07;blackdrag;@Jason, you have the debugging problem in both usages?

@Peter, generating synthetic methods is something I have been thinking about too. But it is not trivial to do, as we sometimes split the primopts block. Switching from one method to the other is then not possible, splitting into many many methods, will reduce the amount of normal methods you can use very much.;;;","14/Apr/12 11:37;jasona@blazetrail.ca;Mainly debugging in IntelliJ + JUnit + plain old groovy code;;;","14/Apr/12 13:23;melix;Hi there,

Just to be precise, I verified that Groovy wrote the line numbers using the ASM API. This doesn't mean that ASM itself writes the line number table properly in the bytecode. This has still to be checked. It would be useful to test if Groovy master, which uses ASM 4 instead of ASM 3, still has the problem.;;;","03/Jun/12 22:15;rattigan;I'm doing Grails development, and this is driving me nuts. This should be a blocker. I've wasted a lot of time wondering why my breakpoints aren't being hit in IDEA. This problem is doing the platform a great disservice. Please address this!;;;","12/Jun/12 10:04;blackdrag;The more I look into that issue the more I have no idea what is actually wrong. I used javap to look at the line number table and it contains 2 entires for each source line, according to fast and slow path. So this looks correct to me. There is also no label/bytecodeline used twice for one line number.

In Java it can happen that you have multiple bytecode areas for the same source line, that is for example if you have a finally block. Since the JSR isntrcution is not to be used anymore you ""inline"" that block of code at multiple places, causing the creation of multiple disconnected ares in the source code with the same source line. Another example could be a simple for, that has one part for the declaration and checks, and another for the increment, which can be at the end of the loop block.

So the what is wrong? No idea? The most likely answer currently seems to be that we use something the debugger don't expect and handle wrong. In other words a bug in the debugger.  Since we don't know what exactly is causing the problem I have no idea on how to solve the issue;;;","12/Jun/12 10:44;blackdrag;Since I did see a normal usage of debugger in Groovy bytecode just a few days ago I am wondering if that is not specific to a certian program. To check this I would need an example for this issue, as small as possible and best out of Grails. Can someone provide that?;;;","12/Jun/12 11:02;gromopetr;Given that there's also GROOVY-4063, where the bytecode also seems correct, I'd agree. Perhaps it's JVM not treating the generated bytecode correctly, maybe some JIT optimizations gone wrong. You can always look into the OpenJDK source, you know :)

There are plenty of small examples:
http://youtrack.jetbrains.com/issue/IDEA-84538
http://youtrack.jetbrains.com/issue/IDEA-82741
http://youtrack.jetbrains.com/issue/IDEA-77116
http://youtrack.jetbrains.com/issue/IDEA-77107;;;","12/Jun/12 11:23;jasona@blazetrail.ca;This isn't Grails specific.  We have plain old Groovy unit tests run in IntelliJ + JUnit launcher, if you try to debug them, set breakpoints, the breakpoints do not get hit.

It comes down to groovyc needs to generate bytecode that can be understood/debugged by current versions of JDK (eg 6+).  This should not be a mystery in terms of how to test it.  (the example is above in original report).;;;","12/Jun/12 11:28;werdna;Same behavior in Groovy-Eclipse.;;;","12/Jun/12 12:48;blackdrag;there is actually one very simple possibility I haven't included yet and that is that the groovy compiler simply emits labels with a wrong line number. Peter mentioned GROOVY-4063, but that is about something not working in 1.6 already. That surely is not related to primtive optimizations at all. And it might be, that it is just the same here. ;;;","12/Jun/12 13:03;blackdrag;After looking at the bytecode of the example in GROOVY-4063 I actually found an error. It seems we don't generate a line number information for simple method calls in the fast path. ;;;","22/Jun/12 14:46;blackdrag;I fixed the issue I found through GROOVY-4063 and I think it fixes this issue here. But since GROOVY-4063 is reported for pre 1.8 I guess it is a different thing there actually. Please reopen if needed;;;",,,,,,,,,,,,,,,,
@Field access within closure fails with 'BUG! exception in phase 'class generation' in source unit',GROOVY-5207,12815685,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ray@suliteanu.com,ray@suliteanu.com,20/Dec/11 10:10,12/Feb/12 04:03,14/Jul/23 06:00,13/Jan/12 21:42,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,,,,,0,,,,,,"Looks like accessing @Field fields inside closures has a problem. Please file a bug.

---------------------------------------------
import groovy.transform.Field

@Field pomProperties = [:]

"""".each {
    pomProperties[1] = 2
}
---------------------------------------------
fails with the same error.
---------------------------------------------
Caught: BUG! exception in phase 'class generation' in source unit 'C:\Temp\m2g.groovy' tried to get a variable with the name pomProperties
 as stack variable, but a variable with this name was not created
---------------------------------------------",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Jan/12 05:50;paulk;groovy5207.patch;https://issues.apache.org/jira/secure/attachment/12722596/groovy5207.patch","11/Jan/12 06:14;paulk;groovy5207B.patch;https://issues.apache.org/jira/secure/attachment/12723018/groovy5207B.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 13 21:42:55 UTC 2012,,,,,,,,,,"0|i2cqwv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jan/12 05:50;paulk;Possible patch attached. It is a little crude in that it runs the VariableScopeVisitor twice. It might be possible to come up with a more efficient alternate approach.;;;","11/Jan/12 06:14;paulk;OK, a slightly nicer patch I think.;;;","13/Jan/12 21:42;paulk;Closures defined externally from the source unit being compiled didn't correctly access @Field fields. This should be fixed now. Thanks for spotting and reporting the problem.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Delegate to a method with optional params,GROOVY-5204,12816029,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mxm-groovy,mxm,19/Dec/11 01:47,22/Feb/22 03:12,14/Jul/23 06:00,27/May/21 17:21,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.16,3.0.10,4.0.0-beta-1,xforms,,,,0,,,,,,"Groovyc fails to compile this code with a message like 'method foo is already defined in B'
{code}
class A {
  def foo(a = ''){}
}

class B {
  @Delegate A a = new A()
  def foo(){}
}
{code}

while these snippets are compiled pretty well
{code}
class A {
  def foo(a){}
  def foo(){}
}

class B {
  @Delegate A a = new A()
  def foo(){}
}
{code}

{code}
class A {
  def foo(a=''){}
}

class B extends A{
  def foo(){}
}
{code}

IMHO there should be a warning (or nothing at all) instead of the compilation error.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 02 11:27:30 UTC 2016,,,,,,,,,,"0|i2c1cf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Dec/11 21:14;roshandawrani;In the last snippet, corrected ""class B extends B"" to ""class B extends A"".;;;","02/Jun/16 11:27;paulk;Perhaps this is nothing to do with @Delegate. I get the same error message from:
{code}
class A {
  def foo(a = ''){}
  def foo() {}
}
{code}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
inherited non public listener structure causing NPE,GROOVY-5202,12815987,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,lwolter,lwolter,18/Dec/11 07:35,19/Feb/12 08:39,14/Jul/23 06:00,01/Feb/12 09:27,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.6,2.0-beta-3,,,,,0,,,,,,"the following script works with groovy 1.8.2 but not with 1.8.4 oci connection has an error (oci_error.txt) -- thin connection works
{code}
import groovy.sql.Sql
import java.sql.SQLException
def dbc = Sql.newInstance('jdbc:oracle:oci:@b003', 'system', 'system', ""oracle.jdbc.driver.OracleDriver"")
//def dbc = Sql.newInstance('jdbc:oracle:thin:@//server:1521/b003', 'system', 'system', ""oracle.jdbc.driver.OracleDriver"")
println dbc.properties
def row = dbc.firstRow(""SELECT count(*) FROM all_users WHERE username = 'SYSTEM'"")
println row
dbc.connection.autoCommit = false
{code}","Windows XP, Oracle 11.2.0.2",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Jan/12 19:39;jwagenleitner;GroovyBugEventListeners.zip;https://issues.apache.org/jira/secure/attachment/12722158/GroovyBugEventListeners.zip","18/Dec/11 07:35;lwolter;oci_error.txt;https://issues.apache.org/jira/secure/attachment/12722595/oci_error.txt",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Feb 19 08:39:56 UTC 2012,,,,,,,,,,"0|i2c0pz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Jan/12 19:39;jwagenleitner;The problem appears to be with processing EventSetDescriptors.  The OCI driver uses the {{T2CConnection}} whose super class {{PhysicalConnection}} contains add/remove event listener methods. The base class is package private and abstract.  The thin driver uses {{T4CConnection}} and that class overrides the {{addXSEventListener}} methods, so that is likely why the thin driver does not exhibit the problem.

I was able to create some sample classes that reproduce the problem (Groovy 1.8.3+ and JDK 6 and 7):

# unzip GroovyBugEventListeners.zip
# cd GroovyBugEventListeners/
# javac example/*
# groovy AbstractBaseWithEventListeners.groovy

Note that if you either make {{FooBaseConnection}} public or change the event listeners from the {{FooEventListener}} interface to the {{java.util.EventListener}} you no longer get the NPE.;;;","25/Jan/12 02:41;blackdrag;the error seems to appear in code from this:{code:Java}
        EventSetDescriptor[] eventDescriptors = info.getEventSetDescriptors();
        for (EventSetDescriptor descriptor : eventDescriptors) {
            Method[] listenerMethods = descriptor.getListenerMethods();
            for (Method listenerMethod : listenerMethods) {
                final MetaMethod metaMethod = CachedMethod.find(descriptor.getAddListenerMethod());
                addToAllMethodsIfPublic(metaMethod);
                String name = listenerMethod.getName();
                if (listeners.containsKey(name)) {
                    listeners.put(name, AMBIGUOUS_LISTENER_METHOD);
                } else {
                    listeners.put(name, metaMethod);
                }
            }
        }{code}
because in addToAllMethodsIfPublic we do{code:Java}
    private void addToAllMethodsIfPublic(MetaMethod metaMethod) {
        if (Modifier.isPublic(metaMethod.getModifiers()))
            allMethods.add(metaMethod);
    }{code}
And I think it is the metaMethod.getModifiers(), that is causing the NPE. A quick fix certainly would be to say we just skip the iteration step if we don't find the method and then not enter addToAllMethodsIfPublic at all. I guess for a non public listener it might be possible that you don't find such a method, especially in a subclass.;;;","25/Jan/12 14:17;jwagenleitner;You are right, {{metaMethod}} is null so it is the {{getModifiers()}} generating the NPE.  The {{descriptor.getAddListenerMethod()}} returns {{public void groovy.bugs.example.FooConnection.addFooEventListener(groovy.bugs.example.FooEventListener)}}, but the {{CacheMethod#find(Method)}} lookup only includes methods from the declaring class in this case.  By the time it reaches here, the method {{public void groovy.bugs.example.FooBaseConnection.addFooEventListener(groovy.bugs.example.FooEventListener)}} from the superclass has already been added to the all methods.  So with a null check in place it just does not add the method name to the listeners map.;;;","25/Jan/12 21:27;jwagenleitner;I checked out the GROOVY_1_8_2 tag and found that it works because {{methods}} in the code below includes the public methods from the abstract super class.

{code:title=groovy.lang.MetaClassImpl}
public static CachedMethod find(Method method) {
   CachedMethod[] methods = ReflectionCache.getCachedClass(method.getDeclaringClass()).getMethods();
{code}

So 1.8.2 {{methods}} is

# public void groovy.bugs.example.FooConnection.addFooEventListener(groovy.bugs.example.FooEventListener)
# public void groovy.bugs.example.FooConnection.removeFooEventListener(groovy.bugs.example.FooEventListener)
# public java.lang.String groovy.bugs.example.FooConnection.someMethod()

And in master it is

# public java.lang.String groovy.bugs.example.FooConnection.someMethod();;;","01/Feb/12 04:49;blackdrag;I updated the title to reflect the issue at hand better, since it is not really SQL specific;;;","01/Feb/12 09:27;blackdrag;should be fixed now;;;","01/Feb/12 22:23;jwagenleitner;I admit I don't know much about event listener handling and this is probably such an edge case it does not matter much, the null check is probably just fine.  However, I was just curious about the problem so ran a {{git bisect}} to track the commit that caused this to no longer work (broke sometime after 1.8.2).
 
[Commit 3c47089c9573df7d01227f07d3a6fac5886a61eb|https://github.com/groovy/groovy-core/commit/3c47089c9573df7d01227f07d3a6fac5886a61eb] introduced this problem by no longer adding these types of methods to the cached class.  To get a good view of the change you can run:

{code}git show -w 3c47089c9573df7d01227f07d3a6fac5886a61eb{code}

{code}
commit 3c47089c9573df7d01227f07d3a6fac5886a61eb
Author: Guillaume Laforge <glaforge@gmail.com>
Date:   Thu Sep 22 21:51:48 2011 +0200

    GROOVY-5003: Fix the problem in handling bridge methods

diff --git a/src/main/org/codehaus/groovy/reflection/CachedClass.java b/src/main/org/codehaus/groovy/reflection/CachedCl
index 139babb..ec6d4da 100644
--- a/src/main/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/org/codehaus/groovy/reflection/CachedClass.java
@@ -96,7 +96,7 @@ public class CachedClass {
                 final CachedMethod cachedMethod = new CachedMethod(CachedClass.this, declaredMethods[i]);
                 final String name = cachedMethod.getName();
 
-                if (name.indexOf('+') >= 0) {
+                if (declaredMethods[i].isBridge() || name.indexOf('+') >= 0) {
                     // Skip Synthetic methods inserted by JDK 1.5 compilers and later
                     continue;
                 } /*else if (Modifier.isAbstract(reflectionMethod.getModifiers())) {
{code}

The current fix that is probably fine, but I found it interesting since the inherited methods are public as part of the subclass and it seems as if they should be part of the cached class.  But again, this is territory I'm not very familiar with so just wanted make note of what caused it break between versions 1.8.2 and 1.8.3.;;;","01/Feb/12 22:33;jwagenleitner;Just read up on bridge methods and guess it does make sense to skip them. :)

Thanks for the fix.;;;","19/Feb/12 08:39;lwolter;I have test it with version 1.8.6 successfully. Thank you very much. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Anonymous class with elipsis type in constructor,GROOVY-5200,12816018,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,mxm-groovy,mxm,17/Dec/11 11:53,17/Jun/15 20:09,14/Jul/23 06:00,28/Dec/14 07:59,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.0-rc-1,,,Compiler,,,,0,,,,,,"{code:title='main.groovy'}
abstract class Abc {
    Abc(String... s) {}
    
    abstract def run()
}

print new Abc() {
    def run(){}
}
{code}

Try to run this code sample and get the following exception :
{{Caught: java.lang.ArrayIndexOutOfBoundsException: 0}}
{{java.lang.ArrayIndexOutOfBoundsException: 0}}
{{at main$1.<init>(main.groovy)}} 
{{at main.run(main.groovy:7)}}",,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 28 07:59:18 UTC 2014,,,,,,,,,,"0|i2crqn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Dec/14 07:59;pschumacher;Thanks for reporting. Your example works for me with groovy 2.4.0-rc-1.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Expression#transformExpression should copy node metadata,GROOVY-5199,12815829,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,16/Dec/11 07:57,24/Dec/11 03:08,14/Jul/23 06:00,16/Dec/11 08:30,1.8.4,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,,,,,0,,,,,,"When an expression is transformed through {{Expression#transformExpression}}, we must make sure to copy node metadata, otherwise this information can be lost for further processing.

It is important for static compilation which relies on node metadata computed by the static type checker. This inferrence information is lost after the OptimizerVisitor has transformed expressions.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-16 07:57:14.0,,,,,,,,,,"0|i2cru7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"using ""as"" to coerce a String to an Enum value results in a groovy.lang.MissingMethodException under high contention",GROOVY-5198,12818130,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,sreilly@equalexperts.com,sreilly@equalexperts.com,16/Dec/11 05:58,24/Dec/11 03:08,14/Jul/23 06:00,19/Dec/11 05:57,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.5,2.0-beta-2,,,,,0,,,,,,"I've provided a test case in the form of a simple script that can be run in GroovyConsole.

It creates 5000 threads -- each thread converts strings to enums in a loop.
I tried three different methods of converting strings to Enums in the test.

These two seem to work fine:

Foo f = Foo.valueOf(key)
Foo f = Enum.valueOf(Foo, key)

However, under load, this method:

Foo f = key as Foo

will occasionally throw an exception like the following:

{noformat}
Exception in thread ""Thread-127349"" 
org.codehaus.groovy.runtime.InvokerInvocationException: groovy.lang.MissingMethodException: No signature of method: static Foo.valueOf() is applicable for argument types: (java.lang.String) values: [bar]
Possible solutions: valueOf(java.lang.String), valueOf(java.lang.Class, java.lang.String), values()
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:97)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:883)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:404)
	at groovy.lang.Closure.run(Closure.java:488)
	at java.lang.Thread.run(Thread.java:680)
Caused by: groovy.lang.MissingMethodException: No signature of method: static Foo.valueOf() is applicable for argument types: (java.lang.String) values: [bar]
Possible solutions: valueOf(java.lang.String), valueOf(java.lang.Class, java.lang.String), values()
	at groovy.lang.MetaClassImpl.invokeStaticMissingMethod(MetaClassImpl.java:1349)
	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1335)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:767)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.asType(DefaultGroovyMethods.java:17327)
	at org.codehaus.groovy.runtime.dgm$58.doMethodInvoke(Unknown Source)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1053)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:883)
	at org.codehaus.groovy.runtime.InvokerHelper.invokePojoMethod(InvokerHelper.java:781)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:772)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:164)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.asType(ScriptBytecodeAdapter.java:587)
	at TestCase$_run_closure1_closure4_closure5.doCall(TestCase.groovy:12)
	at sun.reflect.GeneratedMethodAccessor682.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:883)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:423)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.times(DefaultGroovyMethods.java:12140)
	at org.codehaus.groovy.runtime.dgm$753.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:271)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:53)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at TestCase$_run_closure1_closure4.doCall(TestCase.groovy:10)
	at sun.reflect.GeneratedMethodAccessor672.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:883)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at TestCase$_run_closure1_closure4.doCall(TestCase.groovy)
	at sun.reflect.GeneratedMethodAccessor665.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	... 7 more
{noformat}

It's a concurrency issue, so the test isn't 100% reliable, but on my hardware this test can make the ""as"" conversion fail at least once in a test run most of the time. The other two methods seem to always work.
",OS X lion w/ JDK1.6.0_29 (build 1.6.0_29-b11-402-11M3527),sreilly@equalexperts.com,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Dec/11 05:58;sreilly@equalexperts.com;TestCase.groovy;https://issues.apache.org/jira/secure/attachment/12722165/TestCase.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 19 05:57:53 UTC 2011,,,,,,,,,,"0|i2byan:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Dec/11 05:57;melix;Fixed making CacheEntry fields final.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Source location incorrect for statement after a label,GROOVY-5197,12815872,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,werdna,werdna,15/Dec/11 17:23,12/Feb/12 04:03,14/Jul/23 06:00,28/Dec/11 21:02,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,parser-antlr2,,,,0,,,,,,"Take this code and put it into the groovy console:
{code}
def meth() {
  label:
    assert i == 9
}
{code}

Now inspect the AST and navigate to the assert statement.  You will see that the assert statement has a lineNumber and lastLineNumber are 2, but it should be 3.  This is incorrect.  It doesn't seem like this affects Groovy itself too much, but this is causing an exception in Groovy-Eclipse.  See GRECLIPSE-1270.

The fix is simple enough.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Dec/11 04:15;paulk;groovy5197.patch;https://issues.apache.org/jira/secure/attachment/12722645/groovy5197.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 28 21:02:57 UTC 2011,,,,,,,,,,"0|i2c2ev:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Dec/11 17:28;werdna;Fix:  in {{org.codehaus.groovy.antlr.AntlrParserPlugin.statement(AST)}} at the end of the method, change:

{code}
if (statement != null) {
    configureAST(statement, node);
}
{code}

to:

{code}
if (statement != null && type != LABELED_STAT) {
    configureAST(statement, node);
}
{code}

This problem is coming about because the source location of {{statement}} is being set twice: once from within the call to {{labeledStatment}} using the correct source location and once again using the source location for just the label in the call to {{statement}}.

This leads me to question if explicitly calling {{configureAST}} is necessary at all in the {{statement}} method since all calls to create the different kinds of statements already call {{configureAST}}.;;;","27/Dec/11 04:15;paulk;Proposed patch - a slight variation of what Andrew proposed. The code for the statement method is a little strange in that despite each branch of the switch deriving the respective source positioning depending on the particular branch chosen, it then overrides that information with the information for the entire node. The more refined info is useful in other contexts.;;;","27/Dec/11 07:05;blackdrag;I guess the patch is ok then;;;","27/Dec/11 21:34;paulk;Well, it is more of a philosophical decision I think. At the statement level, we tend to keep track of the whitespace around the statement. Here we would not be doing this. There are no LineColumn checks that test this area. There is only a very minimal SourcePrinter test. I will do another sanity check with some more elaborate SourcePrinter tests before applying the patch. The alternative is that we need to document that any statement may contain a label and it would be up to other tools, e.g. CodeNarc etc. to step around the label. We could provide a utility to make it easier I guess.;;;","28/Dec/11 00:18;werdna;From the tooling perspective, including whitespace in AST nodes is problematic (specifically in expression nodes and too a lesser extent in statement nodes).  There are many situations where trailing whitespace must be worked around.

When there is an easy fix, I patch the groovy compiler and try to send you guys a patch, but often I need some hairy workaround code in Groovy-Eclipse.

Is there a reason why many AST nodes keep trailing whitespace?  Or is this largely legacy?  (From my investigations, it seems to be built into the parser.);;;","28/Dec/11 16:36;blackdrag;I think it is mainly because it is not easy to tell the grammar to not to include the whitespace and since we didn't really need that information to a level where trailing whitespace matters, we simply didn't put in the energy to prevent that from happening.;;;","28/Dec/11 21:02;paulk;Patch applied - I tried playing around with different source texts to confuse the SourcePrinterTests but could't spot any obvious breakages.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Map#drop Javadoc breaks all following Javadoc,GROOVY-5196,12815963,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,wujek,wujek,15/Dec/11 14:29,24/Dec/11 03:08,14/Jul/23 06:00,16/Dec/11 02:43,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,,,,,0,,,,,,"The Map#drop Javadoc has some invalid HTML in it, making all following Javacod preformatted as well.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 16 02:43:06 UTC 2011,,,,,,,,,,"0|i2c633:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Dec/11 14:39;wujek;The problem is in the following lines:

* If the map instance does not have ordered keys,then this function could return a random <code>n<code>
* entries.

The <code> tag is not closed properly.;;;","16/Dec/11 02:43;paulk;fixed - thanks for spotting that!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compilation should always fail when two methods exist in the same class with the same name but differing access levels,GROOVY-5193,12812066,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,bcarr,bcarr,14/Dec/11 08:08,12/Feb/12 04:03,14/Jul/23 06:00,31/Jan/12 09:12,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,,,,,0,breaking,,,,,"Currently, the check only fails under certain circumstatnces, but according to Jochen, it should always fail.

The following passes, but apparently should not:
{code}class Repository {
  def find(String id) {}
  private <T> T find(Class<T> type, String id, boolean suppressNotFoundExceptions) { }
}{code}

The following fails, as expected:

{code}class Repository {
  def find(String id) {}
  private <T> T find(Class<T> type, String id, boolean suppressNotFoundExceptions = true) { }
}{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 31 09:11:36 UTC 2012,,,,,,,,,,"0|i2c7uf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Jan/12 09:11;melix;Patch is reverted in 1.8.6 because it broke some code which previously compiled in Grails. The fix is only on 2.0.x. Here's the discussion:

{noformat}
[11:40:55 CEST] Peter Ledbrook: Another one for the Groovy folks: http://pastebin.com/0FUCJzPa
[11:41:32 CEST] Peter Ledbrook: Recognise the error? This is from an existing Grails project that compiled fine with Grails 2.0, but fails with 2.0.1 (with Groovy 1.8.5)
[11:43:39 CEST] Cédric Champeau: yes, it happens when you have two covariant methods with different modifiers (private/public), Jochen fixed an issue with that recently
[11:43:54 CEST] Cédric Champeau: so that's why the warning occurs
[11:44:18 CEST] Peter Ledbrook: It's not a warning. It's an error and the compilation fails. Or has it been reverted to a warning for 1.8.6?
[11:44:32 CEST] Cédric Champeau: I mean error, there's no warning in Groovy :)
[11:45:07 CEST] Peter Ledbrook: Can I say that I think this is a bad change for a patch release?
[11:46:26 CEST] Cédric Champeau: You can, but I'm sure Jochen has good arguments :) (That's also a reason for the numbering scheme change, with the last number which should only be used for bugfixes starting from 2.0)
[11:47:27 CEST] Peter Ledbrook: Numbering scheme change? You mean from 1.9 -> 2.0? Or something else?
[11:47:42 CEST] Peter Ledbrook: Anyway, I believe that there is no good reason to introduce a breaking change into a patch release.
[11:47:43 CEST] Cédric Champeau: yes, 1.9 becoming 2.0.0
[11:48:08 CEST] Peter Ledbrook: It happened with Grails and it's a bad idea. We definitely don't want Grails 2.0.1 going out with a breaking change.
[11:49:35 CEST] Cédric Champeau: found the jira issue related to this change: https://jira.codehaus.org/browse/GROOVY-5193
[11:49:44 CEST] Cédric Champeau: considered as a bugfix
[11:51:40 CEST] Peter Ledbrook: Thanks. But it's still a breaking change and anyone upgrading from Grails 2.0 to 2.0.1 will suddenly hit this compilation error with Searchable. And who knows what other plugins.
[11:51:55 CEST] Peter Ledbrook: I'm not defending the code that's not compiling.
[11:51:59 CEST] Cédric Champeau: from what I read, it's still possible to remove the fix from 1.8.x branch and keep it in 2.0
[11:52:24 CEST] Peter Ledbrook: That would get my vote :) So is there no way to make it a warning?
[11:52:32 CEST] Cédric Champeau: unfortunately, no
[11:54:00 CEST] Peter Ledbrook: Ouch. Which means no one knows that code needs fixing until it breaks. Anyway, we'll get a version of Searchable out that compiles with 1.8.5, but I strongly vote for rolling back the change on the 1.8.x branch.
[13:09:27 CEST] Jochen: and it is without using default arguments?
[13:10:20 CEST] Jochen: is there a somewhere a link to the source?
[13:21:13 CEST] Jochen: because if no default arguments have been used, then it should have failed before already.
[13:21:28 CEST] Jochen: the default argument usage was therefore a way to bypass this logic
[13:32:01 CEST] Peter Ledbrook: https://github.com/gpc/grails-searchable/blob/master/src/groovy/grails/plugin/searchable/internal/compass/mapping/ClosureSearchableGrailsDomainClassCompassClassMapper.groovy
[13:32:08 CEST] Peter Ledbrook: It's the two init() methods causing the problem.
[13:44:08 CEST] Jochen: so no default parameter usage
[13:44:19 CEST] Jochen: that should not have compiled before
[13:44:41 CEST] Jochen: then I guess we should revert the change for 1.8, since it was more broken than I though
{noformat};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Running script with '--enoding' param and some script parameters,GROOVY-5191,12815984,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,mxm-groovy,mxm,14/Dec/11 03:30,17/Jun/15 20:09,14/Jul/23 06:00,16/Dec/12 16:58,1.8.6,2.0-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,command line processing,,,,1,,,,,,"Create simple script 'main.groovy':
{code}
args.each {println it}
{code}

and try to run it by the following command:
{{groovy --encoding=UTF-8 main.groovy -script -param}}

The output is:
{{script}}
{{-p}}
{{-a}}
{{ram}}

while the expected output is:
{{-script}}
{{-param}}","win 7 x64, jdk 1.6.0.27, groovy 1.9-beta-3",blackdrag,paulk,weitzj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5020,GROOVY-5282,,,,,"20/Feb/12 07:24;weitzj;patch.diff;https://issues.apache.org/jira/secure/attachment/12722598/patch.diff","14/Dec/11 03:30;mxm;proof.png;https://issues.apache.org/jira/secure/attachment/12722359/proof.png",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 04 22:32:16 UTC 2013,,,,,,,,,,"0|i2c1z3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Dec/11 03:55;blackdrag;that sounds very much like a commons cli problem to me.;;;","14/Dec/11 04:36;mxm-groovy;The same result is in IntelliJ IDEA if file have encoding which differs from system default one.

BTW the command without --encoding param produces the correct output (from cmd and IntelliJ iDEA)
{code}
groovy main.groovy -script -param
{code}



;;;","19/Feb/12 10:05;weitzj;Issue is universal. e.g. MacOSX, 2.0.0-beta-3
Fix: Pull Request - https://github.com/groovy/groovy-core/pull/28

Hi,

it's not a commons cli problem. The problems is inside the logic how GroovyMain parses it's args and determines whether it will need the params to itself or pass them to your scriptFile.

Since '-p' and '-a' are Options in GroovyMain and you specified '-param', GroovyMain will extract '-p', and '-a' and give you the rest, which it did not recognize => 'ram'

Therefore the --encoding param is just one example on how this fails.
You can take any params abbreviation, which is used by GroovyMain. 

The current logic determines the name of the scriptfile you want to run, too late, which explains, why 

groovy --encoding=UTF-8 main.groovy -script -param

fails, while

groovy main.groovy -script -param 

does not fail.

So, I think we should force the convention that you first enter all params for the GrooyMain part, then an optional scriptFile and optional scriptArgs.

groovy [options] [scriptName scriptArgs]
;;;","19/Feb/12 14:20;weitzj;Related tickets:
https://jira.codehaus.org/browse/GROOVY-5020
https://jira.codehaus.org/browse/GROOVY-5282
;;;","20/Feb/12 05:43;paulk;link related issues;;;","20/Feb/12 05:46;paulk;The following currently works:
{code}
groovy -e ""println args[0]"" hi
{code}
but produces ""{{java.lang.ArrayIndexOutOfBoundsException: 0}}"" after the patch.

As a minimum this would need to be flagged as a breaking change but I am wondering how many people rely on the above behavior and changing it would not be good for them.
;;;","20/Feb/12 07:24;weitzj;Hi Paul, 
thanks. This was a small error. I did not catch the -e option. You can apply the uploaded patch, which fixes this or get everything from the pull request on Github.
https://github.com/weitzj/groovy-core/commit/bfd6870f8513c5443b7822ef74dbee449ecf3d1e

or change line 386 in groovy.ui.GroovyMain.java to read the following:

if(main.processFiles) --> if(!main.isScriptFile || main.processFiles)


The logic is now:
 * if the user uses the -n, -p or -e option, everything should stay the same as it has before.

Otherwise we know we have a groovy script, which should get executed, and change the args array.


Greetings,

Jan;;;","23/Feb/12 17:37;weitzj;Do you need any more input on this? Is this all crap? :-)

Greets,

Jan;;;","23/Feb/12 19:05;paulk;Your suggestions are probably all spot on - speaking for myself, I just need more time to test and have been pretty busy lately. Parameter passing has traditionally been a very fragile area - mostly not to do with changes we make in Java code; usually related to surrounding windows batch scripts or bugs in commons CLI (mostly earlier versions). And on top of that we have low (automated) test coverage of this area. In any case, I am always loathe to make any changes in this space without sufficient additional manual testing. So, hopefully with a bit more time we can progress this issue to everyone's satisfaction.;;;","16/Dec/12 05:37;paulk;OK, finally got some more time to test things out. Jan's proposed patch definitely works around the problem but it seems to me that this is really a workaround that we shouldn't have to do and in fact there is indeed a bug in Commons-CLI. If I swap out the PosixParser that we currently use and replace it with the GnuParser (or the DefaultParser in Commons-CLI 1.3-SNAPSHOT) then the problem goes away. And looking at the source code for PosixParser, it never seems to clear out the ""currentOption"" field in between iterations - which it should do to work properly when ""stopAtNonOption"" is set to true as per how we use that parser.;;;","16/Dec/12 16:58;paulk;There is now a custom GroovyPosixParser which I hope fixes (some of) the bugs in PosixParser. This should just be an interim measure until Commons-CLI 1.3 is released at which point we should be able to delete that class and switch over to DefaultParser from commons-cli itself.

Note: in 2.1, the ""posix"" flag for CliBuilder is deprecated and GroovyPosixParser becomes the default parser in use if no explicit class is specified via the parser parameter.;;;","04/Jan/13 02:55;blackdrag;Paul, can't we then close this issue and the pull request? I think the issue does not need to stay open until CLI 1.3 eventually comes into existence ;;;","04/Jan/13 22:32;paulk;Yes, closing is fine.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Character XOR behaves differently depending on JVM,GROOVY-5189,12815994,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,tim_yates,tim_yates,13/Dec/11 09:25,22/Dec/12 01:10,14/Jul/23 06:00,19/Dec/12 07:26,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,,groovy-jdk,primtive opts,,,1,,,,,,"If you run this piece of code:

{code}
println GroovySystem.version
println( ('a' as char) ^ ('b' as char) )
{code}

On OS X running with the Apple JVM, then you get:

{code}
1.8.4
3
{code}

If you're running on the Java 6 OpenJDK (for example with Ubuntu, or the Groovy Web Console), you get:

{code}
1.8.4
groovy.lang.MissingMethodException: No signature of method: java.lang.Character.xor() is applicable for argument types: (java.lang.Character) values: [b]
Possible solutions: div(java.lang.Character), any(), use([Ljava.lang.Object;), plus(java.lang.Character), is(java.lang.Object), any(groovy.lang.Closure)
	at Script1.run(Script1.groovy:2)
{code}

Is there anything that can be done to get the behaviour the same across the board?

Jochen [said on the mailing list|http://groovy.markmail.org/thread/keyqmeyfdztgzfxz] that it was an issue to do with the native type optimisations.

Maybe just adding {{xor}} to Character would get rid of the OpenJDK issue?",,blackdrag,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 19 07:26:42 UTC 2012,,,,,,,,,,"0|i2cjvj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Dec/11 09:40;gershwinou;i have also tested with sun jdk (1.6.0_26) on ubuntu and it does NOT work. on my macosx, it is ok.;;;","19/Dec/12 07:26;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy Script Engine creates new classes for each script and doesn't get garbage collected,GROOVY-5187,12815976,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,espeed,espeed,12/Dec/11 16:36,22/Dec/12 01:10,14/Jul/23 06:00,17/Dec/12 08:41,1.8.4,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,,GroovyScriptEngine,,,,0,,,,,,"New classes are created for each script:

https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java#L109

Which are added to the classMap, which grows and old classes don't get garbage collected:

https://github.com/groovy/groovy-core/blob/master/src/main/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java#L338

This results in PermGen errors:

Rexster Groovy Script Engine
https://github.com/tinkerpop/rexster/issues/143

Neo4j Server Groovy Script Engine
http://neo4j-community-discussions.438527.n3.nabble.com/Neo4j-Feedback-after-evaluation-tp3569774p3574520.html

There is no public way of removing older scripts and the HashMap is not a LinkedHashMap with LRU enabled for storing them. Right now the Neo4j workaround is to recreated the GSE every 500 requests.




",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 17 08:41:56 UTC 2012,,,,,,,,,,"0|i2bphb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Aug/12 08:39;blackdrag;I made the map a soft reference based one. It can now forget entries over time. OOME can still happen of course, since class unloading is not always done as it should by the JVM, but the cases are very much reduced. This solution is kind of a middle ground. A LRU could still cause OOME, on the other hand the engine is originally not created to forget classes.;;;","17/Sep/12 09:42;blackdrag;Because of me taking the wrong map GROOVY-5706 was filled and that has a major effect on the fix released in 1.8.8 and 2.0.2, till the point the jsr223 module my not really work anymore. Thus a new fix was required, changing the fix version for this issue;;;","17/Dec/12 08:41;blackdrag;As there have been a conflict with GROOVY-5786 this feature now has to be activated. that means the engine will by default not forget global functions and attached classes. See http://groovy.codehaus.org/JSR+223+Scripting+with+Groovy for how to activate it;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cast operator precedence is incorrect,GROOVY-5185,12815871,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,melix,melix,12/Dec/11 03:34,10/Oct/15 06:34,14/Jul/23 06:00,23/Jun/15 06:00,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.4,,,groovy-runtime,,,,0,breaking_change,,,,,"The cast operator precedence is incorrect:

{code}
def i = (int)1/(int)2
assert i.class==BigDecimal // fails
{code}

To have proper casts, we need extra parenthesis which should not be necessary:

{code}
def i = ((int)1)/((int)2)
assert i.class==BigDecimal // ok
{code}
",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 16 10:59:07 UTC 2015,,,,,,,,,,"0|i2c9sf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jun/15 10:49;paulk;Is this a duplicate of GROOVY-4421?;;;","23/Jun/15 05:28;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/42

    GROOVY-5185: Cast operator precedence is incorrect

    I think this rolls back the prod code changes from GROOVY-2605 but we may have done other changes in the meantime since the tests for the issue seem to all still pass.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy5185

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/42.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #42
    
----
commit 3b9f239790482931a9651cb18c4f0aeeb40ef116
Author: Paul King <paulk@asert.com.au>
Date:   2015-06-23T05:26:02Z

    GROOVY-5185: Cast operator precedence is incorrect

----
;;;","23/Jun/15 05:50;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/42
;;;","16/Jul/15 10:59;paulk;This is a breaking change if you were relying on the ""broken"" precedence. Groovy is now closely aligned with Java's cast precedence rules.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checker doesn't handle divisions properly,GROOVY-5184,12815869,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,12/Dec/11 03:25,24/Dec/11 03:08,14/Jul/23 06:00,12/Dec/11 08:00,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"In the following code:
{code}
def res = 1 / 2
{code}

The inferred type is a {{Number}} because of the return type of DGM#div.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-12 03:25:40.0,,,,,,,,,,"0|i2c59j:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""static final"" constructors should be a Compile-time error",GROOVY-5181,12815892,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,shemnon,shemnon,08/Dec/11 22:13,24/Dec/11 03:08,14/Jul/23 06:00,09/Dec/11 04:26,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,class generator,,,,0,,,,,,"Some modifiers on the constructor should be disallowed instead of being passed to the init method.  For example ""static"":

class Foo {
  static final Foo() {
    println 'it works!'
  }
}

This creates a method <init> with modifiers of 0x19, which are static public and final.  Not valid for a constructor.  This should bomb at compile time instead of generating bytecode.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-08 22:13:50.0,,,,,,,,,,"0|i2byvj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Enum Comparison results in incorrect map behavior when using add assignment operator,GROOVY-5180,12816014,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,,davidclark,davidclark,08/Dec/11 17:15,09/Dec/11 02:23,14/Jul/23 06:00,09/Dec/11 02:23,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.4,,,Compiler,,,,0,,,,,,"In the attached test case you will see four methods which do the same three things.  Each initializes a map, increments a value in the map, and then returns the map.  The method called ""works()"" uses the add assignment operator to do this.  The ""buggy()"" method is the same, but adds an enum comparison.

There is some interaction between the enum comparison and the += operator.  The method ""numericComparison()"" is just like ""buggy(),"" but performs an integer comparison.  The ""workaround()"" method avoids the += operator.  Both of these methods return a Map as expected.","java version ""1.6.0_23""
OpenJDK Runtime Environment (IcedTea6 1.11pre) (6b23~pre11-0ubuntu1.11.10)
OpenJDK 64-Bit Server VM (build 20.0-b11, mixed mode)

Groovy Version: 1.8.2 JVM: 1.6.0_23",paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"08/Dec/11 17:15;davidclark;EnumCompareBug.groovy;https://issues.apache.org/jira/secure/attachment/12722639/EnumCompareBug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Dec 08 20:42:21 UTC 2011,,,,,,,,,,"0|i2bv7z:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"08/Dec/11 18:06;paulk;Strange. I just ran your example as a script and had no problems:
{code}
enum TheEnum { ONE, TWO }

def works() {
  def ret = [ '1': 100.00 ]
  ret['1'] += 45.00
  ret
}

def workaround() {
  def ret = [ '1': 100.00 ]
  if (TheEnum.ONE == TheEnum.ONE) ret['1'] = ret['1'] + 45.00
  ret
}
  
def buggy() {
  def ret = [ '1': 100.00 ]
  if (TheEnum.ONE == TheEnum.ONE) ret['1'] += 45.00
  ret
}

def numericComparison() {
  def ret = [ '1': 100.00 ]
  if (1 == 1) ret['1'] += 45.00
  ret
}

assert works() instanceof Map
assert workaround() instanceof Map
assert numericComparison() instanceof Map
assert buggy() instanceof Map
{code}

I.e. buggy() wasn't buggy for me.

I was using Java 7.0_01, Groovy 1.8.4, Windows 7, running in the groovyConsole.;;;","08/Dec/11 18:07;davidclark;Correction, only 1.8.2 is affected.  1.8.4 is NOT affected.  However, because of issue #5173 I am stuck using 1.8.2 for now.;;;","08/Dec/11 18:09;paulk;Running your script as is from the command-prompt also worked fine.;;;","08/Dec/11 18:11;paulk;So should we close this issue since it is already fixed?;;;","08/Dec/11 20:42;davidclark;This is definitely a bug in 1.8.2.  However it appears to be fixed in 1.8.4.  I am now downgrading to groovy 1.8.1 to avoid this bug and #5173.  I have added a test to my application to check for a regression of this bug in the next version.  You can close this and I will open a new version if it reappears in a later version.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC allows assign an array to any type which is not an array,GROOVY-5178,12815799,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,vns,vns,08/Dec/11 07:36,05/Apr/15 14:44,14/Jul/23 06:00,09/Dec/11 11:14,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"STC allows assign an array to any type which is not an array
{code}
import groovy.transform.*

@TypeChecked 
class Foo {
    def say() {
        FooAnother foo1 = new Foo[13] // but FooAnother[] foo1 = new Foo() reports a STC                        Error
    }
}
class FooAnother {
    
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,2011-12-08 07:36:24.0,,,,,,,,,,"0|i2c6ef:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC allows assign an array to any type which is not an array,GROOVY-5177,12815962,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,vns,vns,08/Dec/11 07:34,24/Dec/11 03:07,14/Jul/23 06:00,08/Dec/11 08:35,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"STC allows assign an array to any type which is not an array
{code}
import groovy.transform.*

@TypeChecked 
class Foo {
    def say() {
        FooAnother foo1 = new Foo[13] // but FooAnother foo1 = new Foo() reports a STC                        Error
    }
}
class FooAnother {
    
}
{code}",,vns,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-08 07:34:25.0,,,,,,,,,,"0|i2cc6n:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
incorrect handling of generics placeholders in JavaStubGenerator,GROOVY-5176,12816015,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,08/Dec/11 07:05,07/Apr/15 19:07,14/Jul/23 06:00,08/Dec/11 15:40,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,,,,,0,,,,,,"The {{JavaStubGenerator}} incorrectly handles generics signatures of the form:
{code}
java.util.List<? extends T>
{code}
instead producing
{code}
java.util.List<? extends java.lang.Object<T>>
{code}
which doesn't compile as {{java.lang.Object}} does not take parameters.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Dec 08 15:39:53 UTC 2011,,,,,,,,,,"0|i2cgdb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Dec/11 15:39;paulk;This has been fixed - not with an ideal solution but hopefully good enough until some other underlying refactoring is done.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Calling a method with a null argument's value when the parameter is an array,GROOVY-5175,12818125,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,vns,vns,08/Dec/11 06:07,24/Dec/11 03:08,14/Jul/23 06:00,08/Dec/11 08:58,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"STC Error when calling a method with an argument of null when the parameter is an array

{code:title=Null parameter with array argument}
import groovy.transform.*

@TypeChecked 
class Foo {
    def say() {
        methodWithArrayParam(null) // STC Error
    }
    def methodWithArrayParam(String[] s) {
        
    }
}

{code}

Other cases tested too:

{code:title=Simple method call with null argument}
class Foo {
    def say() {
        methodWithArrayParam(null)
    }

    def methodWithArrayParam(Date date) {

    }
}
{code}

{code:title=Multiple parameters where one of them is null}
class Foo {
    def say() {
        methodWithArrayParam(null, new Date())
    }
    def methodWithArrayParam(Date date1, Date date2) {

    }
}
{code}

{code:title=Ambiguous method call due to null parameters}
class Foo {
    def say() {
        methodWithArrayParam(null, new Date())
    }
    def methodWithArrayParam(Date date1, Date date2) {

    }
    def methodWithArrayParam(String o, Date date2) {

    }
}
{code}

{code:title=Disambiguated method call}
class Foo {
    def say() {
        methodWithArrayParam((Date)null, new Date())
    }
    def methodWithArrayParam(Date date1, Date date2) {

    }
    def methodWithArrayParam(String o, Date date2) {

    }
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Dec 08 08:58:39 UTC 2011,,,,,,,,,,"0|i2ccef:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Dec/11 08:58;melix;Fixed typo;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BigDecimals are incorrectly converted to Double after arithmetic operation (appears to be the same as [GROOVY-5102] - Unrelated changes cause BigDecimal division to return Double),GROOVY-5173,12815888,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,davidclark,davidclark,06/Dec/11 20:07,12/Dec/11 09:59,14/Jul/23 06:00,12/Dec/11 09:59,1.8.3,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,Compiler,,,,0,,,,,,"It appears that the above bug was not correctly fixed.  Addition of BigDecimals results in a type coercion of the result to Double.

I have attached a GroovyTestCase which should be self explanatory.","java version ""1.6.0_23""
OpenJDK Runtime Environment (IcedTea6 1.11pre) (6b23~pre11-0ubuntu1.11.10)
OpenJDK 64-Bit Server VM (build 20.0-b11, mixed mode)

Groovy Version: 1.8.4 JVM: 1.6.0_23",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/Dec/11 20:07;davidclark;BigDecimalBug.groovy;https://issues.apache.org/jira/secure/attachment/12723015/BigDecimalBug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 12 09:59:08 UTC 2011,,,,,,,,,,"0|i2btuv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"12/Dec/11 09:59;blackdrag;fixes and test in now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inferred generics parameter types could contain primitive types,GROOVY-5172,12815999,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,06/Dec/11 08:59,24/Dec/11 03:08,14/Jul/23 06:00,06/Dec/11 09:00,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"In some cases like Groovy classes extending Java classes, inferred generics parameter types could be primitives instead of boxed types:

{code:title=GroovyPage.java}
public class GroovyPage {
        public final void printHtmlPart(final int partNumber) {}
        public final void createTagBody(int bodyClosureIndex, Closure<?> bodyClosure) {}
    }
{code}

{code:title=Child.groovy}
class Child extends GroovyPage {
                void foo() {
                    createTagBody(1) { ->
                        printHtmlPart(2)
                    }
                }
            }
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-06 08:59:03.0,,,,,,,,,,"0|i2cmgn:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Change execution phase of static type checking,GROOVY-5171,12815801,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,06/Dec/11 04:32,24/Dec/11 03:07,14/Jul/23 06:00,06/Dec/11 04:40,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"The current phase for static type checking is {{CANONICALIZATION}}. However, some AST xforms may be triggered at this phase too. As we cannot make sure that STC will be the last transform to be started, we must delay its execution to the {{INSTRUCTION_SELECTION}} phase.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-06 04:32:20.0,,,,,,,,,,"0|i2cjp3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 GroovyRowResult and GroovyResultSet are Inconsistent with each other when using a postgres driver,GROOVY-5170,12816012,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jwadamson,jwadamson,05/Dec/11 15:21,12/Feb/12 04:03,14/Jul/23 06:00,06/Feb/12 02:39,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,,,,,0,,,,,,"Basically, the root problem seams to be that the postgres (driver?) folds unquoted object identifiers to lower case.  This behavior is transparent to the api when using sql.eachRow, but not when sql.firstRow. This appears to be related to how eachRow uses a GroovyResultSet which delegates the getObject(property) to the driver, but firstRow uses a GroovyRowResult which does not.

	String query = ""SELECT * FROM $table"";
	sql.eachRow(query){ row ->
		def eValue = row[column]
		println ""each row found $eValue"";
	}
	def fValue = sql.firstRow(query)[column]
	println ""firstRow found $fValue""

I saw code in GroovyRowResult#getProperty(String) currently checks the exact case, then tries folding the property name to upper-case (as is more common).  This is not adequate for postgres behavior which folds to lower-case.

Attached is a script which demonstrates this, an example invocation would be
`bug.groovy --url jdbc:postgresql://example.com:5432/catalog --user postgres --pass postgres --schema public --driver org.postgresql.Driver TABLE ID`
It requires a postgres database with a table and column (create using unquoted and/or lowercase names) exist with at least one row.",Groovy with a postgres database,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"05/Dec/11 15:21;jwadamson;bug.groovy;https://issues.apache.org/jira/secure/attachment/12722642/bug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 09 09:27:52 UTC 2012,,,,,,,,,,"0|i2cbrj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Dec/11 17:13;jwadamson;I posted this to ""GroovyDev"" <dev@groovy.codehaus.org> for feedback first, but now I realize I probably wasn't sending from a registered address.  So please forgive me if this a duplicate or ""works as expected"".;;;","04/Feb/12 02:56;jwagenleitner;Just wanted to add a note that the same problem can also occur with MySQL since the driver returns column labels in the same case used in the create table statement.  The {{ResultSet}} seems to handle the names case insensitively which as pointed out is not the case for the {{GroovyRowResult}}.

In Oracle, Hsqldb and H2 the column names are in uppercase so they don't have this problem.

{code}
import groovy.sql.*

def sql = Sql.newInstance('jdbc:mysql://localhost/groovy', 'groovy', 'foo', 'com.mysql.jdbc.Driver')

try {
    sql.execute('''DROP TABLE IF EXISTS foo''')
    sql.execute('''create table foo (name varchar(30), Title varchar(30))''')
    sql.execute('''insert into foo (name, title) values ('foo', 'bar')''') 
    
    sql.eachRow('select * from foo') {
        assert 'foo' == it.nAmE
        assert 'foo' == it.NAME
        assert 'bar' == it.title
        assert 'bar' == it.TITLE 
    }

    def row = sql.firstRow('select * from foo')
    // These will fail
    assert 'foo' == row.NAME
    assert 'bar' == row.title
    assert 'bar' == row.TITLE
} finally {
    sql.close()
}
{code};;;","04/Feb/12 03:12;jwagenleitner;I have submitted a github pull request (https://github.com/groovy/groovy-core/pull/21) for this issue.;;;","04/Feb/12 04:23;blackdrag;Javadoc of ResultSet says this: ""Column names used as input to getter methods are case insensitive. When a getter method is called with a column name and several columns have the same name, the value of the first matching column will be returned. ""
Going by that it should be ok to do this change;;;","05/Feb/12 02:17;paulk;John, I tried to apply your pull request but received this error:
{noformat}
Applying: GROOVY-5170: GroovyRowResult and GroovyResultSet are Inconsistent
error: patch failed: src/test/groovy/sql/GroovyRowResultTest.groovy:1
error: src/test/groovy/sql/GroovyRowResultTest.groovy: patch does not apply
Patch failed at 0001 GROOVY-5170: GroovyRowResult and GroovyResultSet are Inconsistent
{noformat}
I haven't had time to investigate further but applied the patch with some tweaks manually.

John and Jeffrey, if you could test the latest snapshots, that would be great.

Thanks, Paul.;;;","05/Feb/12 20:34;jwagenleitner;I tested using the latest snapshot with a project I have that uses MySQL and it's working great (am grateful to no longer have to remember the exact mixed casing of the column names).

I also did a quick test with Postgresql and that also seems to work fine (though I'm not as familiar with Postresql).;;;","06/Feb/12 02:39;paulk;Thanks John. Resolving for now. Jeffrey, if you spot any problems please reopen or create a new issue.;;;","09/Feb/12 09:27;jwadamson;My basic test work great using. Thanks.

( using local groovy build from f51879debc47c1a0088f2bbbc6ec9062406045b9 of GROOVY_1_8_6_RC );;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonOutput.toJson(object) is not returning expected results,GROOVY-5169,12815877,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,jsumners,jsumners,05/Dec/11 12:38,03/Feb/22 22:35,14/Jul/23 06:00,14/Jan/22 10:58,1.8.4,2.4.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,4.0.0,,,JSON,,,,0,properties,,,,,"Consider the attached Groovy script. It defines two classes. Each has public properties explicitly defined. When I send the resulting objects to JsonOutput.toJson(), I expect the public properties of the object to be serialized into the JSON output. This is not working as expected. The only properties that get serialized are those created via ""def propName"" and those that seem to have getter methods (this in not actually the case).

Attached is a screenshot of GroovyConsole running the attached script.",,bhatt.umang7,blackdrag,emilles,guillaume,hardion,jsumners,pschumacher,richardhightower,,,,,"eric-milles opened a new pull request #1670:
URL: https://github.com/apache/groovy/pull/1670


   https://issues.apache.org/jira/browse/GROOVY-5169
   
   This covers the private property portion of 5169.  The public field is coming separately.


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/22 19:59;githubbot;600","paulk-asert commented on a change in pull request #1670:
URL: https://github.com/apache/groovy/pull/1670#discussion_r778828461



##########
File path: subprojects/groovy-json/build.gradle
##########
@@ -21,13 +21,19 @@ plugins {
 }
 
 dependencies {
-    api rootProject  // JsonBuilder extends GroovyObjectSupport...

Review comment:
       I think it is useful to keep the comment, otherwise it is hard to track down why we use `api` here and not `implementation`. We should have a similar comment for each api dependency.




-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;05/Jan/22 13:45;githubbot;600","eric-milles commented on a change in pull request #1670:
URL: https://github.com/apache/groovy/pull/1670#discussion_r780687643



##########
File path: subprojects/groovy-json/build.gradle
##########
@@ -21,13 +21,19 @@ plugins {
 }
 
 dependencies {
-    api rootProject  // JsonBuilder extends GroovyObjectSupport...

Review comment:
       comment restored




-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jan/22 17:17;githubbot;600","eric-milles merged pull request #1670:
URL: https://github.com/apache/groovy/pull/1670


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jan/22 23:14;githubbot;600",,,,,,,,,,,,,,0,2400,,,0,2400,,GROOVY-10449,,,,,,GROOVY-10438,,,,,,,,,,,,,,,"24/Jan/13 07:39;bhatt.umang7;0001-bugfix.patch;https://issues.apache.org/jira/secure/attachment/12722379/0001-bugfix.patch","06/Jan/18 21:06;bhatt.umang7;0002_patch.txt;https://issues.apache.org/jira/secure/attachment/12904959/0002_patch.txt","05/Dec/11 12:38;jsumners;GroovyConsole_output.png;https://issues.apache.org/jira/secure/attachment/12722983/GroovyConsole_output.png","24/Jan/13 04:03;bhatt.umang7;MetaClassImpl.java;https://issues.apache.org/jira/secure/attachment/12723120/MetaClassImpl.java","24/Jan/13 03:48;blackdrag;MetaClassImpl.patch;https://issues.apache.org/jira/secure/attachment/12722655/MetaClassImpl.patch","05/Dec/11 12:38;jsumners;json_test.groovy;https://issues.apache.org/jira/secure/attachment/12722594/json_test.groovy","24/Jan/13 03:24;bhatt.umang7;screenshot.png;https://issues.apache.org/jira/secure/attachment/12722656/screenshot.png",,7.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 04 20:24:40 UTC 2022,,,,,,,,,,"0|i2btfr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Dec/11 19:59;roshandawrani;Yes. I think JsonOutput.toJson(Object) should be generally in sync with object.dump(), which it is not currently.;;;","07/Dec/11 02:21;blackdrag;@James... if you use a visibility modifier in a declaration for a property, then you actually do not declare a property, but a field only. So if you do ""public String bar"", then you don't have a bar property, but a bar field. If you do ""String bar"", then you get a bar property.;;;","07/Dec/11 02:25;roshandawrani;And a private getter makes a property?;;;","07/Dec/11 02:44;roshandawrani;Wouldn't it make sense if JsonOutput.toJson(Object) included public fields too?;;;","07/Dec/11 05:36;blackdrag;the visibility of the getter is not included in determining if something is a property or not. ;;;","07/Dec/11 05:45;guillaume;When this was initially implemented, the idea was to use properties, not public fields or anything else.
Also, I think only public properties should be used for that JSON serialization.
So according to that logic and concern, I think with your example that foo should be serialized as \{\} and bar as \{""bar"":""foo""\} -- ie. only public getters used for the serialization.;;;","07/Dec/11 06:14;roshandawrani;>> the visibility of the getter is not included in determining if something is a property or not.

Didn't mean in the usual ""property"" sense. I meant outputting a private getter in a JSON looks odd (and public fields are being ignored). As Guillaume seems to agree, only public getters should be used for JSON serialization.;;;","07/Dec/11 07:36;jsumners;From http://groovy.codehaus.org/Groovy+Beans -- ""In Groovy, fields and properties have been merged so that they act and look the same.""

Given that statement, I still think these objects should serialize as I outlined.;;;","14/Oct/12 13:18;bhatt.umang7;probably(i am not sure) we need to do changes in MetaClassImpl.java.

I have made some changes and its working with me(its giving output as Mr. James said).

what am i supposed to do now? to whom do i need to submit the change for review ?

how do i run the test cases ? to whom i need to send the patch ?;;;","14/Oct/12 15:43;blackdrag;you can attach the patch here. It would help to check if the test can be applied to the code base without any test failing.;;;","18/Jan/13 14:24;pschumacher;@umang bhatt:
Could you attach your patch?;;;","24/Jan/13 03:24;bhatt.umang7;I am a beginner so please review my code. Also i have not run any tests yet. 

I have changed  public List<MetaProperty> getProperties() method. 

I have tried fixing the issue. The order is a little different than what is desired.
I can change the behavior as you say(eg include the value that we get from the getter/accesor method).;;;","24/Jan/13 03:27;bhatt.umang7;I have attached the file that contains changes. I have also attached a screenshot.;;;","24/Jan/13 03:48;blackdrag;Please always create a minimal patch file, just attaching the new file does not help much in judging if the change should be done or not. I created the patch for you, plus made some formatting changes to minimize the patch;;;","24/Jan/13 04:03;bhatt.umang7;patch;;;","24/Jan/13 04:04;blackdrag;Part of the patch is puzzling me before we had (!setter && !getter) to filter out properties that are in fact fields and thus have neither getter or setter. What is kept are read- or write-only properties. With your (!setter || !getter) those are removed as well. I can understand from the JSON perspective, but for getProperties this looks wrong. 

Next is the element.getModifiers() != 1, which seems to be there to filter out all non public fields. Since we filtered out all fields before already, thus is surely ok in principle, but you don't do something like that for MetaBeanProperties. They can be protected or package private as well imho. Why should getProperties show a protected MetaBeanProperty, but not a protected CachedField?

My Conclusion:
Changing getProperties to return many more is a potentially breaking change, so it surely wouldn't go into 1.8.x or 2.0.x. I think for 2.1.x it is too late. We have to investigate though how that method is used before we can say that it goes into 2.2, otherwise the next possible version would be 3.0 only. I would suggest finding another way to tackle the problem and keep the changes to the json classes itself if possible.
;;;","24/Jan/13 04:09;bhatt.umang7;ok.
1. I would try to make changes in json related class, should it be fine ?
2. Do i need to change the behavior(output) in any way ? Or this is fine ?

;;;","24/Jan/13 05:00;guillaume;First of all, before doing any further change to your patch, let's agree on what should be serialized or not.
* public properties: Yes (ie. both final and non final)
* public fields: Yes (both final and non final)
* static properties, static fields, whether public, protected or private: No;;;","24/Jan/13 07:24;bhatt.umang7;here is a new patch that does the same thing by adding a method in JsonOutput class;;;","24/Jan/13 08:07;blackdrag;hmm... CachedField is only an internal representation for fields. That means the patch should include only fields that are public. But the usual property is one with getter and setter and private field. In the json_test.groovy attached above this would imho mean that Bar#bar is excluded since it is a property backed by a private field. 

Also there is the question to answer if a property that consists only of a getter or setter and no field should be included. And dynamically added properties are up to discussion as well I think.;;;","24/Jan/13 09:45;jsumners;""Also there is the question to answer if a property that consists only of a getter or setter and no field should be included. And dynamically added properties are up to discussion as well I think.""

When I originally filed the bug, and this still hold true for me, I assumed that the instance of the object would be serialized in such a fashion that it could be recreated from the JSON. That would imply dynamically added properties should be included in the serialization. Otherwise, what are you serializing?;;;","24/Jan/13 12:45;blackdrag;but if you want this to recreate the object afterwards, then read-only-properties are going to be a problem for you - plus dynamically added properties will only be available if they have been added on the deserialization side as well.;;;","24/Jan/13 13:44;jsumners;Well, since Groovy doesn't deserialize JSON to an object anyway (that I can tell) that's a moot point. It would be left up to the deserializer as to how to handle that.;;;","24/Jan/13 13:49;jsumners;By the way, back when I filed this bug I ended up resorting to some ridiculousness to get around it -- http://stackoverflow.com/questions/7853809/iterating-an-objects-own-properties-in-groovy;;;","21/Jul/14 14:58;richardhightower;I am lost in the comment stream. What works? What is broken?;;;","06/Jan/18 21:06;bhatt.umang7;Although years have passed by, trying this one more time. Please bear with me. Attaching one more diff with recent changes. Can you please help me make it correct (0002_patch.txt)? The code now does not affect everything else, change is local to Json.

Thank you so much for your help in advance.;;;","04/Jan/22 20:24;emilles;https://github.com/apache/groovy/pull/1670/commits/f6ab340292465749edac4dec377fe526aded8d28
https://github.com/apache/groovy/pull/1670/commits/8811fcdbdf6a11c43f7c09a81105a2227f9fddc2;;;",,,,,,,,,,,,,,,,,,
Static type checker should not complain on methods w/ implicit object return type when last expression is void,GROOVY-5168,12816005,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,guillaume,guillaume,05/Dec/11 09:43,24/Dec/11 03:08,14/Jul/23 06:00,05/Dec/11 10:41,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"For the script below, when I annotate a method with @TypeChecked, and it has an implicit Object return type (no type, no def, nothing), the checker will complain because the last expression is actually a void statement. This kind of methods, just like plain Groovy, should be valid and return null.

{code}
import groovy.transform.TypeChecked

@TypeChecked m() {
    println ""hello""
}

m()
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-05 09:43:39.0,,,,,,,,,,"0|i2csvb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GDK date methods not recognized by the static type checker,GROOVY-5167,12815998,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,guillaume,guillaume,05/Dec/11 09:36,24/Dec/11 03:08,14/Jul/23 06:00,05/Dec/11 10:09,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"I was playing with the following snippet:
{code}
import groovy.transform.TypeChecked
@TypeChecked void m() {
    def s = ""1234""
    println s.toInteger()
    s = 1234
    println s * 3
    s = new Date()
    println s.year
    println s.format(""yyyyMMdd"")
}
m()
{code}
And the static type checker was complaining on the s.format() call.
The format() method is part of DateGroovyMethods, not directly DefaultGroovyMethods, for modularity sake, and hence it wasn't recognized.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-05 09:36:58.0,,,,,,,,,,"0|i2c7on:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checker should handle closure shared variables properly,GROOVY-5166,12815981,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,05/Dec/11 06:54,21/Jul/22 21:23,14/Jul/23 06:00,05/Dec/11 10:55,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"See discussion at http://groovy.329449.n5.nabble.com/Closure-shared-variables-and-flow-typing-tp5041259p5041259.html

Copy of original post:


Yesterday, Guillaume & I had a face-to-face working session in Paris. One of our discussion subjects was centered on static type checking, and especially a corner case with closure shared variables. In this email, I will expose the problem and the solutions we had in mind. Let's start with a sample code:

{code}
def x = '123'
def cl = { x = new Date() }
x.toInteger()
{code}

The current implementation of the static type checked is totally wrong in that case (this is a bug I know about for long). Especially, it complains with the following error message:

Cannot find matching method java.util.Date#toInteger()

This is because the closure is visited before the call to x.toInteger() so the inferred type of x is changed although the closure is *not* called. This example illustrates the case of a closure shared variable, ""x"", and flow typing. In flow typing, we want this not to throw an error:

{code}
def x = new Date()
x = '123'
x.toInteger() // should work because the compiler can infer that x is of string type at this point
{code}

Now, when ""x"" is closure shared, we are facing a dangerous situation. Back to our first example:

{code}
def x = '123'
def cl = { x = new Date() }
x.toInteger()
{code}

The workaround seems to be easy: ""hey, we don't call the closure, you must know that x is still a string at line 3!"". If we do that, then we must also keep track of closure calls which may alter the shared variable:

{code}
def x = '123'
def cl = { x = new Date() }
cl()
x.toInteger() // now, this must throw an error because x has changed type !
{code}

In that case, this is a very problematic issue. Tracking shared variables is doable, but tracking closure calls depends on runtime execution and seems impossible. For example, we could have nastier code like this:

{code}
def x = '123'
def cl = { foo -> x = new Date() }
def cl2 = cl.curry('If you ever visit Nantes, we could have a talk')
cl2()
x.toInteger() // now, this must throw an error because x has changed type !
{code}

or even more problematic :

{code}
class A {
   Closure action
   def foo() { action() }
}

def x = '123'
def cl = { x = new Date() }
def a = new A(action:cl)
a.foo()
x.toInteger() // now, this must throw an error because x has changed type !
{code}

Basically, the latter example shows it is rather impossible to track closure calls implying shared variables at compile time. The first solution is to disable flow typing. We don't really like that idea, as it is definitely not in the ""Groovy"" spirit. Though flow typing may be seen as bad style, we still think things like this are groovier:

{code}
class A {}
class B extends A { void foo() {} }

A a = new B()
a.foo() // should be allowed in static mode
{code}

The first option, then, is not the one we want to promote. The second option is to go ""Java style"", and disallow closure shared variables, meaning each variable used in a closure should be final. The code you saw would therefore be invalid. But we don't like this idea because it would remove a large part of the interest of using ""lightweight"" closures.

The 3rd solution, first suggested by Guillaume, was to ignore tracking of closure execution, and let the program fail at runtime. For example, this would fail with a class cast exception:

{code}
def x = '123'
def cl = { x = new Date() }
cl()
x.toInteger()
{code}

But it would fail *at runtime*. Dynamic groovy would fail with a ""No signature of method Date#toInteger"". I don't really like this option for two reasons:
    1. it beats the concept of static type checking, which is IMHO interesting if errors are found at compile time rather than runtime
    2. it is conceptually wrong

After a short brainstorming session, where we discussed about possible warnings or disallowing assignments of shared variables in closures, I suggested an alternative option, which requires some trickery in the type checker, but seems conceptually correct: throwing an error on ""x.toInteger()"", knowing that if you assign a shared variable in a closure with an ""incompatible"" type, this is not bad style, but very bad style. The question is how can we throw an error here, without throwing an error when the variable is *not* closure shared (that is to say in the classical flow typing mode). My idea is to use the ""lowest upper bound"" algorithm to compute, for closure shared variables, the lowest common type of all assignments of a closure shared variables. Direct method calls (I mean, without explicit casts), in that case, should only be allowed on methods belonging to that common super type. This means that in that case:

{code}
def x = '123'
def cl = { x = new Date() }
cl()
x.toInteger()
{code}

We know that 'x' is assigned a string and a date. We compute the LUB of those types. Then method calls on 'x' would be checked against this type. Here, the LUB is an Object implementing Serializable. Serializable doesn't have a ""toInteger"" method, so ""toInteger"" would fail here. Guillaume, then, came with another example:

{code}
def x = '123'
def cl = { x = new Date() }
cl()
x = '456'
x.toInteger()
{code}

Using our algorithm, 'x.toInteger()' would throw a compilation error, so Guillaume said this would violate the principle of least surprise. At first, I thought we could be smarter, letting this pass if no method call was made between an assignment and the method call on the shared variable. For example, this would pass:

{code}
def x = '123'
def cl = { x = new Date() }
cl()
x = '456'
x.toInteger()
{code}

But this would not:

{code}
def x = '123'
def cl = { x = new Date() }
cl()
x = '456'
logger.debug('info')
x.toInteger() // would fail, because we don't know what logger.debug does. Potentially, it could lead to using the ""cl"" closure. If you as a human know that it would not, the compiler cannot know, so it must invalidate the call
{code}

However, Guillaume came with an excellent counter-example. What if ""x"" is used in another thread? For example :

{code}
def x = '123'
Thread.start { x = new Date() }
x = '456'
x.toInteger()
{code}

There is absolutely no guarantee that when ""x.toInteger()"" will be called, ""x"" will be of type 'String'. There are chances that it will be of type Date, depending on when the assignement is executed... We all agree that using a shared variable in this use case is a very, ugly, fool code style, but it demonstrates that at compile time, we cannot make any better hint that ""x"" would be of the LUB type.

This is why I think the solution of throwing an error systematically when such a method call is found is the right way to go. This would allow the classical ""flow typing"" to work. This would also encourage good style because using a shared variable to store whatever you want is not a good idea.

Eventually, we must think about this use case :

{code}
def x = 1
def cl = { x.toInteger() }
x = '123'
cl()
{code}

This is a similar problem. Here, to be able to statically check the closure, we must know the type of the shared variable. There is no assignment in the closure, but still, we can statically check it if we use the very same algorithm. A call to "".toInteger()"" would only be allowed if we know that this method belongs to all types that have been assigned to x. This won't be fun to implement, but I still think this is the most promising way to do this.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10700,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 05 07:20:12 UTC 2011,,,,,,,,,,"0|i2c4pr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Dec/11 07:20;melix;Fixed on {{grumpy}} branch, for tests before merge.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ASTNode#removeNodeMetaData may nullify metaData field,GROOVY-5165,12815977,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,05/Dec/11 03:22,24/Dec/11 03:08,14/Jul/23 06:00,05/Dec/11 03:26,1.8.4,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,,,,,0,,,,,,"The {{org.codehaus.groovy.ast.ASTNode#removeNodeMetaData}} method nullifies the {{metadata}} field if the map is empty after removal. However, the map is not supposed to be null, which will cause a NPE if you try to add metadata afterwards.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-05 03:22:42.0,,,,,,,,,,"0|i2bxmv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
IncompatibleClassChangeError when running groovysh,GROOVY-5163,12815996,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,jwb,jwb,02/Dec/11 19:46,12/Feb/12 04:03,14/Jul/23 06:00,31/Jan/12 09:51,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,Groovysh,,,,1,,,,,,"Wondering if this bug is new in Groovy 1.8.4; it seems it work better in 1.8.2.

The problem is that groovysh is throwing IncompatibleClassChangeError in a few cases:
import com.not.Found // import that doesn't resolve to class
show // command doesn't run at all
purge // command doesn't run at all

Groovy 1.8.4 appears to be working well, otherwise.

Please let me know if you need further info. It seems reproducible, here.

Thanks!
John
",Mac Java 6,jwb,lhotari,ssozonoff,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 18 20:51:58 UTC 2012,,,,,,,,,,"0|i2c40v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Dec/11 12:28;ssozonoff;Hi,

I would just like to confirm that I am seeing the same.

1.8.2 seems to work.

Thanks,
Serge;;;","17/Jan/12 23:46;jwagenleitner;I think this is related to GROOVY-4838.  Jdk 7 added a protected constructor to the {{Exception}} class.  For Groovy 1.8.4, it works for me if I use jdk7 to run groovysh but I get the {{IncompatibleClassChangeError}} if I run with jdk6.  

{code}
~/java/groovy-1.8.4$ bin/groovysh 
Groovy Shell (1.8.4, JVM: 1.7.0_02)
Type 'help' or '\h' for help.
-----------------------------------------------------------------------------------------------------------------------
groovy:000> import com.not.Found
ERROR org.codehaus.groovy.tools.shell.CommandException:
Invalid import definition: 'import com.not.Found'; reason: startup failed:
script1326865167473423932601.groovy: 1: unable to resolve class com.not.Found
 @ line 1, column 1.
   import com.not.Found
   ^

1 error

        at java_lang_Runnable$run.call (Unknown Source)
groovy:000> 
{code}

My guess this is happening because {{org.codehaus.groovy.tools.shell.CommandException}} is a Groovy class and v1.8.4 was compiled with jdk7.

If I build from source using jdk7, then I get the {{IncompatibleClassChangeError}} when running groovysh with jdk6.  Same occurs when building using jdk6 and running with jdk7.;;;","18/Jan/12 20:51;jwagenleitner;I have added a github pull request for this issue, https://github.com/groovy/groovy-core/pull/16.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonOutput fails with uninformative NPE when map has null key,GROOVY-5162,12816003,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,jwb,jwb,02/Dec/11 11:58,24/Dec/11 03:07,14/Jul/23 06:00,05/Dec/11 05:17,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,groovy-jdk,,,,0,json,,,,,"{code}
import groovy.json.JsonOutput

def group = [1, 2, null].countBy{it}
def result = use (JsonOutput) {
    group.toJson()
}
{code}
throws NullPointerException due to the presence of a null a as key to map entry.
The stacktrace is rather unhelpful, so it would be nice if the JsonOutput would translate this to indicate a problem with the map content.
http://groovyconsole.appspot.com/script/601001",Mac Java 6,jwb,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 05 05:22:55 UTC 2011,,,,,,,,,,"0|i2byvz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Dec/11 00:19;roshandawrani;Just tried to see how Jackson JSON mapper handles the null key in a map and that rejects it saying ""Null key for a Map not allowed in Json""

Is it ok to have the same behavior in JsonOutput and reject the null key in a map?;;;","05/Dec/11 00:34;jwb;An IllegalArgumentException would be appropriate. It's a minor issue: the NPE is not entirely inappropriate, but it is certainly unhelpful.;;;","05/Dec/11 00:36;roshandawrani;Correct, NPE is not so good. I just wanted to check if are in sync on rejecting null key in the map.;;;","05/Dec/11 01:43;guillaume;According to the JSON spec, null is indeed not allowed as a key of an object.
So JsonOutput should reject it.

You want to have a stab at this issue Roshan?;;;","05/Dec/11 01:54;roshandawrani;Yes Guillaume, I want to.;;;","05/Dec/11 05:22;guillaume;Thank you Roshan!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"MetaObjectProtocol.getMetaMethod doc for ""args"" is ambiguous",GROOVY-5161,12815959,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,roshandawrani,aled.sage@gmail.com,aled.sage@gmail.com,02/Dec/11 11:31,24/Dec/11 03:07,14/Jul/23 06:00,02/Dec/11 21:10,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,,,,,0,,,,,,"http://groovy.codehaus.org/api/groovy/lang/MetaObjectProtocol.html#getMetaMethod(java.lang.String, java.lang.Object[])
---
The args parameter is described as ""The argument types"", but the method definition says ""Retrieves an instance MetaMethod for the given name and argument values, using the types of the argument values to establish the chosen MetaMethod"".

For the former, I'd expect to pass in something like [String.class]; from the latter I'd expect to have to pass in [""""]

---
The code actually works with both!
Looks like it eventually calls MetaClassHelper.castArgumentsToClassArray, which uses the arg if it's a Class, or uses argType.getClass() otherwise.

If this is guaranteed to be the case in future version, then I'd suggest the wording:
    @param args The argument types: can be the Class objects, or example argument values for inferring the types
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 02 21:10:50 UTC 2011,,,,,,,,,,"0|i2btt3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Dec/11 21:10;roshandawrani;Changed to:
{noformat}
* @param args Array containing - 1) the argument values (using which their types are then inferred), or 2) the corresponding argument types
{noformat};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Assignments in if/else/for/while/ternary are not type checked properly,GROOVY-5160,12815851,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,02/Dec/11 08:49,24/Dec/11 03:08,14/Jul/23 06:00,02/Dec/11 09:46,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"The following code will pass, though the return type of x after the if/else statement may differ:

{code}
def x
if (cond) {
  x = new Date()
} else {
  x = 123
}
x.toInteger()
{code}

In a similar manner:
{code}
def x = '123'
for (int i=0; i<5;i++) { x = new HashSet() }
x.toInteger()
{code}

{code}
def x = '123'
while (false) { x = new HashSet() }
x.toInteger()
{code}

{code}
def x = '123'
def cond = false
cond?(x = new HashSet()):3
x.toInteger()
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-12-02 08:49:20.0,,,,,,,,,,"0|i2c6br:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Encoding issue with groovy.xml.XmlUtil.serialize(),GROOVY-5158,12816004,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,citron,citron,01/Dec/11 17:40,13/May/12 03:30,14/Jul/23 06:00,12/Feb/12 03:52,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,,,,,1,,,,,,"http://groovy.329449.n5.nabble.com/Encoding-issue-with-groovy-xml-XmlUtil-serialize-td5038513.html
 

I think it should be possible to put an 'ü' charter in the xml element. 


def xml =""""""<?xml version=""1.0"" encoding=""UTF-8""?> 
<Schlüssel>
 text content 
</Schlüssel>"""""" 

groovy.util.slurpersupport.GPathResult s  = new XmlSlurper().parseText(xml) 

println groovy.xml.XmlUtil.serialize(s) // results in empty xml, why? 

----- OUTPUT 
<?xml version=""1.0"" encoding=""UTF-8""?> 



WORKAROUND
def outxml = new groovy.xml.StreamingMarkupBuilder().with {
  encoding = 'UTF-8'
  '<?xml version=""1.0"" encoding=""UTF-8""?>\n' + bindNode( s )
}
println outxml",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Feb 12 03:52:27 UTC 2012,,,,,,,,,,"0|i2ch53:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Feb/12 18:38;weitzj;GET fix from pull request
https://github.com/groovy/groovy-core/pull/23;;;","12/Feb/12 03:52;paulk;Should be fixed now. Jan, thanks for the pull request. I used the idea but not the implementation - more details on github. Anders, thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Strange method name in the StaticTypeCheckingVisitor class,GROOVY-5156,12815971,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,melix,vns,vns,30/Nov/11 12:05,24/Dec/11 03:08,14/Jul/23 06:00,01/Dec/11 04:23,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,,,,,0,,,,,,"Is the method name valid ?
{color:red}
chooseBestBethod
{color}

May be {color:blue}
chooseBestMethod
{color}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-11-30 12:05:05.0,,,,,,,,,,"0|i2bp3r:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Invalid Static Type Checking report on a method call with type parameters,GROOVY-5154,12815992,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,vns,vns,30/Nov/11 08:09,24/Dec/11 03:08,14/Jul/23 06:00,01/Dec/11 04:22,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,,,,,0,,,,,,"The following code produces static type checking error:

{code}
import groovy.transform.*

@TypeChecked 
class Foo {
    def say() {
        FooWithGenerics f
        FooBound fb
        f.say(fb)
    }
}

class FooWithGenerics {
    def <T extends FooBound> void say(T p) {
    }
}
class FooBound {
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 30 11:50:11 UTC 2011,,,,,,,,,,"0|i2crgv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Nov/11 08:38;roshandawrani;Added code formatting tags.;;;","30/Nov/11 11:50;vns;To continue with my work, I slightly modified method
StaticTypeCheckingVisitor.parameterizeArguments(). 

{code}
parameterizedCN.setGenericsPlaceHolder(paramType.isGenericsPlaceHolder()); 
{code}
for each variable parameterizedCN appearance.

Then modified StaticTypeCheckingSupportMy.isAssignableTo method:
{code}
................
................   
if (OBJECT_TYPE.equals(toBeAssignedTo)) return true;
if (toBeAssignedTo.isUsingGenerics()) {
  if ( toBeAssignedTo.isGenericsPlaceHolder() &&   
      toBeAssignedTo.getGenericsTypes() != null) {
      GenericsType gt = toBeAssignedTo.getGenericsTypes()[0];
      return gt.isCompatibleWith(type);
  }
  // perform additional check on generics
  // ? extends toBeAssignedTo
  GenericsType gt = GenericsUtils.buildWildcardType(toBeAssignedTo);
  return gt.isCompatibleWith(type);
}
................
................   

{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
object instanceof MyObject[] causes ClassDefNotFound exception within Closure,GROOVY-5152,12815961,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,teammcs,teammcs,29/Nov/11 10:35,24/Dec/11 03:08,14/Jul/23 06:00,30/Nov/11 02:49,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.5,2.0-beta-2,,,,,0,,,,,,"The following code causes ClassDefNotFound exception:
{code}
public Map<String, Object> toMap() {
        Map<String, Object> params = getPropertiesWithoutClassData()
        Map<String, Object> params = new HashMap<String,Object>();
        
        params.each { 
           if(it.value instanceof MyObject[]){ 
params.add(it.key, it.value)
 }else{
params.add(""test"",""test"")
           } 
        }

   return params
}
{code}
The equivalent java code works normally:
{code}
public Map<String, Object> toMap() {
        Map<String, Object> params = getPropertiesWithoutClassData()
        Map<String, Object> params = new HashMap<String,Object>();

for(String param : params)
{
 if(params.get(param) instanceof MyObject[]){ 
params.add(""works"", ""works"")
 }else{
params.add(""test"",""test"")
           } 
}

   return params
}
{code} 
Running MacOSX 10.6.6",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 30 02:49:59 UTC 2011,,,,,,,,,,"0|i2csuv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Nov/11 11:18;melix;Formatting tags;;;","29/Nov/11 11:19;melix;Can you attach a complete script which demonstrates the problem? Thanks!;;;","29/Nov/11 23:20;roshandawrani;The following fails with ""java.lang.ClassFormatError: Illegal class name ""MyObject[]"" in class file"" on master.

{code}
class MyObject{}
assert !("""" instanceof MyObject[])
{code};;;","30/Nov/11 02:49;melix;Fixed. Thanks for the example Roshan.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checker should allow casts to character from single char strings,GROOVY-5148,12815814,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,25/Nov/11 11:52,24/Dec/11 03:08,14/Jul/23 06:00,25/Nov/11 12:49,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"The following code is not allowed by the static type checker:
{code}
char c = 'c'
{code}

nor this one:


{code}
Character c = 'c'
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-11-25 11:52:01.0,,,,,,,,,,"0|i2by8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checker marks null assignments as invalid,GROOVY-5147,12815813,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,melix,melix,25/Nov/11 11:50,24/Dec/11 03:08,14/Jul/23 06:00,25/Nov/11 12:49,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"The following code raises a compilation error:
{code}
@groovy.transform.TypeChecked
void test() {
   Integer o = null
}
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-11-25 11:50:38.0,,,,,,,,,,"0|i2c0u7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Return type inference doesn't handle closures properly,GROOVY-5145,12815990,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,24/Nov/11 09:59,24/Dec/11 03:08,14/Jul/23 06:00,24/Nov/11 10:05,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"The following code :
{code}
[1,2,3].collect { it.toString() }
{code}
has an inferred type of {{List<Closure>}} instead of {{List<String>}}.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-11-24 09:59:07.0,,,,,,,,,,"0|i2bppr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper does not handle backslashes at the end of a String,GROOVY-5144,12815827,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,gabrielsz,gabrielsz,24/Nov/11 08:25,12/Feb/12 04:03,14/Jul/23 06:00,15/Jan/12 10:43,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,JSON,,,,2,,,,,,"Whenever I try to deserialize a JSON Object with a String that ends with a correctly escaped backslash ""\\"", it throws an exception:

Caught: groovy.json.JsonException: Expected a value on line: 1, column: 25.
But got an unterminated object.
groovy.json.JsonException: Expected a value on line: 1, column: 25.
But got an unterminated object.
	at JsonSlurperBug.run(JsonSlurperBug.groovy:9)

I've attached a small repro.","Ubuntu Linux 11.10 32-bit, 

OpenJDK Runtime Environment (IcedTea6 1.11pre) (6b23~pre11-0ubuntu1.11.10)
OpenJDK Server VM (build 20.0-b11, mixed mode)",enorris,gabrielsz,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Nov/11 08:25;gabrielsz;JsonSlurperBug.groovy;https://issues.apache.org/jira/secure/attachment/12722904/JsonSlurperBug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jan 15 10:43:53 UTC 2012,,,,,,,,,,"0|i2bpwn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Dec/11 05:41;enorris;This is worse than it appears - if you have an element after the offending escaped backslash, the parseText statement hangs (indefinitely?  I've waited 20 minutes)
works: {""InstallLocation"":""C:\\WINDOWS\\Microsoft.NET\\Framework\\v3.5"",""a"":""b""}
throws exception: {""InstallLocation"":""C:\\WINDOWS\\Microsoft.NET\\Framework\\v3.5\\""}
hangs: {""InstallLocation"":""C:\\WINDOWS\\Microsoft.NET\\Framework\\v3.5\\"",""a"":""b""}

Windows 7 x64, groovy-all-1.8.4, Java 1.6.0.24, IntelliJ Idea 10.5.4;;;","15/Jan/12 09:58;jwagenleitner;Problem appears to be [this line in JsonLexer#nextToken|https://github.com/groovy/groovy-core/blob/aeb689e36b77d62517bb34065eaec9221f082d55/src/main/groovy/json/JsonLexer.java#L113] that determines when the string is terminated by a quote.  Any backslash (current -2) appearing before a quote (current char) causes it to keep reading rather than terminating and returning the token.  When it is able to read to the next quote that does not have a preceeding backslash I think it then hangs when the pattern match is applied by {{possibleTokenType.matching(currentContent.toString())}}.

I have opened a pull request (https://github.com/groovy/groovy-core/pull/14) on github for this issue.;;;","15/Jan/12 10:43;guillaume;Thanks for the pull request!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
collectMany should not use createSimilarCollection and instead behave like collect,GROOVY-5142,12818414,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,24/Nov/11 06:29,07/Apr/15 19:07,14/Jul/23 06:00,24/Nov/11 21:13,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 24 21:13:27 UTC 2011,,,,,,,,,,"0|i2cal3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Nov/11 21:13;paulk;changed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"The static type checker may be unable to choose between two ""identical"" methods from DGM",GROOVY-5141,12815812,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,24/Nov/11 05:48,24/Dec/11 03:08,14/Jul/23 06:00,24/Nov/11 05:51,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"The following code:
{code}
[1,2,3].collect { it.toString() }
{code}

causes the static type checker to fail with a cryptic message :
{code}Reference to method is ambiguous. Cannot choose between [MethodNode@481404130[java.util.List collect(groovy.lang.Closure)], MethodNode@1289411108[java.util.List collect(groovy.lang.Closure)]]{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-11-24 05:48:47.0,,,,,,,,,,"0|i2c4tz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ASTTransformationCustomizer uses wrong classloader to find transformer class from annotation,GROOVY-5140,12818126,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,kdvolder,kdvolder,23/Nov/11 18:01,24/Dec/11 03:08,14/Jul/23 06:00,24/Nov/11 03:10,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,Compiler,,,,0,,,,,,"ASTTransformationCustomizer.

In this method:
{code}
    private static Class<ASTTransformation> findASTTranformationClass(Class<? extends Annotation> anAnnotationClass) {
        final GroovyASTTransformationClass annotation = anAnnotationClass.getAnnotation(GroovyASTTransformationClass)
        if (annotation==null) throw new IllegalArgumentException(""Provided class doesn't look like an AST @interface"")

        Class[] classes = annotation.classes()
        String[] classesAsStrings = annotation.value()
        if (classes.length+classesAsStrings.length>1) {
            throw new IllegalArgumentException(""AST transformation customizer doesn't support AST transforms with multiple classes"")
        }
        return classes?classes[0]:Class.forName(classesAsStrings[0])
    }
{code}

{{Class.forName}} has no classloader, which means it using the loader associated with {{ASTTransformationCustomizer}}, but when I use it from inside STS that loader is associated with the Eclipse/STS infrastructure and the transform isn't on its classpath (since it is part of the compiled project, not the compiler infrastructure).

It would seem more logical/correct if {{Class.forName}} here should use an explicit classloader and pass it the classloader from the annotation instead. After all, I think the annotation class should refer to the transformer class, so the annotation's classloader should be able to find the transform class.

On the other hand, there doesn't seem to be a logical connection between {{ASTTransformationCustomizer}} and some random transform class attached to a random annotation that guarantees the class can be found by the {{ASTTransformationCustomizer}}'s classloader.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 23 19:58:44 UTC 2011,,,,,,,,,,"0|i2bwlb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Nov/11 19:58;paulk;add code tags;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MockFor.getInstance() fails for abstract classes,GROOVY-5137,12815930,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,roadrunner,roadrunner,22/Nov/11 21:01,24/Dec/11 03:08,14/Jul/23 06:00,23/Nov/11 16:36,1.8.2,1.8.3,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,class generator,mocks and stubs,,,0,,,,,,"Trying to mock or stub an abstract class fails as of groovy 1.8.2 and later (this
works under 1.7.10, 1.8.0, and 1.8.1). This code

{code:java}
import groovy.mock.interceptor.MockFor

MockFor.getInstance(URLConnection, new URL('http://foo'))
{code}

results in

{noformat}
Caught: BUG! exception in phase 'class generation' in source unit 'Script1.groovy' SpreadExpression should not be visited here
BUG! exception in phase 'class generation' in source unit 'Script1.groovy' SpreadExpression should not be visited here
{noformat}

The breakage was possibly introduced by the fix for GROOVY-4968.

Also note that this may be related to GROOVY-4255, though I'd expect MockFor and StubFor
to work irrespective of the status of that bug.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 23 11:17:48 UTC 2011,,,,,,,,,,"0|i2ct87:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Nov/11 23:37;paulk;The generated source for the underlying proxy object which works on 1.8.1 but fails from 1.8.2 is the following:
{code}
class URLConnection_groovyProxy extends java.net.URLConnection {
    private closureMap
    URLConnection_groovyProxy(map, args) {
        super(*args)
        this.closureMap = map
    }
    void connect() { throw new UnsupportedOperationException()    }
}
new URLConnection_groovyProxy(map, constructorArgs)
{code};;;","23/Nov/11 11:17;melix;Bisecting leads to the following commit:
{code}
~/DEV/PROJECTS/OPENSOURCE/GROOVY/groovy-git/groovy-git (git::(no branch)) $ git bisect good
71feea7cb3adb91c7eaae766932a8980947c208d is the first bad commit
commit 71feea7cb3adb91c7eaae766932a8980947c208d
Author: Jochen <blackdrag@gmx.org>
Date:   Mon Aug 29 17:53:08 2011 +0200

    GROOVY-4559: enable more direct super constructor calls
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Documentation: Error for one of the examples from JN0025-Starting,GROOVY-5130,12815954,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,defascat,defascat,18/Nov/11 09:03,12/Feb/12 04:03,14/Jul/23 06:00,05/Feb/12 06:07,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,GroovyDoc,,,,0,Documentation,,,,,"One of the examples from http://groovy.codehaus.org/JN0025-Starting is incorrect.

def x= ['a', 'b', 'c'] as Integer[] //convert each item in list to an Integer
assert x[0] == 97 && x[1] == 98 && x[2] == 99 //access each element individually

It causes java.lang.NumberFormatException: For input string: ""a""

There's also a related ticket already: GROOVY-4602","Fedora Linux 15, JDK 1.6",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Feb 05 06:07:28 UTC 2012,,,,,,,,,,"0|i2crvr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Feb/12 14:23;jwagenleitner;I updated the wiki page example and tested with 1.7 and 1.8.;;;","05/Feb/12 06:07;paulk;Documentation fixed by John. Thanks to all involved!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.json.JsonSlurper failes to parse decimal numbers correctly,GROOVY-5129,12815974,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,jonny,jonny,18/Nov/11 05:36,24/Dec/11 03:08,14/Jul/23 06:00,19/Nov/11 07:51,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,JSON,,,,0,decimal,float,json,,,"{code:title=Test.groovy|borderStyle=solid}
slurper = new groovy.json.JsonSlurper()
assert slurper.parseText('{""number"": 123456.123456789}') == [number: 123456.123456789]
{code}
{code:title=Output}
assert slurper.parseText('{""number"": 123456.123456789}') == [number: 123456.123456789]
       |       |                                         |
       |       [number:123456.125]                       false
       groovy.json.JsonSlurper@11346f77
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-11-18 05:36:56.0,,,,,,,,,,"0|i2bylz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Assignement to interface is wrongly marked as an error,GROOVY-5127,12815925,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,15/Nov/11 10:47,24/Dec/11 03:08,14/Jul/23 06:00,29/Nov/11 04:42,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"The following code throws an incompatible assignement type error, though the RHS implements the interface shown on the LHS.

{code}
Serializable ser = 'String'
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-11-15 10:47:38.0,,,,,,,,,,"0|i2c4nb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Arrays.asList(2L,2L) returns incorrect inferred generic type",GROOVY-5126,12815879,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,15/Nov/11 10:14,24/Dec/11 03:08,14/Jul/23 06:00,29/Nov/11 04:42,2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-2,,,Static Type Checker,,,,0,,,,,,"The inferred return type for {{Arrays.asList(2L,2L)}} is {{List<Long>}} but should be {{List<? extends Long>}}. If not, then the following code will fail, though it is valid:

{code}
Set<Number> s4 = new HashSet<Number>(Arrays.asList(0L,0L))
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-11-15 10:14:29.0,,,,,,,,,,"0|i2brn3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyScriptEngine load from  jarURL fail,GROOVY-5125,12815793,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,wonder365,wonder365,15/Nov/11 08:09,11/Sep/12 01:15,14/Jul/23 06:00,14/Aug/12 06:51,1.8.0,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.8,2.0.2,,GroovyScriptEngine,,,,0,,,,,,"GroovyScriptEngine loadScriptByName from jarURL, first time is ok, second time fail, GroovyScriptEngine attempts to load from a fileURL.
For fix this, change this:
{code}
String path = conn.getURL().getPath();
{code}
to
{code}
String path = conn.getURL().toString();
{code}",,blackdrag,mmayer,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 14 06:51:55 UTC 2012,,,,,,,,,,"0|i2cs67:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Dec/11 15:01;paulk;I presume you are talking about {{GroovyScriptEngine#loadScriptByName}} around about line 449?

Can you describe in a little more detail an example that shows the failure?

Thanks.;;;","21/Dec/11 02:22;wonder365;for management, we put groovy scripts in jars. but when gse.loadScriptByName these scripts , failed.
the code like this:
{code}
List<URL> GSEROOTS = new ArrayList<URL>();
URL jarURL = GroovyScriptUtils.class.getClassLoader().getResource(""com/abc/bcd/scripts/"");
GSEROOTS.add(jarURL);
URL fileUrl = new File(""c:\scripts"").toURI().toURL();
GSEROOTS.add(fileUrl);
gse = new GroovyScriptEngine(urlroots);
{code}
then:
{code}
gse.loadScriptByName('a.groovy') //a.groovy in a jar ""com/abc/bcd/scripts/""
{code}
this is ok, do this again:
{code}
gse.loadScriptByName('a.groovy')
{code}
failed, I traced the gse code, gse seek a.groovy in a path not in a jar. because ""String path = conn.getURL().getPath();"" only return a path, the protocol is lost.

;;;","16/Feb/12 07:39;blackdrag;lwh, I was not able to reproduce the issue with your example. That your test can't be right is also shown by GSE not having a list based constructor. Could you please give a test case that fails at least under 1.8.6 and master?;;;","24/Feb/12 23:02;wonder365;I've tested in 1.8.6, it fails. the code is.

{code}
import groovy.lang.Binding;
import groovy.util.GroovyScriptEngine;
import groovy.util.ResourceException;
import groovy.util.ScriptException;

import java.net.MalformedURLException;
import java.net.URL;

public class TestGSE {

	public static void main(String[] args) throws ResourceException,
			ScriptException, InterruptedException, MalformedURLException {

		URL jarURL = TestGSE.class.getClassLoader().getResource(""com/test/"");  //test.groovy is in a jar. (like a test.zip contains com/test/test.groovy)
		URL[] urlroots = {jarURL};
		GroovyScriptEngine gse = new GroovyScriptEngine(urlroots);
		System.out.println(""roots=""+jarURL);
		//this is ok
		gse.run(""test.groovy"", new Binding());
		//this will fail:  groovy.util.ResourceException: Cannot open URL: file:/C:/test.zip!/com/test/test.groovy
		gse.run(""test.groovy"", new Binding());
	}
}

{code}
;;;","05/Apr/12 10:02;mmayer;I have exactly the same problem in 1.8.5.;;;","13/Aug/12 10:29;blackdrag;Iwh, sorry for getting back to this so late... The test case you gave works for me. The question now is why does it not for you? I can only assume that getPath() behaves different for you and me. Assuming this is the case toString() or toExternalForm() might be a better choice, yes.;;;","14/Aug/12 06:51;blackdrag;I made that change as well as another similar change in SourceUnit. I hope this issue is then fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"static fields on interface not getting initialized, when being initialized to an anonymous class instance",GROOVY-5122,12818371,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,alex.heneveld,alex.heneveld,14/Nov/11 07:28,29/Mar/17 09:48,14/Jul/23 06:00,17/Nov/11 16:00,1.8.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.5,2.0-beta-2,,,,,0,,,,,,"The following code shows a _static_ field on an _interface_ not initialized at the point when the constructor of an _instance_ of an implementing class is being run.

{code}

package ignored.alex.failingcallsite

import java.lang.reflect.Field;

class FailingCallSiteLocalClass {
	public static void main(String[] args) {
		new B()		
	}
}

interface A {
	public static X x = new X() {
		public void foo() {}
	}
}

interface X {
	void foo()
}

class B implements A {
	public B() {
        for (Field f in getClass().getFields()) {
			println f
			println f.get(this)
		}
	}
}
{code}

Throws {{java.lang.IllegalAccessError}} when {{x}} is accessed via {{f.get(this)}}.

I would expect {{x}} to have been initialized by this point. Is there something subtle in when interfaces are initialized?

There is no problem if {{A}} is a _class_ extended by {{B}}, and more curiously, no problem if {{x}} is set equal to a named outer class (e.g. a class {{X2 implements X}}).
",OS X (suspected all),alexhen,githubbot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 29 09:48:17 UTC 2017,,,,,,,,,,"0|i2cqqf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Nov/11 07:34;alex.heneveld;I have seen various stack traces as I've tested it in various places.

Firstly, in some instances it complains that the constructor {{A$1(java.lang.Class)}} cannot be accessed, which makes me suspect inner class issues (e.g. GROOVY-5109) may be related.

{code}
public static transient boolean ignored.alex.failingcallsite.B.__$stMC
false
public static final ignored.alex.failingcallsite.X ignored.alex.failingcallsite.A.x
Exception in thread ""main"" java.lang.ExceptionInInitializerError
	at sun.misc.Unsafe.ensureClassInitialized(Native Method)
	at sun.reflect.UnsafeFieldAccessorFactory.newFieldAccessor(UnsafeFieldAccessorFactory.java:25)
	at sun.reflect.ReflectionFactory.newFieldAccessor(ReflectionFactory.java:122)
	at java.lang.reflect.Field.acquireFieldAccessor(Field.java:918)
	at java.lang.reflect.Field.getFieldAccessor(Field.java:899)
	at java.lang.reflect.Field.get(Field.java:358)
	at java_lang_reflect_Field$get.call(Unknown Source)
	at ignored.alex.failingcallsite.B.<init>(FailingCallSiteLocalClass.groovy:25)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
	at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:54)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:186)
	at ignored.alex.failingcallsite.FailingCallSiteLocalClass.main(FailingCallSiteLocalClass.groovy:7)
Caused by: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: ignored.alex.failingcallsite.A$1(java.lang.Class)
	at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1473)
	at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1389)
	at org.codehaus.groovy.runtime.callsite.MetaClassConstructorSite.callConstructor(MetaClassConstructorSite.java:46)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:54)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:190)
	at ignored.alex.failingcallsite.A.<clinit>(FailingCallSiteLocalClass.groovy:12)
	... 18 more
{code}

Running from the command-line shows the smaller trace:
{code}
bugs% ../groovy-2.0.0-beta-1/bin/groovy -e 'ignored.alex.failingcallsite.FailingCallSiteLocalClass.main()'
public static transient boolean ignored.alex.failingcallsite.B.__$stMC
false
public static long ignored.alex.failingcallsite.B.__timeStamp
1321276852344
public static long ignored.alex.failingcallsite.B.__timeStamp__239_neverHappen1321276852344
0
public static final ignored.alex.failingcallsite.X ignored.alex.failingcallsite.A.x
Caught: java.lang.IllegalAccessError: tried to access field ignored.alex.failingcallsite.A$1.$class$ignored$alex$failingcallsite$A from class ignored.alex.failingcallsite.A
java.lang.IllegalAccessError: tried to access field ignored.alex.failingcallsite.A$1.$class$ignored$alex$failingcallsite$A from class ignored.alex.failingcallsite.A
	at ignored.alex.failingcallsite.A.<clinit>(FailingCallSiteLocalClass.groovy:12)
	at java_lang_reflect_Field$get.call(Unknown Source)
	at ignored.alex.failingcallsite.B.<init>(FailingCallSiteLocalClass.groovy:25)
	at ignored.alex.failingcallsite.FailingCallSiteLocalClass.main(FailingCallSiteLocalClass.groovy:7)

{code}


Finally, it might be useful to note that although this test case fails on all versions tested (1.7.2 through 1.8.4, and 2.0.0-beta1), it was extracted from a more complicated scenario which only started failing in 1.8.2 -- was working for many months against 1.8.0-03.
;;;","15/Nov/11 04:36;melix;Without package definition, I obtain another error:
{{java.lang.LinkageError: loader (instance of  groovy/lang/GroovyClassLoader$InnerLoader): attempted  duplicate class definition for name: ""A$1""
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClassCond(ClassLoader.java:631)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:615)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)
	at groovy.lang.GroovyClassLoader.access$300(GroovyClassLoader.java:55)
	at groovy.lang.GroovyClassLoader$ClassCollector.createClass(GroovyClassLoader.java:519)
	at groovy.lang.GroovyClassLoader$ClassCollector.onClassNode(GroovyClassLoader.java:536)}}
which is due to a mismatch in inner class id generation (GeneratorContext). After fixing this bug, cannot reproduce your issue on master, still investigating.
;;;","15/Nov/11 04:59;alex.heneveld;If it's working now in master then I'd guess it's fixed ... either the default/root package bug or maybe GROOVY-5109.
;;;","15/Nov/11 05:02;melix;What is curious is that I cannot reproduce your problem. I have the same duplicate class definition error if I use Groovy 1.8.2.;;;","15/Nov/11 05:20;alex.heneveld;I observed the duplicate class error only when running it in default/root package. Didn't know what I was colliding with but figured it was irrelevant. Are you getting dup-class-def with package ignored.alex.failingcallsite set?

I'm on OS X 10.5 JDK 1.6.0_20 fwiw...
;;;","15/Nov/11 06:56;melix;I pushed the fix to branches 1.7.x, 1.8.x and master. I would be great to tell me if you still experience the problem.;;;","15/Nov/11 21:30;alex.heneveld;Alas, nope. It is still failing on master for me with the same error.

It also fails when the {{package}} line is removed, although the duplicated class error message is gone, I now get the analogous {{IllegalAccessException: tried to access field A$1.$class$A from class A}}.

Here is how I am pull, build and running it, with the class above (including package) in {{bugs/FailingCallSiteLocalClass.groovy}}:

{code}
~/dev/explore/groovy/git/groovy-core% git pull ; ant install -DskipTests=true
...

~/dev/explore/groovy/git/groovy-core% cd ../../bugs/

~/dev/explore/groovy/bugs% rm -rf ignored/

~/dev/explore/groovy/bugs% ../git/groovy-core/target/install/bin/groovyc FailingCallSiteLocalClass.groovy 

~/dev/explore/groovy/bugs% ../git/groovy-core/target/install/bin/groovy -e 'ignored.alex.failingcallsite.FailingCallSiteLocalClass.main()'
public static transient boolean ignored.alex.failingcallsite.B.__$stMC
false
public static long ignored.alex.failingcallsite.B.__timeStamp
1321413751418
public static long ignored.alex.failingcallsite.B.__timeStamp__239_neverHappen1321413751418
0
public static final ignored.alex.failingcallsite.X ignored.alex.failingcallsite.A.x
Caught: java.lang.IllegalAccessError: tried to access field ignored.alex.failingcallsite.A$1.$class$ignored$alex$failingcallsite$A from class ignored.alex.failingcallsite.A
java.lang.IllegalAccessError: tried to access field ignored.alex.failingcallsite.A$1.$class$ignored$alex$failingcallsite$A from class ignored.alex.failingcallsite.A
	at ignored.alex.failingcallsite.A.<clinit>(FailingCallSiteLocalClass.groovy:12)
	at java_lang_reflect_Field$get.call(Unknown Source)
	at ignored.alex.failingcallsite.B.<init>(FailingCallSiteLocalClass.groovy:25)
	at ignored.alex.failingcallsite.FailingCallSiteLocalClass.main(FailingCallSiteLocalClass.groovy:7)
	at script_from_command_line.run(script_from_command_line:1)
{code}
;;;","16/Nov/11 06:40;blackdrag;I start suspecting this happens because the field is final and I think Sun/Oracle VM doesn't check that, while the OSX VM does.;;;","16/Nov/11 10:17;melix;I don't have an OSX machine to test that. It may be some problem with the order fields are initialized, we've seen that in the past, but it doesn't happen here on my JVM. What happens if you write the same code in Java ?;;;","16/Nov/11 11:03;alex.heneveld;Analogous code in Java is fine, happily prints:

{code}
public static final ignored.alex.failingcallsite.poj.X ignored.alex.failingcallsite.poj.A.x
ignored.alex.failingcallsite.poj.A$1@593d93f4
{code}

So suspect you're right, something different in how the OSX JVM does things. :(;;;","17/Nov/11 02:30;melix;For reference, I just tested with Oracle JRockit on Linux 64 bit, it doesn't throw any IAE. I'm trying to download IBM JVM... but I'm stuck at download. Now trying various OpenJDK VM options.;;;","17/Nov/11 08:06;alex.heneveld;No, don't think it's OSX. I have a simpler test case which fails on OSX JVM and on Linux Sun JVM. (Not totally sure it is the same issue but seems like a better starting point.)

{code}
% cat Groovy5122.groovy 
package bug5122.small1

class Groovy5122 {
	public static void main(String[] args) {
		println ""x is: ""+InterfaceWithStaticAnonymous.x;
	}
}

interface InterfaceWithStaticAnonymous {
	public static Object x = new Object() {};
}
{code}

Gives the following error (in all cases):
{code}
% java -cp groovy-all.jar:. bug5122.small1.Groovy5122
Exception in thread ""main"" java.lang.IllegalAccessError: tried to access field bug5122.small1.InterfaceWithStaticAnonymous$1.$class$bug5122$small1$InterfaceWithStaticAnonymous from class bug5122.small1.InterfaceWithStaticAnonymous
	at bug5122.small1.InterfaceWithStaticAnonymous.<clinit>(Groovy5122.groovy:10)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:169)
	at bug5122.small1.Groovy5122.class$(Groovy5122.groovy)
	at bug5122.small1.Groovy5122.$get$$class$bug5122$small1$InterfaceWithStaticAnonymous(Groovy5122.groovy)
	at bug5122.small1.Groovy5122.main(Groovy5122.groovy:5)
{code}

I observe this against v1.8.4 and against git master (with 5109 fix, and tried both with and without an additional patch from Cédric). Problem goes away if we {{s/interface/class/}} and/or if we {{s/{}//}}. Error is the same if we put it in the default package.

Suggest we rename issue to *IllegalAccessError for static field in interface being assigned to anonymous class instance*.

OSX JVM is 1.6.0_20. Linux JVM is Sun/Oracle 1.6.0_22.
;;;","17/Nov/11 09:40;melix;I am under Linux, and I don't face the problem. What bugs me is the way you start the main program. You are using:

{code}java -cp groovy-all.jar:. bug5122.small1.Groovy5122{code}

Which tells you have compiled the script previously. How did you compile the script ? I am using this :

{code}java -cp ~/GG/target/dist/groovy-all.jar:. groovy.ui.GroovyMain bug5122/small1/Groovy5122.groovy 
x is: bug5122.small1.InterfaceWithStaticAnonymous$1@561777b1{code}

And the output is correct. Are you sure you are compiling the script with the right version of Groovy ?
;;;","17/Nov/11 10:03;alex.heneveld;Yes, I always recompile with the same version.  Seemed safest.

Different ways of starting it cause different problems but all cause problems.

When I run with your syntax I get:

{code}
alex@dynlin334:~/groovy/bugs$ java -cp ../current/embeddable/groovy-all-2.0.0-beta-2-SNAPSHOT.jar:. groovy.ui.GroovyMain Groovy5122.groovy 
Caught: java.lang.LinkageError: loader (instance of  groovy/lang/GroovyClassLoader$InnerLoader): attempted  duplicate class definition for name: ""bug5122/small1/InterfaceWithStaticAnonymous$1""
java.lang.LinkageError: loader (instance of  groovy/lang/GroovyClassLoader$InnerLoader): attempted  duplicate class definition for name: ""bug5122/small1/InterfaceWithStaticAnonymous$1""
{code}

Same if I run with {{bin/groovy bug5122/small1/Groovy5122.groovy}}.
;;;","17/Nov/11 10:14;melix;That puzzles me. I don't understand. The last error you show is the one fixed in the lastest master commit... I tried many JDKs, even managed to test on a JDK 1.5 Apple JDK, but none showed that IAE error :p;;;","17/Nov/11 10:50;alex.heneveld;Ah, all good.

Latest commit 2151e717653113c24f4c1f3e48c4960ee67d01c5 fixes it, it just wasn't in github when I pulled. Maybe some delay before things are shown in the mirror?  Sorry for the noise. :(

FWIW the patch you sent me for AsmClassGenerator (replacing ACC_SUPER with ACC_PUBLIC|ACC_STATIC) makes no apparent difference.;;;","17/Nov/11 10:53;melix;Ok, so you are telling me that you don't have any IAE anymore ?;;;","17/Nov/11 11:04;alex.heneveld;Yep. :)  All errors are gone -- IAE for $..class, IAE for call site, duplicate class, missing constructor. Have tried several of the failure cases I had, and all are now happy. Strange that it would manifest itself in so many different ways, but all good now.;;;","17/Nov/11 12:28;melix;Ok, last check. When you say you don't have any errors, is it with or without the patch (which is not committed) on AsmClassGenerator ? ;;;","17/Nov/11 12:34;alex.heneveld;The patch makes no apparent difference.  I get no errors without it, and I get no errors with it.;;;","17/Nov/11 12:35;melix;Great, thanks!;;;","28/Mar/17 10:09;githubbot;Github user tbouron commented on a diff in the pull request:

    https://github.com/apache/brooklyn-server/pull/611#discussion_r108372912
  
    --- Diff: core/src/main/java/org/apache/brooklyn/core/effector/ExplicitEffector.java ---
    @@ -46,12 +58,20 @@ public T call(Entity entity, Map parameters) {
         
         /** convenience to create an effector supplying a closure; annotations are preferred,
          * and subclass here would be failback, but this is offered as 
    -     * workaround for bug GROOVY-5122, as discussed in test class CanSayHi 
    +     * workaround for bug GROOVY-5122, as discussed in test class CanSayHi.
    +     * 
    +     * @deprecated since 0.11.0; explicit groovy utilities/support will be deleted.
          */
    +    @Deprecated
         public static <I,T> ExplicitEffector<I,T> create(String name, Class<T> type, List<ParameterType<?>> parameters, String description, Closure body) {
    +        LOG.warn(""Use of groovy.lang.Closure is deprecated, in ExplicitEffector.create()"");
    --- End diff --
    
    Shouldn't we suggest another class/method to use in the warning message?
;;;","29/Mar/17 09:11;githubbot;Github user aledsage commented on a diff in the pull request:

    https://github.com/apache/brooklyn-server/pull/611#discussion_r108627021
  
    --- Diff: core/src/main/java/org/apache/brooklyn/core/effector/ExplicitEffector.java ---
    @@ -46,12 +58,20 @@ public T call(Entity entity, Map parameters) {
         
         /** convenience to create an effector supplying a closure; annotations are preferred,
          * and subclass here would be failback, but this is offered as 
    -     * workaround for bug GROOVY-5122, as discussed in test class CanSayHi 
    +     * workaround for bug GROOVY-5122, as discussed in test class CanSayHi.
    +     * 
    +     * @deprecated since 0.11.0; explicit groovy utilities/support will be deleted.
          */
    +    @Deprecated
         public static <I,T> ExplicitEffector<I,T> create(String name, Class<T> type, List<ParameterType<?>> parameters, String description, Closure body) {
    +        LOG.warn(""Use of groovy.lang.Closure is deprecated, in ExplicitEffector.create()"");
    --- End diff --
    
    I've added this to javadoc on the class - I think that's good enough, as there's not a direct replacement (i.e. one would extend `AbstractEffector` yourself instead, as we don't need to workaround for GROOVY-5122 if you're not using groovy - I'm not sure why anyone would want to do that).
    
    I agree in general that if deprecating a method/class, one should point at the alternative - but if deprecating a class, I don't think we need it on every method.
;;;","29/Mar/17 09:48;githubbot;Github user tbouron commented on a diff in the pull request:

    https://github.com/apache/brooklyn-server/pull/611#discussion_r108634563
  
    --- Diff: core/src/main/java/org/apache/brooklyn/core/effector/ExplicitEffector.java ---
    @@ -46,12 +58,20 @@ public T call(Entity entity, Map parameters) {
         
         /** convenience to create an effector supplying a closure; annotations are preferred,
          * and subclass here would be failback, but this is offered as 
    -     * workaround for bug GROOVY-5122, as discussed in test class CanSayHi 
    +     * workaround for bug GROOVY-5122, as discussed in test class CanSayHi.
    +     * 
    +     * @deprecated since 0.11.0; explicit groovy utilities/support will be deleted.
          */
    +    @Deprecated
         public static <I,T> ExplicitEffector<I,T> create(String name, Class<T> type, List<ParameterType<?>> parameters, String description, Closure body) {
    +        LOG.warn(""Use of groovy.lang.Closure is deprecated, in ExplicitEffector.create()"");
    --- End diff --
    
    Fair enough
;;;",,,,,,,,,,,,,,,,,,,,,
Node.depthFirst() 'forgets' text nodes,GROOVY-5119,12815880,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,zroh,zroh,10/Nov/11 08:09,13/May/12 03:30,14/Jul/23 06:00,04/Apr/12 06:55,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,XML Processing,,,,0,,,,,,"Node.depthFirst() is expected to recursively include all Node.children() elements. The attached program demonstrates a counter example, where Node.depthFirst() 'forgets' all 3 text chldren resulting in a list of 4 instead of 7 elements.

The correct semantics of ""Node.depthFirst()"" is defined by ""depthFirst( node )"" in the attached program.",(any),paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Nov/11 08:09;zroh;Bug.groovy;https://issues.apache.org/jira/secure/attachment/12722592/Bug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 04 06:55:06 UTC 2012,,,,,,,,,,"0|i2cnnj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Nov/11 15:53;paulk;The behavior of {{depthFirst}} and {{breadthFirst}} for {{XmlParser}} was aligned with {{XmlSlurper}} some time back and it intentionally 'forgets' text nodes - just processing elements. I guess we should allow for both behaviors. Certainly {{depthFirst}} and {{breadthFirst}} need to be kept consistent. The same comments apply to the {{DOMCategory}} implementation, i.e. if we make changes we should align its behavior as well.;;;","11/Nov/11 04:04;zroh;The Behavior of XmlSlurper.depthFirst() is consistent because XmlSlurper.children() also 'forgets' text children.

I did not check the behavior of XmlParser.breadthFirst().

Note that the standard definition of depth and breadth first traversal are based on ""node expansion"" (using ""children()""). Deviations should be explicitely mentioned in the API documentation -- if not considered a bug.;;;","04/Apr/12 02:57;paulk;OK, I have a fix for this but am awaiting other discussions regarding further changes to the XML APIs (with regard as to when to trim ignorable whitespace) which might impact my change.;;;","04/Apr/12 06:55;paulk;I went ahead and applied the fix. Depending on on-going discussions about trimming, the output to be expected may be further refined over time for various edge cases.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
String[] to Set coercion seems broken in some cases,GROOVY-5114,12815939,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,melix,graemerocher,graemerocher,04/Nov/11 11:56,31/May/23 14:49,14/Jul/23 06:00,04/Nov/11 14:56,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.4,2.0-beta-1,,,,,0,,,,,,See http://jira.grails.org/browse/GRAILS-8194 for a description of the problem,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-9852,GROOVY-11073,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 04 14:56:43 UTC 2011,,,,,,,,,,"0|i2cj9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Nov/11 14:56;melix;The problem was that the function which computes the distance between a type parameter and an argument type returns a smaller distance between String[] and Object than it does for String[] and Object[].
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""A transform used a generics containing ClassNode"" error messages for @Delegate",GROOVY-5112,12818127,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,aclement,aclement,01/Nov/11 12:41,24/Dec/11 03:08,14/Jul/23 06:00,01/Nov/11 15:56,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.4,2.0-beta-1,,,,,,0,,,,,,"I had a quick look but didn't see this already raised.  This program:

{code}
class ListWrapper {  
  @Delegate
  List myList
  
  @Delegate
  URL homepage
}
{code}

causes this error:

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Code.groovy: -1: A transform used a generics containing ClassNode java.lang.Class <T extends java.lang.Object -> java.lang.Object> for the method public final java.lang.Object getContent([Ljava.lang.Class; param0) throws java.io.IOException { ... } directly. You are not suppposed to do this. Please create a new ClassNode refering to the old ClassNode and use the new ClassNode instead of the old one. Otherwise the compiler will create wrong descriptors and a potential NullPointerException in TypeResolver in the OpenJDK. If this is not your own doing, please report this bug to the writer of the transform.
 @ line -1, column -1.
1 error

{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 01 15:56:05 UTC 2011,,,,,,,,,,"0|i2bwfj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Nov/11 15:56;melix;The issue was related to a class node which didn't use generics but was an array type which component did use generics. Fixed on master and 1.8.x.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Named parameter support breaks with postgres casting syntax,GROOVY-5111,12815972,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,hollandlef,hollandlef,01/Nov/11 11:58,15/Jun/12 22:56,14/Jul/23 06:00,12/May/12 06:10,1.8.2,1.8.6,2.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-rc-1,,SQL processing,,,,0,,,,,,"Postgres supports a casting syntax like ""SELECT '2011-01-01'::date"". I recently wrote a query like: ""SELECT * FROM table WHERE my_date BETWEEN ?-'1 week'::interval AND ?"" and was surprised to receive strange errors about java.sql.Date not supporting the ""interval"" property. It would appear that the regex parsing that identifies named parameters is a bit broken in this instance.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 12 06:10:59 UTC 2012,,,,,,,,,,"0|i2bx0v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/May/12 07:59;djsutho;
In groovy.sql.Sql changing:
{code}
private static final Pattern NAMED_QUERY_PATTERN = Pattern.compile(""(?::|\\?(\\d?)\\.?)(\\w*)"");
{code}
to:
{code}
private static final Pattern NAMED_QUERY_PATTERN = Pattern.compile(""(?<!:)(:|\\?(\\d*)\\.)(\\w+)"");
{code}
should fix this problem. It matches:
{code}
:foo 
?.bar 
?1.baz 
?12.baz 
{code}
but not:
{code}
:
::asdf
{code}

It does not cover the case when something that looks like a named parameter is contained in a string e.g:

{code}
select * from some_table where description = ':notANamedParameter'
{code}
This case is probably hard to cover in a regex  as it must check that it is not a named parameter surrounded by strings e.g.:
{code}
':notANamedParameter' :aNamedParameter ':alsoNotANamedParameter'
{code}
So while this is not a perfect solution it adds functionality without removing any (as far as I can tell).
;;;","10/May/12 06:35;paulk;@Lucian, try setting {{enableNamedQueries=false}}.

@David, that looks close. We need to also support ordinal (non-named) params and we currently cover both cases with a single regex, so we need to support ?1 for instance. I have adapted your proposed solution and all tests pass - I will commit once I have a good test case.;;;","10/May/12 06:49;hollandlef;@Paul, Thanks for the suggestion. Unfortunately it's been a while since I was working on this project and I'm rather snowed under with another project in a completely different environment... I can't remember off the top of my head whether we needed named parameter support or not, but I suspect we might have been able to work around it like that...;;;","12/May/12 06:10;paulk;changed as per the suggestion (thanks) with some minor changes;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy examples on the codehaus site don't appear to work on some versions of IE,GROOVY-5110,12818412,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,paulk,,31/Oct/11 00:50,07/Apr/15 19:07,14/Jul/23 06:00,18/Jan/13 13:43,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,"When using IE8 (version: 8.0.7601.17514) some (most?) of the code examples don't appear to work.

On the ""Installing Groovy"" page which doesn't display (screen snapshot attached) the html used is:
{code}
<div class=""code panel"" style=""border-width: 1px;""><div class=""codeContent panelContent"">
<script type=""syntaxhighlighter"" class=""theme: Confluence; brush: java; gutter: false""><![CDATA[groovysh]]></script>
</div></div>
{code}
but on the home page which has html like:
{code}
<div class=""preformatted panel preformattedContent panelContent null3""><pre>
...
</pre></div>
{code}
it does seem to display correctly.
",,guillaume,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"31/Oct/11 00:50;paulk;IE.gif;https://issues.apache.org/jira/secure/attachment/12722640/IE.gif",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 18 13:43:54 UTC 2013,,,,,,,,,,"0|i2c12n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Oct/11 00:54;paulk;Looking at the security warnings from IE, it appears to blocking cookies to google.com but doesn't _seem_ to have any problems with scripts coming from codehaus.;;;","18/Jan/13 13:00;pschumacher;The samples also appear for me with Internet Explorer 8. This can be closed.;;;","18/Jan/13 13:43;guillaume;I had made various template fixes and such a while ago, and hopefully all is fine now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
inner class inheritance with outer class inheritance can't find constructor,GROOVY-5109,12817836,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,alex.heneveld,alex.heneveld,30/Oct/11 21:23,24/Dec/11 03:08,14/Jul/23 06:00,15/Nov/11 06:46,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.5,2.0-beta-2,class generator,,,,0,,,,,,"Instantiation fails at runtime if I have an inner class extending an inner class defined in the outer class's parent I get a {{NoSuchMethodError}} on instantiation.  In other words, *{{C2 extends C1}}* and *{{C2.B extends C1.A}}* yields *{{C1$A: method <init>()V not found}}* in *{{C2.B}}*'s constructor.  A repeatable test case is below:

{code}
class FailingInnerClassInheritance {
	
	public static void main(String[] args) {
		new C2()
	}
	
}

class C1 {
	class A {}
}

class C2 extends C1 {
	{ new B() }
	class B extends C1.A {}
}
{code}

The analogous example works in Java. It fails in Groovy even if we construct {{B}} later (after {{C2}} construction) and try to supply various explicit constructors.
",,alexhen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 15 21:32:51 UTC 2011,,,,,,,,,,"0|i2clwn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Nov/11 03:39;alex.heneveld;Nice, Cedric.  Does this also squash GROOVY-5122?
;;;","15/Nov/11 03:41;melix;No, I am working on it, but it generates a different error on master.;;;","15/Nov/11 21:32;alex.heneveld;Fix confirmed working in master.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Same interface can be implemented with two different generic types,GROOVY-5106,12815789,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,melix,melix,28/Oct/11 15:52,03/Feb/22 22:35,14/Jul/23 06:00,05/Jan/22 20:38,2.4.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,4.0.0,,,Compiler,,,,0,,,,,,"Given the following code :
{code}

interface One<T> {
    void echo(T obj);
}

interface Two extends One<String> {}

class OneImpl implements Two,One<Integer> {

    public void echo(String obj) { println obj }
}

def o = new OneImpl()
{code}

The ""One"" interface is implemented twice with two different generic types, which should not be allowed. Here's another example, more complex :

{code}
interface Transcoder<T, U> {
    T transcode(U obj);
}

interface TranscoderToString<V> extends Transcoder<String, V>{
}

abstract class AbstractToStringTranscoder<V> implements TranscoderToString<V> {

    public String transcode(final V obj) {
        return obj.toString();
    }
}

class IntegerToStringTranscoder extends AbstractToStringTranscoder<Integer> implements TranscoderToString<Boolean> {

}
{code}
",,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10439,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 05 20:38:47 UTC 2022,,,,,,,,,,"0|i2chhb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Aug/18 02:44;paulk;Java/Intellij would give an error message like:
{noformat}
One cannot be inherited with different type arguments: <java.lang.String> and <java.lang.Integer>
{noformat}
;;;","05/Jan/22 20:38;emilles;https://github.com/apache/groovy/commit/9e420c1a3a90c737891abff9d1e84b7493d18bd0;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy compiler ignores import * for static nested classes in java sources,GROOVY-5103,12814743,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,clarkdave,clarkdave,26/Oct/11 16:45,19/Mar/22 13:49,14/Jul/23 06:00,20/Jul/20 07:24,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.17,3.0.5,4.0.0-alpha-1,Compiler,,,,0,,,,,,"(using Groovy 1.8.3, JVM 1.6.0_23 OpenJDK)

Given this class:
{code:title=Foo.java}
package org.test;

public class Foo {
    public static class Bar {
        String message;
        
        public Bar(String message) {
            this.message = message;
        }
    }
    public static class Cat {
        Integer amount;

        public Cat(Integer amount) {
            this.amount = amount;
        }
    }
}
{code}

Groovy code can import both of these static nested classes like this:
{code}
import static org.test.Foo.*
{code}

However, in Java they are imported like this:
{code}
import org.test.Foo.*;
{code}

Using the Groovy compiler to compile any Java files which do the above will result in the following error if any of the static nested classes are used:
{code}
App.java: 9: unable to resolve class Bar 
 @ line 9, column 13.
   		Bar bar = new Bar(""Hello"");
{code}

Is this expected? If so, is there a known workaround (or maybe I'm just doing it wrong...)?",,emilles,,,,,,,,,,,,"eric-milles opened a new pull request #1318:
URL: https://github.com/apache/groovy/pull/1318


   https://issues.apache.org/jira/browse/GROOVY-5103
   
   - Java allows ""import foo.Bar.*"" to resolve ""Baz"" to ""foo.Bar$Baz""
   
   - Note: This is also a compatibility/transparency issue for Eclipse Groovy Development Tools, which has supported star imports that resolve inner types for years.
   
   Checking star imports for type reference is limited to ""real"" star imports (those present in the source text) to prevent trying to resolve ""java.lang"", ""java.util"", etc. for every single `ModuleNode`.  Type resolution also enables display of Javadoc information for the imported type:
   ![image](https://user-images.githubusercontent.com/18193802/87860033-96c61100-c8ff-11ea-9222-993dc1189acd.png)


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Jul/20 19:05;githubbot;600","paulk-asert commented on pull request #1318:
URL: https://github.com/apache/groovy/pull/1318#issuecomment-660549463


   This seems okay. It doesn't seem to break the existing import of static classes using ""import static"", which while possibly unexpected from a Java point-of-view, we have supported for a long time. I'll note that your patch doesn't extend to another ""exotic"" case we currently support.
   ```
   import java.util.Map as SomeMap
   import static SomeMap.Entry as SomeEntry
   
   assert SomeEntry instanceof Class
   ```
   works but not without the static. It is also somewhat unusual but accounts for aliases to some degree and we have supported it for along time too. We can cover that off separately.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Jul/20 22:09;githubbot;600","asfgit closed pull request #1318:
URL: https://github.com/apache/groovy/pull/1318


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Jul/20 22:13;githubbot;600","paulk-asert commented on pull request #1318:
URL: https://github.com/apache/groovy/pull/1318#issuecomment-660549908


   Merged, thanks.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Jul/20 22:13;githubbot;600","eric-milles commented on pull request #1318:
URL: https://github.com/apache/groovy/pull/1318#issuecomment-660556422


   > ... your patch doesn't extend to another ""exotic"" case we currently support.
   > 
   > ```
   > import java.util.Map as SomeMap
   > import static SomeMap.Entry as SomeEntry
   > 
   > assert SomeEntry instanceof Class
   > ```
   > 
   > works but not without the static. It is also somewhat unusual but accounts for aliases to some degree and we have supported it for along time too. We can cover that off separately.
   
   If you wanted to shut down this ""exotic"" behavior, you could change this bit:
   ```
       public void visitClass(final ClassNode node) {
           ...
               for (ImportNode importNode : module.getStaticImports().values()) {
                   ClassNode type = importNode.getType();
                   if (resolve(type, true, true, true)) continue; // set flags to ""false, false, true"" to not use other imports to help resolve this import
                   addError(""unable to resolve class "" + type.getName(), type);
               }
   ```
   
   Just an option to consider.  I don't think anyone coming into the language is expecting one import to influence another.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Jul/20 23:20;githubbot;600","paulk-asert commented on pull request #1318:
URL: https://github.com/apache/groovy/pull/1318#issuecomment-660559360


   Not planning to shut it down at this stage. I have had numerous folks (albeit quite a few years ago now) who've come up to me at conferences and expressed their like for that feature and how it made it easier for DSLs and various porting scenarios.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Jul/20 23:52;githubbot;600",,,,,,,,,,,,0,3600,,,0,3600,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 18 19:26:25 UTC 2020,,,,,,,,,,"0|i2bny7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jul/20 19:26;emilles;Enhancement request for supporting star imports in this manner: https://github.com/apache/groovy/pull/1318;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unrelated changes cause BigDecimal division to return Double,GROOVY-5102,12815949,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,sjurgemeyer,sjurgemeyer,25/Oct/11 10:05,03/Nov/11 14:16,14/Jul/23 06:00,03/Nov/11 14:16,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.4,2.0-beta-1,,bytecode,Compiler,,,0,,,,,,"In Groovy 1.8.3 the first test passes while the second fails.  The return type of the second operation (and third, if it were to get to it) becomes a Double.

The tests both pass in 1.8.2.

{code}
class BigDecimalTest extends GroovyTestCase{
    public void testMath1() {
        assert BigDecimal == (3/2).getClass()
        assert BigDecimal == (7.0/8.0).getClass()
        assert BigDecimal == (new BigDecimal(3.0)/new BigDecimal(2.0)).getClass()
        true
    }

    public void testMath2() {
        assert BigDecimal == (3/2).getClass()
        assert BigDecimal == (7.0/8.0).getClass()
        assert BigDecimal == (new BigDecimal(3.0)/new BigDecimal(2.0)).getClass()
    }
}
{code}","OSX, Linux for sure, perhaps others",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 03 14:16:42 UTC 2011,,,,,,,,,,"0|i2cjlz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"03/Nov/11 14:16;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyCastException occurs since 1.8.3,GROOVY-5101,12818108,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,nobeans,nobeans,25/Oct/11 04:50,20/Dec/11 09:32,14/Jul/23 06:00,20/Dec/11 09:32,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,,,,,0,,,,,,"GroovyServ 0.9 doesn't work with Groovy 1.8.3. Surely, it still works well with Groovy 1.8.2.

Stacktrace on starting-up of GroovyServ:
{code}
 2011/10/25 18:17:01.121 ---> org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'groovy.lang.Reference@464693f9' with class 'groovy.lang.Reference' to class 'java.lang.Runnable'
 2011/10/25 18:17:01.121         at org.jggug.kobo.groovyserv.RequestWorker$2.<init>(RequestWorker.groovy)
 2011/10/25 18:17:01.121         at org.jggug.kobo.groovyserv.RequestWorker.newTaskFor(RequestWorker.groovy:85)
 2011/10/25 18:17:01.121         at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:77)
 2011/10/25 18:17:01.121         at java_util_concurrent_ExecutorService$submit.callCurrent(Unknown Source)
 2011/10/25 18:17:01.121         at org.jggug.kobo.groovyserv.RequestWorker.start(RequestWorker.groovy:67)
 ...(snip)...
{code}

At line 85 of RequestWorker:
{code}
new FutureTask(runnable, defaultValue) { // anonymous inner class
    String toString() { runnable.id }
}
{code}

When I tried to fix it as following, it worked well even with groovy 1.8.3.
{code}
        new FutureTask(runnable, defaultValue)
{code}

I'm sorry. I wanted to report the sample code which is independent on GroovyServ, but the problem didn't occur on the simplified sample code.

This might be the same problem as http://jira.codehaus.org/browse/GROOVY-5077.


GroovyServ: http://kobo.github.com/groovyserv/
RequestWorker's full source code: https://github.com/kobo/groovyserv/blob/master/src/main/groovy/org/jggug/kobo/groovyserv/RequestWorker.groovy","MacOSX: 10.6
Groovy Version: 1.8.3
JVM: 1.6.0_26",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"25/Oct/11 21:39;nobeans;Groovy5101Test.groovy;https://issues.apache.org/jira/secure/attachment/12722875/Groovy5101Test.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 20 09:32:02 UTC 2011,,,,,,,,,,"0|i2cibr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Oct/11 11:28;nobeans;I've found the commit at which the problem occurs by using git bisect at the GROOVY_1_8_x branch of groovy/groovy-core on GitHub:
{quote}
fdf212623511fce9d47d3d8ab3954a709d70583f is the first bad commit
commit fdf212623511fce9d47d3d8ab3954a709d70583f
Author: Jochen <blackdrag@gmx.org>
Date:   Fri Sep 9 00:04:39 2011 +0200

    GROOVY-5000: change aic constructor call to correctly respect references
{quote}

At the master branch of groovy/groovy-core on GitHub:
{quote}
commit fa995f14d52d9c0d18c19cffb448d021b29025e9
Author: Jochen <blackdrag@gmx.org>
Date:   Fri Sep 9 00:04:39 2011 +0200

    GROOVY-5000: change aic constructor call to correctly respect references
{quote}

I made sure that the problem doesn't occur at the previous commit of it.

For your reference, I uploaded the test script which I used for ""git bisect run"".
https://gist.github.com/1313324;;;","25/Oct/11 21:39;nobeans;the simpler test which the problem occurs;;;","25/Oct/11 21:53;nobeans;The attached Groovy5101Test.groovy is simple enough to cause the problem, but the API of sample classes is meaningless.
If you mind that, refer to my gist which has the improved version of test code.

https://gist.github.com/1315245
;;;","25/Nov/11 03:47;nobeans;I invoked the attached test code on GroovyConsole and analyzed at end of phase ""Semantic Analysis"" by GroovyASTBrowser.

{code}
public void test_InnerAnonymousClass_UsingArgument() {
    java.lang.Object getClassA = { java.lang.Runnable r ->
        new Groovy5101Test$3(this, r, r) // ---> [1] 2nd and 3rd args are same as Runnable!??
    }
    assert getClassA.call(r).getSomething() == r.toString() : null
}


public class Groovy5101Test$3 extends Groovy5101Test$ClassA { 

    public groovy.lang.Reference r 
    public Groovy5101Test this$0 

    Groovy5101Test$3(Groovy5101Test p0, groovy.lang.Reference p1, java.lang.Object p3) { // ---[2]
        super( p3 )
        this$0 = p0 
    }

    public java.lang.String getSomething() {
        r.toString()
    }
}
{code}

The second parameter of Groovy5101Test$3 is Reference at [2], but the instance of Runnable was passed at [1]. So GroovyCastException occurred there.

I guess the cause is around org.codehaus.groovy.classgen.asm.InvocationWriter#writeAICCall().
;;;","28/Nov/11 03:03;melix;As a workaround, replace:
{code}
ClassA getClassA3(Runnable r) {
            new ClassA(r) {
                String getSomething() { r.toString() }
            }
        }
{code}
with:
{code}
ClassA getClassA3(Runnable r) {
            new ClassA(r) {
                String getSomething() { this.r.toString() }
            }
        }
{code};;;","20/Dec/11 09:32;blackdrag;the fix for GROOVY-5041 is actually almost the fix for this here too, only the wrong method to ask for the closure shared variable was used.

Anyway, this issue is fixed, the provided est case passes now and is part of the build;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using log variable created with @Log causes compiler error if used in static method,GROOVY-5098,12815942,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,hamletdrc,smartini,smartini,24/Oct/11 05:36,24/Dec/11 03:08,14/Jul/23 06:00,24/Oct/11 05:54,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,"If I have a class with it and use the 'log' variable in a static method I get a compilation error. 


Log4jTest.groovy:
import groovy.util.logging.Log4j

@Log4j
class TestLog4j {

  public static void main(String[] args) {
    log.info ""Hello World""
  }
}

Error Message:
Apparent variable 'log' was found in a static scope but doesn't refer to a local variable, static field or class. Possible causes:
You attempted to reference a variable in the binding or an instance variable from a static context.
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method 'log' but left out brackets in a place not allowed by the grammar. ",,smartini,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 24 05:54:51 UTC 2011,,,,,,,,,,"0|i2chev:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Oct/11 05:49;smartini;Hi all,
sorry but I think the issue is still valid (only for the @Log annotation, my use case).
I'm using Groovy-1.8.2 (from latest eclipse 3.7 plugin) and I have the same error described here.
Tell me if you need more info, and sorry for opening this (I wrote a comment in GROOVY-4609 some day ago but maybe it has not so much vivibility).

This is a minimal test:

package mypackage.tests;
import groovy.util.logging.Log
@Log
public class TestLog {
    public static void main(String[] args) { log.info ""Hello World"" }
}


in eclipse I get a compiler error, but all is working at runtime.

Note that I have to use the Java Logging because I'm using it in a simple client side application so I'm not using Log4J.

Thanks,
Sandro
;;;","24/Oct/11 05:54;smartini;Closing it (was created by clone, but without the ability to edit it), so re-create from scratch. Sorry for this noise.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Proxy unwrapping causes UndeclaredThrowableExceptions,GROOVY-5097,12818121,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,jstoneham,jstoneham,23/Oct/11 22:18,10/Aug/13 05:02,14/Jul/23 06:00,10/Aug/13 05:02,1.7.6,1.7.7,1.7.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.0,,,,,,,3,,,,,,"When upgrading to Grails 1.3.7, we started having trouble with UndeclaredThrowableExceptions popping out of our withTransaction blocks. Normally, throwing checked exceptions out of these blocks has worked perfectly well. We traced it down to Groovy 1.7.6's Git commit e53591b122bbfd039a03d37f2868ff95b5202c6b (http://svn.codehaus.org/groovy/branches/GROOVY_1_7_X@21327) which changes src/main/org/codehaus/groovy/runtime/ConversionHandler.java to unwrap GroovyRuntimeExceptions coming out of invokeCustom(). This takes what is normally an InvokerInvocationException containing our real checked exception - which would normally bounce all the way out to user code - and instead throws the real checked exception underneath, which promptly tries to propagate through a proxy which doesn't allow any checked exceptions through at all, and turns into an UndeclaredThrowableException.

Immediate fix would be to revert the commit.

2 sample apps attached (one is for Grails 1.3.6 [bundles Groovy 1.7.5], other is for Grails 1.3.7 [bundles Groovy 1.7.8], they are otherwise identical). Get a copy of Grails 1.3.6 and Grails 1.3.7.

Extract the 1.3.6 app and type 'grails console'. Run:

try {
   test.Test.withTransaction {
      throw new Exception(""Testing throwing exceptions out of withTransaction"")
   }
} catch (Throwable t) {
   println t
}

Expected output: 

java.lang.Exception: Testing throwing exceptions out of withTransaction

Now, switch to Grails 1.3.7, and run grails console for the 1.3.7 app. Same code:

try {
   test.Test.withTransaction {
      throw new Exception(""Testing throwing exceptions out of withTransaction"")
   }
} catch (Throwable t) {
   println t
}

Expected (undesirable) output:

java.lang.reflect.UndeclaredThrowableException","MacOSX, Grails 1.3.7",blackdrag,jstoneham,nobeans,pschumacher,rsaddey,rvowles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/Oct/11 22:20;jstoneham;test-1.3.6.tar.gz;https://issues.apache.org/jira/secure/attachment/12722160/test-1.3.6.tar.gz","23/Oct/11 22:20;jstoneham;test-1.3.7.tar.gz;https://issues.apache.org/jira/secure/attachment/12722902/test-1.3.7.tar.gz",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 10 05:02:40 UTC 2013,,,,,,,,,,"0|i2c1q7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Aug/12 19:22;rvowles;This would seem to me to be expected behaviour. The following code throws an UndeclaredThrowableException, because its undeclared. If you add ""throws Exception"" to the method, you get the right exception. The same problem occurs in Java, so IMHO, this is a Grails or Spring Transaction bug and should be listed over there.

void x(Fred f) {
  f.doSomething()
}

interface Fred {
  void doSomething()// throws Exception
}

try {
   x ({ throw new Exception(""Testing throwing exceptions out of withTransaction"") } as Fred)
} catch (Throwable t) { 
  println t 
}
;;;","20/Aug/12 01:50;rsaddey;From [Differences+from+Java|http://groovy.codehaus.org/Differences+from+Java]:
{quote}The throws clause in a method signature is not checked by the Groovy compiler, because there is no difference between checked and unchecked exceptions.{quote}
* This Jira ticket is about Grails 1.3.7 (as opposed to 1.3.6) no longer conforming to  Groovy conventions. The test case as provided by John appears to be perfectly valid and does not contain a single bit of Java code. 
* The matter is further complicated by the fact that with Spring (unless annotated otherwise), only unchecked exceptions cause transaction rollbacks (i.e. Grails services having transactional = true).;;;","20/Aug/12 02:55;rvowles;Therefore the ticket should be in the GRAILS Jira and not the GROOVY Jira. I understand why it wouldn't want to be so, the chances of it getting fixed are fairly low.

;;;","20/Aug/12 03:04;rsaddey;Citing the description of this ticket:
{quote}Grails 1.3.6 [bundles Groovy 1.7.5], other is for Grails 1.3.7 [bundles Groovy 1.7.8], they are otherwise identical).{quote}

{quote} We traced it down to Groovy 1.7.6's Git commit e53591b122bbfd039a03d37f2868ff95b5202c6b{quote}

Thus the bug *might* (I myself can't judge in this) legitimately refer to Groovy after all...;;;","20/Aug/12 03:15;rvowles;And my point is that I believe on consideration of the alternatives, it is expected Groovy behaviour, and if it wasn't, a pure Groovy test case is required to remove other confusing elements from the equation. I have provided this, so at least the Groovy team can easily decide rather than wading through Grails examples.

I went so far as to do so as respected members of my team have hit this problem and would have preferred not to :-);;;","21/Aug/12 12:28;blackdrag;There is actually a problem with interfaces and the dynamic Proxy stuff from Java, which is, what is used here. The dynamic Proxy is the one complaining about the undelcared Exception, but we can't just add something to the interface. 

Step number one on this here would be to test with an actual 1.7. But since 1.7 reached EOL a little while ago, 1.8 is normally the next version a fix for this could be in. Afaik in 1.8 but surely in 2.0 we don't use the proxy anymore, meaning the problem should not appear there anyway;;;","10/Aug/13 05:02;pschumacher;According to blackdrags last comment this should be fixed in Groovy 2.0. Therefore I'm closing this issue. Please reopen if the error still occurs in current Groovy versions.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy compiler generates invalid byte code for local boolean variables that later on are referenced in a closure,GROOVY-5090,12815932,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,lhotari,lhotari,19/Oct/11 04:40,09/Nov/11 10:17,14/Jul/23 06:00,09/Nov/11 10:17,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.4,2.0-beta-1,,,,,,0,,,,,,"Some sample code to show the bug:

{code}
class GroovyBooleanTest {
	public boolean someCall() {
		return true;
	}
	
	public void somecode() {
		boolean val = someCall()
		println val
		def c = {
			val
		}
		boolean val2 = c.call()
		println val2
	}

}
{code}

decompiled with jd-gui:
{code}
import groovy.lang.Closure;
import groovy.lang.GroovyObject;
import groovy.lang.MetaClass;
import groovy.lang.Reference;
import org.codehaus.groovy.runtime.BytecodeInterface8;
import org.codehaus.groovy.runtime.GeneratedClosure;
import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
import org.codehaus.groovy.runtime.callsite.CallSite;
import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;

public class GroovyBooleanTest implements GroovyObject {
	public GroovyBooleanTest()
  {
    GroovyBooleanTest this;
    CallSite[] arrayOfCallSite = $getCallSiteArray();
    MetaClass localMetaClass = $getStaticMetaClass();
    this.metaClass = localMetaClass;
  }

	public boolean someCall() {
		CallSite[] arrayOfCallSite = $getCallSiteArray();
		return DefaultTypeTransformation.booleanUnbox(Boolean.TRUE);
		return DefaultTypeTransformation
				.booleanUnbox((Integer) DefaultTypeTransformation.box(0));
	}

	public void somecode() {
		CallSite[] arrayOfCallSite = $getCallSiteArray();
		boolean val = new Reference((Boolean) DefaultTypeTransformation.box(0));
		Object localObject1;
		boolean bool1;
		if ((__$stMC) || (BytecodeInterface8.disabledStandardMetaClass())) {
			localObject1 = arrayOfCallSite[0].callCurrent(this);
			((Reference) val).set((Boolean) ScriptBytecodeAdapter.castToType(
					localObject1, $get$$class$java$lang$Boolean()));
		} else {
			bool1 = someCall();
			((Reference) val).set((Boolean) ScriptBytecodeAdapter.castToType(
					(Boolean) DefaultTypeTransformation.box(bool1),
					$get$$class$java$lang$Boolean()));
		}
		arrayOfCallSite[1]
				.callCurrent(this, (Boolean) DefaultTypeTransformation
						.box(DefaultTypeTransformation.booleanUnbox(val.get())));
		GroovyBooleanTest._somecode_closure1 local_somecode_closure1 = new GroovyBooleanTest._somecode_closure1(
				this, val);
		Object c = local_somecode_closure1;

		Object localObject2 = arrayOfCallSite[2].call(c);
		boolean val2 = DefaultTypeTransformation.booleanUnbox(localObject2);
		arrayOfCallSite[3].callCurrent(this,
				(Boolean) DefaultTypeTransformation.box(val2));
	}

	static {
		__$swapInit();
		Long localLong1 = (Long) DefaultTypeTransformation.box(0L);
		__timeStamp__239_neverHappen1319016363968 = DefaultTypeTransformation
				.longUnbox(localLong1);
		Long localLong2 = (Long) DefaultTypeTransformation.box(1319016363968L);
		__timeStamp = DefaultTypeTransformation.longUnbox(localLong2);
	}

	class _somecode_closure1 extends Closure implements GeneratedClosure {
		public _somecode_closure1(Object _thisObject, Reference val) {
			super(_thisObject);
			boolean bool = val;
			this.val = bool;
		}

		public Object doCall(Object it) {
			CallSite[] arrayOfCallSite = $getCallSiteArray();
			return this.val.get();
			return null;
		}

		public Boolean getVal() {
			CallSite[] arrayOfCallSite = $getCallSiteArray();
			return (Boolean) ScriptBytecodeAdapter.castToType(this.val.get(),
					$get$$class$java$lang$Boolean());
			return null;
		}

		public Object doCall() {
			CallSite[] arrayOfCallSite = $getCallSiteArray();
			return arrayOfCallSite[0].callCurrent(this, ScriptBytecodeAdapter
					.createPojoWrapper(null, $get$$class$java$lang$Object()));
			return null;
		}

		static {
			__$swapInit();
		}
	}
}
{code}

Invalid byte code is shown in this line:
{code}
		boolean val = new Reference((Boolean) DefaultTypeTransformation.box(0));
{code}

JVM accepts this, but the debugger will show always ""false"" for such variables.


The type information looks invalid also in the closure class:
{code}
	class _somecode_closure1 extends Closure implements GeneratedClosure {
		public _somecode_closure1(Object _thisObject, Reference val) {
			super(_thisObject);
			boolean bool = val;
			this.val = bool;
		}
{code}",Groovy 1.8.3 + Java 1.6.0_27,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 09 10:13:28 UTC 2011,,,,,,,,,,"0|i2bnxb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Oct/11 08:08;blackdrag;after looking at the code, the operands are actually doing the right thing. What seems to be wrong is the local variable table, which ignores, that the value is a Reference instead a boolean now.

So this bug is about a variable table entry done wrong;;;","19/Oct/11 08:13;lhotari;Yes, quite small problem. The invalid local variable table cause problems to the debugger. (in this case the value of a boolean variable always shows up as ""false"" in the debugger);;;","28/Oct/11 07:23;blackdrag;fixed;;;","09/Nov/11 05:35;lhotari;Would it be possible to backport the fix to 1.8.x ? This issue causes confusion for developers trying to debug their Grails 2.0.x code in a debugger.;;;","09/Nov/11 10:13;blackdrag;Lari, thanks for the pointer. I actually had the fix in 1.8.x as well, just forgot to include that in the fix versions here;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unnecessary unboxing and casting in boolean handling in generated bytecode,GROOVY-5089,12818088,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,lhotari,lhotari,19/Oct/11 00:20,09/Nov/11 10:17,14/Jul/23 06:00,09/Nov/11 10:17,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.4,2.0-beta-1,,,,,,1,,,,,,"This sample code:
{code}
class GroovyBooleanTest {
	public boolean someCall() {
		return true;
	}
	
	public void somecode() {
		boolean val = someCall()
		println val
	}

}
{code}

produces very redundant bytecode (decompiled with jd-gui):
{code}
import groovy.lang.GroovyObject;
import groovy.lang.MetaClass;
import org.codehaus.groovy.runtime.BytecodeInterface8;
import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
import org.codehaus.groovy.runtime.callsite.CallSite;
import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;

public class GroovyBooleanTest implements GroovyObject {
    public GroovyBooleanTest()
  {
    GroovyBooleanTest this;
    CallSite[] arrayOfCallSite = $getCallSiteArray();
    MetaClass localMetaClass = $getStaticMetaClass();
    this.metaClass = localMetaClass;
  }

    public boolean someCall() {
        CallSite[] arrayOfCallSite = $getCallSiteArray();
        return DefaultTypeTransformation.booleanUnbox(Boolean.TRUE);
        return DefaultTypeTransformation.booleanUnbox((Integer)DefaultTypeTransformation.box(0));
    }

    public void somecode() {
        CallSite[] arrayOfCallSite = $getCallSiteArray();
        boolean val = 0;
        Object localObject;
        boolean bool1;
        if ((!BytecodeInterface8.isOrigZ()) || (__$stMC) || (BytecodeInterface8.disabledStandardMetaClass())) {
            localObject = arrayOfCallSite[0].callCurrent(this);
            val = DefaultTypeTransformation.booleanUnbox((Boolean)ScriptBytecodeAdapter.castToType(localObject,
                    $get$$class$java$lang$Boolean()));
        }
        else {
            bool1 = someCall();
            val = DefaultTypeTransformation.booleanUnbox((Boolean)ScriptBytecodeAdapter.castToType(
                    (Boolean)DefaultTypeTransformation.box(bool1), $get$$class$java$lang$Boolean()));
        }
        arrayOfCallSite[1].callCurrent(this, (Boolean)DefaultTypeTransformation.box(val));
    }

    static {
        __$swapInit();
        Long localLong1 = (Long)DefaultTypeTransformation.box(0L);
        __timeStamp__239_neverHappen1319001147656 = DefaultTypeTransformation.longUnbox(localLong1);
        Long localLong2 = (Long)DefaultTypeTransformation.box(1319001147656L);
        __timeStamp = DefaultTypeTransformation.longUnbox(localLong2);
    }
}
{code}


This part of the bytecode is interesting:
{code}

            bool1 = someCall();
            val = DefaultTypeTransformation.booleanUnbox((Boolean)ScriptBytecodeAdapter.castToType(
                    (Boolean)DefaultTypeTransformation.box(bool1), $get$$class$java$lang$Boolean()));
{code}
bool1 and val are both already booleans. It goes through many unnecessary layers before assigning val to bool1.

",Groovy 1.8.3 + Java 1.6.0_27 on Ubuntu Linux 10.04.3,pred,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 02 05:08:43 UTC 2011,,,,,,,,,,"0|i2c833:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Oct/11 00:29;lhotari;What is also quite interesting is that the someCall method has 2 return statements in the bytecode

(output produced by Eclipse Bytecode outline plugin: http://andrei.gmxhome.de/bytecode/)
{code}
  public someCall() : boolean
   L0
    INVOKESTATIC GroovyBooleanTest.$getCallSiteArray() : CallSite[]
    ASTORE 1
   L1
    LINENUMBER 4 L1
    GETSTATIC Boolean.TRUE : Boolean
    INVOKESTATIC DefaultTypeTransformation.booleanUnbox(Object) : boolean
    IRETURN
   L2
    LDC 0
    INVOKESTATIC DefaultTypeTransformation.box(int) : Object
    CHECKCAST Integer
    INVOKESTATIC DefaultTypeTransformation.booleanUnbox(Object) : boolean
    IRETURN
    LOCALVARIABLE this GroovyBooleanTest L0 L2 0
    MAXSTACK = 1
    MAXLOCALS = 2
{code}


decompiled with JD-Gui:
{code}
    public boolean someCall() {
        CallSite[] arrayOfCallSite = $getCallSiteArray();
        return DefaultTypeTransformation.booleanUnbox(Boolean.TRUE);
        return DefaultTypeTransformation.booleanUnbox((Integer)DefaultTypeTransformation.box(0));
    }
{code}

This must be a bug.;;;","19/Oct/11 00:52;lhotari;What is this code generated in so many places:
{code}
if ((!BytecodeInterface8.isOrigZ()) || (__$stMC) || (BytecodeInterface8.disabledStandardMetaClass())) {
{code}
If that's really necessary, please ""cache"" the value of ""(!BytecodeInterface8.isOrigZ()) || (__$stMC) || (BytecodeInterface8.disabledStandardMetaClass())"" .;;;","19/Oct/11 07:53;blackdrag;this is not really a critical issue. As for the second return, it is dead code, it won't have any reasonable effect. The big IF you are wondering about, is the guard for the primitive optimization code, and it cannot be cached, unless you habe a suggestion. A better strategy would be to not to issue the optimization in this case. I have not yet added code that tests if the optimizations make sense in that case at all. Just returning a constant is maybe not a case in which we should do this kind of thing.

Part of the optimizations I added is to gradually change values from being always boxed to be used native as they are. This is currently implemented only for int and double, but not for boolean. That is why you see the unboxing.;;;","19/Oct/11 08:01;lhotari;Thanks for the answer. It would be cool to get the boolean optimizations too. Groovy doesn't look very clean when you go to the bytecode level without fixing this issue. Please schedule the change so that it gets fixed some time in the near future (1.8.4 / 1.8.5 ?).

A more critical issue is GROOVY-5090 . I was actually hunting for that one (debugger showed ""false"" for a boolean value dispite the real value) when I noticed this unboxing/boxing redundancy.;;;","27/Oct/11 10:48;blackdrag;fixed;;;","27/Oct/11 10:52;pred;Aleluia :) Thx thx thx thx;;;","02/Nov/11 04:35;nikolaj49a;Is it possible to add code to test if the optimizations make sense in order to remove unecessary if statements:
{noformat}
if ((!BytecodeInterface8.isOrigZ()) || (__$stMC) || (BytecodeInterface8.disabledStandardMetaClass())) {
{noformat} 
I see this in situations where I do simple String assignments.
Also it confuses Cobertura to think that the assignment is actually a branch condition.;;;","02/Nov/11 05:08;blackdrag;We have now tests that test that check the generated bytecode, so we can surely write tests. More important is to get a list of situations in which thee should be no optimization guard. String assignments normally don't trigger that.

Maybe I should introduce some kind of optimization weight and a threshold, so that I optimize only if the weight is higher than the threshold. But even then I first need to know when it does not make sense.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Variables from a static import scope used in GStrings resolve to null under certain conditions,GROOVY-5087,12815924,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,dgrnbrg,dgrnbrg,18/Oct/11 10:51,13/May/12 03:30,14/Jul/23 06:00,13/Feb/12 05:08,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,,,,,0,,,,,,"I would expect ""$logDir/foo.txt"" to be ""foo/foo.txt"", since I just assigned logDir; however, this doesn't happen. I do not understand why this happens.

Currently, the 2nd and 3rd assertions fail (comment out the 2nd to see the third fail)",,dgrnbrg,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/Oct/11 10:51;dgrnbrg;MinCase.groovy;https://issues.apache.org/jira/secure/attachment/12722981/MinCase.groovy","18/Oct/11 10:51;dgrnbrg;StaticContainer.groovy;https://issues.apache.org/jira/secure/attachment/12722527/StaticContainer.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 13 05:08:50 UTC 2012,,,,,,,,,,"0|i2c3av:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"21/Oct/11 00:44;roshandawrani;Just to de-link the issue from GString - the following version of {{MinCase.groovy}} also fails:

{code}
import static StaticContainer.*
class FooTest extends GroovyTestCase {
    void test1() {
        logDir = 'initial'
        assert logDir == 'initial'

        def map = [:]
        map[logDir] = ''
        assert map.containsKey('initial')
    }
}
{code}

Basically anything with the following form will fail:
{noformat}
<any allowed expression containing statically imported variable> = <whatever>
{noformat}

It's because StaticImportVisitor wrongly concludes just by the presence of static property on the left side that it needs to call the setter for it, instead of getter. 

It does not see on the left side of ""equals"" expression, where exactly does the statically imported variable figure. It's not always {{ logDir = ''}}. It can also be {{map[logDir] = ''}}, where it should not make it {{map[setLogDir()] = ''}}, but make it {{map[getLogDir()] = ''}};;;","13/Feb/12 05:08;paulk;hopefully should be fixed now, thanks for reporting the issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovydoc can't handle @link tags in package-info.java,GROOVY-5084,12815946,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pniederw,pniederw,18/Oct/11 04:14,12/Feb/12 04:03,14/Jul/23 06:00,06/Feb/12 07:06,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,GroovyDoc,,,,0,,,,,,"A @link tag in package-info.java abruptly stops the comment shown in the generated Groovydoc. Compare http://gradle.org/releases/latest/docs/javadoc/index.html to http://gradle.org/releases/latest/docs/groovydoc/index.html.

Would it help to provide a package-info.groovy as well?",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 06 07:06:04 UTC 2012,,,,,,,,,,"0|i2cdsn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Feb/12 02:36;paulk;Peter, can you try a recent snapshot to see if the problem has been solved? I have added a fix which works for the small test case I have here locally but it would be good to try it with something more substantial. Thanks, Paul.;;;","06/Feb/12 07:06;paulk;Closing for now. Peter, if you spot any problems, please reopen or create an additional issue with a more specific error. Thanks, Paul.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sometimes invalid inner class reference left in .class files produced for interfaces,GROOVY-5082,12818120,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,aclement,aclement,17/Oct/11 13:45,01/Feb/12 11:10,14/Jul/23 06:00,01/Feb/12 11:10,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,class generator,,,,0,,,,,,"Compile this:

{code}
interface X {
  public String compute();
}
{code}

Upon javap'ing the result we see this InnerClass attribute:

{code}
public interface X
  SourceFile: ""X.groovy""
  InnerClass: 
   #10= #9 of #2; //""1""=class X$1 of class X
  minor version: 0
  major version: 47
  Constant pool:
{code}

to X$1.  But there is no X$1 produced on disk.  Some environments (e.g. eclipse) are attempting to make sense of this and failing with a 'cant find type' message as they can't find the class file.  groovy shouldn't be including these references.  I believe a decision is made up front that one of these types will be created and then later a decision is taken that there is no need to produce one, but the original reference is left in the interface type (and so it is captured in the attribute).

I changed two things to fix this:

1. Added a method to ClassNode so that it could be told to forget about an interface like this:
{code}
    public void forgetInnerClass(InnerClassNode icn) {
        if (innerClasses!=null) {
        innerClasses.remove(icn);
        }
    }
{code}

2. And then in the code that decides it doesn't need one (in AsmClassGenerator), forget is called so that the InnerClass attribute isn't added for it:
{code}
protected void createInterfaceSyntheticStaticFields() {
    if (referencedClasses.isEmpty()) {
        controller.getClassNode().forgetInnerClass(controller.getInterfaceClassLoadingClass()); // my new line
        return;
    }
    ...
{code}

this appears to fix it and continues to pass all the groovy tests.",,mauromol,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 01 11:10:39 UTC 2012,,,,,,,,,,"0|i2c1rr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Feb/12 11:10;blackdrag;should be fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inner type default constructors incorrectly tagged synthetic,GROOVY-5080,12818118,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,aclement,aclement,16/Oct/11 14:14,24/Dec/11 03:08,14/Jul/23 06:00,28/Nov/11 07:37,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,class generator,,,,0,,,,,,"Possibly groovy is doing this by design, but I suspect not.  When compiling this code:

{code}
class Outer {
  static class Inner { }
}
{code}

groovy creates a public constructor for the Outer.Inner type (because it doesn't have one) but it marks it synthetic.  Synthetic members cannot be called from user written code.  So once compiled I can't write this java code:

{code}
class Foo {
  public void m() {
    new Outer.Inner();
  }
}
{code}

As it will complain the constructor isn't there (it is, but it is synthetic).  Javac does not make these constructors synthetic, I can't think of a good reason why groovy should either (?)

To fix it, change the InnerClassVisitor.visitClass method.  Where it reads (line 73 for me):

{code}
innerClass.addConstructor(PUBLIC_SYNTHETIC, new Parameter[0], null, null);
{code}

change it to:

{code}
innerClass.addConstructor(ACC_PUBLIC, new Parameter[0], null, null);
{code}

This change appears to continue to pass all the tests.

Note you won't see the problem if you compile all the code together (both java and groovy) - I haven't looked but of course the stubs cannot indicate syntheticness before calling javac (and if the stubs contained no ctor in that inner type, it would get the javac behaviour of a non synthetic one).  In eclipse the problem won't happen on a full build because default constructors are not marked synthetic by the conversion layer (between groovy and eclipse types).  It can be seen on an incremental build in eclipse (of the java code) because it then uses the bytecode form of the groovy types to satisfy dependencies.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 28 07:37:01 UTC 2011,,,,,,,,,,"0|i2c8bb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Nov/11 07:06;roshandawrani;Any objection if I make this small change? Looks harmless and inconsistent with Java.;;;","27/Nov/11 09:12;blackdrag;feel free to do so, but please ensure the constructor for an AIC is still synthetic;;;","28/Nov/11 07:37;roshandawrani;Applied the change. AIC handling wasn't affected by it.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler should not allow 2 methods with same name and no argument to return different types,GROOVY-5078,12815922,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,melix,melix,14/Oct/11 04:16,14/Oct/13 16:53,14/Jul/23 06:00,21/Aug/13 07:24,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-beta-2,,,,,,,0,contrib,,,,,"This compiles fine, but it shouldn't be allowed : 
{code}
class A {
   int foo() { 1 }
   long foo() {2L }
}
new A().foo()
{code}

(returns 1)
",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 21 07:24:38 UTC 2013,,,,,,,,,,"0|i2bwan:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Aug/13 07:24;blackdrag;implemented;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyCastException after upgrade from Groovy 1.7.10 to 1.8.3,GROOVY-5077,12815850,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,veita,veita,14/Oct/11 04:12,08/Mar/22 12:16,14/Jul/23 06:00,27/May/21 14:44,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,parser,,,,0,,,,,,"Have a catetegory with
{code}
  public static Object asType(Byte p_byteSelf, Class<?> p_class)
  {
    //...
    return new MyClass(p_byteSelf);
  }
{code}

With Groovy 1.7.10 the script
{code}
  def v
  v = (byte)15 as MyClass  
{code}
worked fine.

With Groovy 1.8.3 a org.codehaus.groovy.runtime.typehandling.GroovyCastException is thrown.

Has the operator precedence been changed?

",n.a.,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 20 02:32:21 UTC 2017,,,,,,,,,,"0|i2bmgv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Oct/11 05:24;melix;Could you try with :
{code}
def v
v = (Byte)15 as MyClass
{code}

Primitives are handled differently since 1.8.;;;","14/Oct/11 06:15;veita;Same problem:
{quote}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: testByteAsMyClass.groovy: Cannot cast object 'MyClass@319c0bd6' with class 'MyClass' to class 'java.lang.Byte'
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToNumber(DefaultTypeTransformation.java:146)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:241)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:599)
	at testIntegerAsValueHolder$_run_closure1.doCall(testIntegerAsValueHolder.groovy:33)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:884)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:46)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at testIntegerAsValueHolder$_run_closure1.doCall(testIntegerAsValueHolder.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:884)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:404)
	at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.use(GroovyCategorySupport.java:106)
	at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.access$400(GroovyCategorySupport.java:64)
	at org.codehaus.groovy.runtime.GroovyCategorySupport.use(GroovyCategorySupport.java:246)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.use(DefaultGroovyMethods.java:359)
	at org.codehaus.groovy.runtime.dgm$875.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoMetaMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:308)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:52)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:46)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:145)
	at testIntegerAsValueHolder.run(testIntegerAsValueHolder.groovy:4)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:580)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:627)
	at MyTestCase.test(MyTestCase.java:38)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at junit.framework.TestCase.runTest(TestCase.java:168)
	at junit.framework.TestCase.runBare(TestCase.java:134)
	at junit.framework.TestResult$1.protect(TestResult.java:110)
	at junit.framework.TestResult.runProtected(TestResult.java:128)
	at junit.framework.TestResult.run(TestResult.java:113)
	at junit.framework.TestCase.run(TestCase.java:124)
	at junit.framework.TestSuite.runTest(TestSuite.java:243)
	at junit.framework.TestSuite.run(TestSuite.java:238)
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:83)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
{quote}

A related problem occurred in a production environment with the code snippet
{code}
XTextCursor curText = (XTextCursor)xTextDocument.getText().createTextCursor()
{code}

which throws the exception
{quote}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'interface com.sun.star.text.XTextCursor' with class 'java.lang.Class' to class 'com.sun.star.text.XTextCursor'
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:338)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:599)
	at script6C28FB038C922529DCC76FDC15A4946276D0CA0E.office2pdf(script6C28FB038C922529DCC76FDC15A4946276D0CA0E.groovy:108)
	at script6C28FB038C922529DCC76FDC15A4946276D0CA0E.run(script6C28FB038C922529DCC76FDC15A4946276D0CA0E.groovy:350)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1054)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:884)
	at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:793)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:776)
{quote}

Unfortunately we generally cannot fix these errors since they may occur in code written by our customers.

;;;","20/Jan/17 02:32;daniel_sun;the new parser Parrot will parse ""(byte)15 as MyClass"" as follows:
((byte)15) as MyClass

Can you provide some runnable test case?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
the shorthand notation for Grab isn't working correctly,GROOVY-5076,12815710,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,14/Oct/11 01:14,07/Apr/15 19:07,14/Jul/23 06:00,14/Oct/11 02:20,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.4,2.0-beta-1,,,,,,0,,,,,,"The following should work:
{code}
@Grab('commons-digester:commons-digester:2.1;transitive=false')
{code}
Instead, a compilation error is thrown because the 'false' value is left as a String not converted to a boolean.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 14 02:20:14 UTC 2011,,,,,,,,,,"0|i2cfrj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Oct/11 02:20;paulk;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SwingBuilder never shuts down the default executor service,GROOVY-5074,12814689,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,aalmiray,melix,melix,12/Oct/11 14:23,24/Jan/14 13:18,14/Jul/23 06:00,10/Jan/13 11:47,1.8.2,1.8.3,1.9-beta-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.0-rc-1,,,Groovy Console,,,,3,contrib,,,,,"If you use the swingbuilder.doOutside() method, the execution is delegated to an executor service which is set globally (static variable). The problem is that when application exits, the executor service is never shutdown, so the VM won't exit.

Steps to reproduce :

1. Open Groovy Console
2. any code like ""println 'hello'"" will do
3. Open AST Browser (which internally calls doOutside)
4. Exit the console with the menu. The application won't return
5. kill -3 <pid of the groovy console> to obtain a thread dump

The thread dump shows threads waiting from the executor service :

{code}
""pool-1-thread-2"" prio=10 tid=0x0000000040cbe800 nid=0x1204 waiting on condition [0x00007f1a06478000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x0000000784fe14b0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1987)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:399)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:947)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)
	at java.lang.Thread.run(Thread.java:662)

""pool-1-thread-1"" prio=10 tid=0x0000000041c6b800 nid=0x1203 waiting on condition [0x00007f1a06579000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x0000000784fe14b0> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:156)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1987)
	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:399)
	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:947)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)
	at java.lang.Thread.run(Thread.java:662)

{code}

",,aalmiray,cutterslade,dhalbert,melix,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 24 13:18:08 UTC 2014,,,,,,,,,,"0|i2cohr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Nov/12 15:47;cutterslade;I've seen this same issue in version 2.0.5, using just the groovy console (on windows). Steps to reproduce:
# Start the groovy console from the command line,
{code}
> groovyConsole.bat
{code}
# Open a file, any file will do,
# Close the console.

The {{groovyConsole.bat}} command will not return. Getting a thread dump at this point shows a similar non-daemon thread still running:
{noformat}
""pool-1-thread-1"" prio=6 tid=0x0000000008dd6000 nid=0x1564 waiting on condition [0x000000001a09f000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000f85980e8> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1043)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1103)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
        at java.lang.Thread.run(Thread.java:722)
{noformat};;;","05/Jan/13 03:55;pschumacher;Possible solutions:
1. Add a method to shutdown the ExecutorService of SwingBuilder
2. Remove the ExecutorService
3. ???
;;;","07/Jan/13 08:17;aalmiray;The problem appears to be that the ExecutorService is never shutdown, because all Threads created by the ExecutorService are not daemon threads the application will 'hang' upon closing. Here are some possible solutions:

 1. Revert back to spawning a new Thread (*sigh*)
 2. Use a custom ThreadFactory that calls setDaemon(true) on the newly created Threads (risky?)
 3. Keep track of how many ExecutorServices are instantiated and shut them down at the right time (quite difficult with plain SwingBuilder).

FYI option #3 is what we decided to apply in Griffon (see https://github.com/griffon/griffon/commit/feed358e20f76d7b2cc4d3df779315310ac8a0b4) as we can clearly identify the moment when the application must shutdown.
;;;","07/Jan/13 08:24;melix;mmm, solution #2 looks ok to me. It would be risky if the thread was killed, but I don't think the JVM kills any thread, it just waits until it's done then shuts down the VM.;;;","07/Jan/13 12:30;pschumacher;""Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.""
source: [http://docs.oracle.com/javase/6/docs/api/java/lang/Thread.html#setDaemon%28boolean%29]

So I guess daemon threads are killed on exit. This is confirmed by:

""When the JVM halts, any remaining daemon threads are abandoned  finally blocks are not executed, stacks are not unwound  the JVM just exits. Daemon threads should be used sparinglyfew processing activities can be safely abandoned at any time with no cleanup. In particular, it is dangerous to use daemon threads for tasks that might perform any sort of I/O.""
source: Brian Goetz - Java Concurrency in Practice, p. 165

Therefore ""1. Revert back to spawning a new Thread"" looks like the best option. Else users could be in for potentially unpleasant surprises.;;;","08/Jan/13 02:44;melix;You're right, I forgot about that... Reading Brian Goetz is always useful :) So, going back to plain old threads is a solution, but not really enjoyable...

Google Guava has a nice tool to deal with this problem. It's basically a combination of solution 2 and a JVM shutdown hook to wait for the tasks to be complete: http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/MoreExecutors.html#getExitingExecutorService(java.util.concurrent.ThreadPoolExecutor)

Maybe we should implement something like this in Groovy.;;;","08/Jan/13 02:53;aalmiray;Perhaps, though in my experience ShutdownHooks are called after all non-daemon threads are stopped/finish (but I may be missing something here). So, I can revert back the code to plain Threads just for the sake of unsticking this issue. We can decide later how to optimize it :-);;;","08/Jan/13 08:01;aalmiray;Pull request sent https://github.com/groovy/groovy-core/pull/103;;;","08/Jan/13 08:29;melix;I merged your pull request in both {{master}} and {{2.0.x}}. Do you think we should close this issue and create another one as an improvement or keep this one open?;;;","08/Jan/13 08:41;aalmiray;I don't like that fact of creating Threads and then throwing them away. I guess it won't hurt to close this one and open an improvement ticket. We can revisit performance issues at a later date, don't you think?;;;","08/Jan/13 08:45;melix;Agreed;;;","10/Jan/13 11:11;pschumacher;should have fix version 2.1.0-rc-1;;;","24/Jan/14 13:18;dhalbert;I'm a little late, since this is closed, but I don't see the improvement ticket mentioned above:

Note that the semantics of using Thread.start() vs ExecutorService.submit() are different for exceptions inside doOutside{}. ExecutorService.submit() uses a Future which traps exceptions until someone calls Future.get(), which doOutside() did not call. This does not happen with a simple Thread.

I ended up asking and then self-answering a SO question on this: http://stackoverflow.com/questions/21336367/handling-exceptions-in-groovy-swingbuilder-dooutside;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SecureASTCustomizer receiver needs documentation,GROOVY-5068,12815915,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,driscoll,driscoll,09/Oct/11 13:09,10/Jul/13 04:42,14/Jul/23 06:00,04/Jul/13 14:42,1.9-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,Compiler,Documentation,,,0,,,,,,"SecureASTCustomizer offers the ability to blacklist receiver methods.  Without at least a minor bit of documentation, I'm concerned that this will result in the naive user creating ""secure"" environments that are anything but.

In particular, in order to stop execution of a method on a class (I'll assume System.exit() for this example), the following configuration is required:

{code}
                receiversClassesBlackList = [
                    Object,
                    Script,
                    GroovyShell,
                    Eval,
                    System,
                ].asImmutable()
                
                expressionsBlacklist = [MethodPointerExpression].asImmutable()
{code}

It's pretty certain that this would be a surprise to most users.

We should fix this in documentation, at a minimum, and I'd also propose that we provide a new example class using Blacklists.

We should also detail that in the event of using whitelist receivers, the above classes must also not be specified.",,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Mar/12 14:27;driscoll;patchfile.txt;https://issues.apache.org/jira/secure/attachment/12722162/patchfile.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 04 14:42:01 UTC 2013,,,,,,,,,,"0|i2cpdr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Oct/11 10:18;driscoll;I'm currently working on a ""fix"" that I'll attach to this bug shortly, once I've figured out how git works...;;;","17/Feb/12 03:58;melix;Jim, did you have time to work on this?;;;","17/Mar/12 14:27;driscoll;Proposed fix is now attached to the bug.

Includes doc fix for SecureASTCustomizer, a new BlacklistingShell (which is the secure equivalent of ArithmeticShell), and a test package for the same.

Sorry this took so long - the fix was actually done a rather long time ago, but I'd put it aside while I tried to make time for working with the (new to me) environment of the Groovy source code.

Let me know if you have any questions.  Since this is dealing with security, I'd appreciate it if at least one other person gave this a through review before releasing these changes, even though it's ""just an example program"".;;;","02/Jan/13 03:28;pschumacher;Any updates Cedric?;;;","04/Jul/13 14:31;pschumacher;I created a [pull request|https://github.com/groovy/groovy-core/pull/215] out of Jims patch to make the review/merge easier.;;;","04/Jul/13 14:42;pschumacher;I merged the pull request. 

Thanks to Jim for reporting the issue and providing the patch. 

Thanks to Cedric for the review.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Cannot set ""-Werror"" javac option when using Groovyc ant task.",GROOVY-5063,12815706,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,ldaley,ldaley,04/Oct/11 05:46,24/Dec/11 03:08,14/Jul/23 06:00,28/Nov/11 04:54,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,Compiler,,,,0,,,,,,"When trying to configure the joint compiler to treat java compile warnings as errors I tried to set the following javac args:

* -Xlint:all
* -Werror

I found that -Xlint:all worked, but -Werror gave me an error saying that it was an unrecognised option. After some digging it seems that the joint compiler prefixes all options bound for javac with -F, which means the lint option was transformed to ""-FXlint:all"" but the -Werror option didn't get this same transformation. If I manually added the ""-F"" making it ""-FWerror"" everything worked as it should.

I went looking for whereabouts this prefixing gets applied to try and determine why it wasn't happening to ""-Werror"" but couldn't find it.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 06 12:35:17 UTC 2011,,,,,,,,,,"0|i2bp27:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Oct/11 12:39;roshandawrani;-X options become -FX in joint compilation here: https://github.com/groovy/groovy-core/blob/GROOVY_1_9_BETA_3/src/main/org/codehaus/groovy/ant/Groovyc.java#L751;;;","04/Oct/11 12:47;roshandawrani;javac -help doesn't show -W options. Is ""-Werror"" an officially supported option?

http://weblogs.java.net/blog/tball/archive/2006/11/get_medieval_on.html calls 'Werror' a hidden option.

Although, it should probably do no harm to allow it if Ant allows it.;;;","04/Oct/11 12:54;roshandawrani;If no one has any objection, I can add {{jointOptions.add(optionStr.replace(""-W"", ""-FW""));}} to support -Werror in joint compilation.;;;","04/Oct/11 13:27;blackdrag;what -W options do exist?;;;","04/Oct/11 14:35;roshandawrani;>> what -W options do exist?

Looking at JDK make files, I can see options like:

{noformat}
-Wno-unused 
-Wno-parentheses
-Werror
{noformat}

But why? Does the decision depend on what options are there? Or is it more like being a pass through to Javac like Ant, and not bother about the specifics of the options?;;;","04/Oct/11 14:54;blackdrag;The amount was interesting to me to see if we do that for a general thing or for just a few options. -X is used with in many combinations, so it is really worth it. -W options is partly undocumented and kind of non-official. Also there exists a way to get this working.

Roshan and Luke, you guys think this is really worth it?;;;","04/Oct/11 15:00;blackdrag;One more thing to say... I actually think this kind of forwarding is a bit problematic for us. Adding -W as a forwarding means we cannot use it ourselves. I actually would have been against the -X version, but I missed that issue I think. The only reason I am considering this here at all, is because we have -X. Which makes it a bit a weak argumentation chain for me.;;;","04/Oct/11 15:09;ldaley;Jochen: so are you proposing that we do nothing and require users to prefix the args themselves?;;;","04/Oct/11 15:14;blackdrag;I am not yet proposing, I want more to see your opinions on this;;;","04/Oct/11 15:18;ldaley;Anything short of being able to just specify the same args I would specify to javac is going to be confusing. It would just be implementation detail leaking through.;;;","04/Oct/11 15:49;blackdrag;but two things speak against that argumentation:
(1) not all java compilers support that option
(2) you give this option to the groovy compiler in the first place, not the java compiler. Controlling the java compiler is supposed to work with -F and -J. ;;;","04/Oct/11 16:52;ldaley;Not sure that (1) is relevant, if the Java compiler doesn't support it should complain and not Groovy.

As for (2), how so? If I nest a <javac> element I would expect as a user for it to be the same as a regular <javac> element. The fact that it behaves  differently because it is nested inside <groovyc> is not obvious at all (and shouldn't be).;;;","04/Oct/11 21:21;roshandawrani;I also happen to think that Groovy should not block -W options in reaching javac from nested <javac> elements. 

It seems inconsistent that in joint compilation, a user can pass one option to javac as <compilerarg value=""-Xlint:all"">, and for other, he needs to do <compilerarg value=""-FWerror"">.;;;","05/Oct/11 06:35;blackdrag;Sorry, guys, I did totally oversee that this is for the ant task, not for the command line. 

But then there should be actually a more general approach. Not only the -W and -X options should be given through, but everything. For example the -g variants. Only problem in that is we would have to check for an assignment, to then use -J, or -F if there is none. The Jikes compiler for example has +K options. Though I think the javac element we have does not support a jikes in fork mode.

What do you think Roshan, Luke?;;;","18/Oct/11 10:34;ldaley;I guess there's not many other options than just amending the list as new args are found.;;;","27/Nov/11 06:06;roshandawrani;+1 to Luke's suggestion. Otherwise it is un-necessarily stuck holding even the options that we know about.;;;","27/Nov/11 09:14;blackdrag;ok then.. Roshan, you want to take the issue?;;;","28/Nov/11 04:54;roshandawrani;Done. In joint compilation, -W options are now passed to javac like -X options.;;;","06/Dec/11 12:35;ldaley;Nice one Roshan, thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect translation of class property which type has array as enclosed type argument,GROOVY-5061,12815859,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,almo,almo,03/Oct/11 03:49,24/Dec/11 03:08,14/Jul/23 06:00,29/Nov/11 09:56,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.5,2.0-beta-2,class generator,Stub generator / Joint compiler,,,0,,,,,,"When compiling via Ant Groovyc task, the compiler generates erroneous Java from the two following files:

{code:title=B.groovy}
class B {
    Map<String, Map<String, Integer[]>> columnsMap = [:]
}
{code}


{code:title=C.java}
public class C {
    public void f(B b) {
        System.out.println(b.getColumnsMap());
    }
}
{code}

Ant compilation results in many lines with the same error (full log attached):

{noformat}
  [groovyc] /tmp/groovy-generated-2531065055182916850-java-source/B.java:16: ';' expected
  [groovyc] public  java.util.Map<java.lang.String, java.util.Map<java.lang.String, [Ljava.lang.Integer;>> getColumnsMap() { return (java.util.Map<java.lang.String, java.util.Map<java.lang.String, [Ljava.lang.Integer;>>)null;}
{noformat}

Notes:
* if C.java is excluded from build, everything compiles fines.
* Eclipse plug-in compiles code fine too.

And if it's needed, the Ant task:

{code:xml}
    <target name=""compile2"" depends=""check_java_version,prepare_libs"">
        <mkdir dir=""temp_src/classes""/>

        <path id=""groovy.class.path"">
            <fileset dir=""${lib.dir}/groovy"" includes=""*.jar""/>
        </path>

        <taskdef name=""groovyc""
                 classname=""org.codehaus.groovy.ant.Groovyc""
                 classpathref=""groovy.class.path"" />

        <groovyc srcdir=""temp_src""
                 destdir=""temp_src/classes""
                 listfiles=""yes""
                 stacktrace=""yes""
                 verbose=""yes"">
            <classpath refid=""arms.class.path""/>
            <javac source=""1.6"" target=""1.6""/>
        </groovyc>
    </target>
{code}","{noformat}
amonakhov@marvin:~$ uname -a
Linux marvin 2.6.39-1-amd64 #1 SMP Tue May 24 14:34:19 UTC 2011 x86_64 GNU/Linux
amonakhov@marvin:~$ java -version
java version ""1.6.0_26""
Java(TM) SE Runtime Environment (build 1.6.0_26-b03)
Java HotSpot(TM) 64-Bit Server VM (build 20.1-b02, mixed mode)
amonakhov@marvin:~$ ant -version
Apache Ant(TM) version 1.8.2 compiled on September 22 2011
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/Oct/11 03:49;almo;ant_error.txt;https://issues.apache.org/jira/secure/attachment/12722874/ant_error.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 31 03:21:44 UTC 2011,,,,,,,,,,"0|i2bw87:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Oct/11 15:00;blackdrag;Paul, didn't we fix this recently?;;;","31/Oct/11 03:21;almo;Guys, any progress on this issue?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
?TreeSet? Comparators not correctly comparing everything - Compares only a subset,GROOVY-5056,12818114,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,jason@bobberinteractive.com,jason@bobberinteractive.com,29/Sep/11 23:11,02/Nov/11 15:34,14/Jul/23 06:00,01/Oct/11 08:16,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.4,1.9-beta-4,,,,,,0,,,,,,"Hi everyone

This fails with the latest 1.8.3 snapshot - But works in 1.7.10

{code}
import java.util.logging.Logger;
import org.junit.*;

class Breaker {
   static Logger log = Logger.getLogger(getName())
   
   @Test
   void testBreaking() {
      def comparator = [compare:
         {a,b-> 
            def retVal = a.x.compareTo(b.x)
            log.info(""Comparing ${a.x} to ${b.x} and returning ${retVal}"")
            return retVal }
      ] as Comparator
   
      def ts1 = new TreeSet(comparator)
      ts1.addAll([
         new ToCompare(x:""1""),
         new ToCompare(x:""2""),
         new ToCompare(x:""3"")
      ])
       
      def ts2 = new TreeSet(comparator)
      ts2.addAll([
         new ToCompare(x:""1""),
         new ToCompare(x:""2""),
         new ToCompare(x:""3"")
      ])
      
      def difference = ts1 - ts2
      assert difference.size() == 0
   }
}

class ToCompare {
   String x
}
{code}

The test works if you pass the same list of the same objects to ts1 and ts2.  Passing in different objects with the same content fails.

For 1.8.x, the logs spit out:
{code}
Sep 29, 2011 9:03:57 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 2 to 1 and returning 1
Sep 29, 2011 9:03:57 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 3 to 1 and returning 2
Sep 29, 2011 9:03:57 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 3 to 2 and returning 1
Sep 29, 2011 9:03:57 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 2 to 1 and returning 1
Sep 29, 2011 9:03:57 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 3 to 1 and returning 2
Sep 29, 2011 9:03:57 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 3 to 2 and returning 1
{code}

For 1.7.10, the logs spit out:
{code}

Sep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 2 to 1 and returning 1
Sep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 3 to 1 and returning 2
Sep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 3 to 2 and returning 1
Sep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 2 to 1 and returning 1
Sep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 3 to 1 and returning 2
Sep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 3 to 2 and returning 1
Sep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 1 to 2 and returning -1
Sep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 1 to 1 and returning 0
Sep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 2 to 2 and returning 0
Sep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 3 to 2 and returning 1
Sep 29, 2011 9:07:09 PM sun.reflect.NativeMethodAccessorImpl invoke0
INFO: Comparing 3 to 3 and returning 0
{code}

Please let me know if there's anything else ya'll need!

Cheers
Jason Griffith",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Sep/11 00:57;roshandawrani;Groovy5056_v1_8_3.diff;https://issues.apache.org/jira/secure/attachment/12722589/Groovy5056_v1_8_3.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 02 15:34:16 UTC 2011,,,,,,,,,,"0|i2cd53:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"30/Sep/11 00:57;roshandawrani;Attaching a patch, that also fixes the following:

{code}
@Test
void testBreaking2() {
  def comparator = [compare:
     {a,b-> 
        def retVal = a.x.compareTo(b.x)
        println(""Comparing ${a.x} to ${b.x} and returning ${retVal}"")
        return retVal }
  ] as Comparator

  def ts1 = new TreeSet(comparator)
  ts1.addAll([
     new ToCompare(x:""1""),
     new ToCompare(x:""2""),
     new ToCompare(x:""3"")
  ])

  def difference = ts1 - new ToCompare(x:""3"")
  assert difference.size() == 2
}
{code};;;","30/Sep/11 06:34;blackdrag;Roshan, the fix looks good to me, but testcases are needed. ;;;","02/Nov/11 15:34;jason@bobberinteractive.com;Just tried out the current 1.8.4 snapshot today.  All of our tests pass!  Thank you all very much for your swift and capable handling of these issues! ;)
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CharsetToolkit javadoc references private guessEncoding() method in the example usage,GROOVY-5052,12815893,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,guillaume,jwagenleitner,jwagenleitner,29/Sep/11 01:15,14/Oct/11 00:28,14/Jul/23 06:00,12/Oct/11 08:35,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.4,1.9-beta-4,GroovyDoc,,,,0,,,,,,"CharsetToolkit javadocs (http://groovy.codehaus.org/api/groovy/util/CharsetToolkit.html) for the class has the following code example:

{code}
...
// guess the encoding
Charset guessedCharset = CharsetToolkit.guessEncoding(file, 4096);
...
{code}

The instance method guessEncoding() is private and is also referenced in other public method javadoc.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 12 08:35:35 UTC 2011,,,,,,,,,,"0|i2c8if:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Sep/11 01:22;jwagenleitner;Added a Github pull request (https://github.com/groovy/groovy-core/pull/2).;;;","12/Oct/11 08:35;guillaume;I merged your javadoc fixes, thank you.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
File.getText() should close the streams,GROOVY-5049,12815711,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,balor123,balor123,27/Sep/11 09:20,14/Oct/11 00:28,14/Jul/23 06:00,30/Sep/11 21:21,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.4,1.9-beta-4,,,,,,0,,,,,,"Performing a lot of system calls causes Groovy to die on Linux with an IOException for ""Too many open files"". The cause is streams which are left open by system calls:

(1..n).each { ""ls"".execute().text }

This method should be changed to close all streams after it gets the text from them.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5058,,,,"27/Sep/11 16:06;balor123;UsageAnalyzer2.groovy;https://issues.apache.org/jira/secure/attachment/12722356/UsageAnalyzer2.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 30 21:21:31 UTC 2011,,,,,,,,,,"0|i2c0un:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Sep/11 09:58;balor123;Discussed here:
http://stackoverflow.com/questions/7570353/why-do-i-get-too-many-open-files-errors;;;","27/Sep/11 10:16;blackdrag;Uri, what version of Groovy are you talking about? File.text will use BuffereReader.text and the code for that looks like this:{code:Java}
    public static String getText(BufferedReader reader) throws IOException {
        StringBuilder answer = new StringBuilder();
        // reading the content of the file within a char buffer
        // allow to keep the correct line endings
        char[] charBuffer = new char[8192];
        int nbCharRead /* = 0*/;
        try {
            while ((nbCharRead = reader.read(charBuffer)) != -1) {
                // appends buffer
                answer.append(charBuffer, 0, nbCharRead);
            }
            Reader temp = reader;
            reader = null;
            temp.close();
        } finally {
            closeWithWarning(reader);
        }
        return 
    }
{code}
I know we had problems with that kind of thing quite some time back, but these are supposed to be solved. And the code above does close the Reader.;;;","27/Sep/11 10:19;balor123;Groovy Version: 1.8.0 JVM: 1.6.0_14;;;","27/Sep/11 10:26;blackdrag;have you a program showing that problem?;;;","27/Sep/11 10:48;balor123;Yes please see the snippet in the stackoverflow thread linked above. I think the input, output, and error streams need to be closed.;;;","27/Sep/11 11:36;blackdrag;Ok, so the problem is on Process, not on File. I haven't seen that, sorry. Process#getText closes the InputStream. The question is if it makes sense to also close error and output streams through this method. I guess that is something we can do, but we would potentially break some code. Also if we go this route we have to think of the case of process error and/or process input stream buffers being full and thus blocking the process from finnishing what it had to tell us. ;;;","27/Sep/11 11:36;blackdrag;Paul, isn't that something for you?;;;","27/Sep/11 11:42;balor123;Hmm yeah maybe it should just close the STDOUT stream. It will break some legacy code but in those cases the stream would have been empty anyway. If my proposal for new mergedText and close methods are accepted, then we'll be able to concicesly close all the streams in all cases. We'll just need to write some notes documenting the pitfalls of executing commands and how to avoid them using the new methods.;;;","27/Sep/11 15:20;paulk;I see a stacktrace on stackoverflow but no code. Perhaps I am missing something. Do you have some code which illustrates the problem you are talking about? Thanks.;;;","27/Sep/11 15:28;balor123;Attached file to bug report. You can uncomment the ""No error"" code to see that closing the streams does fix the error.;;;","27/Sep/11 15:48;balor123;...
<removed dir>
<removed dir>
<removed dir>
Caught: java.util.concurrent.ExecutionException: org.codehaus.groovy.runtime.InvokerInvocationException: java.io.IOException: Cannot run program ""ls"": java.io.IOException: error=24, Too many open files
	at groovyx.gpars.GParsPool.runForkJoin(GParsPool.groovy:305)
	at UsageAnalyzer2$_run_closure2_closure6.doCall(UsageAnalyzer2.groovy:36)
	at groovyx.gpars.GParsPool$_withExistingPool_closure1.doCall(GParsPool.groovy:170)
	at groovyx.gpars.GParsPool$_withExistingPool_closure1.doCall(GParsPool.groovy)
	at groovyx.gpars.GParsPool.withExistingPool(GParsPool.groovy:169)
	at groovyx.gpars.GParsPool.withPool(GParsPool.groovy:141)
	at groovyx.gpars.GParsPool.withPool(GParsPool.groovy:117)
	at UsageAnalyzer2$_run_closure2.doCall(UsageAnalyzer2.groovy:35);;;","27/Sep/11 17:57;blackdrag;@Paul, the example basically is (1..n).each { ""ls"".execute().text }
@Uri, getText does close STDOUT. Since you are not happy with that, it is obviously not enough.;;;","27/Sep/11 18:41;balor123;It seems that the output stream can be closed safely once the process has exited. It makes sense that text would only close STDOUT since it only reads STDOUT. What's missing is the ability to read both STDOUT and STDERR and close both concisely.;;;","28/Sep/11 04:17;paulk;Changing the behavior of the DGM process methods is certainly a possibility. However, the current ""design"" of many of these methods is very much a mix and match toolkit style. The {{getText()}} method has never been designed to be an all-in-one solution, rather a light-weight layer over the existing process methods to make them a little bit nicer.

A common existing usage pattern is:
{code}
p = ""ls = build.gradle"".execute()
p.waitFor()
println ""O: "" + p.text      // O: build.gradle
println ""E: "" + p.err.text  // E: ls: =: No such file or directory
{code}
If {{getText()}} closed all the streams, then obviously the second println above would fail.

The existing methods allow closing of the error stream directly if desired:
{code}
def p = ""ls = build.gradle"".execute()
p.waitFor()
p.err.close()
println ""O:\n"" + p.text
{code}

Trying to change the existing methods is possible but might not be what people expect given the current mix and match style.

At the moment, the closest we have to an all in one solution is the {{waitForProcessOutput()}} methods. At the moment, they don't close the output and error streams but probably should. In the first instance, that is what I am going to fix. That will then allow the following solutions to the above problem:
{code}
p = ""ls = build.gradle"".execute()
def sout = new StringBuilder()
def serr = new StringBuilder()
p.waitForProcessOutput(sout, serr)
println ""O:\n"" + sout
println ""E:\n"" + serr
{code}
Or if merging of the streams is desired:
{code}
p = ""ls = build.gradle"".execute()
def sb = new StringBuffer()
p.waitForProcessOutput(sb, sb)
println ""OE:\n"" + sb
{code}
This should stop the ""Too many open files"" error albeit not in as compact a syntax as might be desired.

I think a more compact solution needs further discussion. It might need to be separate from the existing solutions or we might have to bite the bullet and do some wrapping of Process objects.
;;;","28/Sep/11 07:04;paulk;OK, change made. If you are in a position to test your example with a snapshot jar and alter your code to use the slightly longer version usign {{waitForProcessOutput()}}, that would be great. It would be interesting to ensure that the errors go away. At present I am not closing the input stream as none should be in use but it would be useful to see what results you get.;;;","28/Sep/11 08:20;balor123;Sure I could test it. Just send me the file and instructions on how to install it.;;;","28/Sep/11 08:34;balor123;It might be useful to have an example for evaluating proposals. I'll suggest the following snippet, written in Perl:

{code:none}
if (`ls *.ext1` =~ /\S+/) {
  ...
} elsif (`ls *.ext2` =~ /\S+/) {
  ...
}
{code}

Right now, it would look like this.

{code:java}
def sb1 = new StringBuffer()
def process1 = ""ls *.ext1"".execute()
process1.waitForProcessOutput(sb1, sb1)

def sb2 = new StringBuffer()
def process2 = ""ls *.ext2"".execute()
process2.waitForProcessOutput(sb2, sb2)

if (sb1 =~ /\S+/) {
  ...
else if (sb2 =~ /\S+/) {
  ...
}
{code};;;","28/Sep/11 15:03;paulk;If you grab a snapshot jar from our CI server and just replace your existing groovy or groovy-all jar.
{noformat}
http://snapshots.repository.codehaus.org/org/codehaus/groovy/
{noformat}
You should grab the one closest to your current versions, pick groovy/groovy-all and pick the latest 1.7.x or 1.8.x jar depending on what you are currently using.;;;","29/Sep/11 11:35;balor123;I grabbed groovy-all-1.8.3-SNAPSHOT.jar and placed it into my groovy embeddable directory and renamed it to groovy-all-1.8.2.jar. I then changed the script to use waitForProcessOutput() and ran it in the case showing the error and it still occurs. Did I test it right?;;;","29/Sep/11 14:34;paulk;It depends on how your are running groovy. If you are referencing the groovy-all jar directly (e.g. in an IDE) then you have done the correct steps. If you are using groovy from the commandline or groovyConsole in is likely using the non-all jar in the lib directory.;;;","30/Sep/11 10:18;balor123;The change seems to prevent the exception now.;;;","30/Sep/11 19:01;paulk;Cool. Thanks for trying that out. Next we'll have to think about further shorthands! :-) Though perhaps that could be a separate issue given the title of this issue?;;;","30/Sep/11 21:21;paulk;ok, closing this issue but see GROOVY-5058 for future enhancements;;;",,,,,,,,,,,,,,,,,,,,,,
incorrect result when using += operator in closure,GROOVY-5046,12815902,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,shumin,shumin,26/Sep/11 14:01,29/Sep/11 14:30,14/Jul/23 06:00,29/Sep/11 14:30,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,parser,,,,0,,,,,,"I get incorrect result running the following script with groovy 1.8.2:{code:Java}
a=[3:5]

class B {
        int v;
}

B b = new B();
b.v = 3

clos = {
        if (it!=null)
        {
                a[it.v] += 3
        }
}
clos.call(b)

println 'b.v = ' + b.v
println 'a = ' + a
{code}
> groovy test.groovy
b.v = 8
a = 8
",Linux,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 29 14:30:56 UTC 2011,,,,,,,,,,"0|i2cigf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"29/Sep/11 14:30;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SwingBuilder edt breaks with anonymous subclassing,GROOVY-5045,12818117,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,gubespam,gubespam,26/Sep/11 11:06,13/Jul/23 19:50,14/Jul/23 06:00,13/Jul/23 19:50,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Swing,,,,0,,,,,,"When within SwingBuilder.edt, the instantiation of anonymous inner classes to appears to be broken.

Example code:
{code}
import groovy.swing.SwingBuilder
import javax.swing.SwingWorker;
import javax.swing.JFrame
import java.awt.BorderLayout

class TestEDT {
    public static void main( String[] args )
    {
        def myLabel
        def swing = new SwingBuilder()
        swing.edt {
            frame(pack:true, show:true, defaultCloseOperation:JFrame.EXIT_ON_CLOSE){
                borderLayout()
                myLabel = label(""Hello"", constraints:BorderLayout.CENTER)
            }

            def sw = new SwingWorker() {
                protected Object doInBackground() throws Exception
                {
                    return 10
                }
                protected void done()
                {
                    myLabel.text = get()
                }
            }.execute();
        }
    }
}
{code}

This throws:
{code}Exception in thread ""main"" groovy.lang.GroovyRuntimeException: Could not find matching constructor for: TestEDT$1(java.lang.Class, groovy.lang.Reference)
	at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1481)
	at groovy.lang.MetaClassImpl.invokeConstructor(MetaClassImpl.java:1397)
	at org.codehaus.groovy.runtime.callsite.MetaClassConstructorSite.callConstructor(MetaClassConstructorSite.java:46)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:190)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:202)
	at TestEDT$_main_closure1.doCall(TestEDT.groovy:17)
{code}",,aalmiray,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 18 04:13:35 UTC 2012,,,,,,,,,,"0|i2bqyf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jun/12 04:13;aalmiray;Cannot be reproduced with 1.8.6, the code works OK.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Ant Groovyc compilation error in Gradle,GROOVY-5044,12818478,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,subzero66,subzero66,25/Sep/11 21:40,13/May/12 03:30,14/Jul/23 06:00,14/Feb/12 04:24,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,Ant integration,Compiler,,,1,,,,,,"I ran the [Groovyc Ant task|http://groovy.codehaus.org/The+groovyc+Ant+Task] to compile my classes within Gradle. My code uses the {{@Singleton}} annotation. The version I set in the classpath is 1.8.1. The following snippet shows the code I use:

{code}
def groovycClasspath = getGroovyClasspath().asPath + System.getProperty('path.separator') + getTestRuntimeClasspath().asPath
ant.taskdef(name: 'groovyc', classname: 'org.codehaus.groovy.ant.Groovyc', classpath: getGroovyClasspath().asPath)

ant.groovyc(destdir: getClassesDir().canonicalPath, includeAntRuntime: false, classpath: groovycClasspath) {
    getSrcDirs().each { srcDir ->
        src(path: srcDir)
    }
}
{code}

When I run this without the attribute {{fork: true}} I get this compilation error:

{code}
Not an ASTTransformation: org.codehaus.groovy.transform.SingletonASTTransformation declared by groovy.lang.Singleton
{code}

Running Groovyc as forked process works fine. The compilation finished without an issue. Somebody on the [mailing list|http://groovy.329449.n5.nabble.com/Delegate-annotation-doesn-t-work-when-building-in-NetBeans-td3270943.html] reported the same error except that he uses Groovyc in Ant.",MacOS 10.6.8,bmuschko,ddimitrov,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3294,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 13 04:05:28 UTC 2012,,,,,,,,,,"0|i2cs3j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Sep/11 03:55;paulk;The other workaround that seems to work for me is to set {{includeAntRuntime=""true""}}.;;;","30/Nov/11 05:34;melix;Yes, the problem is that the ""transform class loader"" used by the compilation unit (that is to say the compiler) must, at least, be the same or a child classloader of the  classloader which loads groovy classes.

When ""includeAntRuntime"" is set to false, then the transform classloader used to load AST transforms is an AntClassLoader which doesn't have loaded any groovy internal class. What happens, then, is that when you reach {{org.codehaus.groovy.transform.ASTTransformationCollectorCodeVisitor#verifyClassAndAddTransform}}, there are two distinct {{ASTTransformation}} classes loaded: the one used by the compiler, and the one loaded from AntClassLoader. As a workaround, I tried to force the compiler to use the same classloader as the transform to load and compare the {{ASTTransformation}} class, but it's insufficient. It requires *a lot* of trickery to replace casts, direct method calls with reflective method calls in the compiler just to load the AST transformation.

I am not sure what we should do...;;;","07/Feb/12 03:24;melix;The problem is related to having a transform loader.;;;","13/Feb/12 04:05;melix;Future versions of Groovy will prevent the combination fork=false && includeAntRuntime==false, which can lead to various surprising issues.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Anonymous inner class constructor call referencing a getter caused NPE at compile time,GROOVY-5041,12815884,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,graemerocher,graemerocher,23/Sep/11 08:53,23/Sep/11 10:24,14/Jul/23 06:00,23/Sep/11 10:24,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,,,,,0,,,,,,"Example code:

{code}
import java.sql.Connection
import groovy.sql.Sql

class GrailsPrecondition {

    Connection getConnection() { database?.connection?.wrappedConnection }
    /**
     * Called from the check closure. Creates a <code>Sql</code> instance from the current connection.
     *
     * @return the sql instance
     */
    Sql getSql() {
        if (!connection) return null

        if (!sql) {
            sql = new Sql(connection) {
                protected void closeResources(Connection c) {
                    // do nothing, let Liquibase close the connection
                }
            }
        }

        sql
    }
}
{code}

Exception:

{code}
java.lang.NullPointerException
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitFieldExpression(AsmClassGenerator.java:1081)
	at org.codehaus.groovy.classgen.asm.ClosureWriter.loadReference(ClosureWriter.java:123)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.loadVariableWithReference(InvocationWriter.java:433)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeAICCall(InvocationWriter.java:417)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeConstructor(InvocationWriter.java:385)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorCallExpression(AsmClassGenerator.java:914)
	at org.codehaus.groovy.ast.expr.ConstructorCallExpression.visit(ConstructorCallExpression.java:43)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:283)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:72)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:527)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:599)
	at org.cod
{code}

The issue appears to be that a FieldExpression is created with a null FieldNode when calling the constructor new Sql(connection)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 23 10:24:17 UTC 2011,,,,,,,,,,"0|i2cb3j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Sep/11 10:24;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Variables in annotation closures should never be bound to declarations in ""enclosing"" scopes",GROOVY-5040,12815898,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,pniederw,pniederw,23/Sep/11 00:05,29/Sep/11 17:05,14/Jul/23 06:00,29/Sep/11 17:05,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.3,1.9-beta-4,Compiler,,,,0,,,,,,"For example, in the following code the closure variable is incorrectly bound to the method parameter, resulting in the absence of an (Object, Object) constructur and the presence of an (Object, Object, Reference) constructor for the closure:

{code}
@Foo({ value })
def doit(value) {}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 29 17:05:12 UTC 2011,,,,,,,,,,"0|i2cl6f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Sep/11 00:07;pniederw;Also see http://groovy.329449.n5.nabble.com/Annotation-closure-not-behaving-as-expected-td4821286.html;;;","29/Sep/11 17:05;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Grails functional tests failing due to VerifyError loading classes,GROOVY-5037,12815831,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,graemerocher,graemerocher,22/Sep/11 08:58,22/Sep/11 13:19,14/Jul/23 06:00,22/Sep/11 13:19,1.8.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,,,,,0,,,,,,"Exception:

{code}
Caused by: java.lang.VerifyError: (class: org/jsecurity/grails/RealmWrapper, method: isPermitted signature: (Lorg/jsecurity/subject/PrincipalCollection;Ljava/util/List;)[Z) Expecting to find object/array on stack
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:169)
	at JsecurityGrailsPlugin$_closure7.class$(JsecurityGrailsPlugin.groovy)
	at JsecurityGrailsPlugin$_closure7.$get$$class$org$jsecurity$grails$RealmWrapper(JsecurityGrailsPlugin.groovy)
	at JsecurityGrailsPlugin$_closure7.doCall(JsecurityGrailsPlugin.groovy:338)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokePropertyOrMissing(MetaClassImpl.java:1093)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1056)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:884)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:704)
	at Jsec
{code}

Console output from functional tests:

http://hudson.grails.org/job/grails_functional_tests_2.0.x/1009/console

Code that is causing the exception looks like:

{code}
       def wrapperName = ""${realmName}Wrapper"".toString()
        ""${wrapperName}""(RealmWrapper) {
            realm = ref(""${realmName}Instance"")
            tokenClass = GrailsClassUtils.getStaticPropertyValue(grailsClass.clazz, 'authTokenClass')
        }
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 22 13:19:48 UTC 2011,,,,,,,,,,"0|i2bnhj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Sep/11 13:19;blackdrag;the reason was that the object code was used for boolean arrays. Fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Date and Calendar JSON serialization yields stackoverflow errors,GROOVY-5036,12815890,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,guillaume,guillaume,22/Sep/11 07:26,14/Oct/11 00:28,14/Jul/23 06:00,22/Sep/11 07:32,1.8.2,1.9-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,,,,,0,,,,,,"Date and Calendar contain references to themselves, and the standard object properties serialization logic tries to serialize an infinite chains of such references, yielding a stack overflow error.

The idea is to serialize those dates and calendars into ISO-8601 compliant date strings, that are also parseable from JavaScript with Date.parse(...).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-09-22 07:26:49.0,,,,,,,,,,"0|i2cohb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy is producing incorrect generic type signatures for getters that are created by closures,GROOVY-5034,12818075,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,graemerocher,graemerocher,21/Sep/11 10:49,20/Oct/11 04:51,14/Jul/23 06:00,21/Sep/11 11:20,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,,,,,0,,,,,,"Example say you have a method like:

{code}
    def <T> T  mockController(Class<T> controllerClass) {


        doStuff {
            println controllerClass
            ....
        }
    }
{code}

The closure passed to doStuff contains within its byte code a generated getter called ""getControllerClass"" with the following type signature:

{code}
  public Class<T> getControllerClass()
  {
    CallSite[] arrayOfCallSite = $getCallSiteArray();
    return (Class)ScriptBytecodeAdapter.castToType(this.controllerClass.get(), $get$$class$java$lang$Class());
    return null;
  }

{code}

The generic type T is not declared anywhere. This causes exceptions on OpenJDK such as:

{code}
java.lang.NullPointerException
at com.sun.beans.TypeResolver.resolve(TypeResolver.java:321)
at com.sun.beans.TypeResolver.resolve(TypeResolver.java:351)
at com.sun.beans.TypeResolver.resolve(TypeResolver.java:310)
at com.sun.beans.TypeResolver.resolve(TypeResolver.java:157)
at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:78)
at java.beans.FeatureDescriptor.getReturnType(FeatureDescriptor.java:368)
at java.beans.Introspector.getTargetEventInfo(Introspector.java:1020)
at java.beans.Introspector.getBeanInfo(Introspector.java:424)
at java.beans.Introspector.getBeanInfo(Introspector.java:189)
at grails.test.mixin.web.ControllerUnitTestMixin.mockController(ControllerUnitTestMixin.groovy:268)

{code}

This issue is the cause of http://jira.grails.org/browse/GRAILS-8031",OpenJDK (All Known Versions),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 20 04:51:53 UTC 2011,,,,,,,,,,"0|i2c5tj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Sep/11 11:20;blackdrag;should be fixed now;;;","19/Oct/11 21:16;chrislovecnm;I just opened http://jira.grails.org/browse/GRAILS-8184 are these related?  If so what do I need to change in the groovy class that is attached to the bug?;;;","20/Oct/11 04:51;blackdrag;Does it still happen if you remove the groovy transform?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Annotations on a method with optional parameters do not work,GROOVY-5033,12815866,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,kcheang,kcheang,21/Sep/11 05:31,14/Oct/11 00:28,14/Jul/23 06:00,22/Sep/11 01:57,1.7.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,Compiler,,,,0,,,,,,"I found this bug when using Springcache in a Grails project. I have a service method which flushes a cache.

{code}
class MyService { 
    @CacheFlush('MyCache') 
    def update(paramA, paramB, paramC=null) { 
        ... 
    } 
}
{code}

When I call the update method with all three parameters, Springcache flushes the cache correctly. But when I call with only the first two parameters, Springcache will not flush the cache.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 22 01:57:42 UTC 2011,,,,,,,,,,"0|i2cbkf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Sep/11 01:57;roshandawrani;Should be fixed now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Calling a method overwritten via metaClass from another method uses the original (non-overwritten) method if the overridden class extends something,GROOVY-5030,12815882,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,jason@bobberinteractive.com,jason@bobberinteractive.com,19/Sep/11 20:57,14/Oct/11 00:28,14/Jul/23 06:00,21/Sep/11 02:35,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,primtive opts,,,,1,,,,,,"Hi Everyone

I'm using Groovy 1.8.2, and there's a variant of http://jira.codehaus.org/browse/GROOVY-4884.  This code fails for me:

{code}
import org.junit.Test;

public class BreakingExample_NoMetaclassOverride {
   @Test
   void testNotOverriden() {
      def list = []
      ClassUnderTest cut = new ClassUnderTest()
      cut.metaClass.getRemoteObject = { ->
         return [method: {obj -> 
            list << obj
         }] as RemoteObject
      }
      
      String val = ""Value"" 
      cut.someMethod(val)
      assert list == [val]
   }
}

public class ClassUnderTest extends RemoteObject {
   public def someMethod(String someValue) {
      RemoteObject object = getRemoteObject()
      object.method(someValue)
   }
   protected RemoteObject getRemoteObject() {
      return new RemoteObject()
   }
}

public class RemoteObject {
   public void method(obj) { /* Something */ }
}
{code}

The only difference between this and #4884 is the ""extends RemoteObject"" added to ClassUnderTest.  With it in, the test fails.  Remove it, the test passes.

Please let me know if you need any more info!

Thanks
Jason Griffith",,jwb,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 29 23:02:13 UTC 2011,,,,,,,,,,"0|i2cfin:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"19/Sep/11 22:40;roshandawrani;The issue is related to new optimization logic that determines whether to take a fast path or a slow path. I think Verifier#addFastPathHelperFieldsAndHelperMethod() and DGM#disablePrimitiveOptimization() are a little inconistently written.

Say, we have class B inheriting from A.

Verifier#addFastPathHelperFieldsAndHelperMethod() sees that A has the static field __$stMC (used in optimization related guards) because it also looks at super classes and then doesn't add it to B.

On the other hand, DGM#disablePrimitiveOptimization() tries to set __$stMC on the current class only. But in above case, no __$stMC is added to class B, and attempt to disable the optimizations goes wasted (with NoSuchFieldException), and later on when that flag is looked at to see whether to dispatch the method call in ""RemoteObject object = getRemoteObject()"" in a fast way or slow way, it chooses the fast path because it finds the optimization still enabled by mistake.

So, here is a patch that removes the above inconsistency between Verifier and DGM:
{code}
@@ -17790,15 +17790,21 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     }
 
     private static void disablePrimitiveOptimization(Object self) {
         Field sdyn;
         Class c = self.getClass();
-        try {
-            sdyn = c.getDeclaredField(Verifier.STATIC_METACLASS_BOOL);
-            sdyn.setBoolean(null, true);
-        } catch (Throwable e) {
-            //DO NOTHING
+        while (c != null) {
+            try {
+                sdyn = c.getDeclaredField(Verifier.STATIC_METACLASS_BOOL);
+                sdyn.setBoolean(null, true);
+                break;
+            } catch (NoSuchFieldException e) {
+               c = c.getSuperclass();
+               continue;
+            } catch (Throwable e) {
+                //DO NOTHING
+            }
         }
     }
 
     /**
      * Sets/updates the metaclass for a given class to a closure.
{code}

Although I personally think it's the code in Verifier that is wrong and in adding the static field __$stMC, it should not look at super classes. Depends on bytecode optimization enabling/disabled is designed keeping what kind of behavior in mind when it comes to inheritence. If from A inherit B and C and we do some metaclass stuff to B (and hence disable the optimization in B), in current implementation it may disable the optimization for C also, I think, because the guard pick-up the information from A's __$stMC static field.;;;","20/Sep/11 06:37;blackdrag;Roshan you are completely right about the Verifier I would say. In B extends A I don't want to disable optimizations for A, just because B got changed. ;;;","21/Sep/11 02:35;roshandawrani;Fixed by changing Verifier as discussed.;;;","29/Sep/11 23:02;jason@bobberinteractive.com;Tested the latest 1.8.3 snapshot with this bug - it's fixed on our end.

It was very impressive how quickly you guys jumped on this and fixed it.  Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"XmlSlurper does not close InputStream, leaks file handles/resources",GROOVY-5029,12816242,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,johann,johann,16/Sep/11 16:30,05/Apr/15 14:44,14/Jul/23 06:00,16/Sep/11 20:14,1.8.0,1.9-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.3,1.9-beta-4,groovy-jdk,,,,0,inputstream,leak,resource,xml,xmlslurper,"{code}
  public GPathResult parse(final File file) throws IOException, SAXException {
  final InputSource input = new InputSource(new FileInputStream(file));
    
    input.setSystemId(""file://"" + file.getAbsolutePath());
    
    return parse(input);
    
  }
{code}

I stepped through the SAX code but couldn't see the {{InputSource}} being closed so {{XmlSlurper}} is leaking file descriptors.

I think the {{Reader}} and {{InputStream}} methods' JavaDoc should also mention that the streams aren't closed.

{{GPathResult parse(final String uri)}} also seems to leak though that could also be a Xerces issue because I don't see it closing its input streams, either.

Shameless plug: Use [Resource.close|http://johannburkard.de/blog/programming/java/centralizing-resource-closing.html]

I tried to get the VM to crash. After checking {{ulimit -a}}, I ran
{code}
5000.times { new XmlSlurper().parse(new File('web.xml')) }
{code}

This caused a lot of FileInputStreams to be created but I couldn't reach my limit of 1024 due to the finalizer in {{FileInputStream}}. Still, in the screenshot below you can see how the {{FileInputStream}} instances are accumulating on the heap.

Fixing this is of course easy:

{code}
  public GPathResult parse(final File file) throws IOException, SAXException {
   FileInputStream in = null;
   try {
     in = new FileInputStream(file);
     final InputSource input = new InputSource(in);
     input.setSystemId(""file://"" + file.getAbsolutePath());   
     return parse(input);
   }
   finally {
     close(in); // or if (in != null) try { in.close() } catch (IOException ex) {}
   }   
  }
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Sep/11 16:30;johann;resource-leak.png;https://issues.apache.org/jira/secure/attachment/12722901/resource-leak.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Sat Sep 17 03:26:30 UTC 2011,,,,,,,,,,"0|i2cb9r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Sep/11 20:14;paulk;Fixed. FileInputStream now closed. Javadocs added. Uri version I don't think is in our control, so it was left alone.;;;","17/Sep/11 03:26;johann;Thanks Paul!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovydoc calculateFirstSentence doesn't recognise html tags as breaks,GROOVY-5027,12815868,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,guillaume,tim_yates,tim_yates,16/Sep/11 04:29,05/Apr/15 14:44,14/Jul/23 06:00,22/Sep/11 10:00,1.8.2,1.9-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,GroovyDoc,,,,0,,,,,,"The Method summary block of the groovydoc pages contains a sentence describing the method.

However, if the javadoc looks like (taken from StreamingJsonBuilder.groovy):

{code:java}
    /**
     * Varargs elements as arguments to the JSON builder create a root JSON array
     * <p>
     * Example:
     * <pre class=""groovyTestCase"">
     * new StringWriter().with { w ->
     *   def json = new groovy.json.StreamingJsonBuilder( w )
     *   def result = json 1, 2, 3
     *
     *   assert result instanceof List
     *   assert w.toString() == ""[1,2,3]""
     * }
     * </pre>
     * @param args an array of values
     * @return a list of values
     */
{code}

Then the summary text becomes:

{code:none}
Varargs elements as arguments to the JSON builder create a root JSON array

Example:

 new StringWriter().with { w ->
   def json = new groovy.json.StreamingJsonBuilder( w )
   def result = json 1, 2, 3
{code}

In this case, it is only confusing (as the {{assert}} is missed off the end, but in other cases, it could result in invalid code being shown in the summary.

The attached patch adds another {{replaceAll}} to the {{calculateFirstSentence}} method of {{SimpleGroovyDoc.java}} which trims the javadoc as soon as an HTML tag is encountered as the first thing on a new line in the javadoc.

The summary text for this same method then becomes simply:

{code:none}
Varargs elements as arguments to the JSON builder create a root JSON array
{code}",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Sep/11 04:29;tim_yates;groovydoc.patch;https://issues.apache.org/jira/secure/attachment/12722873/groovydoc.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Sep 23 01:22:33 UTC 2011,,,,,,,,,,"0|i2colj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Sep/11 04:31;tim_yates;Forgot the link to to an example gapi page

http://groovy.codehaus.org/gapi/groovy/json/StreamingJsonBuilder.html;;;","22/Sep/11 10:00;guillaume;Thank you Tim!;;;","23/Sep/11 00:26;paulk;Actually, I just had a look at what javadoc (at least under jdk6 and jdk7) does. It seems like it recognises <p> as a line break but not the other tags. I suspect we want to follow javadocs lead here. I will see if I can tweak the patch accordingly.;;;","23/Sep/11 00:54;paulk;Hmm, seems like {{<p>}} is recognized whether it is on a newline or not but neither {{<p/>}} nor {{<p />}} are recognized.;;;","23/Sep/11 01:22;paulk;ok, tweaks are committed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException using Open JDK caused problems running Grails unit tests,GROOVY-5026,12815895,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,graemerocher,graemerocher,15/Sep/11 10:34,22/Sep/11 13:20,14/Jul/23 06:00,22/Sep/11 13:20,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,,,,,0,,,,,,See http://jira.grails.org/browse/GRAILS-8031,,lhotari,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 22 13:20:49 UTC 2011,,,,,,,,,,"0|i2cilr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Sep/11 13:20;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JavaStubCompilationUnit.addSource() should allow other extensions,GROOVY-5021,12811713,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,keegan,keegan,14/Sep/11 20:16,05/Apr/15 14:44,14/Jul/23 06:00,22/Sep/11 14:28,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,Stub generator / Joint compiler,,,,0,,,,,,"I noticed this while working on a replacement for GMaven.  I think JavaStubCompilationUnit should allow other extensions such as "".gvy"", "".gy"", "".gsh"" to be used when adding sources.  This change in behavior was introduced with https://fisheye.codehaus.org/changelog/groovy?cs=18020.  I think what we might want to do instead is blacklist "".java"" rather than whitelist "".groovy"".  I've attached a patch demonstrating this.",,keeganwitt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"14/Sep/11 20:16;allowOtherExtensions.patch;https://issues.apache.org/jira/secure/attachment/12722986/allowOtherExtensions.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Thu Sep 22 14:28:03 UTC 2011,,,,,,,,,,"0|i2bpz3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Sep/11 22:02;guillaume;I think your approach may have some weird behaviour if the stub compiler was trying to generate java stubs from random resource files.
Instead, you should have a look at CompilerConfiguration, that is passed as parameter of the constructor. Look particularly at the script extensions allowed. The JavaStubCompilationUnit should look up the allowed extensions from there.;;;","15/Sep/11 09:50;keegan;That's quite possible. I made the recommendation from the perspective of an external caller, and my presumption was that if you called addSource(), you really meant for that file to be added as a source for Java stubs.  I have no idea what the implications would be for any internal calls that might exist.  I'm OK with the approach you suggest, but just to be clear though: what you're suggesting is not what the code is currently doing because it has got that hard-coded check.  And this seemed to be the case when I tested setting the script extensions on the CompilerConfiguration with 1.8.2.;;;","22/Sep/11 14:28;guillaume;Use the extensions referenced in CompilerConfiguration rather than the hard-coded .groovy extension.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FileSystemCompiler#generateFileNamesFromOptions is adding filenames multiple times,GROOVY-5018,12815819,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,13/Sep/11 21:20,07/Apr/15 19:06,14/Jul/23 06:00,13/Sep/11 22:11,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.3,1.9-beta-4,,,,,0,,,,,,"See mailing list for further details:
http://groovy.markmail.org/thread/674bikja7ylfejsd",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 13 22:11:01 UTC 2011,,,,,,,,,,"0|i2cson:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Sep/11 22:11;paulk;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[PATCH] SimpleTemplateEngine line number is off by one,GROOVY-5017,12815876,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,kohsuke,kohsuke,13/Sep/11 21:13,05/Apr/15 14:43,14/Jul/23 06:00,14/Sep/11 12:47,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,,,,,0,,,,,,Line number reported from scripts compiled by SimpleTemplateEngine is off by one because it generates an extra new line that's not found in the original source file. Patch attached.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"13/Sep/11 21:13;kohsuke;DIFF;https://issues.apache.org/jira/secure/attachment/12722979/DIFF",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Wed Sep 14 03:17:32 UTC 2011,,,,,,,,,,"0|i2c7kf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Sep/11 22:34;roshandawrani;Thanks for the patch. A slight improvement suggested below.

If we currently have script generated as a), with the patch it looks like b)

a)
{noformat}
-- script source --
/* Generated by SimpleTemplateEngine */
out.print(""""""Hello \""$firstname\"",
Nice to meet you in """"""); print city ;
out.print("""""""""""");

-- script end --
{noformat}

b)
{noformat}
-- script source --
/* Generated by SimpleTemplateEngine */out.print(""""""Hello \""$firstname\"",
Nice to meet you in """"""); print city ;
out.print("""""""""""");

-- script end --
{noformat}

With slightld modified patch, it looks like c)
{code}
         private void startScript(StringWriter sw) {
-            sw.write(""/* Generated by SimpleTemplateEngine */\n"");
             sw.write(""out.print(\""\""\"""");
         }
 
         private void endScript(StringWriter sw) {
-            sw.write(""\""\""\"");\n"");
+            sw.write(""\""\""\"");\n\n/* Generated by SimpleTemplateEngine */"");
         }
{code}

Suggested new output that preserves the line numbers of the original script, but reads slightly better
{noformat}
-- script source --
out.print(""""""Hello \""$firstname\"",
Nice to meet you in """"""); print city ;
out.print("""""""""""");

/* Generated by SimpleTemplateEngine */
-- script end --
{noformat}
;;;","13/Sep/11 22:42;kohsuke;I don't have any objection at all (in fact as far as I'm concerned, I couldn't care less about this ""generated by"" comment.);;;","13/Sep/11 22:48;roshandawrani;Good. There shouldn't probably be, but will just wait for a little bit to see if other devs see any potential impact.;;;","14/Sep/11 01:59;blackdrag;looks like a good idea to me;;;","14/Sep/11 03:17;guillaume;Good idea too here!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Syntax highlighting problem in groovy.ui.Console text editor on empty string expression entering,GROOVY-5014,12815737,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pschumacher,dmovchinn,dmovchinn,13/Sep/11 10:41,26/Nov/13 14:48,14/Jul/23 06:00,25/Nov/13 15:31,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.1,,,Groovy Console,,,,0,empty,highlighting,string,syntax,,Any input of an expression with empty string (see the attachments) does invalid syntax highlighting.,"Mandriva 2010.2 i586 and OpenSUSE 11.4 x86_64, Oracle Java SE 6 Update 26",dmovchinn,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"13/Sep/11 22:01;dmovchinn;GroovyConsole.png;https://issues.apache.org/jira/secure/attachment/12722980/GroovyConsole.png","13/Sep/11 10:41;dmovchinn;GroovyConsole.png;https://issues.apache.org/jira/secure/attachment/12722977/GroovyConsole.png","13/Sep/11 10:41;dmovchinn;GroovyConsole2.png;https://issues.apache.org/jira/secure/attachment/12722978/GroovyConsole2.png","26/Oct/13 06:36;pschumacher;defective_highlight_of_empty_single_quoted_string.png;https://issues.apache.org/jira/secure/attachment/12723092/defective_highlight_of_empty_single_quoted_string.png",,,,,4.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 25 15:31:10 UTC 2013,,,,,,,,,,"0|i2c5hr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Sep/11 10:46;guillaume;The problem in the first place is that the code you entered is not correct.
How would you want it to be highlighted?;;;","13/Sep/11 19:15;paulk;Isn't it OK? Both examples run fine. The first highlights OK for me but not the second.;;;","13/Sep/11 22:07;dmovchinn;The new expression 'println("""" + ""hello"")' must not highlight fine anywhere.;;;","26/Oct/13 06:37;pschumacher;The empty double quoted example was fixed sometime, but for empty single quoted strings the highlighting is still incorrect.;;;","26/Oct/13 08:09;pschumacher;Submitted a [pull request|https://github.com/groovy/groovy-core/pull/277] for this.;;;","25/Nov/13 15:31;pschumacher;pull request merged;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem dispatching array as argument to a closure,GROOVY-5009,12815861,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,brownj,brownj,12/Sep/11 09:12,25/Jan/13 23:35,14/Jul/23 06:00,24/Jan/13 07:31,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.7,2.1.0-rc-1,,,,,9,,,,,,"{code:title=myscript.groovy|borderStyle=solid}
ExpandoMetaClass.enableGlobally()

Object[] myObjectArray = ['a', 'b'] as Object[]

closure = {
	println 'closure running...'
}
	
closure(myObjectArray)
{code}

{noformat}
code $ groovy -version
Groovy Version: 1.8.2 JVM: 1.6.0_26
code $ groovy myscript.groovy 
Caught: groovy.lang.MissingMethodException: No signature of method: myscript$_run_closure1.doCall() is applicable for argument types: (java.lang.String, java.lang.String) values: [a, b]
Possible solutions: doCall(), doCall(java.lang.Object), call(), call([Ljava.lang.Object;), call(java.lang.Object), findAll()
groovy.lang.MissingMethodException: No signature of method: myscript$_run_closure1.doCall() is applicable for argument types: (java.lang.String, java.lang.String) values: [a, b]
Possible solutions: doCall(), doCall(java.lang.Object), call(), call([Ljava.lang.Object;), call(java.lang.Object), findAll()
	at myscript.run(myscript.groovy:9)
{noformat}

I have tested with versions all the way back to 1.7.0 and the exception is thrown for all the versions I tested.

If I remove the ExpandoMetaClass.enableGlobally(), the exception goes away.

I think this is related to http://jira.grails.org/browse/GRAILS-8002, though I am not sure why that problem just showed up in Grails 2.0-M2.  I have not been able to reproduce it with Grails 1.3.7.
",,blackdrag,brownj,graemerocher,lhotari,paulk,tunaranch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 24 07:31:41 UTC 2013,,,,,,,,,,"0|i2bzhb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Sep/11 22:31;roshandawrani;Looked a bit into it and obviously the problem is related to how ClosureMetaClass(CMC) and ExpandoMetaClass choose the method to invoke.

1) The ClosureMetaClass chooses the method to invoke via StandardClosureChooser as it finds the following two methods burnt into the class and restricts its method selection to these two going just by the number of arguments (and selects ""doCall(Object)"" when ""closure(myObjectArray)"" call is made:
{noformat}
- public Object doCall()
- public Object doCall(Object it)
{noformat}

2) On the other hand, the EMC makes its choice from among the following methods and chooses Closure.call(Object... args) as a more exact match:
{noformat}
- public Object groovy.lang.Closure.call()
- public Object groovy.lang.Closure.call(java.lang.Object[])
- public Object groovy.lang.Closure.call(java.lang.Object)
{noformat}

I think the difference in behavior is arising because groovy.lang.Closure has an extra ""call(Object...)"" and its counterpart ""doCall(Object...)"" is missing in closure's bytecode. Shouln't these two sets of methods be in sync always? Once they are, we should have consistent behavior one way or another, whether CMC is used, or EMC.;;;","12/Sep/11 23:12;roshandawrani;Apart from the above mentioned inconsistency on Groovy side, there is another inconsistency on Java side that is in play - related to how the direct dispatch in it differs from a reflection based dispatch:

{code}
import java.lang.reflect.Method;

public class TryInJava {
    public static void main(String[] args) throws Exception {
        Object[] strs = new Object[] {""a"", ""b""};
        Object[] inputs = new Object[] {strs};
        Method m = Foo.class.getMethod(""call"", Object[].class);
        Foo foo = new Foo();
        foo.call(inputs); // this prints ""1"" as the inputs array reaches method ""call"" wrapped properly - as {{""a"", ""b""}}.
        m.invoke(foo, inputs); // this prints ""2"" as now the inputs array reaches method ""call"" unwrapped - as {""a"", ""b""}.
    }
}


class Foo {
    public void call(Object[] inputs) {
        System.out.println(inputs.length);
    }
}
{code}

Since we cannot remove call(Object... args)/call(Object[]) from public API of groovy.lang.Closure and since Groovy has to do a reflection based call, removing the Groovy side inconsistency may result in failure to dispatch the array to a closure in both CMC and EMC cases - unless we then treat it as some special case.;;;","13/Sep/11 04:40;blackdrag;I think the solution is to make EMC doCall instead of call;;;","13/Sep/11 04:41;blackdrag;call is intended to be a kind of dispatcher method and actually behaving as it should, even though that makes no sense if called directly in Grovy;;;","21/Sep/11 03:16;graemerocher;Can we prioritize a fix on this? I would like to get it tested against Grails as I'm concerned about what other regressions could be caused by making a change in behavior like this. In particular I'm concerned about meta-programming logic in EMC and whether it will be impacted by this change.

For example what will be the impact on methodMissing logic like this which currently works:

https://github.com/SpringSource/grails-data-mapping/blob/44031e133d3f7d3c93f575c38b4038bee246292c/grails-datastore-gorm/src/main/groovy/org/grails/datastore/gorm/GormStaticApi.groovy#L102

Anyway regardless I think it is important we get this change in soon so we can do some appropriate testing;;;","21/Sep/11 08:59;blackdrag;should be fixed now;;;","26/Sep/11 02:09;graemerocher;This still seems to be an issue. Code to reproduce:

{code}
ExpandoMetaClass.enableGlobally()
def args = [1, 2] as Object[]
def c = {}
c(args)
{code}

Exception:

{code}
groovy.lang.MissingMethodException: No signature of method: ConsoleScript6$_run_closure1.doCall() is applicable for argument types: (java.lang.Integer, java.lang.Integer) values: [1, 2]
Possible solutions: doCall(), doCall(java.lang.Object), call(), call([Ljava.lang.Object;), call(java.lang.Object), findAll()
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:55)
	at groovy.lang.Closure$call.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at ConsoleScript6.run(ConsoleScript6:4)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:266)
	
{code};;;","26/Sep/11 16:32;brownj;This looks like it may be a regression introduced in 1.8.1.

{code:title=doit.groovy|borderStyle=solid}
ExpandoMetaClass.enableGlobally()
List l = new ArrayList()
l << ([1, 2] as Object[])

l.each {
	println ""it is ${it}""
}
{code}

With 1.8.0...

{noformat}
grv $ groovy -version
Groovy Version: 1.8.0 JVM: 1.6.0_26
grv $ groovy doit.groovy 
it is [1, 2]
grv $ 
{noformat}

With 1.8.1...

{noformat}
grv $ groovy -version
gGroovy Version: 1.8.1 JVM: 1.6.0_26
grv $ groovy doit.groovy 
Caught: groovy.lang.MissingMethodException: No signature of method: doit$_run_closure1.doCall() is applicable for argument types: (java.lang.Integer, java.lang.Integer) values: [1, 2]
Possible solutions: doCall(), doCall(java.lang.Object), call(), call([Ljava.lang.Object;), call(java.lang.Object), findAll()
groovy.lang.MissingMethodException: No signature of method: doit$_run_closure1.doCall() is applicable for argument types: (java.lang.Integer, java.lang.Integer) values: [1, 2]
Possible solutions: doCall(), doCall(java.lang.Object), call(), call([Ljava.lang.Object;), call(java.lang.Object), findAll()
	at doit.run(doit.groovy:5)
grv $ 
{noformat}

With 1.8.2...

{noformat}
grv $ groovy -version
grGroovy Version: 1.8.2 JVM: 1.6.0_26
ogrv $ groovy doit.groovy 
Caught: groovy.lang.MissingMethodException: No signature of method: doit$_run_closure1.doCall() is applicable for argument types: (java.lang.Integer, java.lang.Integer) values: [1, 2]
Possible solutions: doCall(), doCall(java.lang.Object), call(), call([Ljava.lang.Object;), call(java.lang.Object), findAll()
groovy.lang.MissingMethodException: No signature of method: doit$_run_closure1.doCall() is applicable for argument types: (java.lang.Integer, java.lang.Integer) values: [1, 2]
Possible solutions: doCall(), doCall(java.lang.Object), call(), call([Ljava.lang.Object;), call(java.lang.Object), findAll()
	at doit.run(doit.groovy:5)
grv $ 
{noformat};;;","29/Sep/11 15:42;blackdrag;the original example of this issue still holds, but is not ot be fixed for 1.8 or 1.7 and is not o be fixed for Grails as well;;;","15/Dec/11 07:36;graemerocher;Any update on this issue?;;;","11/Jan/12 02:07;graemerocher;Guys are there any plans to fix this?;;;","11/Jan/12 03:43;blackdrag;The problem is how to fix this. We cannot fix this without breaking code at another place. The call(Object...) could be called with call('a','b') or with def x=['a','b'] as Object[]; call\(x\). For the call method they are the same, but for the doCall methods they are not!

For example... let us say we add a doCall(Object...)  method, then either we would let it do what call does and in the end have the same problem and nothing fixed, or we change the type of the implicit it to be an Object[] instead of being an Object. The disadvantages of this are the semantic change for the much implicit it parameter, which will break a lot of code, and that you will then never get a MissingMethodException from the closure unless you gave in the type yourself. And even then it won't be always correct... assuming you have cl={a,b,->...}, and then do cl('a','b') you expect this to work. So far so good... but cl\(x\), with x being the Object[] will still also call that one

The other possible way would be to do what ClosureMetaClass does and not even think about calling the call method, but instead directing to doCall. the result for me: 11 failures and 401 errors in the build. ;;;","18/Jan/13 09:40;blackdrag;this is reported as fixed in 1.8.3;;;","18/Jan/13 09:49;brownj;{noformat}
~ $ groovy -version
Groovy Version: 1.8.8 JVM: 1.6.0_37 Vendor: Apple Inc. OS: Mac OS X
~ $ 
~ $ cat doit.groovy 
ExpandoMetaClass.enableGlobally()

Object[] myObjectArray = ['a', 'b'] as Object[]

closure = {
    println 'closure running...'
}

closure(myObjectArray)

~ $ 
~ $ groovy doit.groovy 
Caught: groovy.lang.MissingMethodException: No signature of method: doit$_run_closure1.doCall() is applicable for argument types: (java.lang.String, java.lang.String) values: [a, b]
Possible solutions: doCall(), doCall(java.lang.Object), call(), call([Ljava.lang.Object;), call(java.lang.Object), findAll()
groovy.lang.MissingMethodException: No signature of method: doit$_run_closure1.doCall() is applicable for argument types: (java.lang.String, java.lang.String) values: [a, b]
Possible solutions: doCall(), doCall(java.lang.Object), call(), call([Ljava.lang.Object;), call(java.lang.Object), findAll()
	at doit.run(doit.groovy:9)
~ $ 
{noformat};;;","18/Jan/13 09:53;blackdrag;reopen for now till I verified it is really fixed in 1.8.9;;;","18/Jan/13 09:54;brownj;Should we remove 1.8.3 from the ""Fix Version"" field?;;;","24/Jan/13 03:24;blackdrag;looks like I made a fix, but then did not apply it to 2.0.x and 1.8.x;;;","24/Jan/13 07:31;blackdrag;I found the fix I did back then and that it is indeed in master and 2.1.0-RC-x, but is missing on 1.8.x and 2.0.x. So I pushed the change there as well and close the issue with that;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,
Integer optimization is not executed,GROOVY-5008,12816260,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,nagai_masato,nagai_masato,11/Sep/11 02:43,05/Apr/15 14:44,14/Jul/23 06:00,11/Sep/11 05:27,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,primtive opts,,,,0,,,,,,"Integer optimization is not executed because BytecodeInterface8.isOrigZ() which is for boolean optimization and always returns false is called instead of BytecodeInterface8.isOrigInt().

Steps to confirm the problem:
# Save the following script as Test.groovy
{code:java}
int fib(int n) {
    if (n < 2) return n
    return rcfib(n - 1) + rcfib(n - 2)
}
{code}
# Compile Test.groovy using groovyc
{noformat}groovyc Test.groovy{noformat}
# Disassemble the Test.class
{noformat}javap -c Test{noformat}
# You can see BytecodeInterface8.isOrigZ is called
{code}
  public int fib(int);
    Code:
       0: invokestatic  #20                 // Method $getCallSiteArray:()[Lorg/codehaus/groovy/runtime/callsite/CallSite;
       3: astore_2      
       4: invokestatic  #66                 // Method org/codehaus/groovy/runtime/BytecodeInterface8.isOrigZ:()Z
       7: ifeq          25
      10: getstatic     #68                 // Field __$stMC:Z
      13: ifne          25
      16: invokestatic  #71                 // Method org/codehaus/groovy/runtime/BytecodeInterface8.disabledStandardMetaClass:()Z
      19: ifne          25
      :
      :
{code}
 ","Groovy version: 1.8.2, 1.9.0-2-SNAPSHOT
JVM version: 1.7.0
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Sep/11 02:43;nagai_masato;patch;https://issues.apache.org/jira/secure/attachment/12722975/patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Sun Sep 11 06:42:28 UTC 2011,,,,,,,,,,"0|i2byfj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Sep/11 02:56;nagai_masato;The above script is wrong. Use the following one instead.
{code}
int fib(int n) {
    if (n < 2) return n
    return fib(n - 1) + fib(n - 2)
}
{code}

;;;","11/Sep/11 05:27;blackdrag;thanks for the patch, but I actually fixed this for the next version already a few days ago;;;","11/Sep/11 05:49;nagai_masato;OK, I got it. So will the fix be commited to https://svn.codehaus.org/groovy/trunk/groovy/groovy-core later?;;;","11/Sep/11 06:42;blackdrag;No, we are about to deprecate that repository for normal Groovy development. Please use git://git.codehaus.org/groovy-git.git (ano access), http://git.codehaus.org/gitweb.cgi?p=groovy-git.git for browsing, ssh://git@git.codehaus.org/groovy-git.git (for commit)... Soon we will also be able to answer to pull requests on github;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inappropriate transformation of type from int to BigDecimal,GROOVY-5006,12818106,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,russel,russel,09/Sep/11 06:41,09/Sep/11 11:20,14/Jul/23 06:00,09/Sep/11 09:24,1.8.2,1.9-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,,,,,0,,,,,,"In Groovy 1.8.1 the following code compiles fine and runs fine.  Fine here means hanging forever with no output.
{code}

@Grab ( 'org.codehaus.gpars:gpars:0.12' )

import groovyx.gpars.group.DefaultPGroup

final int n = 1000000000i
final int actorCount = 1
final int sliceSize = n / actorCount // The division expression here is crucial to observing the problem.
final group = new DefaultPGroup ( )
final accumulator = group.messageHandler { }
final computors = [ ]  
assert sliceSize.class == Integer
for ( index in 0 ..< actorCount ) {
  assert sliceSize.class == Integer
  computors.add (
    //assert sliceSize.class == Integer // this statement causes a compilation error in the following statement ?????
    group.actor {
      assert sliceSize.class == Integer
    }
  )
}
accumulator.join ( )
{code}
Using 1.8.2 or Groovy trunk with the SHA1 given above, this results in:
{quote}
An exception occurred in the Actor thread Actor Thread 2
Assertion failed: 

assert sliceSize.class == Integer
       |         |     |
       1000000000|     false
                 class java.math.BigDecimal

	at org.codehaus.groovy.runtime.InvokerHelper.assertFailed(InvokerHelper.java:385)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.assertFailed(ScriptBytecodeAdapter.java:658)
	at alt$_run_closure2.doCall(alt.groovy:25)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:882)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:46)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at alt$_run_closure2.doCall(alt.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:882)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:404)
	at groovyx.gpars.actor.DefaultActor.handleStart(DefaultActor.java:336)
	at groovyx.gpars.actor.AbstractLoopingActor$1.handleMessage(AbstractLoopingActor.java:70)
	at groovyx.gpars.util.AsyncMessagingCore.run(AsyncMessagingCore.java:132)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:662)
{quote}
it then also hangs forever, but in this case that can be considered normal and correct.","Debian Testing; Groovy trunk fdf212623511fce9d47d3d8ab3954a709d70583f",russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 09 11:20:38 UTC 2011,,,,,,,,,,"0|i2cffb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Sep/11 06:44;russel;NB  This is different from the issue of GROOVY-5000.;;;","09/Sep/11 09:24;blackdrag;I fixed that case, but without test;;;","09/Sep/11 11:20;russel;Rock on man. :-)

I can confirm that the fix causes Groovy to work with the orginal code that highlighted the problem.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
[PATCH] Fix the problem in handling bridge methods,GROOVY-5003,12816985,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,kohsuke,kohsuke,08/Sep/11 17:28,05/Apr/15 14:44,14/Jul/23 06:00,22/Sep/11 14:54,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,,,,,0,,,,,,"Groovy should ignore bridge methods.

This eliminates redundant method calls, although that isn't why
I need it.

My primary reason for this change is bit unusual; I've got a little
byte code post processor to inject synthetic bridge methods
to help me evolve code without breaking existing binaries,
<http://bridge-method-injector.infradna.com/>, and as a part of this
I generate a bridge method whose return type is narrower, instead of
wider.

That is, whereas normally bridge methods are as follows:

{noformat}
interface Base {
    Object foo();
}

class Impl implements Base {
    String foo() {...}

    // the above definition causes javac to insert the following
    // bridge method
    @Synthetic @Bridge
    Object foo() { return <String>foo(); }
}
{noformat}

my byte code post processing would produce this:

{noformat}
class Impl /* no interface needed */ {
    Object foo() {...}

    @Synthetic @Bridge
    String foo() { return (String)<Object>foo(); }
}
{noformat}

This works with javac, in the sense that it'll invoke ""Object foo()"", by preferring non-bridge methods for resolution.

Unfortunately, Grooovy doesn't discreminate against bridge methods, so it can end up calling ""String foo()"" depending on the exact implementation detail of the search.

This fix eliminates this issue by making Groovy ignore all bridge methods. Would you please please include this?",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"08/Sep/11 17:28;kohsuke;DIFF;https://issues.apache.org/jira/secure/attachment/12722973/DIFF",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,2011-09-08 17:28:25.0,,,,,,,,,,"0|i2bq5b:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Map access is given higher precedence when trying to access fields/properties in classes which implement java.util.Map or extend java.util.HashMap or java.util.Properties,GROOVY-5001,12817165,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,ericksn,ericksn,08/Sep/11 15:04,15/Aug/22 14:38,14/Jul/23 06:00,25/Jan/22 18:21,1.8.1,1.8.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,5.0.0-alpha-1,,,groovy-runtime,,,,1,breaking,,,,,"Using the @Log4j annotation on a groovy class that extends java.util.Properties seems to have odd side effects on closures.

{code:title=testscript}

import groovy.util.logging.*

[new Test1(), new Test2(), new Test3()].each {
    runTest(it)
}

def runTest (obj) {
    try {
         obj.test()
         obj.method()
         println ""${obj.getClass()} success""
    }
    catch (e) {
         println ""${obj.getClass()} failed $e""
    }
}

//   classes

@Log4j
class Test1 {
    def test () {
         println '============================='
         println 'testing plain Groovy class'
         println ""testing class [${this.getClass().getSimpleName()}]""
    }
    def method () {
        log.debug 'method called, not in closure'
        ['a', 'b', 'c'].each {
            log.debug ""inside closure [$it]""
        }
    }
}

@Log4j
class Test2 extends BaseClass {
    def test () {
         println '============================='
         println 'testing Groovy class that extends another Groovy class'
         println ""testing class [${this.getClass().getSimpleName()}]""
    }
    def method () {
        log.debug 'method called, not in closure'
        ['a', 'b', 'c'].each {
            log.debug ""inside closure [$it]""
        }
    }
}

class BaseClass {
}

@Log4j
class Test3 extends java.util.Properties {
    def test () {
         println '============================='
         println 'testing Groovy class that extends java.util.Properties'
         println ""testing class [${this.getClass().getSimpleName()}]""
    }
    def method () {
        log.debug 'method called, not in closure'
        ['a', 'b', 'c'].each {
            log.debug ""inside closure [$it]""
        }
    }
}
{code}

{code:title=log4j.properties}
log4j.rootLogger=DEBUG, CONSOLE
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=%d [%t] %-5p %c - %m%n
{code}

{noformat}

$ groovy testscript
=============================
testing plain Groovy class
testing class [Test1]
2011-09-08 15:59:45,757 [main] DEBUG Test1 - method called, not in closure
2011-09-08 15:59:45,759 [main] DEBUG Test1 - inside closure [a]
2011-09-08 15:59:45,759 [main] DEBUG Test1 - inside closure [b]
2011-09-08 15:59:45,759 [main] DEBUG Test1 - inside closure [c]
class Test1 success
=============================
testing Groovy class that extends another Groovy class
testing class [Test2]
2011-09-08 15:59:45,768 [main] DEBUG Test2 - method called, not in closure
2011-09-08 15:59:45,769 [main] DEBUG Test2 - inside closure [a]
2011-09-08 15:59:45,769 [main] DEBUG Test2 - inside closure [b]
2011-09-08 15:59:45,769 [main] DEBUG Test2 - inside closure [c]
class Test2 success
=============================
testing Groovy class that extends java.util.Properties
testing class [Test3]
2011-09-08 15:59:45,771 [main] DEBUG Test3 - method called, not in closure
class Test3 failed java.lang.NullPointerException: Cannot invoke method debug() on null object

{noformat}

The problem is on Test3 where the log instance var is null inside the closure, but not outside it.
Only Test 3 has this problem","linux

[tauser02@gfmwsp11lds cps]$ uname -a
Linux gfmwsp11lds.hsi.hughessupply.com 2.6.18-164.el5 #1 SMP Thu Sep 3 04:15:13 EDT 2009 x86_64 x86_64 x86_64 GNU/Linux

[tauser02@gfmwsp11lds ~]$ groovy -v
Groovy Version: 1.8.2 JVM: 1.6.0_20

I also tried it on Groovy 1.8.1",emilles,ericksn,,,,,,,,,,,"eric-milles opened a new pull request #1674:
URL: https://github.com/apache/groovy/pull/1674


   There is still some asymmetry between read and write for protected fields.  But I wasn't sure if I should add a protected check to read or remove the protected check from write (see `MetaClassImpl#setProperty` circa GROOVY-5985 comment).
   
   https://issues.apache.org/jira/browse/GROOVY-5001
   https://issues.apache.org/jira/browse/GROOVY-5491
   
   see also:
   https://issues.apache.org/jira/browse/GROOVY-662
   https://issues.apache.org/jira/browse/GROOVY-8065
   https://issues.apache.org/jira/browse/GROOVY-8074


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Jan/22 20:45;githubbot;600","danielsun1106 commented on a change in pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#discussion_r780601820



##########
File path: src/main/java/groovy/lang/MetaClassImpl.java
##########
@@ -2085,73 +2089,65 @@ public void setProperty(Object object, Object newValue) {
         checkInitalised();
 
         //----------------------------------------------------------------------
-        // turn getProperty on a Map to get on the Map itself
+        // getter
         //----------------------------------------------------------------------
-        if (!isStatic && this.isMap) {
-            return new MetaProperty(name, Object.class) {
-                @Override
-                public Object getProperty(Object object) {
-                    return ((Map) object).get(name);
-                }
-
-                @Override
-                public void setProperty(Object object, Object newValue) {
-                    throw new UnsupportedOperationException();
-                }
-            };
-        }
-
         Tuple2<MetaMethod, MetaProperty> methodAndProperty = createMetaMethodAndMetaProperty(sender, theClass, name, useSuper, isStatic);
         MetaMethod method = methodAndProperty.getV1();
 
-        //----------------------------------------------------------------------
-        // getter
-        //----------------------------------------------------------------------
-        MetaProperty mp = methodAndProperty.getV2();
+        if (method == null || ""class"".equals(name) || (isMap && ""empty"".equals(name))) {

Review comment:
       It's better to extract the common checking logic, here is same code at line 1981:
   `if (method == null || ""class"".equals(name) || (isMap && ""empty"".equals(name)))`




-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jan/22 00:44;githubbot;600","eric-milles commented on a change in pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#discussion_r780607867



##########
File path: src/main/java/groovy/lang/MetaClassImpl.java
##########
@@ -2085,73 +2089,65 @@ public void setProperty(Object object, Object newValue) {
         checkInitalised();
 
         //----------------------------------------------------------------------
-        // turn getProperty on a Map to get on the Map itself
+        // getter
         //----------------------------------------------------------------------
-        if (!isStatic && this.isMap) {
-            return new MetaProperty(name, Object.class) {
-                @Override
-                public Object getProperty(Object object) {
-                    return ((Map) object).get(name);
-                }
-
-                @Override
-                public void setProperty(Object object, Object newValue) {
-                    throw new UnsupportedOperationException();
-                }
-            };
-        }
-
         Tuple2<MetaMethod, MetaProperty> methodAndProperty = createMetaMethodAndMetaProperty(sender, theClass, name, useSuper, isStatic);
         MetaMethod method = methodAndProperty.getV1();
 
-        //----------------------------------------------------------------------
-        // getter
-        //----------------------------------------------------------------------
-        MetaProperty mp = methodAndProperty.getV2();
+        if (method == null || ""class"".equals(name) || (isMap && ""empty"".equals(name))) {

Review comment:
       Why is it better to extract?  `getProperty` and `getEffectiveMetaProperty` are essentially the same general structure, only differing in a few details.  I don't really have the energy to extract the true repeated structure(s).  You can follow the two methods and see the parallel, so I think it is decent in this state.




-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jan/22 01:21;githubbot;600","danielsun1106 commented on a change in pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#discussion_r780601820



##########
File path: src/main/java/groovy/lang/MetaClassImpl.java
##########
@@ -2085,73 +2089,65 @@ public void setProperty(Object object, Object newValue) {
         checkInitalised();
 
         //----------------------------------------------------------------------
-        // turn getProperty on a Map to get on the Map itself
+        // getter
         //----------------------------------------------------------------------
-        if (!isStatic && this.isMap) {
-            return new MetaProperty(name, Object.class) {
-                @Override
-                public Object getProperty(Object object) {
-                    return ((Map) object).get(name);
-                }
-
-                @Override
-                public void setProperty(Object object, Object newValue) {
-                    throw new UnsupportedOperationException();
-                }
-            };
-        }
-
         Tuple2<MetaMethod, MetaProperty> methodAndProperty = createMetaMethodAndMetaProperty(sender, theClass, name, useSuper, isStatic);
         MetaMethod method = methodAndProperty.getV1();
 
-        //----------------------------------------------------------------------
-        // getter
-        //----------------------------------------------------------------------
-        MetaProperty mp = methodAndProperty.getV2();
+        if (method == null || ""class"".equals(name) || (isMap && ""empty"".equals(name))) {

Review comment:
       It's better to extract the common checking logic, here is same code at line 1981:
   `if (method == null || ""class"".equals(name) || (isMap && ""empty"".equals(name)))`




-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jan/22 10:13;githubbot;600","eric-milles commented on a change in pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#discussion_r780607867



##########
File path: src/main/java/groovy/lang/MetaClassImpl.java
##########
@@ -2085,73 +2089,65 @@ public void setProperty(Object object, Object newValue) {
         checkInitalised();
 
         //----------------------------------------------------------------------
-        // turn getProperty on a Map to get on the Map itself
+        // getter
         //----------------------------------------------------------------------
-        if (!isStatic && this.isMap) {
-            return new MetaProperty(name, Object.class) {
-                @Override
-                public Object getProperty(Object object) {
-                    return ((Map) object).get(name);
-                }
-
-                @Override
-                public void setProperty(Object object, Object newValue) {
-                    throw new UnsupportedOperationException();
-                }
-            };
-        }
-
         Tuple2<MetaMethod, MetaProperty> methodAndProperty = createMetaMethodAndMetaProperty(sender, theClass, name, useSuper, isStatic);
         MetaMethod method = methodAndProperty.getV1();
 
-        //----------------------------------------------------------------------
-        // getter
-        //----------------------------------------------------------------------
-        MetaProperty mp = methodAndProperty.getV2();
+        if (method == null || ""class"".equals(name) || (isMap && ""empty"".equals(name))) {

Review comment:
       Why is it better to extract?  `getProperty` and `getEffectiveMetaProperty` are essentially the same general structure, only differing in a few details.  I don't really have the energy to extract the true repeated structure(s).  You can follow the two methods and see the parallel, so I think it is decent in this state.




-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jan/22 10:16;githubbot;600","eric-milles opened a new pull request #1674:
URL: https://github.com/apache/groovy/pull/1674


   There is still some asymmetry between read and write for protected fields.  But I wasn't sure if I should add a protected check to read or remove the protected check from write (see `MetaClassImpl#setProperty` circa GROOVY-5985 comment).
   
   https://issues.apache.org/jira/browse/GROOVY-5001
   https://issues.apache.org/jira/browse/GROOVY-5491
   
   see also:
   https://issues.apache.org/jira/browse/GROOVY-662
   https://issues.apache.org/jira/browse/GROOVY-8065
   https://issues.apache.org/jira/browse/GROOVY-8074


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jan/22 10:17;githubbot;600","paulk-asert commented on pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#issuecomment-1009908404


   I agree it would be good for the get and set behaviors to be aligned. The suggested external behavior seems okay and I would add 'metaClass' as an additional case to test for.
   
   What worries me is the change in behavior for closures. The following currently passes:
   ```
   class Foo {
       @Delegate Map m = [:]
       def x = 4
       protected y = 5
       private z = 6
       void method() {
           def w = 3
           assert 3 == { -> w }()
           assert null == { -> x }()
           assert null == { -> y }()
           assert null == { -> z }()
       }
   }
   
   class Bar {
       def x = 4
       protected y = 5
       private z = 6
       void method() {
           def w = 3
           assert 3 == { -> w }()
           assert 4 == { -> x }()
           assert 5 == { -> y }()
           assert 6 == { -> z }()
       }
   }
   
   new Foo().method()
   new Bar().method()
   ```
   This exhibits the ""potentially strange"" map takes precedence behavior but is at least consistent across `x`, `y`, and `z`.
   After the change, just the `x` behavior has altered precedence.
   
   My suspicion is that what you have is close but needs some more work. I am also thinking we might need to define a special Map metaclass that would provide back the old behavior - again it would be good to align get/set even for that case. Users relying on the old behavior could manually apply that metaclass. I would regard this as a legacy compatibility mechanism rather than something we would recommend is used for new development.


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;11/Jan/22 12:16;githubbot;600","eric-milles commented on pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#issuecomment-1010106711


   It was intended to make this read the property and not from the map:
   ```groovy
   class C {
       @Delegate Map m = [:]
       def x = 4
       public y = 5
       void method() {
           def v = 3
           assert 3 == { -> v }()
           assert 4 == { -> x }() // previously preferred map lookup
           assert 5 == { -> y }() // previously preferred map lookup
       }
   }
   ```
   
   I thought the first step would be to have read of `public` field or accessor gain precedence over map lookup.  For write it already includes `public` and `protected`.  I took the cautions approach by dealing with `public` first and leaving `protected` as-is.
   
   The idea here is that if you created a type that implements `Map` but then added public API, that API should take precedence over the general map property mechanism.
   
   For legacy support, any code may replace `name` with `get('name')` to stick with the map.


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;11/Jan/22 16:00;githubbot;600","eric-milles commented on pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#issuecomment-1013925732


   Added test cases for ""metaClass"" and ""MetaClass"" in dynamic groovy.  ""class"", ""Class"", ""empty"", ""Empty"", ""metaClass"" and ""MetaClass"" probably need tests under static compilation.


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Jan/22 18:16;githubbot;600","eric-milles edited a comment on pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#issuecomment-1013925732


   Added test cases for ""metaClass"" and ""MetaClass"" in dynamic groovy.  ""metaClass"", ""MetaClass"", ""Class"" and ""Empty"" probably need tests under static compilation.


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Jan/22 18:37;githubbot;600","eric-milles commented on pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#issuecomment-1013940781


   GROOVY-6151 is a good illustration of user expectations (comments added):
   {code:groovy}
   class TestError extends HashMap {
       String id
       boolean equals(Object o) {
           if (this.is(o)) return true
           if (getClass() != o.class) return false // ""o.class"" may not be ""getClass()"" for some types
           if (!super.equals(o)) return false
           TestError testError = (TestError) o
           if (id != testError.id) return false // ""id"" and ""this.id"" refer to the property; ""testError.id"" does not refer to ""getId()""
           return true
       }
   }
   {code}
   
   With this PR, all references to ""id"" will refer to the declared property and not a Map property.  ""class"" vs ""getClass()"" and ""empty"" vs ""isEmpty()"" remain unchanged.


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Jan/22 19:52;githubbot;600","eric-milles edited a comment on pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#issuecomment-1013940781


   GROOVY-6151 is a good illustration of user expectations (comments added):
   ```groovy
   class TestError extends HashMap {
       String id
       boolean equals(Object o) {
           if (this.is(o)) return true
           if (getClass() != o.class) return false // ""o.class"" may not be ""getClass()"" for some types
           if (!super.equals(o)) return false
           TestError testError = (TestError) o
           if (id != testError.id) return false // ""id"" and ""this.id"" refer to the property; ""testError.id"" does not refer to ""getId()""
           return true
       }
   }
   ```
   
   With this PR, all references to ""id"" will refer to the declared property and not a Map property.  ""class"" vs ""getClass()"" and ""empty"" vs ""isEmpty()"" remain unchanged.


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Jan/22 19:52;githubbot;600","sonatype-lift[bot] commented on a change in pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#discussion_r785487229



##########
File path: src/main/java/groovy/lang/MetaClassImpl.java
##########
@@ -1959,100 +1959,105 @@ public void setProperties(Object bean, Map map) {
      * @return the given property's value on the object
      */
     @Override
-    public Object getProperty(Class sender, Object object, String name, boolean useSuper, boolean fromInsideClass) {
+    public Object getProperty(final Class sender, final Object object, final String name, final boolean useSuper, final boolean fromInsideClass) {
 
         //----------------------------------------------------------------------
         // handling of static
         //----------------------------------------------------------------------
-        boolean isStatic = theClass != Class.class && object instanceof Class;
+        boolean isStatic = (theClass != Class.class && object instanceof Class);
         if (isStatic && object != theClass) {
-            MetaClass mc = registry.getMetaClass((Class) object);
+            MetaClass mc = registry.getMetaClass((Class<?>) object);
             return mc.getProperty(sender, object, name, useSuper, false);
         }
 
         checkInitalised();
 
         //----------------------------------------------------------------------
-        // turn getProperty on a Map to get on the Map itself
+        // getter
         //----------------------------------------------------------------------
-        if (!isStatic && this.isMap) {
-            return ((Map) object).get(name);
-        }
-
         Tuple2<MetaMethod, MetaProperty> methodAndProperty = createMetaMethodAndMetaProperty(sender, sender, name, useSuper, isStatic);
         MetaMethod method = methodAndProperty.getV1();
 
-        //----------------------------------------------------------------------
-        // getter
-        //----------------------------------------------------------------------
-        MetaProperty mp = methodAndProperty.getV2();
+        if (method == null || isSpecialProperty(name)) {
+            //------------------------------------------------------------------
+            // public field
+            //------------------------------------------------------------------
+            MetaProperty mp = methodAndProperty.getV2();
+            if (mp != null && Modifier.isPublic(mp.getModifiers())) {
+                try {
+                    return mp.getProperty(object);
+                } catch (IllegalArgumentException | CacheAccessControlException e) {
+                    // can't access the field directly but there may be a getter
+                    mp = null;
+                }
+            }
 
-        //----------------------------------------------------------------------
-        // field
-        //----------------------------------------------------------------------
-        if (method == null && mp != null) {
-            try {
-                return mp.getProperty(object);
-            } catch (IllegalArgumentException | CacheAccessControlException e) {
-                // can't access the field directly but there may be a getter
-                mp = null;
+            //------------------------------------------------------------------
+            // java.util.Map get method
+            //------------------------------------------------------------------
+            if (isMap && !isStatic) {
+                return ((Map<?,?>) object).get(name);
             }
-        }
 
-        // check for propertyMissing provided through a category
-        Object[] arguments = EMPTY_ARGUMENTS;
-        if (method == null && !useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()) {
-            method = getCategoryMethodGetter(sender, PROPERTY_MISSING, true);
-            if (method != null) arguments = new Object[]{name};
+            //------------------------------------------------------------------
+            // non-public field
+            //------------------------------------------------------------------
+            if (mp != null) {
+                try {
+                    return mp.getProperty(object);
+                } catch (IllegalArgumentException | CacheAccessControlException e) {

Review comment:
       *EmptyCatch:*  Caught exceptions should not be ignored [(details)](https://google.github.io/styleguide/javaguide.html#s6.2-caught-exceptions)
   (at-me [in a reply](https://help.sonatype.com/lift/talking-to-lift) with `help` or `ignore`)




-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Jan/22 19:54;githubbot;600","eric-milles commented on a change in pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#discussion_r785488573



##########
File path: src/main/java/groovy/lang/MetaClassImpl.java
##########
@@ -1959,100 +1959,105 @@ public void setProperties(Object bean, Map map) {
      * @return the given property's value on the object
      */
     @Override
-    public Object getProperty(Class sender, Object object, String name, boolean useSuper, boolean fromInsideClass) {
+    public Object getProperty(final Class sender, final Object object, final String name, final boolean useSuper, final boolean fromInsideClass) {
 
         //----------------------------------------------------------------------
         // handling of static
         //----------------------------------------------------------------------
-        boolean isStatic = theClass != Class.class && object instanceof Class;
+        boolean isStatic = (theClass != Class.class && object instanceof Class);
         if (isStatic && object != theClass) {
-            MetaClass mc = registry.getMetaClass((Class) object);
+            MetaClass mc = registry.getMetaClass((Class<?>) object);
             return mc.getProperty(sender, object, name, useSuper, false);
         }
 
         checkInitalised();
 
         //----------------------------------------------------------------------
-        // turn getProperty on a Map to get on the Map itself
+        // getter
         //----------------------------------------------------------------------
-        if (!isStatic && this.isMap) {
-            return ((Map) object).get(name);
-        }
-
         Tuple2<MetaMethod, MetaProperty> methodAndProperty = createMetaMethodAndMetaProperty(sender, sender, name, useSuper, isStatic);
         MetaMethod method = methodAndProperty.getV1();
 
-        //----------------------------------------------------------------------
-        // getter
-        //----------------------------------------------------------------------
-        MetaProperty mp = methodAndProperty.getV2();
+        if (method == null || isSpecialProperty(name)) {
+            //------------------------------------------------------------------
+            // public field
+            //------------------------------------------------------------------
+            MetaProperty mp = methodAndProperty.getV2();
+            if (mp != null && Modifier.isPublic(mp.getModifiers())) {
+                try {
+                    return mp.getProperty(object);
+                } catch (IllegalArgumentException | CacheAccessControlException e) {
+                    // can't access the field directly but there may be a getter
+                    mp = null;
+                }
+            }
 
-        //----------------------------------------------------------------------
-        // field
-        //----------------------------------------------------------------------
-        if (method == null && mp != null) {
-            try {
-                return mp.getProperty(object);
-            } catch (IllegalArgumentException | CacheAccessControlException e) {
-                // can't access the field directly but there may be a getter
-                mp = null;
+            //------------------------------------------------------------------
+            // java.util.Map get method
+            //------------------------------------------------------------------
+            if (isMap && !isStatic) {
+                return ((Map<?,?>) object).get(name);
             }
-        }
 
-        // check for propertyMissing provided through a category
-        Object[] arguments = EMPTY_ARGUMENTS;
-        if (method == null && !useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()) {
-            method = getCategoryMethodGetter(sender, PROPERTY_MISSING, true);
-            if (method != null) arguments = new Object[]{name};
+            //------------------------------------------------------------------
+            // non-public field
+            //------------------------------------------------------------------
+            if (mp != null) {
+                try {
+                    return mp.getProperty(object);
+                } catch (IllegalArgumentException | CacheAccessControlException e) {

Review comment:
       @sonatype-lift ignore




-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Jan/22 20:08;githubbot;600","sonatype-lift[bot] commented on a change in pull request #1674:
URL: https://github.com/apache/groovy/pull/1674#discussion_r785488576



##########
File path: src/main/java/groovy/lang/MetaClassImpl.java
##########
@@ -1959,100 +1959,105 @@ public void setProperties(Object bean, Map map) {
      * @return the given property's value on the object
      */
     @Override
-    public Object getProperty(Class sender, Object object, String name, boolean useSuper, boolean fromInsideClass) {
+    public Object getProperty(final Class sender, final Object object, final String name, final boolean useSuper, final boolean fromInsideClass) {
 
         //----------------------------------------------------------------------
         // handling of static
         //----------------------------------------------------------------------
-        boolean isStatic = theClass != Class.class && object instanceof Class;
+        boolean isStatic = (theClass != Class.class && object instanceof Class);
         if (isStatic && object != theClass) {
-            MetaClass mc = registry.getMetaClass((Class) object);
+            MetaClass mc = registry.getMetaClass((Class<?>) object);
             return mc.getProperty(sender, object, name, useSuper, false);
         }
 
         checkInitalised();
 
         //----------------------------------------------------------------------
-        // turn getProperty on a Map to get on the Map itself
+        // getter
         //----------------------------------------------------------------------
-        if (!isStatic && this.isMap) {
-            return ((Map) object).get(name);
-        }
-
         Tuple2<MetaMethod, MetaProperty> methodAndProperty = createMetaMethodAndMetaProperty(sender, sender, name, useSuper, isStatic);
         MetaMethod method = methodAndProperty.getV1();
 
-        //----------------------------------------------------------------------
-        // getter
-        //----------------------------------------------------------------------
-        MetaProperty mp = methodAndProperty.getV2();
+        if (method == null || isSpecialProperty(name)) {
+            //------------------------------------------------------------------
+            // public field
+            //------------------------------------------------------------------
+            MetaProperty mp = methodAndProperty.getV2();
+            if (mp != null && Modifier.isPublic(mp.getModifiers())) {
+                try {
+                    return mp.getProperty(object);
+                } catch (IllegalArgumentException | CacheAccessControlException e) {
+                    // can't access the field directly but there may be a getter
+                    mp = null;
+                }
+            }
 
-        //----------------------------------------------------------------------
-        // field
-        //----------------------------------------------------------------------
-        if (method == null && mp != null) {
-            try {
-                return mp.getProperty(object);
-            } catch (IllegalArgumentException | CacheAccessControlException e) {
-                // can't access the field directly but there may be a getter
-                mp = null;
+            //------------------------------------------------------------------
+            // java.util.Map get method
+            //------------------------------------------------------------------
+            if (isMap && !isStatic) {
+                return ((Map<?,?>) object).get(name);
             }
-        }
 
-        // check for propertyMissing provided through a category
-        Object[] arguments = EMPTY_ARGUMENTS;
-        if (method == null && !useSuper && !isStatic && GroovyCategorySupport.hasCategoryInCurrentThread()) {
-            method = getCategoryMethodGetter(sender, PROPERTY_MISSING, true);
-            if (method != null) arguments = new Object[]{name};
+            //------------------------------------------------------------------
+            // non-public field
+            //------------------------------------------------------------------
+            if (mp != null) {
+                try {
+                    return mp.getProperty(object);
+                } catch (IllegalArgumentException | CacheAccessControlException e) {

Review comment:
       I've recorded this as ignored for this pull request. If you change your mind, just comment `@sonatype-lift unignore`.




-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Jan/22 20:08;githubbot;600","eric-milles merged pull request #1674:
URL: https://github.com/apache/groovy/pull/1674


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;25/Jan/22 18:20;githubbot;600",,0,9600,,,0,9600,,,,,,,,,GROOVY-5491,GROOVY-662,GROOVY-8065,GROOVY-8074,GROOVY-6144,GROOVY-8555,,,,,,,,,"04/Jan/22 15:31;emilles;screenshot-1.png;https://issues.apache.org/jira/secure/attachment/13038253/screenshot-1.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 25 18:21:14 UTC 2022,,,,,,,,,,"0|i2c9cv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jan/12 15:42;ericksn;just tested this on 1.8.5 and it still is a problem;;;","03/Jan/12 15:47;melix;Formatting tags;;;","14/Jan/12 05:27;paulk;This isn't specific to the logging annotations since {{Test4}} below works fine but not {{Test5}} which extends {{Properties}}:
{code}
class Test4 {
    private log = [info: { println it }]
    def test () {
         println 'testing Groovy class that doesn't extend java.util.Properties'
         println ""testing class [${this.getClass().getSimpleName()}]""
    }
    def method () {
        log.info 'method called, not in closure'
        ['a', 'b', 'c'].each { log.info ""inside closure [$it]"" }
    }
}

class Test5 extends java.util.Properties {
    private log = [info: { println it }]
    def test () {
         println 'testing Groovy class that extends java.util.Properties'
         println ""testing class [${this.getClass().getSimpleName()}]""
    }
    def method () {
        log.info 'method called, not in closure'
        ['a', 'b', 'c'].each { log.info ""inside closure [$it]"" }
    }
}
{code};;;","14/Jan/12 17:46;ericksn;good point! Can the title of this bug be changed?;;;","16/Jan/12 05:59;paulk;changed;;;","04/Jan/22 15:34;emilles;This can still be seen in 2022. The light blue indicates field resolution, which is ""two()"" and ""three"" outside of closure (aka subclass) and only ""two()"" within closure (aka subclass).  Both instances of ""one"" resolve to map property since they are superclass fields and there is no callable conversion.

[~paulk]
Is there any desire to alter this lookup order?  Or can this be closed as works by design?

!screenshot-1.png!;;;","07/Jan/22 17:45;emilles;[~paulk]
My proposal to lower the precedence of Map#get is this:
# Allow access method (getName() or isName()) to be called through ""name"" (GROOVY-662) when not ""empty"" or ""class""
# Allow public field to be read before map property
# Non-public fields would still have precedence below map get
# The precedence of put would be fixed to match (GROOVY-5491)

That is, the ""empty"" variables in the above screenshot would remain a reference to map property (greenish).  Otherwise, maps would stop supporting map['empty'] and map['class'] (unless a bunch of extra checking was implemented).  And the variables ""one"" and ""three"" would all refer to the declared fields/properties (blueish).

This illustrates the proposal.  I think this would be fairly safe to do and give most of what is expected.
{code:groovy}
            class C {
                @Delegate Map m = [:]
                private def x = 'x'
                public  def y = 'y'
                def getZ() { 'z' }
            }
            def c = new C()

            assert c.class == null
            assert c.empty == null
            assert c.m === c.@m
            assert c.x == null
            assert c.y == 'y'
            assert c.z == 'z'
{code};;;","07/Jan/22 20:45;emilles;https://github.com/apache/groovy/pull/1674;;;","25/Jan/22 18:21;emilles;https://github.com/apache/groovy/commit/051d3cf3ef29a521137b9d6b71cb8097d077d46b;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong constructor call generated with AIC + closure usage,GROOVY-5000,12817209,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,roshandawrani,roshandawrani,07/Sep/11 10:54,09/Sep/11 06:43,14/Jul/23 06:00,08/Sep/11 17:10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,,,,,0,,,,,,"This issue is raised based on dev mailing list discussion here: http://markmail.org/message/ksngkezqgqazpz5q

Here are the code snippets that demonstrate the issue with constructor call generation when anonymous inner classes and closure are used together.

1)
{code}
interface X{}

final double delta = 0.1
(0 ..< 1).collect { n ->
    new X () {
        Double foo () {
            delta
        }
    }
}
{code}

fails with
{noformat}
Caught: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: TryGroovy$1(TryGroovy, java.lang.Double)
{noformat}

2) Seems like there is some mix-up with the variables used from the enclosing context. In this snippet, I use 2 variables from enclosing context, and both become part of constructor call that fails.

{code}
interface X{}

final double delta1 = 0.1
final double delta2 = 0.1
(0 ..< 1).collect { n ->
    new X () {
        Double foo () {
            delta1 + delta2
        }
    }
}
{code}

fails with:

{noformat}
Caught: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: TryGroovy$1(TryGroovy, java.lang.Double, java.lang.Double)
{noformat}",,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 09 06:43:45 UTC 2011,,,,,,,,,,"0|i2c7if:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Sep/11 17:10;blackdrag;fixed;;;","09/Sep/11 04:02;russel;I just pulled and reinstalled, but I still get the errant behaviour :-(;;;","09/Sep/11 05:25;russel;Experiment shows that Roshan's code highlights a bug that has been present in 1.8.0, 1.8.1 and 1.8.2 but is now fixed in HEAD.  The problem I am having with my Pi_Quadrature codes is not present in 1.8.0 and 1.8.1, but is present in 1.8.2 and remain in HEAD after this fix commit.  The hypothesis must be that the problem in Pi_Quadrature is in fact different from these small tests  which have highlighted a bug we didn't know we had!

I'll see if I can trim one of my programs to something different than the above that shows the fault and create a new issue.  This issue is quite properly closed. ;;;","09/Sep/11 06:43;russel;The continuation issue is GROOVY-5006.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Runtime error on static overloaded mixin method,GROOVY-4999,12818103,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,sehseh,sehseh,06/Sep/11 05:25,14/Oct/11 00:28,14/Jul/23 06:00,12/Sep/11 20:28,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,class generator,Compiler,,,0,exception,runtime,,,,"I have a class with static utility methods. I have done 'mixin' this class into another class using @Mixin annotation and then while calling static overloaded method I give runtime error.

Utility class:
{code}
class UtilClass {
    public void callClassOverloadedMethod(String s) {
        System.out.println(""callClassOverloadedMethod(String)"");
    }
    public void callClassOverloadedMethod(String s, Object o) {
        System.out.println(""callClassOverloadedMethod(String, Object)"");
    }
    public static void callStaticOverloadedMethod(String s) {
        System.out.println(""callStaticOverloadedMethod(String)"");
    }
    public static void callStaticOverloadedMethod(String s, Object o) {
        System.out.println(""callStaticOverloadedMethod(String, Object)"");
    }
}
{code}
Main class:
{code}
@Mixin(UtilClass)
class MainClass {
    public static void main(String []s) {
        MainClass mc = new MainClass()
        mc.callMixinMethods()
    }

    void callMixinMethods() {
        callClassOverloadedMethod("""")
        callStaticOverloadedMethod("""")
    }
}
{code}
Run command:
{noformat}
groovy -cp . MainClass
{noformat}
Error:
{noformat}
Caught: org.codehaus.groovy.runtime.metaclass.MethodSelectionException: Could not find which method callStaticOverloadedMethod() to invoke from this list:
  public static void UtilClass#callStaticOverloadedMethod(java.lang.String)
  public static void UtilClass#callStaticOverloadedMethod(java.lang.String, java.lang.Object)
        at MainClass.callMixinMethod(MainClass.groovy:20)
        at MainClass.main(MainClass.groovy:12)
{noformat}

Please fix this trouble, it prevent me to write code and tests.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Sep/11 23:52;roshandawrani;Patch_Master.diff;https://issues.apache.org/jira/secure/attachment/12722974/Patch_Master.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 12 09:47:28 UTC 2011,,,,,,,,,,"0|i2c69j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"07/Sep/11 14:33;paulk;add code tags;;;","11/Sep/11 23:52;roshandawrani;Attached patch with a suggested fix.

Works with the test case provided (will add it formally if the fix looks ok).;;;","12/Sep/11 03:28;blackdrag;feel free to commit;;;","12/Sep/11 09:12;sehseh;Thanks! This patch works for me. When can I see changes in production release?;;;","12/Sep/11 09:18;roshandawrani;The daily snapshots should include this patch by tonight (http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all/);;;","12/Sep/11 09:43;blackdrag;But you did not yet commit Roshan, did you?;;;","12/Sep/11 09:47;roshandawrani;No. That's why I said it will be there by tonight, otherwise the snapshot-with-the-fix would have already been there :-)

Not near my computer at the moment. Will be in a couple of hours.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Immutable not working for inner classes,GROOVY-4997,12815703,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,codevise,codevise,02/Sep/11 08:27,13/May/12 03:30,14/Jul/23 06:00,22/Feb/12 01:03,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,,,,,0,breaking,,,,,"{code}
class A {
    @Immutable
    class B {  
    }
}
{code}
throws
{code}
Explicit constructors not allowed for @Immutable class: A$B
 at line: -1, column: -1
{code}",,paulk,sgrossman,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 22 01:39:19 UTC 2012,,,,,,,,,,"0|i2c9jb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Sep/11 12:39;sgrossman;I can appreciate that @Immutable will not work for a _non_-static inner class (such as B) due to its implicit constructor that takes the outer class (A, in this case) as an argument.

However, it also fails with the ""explicit constructors not allowed"" error when the inner class _is_ static.  Specifically, the following class also fails.

{code}
class A {
    @Immutable
    static class B {  
    }
}
{code}
;;;","15/Sep/11 09:39;roshandawrani;Regarding making the static version work - we can surely look for Immutable annotation on inner class and not add the constructor here if the inner class is static, but I don't particularly like this string coupling of implementation of one feature with another. Anyone sees another, simpler way of doing it?

An alternative could be to do ImmutableASTTransformation.validateConstructors() a little differently - that if it finds an empty no-arg constructor, it can get rid of it, and add its own as usual.

Any other suggestions?

{code}
class A {
    @Immutable
    static class B {}
}
{code}
;;;","15/Sep/11 17:32;paulk;@Roshan, your last suggestion sounds like the way to go.;;;","20/Sep/11 01:35;roshandawrani;For static inner classes, the fix is done now in v1.8.3-SNAPSHOT and v1.9.0-beta-4-SNAPSHOT.;;;","22/Feb/12 01:03;paulk;This should be working now. For 2.0, part of the logic for handling inner classes (constructor tweaking) was moved until a later phase. This means that Roshan's fix mentioned in earlier comments is no longer required for 2.0 but it remains in place for 1.8.x as a partial fix for static inner classes.;;;","22/Feb/12 01:39;paulk;adding 'breaking' label - shouldn't break user code, nor most transforms but might impact transforms that play with constructors;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy-all-1.7.8 in Codehaus Maven repository is actually 1.7.9-SNAPSHOT,GROOVY-4995,12815843,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,kpshek,kpshek,31/Aug/11 10:12,07/Sep/11 14:13,14/Jul/23 06:00,01/Sep/11 22:43,1.7.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2,,,,,,"See http://groovy.markmail.org/message/tvfmmgieh4sgdkkr

The groovy-all-1.7.8 in the Codehaus Maven repository is actually a 1.7.9-SNAPSHOT. Thus, anyone download groovy-all-1.7.8 from this location is unknowingly getting a 1.7.9-SNAPSHOT.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 01 22:43:55 UTC 2011,,,,,,,,,,"0|i2bn53:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Sep/11 22:43;kpshek;Jochen Theodorou fixed this today by redeploying 1.7.8 to the Codehaus Maven repository.

See http://groovy.markmail.org/message/tvfmmgieh4sgdkkr for the details.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
wrong delegate for ComposedClosure,GROOVY-4994,12815684,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,30/Aug/11 14:34,30/Aug/11 15:06,14/Jul/23 06:00,30/Aug/11 15:06,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,,,,,0,,,,,,"{code:Java}
def a = { println foo }
def b = { println bar }

class O {
    def foo = 'foo'
    def bar = 'bar'
}

def ab = a >> b
ab.delegate = new O()
ab()
{code}
throws groovy.lang.MissingPropertyException: No such property: foo for class: ConsoleScript5",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 30 15:06:56 UTC 2011,,,,,,,,,,"0|i2bpfr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Aug/11 15:06;blackdrag;fixed in a7b4af5d58be26a0dbabe7dac941a7c26470438c;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper fails to correctly parse strings containing some escaped character sequences,GROOVY-4988,12815816,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,ltpcsucs,ltpcsucs,25/Aug/11 11:26,24/Dec/11 03:07,14/Jul/23 06:00,07/Nov/11 09:37,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.4,2.0-beta-1,,JSON,,,,0,,,,,,It seems JsonSlurper does not successfully parse serialized objects that originally contain character sequences like \n \t etc.,Windows 7 x32 (intel)/Java(TM) SE Runtime Environment (build 1.6.0_23-b05),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"25/Aug/11 11:26;ltpcsucs;bug_script.groovy;https://issues.apache.org/jira/secure/attachment/12722968/bug_script.groovy","05/Sep/11 04:18;ltpcsucs;bug_script_assert.groovy;https://issues.apache.org/jira/secure/attachment/12722970/bug_script_assert.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 24 08:25:51 UTC 2011,,,,,,,,,,"0|i2cgxj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Aug/11 11:51;guillaume;Could you use assert statements in your script to tell me exactly what you would want to see?;;;","31/Aug/11 12:19;guillaume;I guess you'd expect {{assert erroneous == deserialized}} ?;;;","05/Sep/11 04:18;ltpcsucs;Added assert at the end of the script. Thanks.;;;","24/Nov/11 07:57;gabrielsz;I have another case pretty much like this one, and fails on 1.8.4. Should I reopen this bug or create a new one?


Groovy Version: 1.8.4 JVM: 1.6.0_21 (Ubuntu Linux 11.10 32-bit)
;;;","24/Nov/11 08:07;guillaume;Please open a new one.;;;","24/Nov/11 08:25;gabrielsz;Thanks, I've submitted bug# GROOVY-5144;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.sql.Timestamp + int = java.util.Date,GROOVY-4986,12817017,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,driscoll,driscoll,24/Aug/11 13:40,05/Apr/15 14:44,14/Jul/23 06:00,03/Dec/11 11:37,1.6.9,1.7.10,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,groovy-jdk,,,,0,,,,,,"The following code:

{code:Java}
def d = new Date()
def t = new java.sql.Timestamp(d.getTime())
println t.class
t = t + 1
println t.class
{code}
Produces the following output:

class java.sql.Timestamp
class java.util.Date


This behavior is unexpected, and is causing us a small problem.  The fix would be to change the org.codehaus.groovy.runtime.DateGroovyMethods.plus(Date,int) method to be as follows:
{code:Java}
    public static Date plus(Date self, int days) {
        Calendar calendar = (Calendar) Calendar.getInstance().clone();
        calendar.setTime(self);
        calendar.add(Calendar.DAY_OF_YEAR, days);
        if (self instanceof java.sql.Timestamp) {
            java.sql.Timestamp ts = new java.sql.Timestamp(calendar.getTime().getTime());
            ts.setNanos(((java.sql.Timestamp)self).getNanos());
            return ts;
        }
        return calendar.getTime();
    }
{code}

",This bug appears to be platform and JDK independant.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Wed Aug 24 15:45:17 UTC 2011,,,,,,,,,,"0|i2by7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Aug/11 13:54;blackdrag;fixed code tags;;;","24/Aug/11 13:56;blackdrag;actually I think adding {code:Java}public static Timestamp plus(Timestamp self, int days) {
        Calendar calendar = (Calendar) Calendar.getInstance().clone();
        calendar.setTime(self);
        calendar.add(Calendar.DAY_OF_YEAR, days);
        Timestamp ts = new Timestamp(calendar.getTime().getTime());
        ts.setNanos(self).getNanos());
        return ts;
    }{code}
is a better way than an instanceof check in the method;;;","24/Aug/11 15:45;driscoll;It's a matter of taste, but since there's already a separate method for java.sql.Date, I'm inclined to agree with you.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonOutput.toJson(object) does not handle char[] correctly,GROOVY-4984,12815833,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,seth.miller,seth.miller,23/Aug/11 12:30,07/Sep/11 14:13,14/Jul/23 06:00,31/Aug/11 11:47,1.8.0,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,groovy-jdk,,,,0,,,,,,"Currently {quote}println new JsonBuilder(['a','b','c','d'] as char[]).toString(){quote} will output {quote}[{},{},{},{}]{quote} since the primitive class {{char}} has no properties (other than {{class}}).

My solution is to call {{toString}} on the object if there are no properties left. I have attached an updated JsonOutput.groovy and a fixed test.",,seth.miller,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Aug/11 10:01;seth.miller;GROOVY-4984.patch;https://issues.apache.org/jira/secure/attachment/12722969/GROOVY-4984.patch","23/Aug/11 12:30;seth.miller;JsonOutput.groovy;https://issues.apache.org/jira/secure/attachment/12722966/JsonOutput.groovy","23/Aug/11 12:30;seth.miller;JsonOutputTest.groovy;https://issues.apache.org/jira/secure/attachment/12722967/JsonOutputTest.groovy",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 31 11:47:47 UTC 2011,,,,,,,,,,"0|i2c587:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"28/Aug/11 10:01;seth.miller;Here is a patch file with my changes, if that helps.;;;","31/Aug/11 06:46;guillaume;I've got a slightly different view on this issue.
I think char[] should be represented as a String, ie. ['a','b','c','d'] as char[] would be ""abcd"".;;;","31/Aug/11 08:58;seth.miller;I'm afraid I would have to disagree. If someone has gone through the trouble of dealing with a char array, it is likely that they wanted to work with the individual chars. At least this was the case for me.;;;","31/Aug/11 09:49;guillaume;Ok fair enough.;;;","31/Aug/11 11:47;guillaume;Implemented as a JSON array of single-character strings;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Integer multiples of 256 evaluate to false.,GROOVY-4983,12818410,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,huxi,huxi,22/Aug/11 14:53,30/Aug/11 04:26,14/Jul/23 06:00,30/Aug/11 04:26,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,,,,,0,,,,,,"groovy -e ""assert 256""
groovy -e ""assert 512""
and so on will fail.",Groovy Version: 1.8.1 JVM: 1.6.0_26,jhuxhorn,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 30 04:26:20 UTC 2011,,,,,,,,,,"0|i2chp3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Aug/11 04:26;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Code examples on website are not visible,GROOVY-4981,12815691,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,guillaume,redshadow,redshadow,20/Aug/11 20:20,21/Dec/12 09:46,14/Jul/23 06:00,21/Dec/12 09:46,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1,,,,,,"The code snippets in the user guide, cookbook, and elsewhere on groovy.codehaus.org are not visible.  Instead of a box containing something like:
println 'Hello World'
A small empty rectangle is displayed instead.
It looks like this syntax highlighter library is being used: http://alexgorbatchev.com/SyntaxHighlighter/manual/installation.html.  However, looking at the source of the page it appears that the javascript and css libraries that it uses aren't actually loaded, nor is the SyntaxHighlighter.all() JavaScript method invoked.
",,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Aug/11 20:20;redshadow;Groovy - Process Management.html;https://issues.apache.org/jira/secure/attachment/12722965/Groovy+-+Process+Management.html","20/Aug/11 20:20;redshadow;Groovy_Website_Code_Not_Visible.png;https://issues.apache.org/jira/secure/attachment/12722964/Groovy_Website_Code_Not_Visible.png",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 21 09:40:05 UTC 2012,,,,,,,,,,"0|i2bro7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Aug/11 04:24;blackdrag;Looks like a confluence problem. I filled HAUS-2113 for it;;;","23/Aug/11 16:52;paulk;The code samples are now back but without syntax highlighting - at least for the moment.;;;","06/Oct/11 09:49;beldenge;I can see the code samples on the home page, but I am still unable to see the code samples on the following pages for example:

http://groovy.codehaus.org/Tutorial+1+-+Getting+started
http://groovy.codehaus.org/Quick+Start

All I see are empty boxes.  I've tried with IE 8, Firefox 7, and Chrome 14.;;;","06/Oct/11 09:54;redshadow;George, I can see the code samples, but I have to turn on Javascript.  I'm using Firefox 3.6.23 and Firefox 7.;;;","06/Oct/11 10:01;beldenge;John, thanks for the reply.  I have JavaScript enabled on all my browsers, but still no luck seeing the samples.  I'm currently on Windows 7.

I can in fact see the samples from my android phone however.;;;","06/Oct/11 10:12;beldenge;This may actually be a firewall issue.  I'll confirm this later today and post an update here.  Thanks again.;;;","06/Oct/11 20:38;paulk;I definitely can't see them behind a corporate firewall of one of my customers when using IE. I suspect their IE configuration or firewall stops scripts loading from third-party sites. It seems to work from other browsers at that site though - so perhaps their IE config is the culprit.;;;","06/Oct/11 20:44;beldenge;Yes I can confirm that the code samples are just being blocked by the firewall, as I'm home on the same laptop and now I can see them.  I'm guessing the JavaScript is being blocked.

I apologize for raising the concern.;;;","21/Dec/12 09:40;pschumacher;As per previous comment this was caused by a firewall. The issue should be closed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Named argument constructor doesn't work for inner classes,GROOVY-4980,12815797,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,pniederw,pniederw,19/Aug/11 17:58,14/Oct/11 00:28,14/Jul/23 06:00,13/Sep/11 12:37,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,Compiler,,,,0,,,,,,"{code}
class Outer {
  class Inner {
    String name
  }

  def doit() {
    new Inner(name: ""fred"")
  }
}

new Outer().doit()
{code}

{noformat}
Caught: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: Outer$Inner(Outer, java.util.LinkedHashMap)
	at Outer.doit(OuterF.groovy:7)
	at OuterF.run(OuterF.groovy:11)
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"13/Sep/11 00:34;roshandawrani;commit-36655bb.diff;https://issues.apache.org/jira/secure/attachment/12722976/commit-36655bb.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 13 08:14:37 UTC 2011,,,,,,,,,,"0|i2bn7r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Sep/11 00:34;roshandawrani;Attaching a patch for review.;;;","13/Sep/11 04:48;blackdrag;I somehow remember a problem with Class#getEnclosingClass. Some of these methods are working only if the class file bytecode version is really 1.5 or higher. Our default is still 1.4. But since your example is not using 1.5 code and is still working that might not be the case here. Otherwise the patch looks just fine to me;;;","13/Sep/11 05:12;roshandawrani;1) My understanding was that Groovy version >= 1.7, we only generate V1_5 bytecode (major version = 49) and that's why we don't have JDK 1.4 builds anymore for these Groovy versions. Is that incorrect?

2) Even if our intention is to generate JDK 1.4-compliant code based on features (annotations, generics) being used in the Groovy code, I don't think it will ever do it in practice. The reason being that ResolveVisitor.resolveGenericsTypes() unconditionally sets usesGenerics = true on every classnode it processes. Due to that the bytecode being generated for class Outer in the example code of this issue is still V1_5 and not V1_3.

Am I misreading something?;;;","13/Sep/11 05:47;blackdrag;I am quite sure we don't produce V1_5 always. But anyway, we should make it the default for all branches;;;","13/Sep/11 05:51;roshandawrani;So, r u saying that I can assume it is ok to assume V1_5 is default and apply the patch?;;;","13/Sep/11 06:51;blackdrag;No... I am saying we have to ensure 1.5 is the default first.;;;","13/Sep/11 06:59;roshandawrani;To me it looks like we only produce V1_5 bytecode anyway. Ensuring that we only produce V1_5 code should be simple by having AsmClassGenerator.getBytecodeVersion() always return Opcodes.V1_5.

The real questions are:

a) are we we clear that it's no longer our intention to try and produce V1_3 bytecode (as was the confusion in an earlier comment here).

b) your doubt that we don't always produce V1_5 bytecode as of now even in newer Groovy versions (>= 1.7). When is that, and why is that? If it is really needed, then it's not my call to always ensure V1_5 code.;;;","13/Sep/11 07:20;blackdrag;(a) I spoke with Guillaume about that and we agreed that we should migrate to V1_5. 
(b) If you want to see an example of when we produce V1_3 code I suggest you take class X { class Y {}} and look at the generated bytecode. I see there the usage of class version 47, which is V1_3. I would have said we don't need to go that far and can take the example above, but it actually shows that there is a very uneven handling of these things. Outer get the class version 49, Outer.Inner 47. Since we need 49 on Inner there is still the danger of your patch not working. Anayway... I think the point that 49 is not always used is clear now.

As for AsmClassGenerator.getBytecodeVersion().. I guess we can change it to always return V1_5 for now, but I think in the long term we have to adjust the logic with CompilerConfiguration as well.
;;;","13/Sep/11 07:31;roshandawrani;True. Misread ResolveVisitor.resolveGenericsTypes()'s ""if (types == null) return"". Sorry.

So, I will change the bytecode version in ASM to V1_5 on 1.8.x and master and then apply this patch. If it becomes clear where adjustments need to be made to CompilerConfiguration, will do that as well.

Thanks.;;;","13/Sep/11 08:04;blackdrag;I am wondering if we should push that to 1.7 as well;;;","13/Sep/11 08:08;roshandawrani;Not sure if it makes sense to remove support for V1_3 after 1.7.""10"". 

I would rather 1.7.11 also has the support, but then this fix and ensure-V1_5 go hand in hand. If we want to push this feature to 1.7.x line, we will need to remove support for V1_3 in whatever shape it exists currently.;;;","13/Sep/11 08:14;blackdrag;I think you are right. Btw, thanks for working on this Roshan;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@ToString creates additional unneeded field,GROOVY-4979,12815679,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,johann,johann,19/Aug/11 14:36,13/May/12 03:30,14/Jul/23 06:00,19/Feb/12 01:24,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,,,,,0,annotation,ast,toString,transform,,"Using {{@ToString(includeNames = true)}} inserts a field called {{$print$names}} into the class. This field is neither transient nor static, which causes havoc when using XStream.

Example XStream output:

{code}
[
  {
    ""name"": ""&#12415; +()[]{}.mp3"",
    ""size"": 690037,
    ""outputSize"": 0,
    ""format"": {
      ""codec"": ""mp3"",
      ""name"": ""mp3"",
      ""bitDepth"": ""s16le"",
      ""samplingRate"": 44100,
      ""channels"": 2,
      ""$print$names"": true
    }
  }
]
{code}

I don't understand why the field is there in the first place since printNames is a compile-time thing.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Feb 19 01:24:56 UTC 2012,,,,,,,,,,"0|i2ctjr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Aug/11 23:07;paulk;The reason for its existence is for legacy behavior of {{@Immutable}} which calls through to {{@ToString}}. With {{@Immutable}} classes created using the named params constructor automatically print out with printNames true whereas ones created with a tuple constructor don't. Current thinking is that we may deprecate this behavior as we have had no feedback indicating that it is absolutely essential for some particular use case and it does add complexity.

The field is marked ""synthetic"" and that is enough for some tools to ignore it - for XStream you would have to add an XStream annotation to ignore it or write your own convertor. CGLibConverter for example ignores synthetic fields I believe. This would be the workaround.

You mention ""causes havoc"". What exactly do you observe?
;;;","20/Aug/11 04:07;johann;How can I add an XStream annotation to a field generated during compiling? Or do you mean something like {{private transient boolean $print$names = true}} would work?

I agree, maybe havoc was the wrong word. ;);;;","23/Aug/11 17:21;paulk;I was hoping {{XStreamOmitField}} could be placed on a class with a list of fields to omit but it isn't designed that way at all after checking. ;-);;;","13/Sep/11 03:11;roshandawrani;Got interested in how to solve this problem, and documented a technique here as it could be useful to others as well: http://roshandawrani.wordpress.com/2011/09/13/better-serialization-of-groovy-objects-using-xstream/;;;","13/Sep/11 04:49;blackdrag;What should we do about this issue then?;;;","13/Sep/11 04:55;roshandawrani;I thought Paul's comment clarified that all Groovy can do is mark its internal fields ""synthetic"" and then let the libraries utilize that meta-data to ignore them (like CGLibConverter does). And now we have provided a XStream specific workaround as well.

Let's still wait for a little while for Johann to share his views about it.;;;","13/Sep/11 19:22;paulk;Yes, with Roshan's published workaround I would recommend closing the issue if Johann agrees. We might as a separate activity want to deprecate the use of '$print$names' but that is a separate issue.;;;","14/Sep/11 13:50;johann;The issue I think about here is that of annotations creating non-static fields. People can say ""Groovy is slow"" and that's one (largely irrelevant) thing but if they say ""Groovy is slow and its memory usage is completely unpredictable and therefore, it cannot scale,"" that's unacceptable.

In other words, if I didn't know it, I wouldn't expect Groovy to add fields to my classes. The fields it adds today are thankfully static so it's not really an issue but per-instance fields might be.;;;","07/Dec/11 04:04;paulk;I'm going to go ahead and close this issue. The internal $print$names field has been removed from Groovy 2.0 in any case. In general, annotations don't add fields (static or otherwise) without careful consideration. It would only be because such a field was required for the functionality of the annotation.;;;","18/Feb/12 21:43;paulk;I just looked at the code changes I made for this for 2.0-beta-2 and they didn't seem to be committed - I presume I stuffed up the git command at this end. Re-applying shortly and I'll bump the fix version appropriately.;;;","19/Feb/12 01:24;paulk;fixed glitch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SecureASTCustomizer blacklist is ignored inside method body,GROOVY-4978,12815796,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,cmj,cmj,16/Aug/11 10:27,07/Sep/11 14:13,14/Jul/23 06:00,31/Aug/11 03:32,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,Compiler,,,,1,,,,,,"I'm trying to compile Groovy Scripts while rejecting calls to System.exit() by using using a SecureASTCustomizer like this:

{code}
final SecureASTCustomizer customizer = new SecureASTCustomizer();
customizer.setImportsBlacklist(asList(""java.lang.System"",
		""groovy.lang.GroovyShell"", ""groovy.lang.GroovyClassLoader""));
customizer.setIndirectImportCheckEnabled(true);

CompilerConfiguration configuration = new CompilerConfiguration();
configuration.addCompilationCustomizers(customizer);

ClassLoader parent = ScriptCompiler.class.getClassLoader();
GroovyClassLoader loader = new GroovyClassLoader(parent, configuration);
{code}

The following Script is blocked correctly and I get an exception during parseClass()
{code}
System.exit(1);
{code}

In the following script, System.exit() is called successfully:
{code}
def x() { System.exit(1) }
x()
{code}
",,cmj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Aug/11 10:29;cmj;SecureScriptTest.java;https://issues.apache.org/jira/secure/attachment/12722962/SecureScriptTest.java",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 31 03:32:14 UTC 2011,,,,,,,,,,"0|i2cc4f:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"16/Aug/11 10:29;cmj;Failing JUnit4 Test Case;;;","31/Aug/11 03:32;melix;I fixed this issue, but there are still problems regarding constructors because the AST transformation can't determine whether the constructor was handwritten or generated by the groovy compiler.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE in AntlrParserPlugin on incorrect array creation expression,GROOVY-4976,12815659,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,edebrev,edebrev,15/Aug/11 07:12,21/Feb/20 03:48,14/Jul/23 06:00,01/Feb/20 21:50,1.8.1,1.8.9,2.0.8,3.0.0-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,3.0.0,,,parser-antlr2,parser-antlr4,,,0,,,,,,"Groovy parser fails on incorrect array creation expression:

{noformat}
$ java -jar groovy-all-1.8.1.jar -d -e ""def foo = new double[][5]""
Caught: BUG! exception in phase 'conversion' in source unit 'script_from_command_line' null
BUG! exception in phase 'conversion' in source unit 'script_from_command_line' null
        at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:843)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:544)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:520)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:497)
        at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:287)
        at groovy.lang.GroovyShell.parseClass(GroovyShell.java:731)
        at groovy.lang.GroovyShell.run(GroovyShell.java:516)
        at groovy.lang.GroovyShell.run(GroovyShell.java:172)
        at groovy.ui.GroovyMain.processOnce(GroovyMain.java:526)
        at groovy.ui.GroovyMain.run(GroovyMain.java:332)
        at groovy.ui.GroovyMain.process(GroovyMain.java:318)
        at groovy.ui.GroovyMain.processArgs(GroovyMain.java:115)
        at groovy.ui.GroovyMain.main(GroovyMain.java:96)
Caused by: java.lang.NullPointerException
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:1649)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1633)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1629)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.arraySizeExpression(AntlrParserPlugin.java:2509)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.arraySizeExpression(AntlrParserPlugin.java:2507)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.constructorCallExpression(AntlrParserPlugin.java:2460)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:1670)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1633)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expression(AntlrParserPlugin.java:1629)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.declarationExpression(AntlrParserPlugin.java:1437)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.variableDef(AntlrParserPlugin.java:1453)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.statement(AntlrParserPlugin.java:1203)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.convertGroovy(AntlrParserPlugin.java:304)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.buildAST(AntlrParserPlugin.java:241)
        at org.codehaus.groovy.control.SourceUnit.convert(SourceUnit.java:272)
        at org.codehaus.groovy.control.CompilationUnit$10.call(CompilationUnit.java:618)
        at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:839)
        ... 13 more

$ java -jar groovy-all-1.8.1.jar -v
Groovy Version: 1.8.1 JVM: 1.6.0_25
{noformat}
",,daniel_sun,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Feb 01 21:50:38 UTC 2020,,,,,,,,,,"0|i2cpfb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Aug/11 05:29;paulk;Attempting to compile the following in the GroovyConsole is also enough to trigger the problem:
{code}
new int[][]
{code};;;","12/Sep/11 20:59;roshandawrani;1) works
{code}
new int[0][]
{code}


2) fails with NPE
{code}
new int[][0]
{code}
;;;","27/Jan/20 00:40;paulk;Since 2.0.8 and perhaps earlier, there is now no longer the {{Caught: BUG! exception}} but rather a compiler error as expected.
However the error message is much less intuitive that Java which says: {{error: array dimension missing}}.
Currently Antlr2 produces: {{No expression for the array constructor call}}
Antlr4 produces: {{Unexpected input: '['}} or {{Unexpected input: '<EOF>'}}.
So, this issue remains open just to look at providing a more intuitive error message.;;;","01/Feb/20 21:50;daniel_sun;Fixed by [https://github.com/apache/groovy/commit/a5629358ecb847fff01f5afc4f266938c8b5ef03];;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyScripeEngine fails to properly reload when dependent class is updated,GROOVY-4975,12815810,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,dsmith,dsmith,14/Aug/11 11:57,04/Oct/12 17:02,14/Jul/23 06:00,01/Oct/12 02:33,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.5,,GroovyScriptEngine,,,,4,reload,,,,,"Let's say you have 2 scripts : script1 and script2 and they both use class BeanX and they are all loaded via the same GroovyScriptEngine instance.  If I modify BeanX, the script that is the first to get loaded and references BeanX will reflect changes made to BeanX, while the other or second script to reference BeanX will fail to reflect changes made to BeanX.

I'm assuming this is not the proper behavior, although I don't see any test to test for this scenario.  If one is using groovy via Groovlets or something like Gaelyk where the assumption is that I can write 
scripts and hot have to constantly restart to have my changes reflected then I would assume the GSE should reload classes and dependent classes regardless of the order in which they are referenced.

Test attached.","Win 7 64bit, OSX Lion",alessiostalla,blackdrag,dsmith,fransvanbuul,paulk,sdmurphy,sslavic,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"05/Dec/11 10:02;fransvanbuul;GroovyScriptEngineReloadingSlowTest.groovy;https://issues.apache.org/jira/secure/attachment/12723013/GroovyScriptEngineReloadingSlowTest.groovy","14/Aug/11 11:57;dsmith;ReloadTest.groovy;https://issues.apache.org/jira/secure/attachment/12722872/ReloadTest.groovy","14/Aug/11 11:57;dsmith;ReloadTestJava.java;https://issues.apache.org/jira/secure/attachment/12722963/ReloadTestJava.java","04/Dec/11 11:42;fransvanbuul;patch4975_main.txt;https://issues.apache.org/jira/secure/attachment/12722905/patch4975_main.txt","04/Dec/11 11:42;fransvanbuul;patch4975_test.txt;https://issues.apache.org/jira/secure/attachment/12722531/patch4975_test.txt","10/Dec/11 06:53;fransvanbuul;patch4975_v2.txt;https://issues.apache.org/jira/secure/attachment/12722906/patch4975_v2.txt",,,6.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 01 02:33:24 UTC 2012,,,,,,,,,,"0|i2c9k7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"04/Dec/11 11:42;fransvanbuul;I've ran into a similar issue. For me, the problem presented itself as a class cast exception after a runtime update of some scripts.

The attached patches are:
- a patch to the GroovyScriptEngineReloadTest, for testing for this (non-deterministic) phenomenon. Both the case reported by David and 'my' problem are included as test cases. 
- a patch to the GroovyScriptEngine that solves this problem. The solution works, but is pretty crude. 

Both patches are relative to the 1.8.4 sources.

I hope this can be included in the next release. We're using the script engine inside a process engine we've written to replace BPEL in our organisation, using Groovy as a process definition language. Works great, but because of this issue we have to restart the entire engine every time we change a process.

;;;","04/Dec/11 16:16;blackdrag;in the CompilerConfiguration is a reloading interval as option you can influence... could that be used here?;;;","05/Dec/11 01:01;fransvanbuul;Hi Jochen,

I've looked into that, but that doesn't solve the problem. The unit tests I provided set the config.minimumRecompilationInterval value to 0 ms, and sleep for 20ms between modifying the scripts and using them through the scripting engine. This should be non-problematic, but it is.

Regards,
Frans


;;;","05/Dec/11 06:41;blackdrag;only the thing is, your patch more or less sets the time code for every entry to about 1s in the past. Unless minimumRecompilationInterval is set higher it will not have any effect anymore. minimumRecompilationInterval has a certain impact on performance of the engine, that is why it was introduced. Also there is the problem with getting an exact time on windows. currentTimeMillis has a resolution of about 1ms on Linux systems, but on for example XP it 15ms or more. I remember on older windows versions it was even higher. That's also why we set the minimumRecompilationInterval to 100 by default, to avoid such strange timing problems. If you wait only 20ms (or even less), then it can happen that current time will still be the same as before, thus no recompilation will happen. 

Looking at isSourceNewer{code:Java} 
    protected boolean isSourceNewer(ScriptCacheEntry entry) throws ResourceException {
        if (entry == null) return true;
        long now = System.currentTimeMillis();

        for (String scriptName : entry.dependencies) {
            ScriptCacheEntry depEntry = scriptCache.get(scriptName);
            long nextPossibleRecompilationTime = depEntry.lastModified + config.getMinimumRecompilationInterval();
            if (nextPossibleRecompilationTime > now) continue;

            URLConnection conn = rc.getResourceConnection(scriptName);
            // getLastModified() truncates up to 999 ms from the true modification time, let's fix that
            long lastMod = ((conn.getLastModified() / 1000) + 1) * 1000 - 1;
            // getResourceConnection() opening the inputstream, let's ensure all streams are closed
            forceClose(conn);

            if (depEntry.lastModified < lastMod) {
                ScriptCacheEntry newEntry = new ScriptCacheEntry(depEntry.scriptClass, lastMod, depEntry.dependencies);
                scriptCache.put(scriptName, newEntry);
                return true;
            }
        }

        return false;
    }
{code} 
especially the 
{code:Java}
 URLConnection conn = rc.getResourceConnection(scriptName);
 // getLastModified() truncates up to 999 ms from the true modification time, let's fix that long lastMod = ((conn.getLastModified() / 1000) + 1) * 1000 - 1; 
{code} 
makes me wonder if the problem is not here to be found. With reloading intervals below 1s this code may set times in the future, since we use lastMod to create a new ScriptCacheEntry. The code was added as a reaction to GROOVY-4492, the lastMod as time for the new entry is used due to GROOVY-2811 and GROOVY-4286, but I cannot see why. But I feel the fix should be in this part instead actually

;;;","05/Dec/11 08:30;dsmith;There is definitely a problem.  The problem is with ScriptCacheEntry.dependencies, not the timing.
The dependency graph is not correct for a second script that loads dependencies that have already been loaded.

It's demonstrated in both test.  isSourceNewer is failing because ScriptCacheEntry.dependencies does not contain all of the correct entries for the second script.

It's easily evident if the tests are run in a debug session w/breakpoints set in isSourceNewer inspecting entry.dependencies.



        ;;;","05/Dec/11 10:02;fransvanbuul;David is correct. My original solution only hides the problem. I've run a new test similar to my original ones (attached) with a minimum recompilation interval of 2000 ms and sleeps of 5000 ms between modifying the source and using it. This is slow enough to eliminate all timing issues. In this case, the problem shows up deterministically, 100% of the time.

Any ideas on how this should be properly solved? I do have some time available to work on this, but some pointers would be useful.


;;;","05/Dec/11 11:07;fransvanbuul;I've inserted some logging into the scripting engine and my test case, results are shown below. The entire dependency between Extractor and MyBean is not managed, and looking at the code, I see nothing that should manage it. Disabling the timestamp check in 'isSourceNewer' solves the problem at the expense of disabling the entire mechanism.

    [junit] Writing source code at Mon Dec 05 17:59:42 CET 2011
    [junit]
    [junit]
    [junit] Sleeping for 10 seconds
    [junit]
    [junit]
    [junit] Using source code
    [junit] Instantiating bean
    [junit] Putting into scriptcache (in parseClass): /MyBean.groovy
    [junit]     lastmod:  Mon Dec 05 17:59:52 CET 2011
    [junit]     dependencies:  [/MyBean.groovy]
    [junit] Instantiating extractor
    [junit] Putting into scriptcache (in parseClass): /Extractor.groovy
    [junit]     lastmod:  Mon Dec 05 17:59:52 CET 2011
    [junit]     dependencies:  [/Extractor.groovy]
    [junit]
    [junit]
    [junit] Sleeping for 10 seconds
    [junit]
    [junit]
    [junit] Modifying MyBean source code at Mon Dec 05 18:00:02 CET 2011
    [junit]
    [junit]
    [junit] Sleeping for 10 seconds
    [junit]
    [junit]
    [junit] Using modified source code
    [junit] Instantiating bean
    [junit] Calling isSourceNewer for entry MyBean
    [junit] Checking dependency /MyBean.groovy
    [junit] Putting into scriptcache (in isSourceNewer): /MyBean.groovy
    [junit]     lastmod:  Mon Dec 05 18:00:02 CET 2011
    [junit]     dependencies:  [/MyBean.groovy]
    [junit] Putting into scriptcache (in parseClass): /MyBean.groovy
    [junit]     lastmod:  Mon Dec 05 18:00:12 CET 2011
    [junit]     dependencies:  [/MyBean.groovy]
    [junit] Instantiating extractor
    [junit] Calling isSourceNewer for entry Extractor
    [junit] Checking dependency /Extractor.groovy
    [junit] Not putting into scriptcache (in isSourceNewer): /Extractor.groovy
    [junit]     lastmod: Mon Dec 05 17:59:42 CET 2011
    [junit]     depEntry.lastModified: Mon Dec 05 17:59:52 CET 2011;;;","05/Dec/11 12:49;blackdrag;Frans, having a test that fails deterministically each time is worth a lot!  Since we now know that the dependencies are set wrong, we can concentrate on that part better and stop thinking about timing problems (the code in isSourceNewer still looks wrong to me, but we can maybe fix that one later on)

That means there might be a bug in org.codehaus.groovy.tools.gse.DependencyTracker then - or its usage... so I guess a first step would be to check if the tracker gets the dependency between MyBean and Extractor right and if they both appear then correctly in the transitive hull.

Should that work, then the next step would be to check the way the dependencies are stored, and if that is right. This part is also not so easy code and may have the bug we search for.
;;;","06/Dec/11 10:30;fransvanbuul;Jochen, I put logging into the DependencyTracker and that seems to be working correctly. I also checked how they are stored in the scriptcache, and how the transitive hull is calculated. Seems to be working correctly as well. I think the problem is that this information is not being used.

I changed GroovyScriptEngine#isSourceNewer in such a way that when an entry is updated, existing entries that depend on the updated entry are removed from the cache. This forces recompilation when they are accessed. The relevant fragment is shown below. With this modification, the unit test passes. Is this an acceptable solution?

{code} 
if (depEntry.lastModified < lastMod) {
     ScriptCacheEntry newEntry = new ScriptCacheEntry(depEntry.scriptClass, lastMod, depEntry.dependencies);
     scriptCache.put(scriptName, newEntry);
     /* Removing entries from cache that depended on the entry we just updated; these should be recompiled. */ 
     for(Map.Entry<String, ScriptCacheEntry> currentEntry : scriptCache.entrySet()) {
          if(!currentEntry.getKey().equals(scriptName) &&
              currentEntry.getValue().dependencies.contains(scriptName)) {
              scriptCache.remove(currentEntry.getKey());
          }
     }
     return true;
}
{code} 
;;;","07/Dec/11 06:09;fransvanbuul;Some more results: the change I proposed in my previous comment certainly fixes one problem, but not all. In the more complex case, the registration/calculation of the dependencies seems broken as well. I'll look into that next.;;;","10/Dec/11 06:53;fransvanbuul;I've created a new patch to fix this issue. It contains a new unit test, a small change to DependencyTracker, and several changes to GroovyScriptEngine.

To summarise, I found and (I think) corrected the following issues:

1. After a class is updated because a newer version of the script is found, all classes that directly or indirectly depend on it are no longer valid. This means they must be removed from the scriptcache (as per my previous comment), but also from the classloader cache (new in this patch).

2. If we have dependencies (A->C) and (B->C), and we first compile A (compilation unit (A,C)), compiling B later on would fail to detect the dependency on C. The reason was that in this case, class C is not identified as a primary node in the semantic analysis and is thus ignored in the dependency tracker. I've modified the tracker and the scripting engine to ignore the 'primary node' status in case we're dealing with a previously seen scripted class.
;;;","04/Jan/12 21:37;dsmith;Finally got around to trying this patch.
It works beautifully thus far. Thanks Frans.

Hopefully the groovy team will include this is a release soon.;;;","05/Jan/12 00:10;fransvanbuul;Hi David,

Thanks for trying it out. I've discussed this patch on the Groovy dev list. Jochen Theodorou had some very valid criticisms on this patch, it runs fine in the unit tests but it's not completely reliable in all circumstances. 

Once I find some time (hopefully next week) I'll try to create a new patch that addresses these problems.

Regards,
Frans
;;;","25/Jan/12 12:25;sdmurphy;Any update on this? We believe this bug may be causing a nasty side effect of recompiling scripts on each use resulting 
in frequent PermGen errors for server side applications.

http://groups.google.com/group/gaelyk/browse_thread/thread/58ff42f7d679b23b;;;","01/Feb/12 07:50;guillaume;Frans, did you have time to integrate Jochen's suggestions in a new patch?;;;","06/Feb/12 03:39;blackdrag;Frans seems not to have time right now;;;","10/Apr/12 01:31;sslavic;Shouldn't [{{DependencyTracker#visitCastExpression(org.codehaus.groovy.ast.expr.CastExpression)}}|http://groovy.codehaus.org/gapi/org/codehaus/groovy/tools/gse/DependencyTracker.html#visitCastExpression%28org.codehaus.groovy.ast.expr.CastExpression%29] be called for that cast to {{MyBean}} in {{Extractor.groovy}} (see [^GroovyScriptEngineReloadingSlowTest.groovy]), so that {{MyBean.groovy}}, along with {{Extractor.groovy}}, gets registered as dependency of {{Extractor}}?

When I debuged, {{visitCastExpression}} didn't get called, and {{Extractor}}, like in [Frans' log output|http://jira.codehaus.org/browse/GROOVY-4975?focusedCommentId=284932&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-284932], had only {{Extractor.groovy}} as dependency.;;;","17/Aug/12 09:02;blackdrag;I am looking now into this again freshly... RealodTest#testReloadWith2ScriptsDependentOnSameBean looks good and produces the problem, so I will use that... In a first call we request script1, that will create a dependency for script1 on itself and Bean, as it should. In the next run we request script2, that also depends on Bean, but as found out earlier in here, it is not added as dependency, because it is no primary node.

Frans patch tried to change that here and ignore the primary node state. Doing so will correctly ensure the dependency, but it will not recompile Bean the first time. That means if we would make a test in which first script2 is loaded and we then change Bean to then load script1, we would still not get a recompiled Bean. Testing this with a modified version of ReloadTest I can confirm this.

Solving this problem would most probably also solve the other problems;;;","17/Aug/12 09:45;blackdrag;After further thinking I tend to say that ResolveVisitor is here not doing the right thing for us. ResolveVisitor resolves Bean to a precompiled class, as it already exists. It is done with that and now happily assumes all is fine. But in our case we want Bean maybe to be enlisted in the compilation queue, with our own check for if the source is newer or not. ResolveVisitor is clearly lacking some abstraction in that section, making a nice solution difficult.;;;","22/Aug/12 08:34;blackdrag;The issue should be fixed now. It required me to hook into ResolveVisitor in a way, that was not planned before, but well, there is a clean way now and the reload test from before works now. It would be nice to here of you people here if this new versions resolves the issues you had;;;","23/Aug/12 21:14;dsmith;I'm testing w/1.8.8-SNAPSHOT and I'm getting the same result.  The test is also still failing for me.  ;;;","24/Aug/12 05:33;blackdrag;if you say you test with 1.8.8 SNAPSHOT, you mean you compiled it from our repository? And you say the here attached ReloadTest.groovy does not work for you?;;;","24/Aug/12 08:57;blackdrag;I just tested to be sure. I got the SNAPSHOT from http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all/1.8.8-SNAPSHOT/ and executed ReloadTest.groovy. Actually ReloadTest.groovy has a bug, the line:{code:Java}path = new File(dir + ""ReloadTest"");{code}should be (on my system at least){code:Java}path = new File(dir,""ReloadTest"");{code}. After changing the two times this appaears the test executes and works for me;;;","25/Aug/12 23:24;dsmith;Tried again, the tests did pass for me.;;;","27/Aug/12 10:13;blackdrag;So you tried ReloadTest and the test just failed by saying the bean had the wrong value? Or was there any exception? Any idea what could be wrong?;;;","27/Aug/12 10:21;dsmith;Everything is good.  All tests in ReloadTest passed for me.  No exceptions.  
;;;","27/Aug/12 10:31;blackdrag;Ah sorry David... don't know what I was smoking ;) You actually confirmed it being fixed. Thanks for the help;;;","14/Sep/12 07:47;alessiostalla;Groovy 1.8.8 does not solve the problem for me. The tests (both the Groovy one and Java one) still fail randomly, both when launched from IntelliJ IDEA and when run manually from the command line. The Java test fails much more often, though - you may have to run the Groovy test several times in a row before getting a failure.

I observed a couple of facts, that I report here in hope that they will help someone who knows the GSE internals better than me to find a solution.

1. When the test fails, the 2nd dependent script has its dependencies incorrectly computed: it only depends on itself, not on the shared Bean.

2. I modified the generated scripts to print their classloader, as well as the one that loaded the Bean class. When the test passes, each script gets its own classloader, which is *always* also the classloader of the Bean class. In other words, each script class gets its own version of the Bean class. When the test fails, the 2nd script has a different classloader than the first, but it sees the Bean class as loaded from the 1st classloader (which I suppose should be the expected behaviour). Somehow that causes the script not be reloaded. To make it clearer, this is a printout of two sample runs:

test PASS

class script2
script classloader: groovy.lang.GroovyClassLoader$InnerLoader@186fa9fc
Instantiating bean class: groovy.lang.GroovyClassLoader$InnerLoader@186fa9fc
bean classloader: groovy.lang.GroovyClassLoader$InnerLoader@186fa9fc
class script1
script classloader: groovy.lang.GroovyClassLoader$InnerLoader@2918958e
Instantiating bean class: groovy.lang.GroovyClassLoader$InnerLoader@2918958e
bean classloader: groovy.lang.GroovyClassLoader$InnerLoader@2918958e
class script1
script classloader: groovy.lang.GroovyClassLoader$InnerLoader@87e9ce2
Instantiating bean class: groovy.lang.GroovyClassLoader$InnerLoader@87e9ce2
bean classloader: groovy.lang.GroovyClassLoader$InnerLoader@87e9ce2
class script2
script classloader: groovy.lang.GroovyClassLoader$InnerLoader@5567d7fb
Instantiating bean class: groovy.lang.GroovyClassLoader$InnerLoader@5567d7fb
bean classloader: groovy.lang.GroovyClassLoader$InnerLoader@5567d7fb


test FAIL

class script2
script classloader: groovy.lang.GroovyClassLoader$InnerLoader@36b60b93
Instantiating bean class: groovy.lang.GroovyClassLoader$InnerLoader@36b60b93
bean classloader: groovy.lang.GroovyClassLoader$InnerLoader@36b60b93
class script1
script classloader: groovy.lang.GroovyClassLoader$InnerLoader@741827d1
bean classloader: groovy.lang.GroovyClassLoader$InnerLoader@36b60b93
class script1
script classloader: groovy.lang.GroovyClassLoader$InnerLoader@741827d1
bean classloader: groovy.lang.GroovyClassLoader$InnerLoader@36b60b93
//FAIL

Note: this is from the test method testReloadWith2ScriptsDependentOnSameBeanOrderSwitched(), but similar stuff happen with testReloadWith2ScriptsDependentOnSameBean(). ""Instantiating bean class"" is printed from a static initializer in Bean. ;;;","14/Sep/12 08:02;blackdrag;Alessio, what OS are you using? Because the only part that I can imagine still failing here is that an update of the file is not seen, because of timing issues of the OS. That would also explain why it fails only sometimes. Before it should have failed always.;;;","14/Sep/12 08:53;alessiostalla;I'm using OSX, but I also tested it on Linux, with the same outcome. I don't think it's related to timing and the OS, because I can arbitrarily increase the wait time between writing the bean and reloading the dependent scripts, and I still get failures. The test above was using a 500ms wait, but I went up to 4500ms to no avail. Also, the two different classloader behaviours are already apparent before any reload happens: the shared Bean is modified just before the line ""class script1"" is printed for the second time in my example.;;;","17/Sep/12 10:01;blackdrag;I made the following... I downloaded Groovy 2.0.2 and let it execute raw.github.com/groovy/groovy-core/master/src/test/groovy/util/GroovyScriptEngineReloadingTest.groovy 10 times in a row. And indeed the test is failing about once in ten times.... maybe every 6th time.

But I don't understand why. If it is no timing issue, then I would have put my finger on a concurrency issue, but with 4500ms wait time, that is unlikely as well. The symptoms are clear of course. I mean the classloader being the same and all. The question is more what the cause is. 

Why does it work one time and another time it does not?;;;","17/Sep/12 10:46;alessiostalla;One thing that I thought that could cause nondeterminism is the garbage collector. I saw that a few caches are held in thread-local weak references; maybe if they're garbage collected too early some important information could be lost. I passed the -verbose:gc flag to the JVM, but it only prints something at the beginning; OTOH, I don't know whether it only prints full GC or it is more detailed.

As for concurrency, I'm convinced that there's only one thread; I put print statements in a few places to be sure.;;;","19/Sep/12 01:08;bwalding;Closing now that spam removed.;;;","19/Sep/12 10:33;alessiostalla;I took my analysis further and I can now say that timing is, indeed, part of the issue - but only because it's exposing a deeper problem.

There are two timestamps being compared to decide whether to recompile a file: one is the file modification time, rounded up to the next second; the other is the script compilation time, not rounded. The first is computed at line 595 in GroovyScriptEngine - {{long lastMod = ((conn.getLastModified() / 1000) + 1) * 1000 - 1;}}. The second is at line 240, {{long now = System.currentTimeMillis();}}. When a file is compiled (the shared Bean in our case), the rounded up time may end up being earlier or later than the compilation time, in a nondetermistic way, because of the rounding. This alone should not be a big problem - at worst, it would sometimes cause unnecessary recompilations. But...

...the logic that records dependencies between files is flawed; a dependency between file A and file B is only recorded when B is compiled in the same compilation unit as A. If B is not recompiled, the dependency is not recorded. This is caused by the fact that the DependencyTracker is invoked by a PrimaryClassNodeOperation (GSE, lines 165 - 175). I don't know the specifications of the various compiler phases, but certainly I can see that, by manually altering the source file last modification date, I can cause the dependency to be deterministically recorded or not, i.e. {{dt.visitClass(classNode);}} (line 173) being executed or not, depending on whether the modification date is forcibly set in the future or in the past. You can obtain the same effect also by causing a big enough sleep (say, 2000ms) between writing Bean.groovy and writing the scripts.

So, those unnecessary recompilations caused by the timing problem are actually necessary for the dependency to be recorded. That's why in our app it consistently fails - the shared classes are compiled much later than their last modification.

Does it make sense to you?;;;","19/Sep/12 13:37;blackdrag;I am currently preparing a fix for the first issue you mention. It seems this new version is excluding the timing issue finally. I am going to push that soon and it would be good of you if you could test it as well. I will comment here as soon as it is available, since it is getting late here.

The second part of your comment is something that should not be true anymore. Since the latest version there is a new element called ClassNodeResolver involved. This is used to resolve class names and eventually enqueue new sources. For every script cache entry of GSE that has been requested, a new source unit will be added, if the source is newer. If not, then no recompilation will happen. It is true that the dependencies are not fully right then, yes... but actually I think the dependency tracking is now surplus, since the ClassNodeResolver will do that job implicitly and much better. Actually I am wondering if I should not remove the tracker even. ;;;","20/Sep/12 01:56;blackdrag;I filled GROOVY-5713 as follow-up issue;;;","20/Sep/12 04:26;alessiostalla;Thanks for addressing the timing issue!

As for the other point, I hadn't realized that the ClassNodeResolver was meant to replace the PrimaryClassNodeOperation. Unfortunately, I don't think that you can do without dependency tracking. The ClassNodeResolver is only invoked when a file is compiled; what if a file is not modified (compared to the cached version), but one of its dependencies was modified? Without dependency tracking, the dependency won't be recompiled. In other words, the ClassNodeResolver works top-down, while the decision to recompile or not should be a bottom-up process.;;;","20/Sep/12 08:23;blackdrag;You are right... as often, almost right after writing that we may not need the tracker it dawned on me, that I said something stupid ;) Of course some of the logic would have to be moved to the ClassNodeResolver and there we don't know the ""cause"" of the request, this it is impossible to make the connection, thus we need the tracker in the end still.

I just did the commit for GROOVY_1_8_X with my new version. Is it possible for you to check if that helps you?;;;","20/Sep/12 09:11;alessiostalla;Nope, I ran the test again with 1.8.9-SNAPSHOT from Git and it still fails nondeterministically.;;;","20/Sep/12 10:19;blackdrag;full determinism is impossible to achieve. UrlConnection.getLastModified may not know milliseconds, that is why there is this truncation. truncating the modification time means that if your  change has been done too fast, it cannot be picked up, since it has the same time as before. So you need 1000 ms minimum delay to ensure the time in last modified is updated properly. But it is actually more, since the OS has a timer with differing resolution. A delay of 1100ms should catch most cases, but that does not guarantee the change will be picked up right away. actually the next possible point of a recompilation is time of last compilation plus 1100 plus minimum recompilation interval.  ;;;","21/Sep/12 06:57;alessiostalla;Ok, let's step back a bit: I don't have a problem with nondeterminism per se - the problem is that GSE doesn't properly reload dependencies, *ever*, *unless* a dependency is found to be modified later than it was compiled (due to nondeterminism). That is, nondeterminism is what makes the test *pass* sometimes, not fail. If you eliminate nondeterminism (for example, by ensuring that there is a long enough sleep between writing Bean.groovy and loading the scripts for the first time), the test *always* fails.;;;","25/Sep/12 08:18;blackdrag;Alessio, after totally rewriting the tests to not to use the file system anymore, but something custom I found that you are right in more than one way. It was indeed the case that a precompiled dependency is not picked up. This is now basically fixed. I still have a problem to solve though...

In he current setup if I have script1 depending on Bean and script2 depending on it as well, if I recompiled script1 and Bean, because Bean changed, then script2 will not be recompiled, because the entries are all up to date;;;","01/Oct/12 02:33;blackdrag;the issue was marked as fixed for 2.0.2 and 1.8.8, but it seems due to the tests not always showing the real problem it was only partially fixed. This new version in 2.0.5 and 1.8.9 should finally fix the issue of not picking up dependencies. It is still no 100% satisfying solution to me, but at least it works;;;",,
Bounded generics do not work with inheritance,GROOVY-4974,12815825,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ddimitrov,ddimitrov,13/Aug/11 05:46,14/Oct/11 00:28,14/Jul/23 06:00,12/Sep/11 20:51,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,1.9-beta-4,,Compiler,,,,0,,,,,,"The following code works in Java, but fails to compile in Groovy - looks like unintentional: 

{code}
public class TestGenerics { 
    static interface Z {} 
    static class X implements Z {} 
    static class Y extends X {} 

    static class A <T extends Z> { void a(T t) { System.out.println(t); } } 
    static class B extends A<Y> {} 
    static class C extends A<X> {} 

    public static void main(String[] args) { 
        new C().a(new Y()); 
    } 
} 
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 12 20:51:42 UTC 2011,,,,,,,,,,"0|i2bnjz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"12/Sep/11 20:51;paulk;Should be fixed but if you get a chance to confirm by trying a snapshot that would be great. Thanks for reporting the problem.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inconsistent numeric range types,GROOVY-4973,12815830,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,ddimitrov,ddimitrov,13/Aug/11 05:44,24/Dec/11 03:08,14/Jul/23 06:00,03/Dec/11 11:04,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,class generator,,,,0,,,,,,"I would expect that range literal follow the same type promotion rules as arithmetic operations, yet: 

{code}
assert (1+10).class == Integer   
assert (1L+10).class == Long 
assert (1+10L).class == Long 

assert (1..10).every { it.class == Integer  } 
assert (1L..10).every { it.class == Long } 
assert (1..10L).every { it.class == Integer } // <= weird 
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Dec 03 05:36:40 UTC 2011,,,,,,,,,,"0|i2ck0n:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"03/Dec/11 02:50;roshandawrani;ObjectRange#constructorHelper(from, to) has the following piece commented out that should take care of this JIRA.

Is there any concern in aligning from / to types like this?

{code}
        // TODO: Should we align to like types?
//        if (from instanceof Integer && to instanceof Long) {
//            from = Long.valueOf(((Integer) from).longValue());
//        } else if (to instanceof Integer && from instanceof Long) {
//            to = Long.valueOf(((Integer) to).longValue());
//        }
{code};;;","03/Dec/11 05:36;blackdrag;looks like the comment was added as a reaction to GROOVY-2976, Paul 2008-09-06

I think it is ok to do that change;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.codehaus.org gives a 404,GROOVY-4972,12815798,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,mlzarathustra,mlzarathustra,12/Aug/11 19:12,13/Aug/11 02:37,14/Jul/23 06:00,13/Aug/11 02:37,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,"Here's the message:
404 Unknown page Home
/groovy.codehaus.org/Home was not found on this server.

Resin-3.0.14 (built Tue, 05 Jul 2005 11:03:36 PDT) ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 13 02:37:46 UTC 2011,,,,,,,,,,"0|i2bo3j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Aug/11 02:37;paulk;http://groovy.codehaus.org/Home works fine for me. The infrastructure at codehaus occasionally goes down and is out of our control. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Method call expression parsed differently in 1.8 compared to 1.7,GROOVY-4970,12815837,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,pniederw,pniederw,10/Aug/11 14:09,18/Oct/11 07:28,14/Jul/23 06:00,18/Oct/11 07:28,1.8.0,1.8.1,1.9-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.4,2.0-beta-1,,parser-antlr2,,,,0,,,,,,"Some method call expressions are parsed differently in 1.8 compared to 1.7. This causes one of Gradle's AST transforms to fail. According to Jochen, this looks like a bug in the 1.8 ANTLR grammar.

{noformat}
task copy(type: Copy) { x = 10 }
g1.7: this.task(this.copy(...))
g1.8: this.task(this.copy(...))

task copy(type: Copy) { println 10 }
g1.7: this.task(this.copy(...))
g1.8: task.copy(...)
{noformat}

The first expression is parsed the same in 1.7 and 1.8, but the second expression is parsed differently.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 18 07:28:17 UTC 2011,,,,,,,,,,"0|i2cu1r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Oct/11 06:30;guillaume;Another similar problem reported to me by Roshan, in Grails' url mappings:
{code}
name xxx: ""/c/$authCode""(controller: 'foo', action: 'bar') {
    constraints {
        authCode blank: false
    }
}
{code};;;","11/Oct/11 06:33;guillaume;And as a workaround for now, putting back the parentheses make things work:
{code}
name(xxx: ""/c/$authCode""(controller: 'foo', action: 'bar')) {
    constraints {
        authCode blank: false 
    }
}
{code};;;","18/Oct/11 07:28;blackdrag;the reason for the bug was not because of a wrong or grammar rule, it was because of some semantic action executed only in certain cases, that was causing this. Took a while, but seems to be fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BUG! exception when using spread operator,GROOVY-4968,12816912,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,pniederw,pniederw,09/Aug/11 08:23,29/Aug/11 14:07,14/Jul/23 06:00,29/Aug/11 14:07,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,,,,,0,,,,,,"Not sure why the author used a spread operator here, but this works fine with Groovy 1.7, and blows up with 1.8.

{code}
class SpreadBug {
  def foo(String... args) {
    bar(*args)
  }
  
  def bar(String... args) {}
}
{code}

Output when run in Groovy Console:

{noformat}
BUG! exception in phase 'class generation' in source unit 'ConsoleScript0' SpreadExpression should not be visited here
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitSpreadExpression(AsmClassGenerator.java:575)
	at org.codehaus.groovy.ast.expr.SpreadExpression.visit(SpreadExpression.java:39)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeDirectMethodCall(InvocationWriter.java:125)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:167)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:87)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:71)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:288)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:662)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:75)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:577)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeReturn(OptimizingStatementWriter.java:296)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:456)
	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:80)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:160)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:406)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:289)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:268)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:366)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1058)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:174)
	at org.codehaus.groovy.control.CompilationUnit$13.call(CompilationUnit.java:763)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:957)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:542)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:520)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:497)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:287)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:731)
	at groovy.lang.GroovyShell.run(GroovyShell.java:516)
	at groovy.lang.GroovyShell.run(GroovyShell.java:172)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:924)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:883)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:46)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:883)
	at groovy.lang.Closure.call(Closure.java:410)
	at groovy.lang.Closure.call(Closure.java:404)
	at groovy.lang.Closure.run(Closure.java:488)
	at java.lang.Thread.run(Thread.java:680)
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 29 14:07:19 UTC 2011,,,,,,,,,,"0|i2bq33:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Aug/11 11:14;blackdrag;I can confirm this and writeDirectMethodCall should not appear in the trace.;;;","29/Aug/11 14:07;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
List to LinkedHashSet inconsistent conversion behavior vs List to HashSet,GROOVY-4967,12815820,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,roshandawrani,roshandawrani,07/Aug/11 21:35,24/Dec/11 03:08,14/Jul/23 06:00,05/Dec/11 02:45,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,,,,,0,,,,,,"a), b), and c) all work, but d) fails with ""GroovyCastException: Cannot cast object '[x]' with class 'java.util.ArrayList' to class 'java.util.LinkedHashSet'""

a)
{code}
List x = []
HashSet<String> lhs = x
{code}

b)
{code}
List x = ['x']
HashSet<String> lhs = x
{code}

c)
{code}
List x = []
LinkedHashSet<String> lhs = x
{code}

d)
{code}
List x = ['x']
LinkedHashSet<String> lhs = x
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-08-07 21:35:28.0,,,,,,,,,,"0|i2c0gv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VeryifyError in multi-dimensional array usage:  Incompatible argument to function,GROOVY-4966,12815774,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,cfriedline,cfriedline,06/Aug/11 08:58,24/Dec/11 03:08,14/Jul/23 06:00,29/Nov/11 21:42,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,,,,,0,,,,,,"When running this code, I get the attached error.  Please see: http://pastie.org/2327875.  Dropping back to 1.7 seems to work.  I'm running 1.8.1, but the problem also exists in 1.8.0.","Mac OSX 10.7, jdk 1.6.0_26-b03-383-11A511",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 29 21:42:17 UTC 2011,,,,,,,,,,"0|i2cqn3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"06/Aug/11 09:11;cfriedline;Sorry, this error is not present in 1.8.0, I forgot to recompile after changing the gdk.  It does remain in 1.8.1, however. ;;;","06/Aug/11 22:12;roshandawrani;Here is a shorter piece of code that reproduces it:
{code}
char[] c1 = 'xy'.toCharArray()
getIndex(c1[0])

/*
//Note: This works fine
char a = 'a'
getIndex(a)
*/

def getIndex(char base) {}
{code};;;","28/Nov/11 21:57;roshandawrani;Corrected the bug title a bit.;;;","28/Nov/11 22:02;roshandawrani;Here is the shorter version of the code that currently reproduces the bug. (Probably the shorter version supplied earlier resulted in a VerifyError due to some other reason, and that piece of code works now.)

{code}
class ParalinearTest {
    static void main(args){}

    void zeroMatrix(int[][] matrix) {
        matrix[0][0]
    }
}
{code}

The bug can be seen in action on Groovy Web Console here: http://groovyconsole.appspot.com/edit/597001;;;","28/Nov/11 22:14;roshandawrani;The VerifyError is caused by how multi-dimensional arrays are handled on the fast-path.

For ""int[][] matrix"", matrix[0][0] is written in the class like:

{code}
BytecodeInterface8.intArrayGet(BytecodeInterface8.objectArrayGet(matrix, 0), 0)
{code}

when it should have been written as:

{code}
BytecodeInterface8.intArrayGet((int[])ScriptBytecodeAdapter.castToType(BytecodeInterface8.objectArrayGet(matrix, 0), int[]), 0)
{code}

The result of BytecodeInterface8.objectArrayGet was not casted to int[], which made the BytecodeInterface8.intArrayGet() call invalid.

The following patch solves the issue (tested locally with the latest shorter version and the original testcase of the bug):

{code}
@@ -166,11 +166,15 @@ public class BinaryExpressionMultiTypeDispatcher extends BinaryExpressionHelper
                 leftExp.visit(acg);
                 os.doGroovyCast(leftTypeOrig);
                 rightExp.visit(acg);
                 os.doGroovyCast(int_TYPE);
                 bew.arrayGet(operation, false);
-                os.replace(leftType,2);
+                if(bew instanceof BinaryObjectExpressionHelper) {
+                    os.replace(ClassHelper.OBJECT_TYPE,2);
+                } else {
+                    os.replace(leftType,2);
+                }
             } else {
                 super.evaluateBinaryExpression(message, binExp);
             }
         } else {
             int operationType = getOperandConversionType(leftType,rightType);
{code};;;","29/Nov/11 06:45;blackdrag;Well spotted Roshan! If that patch works with a 3d and 4d array too, then it would be nice of you to commit it. But I think it will work;;;","29/Nov/11 21:42;roshandawrani;Extended the test to cover 3d, 4d arrays also. They also work now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
shim classes generated incorrectly in 1.8.1 (was fine in 1.8.0) for some static inner-class usages,GROOVY-4965,12815636,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paul,paul,05/Aug/11 12:42,16/Sep/11 18:10,14/Jul/23 06:00,16/Sep/11 18:08,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,Compiler,,,,0,,,,,,"Static inner classes that are imported into Groovy scripts just fine in 1.8 are causing compilation issues in 1.8.1

To reproduce:
1) Java class Foo.Bar where Bar is public static within Foo.
2) Groovy script references the Foo.Bar as a type with an arglist to a method.

3) Groovy/Maven/Shim compiler puts a $ in the generated Java source name instead of a dot.

As I said, all that changed between working and not working is the version of Groovy.  This worked in 1.8.0 and at least some recent 1.7.x versions.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 16 18:08:18 UTC 2011,,,,,,,,,,"0|i2cf7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Aug/11 04:46;paulk;I suspect this was fixed as part of GROOVY-4939. Any chance you could try a snapshot, otherwise a better example would be good because the one I just created according to above appears to work in trunk. Thanks.;;;","08/Aug/11 11:28;paul;I'm, trying to run the Groovy build and it barfs foe me: some plexus classCastException issue, and I'm timing out on this.

I'll wait for a formal release of 1.8.2 and report then what it feels like. ;;;","08/Aug/11 11:37;paul;The uploaded 1.8.2-SNAPSHOT (dated 30th July) still exhibits the same defect.;;;","08/Aug/11 14:25;pniederw;I ran into the same problem when trying to upgrade Gradle to Groovy 1.8. I tried with with latest rev. 22728 (July 30th). Here is the generated method:

{code}
public static  java.lang.Object assertSetContains(org.gradle.api.file.FileCollection set, java.util.Set<java.lang.String> filenames, java.lang.Iterable<org.gradle.api.file.FileCollection$AntType> types, boolean generic) { return null;}
{code}

FileCollection.AntType is an inner enum written in Java. Again notice the {{$}}.
;;;","08/Aug/11 17:26;guillaume;With the following test, I couldn't reproduce the problem experienced in Gradle, neither with trunk nor 1.8.x:
{code}
/**
 * GROOVY-4965: shim classes generated incorrectly in 1.8.1 (was fine in 1.8.0) for some static inner-class usages
 * 
 * @author Guillaume Laforge
 */
class InterfaceInnerEnumUsedAsGenericsParamTest extends StringSourcesStubTestCase {

    Map<String, String> provideSources() {
        [
                'org/gradle/api/file/FileCollection.java': '''
                    package org.gradle.api.file;

                    public interface FileCollection {
                        enum AntType {
                            MatchingTask, FileSet, ResourceCollection
                        }
                    }
                ''',

                'org/gradle/api/tasks/AntBuilderAwareUtil.groovy': '''
                    package org.gradle.api.tasks

                    import org.gradle.api.file.FileCollection

                    class AntBuilderAwareUtil {
                        static def assertSetContains(FileCollection set, Set<String> filenames, Iterable<FileCollection.AntType> types, boolean generic = true) {
                            true
                        }
                    }
                '''
        ]
    }

    void verifyStubs() {
        println stubJavaSourceFor('org.gradle.api.tasks.AntBuilderAwareUtil')
    }
}
{code};;;","09/Aug/11 09:02;paul;I've managed to build trunk using ant, commenting out the hanging tests, ignoring the maven-deploy stage, then doing a manual install later.  

The bug is still there with a TRUNK checkout from moments ago.

Can someone direct me to the class that writes shim classnames?  I'll add a .replace(""$"",""."") where appropriate, and report back.;;;","09/Aug/11 10:44;guillaume;Hi Paul, you can look at org.codehaus.groovy.tools.javac.JavaStubGenerator.
And you can look at the printParams() method, which is most probably where the action takes place -- if it's in the types of the parameters of your methods that the problem arises.
Ideally, it would be good to have a reproducable test case like the one I pasted in my previous comment, so that we know it won't happen again once fixed.;;;","09/Aug/11 12:42;paul;Thanks Guillaume, 

Line 589 or so, genericsTypes[i].toString() should be genericsTypes[i].toString().replace(""$"",""."")
Either that or reuse/recurse into printType(..) as the  same replacement is done elsewhere in the code, but not for this particular path.

I can confirm, that my issue with live client code (hence it's not so easy to share) disappeared.;;;","09/Aug/11 12:58;blackdrag;Paul, you made me delete a very long comment ;) You are obviously right that printType should be reused here. Can you make a patch that works for you Paul?;;;","09/Aug/11 14:17;paul;Sounds like y'all are on the cusp of a change that doesn't lower test coverage ;)

However, answering the questions posed in the deleted comment:

{noformat}
genericsTypes[i].getType().isGenericsGenericsPlaceHolder() is false.
genericsTypes[i].toString() looks like so my.package.MyClass$MyInnerClass
{noformat}

Here's the one-liner diff, that aims at reuse of existing logic (that does the right thing).  Tested of course:
{noformat}
Index: src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
===================================================================
--- src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java    (revision 22747)
+++ src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java    (working copy)
@@ -589,7 +589,7 @@
         out.print('<');
         for (int i = 0; i < genericsTypes.length; i++) {
             if (i != 0) out.print("", "");
-            out.print(genericsTypes[i].toString());
+            printTypeName(out, genericsTypes[i].getType());
         }
         out.print('>');
     }
{noformat}
;;;","04/Sep/11 14:17;paulk;I have been unable to replicate an error case yet but the latest snapshot (I believe) should have the ""replace"" patch in place - the ""printTypeName"" patch broke some other behavior so I didn't go that way. It would be interesting to see if the latest snapshot fixes your issue.;;;","04/Sep/11 16:54;paul;close this issue. i moved my inner class to outer.;;;","16/Sep/11 06:09;paulk;Just waiting feedback from Peter to see if this is still a problem for Gradle. If not I will close the issue.;;;","16/Sep/11 17:52;pniederw;I eventually worked around it like Paul (converted the nested class to a top-level class). If you are interested, the groovy-1.8 branch of Gradle is available on GitHub.;;;","16/Sep/11 18:08;paulk;Fix to replace '$' with '.' was added but no test case could reproduce the original problem. Assuming fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static import overrides explicit class name when getting property,GROOVY-4964,12815838,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,david_beutel,david_beutel,05/Aug/11 00:09,07/Sep/11 14:13,14/Jul/23 06:00,29/Aug/11 06:40,1.7.8,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,,,,,0,,,,,,"When I static import a method, it takes precedence over a call to the method explicitly on another class, if I get a property from the result.

{code}
$ cat Foo.groovy 
class Foo {
    static doIt() { [k: 'foo'] }
}

jbeutel@jbeutel-mac:~/proj/groovySandboxes/staticImports (master *)
$ cat Bar.groovy 
import static Foo.*
class Bar {
    static doIt() { [k: 'bar'] }
    static doAssert() {
        assert doIt().k == 'foo'
        assert doIt() == [k: 'foo']
        assert Bar.doIt() == [k: 'bar']
        assert Bar.doIt().k == 'bar'
    }
}

jbeutel@jbeutel-mac:~/proj/groovySandboxes/staticImports (master *)
$ groovy -e 'Bar.doAssert()'
Caught: Assertion failed: 

assert Bar.doIt().k == 'bar'
                  | |
                  | false
                  foo

Assertion failed: 

assert Bar.doIt().k == 'bar'
                  | |
                  | false
                  foo

	at Bar.doAssert(Bar.groovy:8)
	at Bar$doAssert.call(Unknown Source)
	at script_from_command_line.run(script_from_command_line:1)

jbeutel@jbeutel-mac:~/proj/groovySandboxes/staticImports (master *)
$ groovy --version
Groovy Version: 1.8.1 JVM: 1.6.0_26
{code}

This was a problem for me when statically importing (with wildcards) a bunch of enum classes into another enum.

Work-around:  assign the method result to a temporary variable before getting a property from it.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 29 06:40:03 UTC 2011,,,,,,,,,,"0|i2bwfb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"05/Aug/11 13:16;david_beutel;For the method calls without an explicit class, I'm not sure if the statically imported method should take precedence over the local method.  But either way, I expect the last assert to succeed.;;;","29/Aug/11 06:40;paulk;Should be fixed - thanks for finding the issue.

We are still getting our CI servers switched over to git, so if you want to test in the very short term, you will need to build yourself from source. Once we have completed the switch, a snapshot jar should be available in the codehaus snapshot repo.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ConfigSlurper doesn't parse config files that contain $ signs in property values correctly,GROOVY-4958,12815822,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,erpl,erpl,03/Aug/11 06:04,24/Dec/11 03:08,14/Jul/23 06:00,30/Nov/11 03:33,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.5,2.0-beta-2,,,,,,0,,,,,,"When a ConfigObject is written to file all values are quoted with {{""}}. This leads to problems if a value contains a {{$}} for example.

Consider the following code snipet:
{code}
def config = new ConfigObject()
config.instObject = '1. Dyn. Aktber. ($IO_AKTBER)   # Aktenbereich (V-AKTBER)'

println ""config before writing to file:    ${config}""

def file = new File('C:/Temp/config.groovy')
file.withWriter { writer ->
    config.writeTo(writer)
}

config = new ConfigSlurper().parse(file.getText())
println ""config after reloading from file: ${config}""
{code}

The output is:
{code}
config before writing to file:    [instObject:1. Dyn. Aktber. ($IO_AKTBER)   # Aktenbereich (V-AKTBER)]
config after reloading from file: [IO_AKTBER:[:], instObject:1. Dyn. Aktber. ([:])   # Aktenbereich (V-AKTBER)]
{code}

The according file content:
{code}
instObject=""1. Dyn. Aktber. ($IO_AKTBER)   # Aktenbereich (V-AKTBER)""
{code}

As can be seen the two config objects differ widely. A solution could perhaps be writing properties quoted by {{'}} or writing the properties the way they are quoted in the source code, e. g. {{config.property1 = ""$property1""}} would become {{property1 = ""$property1""}} in the file and {{config.property2 = '$property1'}} would become {{property2 = '$property1'}}. This way the programmer could control the desired behaviour.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Nov/11 23:38;roshandawrani;GROOVY-4958_Patch.diff;https://issues.apache.org/jira/secure/attachment/12722593/GROOVY-4958_Patch.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 30 03:33:43 UTC 2011,,,,,,,,,,"0|i2bvgn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Nov/11 23:38;roshandawrani;ConfigObject.writeTo() depends on inspect(), which writes strings in form ""a"" instead of 'a'.
{code}
def list = ['a', 'b']
println list.inspect() // produces [""a"", ""b""]. Wouldn't it be Groovier, more correct to produce ['a', 'b'], to avoid GString mix-up possibility?
{code}

Attaching the patch for review that solves the ConfigObject issue reported here through this small change in inspect().

Does anyone see any negative impact of this change?;;;","29/Nov/11 02:50;melix;I think this is the right way to do this, but it seems your patch doesn't change the escaping of double quotes to escaping of simple quotes.;;;","30/Nov/11 03:33;roshandawrani;Fixed. Escaping of double quotes is now replaced by that of single quotes.

Thanks for reviewing the patch, Cedric. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Currying closure with null as argument fails with NPE,GROOVY-4954,12815795,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,dsrkoc,dsrkoc,01/Aug/11 16:49,28/Sep/11 10:14,14/Jul/23 06:00,28/Sep/11 10:14,1.8.0,1.8.1,1.9-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.9-beta-4,,,,,,,0,,,,,,"Trying to curry a closure with {{null}} as a parameter throws {{NullPointerException}}. With Groovy 1.7.10 it works as expected, i.e. sets the first closure argument to {{null}}.

Example using Groovy 1.8.1:
{code}
{ x, y -> x ?: y }.curry(null)

java.lang.NullPointerException
	at org.codehaus.groovy.runtime.CurriedClosure.<init>(CurriedClosure.java:54)
	at org.codehaus.groovy.runtime.CurriedClosure.<init>(CurriedClosure.java:86)
	at groovy.lang.Closure.curry(Closure.java:527)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:883)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:39)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
[...]

// The workaround is this:
assert { x, y -> x ?: y }.curry([null] as Object[])(3) == 3
{code}

Groovy 1.7.10 works as expected:
{code}
assert { x, y -> x ?: y }.curry(null)(3) == 3
assert { x, y -> x ?: y }.curry([null] as Object[])(3) == [null]
{code}

{{CurriedClosure}} constructor changed between 1.7 and 1.8:
{code}
$ diff 1.7.10/.../CurriedClosure.java 1.8.1/.../CurriedClosure.java
49c49
<     public CurriedClosure(int index, Closure uncurriedClosure, Object[] arguments) {
---
>     public CurriedClosure(int index, Closure<V> uncurriedClosure, Object... arguments) {
{code}

{{arguments}} parameter in 1.8 is set to {{null}} instead of {{[null]}} when invoking {{curry(null)}}, hence the exception on line 54 of {{CurriedClosure}} class.",,dsrkoc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 28 10:13:44 UTC 2011,,,,,,,,,,"0|i2cefb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Sep/11 06:43;paulk;Fixed.;;;","28/Sep/11 10:13;blackdrag;because of problems in GRails we had to rever the patch for 1.8;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE possibly related to PojoWrapper,GROOVY-4953,12818100,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,brownj,brownj,29/Jul/11 15:59,29/Aug/11 14:05,14/Jul/23 06:00,29/Aug/11 14:05,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.2,1.9-beta-3,,,,,0,,,,,,"{code:title=Widget.groovy|borderStyle=solid}
class Widget {
}
{code}

{code:title=testscript.groovy|borderStyle=solid}
Widget.metaClass.invokeMethod = { String methodName, Object[] args ->
    
    args.each { a ->
        println a.class
    }
}

w = new Widget()

w.doSometing([] as Object[])
{code}

With Groovy 1.8.0:

{noformat}
pojoproblem $ groovy -version
Groovy Version: 1.8.0 JVM: 1.6.0_26
pojoproblem $ groovy testscript.groovy 
class [Ljava.lang.Object;
{noformat}

With Groovy 1.8.1:

{noformat}
pojoproblem $ groovy -version
Groovy Version: 1.8.1 JVM: 1.6.0_26
pojoproblem $ groovy testscript.groovy 
Caught: java.lang.NullPointerException
java.lang.NullPointerException
	at testscript$_run_closure1_closure2.doCall(testscript.groovy:4)
	at testscript$_run_closure1.doCall(testscript.groovy:3)
	at testscript.run(testscript.groovy:10)
{noformat}

I think (not 100% sure) the NPE is related to the delegate property in PojoWrapper being null.  PojoWrapper.getProperty(String) is called, which looks like this:

{noformat}
    public Object getProperty(final String property) {
        return this.delegate.getProperty(this.wrapped, property);
    }
{noformat}

Is the wrapper really supposed to be passed into the closure or is it supposed to be the unwrapped object?",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 29 14:05:24 UTC 2011,,,,,,,,,,"0|i2c0qv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jul/11 18:08;paulk;A little more of the unsanitized stacktrace:
{noformat}
java.lang.NullPointerException
	at org.codehaus.groovy.runtime.wrappers.PojoWrapper.getProperty(PojoWrapper.java:41)
	at org.codehaus.groovy.runtime.callsite.PogoGetPropertySite.getProperty(PogoGetPropertySite.java:47)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGetProperty(AbstractCallSite.java:227)
	at ConsoleScript44$_run_closure1_closure2.doCall(ConsoleScript44:5)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1392)
{noformat}
Line 41 of PojoWrapper being the line Jeff refers to above.;;;","29/Aug/11 14:05;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError - Virtual method call from a static context,GROOVY-4952,12818101,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,jason@bobberinteractive.com,jason@bobberinteractive.com,28/Jul/11 19:42,29/Aug/11 14:05,14/Jul/23 06:00,29/Aug/11 14:05,1.8.0,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,bytecode,Compiler,,,1,,,,,,"Failing to put a public accessor on the 'name' field of the attached test object causes an error in the bytecode.

The exception is:
    <error message=""(class: com/peersaver/model/Breaking, method: &lt;clinit&gt; signature: ()V) Incompatible object argument for function call"" type=""java.lang.VerifyError"">java.lang.VerifyError: (class: com/peersaver/model/Breaking, method: &lt;clinit&gt; signature: ()V) Incompatible object argument for function call
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:169)
        at com.peersaver.model.BreakingTest.class$(BreakingTest.groovy)
        at com.peersaver.model.BreakingTest.$get$$class$com$peersaver$model$Breaking(BreakingTest.groovy)
        at com.peersaver.model.BreakingTest.testBreaking(BreakingTest.groovy:23)
</error>

The email conversation with details is here:
http://groovy.329449.n5.nabble.com/VerifyError-when-upgrading-to-Groovy-1-8-1-clinit-problem-around-getter-generation-td4640586.html

The relevant bit, again quoting BlackDragon: 
(in the <clinit> bytecode)
""> ALOAD 0
> INVOKEVIRTUAL Quiz.getName() : String
> INVOKEINTERFACE CallSite.call(Object,Object) : Object

it is a pretty bad idea to do a virtual method call from a static
context. Looks like that information is missed on ""  ",Mac - JDK 1.6.0_22,jason@bobberinteractive.com,jwb,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Jul/11 19:42;jason@bobberinteractive.com;BreakingTest.groovy;https://issues.apache.org/jira/secure/attachment/12722960/BreakingTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 29 14:05:53 UTC 2011,,,,,,,,,,"0|i2coef:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"29/Aug/11 14:05;blackdrag;fixed
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError - Expecting to find integer on stack,GROOVY-4951,12818116,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,jason@bobberinteractive.com,jason@bobberinteractive.com,28/Jul/11 19:32,05/Sep/11 05:03,14/Jul/23 06:00,29/Aug/11 14:06,1.8.0,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,bytecode,Compiler,primtive opts,,2,,,,,,"The line
result = prime * result + (int) (_tagReservationDate ^ (_tagReservationDate >>> 32))
produces bytecode that fails to run in the accompanying test.


<error message=""(class: com/peersaver/model/Breaking, method: hashCode signature: ()I) Expecting to find integer on stack"" type=""java.lang.VerifyError"">java.lang.VerifyError: (class: com/peersaver/model/Breaking, method: hashCode signature: ()I) Expecting to find integer on stack
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:169)
        at com.peersaver.model.BreakingTest.class$(BreakingTest.groovy)
        at com.peersaver.model.BreakingTest.$get$$class$com$peersaver$model$Breaking(BreakingTest.groovy)
        at com.peersaver.model.BreakingTest.testBreaking(BreakingTest.groovy:55)
</error>

The email conversation that covers drilling down into details can be found here:
http://groovy.329449.n5.nabble.com/VerifyError-when-upgrading-from-Groovy-1-7-6-to-1-8-1-td4632721.html

The relevant bit, quoting BlackDragon:
""
> L13
> ILOAD 3: prime
> [int] ILOAD 5: result
> [int,int] IMUL
> [int] ALOAD 0: this
> [int, this] GETFIELD TrackingTagReservation._tagReservationDate : long
> [int, long] ALOAD 0: this
> [int, long, this] GETFIELD TrackingTagReservation._tagReservationDate : long
> [int, long, long] LDC 32
> [int, long, long, int] I2L
> [int, long, long, long] LUSHR

here is a problem, LUSHR expects [..., long, int], but we have 2 longs
here. The I2L should not have happened. So I can confirm a problem here. ""

Thanks!
Jason",Mac - JDK 1.6.0_22,jason@bobberinteractive.com,jwb,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Jul/11 19:35;jason@bobberinteractive.com;BreakingTest.groovy;https://issues.apache.org/jira/secure/attachment/12722899/BreakingTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 05 05:03:00 UTC 2011,,,,,,,,,,"0|i2cqo7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"28/Jul/11 19:35;jason@bobberinteractive.com;A copy that doesn't reference ""TrackingTagReservation"", the original name of ""Breaking"";;;","11/Aug/11 10:36;jwb;It's good to see there's attention to this. Jason and I will be away for a week and will be available starting 26 Aug to test out any updates. We're excited to get to Groovy 1.8, so please let us know if you have any requests or suggestions.;;;","29/Aug/11 14:06;blackdrag;fixed
;;;","04/Sep/11 22:33;jason@bobberinteractive.com;Hi Jochen

I downloaded today's 1.8.2 snapshot, and this test still fails for me.  Is the fix in 1.8.2's snapshot?

Thanks!
Jason;;;","05/Sep/11 04:43;blackdrag;if the snapshot is from september, it should be in there, yes
;;;","05/Sep/11 05:03;blackdrag;ok, I found my mistake, I made the test with >> instead of >>> and forgot about the unassigned shift altogether... will be corrected in a sec;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ConfigSlurper broken on AppEngine,GROOVY-4950,12815823,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,guillaume,axel.fontaine,axel.fontaine,27/Jul/11 08:52,28/Dec/12 20:43,14/Jul/23 06:00,20/Dec/12 05:05,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,2.1.0-beta-1,,,,,5,,,,,,"On the production AppEngine environment, ConfigSlurper now breaks in 1.8.1 (This was working in 1.8.0) This makes Groovy 1.8.1 unusable on GAE as it stands!

Exception:
{code}
Caused by: java.lang.SecurityException: Unable to get members for class groovy.util.ConfigObject
	at com.google.appengine.runtime.Request.process-f6979038393db0ef(Request.java)
	at org.codehaus.groovy.reflection.CachedClass$3$1.run(CachedClass.java:84)
	at java.security.AccessController.doPrivileged(AccessController.java:34)
	at org.codehaus.groovy.reflection.CachedClass$3.initValue(CachedClass.java:81)
	at org.codehaus.groovy.reflection.CachedClass$3.initValue(CachedClass.java:79)
	at org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:46)
	at org.codehaus.groovy.util.LazyReference.get(LazyReference.java:33)
	at org.codehaus.groovy.reflection.CachedClass.getMethods(CachedClass.java:250)
	at groovy.lang.MetaClassImpl.populateMethods(MetaClassImpl.java:340)
	at groovy.lang.MetaClassImpl.fillMethodIndex(MetaClassImpl.java:290)
	at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:2915)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:166)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:182)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:242)
	at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:751)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallConstructorSite(CallSiteArray.java:71)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:54)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:190)
	at groovy.util.ConfigSlurper.parse(ConfigSlurper.groovy:160)
...
{code}
Note: This error does not occur on the GAE dev server.",AppEngine Java 1.5.2 Production,dhdaines,guillaume,marceloverdijk,mmigdol,sslavic,zhaber,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 28 20:43:29 UTC 2012,,,,,,,,,,"0|i2ck3j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Oct/11 05:41;axel.fontaine;As this doesn't seem to be on the radar for the next few releases, I have now moved to Json and JsonSlurper which work great on GAE and are both simpler and faster.

Please note that as I stated in the original report, this was a clear regression between 1.8.0 and 1.8.1;;;","14/Oct/11 09:01;blackdrag;I assign it to our appengine expert Guillaume, unless for example Roshan wants to take it;;;","28/Aug/12 17:12;zhaber;I can confirm that the bug is still reproducible with Groovy 2.0.1 and Google App Engine 1.7.1;;;","04/Sep/12 04:25;guillaume;For reproducing the issue, the simple statement below exhibits the problem on the Groovy Web Console:
{code}
new ConfigSlurper().parse('')
{code};;;","20/Dec/12 05:05;guillaume;I've rewritten the ConfigObject class in Java, to circumvent the odd security constraints of Google App Engine.;;;","28/Dec/12 20:43;dhdaines;Good idea although it has the side effect that ConfigObject no longer implements Cloneable, which unexpectedly breaks people's code...;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy getAt cannot be used with lazily initialized lists,GROOVY-4946,12818095,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,overzealous,overzealous,25/Jul/11 14:05,13/May/12 03:30,14/Jul/23 06:00,14/Mar/12 08:15,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,groovy-jdk,,,,0,runtime,,,,,"I'm not sure if this should even be logged as a bug, but here goes:

I was playing around with the Apache Commons {{ListUtils.lazyList}}.  This list will automatically create an item if an index is not yet defined (or is {{null}}).  Example code:

{code:title=Example.groovy}
@Grab(group='commons-collections', module='commons-collections', version='[1.3,)')
import org.apache.commons.collections.ListUtils
import org.apache.commons.collections.Factory
import groovy.transform.Canonical

@Canonical class Test {
    String name
    int amount
}

List<Test> t = ListUtils.lazyList([], { new Test() } as Factory)

// UNCOMMENT to make the example work:
// t.get(1)

// Thows NPE here:
t[1].name = 'Jim'
t[0].amount = 6

assert t == [new Test(null, 6), new Test('Jim', 0)]
{code}

However, I thought it was broken, because I had been running with without the commented {{t.get(1)}} line.  The {{getAt}} code checks the size of the dynamic list, and since it is smaller, returns {{null}}.  This causes an NPE to be thrown.

I realize that the lazy list breaks the {{List}} contract (by dynamically changing the list size).  However, it seems like a fairly useful feature to have a lazily created list.

I'm not sure there is an acceptable solution, but returning {{null}} hides the problem in a way that is hard to debug!  Maybe it would be better to have a {{withDefault}} method for lists, too, that works like the one for {{Map}}s.  That would provide a usable solution without breaking the current design.  Plus, you no longer have to include the commons library for that use case.  :-)",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 14 08:15:52 UTC 2012,,,,,,,,,,"0|i2bm9z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Mar/12 00:17;paulk;Yes, I think it would be good to introduce a ListWithDefault in Groovy similar to MapWithDefault. We could mimic the behaviour in the commons collection LazyList as you suggest. Here is the javadoc for anyone interested:

http://commons.apache.org/collections/apidocs/org/apache/commons/collections/list/LazyList.html

We would also need to add a {{DGM#withDefault(List, Closure)}} method.

A variation we could potentially support is a boolean flag to indicate eager creation of intervening index entries, i.e. {{DGM#withDefault(List, Closure, Boolean)}} with default to false, i.e. we would mimic LazyList and not support null as a valid list value. With the boolean set to true, we could support nulls but if you had a list with 2 elements (index values 0 and 1), then calling get at index 4 would cause the closure to be called for index values 2, 3 and 4 - rather than calling it just for 4 and setting the others to null.;;;","13/Mar/12 00:19;paulk;Actually, not sure whether we should split out creation of ListWithDefault as a separate Jira issue. In theory, we might want to address the {{getAt}} problem separately though I can't think of a backwards compatible way to do that.;;;","13/Mar/12 02:22;andre.steingress;The problem is that LazyList breaks the List contract as already mentioned above. I can't see how to handle this in DGM#getAt without introducing any direct/indirect references/checks for Commons LazyList.

Thus, I would vote for going with the DGM#withDefault approach.;;;","13/Mar/12 02:30;overzealous;If there is no way to ""fix"" {{getAt}}, I think that simply providing a {{withDefault}} is valid solution to this bug.

The real issue here is finding a way to support lazily-initialized lists via the subscript operator, not necessarily supporting the commons version.

I also think that using {{withDefault(Closure, Boolean)}} would be ugly (and have a ""magic"" boolean).  It would make more sense to have it a second method with the functionality in the name, like {{withFilledDefault(Closure)}}, which avoids the ambiguity.;;;","13/Mar/12 04:09;paulk;A potential gotcha compared to LazyList from commons collections is handling -ve indices. For most list-like things in Groovy we would allow index values from -1 through to (-size() + 1). I guess this is possible for ListWithDefault but needs to be thought through.;;;","13/Mar/12 15:17;andre.steingress;this is the pull request for the ListWithDefault implementation and DGM extension:

https://github.com/groovy/groovy-core/pull/37
;;;","14/Mar/12 08:15;paulk;ListWithDefault has been added. Thanks to all for the ideas and contributions.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Incorrect ""Possible solutions"" when calling a method on super in a non-derived class",GROOVY-4945,12818416,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,rene.scheibe,rene.scheibe,25/Jul/11 06:09,23/Jul/20 14:16,14/Jul/23 06:00,02/Jul/20 23:42,1.7.10,1.8.1,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.13,3.0.5,4.0.0-alpha-1,groovy-runtime,,,,0,,,,,,"h3. Calling an instance method on super in a non-derived class.

{code}
class T { void m() { super.m() } }
new T().m() 
{code}

This results in the below exception.

{noformat}
ERROR groovy.lang.MissingMethodException:
No signature of method: T.m() is applicable for argument types: () values: []
Possible solutions: m(), is(java.lang.Object), dump(), any(), any(groovy.lang.Closure), use([Ljava.lang.Object;)
{noformat}

This can be quite confusion as the called method on super is also listed in the possible solutions. The error message should be a different one.

h3. Calling a static method on super in a non-derived class.

{code}
class T { static void m() { super.m() } }
T.m() 
{code}

This results in the below stack overflow.

{noformat}
ERROR java.lang.StackOverflowError:
null
        at T.$getCallSiteArray (groovysh_evaluate)
        at T.m (groovysh_evaluate)
        at T.m (groovysh_evaluate:2)
        at T.m (groovysh_evaluate:2)
        ...
{noformat}",,blackdrag,pschumacher,,,,,,,,,,,"eric-milles opened a new pull request #1294:
URL: https://github.com/apache/groovy/pull/1294


   https://issues.apache.org/jira/browse/GROOVY-4945
   https://issues.apache.org/jira/browse/GROOVY-9615


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;01/Jul/20 22:28;githubbot;600","danielsun1106 merged pull request #1294:
URL: https://github.com/apache/groovy/pull/1294


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;02/Jul/20 23:42;githubbot;600","danielsun1106 commented on pull request #1294:
URL: https://github.com/apache/groovy/pull/1294#issuecomment-653262409


   Merged. Thanks.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;02/Jul/20 23:42;githubbot;600",,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,GROOVY-9615,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 19 03:25:41 UTC 2013,,,,,,,,,,"0|i2cixj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jun/13 12:49;pschumacher;Using Groovy 2.2.0-Snapshot I no longer get the stack overflow:

{code}
groovy:000> class T { static void m() { super.m() } }
===> true
groovy:000> T.m()
ERROR groovy.lang.MissingMethodException:
No signature of method: static java.lang.Object.m() is applicable for argument types: () values: []
Possible solutions: is(java.lang.Object), dump(), any(), any(groovy.lang.Closure), use([Ljava.lang.Object;), use(java.lang.Class,
groovy.lang.Closure)
        at T.m (groovysh_evaluate:2)
        at T$m.call (Unknown Source)
{code}

Therefore I changed the title and the priority of the issue.;;;","18/Jun/13 13:16;blackdrag;it is not only not overflowing anymore, the ""possible solutions"" in the error message are now correct as well. I am for closing the issue;;;","18/Jun/13 13:24;pschumacher;For the non-static instance method the error message does not seem correct:

{code}
groovy:000> class T { void m() { super.m() } }
===> true
groovy:000> new T().m()
ERROR groovy.lang.MissingMethodException:
No signature of method: T.m() is applicable for argument types: () values: []
Possible solutions: m(), is(java.lang.Object), any(), dump(), use([Ljava.lang.Object;), any(groovy.lang.Closure)
        at T.m (groovysh_evaluate:2)
        at T$m.call (Unknown Source)
{code}

or I'm I missing something?;;;","19/Jun/13 03:25;blackdrag;ah, I failed to see that you used a static call while the original report is about a non static call. Sorry. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Presence of ""assert"" unexpectedly changes program semantics (in Groovlet)",GROOVY-4944,12818509,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,yatima,yatima,25/Jul/11 05:50,25/Jul/11 14:33,14/Jul/23 06:00,25/Jul/11 12:27,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.2,1.9-beta-3,Groovlet / GSP,,,,0,,,,,,"In a Groovlet:

We have a function to map ""stuff"" to a boolean:
{code}
boolean mapBoolean(def datum, boolean defaultValue) {
   ......
   return res
}
{code}
Immediately after the above in the Groovlet source, the function is tested:
{code}
assert mapBoolean(null, false) == false
assert mapBoolean(null, null)  == false
{code}
One would expect the compiler to generate an error as 'null' cannot be passed as second parameter.

But the asserts above are accepted and pass!

If one removes the first assert and changes to solely
{code}
assert mapBoolean(null, null)  == false
{code}
THEN the compiler generates an error:
{code}
message GroovyServlet Error: script: 'foo': Script processing failed.No signature of method: com.mplify.interact.InspectMsg.mapBoolean() is applicable for argument types: (null, null) values: [null, null] Possible solutions: mapBoolean(java.lang.Object, boolean), asBoolean()org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)
{code}

A totally bared-down test ""Simple.groovy"" would be:

{code}
boolean mapBoolean(def datum, boolean defaultValue) {
   return false
}

if (params['run']) {
   assert mapBoolean(null, false)  == false
}

assert mapBoolean(null, null) == false

html.html {
    head { title ""Testing"" }
    body { div ""PASSED"" }
}
{code}

Called with Simple.groovy?run=true ---> PASSED
Called with Simple.groovy          ---> Script processing failed.No signature of method: Simple.mapBoolean() is applicable for argument types: (null, null) ","Red Hat Enterprise Linux Server release 5.6, Sun JDK build 1.6.0_26-b03",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 25 14:33:49 UTC 2011,,,,,,,,,,"0|i2c91j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Jul/11 08:51;blackdrag;David, we have not been able to reproduce this;;;","25/Jul/11 09:39;yatima;Hi,

Ok, let's see what's different.

Instead of a Groovlet, a script, same problem:

{code}
// Script!

// This method shall be called and cause trouble

boolean shaky(boolean defaultValue) {
   return false
}

// Pass ""skip"" as first argument to skip the assertion

if (args && args[0] == 'skip') {
   assert shaky(false)  == false
}

// This assertion will cause a runtime error if the previous assertion is not skipped

assert shaky(null) == false

System.out << ""PASSED\n""
{code}

Problem occurs on:

   Red Hat Enterprise Linux Server release 5.6 (Tikanga)
   Groovy Version: 1.8.0 
   JVM: Java(TM) SE Runtime Environment (build 1.6.0_26-b03)

Also on 

   Fedora release 14 (Laughlin) 
   Groovy Version: 1.8.0 
   JVM: Java(TM) SE Runtime Environment (build 1.6.0_26-b03)
   or
   JVM: IcedTea6 1.9.8


;;;","25/Jul/11 09:46;guillaume;Can you tell us also what's on your classpath?

Also is it intentional that you're using boolean vs Boolean and passing null into that primitive method parameter?;;;","25/Jul/11 09:59;yatima;Hi Guillaume, 

>is it intentional that you're using boolean vs Boolean 

Yes. I wanted to have a function that as non-null parameters coming in. I then added the assertion passing null to see what Groovy would do, and it did something surprising.

Furthermore, the CLASSPATH is empty.;;;","25/Jul/11 10:53;blackdrag;I can reduce the script to {code:Java}boolean shaky(boolean defaultValue) {false}
shaky(false)
shaky(null)
System.out << ""PASSED\n""{code};;;","25/Jul/11 12:02;yatima;Jochen's script passes.

However

{code}
boolean shaky(boolean defaultValue) {false}
shaky(null)
System.out << ""PASSED\n""
{code}

yields groovy.lang.MissingMethodException
;;;","25/Jul/11 12:27;blackdrag;I seems the bug appears only if there is one method and there had been an invocation cached before. And then it is only wrong if there is the usage of null as value, as you did here in the second invocation. 

So a big thank you for finding this one. It should be fixed now.;;;","25/Jul/11 14:33;yatima;It me thanking you. Keep up the excellent work!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.bat can't run if PATH contains parentheses ,GROOVY-4942,12811912,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,aeffy,aeffy,23/Jul/11 09:26,05/Apr/15 14:43,14/Jul/23 06:00,26/Jul/11 23:44,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,command line processing,,,,0,,,,,,"JAVA_HOME not defined.

PATH contains "")"" character(Windows 7 default Path).
{code}
C:\Dev\Apps\groovy-1.8.0\bin>echo %PATH%
C:\Program Files\Common Files\Microsoft Shared\Windows Live;C:\Program Files (x8
6)\Common Files\Microsoft Shared\Windows Live;C:\windows\system32;C:\windows;
C:\Program Files\Java\jre7\bin
{code}

groovy and goovysh can't run.
{code}
C:\Dev\Apps\groovy-1.8.0\bin>groovy -v
\Common was unexpected at this time.
{code}

Windows batch command ""for"" can't treat a string contains "")"".
",Windows 7 Home Edition Premiun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/Jul/11 09:26;aeffy;startGroovy.patch;https://issues.apache.org/jira/secure/attachment/12722869/startGroovy.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Tue Jul 26 23:44:20 UTC 2011,,,,,,,,,,"0|i2bz8n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jul/11 13:27;blackdrag;Paul, could you test the patch?I don't have a windows box ready;;;","26/Jul/11 23:44;paulk;patch applied, thanks;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy Console Icon for OSX still broken,GROOVY-4940,12815771,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,tim_yates,tim_yates,22/Jul/11 02:03,22/Jul/11 08:51,14/Jul/23 06:00,22/Jul/11 08:51,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.2,1.9-beta-3,,,,,0,,,,,,"The long serving bug GROOVY-4306 is still around.

Looking at the icns file using a hex editor (and comparing it to the one I attached to the GROOVY-4306 issue) seems to show lots of extra data being stuffed into the one distributed with the binary distribution...

It's like it's being converted to unicode or something?

The original icns file starts with the following 64 bytes:

{code}
69636E73 0001B17B 696C3332 00000A51
87FF0B53 2D110A05 0B0A0B0C 1E38EC8F
FF10551A 13294760 717A7F73 6948270B
2595C08A FF147F23 1C45718A 9EABB1B4
{code}

But the distributed one starts with:

{code}
69636E73 0001EFBF BD7B696C 33320000
0A51EFBF BDEFBFBD 0B532D11 0A050B0A
0B0C1E38 EFBFBDEF BFBD1055 1A132947
60717A7F 73694827 0B25EFBF BDEFBFBD
{code}

As you can see, the byte {{B1}} at position 7 in the original has been changed to {{EFBFBD}} in the distributed file -- and again, {{87FF}} at position 16 seems to be replaced with {{EFBFBDEFBFBD}}

The file size has increased as well, the original being 110971 bytes in length, but the distributed file is 214052 bytes",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 22 08:50:35 UTC 2011,,,,,,,,,,"0|i2c5ef:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jul/11 03:15;guillaume;Rohhh... okay, so it was really not a problem with fixcrlf...
I don't think we have a native2ascii call or something like that though.
Not sure what borks the icon file yet :-(;;;","22/Jul/11 04:49;tim_yates;Strangely, if I run {{ant dist}} on my mac, and unzip the generated {{target/dist/groovy-binary-1.9.0-beta-2-SNAPSHOT.zip}} file, the {{bin/groovy.icns}} file inside is fine

My current guesses are:

# Something downstream from here, between building and releasing to the site for download is manipulating the file
# The machine that builds the distribution has some extra steps it performs which is corrupting the file
# Building on a non-mac machine corrupts the file
# Building on Java 1.5 or an ant version < 1.8.2 corrupts the file

But they are only guesses, and I have no way to check if any of them are true;;;","22/Jul/11 04:57;tim_yates;Just did a quick search for {{EFBFBD}}, and it looks like it is the [Unicode Replacement Character|http://www.fileformat.info/info/unicode/char/fffd/index.htm]

{quote}
used to replace an incoming character whose value is unknown or unrepresentable in Unicode
{quote}

So it is something somewhere checking that groovy.icns is valid unicode (which it obviously isn't), and injecting replacement chars all over the place;;;","22/Jul/11 08:50;blackdrag;The ant copy task we used here changed the file. We fixed that now and it seems the file is now unchanged copied over, which should fix the problem;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovyc compilation problem for return values with generics,GROOVY-4939,12818098,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,armsargis,armsargis,21/Jul/11 15:35,07/Sep/11 14:13,14/Jul/23 06:00,22/Jul/11 22:53,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.2,1.9-beta-3,Compiler,,,,0,,,,,,"Hi I have following code which was ok for groovy 1.8.0 but after updating to groovy 1.8.1 I have failed compilation 

{code:title=MessagingTask.groovy}
class MessagingTask<T extends Serializable> {

  private static final long serialVersionUID = -5533069690405593263L;

  Long id
  String messageId
  String inDestination
  String outDestination
  MessagingTaskType messageType
  T messagePayload

  public String toString() {
    return ""Task{"" +
            ""id="" + id +
            "", messageId='"" + messageId + '\'' +
            "", inDestination='"" + inDestination + '\'' +
            "", outDestination='"" + outDestination + '\'' +
            "", messageType='"" + messageType + '\'' +
            "", messagePayload="" + messagePayload +
            '}';
  }
}
{code}
{code:title=MessagingTaskDatabase.groovy}
class MessagingTaskDatabase {

    public List<MessagingTask<OutMessage>> loadOutMessage() {
        return new ArrayList<MessagingTask<OutMessage>>();
    }

}
{code}
{code:title=SomeClient.java}
List<MessagingTask<OutMessage>> messagingTasks = taskDatabase.loadOutMessage();
{code}
And the compile log:
{noformat}
    [mkdir] Created dir: /home/sargis/projects/twm_v3/trunk/twm_v3/accounting/Server/classes
  [groovyc] Compiling 185 source files to /home/sargis/projects/twm_v3/trunk/twm_v3/accounting/Server/classes
  [groovyc] org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
  [groovyc] Compile error during compilation with javac.
  [groovyc] /home/sargis/projects/twm_v3/trunk/twm_v3/accounting/Server/src/com/webbfontaine/twm/accounting/epaylog/scheduler/SendingScheduler.java:46: incompatible types
  [groovyc] found   : java.util.List<com.webbfontaine.twm.accounting.epaylog.emess.task.MessagingTask>
  [groovyc] required: java.util.List<com.webbfontaine.twm.accounting.epaylog.emess.task.MessagingTask<com.webbfontaine.twm.accounting.epaylog.emess.core.OutMessage>>
  [groovyc]         List<MessagingTask<OutMessage>> messagingTasks = taskDatabase.loadOutMessage();
  [groovyc]                                                                                     ^
  [groovyc] Note: Some input files use unchecked or unsafe operations.
  [groovyc] Note: Recompile with -Xlint:unchecked for details.
  [groovyc] 1 error
  [groovyc] 
  [groovyc] 
  [groovyc] 1 error
{noformat}

But if I remove generic type parameters from return and compilation is ok
{code}
public List loadOutMessage() {
    return new ArrayList<MessagingTask<OutMessage>>();
}
{code}
","sargis@sargis:~> uname -a
Linux sargis.webbfontaine.fr 2.6.37.6-0.5-desktop #1 SMP PREEMPT 2011-04-25 21:48:33 +0200 x86_64 x86_64 x86_64 GNU/Linux
sargis@sargis:~> java -version
java version ""1.6.0_26""
Java(TM) SE Runtime Environment (build 1.6.0_26-b03)
Java HotSpot(TM) 64-Bit Server VM (build 20.1-b02, mixed mode)
sargis@sargis:~> groovy -version
Groovy Version: 1.8.1 JVM: 1.6.0_26
sargis@sargis:~> 
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/Jul/11 16:25;armsargis;groovyc-test.tar.gz;https://issues.apache.org/jira/secure/attachment/12722957/groovyc-test.tar.gz",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 23 02:51:08 UTC 2011,,,,,,,,,,"0|i2cre7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jul/11 16:25;armsargis;I created some simple project with gradle to help you to reproduce compilation error;;;","22/Jul/11 03:40;paulk;add code tags;;;","22/Jul/11 22:53;paulk;Should be fixed - if you can try a snapshot jar, that would be great.;;;","23/Jul/11 02:51;armsargis;I tried to build with snapshot jar and now everything is ok, issue solved. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError related to byte arrays,GROOVY-4938,12815784,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,brownj,brownj,21/Jul/11 12:29,23/Jul/11 04:54,14/Jul/23 06:00,23/Jul/11 04:54,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,,,,,0,,,,,,"{noformat}
~ $ groovy --version
Groovy Version: 1.8.1 JVM: 1.6.0_26
~ $ groovy -e ""i = new int[42];println i[0];""
0
~ $ groovy -e ""int[] i = new int[42];println i[0];""
0
~ $ groovy -e ""b = new byte[42]; println b[0];""
0
~ $ groovy -e ""byte[] b = new byte[42]; println b[0];""
Caught: java.lang.VerifyError: (class: script_from_command_line, method: run signature: ()Ljava/lang/Object;) Incompatible argument to function
java.lang.VerifyError: (class: script_from_command_line, method: run signature: ()Ljava/lang/Object;) Incompatible argument to function
{noformat}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 23 04:54:26 UTC 2011,,,,,,,,,,"0|i2bzsn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jul/11 04:54;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sorting an ObservableList instance results in IndexOutOfBoundsException,GROOVY-4937,12815766,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,aalmiray,aalmiray,21/Jul/11 07:21,07/Sep/11 14:13,14/Jul/23 06:00,22/Jul/11 22:55,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.2,1.9-beta-3,,,,,0,,,,,,"Reported at the Griffon user ML

{code}
l = [1, 4, 2] as ObservableList
l.sort()
{code}

results in

{code}
java.lang.IndexOutOfBoundsException: Index: 3, Size: 3
	at java.util.ArrayList.RangeCheck(ArrayList.java:547)
	at java.util.ArrayList.set(ArrayList.java:337)
	at groovy.util.ObservableList.set(ObservableList.java:349)
	at groovy.util.ObservableList$ObservableListIterator.set(ObservableList.java:439)
	at java.util.Collections.sort(Collections.java:163)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.sort(DefaultGroovyMethods.java:5918)
	at org.codehaus.groovy.runtime.dgm$595.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:271)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:53)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at ConsoleScript3.run(ConsoleScript3:2)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:266)
	at groovy.lang.GroovyShell.run(GroovyShell.java:517)
	at groovy.lang.GroovyShell.run(GroovyShell.java:172)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:910)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)
	at groovy.lang.Closure.call(Closure.java:405)
	at groovy.lang.Closure.call(Closure.java:399)
	at groovy.lang.Closure.run(Closure.java:483)
	at java.lang.Thread.run(Thread.java:680)
{code}",,paulk,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"22/Jul/11 03:19;tim_yates;groovy-4937.patch;https://issues.apache.org/jira/secure/attachment/12722897/groovy-4937.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 22 22:55:51 UTC 2011,,,,,,,,,,"0|i2c707:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jul/11 02:20;tim_yates;Had a quick test, and this seems to have been a bug in all versions

(tested v1.8.0, v1.7.8, v1.7.0, and v1.6.3);;;","22/Jul/11 03:19;tim_yates;Think this catches it, I believe {{cursor}} in {{ObservableIterator}} and {{ObservableListIterator}} needed initialising to {{-1}} or {{index -1}} respectively.

Added a couple of tests, to try and make sure I haven't broken anything...;;;","22/Jul/11 07:32;paulk;Patch looks good. Andres, want me to apply it?;;;","22/Jul/11 10:58;aalmiray;Yes, please :-)
Thanks again Tim!

Patch for GROOVY-4699 (by Tim) is also available.;;;","22/Jul/11 22:55;paulk;Applied. Thanks for the patch Tim.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
package protected method in Parent class cannot be called,GROOVY-4936,12815529,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,20/Jul/11 17:53,21/Jul/11 05:01,14/Jul/23 06:00,21/Jul/11 05:01,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,,,,,0,,,,,,"assuming we have {code:Java}
public class Parent{ 
  int someMethod(){return 1;}
}{code}written in Java and {code:Java}
public class Child extends Parent{
  int someMethod(){
    return super.someMethod()+2
  }
}{code} written in Groovy, then this results in a StackOverflow.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Jul/11 17:59;blackdrag;4936.patch;https://issues.apache.org/jira/secure/attachment/12722958/4936.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 21 05:01:41 UTC 2011,,,,,,,,,,"0|i2c9uv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jul/11 17:56;blackdrag;part of the problem is, as described in GROOVY-4922, the logic {code:Java}useThis ^ (method.getModifiers() & (Modifier.PUBLIC | Modifier.PROTECTED){code}
But this logic appears twice in MetaClassImpl and a third time in MetaMethod#getMopName;;;","20/Jul/11 17:59;blackdrag;attaching a partial patch. This fixes the stack overflow problem, but with this patch we still have 1 failing test. Which is funnily the formerly passing test for GROOVY-4922 I added earlier. It fails now with: tried to access method groovy.bugs.Groovy4922BugSupport.someMethod(Ljava/lang/String;)V
Which means the logic is not yet right like this maybe;;;","20/Jul/11 18:01;blackdrag;The stack is:{code}
java.lang.IllegalAccessError: tried to access method groovy.bugs.Groovy4922BugSupport.someMethod(Ljava/lang/String;)V from class groovy.bugs.Groovy4922BugChild
at groovy.bugs.Groovy4922BugChild.super$2$someMethod(TestScripttestShouldNotThrowStackOverflow82.groovy) 
at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90){code};;;","20/Jul/11 18:04;blackdrag;What can be seen here is, correct super$2$someMethod method is selected and executed, but it has no access to the package private parent class method. The question is why. They are in the same package, so there should be no problem with that.;;;","21/Jul/11 05:01;blackdrag;The reason for the IllegalAccessError is that in the test the class loaders for the Child and for the parent are different. In terms of package private that means that no access is allowed and the IllegalAccessError is correct. Thus I changed the test to use the PackaScope transformation instead and then all tests pass.
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
stub generator loses package qualification for generic type argument,GROOVY-4935,12818099,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,lgdean,lgdean,20/Jul/11 12:13,22/Jul/11 16:56,14/Jul/23 06:00,21/Jul/11 04:58,1.8.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,Stub generator / Joint compiler,,,,0,,,,,,"In my groovy class, I have a method that returns a List<Year>, where <Year> is a java class in another package.  (Not sure whether the ""java"" part is relevant; it's what my code happened to do.  I also haven't checked whether this problem happens only with method return types, though I _think_ all the examples I saw had that property.)

{code}
import other_package.Year

class YearRange {
   List<Year> getYears() {
      return null
   }
}
{code}

When groovy creates the stub, however, it includes the full package name for List, but not for Year:

{noformat}
  [groovyc] C:\DOCUME~1\cyrus\LOCALS~1\Temp\groovy-generated-1209606927705701441-java-source\one_package\YearRange.java:18: cannot find symbol
  [groovyc] symbol  : class Year
  [groovyc] location: class one_package.YearRange
  [groovyc] public  java.util.List<Year> getYears() { return (java.util.List<Year>)null;}
  [groovyc]                        ^
  [groovyc] C:\DOCUME~1\cyrus\LOCALS~1\Temp\groovy-generated-1209606927705701441-java-source\one_package\YearRange.java:18: cannot find symbol
  [groovyc] symbol  : class Year
  [groovyc] location: class one_package.YearRange
  [groovyc] public  java.util.List<Year> getYears() { return (java.util.List<Year>)null;}
{noformat}

I have this problem with the following snapshot build:
groovy-all-1.8.1-SNAPSHOT.jar              20-Jul-2011 06:11  5.8M

I do not have this problem with groovy 1.8.0.","Windows XP (as it happens)
jdk1.6.0_17",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Jul/11 12:13;lgdean;generic-return.zip;https://issues.apache.org/jira/secure/attachment/12722895/generic-return.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 22 16:56:14 UTC 2011,,,,,,,,,,"0|i2cmfr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"21/Jul/11 04:58;paulk;Thanks for the excellent feedback and testcases - should be fixed. If you can try another snapshot once the CI server has complete, that would be great. Thanks again.;;;","22/Jul/11 16:56;lgdean;works for me with this snapshot:
groovy-all-1.8.1-SNAPSHOT.jar              21-Jul-2011 07:46  5.8M

Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
incorrect signature attributes in class files for inner class generics,GROOVY-4934,12816512,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,aclement,aclement,19/Jul/11 19:53,01/Feb/12 12:47,14/Jul/23 06:00,01/Feb/12 12:47,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.6,2.0-beta-3,bytecode,class generator,,,7,,,,,,"When an inner type shares state with its outer type, and that shared state is generic, the signature attributes generated inside the inner class are not correct.  This is not normally a problem because once created they are rarely processed again, however, Eclipse checks these things and discovers the inconsistencies, reporting an 'inconsistent class file' error when it sees a type variable referenced that is not in scope.

Here is a simple groovy program:
{code}
import groovy.lang.Closure

import java.io.Serializable
import java.util.Map

class GormInstanceApi<D> {

	void delete(D instance) {
		new VoidSessionCallback() {
			void doInSession() {
				print instance
			}
		}
	}

}

interface VoidSessionCallback {
	void doInSession();
}
{code}

When this gets compiled, a field of type Reference is created in the inner type (in the InnerClassVisitor.visitConstructorCallExpression()) code, and this is added to the constructor.  The signature attribute for the new field and the constructor of the inner type encodes a generic reference that isn't quite right - it refers to a type variable that isn't in scope.  Here is the generic signature attribute for the constructor:

 (LGormInstanceApi<TD;>;Lgroovy/lang/Reference<TT;>;)V;

The first bit is OK, the 'D' referred to is defined by the declaring type and so visible from the inner.  However the 'T' is not visible - I would have expected a reference to the raw type there:

(LGormInstanceApi<TD;>;Lgroovy/lang/Reference;)V;

Or, if it was being used in parameterized form:

(LGormInstanceApi<TD;>;Lgroovy/lang/Reference<Ljava/lang/Object;>;)V;

Similarly it is wrong for the field:

 Lgroovy/lang/Reference<TT;>;;

T is not in scope (not declared by this type or a surrounding type).

To see this problem in Eclipse, define a project containing that code above and then create a pure java project that depends upon it.  Add this file to the java project:
{code}
class Simple<D> extends GormInstanceApi<D> {
	 
	void foo() {	 
		new VoidSessionCallback() {
			public void doInSession() {
			}  
		} ;
	}    
}  
{code}

This code is enough to force JDT to load in the GormInstanceApi inner class and discover the inconsistency in signatures:

Inconsistent classfile encountered: The undefined type parameter T is referenced from within GormInstanceApi<D>.1	

I'd propose the type of the newly created field is set to the raw type for groovy.lang.Reference, but I don't know how to create a raw ClassNode.",,burtbeckwith,davide.cavestro,mauromol,mrtrevisan,paulk,werdna,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/Aug/11 12:31;aclement;version3.patch;https://issues.apache.org/jira/secure/attachment/12722961/version3.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 01 12:47:55 UTC 2012,,,,,,,,,,"0|i2btnr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jul/11 22:14;aclement;Ah, I see, you call them plain references.  Please find a patch attached that uses the raw (plain) type reference for the new fields created inside these inner types.  I'm afraid I haven't run it against your test suite, but it fixes the inconsistent class issue that eclipse finds.;;;","20/Jul/11 04:45;blackdrag;the patch works for 1.8 and 1.9, but in 1.7 not.I committed the patch to 1.8/1.9 then.;;;","26/Jul/11 10:11;aclement;My users were hitting this with groovy 1.7 so I applied the same change there, this does not work by itself.  It looks like it fails because getPlainNodeReference doesn't set the interfaces, only the superclass (and so the users were seeing an NPE when attempting to work with the interfaces for the plain node).  So I had to make the additional change in getPlainNodeReference to pass getInterfaces() alongside getSuperclass() when building the new ClassNode.;;;","05/Aug/11 12:35;aclement;This is the variant of the patch for 1.7.10 - which in addition to using a plain node reference ensures the interfaces are set for the node ref.;;;","08/Aug/11 09:30;blackdrag;Andy, with this patch I still get a failing test:
  [groovyc] BUG! exception in phase 'class generation' in source unit '/home/blackdrag/coding/GROOVY_1_7_X/src/test/groovy/lang/ReferenceSerializationTest.groovy' ClassNode#getTypeClass for groovy.lang.Reference is called before the type class is set ;;;","08/Aug/11 10:12;aclement;ok Jochen, I'll take a look when I get some time.;;;","18/Aug/11 12:31;aclement;New version of the patch which copies the clazz across when creating a plain node reference.  Seems to pass all the groovy tests.;;;","22/Sep/11 06:18;blackdrag;Andy sorry it took so long... there are some things in the patch that make me wonder if the usage is really correct. A plain node reference is supposed to be a ClassNode that redirects to another one and contains itself no generics information. 

As such setting clazz makes no sense. Normally a redirecting ClassNode should never have clazz set. I can only assume that eclipse is using that API differently here. But this has future conflict potential.

Next tihng is the interfaces. A redirecting node will ask the node it redirects to for the the interfaces. Therefore it makes no sense to store them directly on the redirecting node as well.

The part of InnerClassVisitor is already in the repo;;;","22/Sep/11 10:09;aclement;Hey.  Been a while since I look at this, but I think I only did the 'extra stuff' to keep some of the groovy infrastructure happy, not eclipse, I was making minor changes and that running the groovy tests.  So I found if the clazz or interfaces werent set, groovy tests were failing - if I recall correctly.;;;","01/Feb/12 12:47;blackdrag;the fix versions for 1.8 and 2.0 are not really right, but we missed to add those, so I use the current one. I finally managed to apply your patch. I actually tried to not use some of the parts you use, like not setting the interfaces, but didn't work. While not perfect, I think it is ok for 1.7, so I simply applied it;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Class implementing a generic interface causes VerifyError,GROOVY-4924,12815754,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,dvekhter,dvekhter,14/Jul/11 13:17,14/Jul/11 15:26,14/Jul/23 06:00,14/Jul/11 15:26,1.7.10,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,,,,,0,,,,,,"This script:
{code}
interface Interface<SomeType> {
   public void handle(long a, SomeType x);
}

class InterfaceImpl
implements Interface<String> {
    public void handle(long a, String something) {
        println(something);
    }
}

InterfaceImpl test = new InterfaceImpl()
test.handle(5, ""hi"");
{code}
causes:

{code}
Caught: java.lang.VerifyError: (class: InterfaceImpl, method: handle signature: (JLjava/lang/Object;)V) Register 2 contains wrong type
        at Test.class$(Test.groovy)
        at Test.$get$$class$InterfaceImpl(Test.groovy)
        at Test.run(Test.groovy:12)
{code}","Groovy Version: 1.8.0 JVM: 1.6.0_0
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 14 15:26:29 UTC 2011,,,,,,,,,,"0|i2bpiv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"14/Jul/11 15:10;blackdrag;looks like the bridge method creation code does simply ignore double and long taking two slots;;;","14/Jul/11 15:26;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Creating Pattern from declared String variable  with pattern = ~stringvariable fails,GROOVY-4923,12815735,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ola.mattsson,ola.mattsson,14/Jul/11 12:03,14/Jul/11 16:20,14/Jul/23 06:00,14/Jul/11 16:20,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,,,,,0,,,,,,"An attempt to create a java.util.regex.Pattern from a variable that is declared as a String fails with a java.lang.ClassCastException: java.util.regex.Pattern cannot be cast to java.lang.String

The code below worked with Groovy 1.7.8 but fails with Groovy 1.8.0
String value=""test""
String s = ""^\\S+$value\$""
def p = ~s <==Fails here

A workaround is to change the last statement to:
def p = ~/$s/
but that adds clutter
","Windows 7 64bit, 32 bit jvm 1.6.0_26",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 14 16:20:54 UTC 2011,,,,,,,,,,"0|i2bp1r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Jul/11 16:20;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StackOverflowError when calling super and overriding a package protected java method,GROOVY-4922,12815873,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,13/Jul/11 14:55,13/May/12 03:30,14/Jul/23 06:00,14/Feb/12 12:28,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.7,2.0-beta-3,,,,,10,,,,,,"For reference : http://groovy.329449.n5.nabble.com/StackOverflowError-when-dispatching-to-super-td4572268.html

If a package protected method written in a Java class is overriden in a Groovy class and that method calls super.method(), Groovy throws a stack overflow :

{code:title=Parent.java}
class Parent {
   void someMethod(String param) { ... }
}
{code}

{code:title=Child.groovy}
class Child {
   void someMethod(String param) { super.someMethod(param) }
}
{code}

{code}
java.lang.StackOverflowError
	at java.lang.Exception.<init>(Exception.java:77)
	at java.lang.reflect.InvocationTargetException.<init>(InvocationTargetException.java:54)
	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1054)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:128)
	at groovy.bugs.GroovyStackOverflowBug$Child.someMethod(GroovyStackOverflowBug.groovy:39)
	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1054)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:128)
	at groovy.bugs.GroovyStackOverflowBug$Child.someMethod(GroovyStackOverflowBug.groovy:39)
	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1054)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:128)
	at groovy.bugs.GroovyStackOverflowBug$Child.someMethod(GroovyStackOverflowBug.groovy:39)
	at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
...
{code}

Adding a public or protected modifier to the super class solves the problem.",,darxriggs,hamletdrc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"19/Jul/11 05:02;hamletdrc;4922failure.patch;https://issues.apache.org/jira/secure/attachment/12722861/4922failure.patch","18/Jul/11 11:56;melix;GROOVY-4922-new.patch;https://issues.apache.org/jira/secure/attachment/12722862/GROOVY-4922-new.patch","18/Jul/11 09:07;melix;GROOVY-4922.patch;https://issues.apache.org/jira/secure/attachment/12722864/GROOVY-4922.patch","21/Jul/11 10:21;hamletdrc;new_stackoverflow_example.zip;https://issues.apache.org/jira/secure/attachment/12722956/new_stackoverflow_example.zip","21/Jul/11 06:06;hamletdrc;stackoverflow-example.zip;https://issues.apache.org/jira/secure/attachment/12722896/stackoverflow-example.zip","18/Jul/11 09:07;melix;test-reports.tar.gz;https://issues.apache.org/jira/secure/attachment/12722952/test-reports.tar.gz",,,6.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 14 12:28:05 UTC 2012,,,,,,,,,,"0|i2c2nj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jul/11 15:57;melix;Here is what I found. In MetaClassImpl.MethodIndexAction#methodNameAction(), 

# If you use a protected modifier in the super class method, the _mopMethods_ list contains the _$super_ method. If the modifier is removed, the method disappears from _mopMethods_.

# plus, the following test fails because of the modifier test (line 460) : {code}(useThis ^ (method.getModifiers() & (Modifier.PUBLIC | Modifier.PROTECTED)) == 0){code}

So it seems there are two problems to solve : the fact that the super method is missing from the MOP methods and the test which forgets about package protected methods. I'm not sure this can be fixed without side effects.
;;;","18/Jul/11 06:28;hamletdrc;I recommend changing the Priority to Blocker. ;;;","18/Jul/11 06:56;melix;Hamlet,

Here is my test case for this bug. In the thread, you say that you have the error even with a non package protected method. Could you update the test class with an example of such a behaviour ? Thank you !

{code:title=StackOverflowBugSupport.java}
package groovy.bugs;

/**
 * Support class for GROOVY-4922 bug. Must be written in Java.
 */
class StackOverflowBugSupport {
    protected String support;

    void someMethod(String value) {
        support = value;
    }
}

{code}

{code:title=GroovyStackOverflowBug}

package groovy.bugs


class GroovyStackOverflowBug extends GroovyTestCase {
    void testShouldNotThrowStackOverflow() {
        def child = new Child()
        child.someMethod(""value"")
        assert child.support == ""value""
    }


    class Child extends StackOverflowBugSupport {
        protected void someMethod(String parameter) {
            super.someMethod(parameter)
        }
    }
}
{code}

I'll update this ticket if I find anything relevant meanwhile.;;;","18/Jul/11 08:50;blackdrag;Cedric be careful and keep inner classes out of this, they may have differing semantics here and there. not that its necessarily intentional, but that would be a different bug then;;;","18/Jul/11 08:55;melix;Ok, I'll be testing both. I have a patch which solves the problem by adding package protected methods to the list of generated _super$_ methods. Doing so (and updating the modifiers test too), I can work around the stack overflow, but right now it seems to break the build (3 tests fail). I don't know if it's related to my changes or not, since I didn't do a clean build before patching, but this bug is the kind of ones which could have serious side effects.

I'll tell you as I advance, I'll have 2 hours of train where I'll be able to play around ;);;;","18/Jul/11 09:01;blackdrag;most probably this is the right way to solve the issue. it would be good to (a) attach the not yet complete patch here and (b) to show what 3 tests fail. Normally I wouldn't be pressing, but we intend to release tomorrow and I would like this issue here to be solved till then ;);;;","18/Jul/11 09:07;melix;Here is the patch and the test case results. I won't be able to deliver a full fix until tomorrow because I won't be home, so feel free to complete.

Sorry I can't give you more information, I have to take my train now :);;;","18/Jul/11 11:56;melix;The following patch (new) passes all tests on trunk. Basically, I moved my ""Child"" test class to its own file and made ""shouldNotCompile"" in GenericsTestBase protected. However, at first glance, it should have worked even without the latter modification. I would be great if Hamlet could test it.;;;","18/Jul/11 17:43;blackdrag;I modified your test Cedric to test for private directly instead of excluding others. That did let the tests pass. So I am closing the issue for now;;;","19/Jul/11 01:42;hamletdrc;I still have this error when using 1.8.x branch and the trunk. ;;;","19/Jul/11 04:32;melix;The fix requires that you recompile the child class. Did you do so ? If yes then it is probably a separate bug and it would help if you could update the unit test to highlight your use case.;;;","19/Jul/11 05:02;hamletdrc;here is a patch showing that this still fails. You probably fixed it for protected methods but not for package-private methods. ;;;","19/Jul/11 05:18;blackdrag;I think I am missing information here. The test I added uses a package private method in the java super class. In the test the child class uses a protected method to overwrite this. In the patch from Hamlet it is a public method. Oh I see the test case is not ending with Test, so maybe it is not picked up.;;;","19/Jul/11 06:42;guillaume;oops (closed wrong issue), so reopen;;;","19/Jul/11 07:35;blackdrag;ok, seems not to be the issue.;;;","19/Jul/11 09:01;blackdrag;the example from the list is causing an illegal access error in 1.7.11, since the class is package private. Same for trunk;;;","19/Jul/11 09:04;blackdrag;and any version since 1.5.1 I tested has the same problem;;;","19/Jul/11 09:05;melix;Yes there are two separate problems in the latest patch from Hamlet :
# the field ""value"" in the parent class is package protected and not recognized in the subclass
# it throws a StackOverflowError while my example does not

While I'm still scratching my head wondering why his example throws the error and not mine, I think the 1st one should be considered as a separate bug.;;;","19/Jul/11 09:13;blackdrag;I just tried it with the precompilation as suggested and this does indeed reproduce the issue... only 1.7.0 has exactly the same problem. And even 1.5.1 has this problem. So we are far away from a regression;;;","19/Jul/11 09:30;hamletdrc;When CodeNarc users run CodeNarc with 1.7, they never receive a stack overflow exception. When they run it with CodeNarc 1.8 they do. While this specific scenario in the use case may not be a regression, there is something in Groovy 1.8 that causes this. For instance, if Groovy provides a Java class called ""ClassCodeVisitorSupport"" and the visibility modifier of a method was changed from protected to package-visibile (which should be a non-breaking change), then there is a chance that this is introduced, correct? There is definitely a regression somewhere. If we don't fix this ticket, then I will start looking for changed visibility modifiers that need to be reverted... because from a user perspective there are stackoverflow errors in 1.8 that are not in 1.7. ;;;","19/Jul/11 11:04;blackdrag;changing from protected to package-private is a breaking change in Java. A subclass in a different package can see protected methods, but not package-private methods. The problem is that I don't have a test case. The one from here is not exhibiting the special problem, the zip from the list also not. Without test case I cannot reproduce the issue. Since it seems that you can reproduce the issue, I guess bisecting is the one way to identify the commit that introduced that. You can of course also look for changed modifiers. In any case we will then have to discuss why this is a problem.


It is too bad that the stackoverflow example you gave is not so easy to debug here

;;;","19/Jul/11 12:06;hamletdrc;what is wrong with the failing test case I attached? that reproduces the error every time for me?;;;","19/Jul/11 15:14;melix;Hamlet,

Yes, I can reproduce the error with your test case. I think what Jochen says is that this test does not correspond to the error you initially reported which is related to the ClassCodeVisitorSupport. There are two things mixed up here (well, I could identify more) : the regression which was introduced somewhere in ClassCodeVisitorSupport or any other class, and the bug which reproduces the StackOverflowError here, but which is not a regression as it could be identified in every version of Groovy tested so far.

Here's the result of my late investigations :

* the initial patch works if the superclass is public and a method is package private and the child class is defined in its own file (bug #1, fixed)
* if you remove the ""public"" modifier from the superclass definition, it fails with ""class groovy.bugs.Groovy4922BugChild cannot access its superclass groovy.bugs.Groovy4922BugSupport"" (bug #2, not fixed)
* if you remove the ""protected"" modifier on the ""value"" property of the superclass, it fails with ""groovy.lang.MissingPropertyException: No such property: support for class: groovy.bugs.Groovy4922BugChild"" (bug #3, not fixed but less critical)
* if you define the child class directly in the test case, like you did Hamlet, instead of in the ""assertScript"" section, it fails with a StackOverflowError (bug #4)

So, I would say your initial error is bug #5, which *could* be a modifier changed somewhere in the ClassCodeVisitorSupport class or its hierarchy between 1.7 and 1.8.

There's still some work to fully understand what's going on there :p;;;","19/Jul/11 16:03;hamletdrc;Bug #4 - This is the most direct representation of the CodeNarc code that is seeing the regression. i suggest focusing on this use case. 

Bug #5 - ""CodeNarc use case"" - CodeNarc subclasses ClassCodeVisitorSupport, and the overflow comes out of the overridden ""void visitDeclarationExpression(DeclarationExpression expression)"". This method is overridden in CCVS in 1.7 but not in 1.8. The method isn't on the class in 1.7, it is higher up in the hierarchy, but it is on the class in 1.8. Perhaps this is causing the issue, in which case the method should be added back on. 

Regarding whether this is a regression or not... No CodeNarc users see a StackOverflowError using 1.7 and almost all users see it with 1.8. If we're finding defects that are present in 1.7 and earlier then those are nice to fix, but not the root cause of the CodeNarc exceptions. ;;;","19/Jul/11 17:07;blackdrag;to clarify things... the method is not overriden in ClassCodeVisitorSupport in 1.7, but is in 1.8 and 1.9. The method is also overridden in CodeVisitorSupport, the first place in 1.7 and the second case in 1.8/1.9, the class is higher up in the hierarchy.

The CodeNarc problem is then fully unrelated to modifiers, since the method is public only. 

The next step would be to reproduce the issue using overridden public methods only. And that is a setup that does not exist as of yet.;;;","20/Jul/11 17:53;blackdrag;since the CodeNarc problem seems to be a different one than the one here I created GROOVY-4936. If GROOVY-4936 is fixed we can test if this issue is resolved as well - by chance.;;;","21/Jul/11 05:02;blackdrag;GROOVY-4936 is now fixed, it would be good to know if that fixed the original issue here as well. ;;;","21/Jul/11 05:41;hamletdrc;I retested the scenario in the .zip file that I uploaded, and that is fixed. 
However, I retested against CodeNarc and that is not fixed. 
I will try to make a new small, self-executing example that shows the problem. ;;;","21/Jul/11 06:06;blackdrag;I was afraid that may be the case, that's why I made the other issue;;;","21/Jul/11 06:06;hamletdrc;I attached a new self executing stack overflow example. 
This shows it broken when using the ast visitors. ;;;","21/Jul/11 06:12;blackdrag;Isn't example the same as before?;;;","21/Jul/11 06:24;hamletdrc;It is slightly different and the example extends ClassCodeVisitorSupport the way our production code does. ;;;","21/Jul/11 07:18;blackdrag;still, when I execute your ""run.sh"" it works here with trunk and 1.8;;;","21/Jul/11 08:39;hamletdrc;Does your command line environment call the Groovy 1.7 groovyc? 
If you have Groovy 1.8 in your path then the sample runs fine. 
You need to make sure that groovyc dispatches to the 1.7 version. ;;;","21/Jul/11 10:00;blackdrag;compiled with 1.7.11 and run with 1.8.1 works fine;;;","21/Jul/11 10:06;blackdrag;compiled with 1.7.8 and run with 1.8.1 does not work, but run with 1.7.8 does also not;;;","21/Jul/11 10:16;blackdrag;comparing the bytecode generated by 1.8.1 and 1.7.8 I can see that it simply cannot work. there is a method{code:Java}  public super$2$someMethod(Ljava/lang/String;)V
    ALOAD 0
    ALOAD 1
    INVOKESPECIAL Parent.someMethod (Ljava/lang/String;)V
    RETURN
    MAXSTACK = 2
    MAXLOCALS = 2
{code}needed to call the super method, which in 1.7.8 does simply not exist. That is also the reason why compiled with 1.7.8 and run with 1.7.8 cannot work as well. 1.7.11 fixes the problem as does 1.8.1. But there is no chance that code compiled with 1.7.8 will ever run correctly like this. And there is nothing we can fix, since the support method needed for this is missing.;;;","21/Jul/11 10:19;blackdrag;for CodeNarc you could look at the bytecode of the class containing the super method call. Does it have a method like above? ;;;","21/Jul/11 10:21;hamletdrc;Here is the ""new"" stack overflow example. You and I are clearly working from different examples. ;;;","21/Jul/11 10:30;hamletdrc;Jochen, concerning the super method in CodeNarc. 

In CodeNarc, the stack overflow comes from: 

{code}
public void visitDeclarationExpression(DeclarationExpression expression)
{code}
The super implementation is in CodeVisitorSupport. This method was present in 1.7 and 1.8. 

;;;","21/Jul/11 10:50;blackdrag;ok, the important difference between 1.7 and 1.8/1.9 is in 1.7 we have {code:Java}  public super$2$visitDeclarationExpression(Lorg/codehaus/groovy/ast/expr/DeclarationExpression;)V
    ALOAD 0
    ALOAD 1
    INVOKESPECIAL org/codehaus/groovy/ast/CodeVisitorSupport.visitDeclarationExpression (Lorg/codehaus/groovy/ast/expr/DeclarationExpression;)V
    RETURN
    MAXSTACK = 2
    MAXLOCALS = 2{code} and in 1.8 we have{code:Java}  public super$3$visitDeclarationExpression(Lorg/codehaus/groovy/ast/expr/DeclarationExpression;)V
    ALOAD 0
    ALOAD 1
    INVOKESPECIAL org/codehaus/groovy/ast/ClassCodeVisitorSupport.visitDeclarationExpression (Lorg/codehaus/groovy/ast/expr/DeclarationExpression;)V
    RETURN
    MAXSTACK = 2
    MAXLOCALS = 2{code}
As can be clearly see there is a difference in what class is called as well as what number is used;;;","21/Jul/11 10:56;blackdrag;From the trace I can tell the 1.7 method is not called. I assume the runtime looks only for the exact match, which for 1.8 is super$3 and not super$2, thus not finding the method and then placing the normal method for the call to super, when it should have caused an exception instead;;;","13/Feb/12 06:20;blackdrag;If my assumption with the fall back is right, then GROOVY-5285 is caused by the exact same logic;;;","14/Feb/12 08:29;melix;GROOVY-5285 is unrelated. Another stack overflow :);;;","14/Feb/12 12:28;melix;Fixed by testing if other MOP methods exist with the same name but with a lower index.;;;"
Default values for primitives error in groovy 1.8.0,GROOVY-4920,12815785,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,shogusumi,shogusumi,11/Jul/11 12:13,15/Jul/11 11:47,14/Jul/23 06:00,15/Jul/11 11:47,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,primtive opts,,,,0,,,,,,"In Groovy 1.8.0, this works fine:
{noformat}
groovy:000>  int x; println x
0
===>  null
{noformat}

Whereas this blows up:

{noformat}
groovy:000>  int x; 1.times { println x }
ERROR org.codehaus.groovy.runtime.typehandling.GroovyCastException:
Cannot cast object 'null' with class 'null' to class 'int'. Try
'java.lang.Integer' instead
        at groovysh_evaluate.run (groovysh_evaluate:2)
        ...
{noformat}
Is that a known issue?

bug and not known, because new in 1.8. Please fill a bug report for this

bye blackdrag",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 15 11:47:01 UTC 2011,,,,,,,,,,"0|i2bwu7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Jul/11 11:47;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Categories sometimes not applied,GROOVY-4919,12818094,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,johann,johann,11/Jul/11 12:04,16/Nov/14 07:23,14/Jul/23 06:00,16/Nov/14 07:23,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,groovy-jdk,,,,0,1.8,category,use,usertask,,"Since upgrading http://media.io to Groovy 1.8.0, I very rarely get these exceptions:

{code}

groovy.lang.MissingMethodException: No signature of method: java.lang.String.shaHex() is applicable for argument types: () values: []
Possible solutions: size(), charAt(int), isCase(java.lang.Object), isCase(java.lang.Object), sleep(long), sleep(long, groovy.lang.Closure)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:55)
	at org.codehaus.groovy.runtime.callsite.PojoMetaClassSite.call(PojoMetaClassSite.java:46)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at media.entities.Info$_getCleanName_closure1.doCall(Info.groovy:87)
{code}

The code in Info.groovy uses categories together with commons-codec and looks like this:

{code}
@EqualsAndHashCode(excludes = 'size,outputName,outputSize,format,progress,downloaded,tags')
class Info implements Serializable {
    
    private static final long serialVersionUID = 3L
    
    String name
...
    String getCleanName(String extension) {
        use (DigestUtils) { extension ? new StringBuilder(49).append(name.shaHex()).append('.').append(extension) : name.shaHex() }
    }
    
}
{code}

My guess is that this happens less frequently than every 50000 calls so it's hard for me to reproduce.

Any ideas? Could this be a thread-safety thing?

",Debian Lenny Linux,johann,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 16 07:23:57 UTC 2014,,,,,,,,,,"0|i2c3rb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jul/11 13:08;guillaume;Even if hard to reproduce, could you still try to make an easily reproducable sample?;;;","12/Jul/11 13:27;johann;Sure. Try this:

{code}
@Grab('commons-codec:commons-codec:1.5')
import org.apache.commons.codec.digest.*

println use (DigestUtils) { 'bla'.shaHex() }

@Grab('org.codehaus.gpars:gpars:0.12')
import groovyx.gpars.GParsPool


GParsPool.withPool(10, {
 (1..1000000).each {
  Closure category = { use (DigestUtils) { 'bla'.shaHex() } }
  Closure asyncCategory = category.async()
  asyncCategory()
 }
})
{code}

I tried running it on this little netbook here but it crashed it. Maybe you have some cycles you can donate?

Looking at the stacktrace now...

{code}
	at org.codehaus.groovy.runtime.callsite.PojoMetaClassSite.call(PojoMetaClassSite.java:46)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at media.entities.Info$_getCleanName_closure1.doCall(Info.groovy:87)
{code}

Why is it a {{PojoMetaClassSite}}? Shouldn't using categories change the call site?;;;","12/Jul/11 23:43;paulk;At 1000000 it was taking way too long. Set it to 10000 and it has ran fine several times so far. From what you know, is every statement inside the loop important? I.e. do you know whether it is just calling the closure which is important or the ""use"" statement which tends to cause problems.;;;","13/Jul/11 00:05;johann;I think it's only the use block. As you can see in the code, the use block is the only thing in the {{getCleanName}} method.;;;","19/Jul/11 03:08;johann;Another one that might or might not be related to this one:

{code}
groovy.lang.MissingMethodException: No signature of method: static java.util.regex.Pattern.isCase() is applicable for argument types: (java.util.regex.Pattern) values: [(?i)	artist=(.*)]
Possible solutions: isCase(java.lang.Object), isCase(java.lang.Object), use([Ljava.lang.Object;), asType(java.lang.Class), is(java.lang.Object)
	at groovy.lang.MetaClassImpl.invokeStaticMissingMethod(MetaClassImpl.java:1354)
	at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1340)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:767)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodN(ScriptBytecodeAdapter.java:164)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.isCase(ScriptBytecodeAdapter.java:667)
	at media.parser.OutputParser.callClosureIfMatch(OutputParser.groovy:127)
{code}

Source code:

{code}
    boolean callClosureIfMatch(String line, def prefix, Closure closure, Info info) {
        if (prefix in Pattern) {
            Matcher m = prefix.matcher(line)
            if (m.find()) {
                addFormatAndTagsIfNecessary(info)
                closure(m)
                return true
            }
        }
{code}

Just happened for the first time. Never seen this before even though the code in question has probably seen more than 250000 invocations.;;;","16/Nov/14 04:05;pschumacher;Does this issue still occur with recent versions of groovy?;;;","16/Nov/14 06:52;johann;Haven't seen this again, so I would say this can be closed.;;;","16/Nov/14 07:23;pschumacher;Thanks for the feedback. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GetEffectivePojoPropertySite#acceptGetProperty may produce a NullPointerException when provided with a null 'receiver' object,GROOVY-4918,12815723,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,noamt,noamt,11/Jul/11 07:38,23/Feb/15 01:12,14/Jul/23 06:00,21/Jan/15 08:10,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.1,,,groovy-runtime,,,,2,exception,,,,,"When given a null {{receiver}} object, line 51 of {{org.codehaus.groovy.runtime.callsite.GetEffectivePojoPropertySite}} may produce a {{NullPointerException}} when trying to invoke {{java.lang.Object#getClass}}.
It seems that the commented-out if statement on line 50 handles this case by checking the {{receiver}} object with {{instanceof}}.
Although if fixed, a {{NullPointerException}} will eventually be thrown by the {{NullCallSite}} object when trying to access a property of the null object, the exception thrown by {{NullCallSite}} is much more descriptive.",,blackdrag,candrews,gonzo125,jkemnade,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Jan/15 09:51;jkemnade;groovy-4918.zip;https://issues.apache.org/jira/secure/attachment/12723070/groovy-4918.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 21 09:07:35 UTC 2015,,,,,,,,,,"0|i2buqf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jul/11 09:52;blackdrag;if I remember right, then this Site is not used for null values at all - thus no null check needed. Do you have an groovy code example producing this?;;;","11/Jul/11 10:23;noamt;It's part of a pretty large framework, but I'll try to extract and isolate an example.
In any case, the main gist of the scenario is:

A Groovy script invokes a method in a Java class which potentially returns a null object and then calls a getter method on this object; when this object is null, the following exception is thrown:

{code}
Caused by: java.lang.NullPointerException: null
	at org.codehaus.groovy.runtime.callsite.GetEffectivePojoPropertySite.acceptGetProperty(GetEffectivePojoPropertySite.java:51) [groovy-1.8.0.jar:1.8.0]
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGetProperty(AbstractCallSite.java:227) [groovy-1.8.0.jar:1.8.0]
	at datastoreCleanup$_run_closure1_closure2.doCall(datastoreCleanup.groovy:29) [na:na]
	at sun.reflect.GeneratedMethodAccessor89.invoke(Unknown Source) [na:na]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) [na:1.6.0_23]
	at java.lang.reflect.Method.invoke(Method.java:597) [na:1.6.0_23]
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90) [groovy-1.8.0.jar:1.8.0]
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233) [groovy-1.8.0.jar:1.8.0]
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272) [groovy-1.8.0.jar:1.8.0]
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885) [groovy-1.8.0.jar:1.8.0]
	at groovy.lang.Closure.call(Closure.java:405) [groovy-1.8.0.jar:1.8.0]
	at org.codehaus.groovy.runtime.ConvertedClosure.invokeCustom(ConvertedClosure.java:51) [groovy-1.8.0.jar:1.8.0]
	at org.codehaus.groovy.runtime.ConversionHandler.invoke(ConversionHandler.java:82) [groovy-1.8.0.jar:1.8.0]
	at $Proxy151.beforeDownload(Unknown Source) [na:na]
	... 60 common frames omitted
{code};;;","11/Jul/11 10:29;blackdrag;ah, ok, the trace proofes that it is happening, so yes, that is something we should fix.;;;","07/Aug/14 03:08;gonzo125;{code}
java.lang.NullPointerException
	at org.codehaus.groovy.runtime.callsite.GetEffectivePojoPropertySite.acceptGetProperty(GetEffectivePojoPropertySite.java:51)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGetProperty(AbstractCallSite.java:227)
	at groovy.tmp.templates.GStringTemplateScript8$_getTemplate_closure1.doCall(GStringTemplateScript8.groovy:17)
	at sun.reflect.GeneratedMethodAccessor3186.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:909)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure$WritableClosure.writeTo(Closure.java:853)
	at groovy.lang.Closure$WritableClosure.toString(Closure.java:979)
	at sun.reflect.GeneratedMethodAccessor3158.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:272)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:64)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	ommited frames
{code}

my line of code causing it is simply:
{code}
return template.make(binding).toString();
{code}
where template is groovy template created by GStringTemplateEngine;;;","07/Aug/14 07:53;blackdrag;but it is not that line directly that is causing it. It is from inside the template. Do you have a template to reproduce this as well?;;;","07/Aug/14 08:34;gonzo125;yes, i know it was from template. unfortunately error occured on our client's server, and I was unable to reproduce it locally (even when I fed this template with identical data)

template:
{code}
<CustomerModRq requestID=""${requestId}"">
    <CustomerMod>
        <ListID>${aliasFormatter.format(entity)}</ListID>
        <EditSequence>${editSequence}</EditSequence>
        <Name >${f.esc(entity.name,41)}</Name>
        <IsActive >1</IsActive>
        <CompanyName>${f.esc(entity.fullname,41)}</CompanyName>
        <BillAddress>
            <Addr1 >${f.esc(entity.address.address, 41)}</Addr1>
            <Addr2 >${f.esc(entity.address.address, 41, 41)}</Addr2>
            <Addr3 >${f.esc(entity.address.address, 41, 82)}</Addr3>
            <Addr4 >${f.esc(entity.address.address, 41, 123)}</Addr4>
            <Addr5 >${f.esc(entity.address.address, 41, 164)}</Addr5>
            <City >${f.esc(entity.address.city, 31)}</City>
            <PostalCode >${f.esc(entity.address.zipCode, 13)}</PostalCode>
            <Country >${f.esc(entity.address.country.name, 31)}</Country>
        </BillAddress>
        <ShipAddress>
            <Addr1 >${f.esc(entity.address.address, 41)}</Addr1>
            <Addr2 >${f.esc(entity.address.address, 41, 41)}</Addr2>
            <Addr3 >${f.esc(entity.address.address, 41, 82)}</Addr3>
            <Addr4 >${f.esc(entity.address.address, 41, 123)}</Addr4>
            <Addr5 >${f.esc(entity.address.address, 41, 164)}</Addr5>
            <City >${f.esc(entity.address.city, 31)}</City>
            <PostalCode >${f.esc(entity.address.zipCode, 13)}</PostalCode>
            <Country >${f.esc(entity.address.country.name, 31)}</Country>
        </ShipAddress>
        <Phone >${f.esc(entity.phone, 21)}</Phone>
        <Email >${f.esc(entity.email, 1023)}</Email>
    </CustomerMod>
</CustomerModRq>
{code}

Edit: One thing I didnt mention before: most probably this template was fed with hibernate proxy. Maybe that was the case..;;;","20/Jan/15 03:25;jkemnade;I'm getting a similar error with 2.3.8 in {{org.codehaus.groovy.runtime.callsite.PogoGetPropertySite.acceptGetProperty(Object)}}, which also tries to call {{getClass()}} on {{null}}.;;;","20/Jan/15 03:45;blackdrag;can you give a small example producing the problem?;;;","20/Jan/15 03:58;jkemnade;I'm struggling to reproduce the issue in a mimimal example. I get this issue in a slightly complex setup involving metaclasses, categories, builders and tons of libaries. I'll let you know when I manage.;;;","20/Jan/15 07:54;jkemnade;No luck yet. I can create a NullPointerException which I guess is related by running this script:
{code}
class MyMap extends GroovyObjectSupport {
  
  MyMap(Map m){
    this.m = m
  }
  
  Map m
  
  public Object getProperty(String property) {
    println ""m: get $property from $m""
    if (m.containsKey(property)){
      def val = m.get(property)
      println ""m: $val, ${val.getClass()}""
      
      if (val instanceof Map){
        return new MyMap(val)
      }
      else {
        return val
      }
    }
    println ""m: null""
    return null
  }
  
}

def l = [ new MyMap([b:[c:'foo']]), new MyMap([:]) ] 

l.each{a->
  println a.b.c
}
{code}

But I haven't yet figured out how to recreate the specific stacktrace that I get with the original setup:
{code}
java.lang.NullPointerException
	at org.codehaus.groovy.runtime.callsite.PogoGetPropertySite.acceptGetProperty(PogoGetPropertySite.java:32)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGetProperty(AbstractCallSite.java:227)
	at Script9$_run_closure1.doCall(Script9.groovy:6)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:324)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:278)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1016)
	at groovy.lang.Closure.call(Closure.java:423)
	at groovy.lang.Closure.call(Closure.java:439)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1379)
...
{code}
It seems to happen when calling a closure. I wonder how to make Groovy take the path via {{CachedMethod}}. ;;;","20/Jan/15 09:51;jkemnade;Got it, just run {{./gradlew run}} in the project.;;;","21/Jan/15 02:02;jkemnade;2.4.0-rc-2 is affected too. Unfortunately, I cannot update the issue's field.;;;","21/Jan/15 06:38;blackdrag;I changed this to ""Improvement"" since this is no bug ;);;;","21/Jan/15 06:49;jkemnade;It isn't? I'm curious. Could you please explain what's leading to the NPE in my example project? I assume that Groovy somehow remembers the type of property 'b' of the first list entry and that it assumes that property 'b' of the second list entry returns the same type. But I may be completely wrong.
Also, if this behavior is expected, then how am I supposed to prevent that NPE? Should I always return {{org.codehaus.groovy.runtime.NullObject.getNullObject()}} in POGOs where I would usually return {{null}} and always check for {{null}} and {{org.codehaus.groovy.runtime.NullObject.getNullObject()}} where I would usually only check for {{null}}?;;;","21/Jan/15 07:32;blackdrag;Maybe a misunderstanding.. I am saying that throwing an NPE in this code is not bug, because new MyMap([:]).b.c will cause it being thrown, since there is no b in the underlaying map. So a NPE is the right thing here. 

I marked it as improvement, since it is only the text of the NPE that requires a change. What we want is not the standard NPE from Java, but the one we generate for access on NullObject. And for this I will make a change;;;","21/Jan/15 07:52;blackdrag;just noticed, I made a mistake, I used a slightly modified program, because I thought I found something I can actually use a black box test, but it turns out I improved a different part of the code. The code here really is a bug, because  even if throwing the NPE is the correct thing, not trying NullObject is not, since in theory you can add a property to it;;;","21/Jan/15 08:10;blackdrag;should be fixed now;;;","21/Jan/15 08:15;jkemnade;Actually I thought the bug was that the {{new MyMap([:]).b.c}} went though {{PogoGetPropertySite}} instead of {{NullCallSite}}. But I guess my understanding of Groovy's internals is still pretty limited in that regard. Looking forward to seeing how you're going to fix this.;;;","21/Jan/15 09:00;blackdrag;Don't worry, you have been right, I am a bit distracted these days, so I did interpret some thing wrong. that getClass() call should not happen on null and going through NullObject/NullCallSite is the right thing to do. See https://github.com/groovy/groovy-core/commit/26488caf898b34537e395a2531470d44176d3c50;;;","21/Jan/15 09:07;jkemnade;Alright, maybe I should have described things more clearly. Anyway, thanks for the fix and the explanations!;;;",,,,,,,,,,,,,,,,,,,,,,,,,
Set equality fails if null elements are present,GROOVY-4916,12815749,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,rconner,rconner,08/Jul/11 12:32,21/Jul/11 19:06,14/Jul/23 06:00,09/Jul/11 06:29,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,,,,,0,,,,,,"The following assertions work as expected in groovy 1.7.10, but fail in groovy 1.8.0

First case:
{code}
def foo = [ ""a"", null ] as Set
assert foo.equals( foo )
{code}

Second case:
{code}
def foo = [ ""a"", null ] as Set
def bar = [ ""a"", null ] as Set
assert foo == bar
assert foo.equals( bar )
{code}

foo == foo happens to work, which leads me to believe that == tests for object identity first.

I can workaround by testing Set equality using brute force, but it's very surprising.
","java version ""1.6.0_24""
Java(TM) SE Runtime Environment (build 1.6.0_24-b07)
Java HotSpot(TM) 64-Bit Server VM (build 19.1-b02, mixed mode)
Ubuntu 10.04",paulk,rconner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 09 06:29:41 UTC 2011,,,,,,,,,,"0|i2cldj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Jul/11 23:11;paulk;add code tags, move environment info;;;","09/Jul/11 06:29;paulk;There was/is no special Set equals handling in Groovy 1.7, so it just gets the default Java equals (which happens to be {{AbstractSet#equals}} which works in your case but wouldn't work in other places where Groovy coerces values from related types, e.g. if you had 3 and 3.0 in two sets). Groovy 1.8.0 had special equals handling but it was broken for sets containing null. It has been fixed now. Thanks for filing the report.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong access modifiers in JsonSlurper,GROOVY-4915,12815741,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,axel.fontaine,axel.fontaine,07/Jul/11 07:25,21/Jul/11 19:06,14/Jul/23 06:00,11/Jul/11 03:52,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,1.9-beta-1,,JSON,,,,0,,,,,,"JsonSlurper.java has parseText() and parse() with package-private instead of public visibility.

IntelliJ rightfully reports a warning when trying to use them.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 11 03:52:51 UTC 2011,,,,,,,,,,"0|i2ctyv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jul/11 03:52;guillaume;Already fixed in 1.8.1 and 1.9-beta-1 (not released yet).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FieldNode doesn't collect annotations,GROOVY-4914,12815765,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mojojojo,mojojojo,06/Jul/11 13:29,21/Jul/11 19:06,14/Jul/23 06:00,07/Jul/11 19:27,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,,,,,0,,,,,,"It's in the test case:
{code}
import org.codehaus.groovy.ast.ClassNode
import java.lang.annotation.RetentionPolicy
import java.lang.annotation.Retention


@Retention(RetentionPolicy.RUNTIME)
@interface Annotation1 {}

@Annotation1 class A {
    @Annotation1 def field1    
}


new ClassNode(A).with {
    assert annotations: ""ClassNode for class 'A' has an annotation as it should""
    getField('field1').with {
        assert !annotations: ""Because of a bug FieldNode for field 'field1' doesn't have annotations""
    }
}
{code}",,mojojojo,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 07 19:27:23 UTC 2011,,,,,,,,,,"0|i2co3z:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"06/Jul/11 15:56;paulk;There are potentially two parts to this issue:
* placement of annotation on a field (changing def to public) illustrates that this doesn't work
* where to place annotations during creation of a property, on getter, setter and private field?;;;","07/Jul/11 19:27;paulk;Some annotation metadata configuration wasn't being set - should be fixed now - thanks for spotting the problem.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.bat fails when the JAVA_OPTS contains space characters,GROOVY-4910,12814465,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,nagai_masato,nagai_masato,02/Jul/11 06:04,09/Apr/15 13:42,14/Jul/23 06:00,26/Jul/11 23:44,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,command line processing,,,,1,,,,,,"groovy.bat fails when the JAVA_OPTS environment variable contains space characters like the following:

> set JAVA_OPTS=-Daprop=""a value""
> bin\groovy -h
value"""" was unexpected at this time.",,dmurat,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7378,,,,,,,,,,,,,,,"02/Jul/11 06:04;nagai_masato;patch;https://issues.apache.org/jira/secure/attachment/12722950/patch","03/Jul/11 08:01;nagai_masato;test.groovy4910.bat;https://issues.apache.org/jira/secure/attachment/12722865/test.groovy4910.bat",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Tue Jul 26 23:44:47 UTC 2011,,,,,,,,,,"0|i2ckkf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jul/11 08:22;nagai_masato;>contains space characters 
contains double quoted strings have space characters;;;","02/Jul/11 11:23;nagai_masato;When JAVA_OPTS is -Daprop=""a value"", ""%JAVA_OPTS"" means ""-Daprop=""a value"""".
So the following part of startGroovy.bat (line 223) throws the error.

if ""%JAVA_OPTS%"" == """" set JAVA_OPTS=""-Xmx128m""

The patch changes startGroovy.bat to use GROOVY_OPTS local variable for local options instead of JAVA_OPTS that is commonly used by other programs. ;;;","03/Jul/11 08:01;nagai_masato;I also attached a small test program.
By the way, is there nobody can verify this issue?;;;","23/Jul/11 14:52;blackdrag;Paul, can you check this?;;;","26/Jul/11 23:44;paulk;patch applied, thanks;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
insufficient compiler error messages relating to interface member visibility,GROOVY-4909,12818406,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,01/Jul/11 18:16,22/May/22 16:05,14/Jul/23 06:00,02/Jul/11 01:00,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,,,,,0,ClassFormatError,,,,,"The following interface illustrates two problems:
{code}
interface Foo {
  private static BAR = 3 // => java.lang.ClassFormatError: Illegal field modifiers in class Foo: 0x1A
  protected foo() // => java.lang.ClassFormatError: Method foo in class Foo has illegal modifiers: 0x404
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-07-01 18:16:38.0,,,,,,,,,,"0|i2btmn:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Command line interface of AstNodeToScriptAdapter.groovy don't works,GROOVY-4907,12816763,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,uehaj,uehaj,30/Jun/11 03:12,05/Apr/15 14:43,14/Jul/23 06:00,30/Jun/11 08:27,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,,,,,0,,,,,,"I tried AstNodeToScriptAdapter#main() but get 
{code}
$ groovy -e 'groovy.inspect.swingui.AstNodeToScriptAdapter.main(args)' a.groovy  1
Caught: groovy.lang.MissingMethodException: No signature of method: static org.codehaus.groovy.control.CompilePhase.fromPhaseNumber() is applicable for argument types: (java.lang.String) values: [1]
Possible solutions: fromPhaseNumber(int), getPhaseNumber()
	at groovy.inspect.swingui.AstNodeToScriptAdapter.main(AstNodeToScriptAdapter.groovy:56)
	at script_from_command_line.run(script_from_command_line:1)
{code}
follwing is a patch:
{code}
$ svn diff AstNodeToScriptAdapter.groovy
Index: AstNodeToScriptAdapter.groovy
===================================================================
--- AstNodeToScriptAdapter.groovy	(revision 22473)
+++ AstNodeToScriptAdapter.groovy	(working copy)
@@ -52,7 +52,7 @@
 and [compilephase] is a valid Integer based org.codehaus.groovy.control.CompilePhase""""""
         } else {
             def file = new File((String) args[0])
-            def phase = CompilePhase.fromPhaseNumber(args[1])
+            def phase = CompilePhase.fromPhaseNumber(args[1] as int)
             if (!file.exists()) {
                 println ""File ${args[0]} cannot be found.""
             } else if (phase == null) {
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Thu Jun 30 08:27:25 UTC 2011,,,,,,,,,,"0|i2ciuf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Jun/11 08:27;paulk;Patch applied, thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StackOverflowError when parsing JSON text with JsonSlurper().parseText(),GROOVY-4903,12818409,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,genie,genie,26/Jun/11 13:22,30/Jun/12 19:00,14/Jul/23 06:00,20/Jul/11 15:45,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,1.9-beta-1,,JSON,,,,1,,,,,,"The following code throws java.lang.StackOverflowError

{code}
def jsonData = '{""messageId"":1008,""messages"":[{""id"":""1005"",""urgency"":""info"",""senderName"":""Evgeny Goldin"",""date"":""Saturday, June 25, 2011"",""time"":""09:08"",""text"":""aaaaaaaaaaa"",""sender"":""evgenyg"",""timestamp"":""1309003733376"",""longevity"":168,""sendToAll"":true,""sendToGroups"":[],""sendToUsers"":[],""usersDeleted"":[""evgenyg""]},{""id"":""1006"",""urgency"":""critical"",""senderName"":""Evgeny Goldin"",""date"":""Saturday, June 25, 2011"",""time"":""09:11"",""text"":""eeeeeeeeeeee"",""sender"":""evgenyg"",""timestamp"":""1309003888160"",""longevity"":168,""sendToAll"":true,""sendToGroups"":[],""sendToUsers"":[],""usersDeleted"":[""evgenyg""]},{""id"":""1007"",""urgency"":""warning"",""senderName"":""Evgeny Goldin"",""date"":""Saturday, June 25, 2011"",""time"":""09:14"",""text"":""<p>Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo. Quisque sit amet est et sapien ullamcorper pharetra. Vestibulum erat wisi, condimentum sed, commodo vitae, ornare sit amet, wisi. Aenean fermentum, elit eget tincidunt condimentum, eros ipsum rutrum orci, sagittis tempus lacus enim ac dui. Donec non enim in turpis pulvinar facilisis. Ut felis. Praesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat. Aliquam erat volutpat. Nam dui mi, tincidunt quis, accumsan porttitor, facilisis luctus, metus</p>"",""sender"":""evgenyg"",""timestamp"":""1309004072795"",""longevity"":168,""sendToAll"":true,""sendToGroups"":[],""sendToUsers"":[],""usersDeleted"":[""evgenyg""]},{""id"":""1008"",""urgency"":""warning"",""senderName"":""Evgeny Goldin"",""date"":""Saturday, June 25, 2011"",""time"":""09:16"",""text"":""<p>Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo. Quisque sit amet est et sapien ullamcorper pharetra. Vestibulum erat wisi, condimentum sed, commodo vitae, ornare sit amet, wisi. Aenean fermentum, elit eget tincidunt condimentum, eros ipsum rutrum orci, sagittis tempus lacus enim ac dui. Donec non enim in turpis pulvinar facilisis. Ut felis. Praesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat. Aliquam erat volutpat. Nam dui mi, tincidunt quis, accumsan porttitor, facilisis luctus, metus</p>"",""sender"":""evgenyg"",""timestamp"":""1309004197803"",""longevity"":168,""sendToAll"":true,""sendToGroups"":[],""sendToUsers"":[],""usersDeleted"":[""evgenyg""]}]}'

new groovy.json.JsonSlurper().parseText( jsonData )

{code}


{code}
Exception thrown
Jun 26, 2011 3:18:23 PM org.codehaus.groovy.runtime.StackTraceUtils sanitize

WARNING: Sanitizing stacktrace:

java.lang.StackOverflowError

	at java.util.regex.Pattern$8.isSatisfiedBy(Pattern.java:4783)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at jav
a.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern
$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)

	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)

	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)

	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)

	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)

	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)

	at java.util.re
{code}",,blendmaster,enorris,enterit,guillaume,kpshek,paul,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"26/Jun/11 13:28;messages-failed-to-load-1309112875059.json;https://issues.apache.org/jira/secure/attachment/12722892/messages-failed-to-load-1309112875059.json","19/Jul/11 09:05;kpshek;search.json;https://issues.apache.org/jira/secure/attachment/12722954/search.json",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jun 30 19:00:50 UTC 2012,,,,,,,,,,"0|i2cmtj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jun/11 13:34;genie;For some reason I was only able to reproduce it once in GroovyConsole but I attached a file which I constantly fail to read by [this code|https://github.com/evgeny-goldin/teamcity-plugins/blob/0f6ea8c0ce2887e77c2432b70115d3d5a5b8c7fa/messenger-plugin/src/main/groovy/com/goldin/plugins/teamcity/messenger/impl/MessagesPersistencyImpl.groovy#L61].;;;","26/Jun/11 15:04;blackdrag;somehow I think this is not really a Groovy bug, but a bug in the JDK. This one here: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5050507 sounds as it may be realted. In JBEHAVE-242 they have such a ""bug"" analyzed and worked around it. Maybe the same approach would work here as well. Basically we have to look for a (.|\s)* and replace it by .* - if that is the solution here as well;;;","19/Jul/11 06:48;guillaume;By the way, which version of the JDK are you using?
I tried to reproduce the problem, but it just worked for me on my Mac:
{code}
java version ""1.6.0_26""
Java(TM) SE Runtime Environment (build 1.6.0_26-b03-384-9M3425)
Java HotSpot(TM) 64-Bit Server VM (build 20.1-b02-384, mixed mode)
{code};;;","19/Jul/11 07:00;guillaume;On Google App Engine, I had this JSON payload that was problematic:
http://jfokus-schedule.appspot.com/json-backup/speakers.json
But it's working on my laptop!;;;","19/Jul/11 08:20;genie;It was 1.6.0_25, Windows x86 JDK. And I couldn't always reproduce it as well. It always failed when in application but hardly failed when in GroovyConsole.;;;","19/Jul/11 08:21;genie;If nothing helps then I can try to provide you with an application where it happened to me, it's a TeamCity plugin so you may need to install and debug it.;;;","19/Jul/11 09:05;kpshek;I'm attaching JSON that fails to be slurped on my machine.

The following snippet demonstrates the issue (I ran this in GroovyConsole):
{code}
def f = new File('search.json')
def json = new groovy.json.JsonSlurper().parseText(f.text)
{code}

The error this produces:
{noformat}
Jul 19, 2011 9:04:35 AM org.codehaus.groovy.runtime.StackTraceUtils sanitize
WARNING: Sanitizing stacktrace:
java.lang.StackOverflowError
	at java.util.regex.Pattern$CharProperty$1.isSatisfiedBy(Pattern.java:3337)
	at java.util.regex.Pattern$8.isSatisfiedBy(Pattern.java:4783)
	at java.util.regex.Pattern$CharProperty.match(Pattern.java:3345)
	at java.util.regex.Pattern$Branch.match(Pattern.java:4114)
	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4168)
	at java.util.regex.Pattern$Loop.match(Pattern.java:4295)
	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4227)
	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4078)
...this goes on for a long time
{noformat}

My machine details:
{noformat}
Mac OS X 10.6.8

java -version
java version ""1.6.0_26""
Java(TM) SE Runtime Environment (build 1.6.0_26-b03-384-10M3425)
Java HotSpot(TM) 64-Bit Server VM (build 20.1-b02-384, mixed mode)
{noformat}

edit: I should also note that I've moved off of use the classes in groovy.json.* as I cannot guarantee that any json I may receive from a web service can be parsed without error. I'm currently using [json-lib|http://json-lib.sourceforge.net/] and 'f.text as net.sf.json.JSON' which works every time.;;;","19/Jul/11 09:16;genie;Kevin's file fails for me as well.


Windows 7 x64, Groovy 1.8.0 (GroovyConsole)

{code}
java version ""1.6.0_25""
Java(TM) SE Runtime Environment (build 1.6.0_25-b06)
Java HotSpot(TM) Client VM (build 20.0-b11, mixed mode, sharing)
{code}
;;;","20/Jul/11 15:45;guillaume;I used the same approach as the issue JBehave had, by tweaking the regex and using DOTALL.

It's weird the issue is not necessarily happening on all JDKs though.;;;","12/Mar/12 18:59;enterit;I can still reproduce the issue. Please find real-world example (obfuscated unfortunately) for details:
{code}
@Grab(group='net.sf.json-lib', module='json-lib', version='2.4', classifier=""jdk15"")
import groovy.json.JsonSlurper
import net.sf.json.JSONSerializer

stackOverflowText = /{""a"":[{""a"":""{\""a\"":[],\""a\"":[],\""a\"":[{\""a\"":{\""a\"":a,\""a\"":a,\""a\"":a,\""a\"":a,\""a\"":a,\""a\"":a,\""a\"":a,\""a\"":a},\""a\"":\""a\"",\""a\"":\""a.a.a\"",\""a\"":\""a\"",\""a\"":\""a-a\"",\""a\"":\""a.a.a.a\"",\""a\"":a,\""a\"":{\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\"",\""a\"":\""a\""},\""a\"":{\""a\"":\""a\""},\""a\"":{\""a\"":\""a\""},\""a\"":{\""a\"":\""a\""},\""a\"":{\""a\"":\""a\"",\""a\"":\""a\""},\""a\"":{\""a\"":\""a\""},\""a\"":{\""a\"":\""a\"",\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\"",\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\"",\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\"",\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\"",\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\"",\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\"",\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\""},\""a-a\"":{\""a\"":\""a\"",\""a\"":\""a\""}},\""a-a\"":{},\""a\"":[[{\""a\"":\""a-a\"",\""a\"":\""a\"",\""a\"":a,\""a\"":a,\""a\"":\""a\"",\""a\"":\""a\"",\""a\"":[],\""a\"":[],\""a\"":\""a\"",\""a\"":a},{\""a\"":\""a-a\"",\""a\"":\""a\"",\""a\"":a,\""a\"":a,\""a\"":\""a\"",\""a\"":\""a\"",\""a\"":[],\""a\"":[],\""a\"":\""a\"",\""a\"":a,\""a\"":a,\""a\"":[{\""a\"":a,\""a\"":\""a\""},{\""a\"":a,\""a\"":\""a\""},{\""a\"":a,\""a\"":\""a\""}]},{\""a\"":\""a-a\"",\""a\"":\""a-a\"",\""a\"":a,\""a\"":a,\""a\"":\""a\"",\""a\"":\""a\"",\""a\"":[],\""a\"":[],\""a\"":\""a\"",\""a\"":a},{\""a\"":\""a-a\"",\""a\"":\""a-a\"",\""a\"":a,\""a\"":a,\""a\"":\""a\"",\""a\"":\""a\"",\""a\"":[],\""a\"":[],\""a\"":\""a\"",\""a\"":a},{\""a\"":\""a\"",\""a\"":\""a\"",\""a\"":a,\""a\"":a,\""a\"":\""a\"",\""a\"":\""a\"",\""a\"":[],\""a\"":[],\""a\"":\""a\"",\""a\"":a},{\""a\"":\""a\"",\""a\"":\""a\"",\""a\"":a,\""a\"":a,\""a\"":\""a\"",\""a\"":\""a\"",\""a\"":[],\""a\"":[],\""a\"":\""a\"",\""a\"":a},{\""a\"":\""a\"",\""a\"":\""a\"",\""a\"":a,\""a\"":a,\""a\"":\""a\"",\""a\"":\""a\"",\""a\"":[],\""a\"":[],\""a\"":\""a\"",\""a\"":a,\""a\"":a,\""a\"":[{\""a\"":a,\""a\"":\""a a a a\""},{\""a\"":a,\""a\"":\""a a\""},{\""a\"":a,\""a\"":\""a a a\""},{\""a\"":a,\""a\"":\""a a\""},{\""a\"":a,\""a\"":\""a a\""},{\""a\"":a,\""a\"":\""a a\""},{\""a\"":a,\""a\"":\""a\""},{\""a\"":a,\""a\"":\""a a\""},{\""a\"":a,\""a\"":\""a a\""}]},{\""a\"":\""a\"",\""a\"":\""a\"",\""a\"":a,\""a\"":a,\""a\"":\""\""}]]}]}""}]}/

println JSONSerializer.toJSON(stackOverflowText) // works properly
new JsonSlurper().parseText(stackOverflowText)   // throws StackOverflowError
{code};;;","12/Mar/12 19:01;enterit;The cause of the issue is (most of all) inefficient regexp groovy.json.JsonTokenType#STRING.
I have prepared a patch that fixed the issue. Could you please review it?

{noformat}
# HG changeset patch
# User enterit
# Date 1331596479 -7200
# Node ID 7e7048d145315b6655c4182603512df7da5b6edb
# Parent  3115bbd523ce0666f0f847def744229d6ef9cc5e
JsonSlurper: fixed StackOverflowError that happened during parsing of long strings with backslashes.

diff -r 3115bbd523ce -r 7e7048d14531 src/main/groovy/json/JsonTokenType.java
--- a/src/main/groovy/json/JsonTokenType.java	Tue Mar 13 01:46:45 2012 +0200
+++ b/src/main/groovy/json/JsonTokenType.java	Tue Mar 13 01:54:39 2012 +0200
@@ -15,6 +15,8 @@
  */
 package groovy.json;
 
+import groovy.lang.Closure;
+
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -35,7 +37,19 @@
     TRUE            ( ""the constant 'true'"",                ""true""      ),
     FALSE           ( ""the constant 'false'"",               ""false""     ),
     NUMBER          ( ""a number"",                           Pattern.compile(""-?\\d+(\\.\\d+)?((e|E)(\\+|-)?\\d+)?"")),
-    STRING          ( ""a string"",                           Pattern.compile(""\""([^\""\\\\]*|\\\\[\""\\\\bfnrt\\/]|\\\\u[0-9a-fA-F]{4})*\"""", Pattern.DOTALL));
+    //STRING          ( ""a string"",                           Pattern.compile(""\""([^\""\\\\]*|\\\\[\""\\\\bfnrt\\/]|\\\\u[0-9a-fA-F]{4})*\"""", Pattern.DOTALL));
+    /**
+     * Original pattern throws the StackOverflowError for long strings with backslashes.
+     * So it is replaced by 2-step approach taken from json2.js sources: https://github.com/douglascrockford/JSON-js/blob/master/json2.js#L462
+     * See {@link JsonTokenTypeTest#testMatchingLongStringWithBackslashes()} for details.
+     */
+    STRING          ( ""a string"",                           new Closure(null) {
+        private Pattern replacePattern = Pattern.compile(""(?:\\\\[\""\\\\bfnrt\\/]|\\\\u[0-9a-fA-F]{4})"");
+        private Pattern validatePattern = Pattern.compile(""\""[^\""\\\\]*\"""");
+        boolean doCall(String it) {
+            return validatePattern.matcher(replacePattern.matcher(it).replaceAll(""@"")).matches();
+        }
+    });
 
     /**
      * A String constant or a Pattern, serving as a validator for matching tokens.
@@ -72,6 +86,8 @@
         if (validator instanceof Pattern) {
             Matcher matcher = ((Pattern)validator).matcher(input);
             return matcher.matches();
+        } else if (validator instanceof Closure) {
+            return (Boolean)((Closure) validator).call(input);
         } else if (validator instanceof String) {
             return input.equals(validator);
         } else {
diff -r 3115bbd523ce -r 7e7048d14531 src/test/groovy/json/JsonTokenTypeTest.groovy
--- a/src/test/groovy/json/JsonTokenTypeTest.groovy	Tue Mar 13 01:46:45 2012 +0200
+++ b/src/test/groovy/json/JsonTokenTypeTest.groovy	Tue Mar 13 01:54:39 2012 +0200
@@ -82,6 +82,10 @@
         assert STRING.matching('""a\\""""')
     }
 
+    void testMatchingLongStringWithBackslashes() {
+        assert STRING.matching('""a' + '\\""'*10000 + '""')
+    }
+
     void testTokenStartingWithChar() {
         assert startingWith('{' as char)      == OPEN_CURLY
         assert startingWith('}' as char)      == CLOSE_CURLY
{noformat}
;;;","26/Mar/12 09:36;guillaume;I've committed those changes.
I haven't been able to test the behavior locally, but I trust you that it works well with the patch you prepared.
Thanks for finding that out.;;;","24/May/12 11:51;blendmaster;I can still reproduce this bug with Groovy 1.8.6 on

java version ""1.6.0_24""
OpenJDK Runtime Environment (IcedTea6 1.11.1) (6b24-1.11.1-4ubuntu3)
OpenJDK Client VM (build 20.0-b12, mixed mode, sharing)

JSON with long strings (in my case, raw MIME email messages) seems to cause a StackOverflowException more often.

Why does the JSON slurper use regex at all? Implementing a custom parser wuold be trivial, and would get around the JDK regex's WONTFIX bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5050507;;;","24/May/12 11:58;guillaume;If it's trivial and as efficient and passes all the tests, feel free to submit a patch :-);;;","30/Jun/12 19:00;paul;This is still a defect in Groovy 2.0 - right ?

Try this .......

import groovy.json.JsonSlurper

def doData(data) {
    def children = data.children
	if (children != null) {
	  doChildren(children)
	}
	def replies = data.replies
	if (replies != null) {
	  doReplies(replies)
	}
	def body = data.body
	if (body != null) {
	  doBody(body)
	}
}

def doChildren(children) {
	def data = children.data
	if (data != null) {
	  doData(data)
	}
}

def doReplies(replies) {
	def data = replies.data
	if (data != null) {
	  doData(data)
	}
}

def doBody(body) {
    println ""yay""
}

File dir = new File('.')
JsonSlurper jsonSlurper = new JsonSlurper();

URL url = new URL(""http://www.reddit.com/r/programming/comments/vtuii/why_files_exist.json"");

InputStream urlStream = null;
try {
    urlStream = url.openStream();
    BufferedReader reader = new BufferedReader(new InputStreamReader(urlStream));
    def doc = jsonSlurper.parse(reader)		
    doc.each { it ->
        def d = it.data;
	    if (d != null) {
		    doData(d)
		}
    }	
} finally {
    urlStream.close();
}

;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy class not compatible with Java integration when @Immutable is used,GROOVY-4902,12815753,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,venkats,venkats,26/Jun/11 11:05,21/Jul/11 19:06,14/Jul/23 06:00,30/Jun/11 19:09,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,Compiler,,,,0,,,,,,"The following Groovy class with the {{UsePerson.java}} below works well:
{code}
class Person {
  String firstName
  public Person(first) { firstName = first }
}
{code}
Defining a class with @Immutable annotation seems to result in compilation error when used from Java.

{code:title=Person.groovy}
@Immutable class Person {
  String firstName
}
{code}
{code:title=UsePerson.java}
public class UsePerson {
  public static void main(String[] args) {
    Person person = new Person(""Sam"");
    System.out.println(person.getFirstName());
  }
}
{code}
{noformat}
>groovyc Person.groovy

>ls
Person.class	Person.groovy	UsePerson.java

>javac UsePerson.java 
UsePerson.java:3: cannot access Person
bad class file: ./Person.class
undeclared type variable: K
Please remove or make sure it appears in the correct subdirectory of the classpath.
    Person person = new Person(""Sam"");
    ^
1 error
{noformat}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 30 19:09:15 UTC 2011,,,,,,,,,,"0|i2ckr3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Jun/11 08:35;paulk;add code tags;;;","30/Jun/11 19:09;paulk;Thanks for spotting that - some internal generics information was leaking into the bytecode.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc fails with MissingPropertyException,GROOVY-4898,12815736,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,nagai_masato,nagai_masato,24/Jun/11 07:48,05/Apr/15 14:44,14/Jul/23 06:00,25/Jun/11 06:20,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,GroovyDoc,,,,0,,,,,,"I got the following error when executing ""ant dist"" to build groovy:

    [java] [groovydoc] groovy.lang.MissingPropertyException: No such property: version for class: org.codehaus.groovy.runtime.InvokerHelper


The patch is to use GroovySystem.getVersion() instead of InvokerHelper.getVersion(). ",https://svn.codehaus.org/groovy/trunk/groovy/groovy-core r22395,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Jun/11 07:48;nagai_masato;patch;https://issues.apache.org/jira/secure/attachment/12722948/patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Sat Jun 25 06:20:27 UTC 2011,,,,,,,,,,"0|i2cj7r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Jun/11 06:20;paulk;Patch applied - Thanks!!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Anonymous inner class failure,GROOVY-4896,12818508,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mrctrevisan,mrctrevisan,23/Jun/11 10:35,15/Oct/15 18:16,14/Jul/23 06:00,03/Jul/14 05:18,1.7.10,1.8.0,3.x,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.3.4,,,class generator,,,,2,,,,,,"Hi all, 

I found some strange behaviour using anonymous inner classes.

If I declare (and use) an anonymous inner class inside a groovy closure inside a method, AND the anonymous inner class uses at least one of the method's input parameters, I get the following exception:

groovy.lang.GroovyRuntimeException: Could not find matching constructor for: [className]$[closureNumber]([parameters])

{code}
    void doSomethingUsingParam(final String s1){ // This always fails
        logExceptions {
            println ""doing something (expect exception)...""
            Runnable ifA = new Runnable(){
                        void run(){
                            println s1
                        }
                    }
            ifA.run()
        }
    }

    def logExceptions(Closure c){
        try{
            return c.call()
        } catch (Throwable e){
            e.printStackTrace();
        }
    }
}
{code}

I think it's a bug because the same code runs smoothly if, instead of the method input parameter, I use a local variable inside the groovy closure (the local variable doesn't even need to be declared as ""final"").

{code}
void doSomethingUsingParamWorkaround(final String s2){
    logExceptions {
        println ""doing something...""
        String s1=s2 // Too Ungroovy IMHO
        Runnable ifA = new Runnable(){
                    void run(){
                        println s1
                    }
                }
        ifA.run()
    }
}
{code}

A more complete set of variants of the above methods is attached
",,blackdrag,davide.cavestro,mauromol,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/Jun/11 10:35;runner.groovy;https://issues.apache.org/jira/secure/attachment/12722891/runner.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 03 05:18:06 UTC 2014,,,,,,,,,,"0|i2ckmn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jun/11 15:50;paulk;I can replicate the problem. Also, changing the number of params doesn't alter the bug:
With this altered method definition.
{code}
void doSomethingUsingParam(String s1, String s2){
{code}
and this code inside the run method:
{code}
println s1 + s2
{code}
and called like this:
{code}
doSomethingUsingParam(""any"", ""String"")
{code}
The error looks like this:
{noformat}
groovy.lang.GroovyRuntimeException: Could not find matching constructor for: ConsoleScript3$4(ConsoleScript3, java.lang.String, java.lang.String)
{noformat}
Inspecting the AST shows the constructor params as this (which looks ok I think):
{noformat}
[org.codehaus.groovy.ast.Parameter@5aade4[name:p0 type: script1308862327975, hasDefaultValue: false], org.codehaus.groovy.ast.Parameter@14e9177[name:p1 type: groovy.lang.Reference, hasDefaultValue: false], org.codehaus.groovy.ast.Parameter@1302067[name:p2 type: groovy.lang.Reference, hasDefaultValue: false]]
{noformat};;;","23/Jun/11 16:21;mrctrevisan;Hi paul,

I also wonder how can I really be the first to have noticed such a problem (but I searched the JIRA and didn't find any existing bug like this one). It comes in your way when you have to develop groovy code which adapts existing legacy Java code (i.e. abstract classes, where you cannot simply force a closure to be of the same type of the required interface, you really have to extend it).

Cheers!
  Marco
;;;","23/Jun/11 17:09;blackdrag;looking at what Paul debugged the problem seems to be as follows. local varibales of any kind used in a closure or inner class are actually References, containing the value. This works fine for closures normally, but somehow not anymore for inner classes containing a closure. The constructor call should have been done with References, but is done with String, meaning the outside wrapping somehow does not work here.;;;","04/Nov/11 16:09;melix;In can reproduce with 1.8.2

However, 1.8.3, master + 1.8.x branch do not seem to have the problem, so I suspect this has already been fixed as a side effect of another bug.;;;","07/Nov/11 02:43;melix;Not reproducible under 1.8.4. Seems to have been fixed in 1.8.3.;;;","07/Feb/13 10:14;davide.cavestro;I guess I've reproduced this bug on groovy 1.8.8 running the following test case on groovy console
{code:java}
interface Foo {
    void foo ()
}

class Callee {
  String getMessage () {
      ""hello""
  }
  
  void hello() {
     ['Sparrow', 'Barbossa', 'Jones', 'Trevisan'].each {
     def msg1 = message
         new Foo () {
             void foo () {
                 String msg = message //FAILS
                 //String msg = msg1 //WORKS
                 println ""${msg}, $it""
             }
         }.foo ()
     }
  }
}

new Callee ().hello ()
{code}

Could you please reopen this bug?;;;","08/Feb/13 08:03;davide.cavestro;The problem is reproducible (with the test case provided on my previous comment) even on latest stable version (groovy 2.1.0).
Maybe you could be also interested in updating the affected versions.;;;","08/Feb/13 08:12;pschumacher;Thanks for the info. :) I update the affected version.;;;","03/Jul/14 05:18;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"GroovyInterceptable / invokeMethod does not correctly in Groovy 1.8.0 when Methods with no arguments are ""delegated""",GROOVY-4892,12818115,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,radgon,radgon,21/Jun/11 05:16,15/Jul/11 14:38,14/Jul/23 06:00,15/Jul/11 14:38,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,Compiler,primtive opts,,,0,metaprogramming,,,,,"please compare
http://stackoverflow.com/questions/6419674/groovyinterceptable-does-not-work-on-methods-with-no-arguments

the following class gives the correct output in Groovy < 1.8, in 1.8 it only works if a parameter is added to the nested method.

A workaround is mentioned in the stackoverflow link.
{code:Java}
class SimpleFlow implements GroovyInterceptable {

    def invokeMethod(String name, args) {
        System.out.println(""time before ${name} called: ${new Date()}"")

        def calledMethod = SimpleFlow.metaClass.getMetaMethod(name, args)
        calledMethod?.invoke(this, args)

        System.out.println(""time after ${name} called: ${new Date()}\n"")
    }

    void simpleMethod1(){
        System.out.println(""simpleMethod1() called"")
        simpleMethod2Nested()
    }

    // works well when using an argument
    void simpleMethod2Nested(){
        System.out.println(""simpleMethod2Nested"")
    }

    public static void main(String[] args) {
        def flow = new SimpleFlow()
        flow.simpleMethod1()
    }
}
{code}
actual output:

time before simpleMethod1 called: Tue Jun 21 04:16:41 CEST 2011
simpleMethod1() called
simpleMethod2Nested
time after simpleMethod1 called: Tue Jun 21 04:16:41 CEST 2011

estimated output:
time before simpleMethod1 called: Tue Jun 21 13:32:44 GMT+08:00 2011
simpleMethod1() called
time before simpleMethod2Nested called: Tue Jun 21 13:32:44 GMT+08:00 2011
simpleMethod2Nested
time after simpleMethod2Nested called: Tue Jun 21 13:32:44 GMT+08:00 2011
time after simpleMethod1 called: Tue Jun 21 13:32:44 GMT+08:00 2011",Windows XP / 7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 15 14:38:17 UTC 2011,,,,,,,,,,"0|i2bufr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jun/11 06:07;blackdrag;changed formatting;;;","21/Jun/11 06:09;blackdrag;I change the priority to blocker, since  it looks like the method optimizations simply ignore the GroovyInterceptable interface atm;;;","15/Jul/11 14:38;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovyConsole throws an exception when opening the AST browser ,GROOVY-4891,12818511,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,rene.scheibe,rene.scheibe,20/Jun/11 09:14,25/Aug/13 16:59,14/Jul/23 06:00,23/Jul/13 13:44,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,,,Groovy Console,,,,0,,,,,,"Running ""Inspect Ast"" (Ctrl-T) throws the below exception. The AST browser still opens and looks like usable. This only happens in Groovy 1.8.

{noformat}
Exception in thread ""Thread-4"" 
org.codehaus.groovy.runtime.InvokerInvocationException: java.lang.LinkageError: loader (instance of  org/codehaus/groovy/tools/RootLoader): attempted  duplicate class definition for name: ""groovy/grape/GrabAnnotationTransformation""
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:97)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:929)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)
	at groovy.lang.Closure.call(Closure.java:405)
	at groovy.lang.Closure.call(Closure.java:399)
	at groovy.lang.Closure.run(Closure.java:483)
	at java.lang.Thread.run(Thread.java:662)
Caused by: java.lang.LinkageError: loader (instance of  org/codehaus/groovy/tools/RootLoader): attempted  duplicate class definition for name: ""groovy/grape/GrabAnnotationTransformation""
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:616)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:283)
	at java.net.URLClassLoader.access$000(URLClassLoader.java:58)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:197)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at org.codehaus.groovy.tools.RootLoader.oldFindClass(RootLoader.java:152)
	at org.codehaus.groovy.tools.RootLoader.loadClass(RootLoader.java:124)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:296)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:696)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.addPhaseOperationsForGlobalTransforms(ASTTransformationVisitor.java:285)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.doAddGlobalTransforms(ASTTransformationVisitor.java:266)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.addGlobalTransforms(ASTTransformationVisitor.java:187)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.addPhaseOperations(ASTTransformationVisitor.java:150)
	at org.codehaus.groovy.control.CompilationUnit.<init>(CompilationUnit.java:188)
	at org.codehaus.groovy.control.CompilationUnit.<init>(CompilationUnit.java:120)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
	at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:54)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:198)
	at groovy.inspect.swingui.AstNodeToScriptAdapter.compileToScript(AstNodeToScriptAdapter.groovy:90)
	at groovy.inspect.swingui.AstNodeToScriptAdapter$compileToScript.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at groovy.inspect.swingui.AstBrowser$_decompile_closure6.doCall(AstBrowser.groovy:269)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	... 9 more
{noformat}

I also had problems that the tree view in the AST browser was not showing anything due to NoClassDefFound execptions for Swing classes but I cannot reproduce this at the moment.",,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 23 13:44:02 UTC 2013,,,,,,,,,,"0|i2bxc7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jun/11 10:21;guillaume;Can you please list the jars that you have in your groovy home installation?
Looks like you have two Groovy jars in there.;;;","20/Jun/11 11:17;rene.scheibe;I checked my GROOVY_HOME - it's nothing special in there:

embeddable/groovy-all-1.8.0.jar
lib/ant-1.8.2.jar
lib/ant-antlr-1.8.2.jar
lib/ant-junit-1.8.2.jar
lib/ant-launcher-1.8.2.jar
lib/antlr-2.7.7.jar
lib/asm-3.2.jar
lib/asm-analysis-3.2.jar
lib/asm-commons-3.2.jar
lib/asm-tree-3.2.jar
lib/asm-util-3.2.jar
lib/bsf-2.4.0.jar
lib/commons-cli-1.2.jar
lib/commons-logging-1.1.1.jar
lib/gpars-0.11.jar
lib/groovy-1.8.0.jar
lib/ivy-2.2.0.jar
lib/jansi-1.2.1.jar
lib/jline-0.9.94.jar
lib/jsp-api-2.0.jar
lib/jsr166y-070108.jar
lib/junit-4.8.2.jar
lib/servlet-api-2.4.jar
lib/xstream-1.3.1.jar

I also removed the embeddable/groovy-all-1.8.0.jar for testing, just to make sure, but still the same problem.

I removed my ~/.groovy folder, but still the same problem.

I checked my . folder, there is no groovy jar in there.;;;","20/Jun/11 12:04;rene.scheibe;I checked again against all 1.7.x version.

The problem is present since 1.7.6. Looks like this is the version where the source view was introduced in the AST browser. Maybe it relates to this - just a guess.

I don't see this problem 100% of the time - it's about 80% of the time.;;;","20/Jun/11 14:07;melix;I can see this too. I'm using the debian installer. Are you on Linux too ?;;;","20/Jun/11 14:09;rene.scheibe;I am on Ubuntu 11.04. My Groovy installations are downloaded and expanded tarballs.;;;","20/Jun/11 14:35;melix;Maybe a thread synchronization issue in the GroovyClassLoader because :
* hint 1 : the error message either appears in the main console window, or the AST browser
* hint 2 : the error doesn't appear if I run the script before opening the AST browser
* hint 3 : AST Browser runs concurrently

For example, if I do :
{code}
println 'toto'
{code}

Save it in a file, then open the groovy console (close the console after each test) :
{code}groovyConsole toto.groovy{code}

Test 1: Do not run the script, but open AST browser : the errors shows up most of the times
Test 2: Run the script then show the AST browser. No error.
;;;","20/May/13 21:19;paulk;Does this still occur? I am wondering (perhaps a long shot) whether GROOVY-4960 fixed the problem?;;;","23/Jul/13 13:44;pschumacher;I can not reproduce (following Cedrics instructions) this with Groovy 2.2, so I guess Paul is right.

Please reopen if this error still occurs. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MapExpression#getText incorrect for empty map,GROOVY-4890,12815574,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,rene.scheibe,rene.scheibe,20/Jun/11 06:35,05/Apr/15 14:44,14/Jul/23 06:00,20/Jun/11 15:52,1.7.10,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,,,,,0,,,,,,"For an empty map - e.g.
{code}
a = [:]
{code}
MapExpression#getText returns {{[]}} but should return {{[:]}}.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Jun/11 07:06;AST_expression_tests_cleanup.patch;https://issues.apache.org/jira/secure/attachment/12722859/AST_expression_tests_cleanup.patch","20/Jun/11 06:35;MapExpression_getText.patch;https://issues.apache.org/jira/secure/attachment/12722888/MapExpression_getText.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Mon Jun 20 15:53:13 UTC 2011,,,,,,,,,,"0|i2cdxz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"20/Jun/11 07:06;rene.scheibe;Cleaned up some existing AST expression tests.;;;","20/Jun/11 15:53;paulk;Thanks for the patches!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy console script execution output appears in all output windows,GROOVY-4888,12815742,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pascalschumacher,ingorichter,ingorichter,17/Jun/11 17:30,22/Feb/16 20:48,14/Jul/23 06:00,25/Oct/15 18:44,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.6,,,Groovy Console,,,,0,,,,,,"Having two open windows in groovy console. Executing a script in one of the windows will result in having the output in all output windows.
Expected: output appears only in the output window belonging to the script that was executed","OS X 10.6.7, english
groovy 1.8.0
java version ""1.6.0_24""",githubbot,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 26 18:47:10 UTC 2015,,,,,,,,,,"0|i2crdj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Dec/11 21:18;roshandawrani;It seems to be quite explicitly sending normal / error output to all console windows' output area, so just wanted to cross-check if there is some other feature that depends on it. Or, is it ok to go ahead and fix it so that output always remains in the window in which it was executed?;;;","07/Dec/11 03:10;guillaume;It always appeared strange to me that the results were output on all output windows.
I would think it's okay to go and fix it, because I can't really understand the rationale here why it'd be so.;;;","07/Dec/11 04:12;paulk;I wasn't involved but from memory there was something mentioned as to why the behavior is the way it is (as an interim measure until the issue could be fixed). Perhaps it was something like the error output could only go to one window and it was hard to tell what errors below to where without also seeing the normal output. But we have made numerous changes since then so maybe the problem/issue has already been corrected. I mention this not to defend the current behavior just by way of background if anything strange occurs on the path to fixing the error. :-);;;","25/Oct/15 06:41;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/incubator-groovy/pull/160

    GROOVY-4888 - groovy console script execution output appears in all o…

    …utput windows

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/incubator-groovy GROOVY-4888

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/160.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #160
    
----
commit 6428b35a9ae32996b4ae91ffb6eb104cf6c93e3b
Author: John Wagenleitner <john.wagenleitner@gmail.com>
Date:   2015-10-25T06:30:34Z

    GROOVY-4888 - groovy console script execution output appears in all output windows

----
;;;","25/Oct/15 18:35;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/160
;;;","25/Oct/15 18:44;pascalschumacher;Pull request merged. Thanks!;;;","26/Oct/15 18:47;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/161
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
New Compile failure when upgrading from 1.7.1 to 1.8.0,GROOVY-4887,12818091,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,jay.guidos,jay.guidos,17/Jun/11 11:21,01/Apr/13 05:56,14/Jul/23 06:00,01/Apr/13 05:56,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.2,,,class generator,,,,0,,,,,,"When recompiling after switching from 1.7.1 to 1.8.1 I see the following compiler bug error. Do you have suggestions for a fix or a work around?  I don't really understand what the underlying issue is:

{noformat}
BUG! exception in phase 'class generation' in source unit '/home/bidsjagu/java/amsl/eomssim/bids/tools/eomssim/groovy/engine/test/com/dark/eoms/sim/engine/fixture/TestCRDConnector.groovy' Type is null. Most probably you let a transform reuse existing ClassNodes with generics information, that is now used in a wrong context.
	at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:96)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureTypeArguments(Java5.java:157)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureParameterizedType(Java5.java:137)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:88)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeClassNode(Java5.java:383)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeParameter(Java5.java:402)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeParameters(Java5.java:395)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:340)
	at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:264)
	at org.codehaus.groovy.ast.ClassNode.getUnresolvedSuperClass(ClassNode.java:974)
	at org.codehaus.groovy.ast.ClassNode.getUnresolvedSuperClass(ClassNode.java:969)
	at org.codehaus.groovy.ast.ClassNode.getSuperClass(ClassNode.java:963)
	at org.codehaus.groovy.ast.ClassNode.isDerivedFrom(ClassNode.java:906)
	at org.codehaus.groovy.classgen.asm.OperandStack.doConvertAndCast(OperandStack.java:290)
	at org.codehaus.groovy.classgen.asm.OperandStack.doAsType(OperandStack.java:274)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitCastExpression(AsmClassGenerator.java:630)
	at org.codehaus.groovy.ast.expr.CastExpression.visit(CastExpression.java:66)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:279)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:68)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:526)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:599)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:323)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:460)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:80)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:151)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:406)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:289)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:268)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:366)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:174)
	at org.codehaus.groovy.control.CompilationUnit$13.call(CompilationUnit.java:763)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:957)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:542)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:520)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:497)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:43)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:128)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:75)
{noformat}",Linux 64 bit,jan42,jay.guidos,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Jun/11 19:09;jay.guidos;Shares.groovy;https://issues.apache.org/jira/secure/attachment/12722860/Shares.groovy","17/Jun/11 19:09;jay.guidos;TestCRDConnector.groovy;https://issues.apache.org/jira/secure/attachment/12722945/TestCRDConnector.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 01 05:56:03 UTC 2013,,,,,,,,,,"0|i2cjlr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jun/11 15:04;guillaume;Please provide a sample class that exhibits that compilation problem, otherwise, it'll be difficult for us to find the cause.;;;","17/Jun/11 16:46;jay.guidos;Was caused by having some code compiled by 1.7.1 and some by 1.8.0.  When I recompiled all code using only 1.8.0 the BUG report went away.;;;","17/Jun/11 18:24;jay.guidos;Problem still exists - I have more diagnostics now;;;","17/Jun/11 18:33;jay.guidos;Comment deleted;;;","17/Jun/11 19:09;jay.guidos;Shares classes with @Immutable;;;","17/Jun/11 19:09;jay.guidos;Problem class;;;","17/Jun/11 19:12;jay.guidos;I have attached a test case.  I am betting the root problem is an issue with @Immutable.

Compiling the test code will work until you uncomment the method in TestCRDConnector.  If you do so, you will see the following error:

{noformat}
BUG! exception in phase 'class generation' in source unit '/home/bidsjagu/java/GroovyBug/src/TestCRDConnector.groovy' Type is null. Most probably you let a transform reuse existing ClassNodes with generics information, that is now used in a wrong context.
	at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:96)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureTypeArguments(Java5.java:157)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureParameterizedType(Java5.java:137)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:88)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeClassNode(Java5.java:383)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeParameter(Java5.java:402)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeParameters(Java5.java:395)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:340)
	at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:264)
	at org.codehaus.groovy.ast.ClassNode.getUnresolvedSuperClass(ClassNode.java:974)
	at org.codehaus.groovy.ast.ClassNode.getUnresolvedSuperClass(ClassNode.java:969)
	at org.codehaus.groovy.ast.ClassNode.getSuperClass(ClassNode.java:963)
	at org.codehaus.groovy.ast.ClassNode.isDerivedFrom(ClassNode.java:906)
	at org.codehaus.groovy.classgen.asm.OperandStack.doConvertAndCast(OperandStack.java:290)
	at org.codehaus.groovy.classgen.asm.OperandStack.doAsType(OperandStack.java:274)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitCastExpression(AsmClassGenerator.java:630)
	at org.codehaus.groovy.ast.expr.CastExpression.visit(CastExpression.java:66)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:279)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitDeclarationExpression(AsmClassGenerator.java:521)
	at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:85)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:599)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:323)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:460)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:80)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:151)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:406)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:289)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:268)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:366)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:174)
	at org.codehaus.groovy.control.CompilationUnit$13.call(CompilationUnit.java:763)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:957)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:542)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:520)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:497)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:43)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:128)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:75)
{noformat}
;;;","18/Jun/11 01:21;paulk;If I have the import:
{code}
import groovy.transform.Immutable
{code}
then it seems to compile and run fine - though perhaps we don't have the full code.;;;","18/Jun/11 12:56;jay.guidos;Hi Paul,

Thanks for taking a look. I was having problems reproducing it all the time - sometimes it happens, sometimes not. I think I can reproduce it reliably now with the two files I gave you. If you compile both classes from scratch there are no problems. If you then edit the TestCRDConnector.groovy file (any change will do) and then recompile without changing the Shares.groovy class then I can reliably reproduce the above stack trace. So the problem seems to be how the groovy compiler is re-loading the already compiled class file for Shares.groovy, and may not be connected to how TestCRDConnector actually uses Shares.

I am not sure why you needed to include the Immutable import, I seem to be able to compile successfully (from scratch) without doing that.

I can upload the entire IntelliJ 10.5 project if you think that would help, it is only those two files you have already seen plus a project config directory.;;;","19/Jun/11 04:50;paulk;Haven't had time to try recompiling just yet. Just on the import, {{groovy.lang.Immutable}} is deprecated - everyone should be using {{groovy.transform.Immutable}} these days - I was just suggesting the import to remove that potential complication from the mix.;;;","20/Jun/11 09:54;jay.guidos;I had a go using the non-deprecated version of Immutable, with no change in results.;;;","22/Jun/11 06:59;jan42;I can reproduce this bug, too.
It appears from time to time in my groovy project, when I'm trying to compile certain classes.
I have not fully identified what classes cause this bug to appear, so I can't attach another example.
Rebuilding the whole project helps though.

Below is my setup and how I was able to reproduce the bug, using the files Jay provided.
I added an import to 'groovy.transform.Immutable' in Shares.groovy and uncommented the line in TestCRDConnector.groovy.

{quote}
$ uname -a
Linux box 2.6.38-8-generic #42-Ubuntu SMP Mon Apr 11 03:31:24 UTC 2011 x86_64 x86_64 x86_64 GNU/Linux
{quote}

{quote}
$ java -version                                                           
java version ""1.6.0_24""
Java(TM) SE Runtime Environment (build 1.6.0_24-b07)
Java HotSpot(TM) 64-Bit Server VM (build 19.1-b02, mixed mode)
{quote}

{quote}
$ groovyc -version                   
Groovy compiler version 1.8.0
Copyright 2003-2010 The Codehaus. http://groovy.codehaus.org/
{quote}

{quote}
$ groovyc Shares.groovy
$ groovyc TestCRDConnector.groovy
>>> a serious error occurred: BUG! exception in phase 'class generation' in source unit 'TestCRDConnector.groovy' Type is null. Most probably you let a transform reuse existing ClassNodes with generics information, that is now used in a wrong context.
>>> stacktrace:
 *same stacktrace as above*

{quote}
;;;","01/Apr/13 05:56;pschumacher;I used the same steps as in Jan Ahrens last comment, but could not reproduce this with Groovy 2.1.2, so I'm closing this issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Calling a method overwritten via metaClass from another method uses the original (non-overwritten) method,GROOVY-4884,12815719,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,rene.scheibe,rene.scheibe,16/Jun/11 05:23,26/Jul/11 19:44,14/Jul/23 06:00,14/Jul/11 11:54,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,primtive opts,,,,2,,,,,,"Having the following code...

{code}
class A {
    String m1() { println 'called m1'; 'm1' }
    String m2() { println 'called m2'; println m1(); 'm2' }
}
a = new A()                                                                                                   
a.metaClass.m1 = { -> println 'pwned m1'; 'o-m1' }                                                            
{code}

Calling a.m2() shows...
{noformat}
called m2
called m1
m1
===> m2
{noformat}

...but expected is this:
{noformat}
called m2
pwned m1
o-m1
===> m2
{noformat}

The correct output is shown in Groovy 1.7.x, only Groovy 1.8.0 shows the wrong one.",,jason@bobberinteractive.com,jwb,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 26 19:44:02 UTC 2011,,,,,,,,,,"0|i2bsj3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jun/11 05:30;tim_yates;Oddly, works as expected on the Groovy Web Console (which I believe is running 1.8.0?)...;;;","16/Jun/11 05:47;guillaume;Groovy Web Console indeed runs 1.8.0.;;;","28/Jun/11 16:59;jason@bobberinteractive.com;We appear to be hitting this in our tests...  Upgrading from 1.7.5 to 1.8.0 broke tests that verified values by overriding m1()-type methods and checking what m2() was passing in.

We've tried the 1.8.1 snapshot, but our tests still fail.  

I'd be happy to attach an example, but it doesn't vary much from Rene's code.  Please let me know if there's anything I can do to help! ;;;","14/Jul/11 11:54;blackdrag;should be fixed now;;;","25/Jul/11 22:24;jason@bobberinteractive.com;Hi Jochen,

Rene's example works, and more of our tests pass with 1.8.1, but we're still having problems with what looks like a variant of the problem.

This is a stripped-down version of a test that passes with 1.7.6 but fails with 1.8.1:

{code}
import org.junit.Test;

public class BreakingExample_NoMetaclassOverride {
   @Test
   void testNotOverriden() {
      def list = []
      ClassUnderTest cut = new ClassUnderTest()
      cut.metaClass.getRemoteObject = { ->
         return [method: {obj -> 
            list << obj
         }] as RemoteObject
      }
      
      String val = ""Value"" 
      cut.someMethod(val)
      assert list == [val]
   }
}

public class ClassUnderTest {
   public def someMethod(String someValue) {
      RemoteObject object = getRemoteObject()
      object.method(someValue)
   }
   protected RemoteObject getRemoteObject() {
      return new RemoteObject()
   }
}

public class RemoteObject {
   public void method(obj) { /* Something */ }
}
{code}

Is this a bug or a change in how the metaClass works?

Thank you!
Jason;;;","26/Jul/11 04:18;blackdrag;your code works for me in trunk. ;;;","26/Jul/11 11:23;jwb;Seems we either need another issue to track the fix into 1.8.x or re-open this issue. If it's not appropriate to re-open this, we can make a new report for the problem Jason identified in 1.8.1.;;;","26/Jul/11 16:37;blackdrag;please open a new issue;;;","26/Jul/11 19:44;jason@bobberinteractive.com;Looks like Eclipse and/or I messed up the build order...  The Groovy-Eclipse plugin (currently) comes with Groovy 1.8.0.  Once I made sure I had groovy-all-1.8.1.jar ahead of ""Groovy Libraries"" in the Order and Export list, the example I posted worked.

The test it came from still fails in Eclipse, but that looks like further Eclipse wackiness...  The failing test passes by cleaning, building and testing from command-line Ant using only 1.8.1.

Thanks for taking a look, Jochen!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Concatenating an empty list to a GString throws a MethodSelectionException ,GROOVY-4882,12815896,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,mjjustin,mjjustin,14/Jun/11 17:33,31/Jan/12 23:04,14/Jul/23 06:00,31/Jan/12 23:04,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,,,,,,,0,,,,,,"A MethodSelectionException is thrown when appending an empty list to a GString that contains a ${} expression.  Note that no exception is thrown if the GString does not contain a ${} expression or if the list is nonempty.  The exception thrown is:

{code}Caught: org.codehaus.groovy.runtime.metaclass.MethodSelectionException: Could not find which method plus() to invoke from this list:
  public groovy.lang.GString groovy.lang.GString#plus(groovy.lang.GString)
  public groovy.lang.GString groovy.lang.GString#plus(java.lang.String)
{code}

No other concatenation I've tried has this behavior.  So the following line throws the exception:

{code}""GString concat ${'a'}"" + []{code}

None of the following throw anything:

{code}
""GString concat ${'a'}"" + ['abc']  // Concatenating a nonempty list
""GString concat "" + []             // Concatenating an empty list, but not using ${} in the GString

// Concatenating various other object types
['abc', '', null, [:], 0, 1, false, new Object[0]].each { ""GString concat ${'a'}"" + it }
{code}

I would expect the behavior of appending an empty list to be consistent with appending any other list (or object type).",,mjjustin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"14/Jun/11 17:33;mjjustin;GStringPlusEmptyListThrowsExceptionTest.groovy;https://issues.apache.org/jira/secure/attachment/12722858/GStringPlusEmptyListThrowsExceptionTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 31 23:04:33 UTC 2012,,,,,,,,,,"0|i2bmn3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"18/Jan/12 13:00;jwagenleitner;Just wanted to note that the attached testcase passes in Groovy 1.8.2 and above.;;;","31/Jan/12 23:04;paulk;I think this was ""fixed"" via other changes (possible GROOVY-4949). Please reopen if you can reproduce with a recent version of Groovy.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper does not handle backslash,GROOVY-4881,12818084,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,mattmichalowski,mattmichalowski,14/Jun/11 00:23,21/Jul/11 19:06,14/Jul/23 06:00,15/Jun/11 10:36,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,1.9-beta-1,,JSON,,,,0,,,,,,"The JsonSlurper does not appear to handle backslash characters (\) even if they have been properly escaped.

Using this sample pieced together from the Groovy 1.8.0 Release Notes:

{code}
import groovy.json.*

def json = new JsonBuilder()

json.person {
    name ""Guill\\aume""
    age 33
    pets ""Hector"", ""Felix""
}

def jsonstring = json.toString()
println jsonstring

def slurper = new JsonSlurper()
def doc = slurper.parseText(jsonstring)

println doc
{code}

$ groovy json.groovy 
{noformat}
{""person"":{""name"":""Guill\\aume"",""age"":33,""pets"":[""Hector"",""Felix""]}}
Caught: groovy.json.JsonException: Expected a value on line: 1, column: 69.
But got an unterminated object.
        at json.run(json.groovy:15)
{noformat}

Have tried this with 1.8.0, 1.8.1 Snapshot (2011-06-13), 1.9.0 Snapshot (2011-06-13)",Gentoo Linux (amd64) / sun-jdk 1.6.0_26,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"14/Jun/11 00:24;mattmichalowski;json.groovy;https://issues.apache.org/jira/secure/attachment/12722886/json.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 14 00:28:00 UTC 2011,,,,,,,,,,"0|i2cofr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"14/Jun/11 00:28;mattmichalowski;Sorry, new to both groovy & jira, have attached my code example.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Documentation incorrect for Object#with,GROOVY-4866,12815818,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,justin.piper@gmail.com,justin.piper@gmail.com,06/Jun/11 13:24,21/Jul/11 19:06,14/Jul/23 06:00,16/Jun/11 04:57,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,1.9-beta-1,,,,,0,,,,,,"The documentation for Object#with suggests using it to initialize objects, but the examples it provides are not correct. They assume that #with returns the object, when it actually returns the result of the closure.

The first example works because StringBuilder#append serendipitously returns the object, and the closure returns the result of the last #append.

{code}
def b = new StringBuilder().with {
  append('foo')
  append('bar')
}

assert b instanceof StringBuilder
{code}

The second example does not work correctly, since the closure returns the result of the assignment to the lastName property.

{code}
class Person { def firstName, lastName }

def p = new Person().with {
   firstName = 'John'
   lastName = 'Doe'
}

assert p instanceof Person
{code}

Modifying the examples so that the closures explicitly return the object would make the documentation correct.

{code}
def b = new StringBuilder().with {

  append('foo')
  append('bar')
  
  return it
}

assert b instanceof StringBuilder

class Person { def firstName, lastName }

def p = new Person().with {

  firstName = 'John'
  lastName = 'Doe'
  
  return it
}

assert p instanceof Person
{code}",,justin.piper@gmail.com,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-06-06 13:24:56.0,,,,,,,,,,"0|i2ce8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"HTML builder for ""textarea"" creates empty ""textarea"" element if no text specified, which is not alloed in HTML",GROOVY-4864,12816223,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,yatima,yatima,06/Jun/11 07:11,21/Jul/11 19:06,14/Jul/23 06:00,10/Jun/11 07:18,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,groovy-jdk,,,,0,,,,,,"Groovy's HTMLBuilder creates an empty ""textarea"" element (i.e. inserts the string ""<textarea />"" instead of ""<textarea></textarea>"") if no text has been specified for the textarea builder.

 The HTML spec is not fully clear on whether an empty element is allowed for ""textarea"":

      http://www.w3.org/TR/html401/interact/forms.html#h-17.7

 But one might want to read this about empty elements in HTML:

      http://www.cs.tut.fi/~jkorpela/html/empty.html


Firefox 3.6.17 deals badly with this (all the stuff following ""<textarea />"" is interpreted as the text of the textarea)


Workaround:

Instead of

   textarea(cols: 40, rows:5, name:'message')       --> <textarea />

Used

   textarea(cols: 40, rows:5, name:'message', """")   --> <textarea></textarea>


","Linux 2.6.35.13-91.fc14.i686
Java(TM) SE Runtime Environment (build 1.6.0_22-b04)
Firefox 3.6.17",paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 10 07:18:03 UTC 2011,,,,,,,,,,"0|i2bmyv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jun/11 19:41;paulk;Groovy's {{MarkupBuilder}} and {{StreamingMarkupBuilder}} are general purpose builders for any XML not just HTML. It wouldn't be right to presume that what is sometimes desirable for HTML should be the default. In fact, the 'workaround' you mention is indeed the correct way to use the builders to produce the output you want for HTML. I guess one possibility would be to provide an {{expandEmptyElement}} flag when creating the builder. Does that sound like it would neet your requirement?;;;","10/Jun/11 04:45;yatima;Hi Paul,

>It wouldn't be right to presume that what is sometimes desirable for HTML should be the default.

Certainly -- the more so as HTML is not actually XML at all. 

The problem I had basically stems from the fact that I assumed an ""HTMLbuilder"" would do the Right Thing regarding HTML, while in the end it didn't actually generate HTML at all. Or in other words: Expectations differ when you are using an ""XHTMLBuilder"" or an ""HTMLBuilder"". Debugging this is difficult, as one has to know about this HTML quirk or (in my case) google and find someone who posted a solution to this problem on a mailing list.

>I guess one possibility would be to provide an expandEmptyElement flag when creating the builder. 

Or something like ""enforceHtml"" if ""HTMLBuilder"" is used for both HTML and XHTML. I don't know if similar problems exist for other HTML entities -- but I suppose yes. 

Best regards,

-- David.
;;;","10/Jun/11 05:01;paulk;Which builder are you actually using?;;;","10/Jun/11 05:11;yatima;The one which is injected into the Groovlet by GroovyServlet?

""html.html"";;;","10/Jun/11 07:18;paulk;The previously discussed {{expandEmptyElements}} flag has been added to {{StreamingMarkupBuilder}} and {{MarkupBuilder}}. The default value for this flag is {{false}} but the {{MarkupBulder}} instance created for Groovlets has it set to {{true}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1.8 incompatibility with named parameters,GROOVY-4863,12815681,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,bob.swift,bob.swift,06/Jun/11 06:35,29/Aug/11 13:46,14/Jul/23 06:00,29/Aug/11 13:46,1.8.0,1.8.1,1.9-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.2,1.9-beta-3,,,,,,0,,,,,,"See http://groovy.markmail.org/message/wuskviqggfgzos7r?q=1%2E8+incompatibility&page=1

I have methods that support named parameters via a Map and positional method with the same name. Works on 1.7.x but gives stack overflow error on 1.8.

{noformat}
foo('xxxx')

def foo(final Map map) {
    println map
}

def foo(final name) {
    return foo(name: name)
}
{noformat}

{noformat}
imac:info bob$ groovy test18.groovy
Caught: java.lang.StackOverflowError
	at test18.foo(test18.groovy)
	at test18.foo(test18.groovy:8)
	at test18.foo(test18.groovy:8)
	at test18.foo(test18.groovy:8)

{noformat}","Mac OS 10.6.7, Java 6",paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 29 13:46:39 UTC 2011,,,,,,,,,,"0|i2cnrj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Aug/11 13:46;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Duplicate entry in InnerClasses,GROOVY-4861,12815518,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,02/Jun/11 15:35,22/May/22 16:05,14/Jul/23 06:00,05/Jun/11 06:38,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,,,,,0,ClassFormatError,,,,,"For this code:
{code}
class Foo {
    static interface A{}
    static interface B{} // (1)
    static class Inner<X> {}
    static Inner<A> method() {} // (2)
}

println new Foo()
{code}
This error is received:
{noformat}
java.lang.ClassFormatError: Duplicate entry in InnerClasses in class file Foo
{noformat}

Removing either the declaration of {{B}} at (1) or the Generics attribute {{<A>}} on the type {{Inner}} at (2) will avoid the error.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-06-02 15:35:16.0,,,,,,,,,,"0|i2bmvr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
toString() unsupported on proxy,GROOVY-4857,12818089,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,olandere,olandere,01/Jun/11 15:16,05/Apr/15 14:44,14/Jul/23 06:00,23/Sep/11 05:08,1.7.10,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.3,1.9-beta-4,,,,,7,,,,,,"toString() and other methods that are expected to be on Object should not generate an UnsupportedOperationException when using the Proxy pattern in groovy.  Many methods expect non-null objects to allow methods that exist on Object to be called without issue.  The example below should throw a MissingMethodException with a nice message that includes the method name and the arguments that were called, but since MissingMethodException.getMessage() calls the proxy's toString() method we get an UnsupportedOperationException on toString() instead, as well as a stack trace that originates from the location that the MissingMethodException's getMessage() is being called, obscuring the actual problem entirely.
{code}
interface A {
  def getValue()
}

class B { }

def test = [
  getValue: {
    'getValue() called'
  }
] as A

def b = new B()

b.call(test)
{code}

Stack trace from 1.8.0:
{code}
java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:108)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130)
Caused by: java.lang.UnsupportedOperationException
	at org.codehaus.groovy.runtime.ConvertedMap.invokeCustom(ConvertedMap.java:46)
	at org.codehaus.groovy.runtime.ConversionHandler.invoke(ConversionHandler.java:82)
	at $Proxy4.toString(Unknown Source)
	at org.codehaus.groovy.runtime.InvokerHelper.format(InvokerHelper.java:550)
	at org.codehaus.groovy.runtime.InvokerHelper.format(InvokerHelper.java:504)
	at org.codehaus.groovy.runtime.InvokerHelper.toArrayString(InvokerHelper.java:689)
	at org.codehaus.groovy.runtime.InvokerHelper.toString(InvokerHelper.java:109)
	at groovy.lang.MissingMethodException.getMessage(MissingMethodException.java:55)
	at java.lang.Throwable.getLocalizedMessage(Throwable.java:267)
	at java.lang.Throwable.toString(Throwable.java:343)
	at java.lang.String.valueOf(String.java:2826)
	at java.lang.StringBuilder.append(StringBuilder.java:115)
	at groovy.ui.GroovyMain.run(GroovyMain.java:340)
	at groovy.ui.GroovyMain.process(GroovyMain.java:315)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:112)
	at groovy.ui.GroovyMain.main(GroovyMain.java:93)
	... 6 more
{code}

",,lhotari,olandere,paulk,tim_yates,trygvea,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/Aug/11 03:51;tim_yates;Groovy4857Bug.groovy;https://issues.apache.org/jira/secure/attachment/12722870/Groovy4857Bug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Sep 23 10:02:29 UTC 2011,,,,,,,,,,"0|i2cqnb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Aug/11 03:37;tim_yates;I think the patch needs to go into {{org/codehaus/groovy/runtime/ConvertedMap.java}}

This catches the {{toString()}} instance, but there must be a nicer way of catching all of the base methods of {{Object}} (if they don't exist as closures in the Map itself)

{code:none}
Index: src/main/org/codehaus/groovy/runtime/ConvertedMap.java
===================================================================
--- src/main/org/codehaus/groovy/runtime/ConvertedMap.java	(revision 22732)
+++ src/main/org/codehaus/groovy/runtime/ConvertedMap.java	(working copy)
@@ -42,6 +42,9 @@
             throws Throwable {
         Map m = (Map) getDelegate();
         Closure cl = (Closure) m.get(method.getName());
+        if( cl == null && ""toString"".equals(method.getName() ) ) {
+            return m.toString() ;
+        }
         if (cl == null) {
             throw new UnsupportedOperationException();
         }
{code};;;","03/Aug/11 03:51;tim_yates;Attached Test case which goes in {{src/test/groovy/bugs}};;;","11/Sep/11 13:17;trygvea;I suggest this is a blocker - it makes familiar constructs like 
{code}
[run: {}] as Runnable
{code}
fail.
;;;","23/Sep/11 10:02;tim_yates;Added a test for the Runnable failing example:

{code:none}
diff --git a/src/test/groovy/bugs/Groovy4857Bug.groovy b/src/test/groovy/bugs/Groovy4857Bug.groovy
index 3b20426..b6f8a62 100644
--- a/src/test/groovy/bugs/Groovy4857Bug.groovy
+++ b/src/test/groovy/bugs/Groovy4857Bug.groovy
@@ -38,5 +38,12 @@ class Groovy4857Bug extends GroovyTestCase {
             assert e.class.name == 'groovy.lang.MissingMethodException'
         }
     }
+
+    void testTrygveAmundsensExample() {
+        def val = new GroovyShell().evaluate """"""
+            [run: {}] as Runnable
+        """"""
+        assert val instanceof Runnable
+    }
{code}

Which works now on trunk (or should that be 'master' now we're using git?) :-);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MyEnum.values() bombs out on AppEngine,GROOVY-4854,12815683,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,guillaume,axel.fontaine,axel.fontaine,31/May/11 18:13,21/Jul/11 19:06,14/Jul/23 06:00,16/Jun/11 07:27,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,1.9-beta-1,,,,,,0,,,,,,"Calling MyEnum.values() works great on the AppEngine local development server, but once this code runs in production you get:
{noformat}
java.lang.IllegalAccessException: Reflection is not allowed on protected native java.lang.Object java.lang.Object.clone() throws java.lang.CloneNotSupportedException
	at com.google.appengine.runtime.Request.process-d87840548eba2c93(Request.java)
	at java.lang.reflect.Method.invoke(Method.java:43)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1055)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)
	at org.codehaus.groovy.runtime.callsite.PojoMetaClassSite.call(PojoMetaClassSite.java:44)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:112)
	at MyEnum.values(Environment.groovy)
	at MyEnum$values.call(Unknown Source)
{noformat}",AppEngine Java 1.5,axel.fontaine,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 05 08:12:17 UTC 2011,,,,,,,,,,"0|i2btmf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Jun/11 15:46;axel.fontaine;Enum.valueOf(type, value) also fails catastrophically with

java.lang.IllegalArgumentException: MyEnum is not an enum type
  at java.lang.Class.enumConstantDirectory(Class.java:2982)
  at java.lang.Enum.valueOf(Enum.java:209)


Again, this only happens on the AppEngine production system.;;;","05/Jun/11 04:28;blackdrag;I guess that means, that if we do the clone, then we should do that by using a direct method call instead. If we don't  use clone, then this is a AppEngine problem;;;","05/Jun/11 08:12;axel.fontaine;Moving the enum to src/main/java works, so it is a Groovy issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Constant Optimization is a little off,GROOVY-4852,12815713,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,melix,roshandawrani,roshandawrani,30/May/11 04:56,23/Feb/15 01:12,14/Jul/23 06:00,14/Jan/15 05:33,1.8.0,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.3.10,2.4.1,,class generator,,,,0,u,,,,,"{code}
class Test {
    static main(String[] args) {
        def x = 2.0
        def y = 2.0
        def z = 2.0
    }
}
{code}
For the code above, optimizer generates the code below which has the optimization for first constant wrong (it should also be Object x = $const$0).
{noformat}
  public static Object main(String[] args)
  {
    Object x = new BigDecimal(""2.0"");
    Object y = $const$0;
    Object z = $const$0;
  }
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-05-30 04:56:08.0,,,,,,,,,,"0|i2bpnj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NullPointerException on iterator() call,GROOVY-4851,12815704,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,trx,trx,28/May/11 19:39,12/Jun/17 00:12,14/Jul/23 06:00,17/May/17 15:39,1.7.10,1.8.0,1.8-rc-3,1.8-rc-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.0-beta-1,,,groovy-runtime,,,,0,,,,,,"I got with the following code which use http://sourceforge.net/projects/picard/files/picard-tools/  
{code}
import net.sf.picard.util.Interval 
import net.sf.picard.util.IntervalList 
import net.sf.picard.util.SamLocusIterator 
import net.sf.picard.util.SamLocusIterator.RecordAndOffset 
import net.sf.samtools.SAMFileHeader 
import net.sf.samtools.SAMFileReader 
import net.sf.samtools.SAMFileReader.ValidationStringency 

bamFile = new File(""/media/trx/workspace/Picard/test/ex1.bam"") 
baiFile = new File(bamFile.getAbsolutePath() + "".bai"") 

sam = new SAMFileReader(bamFile, baiFile, true) 

sam.setValidationStringency(ValidationStringency.SILENT) 
if(!sam.hasIndex()) throw new Exception(""Missing index"") 

SAMFileHeader header = sam.getFileHeader() 

sequences = header.getSequenceDictionary().getSequences() 

for ( i in sequences) { 
        println(""${i.getSequenceName()} = ${i.getSequenceLength()}"") 
} 

IntervalList il = new IntervalList(header) 
il.add(new Interval(""chr1"",0, 157)) 
final SamLocusIterator sli = new SamLocusIterator(sam, il, true) 
sli.setEmitUncoveredLoci(false) 

sli.each { li -> 
        println li.getSequenceName() 
} 
{code}
I got the following error: 
{code}
chr1 = 1575 
chr2 = 1584 
WARNING	2011-04-30 12:10:29	SamLocusIterator	SamLocusIterator constructed with samReader that has SortOrder == unsorted.  Assuming SAM is coordinate sorted, but exceptions may occur if it is not. 
Exception in thread ""main"" java.lang.NullPointerException 
        at net.sf.picard.util.SamLocusIterator.samHasMore(SamLocusIterator.java:223) 
        at net.sf.picard.util.SamLocusIterator.hasNext(SamLocusIterator.java:231) 
        at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1219) 
        at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1196) 
        at org.codehaus.groovy.runtime.dgm$110.invoke(Unknown Source) 
        at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:270) 
        at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:52) 
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40) 
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116) 
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124) 
        at pileup.run(pileup.groovy:33) 
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) 
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
        at java.lang.reflect.Method.invoke(Method.java:616) 
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90) 
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233) 
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1058) 
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886) 
        at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:793) 
        at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:776) 
        at org.codehaus.groovy.runtime.InvokerHelper.runScript(InvokerHelper.java:394) 
        at org.codehaus.groovy.runtime.InvokerHelper$runScript.call(Unknown Source) 
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40) 
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116) 
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:128) 
        at pileup.main(pileup.groovy) 
{code}

The following code is written completely in Java and uses the same input file without any error: 
{code}
import java.io.File; 
import java.util.List; 
import net.sf.picard.util.Interval; 
import net.sf.picard.util.IntervalList; 
import net.sf.picard.util.SamLocusIterator; 
import net.sf.picard.util.SamLocusIterator.LocusInfo; 
import net.sf.picard.util.SamLocusIterator.RecordAndOffset; 
import net.sf.samtools.SAMFileHeader; 
import net.sf.samtools.SAMFileReader; 
import net.sf.samtools.SAMRecord; 
import net.sf.samtools.SAMRecordIterator; 
import net.sf.samtools.SAMSequenceRecord; 
import net.sf.samtools.SAMFileReader.ValidationStringency; 


public class ReadReferenceName { 

        /** 
         * @param args 
         * @throws Exception 
         */ 
        public static void main(String[] args) throws Exception { 
                // TODO Auto-generated method stub 
                
                File bamFile = new File(""/media/trx/workspace/Picard/test/ex1.bam""); 
                File baiFile = new File(bamFile.getAbsolutePath() + "".bai"");	
                
                SAMFileReader sam = new SAMFileReader(bamFile, baiFile, true); 
        sam.setValidationStringency(ValidationStringency.SILENT); 
                if(!sam.hasIndex()) throw new Exception(""Missing index""); 
                
                SAMFileHeader header = sam.getFileHeader(); 
                List<SAMSequenceRecord> sequences = header.getSequenceDictionary().getSequences(); 
                
                for(SAMSequenceRecord rec: sequences) { 
                        System.out.println(rec.getSequenceName() + "" = "" + 
                                        rec.getSequenceLength()); 
                } 
                
                IntervalList il = new IntervalList(header); 
                il.add(new Interval(""chr1"",0, 157)); 
        final SamLocusIterator sli = new SamLocusIterator(sam, il, true); 
        sli.setEmitUncoveredLoci(false); 
      
        for (final SamLocusIterator.LocusInfo li : sli) { 
        String sequenceName = li.getSequenceName(); 
        int pos = li.getPosition(); 
        int coverage = li.getRecordAndPositions().size(); 
        System.out.println(sequenceName + "" coverage at base "" + pos + "" = "" 
        + coverage); 
        for (int i = 0; i< coverage; i++){ 
        RecordAndOffset rec = li.getRecordAndPositions().get(i); 
        char base = (char)rec.getReadBase(); 
        String readName = rec.getRecord().getReadName(); 
        System.out.println(""  base in read "" + readName + "" = "" + base);	
        } 
        } 
        } 
} 
{code}

and it produced this output: 

{code}
chr1 = 1575 
chr2 = 1584 
WARNING	2011-04-30 19:30:07	SamLocusIterator	SamLocusIterator constructed with samReader that has SortOrder == unsorted.  Assuming SAM is coordinate sorted, but exceptions may occur if it is not. 
chr1 coverage at base 100 = 1 
  base in read EAS56_57:6:190:289:82 = A 
chr1 coverage at base 101 = 1 
... 
{code}

Tim Yates wrote the following work around for this problem:

{code}
import net.sf.picard.util.*
import net.sf.picard.util.SamLocusIterator.RecordAndOffset
import net.sf.samtools.*
import net.sf.samtools.SAMFileReader.ValidationStringency
import net.sf.picard.filter.*
import net.sf.samtools.util.CloseableIterator

bamFile = new File(""ex1.bam"")
baiFile = new File(""ex1.bam.bai"")

sam = new SAMFileReader(bamFile, baiFile, true)
sam.validationStringency = ValidationStringency.SILENT
if(!sam.hasIndex()) throw new Exception(""Missing index"")

SAMFileHeader header = sam.fileHeader
sequences = header.sequenceDictionary.sequences

sequences.each { i ->
  println ""$i.sequenceName = $i.sequenceLength""
}

SamLocusIterator.metaClass.iterator = {
  if ( delegate.@samIterator != null ) {
    throw new IllegalStateException(""Cannot call iterator() more than once on SamLocusIterator"");
  }
  CloseableIterator<SAMRecord> tempIterator;
  if (delegate.@intervals != null) {
    tempIterator = new SamRecordIntervalIteratorFactory().makeSamRecordIntervalIterator(delegate.@samReader, delegate.@intervals, delegate.@useIndex);
  } else {
    tempIterator = delegate.@samReader.iterator();
  }
  if (delegate.@samFilters != null) {
    tempIterator = new FilteringIterator(tempIterator, new AggregateFilter(delegate.@samFilters));
  }
  delegate.@samIterator = new PeekableIterator<SAMRecord>( tempIterator )
  delegate 
}

IntervalList il = new IntervalList( header )
il.add( new Interval( ""chr1"", 0, 157 ) )
SamLocusIterator sli = new SamLocusIterator( sam, il, true )
sli.emitUncoveredLoci = false

sli.each { li ->
  println ""$li.sequenceName coverage at base $li.position = ${li.recordAndPositions.size()}""
  (0..<li.recordAndPositions.size()).each { i ->
    rec = li.recordAndPositions.get( i )
	println ""  base in read $rec.record.readName = $rec.readBase""
  }
}
{code}

More information can be found here ( http://groovy.329449.n5.nabble.com/NullPointerException-problem-td4360426.html )",Linux Mint 10,blackdrag,jkemnade,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7937,,,,,,,,,,,,,,,"02/Sep/13 03:09;blackdrag;GROOVY-4851.patch;https://issues.apache.org/jira/secure/attachment/12723230/GROOVY-4851.patch","28/May/11 19:39;trx;ex1.bam;https://issues.apache.org/jira/secure/attachment/12722882/ex1.bam","28/May/11 19:39;trx;ex1.bam.bai;https://issues.apache.org/jira/secure/attachment/12722854/ex1.bam.bai",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Wed May 17 15:39:32 UTC 2017,,,,,,,,,,"0|i2c7gv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"30/May/11 03:05;melix;Formatting tags;;;","15/Jun/12 09:39;blackdrag;After further investigation I found this minimal example to reproduce the problem:{code:Java}
class X implements Iterable, Iterator {
    Iterator iterator() {null}
    boolean hasNext(){true}
    def next(){}
    void remove(){}
}


def x = new X()
assert x.iterator() == null
{code}
the call to iterator() will not call the declared method, instead it will call the our Iterator#iterator method in DGM. If you remove the Iterator interface it works just fine, so it is only reproducable with both interfaces present;;;","15/Jun/12 09:40;blackdrag;reducing the level of this bug, since it is not a common problem and depends on the special occasion of an Itarable being also an Iterator;;;","15/Jun/12 09:43;blackdrag;it must be something in generating the method list for this class, that makes things go wrong. DGM has the ability to shadow methods of the class, but here it is from an interface and the class implementation should take precedence ;;;","24/Dec/12 03:59;paulk;tagging for review for 2.1.0-rc-1 otherwise we should reassign fix version;;;","02/Sep/13 03:09;blackdrag;The attached patch seems to fix the issue, but creates new problems with getMetaClass(). For me it currently looks like a this.getMetaClass() is currently tending to call the DGM version of this, instead of the local getter method. The fix changes this, but that of course breaks some things here and there (35 meta class related failures)

Due to those failures I think it is not appropriate to have this in Groovy 2.x and the fix has to wait for Groovy 3 instead;;;","02/Sep/13 03:10;blackdrag;Setting new fix version to 3.0;;;","17/May/17 11:02;jkemnade;This is fixed in 2.5.0-alpha-1 via GROOVY-7937.;;;","17/May/17 15:39;jwagenleitner;Thanks Michal for reporting the issue and thanks to Jochen K. for confirming the fix.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@ToString should use getX() rather than the field x when getting property values,GROOVY-4844,12815686,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,25/May/11 22:32,07/Apr/15 19:06,14/Jul/23 06:00,26/May/11 17:32,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,,,,,0,,,,,,"I expect the following example to work:
{code}
@TupleConstructor @ToString class Point { int x, y }
def p1 = new Point(1, 2)
def p2 = new Point(1, 1) { int getY() { 2 } }
assert p1.toString() == 'Point(1, 2)'
assert p2.toString() == 'Point(1, 2)'
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-05-25 22:32:46.0,,,,,,,,,,"0|i2bmkn:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Null BigDecimals converted to String with add operator,GROOVY-4841,12815699,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mcantrell,mcantrell,24/May/11 15:15,07/Feb/12 06:32,14/Jul/23 06:00,07/Feb/12 06:32,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,,,,,1,breaking,,,,,"Using the add operator on null BigDecimal objects concatenates them as Strings

{code:java}
  @Test
  void testNullBigDecimalAddOperator() {
    BigDecimal a = null
    BigDecimal b = null
    assert null == a+b
  }
{code}

{noformat}
Assertion failed: 

assert null == a+b
            |  |||
            |  ||null
            |  |nullnull
            |  null
            false
{noformat}

I would expect a NullPointer would be thrown as the divide operator behaves. 


{code:java}
  @Test(expected=NullPointerException)
  void testNullBigDecimalDivOperator() {
    BigDecimal a = null
    BigDecimal b = null
    assert null == a/b
  }
{code}

{noformat}
java.lang.NullPointerException: Cannot invoke method div() on null object
{noformat}",,gorshing,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 07 06:32:23 UTC 2012,,,,,,,,,,"0|i2cn2f:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"24/May/11 15:24;blackdrag;at the time of invocation of the plus method it does not matter what type you statically declared for the types. We always take the runtime types and since null has none really, we take NullObject instead. So this issue is not about BigDecimal#plus, but about NullObject#plus. This method now basically does: ""null""+b leading to the ""nullnull"" you have observed.
We can of course do a special case for null+null, but you actually want a NPE for the cases of any of the operands null, or not? That would break code.
So I kind of tend to close this issue as ""Won't Fix"".;;;","24/May/11 17:24;mcantrell;I think you're correct. A NPE probably wouldn't be the best option. I still think that the conversion to a string is problematic. Maybe null + null = null would be better?;;;","24/May/11 20:45;mcantrell;I think a better testcase would be 

{code:java}
  @Test
  void testNullBigDecimalAddOperator() {
    BigDecimal a = null
    BigDecimal b = null
    BigDecimal c = a+b
  }
{code}

{panel}
GroovyCastException: Cannot cast object 'nullnull' with class 'java.lang.String' to class 'java.math.BigDecimal'
{panel}
;;;","09/Nov/11 15:41;dirkw;I've added a bugfix and opened a pull-request in github. The solution will extend the plus-method of NullObject: if another NullObject has been passed, a null-reference will be returned. Also added the test of Mike Cantrell to NullObjectTest.;;;","31/Jan/12 09:29;blackdrag;I have been thinking about this one for a while and I think we should go a different way. Why is there a plus(String) method? It is there because we want null+""X"" return something for us useful. But since it is the only plus method it will be called even if that null value is supposed to be a BigDecimal. This is surely not what we want. The alternative solution would be to provide a plus(Object) method, which then for example throws an NullPointerException. Then Mike's example would cause a NPE instead of producing a strange String. It would also cause a+b not to work anymore if both are supposed to be String. But maybe that is not too bad.;;;","06/Feb/12 03:31;blackdrag;since the nature of the change I am going to do has a potential to break 1.8 code I will do this fix for 2.0 only.;;;","07/Feb/12 06:32;blackdrag;I implemented it that way now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
LogASTTransformation fails if super class defines a private log field,GROOVY-4840,12818083,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,hamletdrc,ipsi,ipsi,24/May/11 00:21,21/Jul/11 19:06,14/Jul/23 06:00,25/May/11 09:31,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,1.9-beta-1,,groovy-jdk,,,,0,,,,,,"Given a Java class which has a private static final Log log = ... field, I find that I cannot apply the @Commons annotation (or, indeed, any other logging annotation) to a subclass without specifying a name other than 'log'. That seems a bit absurd - the sub-classes shouldn't be able to access the super-class log, as it is private. And, indeed, attempting to run code which accesses the private super-class 'log' variable fails with a 'groovy.lang.MissingPropertyException'.

The fix for this would be to check if the owning class of the field (which is acquired on line 81 of LogASTTransformation.groovy) is the one we are currently processing. If so, then fail it. Otherwise, only fail it if the field is non-private - Package, Protected, or Public.",,ipsi,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 25 09:43:35 UTC 2011,,,,,,,,,,"0|i2cb27:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/May/11 09:31;hamletdrc;fixed in the trunk and 1.8.x branch. You may want to double check my ""fixed versions"" field to make sure it is correct. ;;;","25/May/11 09:43;guillaume;Fix versions should be 1.8.1 and 1.9-beta-1, since they will be the next available releases of those two branches.
Thanks for the fix Hamlet!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Class that extends ClassLoader compiled with JDK 1.5 fails to run on JDK 1.6 with IncompatibleClassChangeError,GROOVY-4838,12815569,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,graemerocher,graemerocher,23/May/11 03:36,26/Nov/13 14:50,14/Jul/23 06:00,25/Nov/13 08:45,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0,,,,,,,4,,,,,,"We have a class loader like this:


{code}
class ParentOnlyClassLoader extends ClassLoader{

    ParentOnlyClassLoader(ClassLoader parent) {
        super(parent)
    }

    @Override protected Class<?> findClass(String name) {
        parent.findClass(name)
    }

}
{code}

When this class is compiled with JDK 1.5 then executed in JDK 1.6 you get the error:

{code}
java.lang.IncompatibleClassChangeError: the number of constructors during runtime and compile time for java.lang.ClassLoader do not match. Expected 2 but got 3
	at org.grails.plugins.tomcat.ParentOnlyClassLoader.<init>(ParentOnlyClassLoader.groovy:28)
	at org
{code}",,blackdrag,dmurat,jstoneham,lhotari,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 22 06:01:04 UTC 2013,,,,,,,,,,"0|i2bzvr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/May/11 04:26;blackdrag;the important part is not so much waht exact constructors there are in ParentOnlyClassLoader, but what there is in java.lang.ClassLoader. As it seems, at elast on some JDKs, there is an additional private constructor that wrongly gets included here. If we fix that part, then all code compiled with 1.8.0 and before may have a problem. Also it is no final solution. Should the parent class gain a new non-private constructor, for example because of refactoring, this problem will reappear;;;","31/Oct/11 09:04;jasona@blazetrail.ca;This occurs also with code compiled in JDK 6 when running in JDK 7.   Groovy 1.8.2

eg. make a Groovy class that extends from Throwable or Exception, and try to run it on JDK 7 and it will get the constructors/runtime error.   JDK 7 added some additional protected constructors.

;;;","03/May/12 14:19;dmoshal;Just ran into this with Groovy 1.8.6 / JDK 7 / OSX
;;;","21/Jan/13 14:18;pschumacher;Reading blackdrags comments I guess this should be closed.;;;","22/Jan/13 06:01;blackdrag;Thanks for digging this one out, it will save me the trouble to find it later again.
I do intend to create a new solution for this in which the available constructors are stored as MethodType[] and are given to the runtime to choose from those, instead of the runtime available list of constructors. Possibly I let the runtime filter out the signatures that don't exist anymore. That way there is a good chance a problem like described in the issue here will not appear again;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Field AST Transformation looses annotations,GROOVY-4833,12815693,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,18/May/11 17:08,25/Apr/13 05:09,14/Jul/23 06:00,18/May/11 17:19,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,1.9-beta-1,,,,,,0,,,,,,"For reference : http://groovy.329449.n5.nabble.com/Revisiting-guice-injection-with-Groovy-1-8-td4387777.html

The @Field AST transformation creates a FieldNode but forgets to put the other possible annotations on the generated field. For example, in the following code :

{code}
@Awesome @Field def test
{code}

The @Awesome annotation is lost.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6112,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 18 17:19:16 UTC 2011,,,,,,,,,,"0|i2bw4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/May/11 17:19;melix;Fixed on trunk and 1.8.1;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"when two java classes extend a groovy class, both subclasses have a metaClass for whichever subclass was loaded first",GROOVY-4832,12818087,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,lgdean,lgdean,18/May/11 15:34,04/Sep/11 15:00,14/Jul/23 06:00,04/Sep/11 15:00,1.7.10,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.2,1.9-beta-3,,,,,3,,,,,,"*Original problem:*

I have an abstract groovy class, and two (or more) concrete java subclasses extend it.  The superclass has an abstract method, which each concrete subclass overrides (of course).

When I use just one subclass, everything works fine: I call a superclass method that calls the abstract method, and I get the behavior I expect.  But when the other subclass has already been loaded, things are different.  Then, I get an IllegalArgumentException: object is not an instance of declaring class.

This problem corresponds to testGenericSubclassWithBafflingSymptom() in the attached junit tests.  See that test for additional details.

*Simpler case that illustrates the likely underlying problem (and does not involve generics):*

I have an abstract groovy class, and two concrete java subclasses extend it.  If I have an instance of just one of the subclasses, then instance.metaClass.theClass returns exactly what I expect.  But if I've already loaded the other subclass, then the metaClass on an instance of *either* subclass is for the class that was used first!

{code:java}
// snippet of the groovy version of testSubclass(), also attached
      OtherConcreteJavaSubclass unrelatedInstance = new OtherConcreteJavaSubclass();
      ConcreteJavaSubclass instance = new ConcreteJavaSubclass();
      assertEquals(""this one works"", OtherConcreteJavaSubclass, unrelatedInstance.metaClass.theClass)
      assertEquals(""but this one is wrong"", ConcreteJavaSubclass, instance.metaClass.theClass)
{code}


This mixture of groovy and java may sound a little odd, but we actually ran into it when converting an existing class from java to groovy, and it stumped us for quite a while.",WinXP,alexhen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/May/11 15:34;lgdean;groovy-subclass-project.zip;https://issues.apache.org/jira/secure/attachment/12722881/groovy-subclass-project.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 04 15:00:03 UTC 2011,,,,,,,,,,"0|i2clrr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"13/Jul/11 18:37;alex.heneveld;This bit us as well--as it manifests subtly, because unit tests pass when run in isolation but once both classes are loaded the same code will throw the exception mentioned above:

{code}
java.lang.IllegalArgumentException: object is not an instance of declaring class
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:226)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:145)
	at instance.methodFromGroovySuperclass
{code}

Suggest high priority as this takes a long time to track down and mixing Java and Groovy will be common in a large team.

The simple *workaround* we use is to put the following in the groovy superclass constructor (getting the metaclass of the java subclass, curiously, seems to work):

{code}
setMetaClass(DefaultGroovyMethods.getMetaClass(getClass()))
{code}
;;;","18/Jul/11 17:43;blackdrag;closed wrong issue
;;;","02/Sep/11 17:35;blackdrag;when I wrote the only place it could be going wrong, the method $getStaticMetaClass from bytecode to Java, I came up with this:
{code:Java}
protected MetaClass $getStaticMetaClass() {
  if (this.getClass()!=A.class) {
    return ScriptBytecodeAdapter.initMetaClass(this)
  } else {
    ClassInfo ci = A.$staticClassInfo
    if (ci==null) {
      ci = ClassInfo.getClassInfo(this.getClass())
      A.$staticClassInfo = ci
    }
    return ci.getMetaClass()
  }
}
{code}
compiling this to bytecode and comparing it with the actual bytecode revealed, that my translation to Java is wrong. In the byteocde
{code}
   protected $getStaticMetaClass()Lgroovy/lang/MetaClass;
     ALOAD 0
     INVOKEVIRTUAL java/lang/Object.getClass ()Ljava/lang/Class;
     INVOKESTATIC A.$get$$class$A ()Ljava/lang/Class;
     IF_ACMPNE L0
     ALOAD 0
     INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.initMetaClass (Ljava/lang/Object;)Lgroovy/lang/MetaClass;
     ARETURN
    L0
     GETSTATIC A.$staticClassInfo : Lorg/codehaus/groovy/reflection/ClassInfo;
     ASTORE 1
     ALOAD 1
     IFNONNULL L1
     ALOAD 0
     INVOKEVIRTUAL java/lang/Object.getClass ()Ljava/lang/Class;
     INVOKESTATIC org/codehaus/groovy/reflection/ClassInfo.getClassInfo (Ljava/lang/Class;)Lorg/codehaus/groovy/reflection/ClassInfo;
     DUP
     ASTORE 1
     PUTSTATIC A.$staticClassInfo : Lorg/codehaus/groovy/reflection/ClassInfo;
    L1
     ALOAD 1
     INVOKEVIRTUAL org/codehaus/groovy/reflection/ClassInfo.getMetaClass ()Lgroovy/lang/MetaClass;
     ARETURN
     MAXSTACK = 2
     MAXLOCALS = 2
{code}
the IF_ACMPNE should be a IF_ACMPEQ. Doing this change makes the tests in the attached project pass, while it does not without. IF_ACMPNE means we don't do this.getClass()!=A.class, we do this.getClass()==A.class and then it becomes clear that the code above makes no sense like this.;;;","04/Sep/11 15:00;blackdrag;I corrected the coe as stated before, would be nice if people could test this;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
New line character is not escaped in attribute when using MarkupBuilder,GROOVY-4831,12815677,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jakub.neubauer,jakub.neubauer,18/May/11 06:33,21/Jul/11 19:06,14/Jul/23 06:00,23/May/11 17:12,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,XML Processing,,,,0,,,,,,"For example:
{code}
import groovy.xml.*
def xml = new MarkupBuilder()
xml.test(a:""hello\nworld""){}
{code}

produces output:
{code:xml}
<test a='hello
world' />
{code}

But xml specification says that when parsing, new lines in attribute value should be converted to single space. So they are not preserved.

I suggest this new method implementation (sorry that I don't provide real .patch):
{code}
    private String checkForReplacement(boolean isAttrValue, char ch) {
        switch (ch) {
            case '&':
                return ""&amp;"";
            case '<':
                return ""&lt;"";
            case '>':
                return ""&gt;"";
            case '""':
                // The double quote is only escaped if the value is for
                // an attribute and the builder is configured to output
                // attribute values inside double quotes.
                if (isAttrValue && useDoubleQuotes) return ""&quot;"";
                break;
            case '\'':
                // The apostrophe is only escaped if the value is for an
                // attribute, as opposed to element content, and if the
                // builder is configured to surround attribute values with
                // single quotes.
                if (isAttrValue && !useDoubleQuotes) return ""&apos;"";
                break;
            case '\n':
                if(isAttrValue) return ""&#10;"";
            case '\r':
                if(isAttrValue) return ""&#13;"";
        }
        return null;
    }
{code}
",,jakub.neubauer,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/May/11 06:39;jakub.neubauer;MarkupBuilder.java.patch;https://issues.apache.org/jira/secure/attachment/12722807/MarkupBuilder.java.patch","20/May/11 06:12;jakub.neubauer;repair.txt;https://issues.apache.org/jira/secure/attachment/12722808/repair.txt",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon May 23 17:12:32 UTC 2011,,,,,,,,,,"0|i2c3hj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/May/11 06:39;jakub.neubauer;My previous comment was mangled, so I rather try to attach a patch.;;;","18/May/11 07:41;blackdrag;But if you say the spec says ""new lines in attribute value should be converted to single space"" and then produce &#10;, isn't that wrong? would you want to use "" ""?;;;","19/May/11 00:15;paulk;Do you have a link to the relevant part of the spec?;;;","19/May/11 01:20;jakub.neubauer;The link to spec is: http://www.w3.org/TR/xml/#AVNormalize

It says when parsing, white space characters #x20, #xD, #xA, #x9 should be converted to #x20 (space). Then, all leading and trailing spaces are removed and all sequences of spaces are merged to one space.

So, now I see that my patch is not enough. The generator should also convert spaces and tabs to their escape sequences, assuming that attribute value should be preserved exactly as is after parsing it back.

To Jochen: we probably didn't understand each other. The normalizing attribute value occurs in XML parser. I expect that generating xml and parsing it back should provide the same values. But if you generate XML with attribute value containing new line, parse it back, you get a space.
;;;","19/May/11 06:23;paulk;Should be fixed in trunk. I ended up using a slightly tweaked version of your patch. If you can try both {{MarkupBuilder}} and {{StreamingMarkupBuilder}} using one of the CI server produced snapshots, that would be great. Thanks for spotting the problem.;;;","20/May/11 02:51;jakub.neubauer;Sorry, but in later comment I stated that TAB and SPACE characters should be escaped too ('\t' -> ""&\#9;"" and ' ' -> ""&\#32""). For the same reasons as \n and \r.;;;","20/May/11 05:53;paulk;I am wondering whether I am totally following what you would like. Are you wanting the first or second line:
{code}
\t -> &#9;
\t -> &amp;#9;
{code}
because I am wondering whether even the earlier changes are want you wanted?
;;;","20/May/11 06:12;jakub.neubauer;The first line is what I meant, and similarly for SPACE. To be sure, I attach a code snippet from MarkupBuilder.java, it is most precise after all :-);;;","20/May/11 07:19;paulk;That is what you said before - I would be worried about us producing ""non-standard"" looking XML. Can you elaborate a bit more on what kind of round-tripping you are trying to enable?;;;","23/May/11 02:17;jakub.neubauer;Hello, I went through the spec again (few times) and tried another libraries(Java DOM, Transformer, SAX Parser). I realized that I made mistake concerning a SPACE character. It can be produced as is. I was mistaken by this part of spec:

bq. If the attribute type is not CDATA, then the XML processor MUST further process the normalized attribute value by discarding any leading and trailing space (#x20) characters, and by replacing sequences of space (#x20) characters by a single space (#x20) character.

But, 2 paragraphs later:

bq. All attributes for which no declaration has been read SHOULD be treated by a non-validating processor as if declared CDATA.

So, SPACES don't need to be produced as escape sequences. I tried groovy.xml.XMLParser and it keeps them as they are.

So, only TAB character should be escaped. This is test, which should pass:

{code}
import groovy.xml.*

doTest(""  hello  world  "") //  (1)
doTest(""hello\nworld"")     //  (2)
doTest(""hello\rworld"")     //  (3)
doTest(""hello\tworld"")     //  (4)

def doTest(String value) {
  StringWriter w = new StringWriter()
  new MarkupBuilder(w).root(a:value)
  xml2 = new XmlParser().parseText(w.toString())
  assert value == xml2.@a
}
{code}

Original version fails in parts (2), (3) and (4), after your changes it still fails in part (4). The part (1) passes, which is confirmation of what I said in this comment.
;;;","23/May/11 17:12;paulk;Tab is now escaped too. Thanks for all the feedback and information.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@EqualsAndHashCode.excludes doesn't work correctly with class inheritance,GROOVY-4827,12818082,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pawlom,pawlom,16/May/11 13:04,21/Jul/11 19:06,14/Jul/23 06:00,29/May/11 05:18,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,,,,,0,,,,,,"I cannot inherit exclusions of EqualsAndHashCode, I have to duplicate exclusions in every child class.
Please see the tescase, only testA() and testE() pass.

{code}
class EqualsTest {
    @EqualsAndHashCode(excludes = 'a1')
    static class A {
        def a1, a2;
    }

    @Test
    void testA() {
        assert new A(a1: 'same', a2: 'same') == new A(a1: 'same', a2: 'same') // ok
        assert new A(a1: 'diff', a2: 'same') == new A(a1: 'erent', a2: 'same') // ok
    }

    static class B extends A {
        def b
    }

    @Test
    void testB() {
        assert new B(a1: 'diff', a2: 'same', b: 'same') == new B(a1: 'erent', a2: 'same', b: 'same')
        // failed! Shouldn't equals() be inherited from A?
    }

    //ok. let's try to specify explicitly that we call super.equals()
    @EqualsAndHashCode(callSuper = true)
    static class C extends A {
        def c
    }

    @Test
    void testC() {
        assert new C(a1: 'diff', a2: 'same', c: 'same') == new C(a1: 'erent', a2: 'same', c: 'same')
        // failed!
    }

    //hm. what about excluding it again in the child class?
    @EqualsAndHashCode(callSuper = true, excludes = 'a1')
    static class D extends A {
        def d
    }

    @Test
    void testD() {
        assert new D(a1: 'diff', a2: 'same', d: 'same') == new D(a1: 'erent', a2: 'same', d: 'same')
        // failed!
    }

    //hm. should I forget about inheritance??
    @EqualsAndHashCode(excludes = 'a1')
    static class E extends A {
        def e
    }

    @Test
    void testE() {
        assert new E(a1: 'diff', a2: 'same', e: 'same') == new E(a1: 'erent', a2: 'same', e: 'same')
        // YES :(
    }

}
{code} ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/May/11 13:04;pawlom;equalsExcludes.groovy;https://issues.apache.org/jira/secure/attachment/12722851/equalsExcludes.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 29 05:18:18 UTC 2011,,,,,,,,,,"0|i2bx9b:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"25/May/11 04:48;paulk;There is no intention to allow exclusions from properties inherited from super classes. By using 'callSuper' you get to decide whether the identity as defined in the base class (already specified by its equals and hashCode methods) are important to you or not. Having said that, your examples reveal a bug in how callSuper is working. This came about when we made the implementation of equals stricter to ensure that the equals contract was always fulfilled evening when using inheritance. We will probably alter the implementation to use a canEqual method ala project Lombok 0.10+ or Scala case classes - so that it will work properly for inheritance but also for JPA proxy classes which also use inheritance but only as an implementation detail. We might make this an option or configurable to some extent.

Reference to an explanation of what we would probably implement:
http://www.artima.com/lejava/articles/equality.html

We would probably have a ""useCanEqual"" flag which defaults to true and results in a public ""canEqual"" method being defined as per the above article (and project lombok 0.10+ and recent scala case classes). If you set the ""useCanEqual"" flag to false you will get the current implementation which compares getClass() and you won't pollute the class with a ""canEqual"" method but the following won't return true (and ditto for JPA proxy instances) which most people would expect to work:
{code}
@Canonical class Point { def x, y }
assert new Point(1, 2) == new Point(1, 1) { def getY() { 2 } }
{code}
;;;","29/May/11 05:18;paulk;This should be fixed. Thanks for spotting this. Please let me know if you observe any strange behavior with this functionality.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler Errors for @Immutable,GROOVY-4825,12818407,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,peter.rietzler@smarter-ecommerce.com,peter.rietzler@smarter-ecommerce.com,16/May/11 04:02,04/Aug/11 15:51,14/Jul/23 06:00,04/Aug/11 15:51,1.7.10,1.7.8,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,,,,,1,,,,,,"{code}
@Immutable
class X {
  int a	
}
{code}

Leads to (groovy 1.7.10, executed using gradle)

{noformat}
java.lang.RuntimeException: Explicit constructors not allowed for @Immutable class: X
	at org.codehaus.groovy.transform.ImmutableASTTransformation.createConstructor(ImmutableASTTransformation.java:308)
	at org.codehaus.groovy.transform.ImmutableASTTransformation.visit(ImmutableASTTransformation.java:117)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:129)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:172)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:942)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:519)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:497)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:474)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:453)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:67)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:180)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:148)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:162)
{noformat}

{code}
@Immutable
class X {
}
{code}

Leads to (groovy 1.7.8.xx-20110426-1500-e36, eclipse)

{noformat}
Duplicate method X() in type X
{noformat} 


{code}
class Y {
  X x
}
{code}

Leads to (groovy 1.7.8.xx-20110426-1500-e36, eclipse)

{noformat}
General error during canonicalization: @Immutable processor doesn't know how to handle field 'x' of type 'playground.X' while compiling class playground.Y.
@Immutable classes currently only support properties with known immutable types or types where special handling achieves immutable behavior, including:
- Strings, primitive types, wrapper types, BigInteger and BigDecimal, enums
- other @Immutable classes and known immutables (java.awt.Color, java.net.URI)
- Cloneable classes, collections, maps and arrays, and other classes with special handling (java.util.Date)
Other restrictions apply, please see the groovydoc for @Immutable for further details
{noformat}


",Mac OS X,bunglefeet,paulk,rsaddey,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 05 03:30:39 UTC 2011,,,,,,,,,,"0|i2c7jb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/May/11 07:30;paulk;The following works fine for me in the GroovyConsole for 1.7.11-SNAPSHOT:
{code}
@Immutable
class X {
  int a
}

@Immutable
class Y {
  X x
}

println new Y(x:new X(a: 3))
// => Y(x:X(a:3))
{code}
Can you try the above? I am trying to reproduce the issue and suspect it is either version related or environment related but can't tell for sure just yet.
;;;","20/May/11 09:53;aalmiray;None of those cases fail with 1.8.0 (groovyConsole) nor with the groovy intepreter.;;;","20/May/11 13:41;blackdrag;I close the issue unless Peter finds the problem still exists and can provide a reproducable issue;;;","23/May/11 01:00;peter.rietzler@smarter-ecommerce.com;in the meantime we've switched our complete environment to 1.8.0 where everything works fine;;;","01/Jul/11 06:39;graemerocher;There is an example that reproduces the issue in this Grails JIRA:

http://jira.grails.org/browse/GRAILS-7205

It still impacts 1.8.0

Download the attach app and run it with Grails to see the error. If you wish to debug create a remote debugger and run 'grails-debug'. From my debugging the ClassNode is returning a constructor of ""<init>"" as being present which results in the exception being thrown.;;;","01/Jul/11 10:22;paulk;Grails compilation uses the Joint compiler. Currently, not all transforms are guaranteed to work with joint compilation. I have tweaked stub generation to not interfere with (the constructor creation part of) @Immutable. If you can test this out, that would be great. Only in 1.7.11-SNAPSHOT for now. Committed in subversion and should be available as a jar once the CI build finishes.;;;","02/Jul/11 06:56;paulk;Also merged into 1.8.1 and trunk;;;","05/Jul/11 03:30;graemerocher;Thanks will test it out;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.lang.MissingMethodException if using class extending BigDecimal,GROOVY-4823,12818096,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,uwekirsch,uwekirsch,12/May/11 06:47,09/Sep/11 08:08,14/Jul/23 06:00,09/Sep/11 08:08,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.3,1.9-beta-4,,,,,0,,,,,,"We have a class extending java.math.BigDecimal, also a method having a BigDecimal argument
The method works fine if we call it with a BigDecimal object. If the method is called with an instance of the extending class, a MissingMethodException is thrown.

groovy.lang.MissingMethodException: No signature of method: ConsoleScript16.f() is applicable for argument types: (ExtendedBigDecimal) values: [1]
Possible solutions: f(java.math.BigDecimal), is(java.lang.Object), run(), run(), any(), any(groovy.lang.Closure)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:54)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:78)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:44)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:149)
	at ConsoleScript16.run(ConsoleScript16:14)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:266)
	at groovy.lang.GroovyShell.run(GroovyShell.java:517)
	at groovy.lang.GroovyShell.run(GroovyShell.java:172)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:904)
	at sun.reflect.GeneratedMethodAccessor227.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:149)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor226.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:282)
	at groovy.lang.Closure.call(Closure.java:277)
	at groovy.lang.Closure.run(Closure.java:360)
	at java.lang.Thread.run(Thread.java:619)
","Windows XP SP3, Groovy 1.7.10",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/May/11 06:47;uwekirsch;bug.groovy;https://issues.apache.org/jira/secure/attachment/12722806/bug.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 09 08:08:12 UTC 2011,,,,,,,,,,"0|i2c1kv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"09/Sep/11 08:08;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Label before closure,GROOVY-4822,12815648,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,zhaber,zhaber,11/May/11 23:03,17/Dec/14 13:25,14/Jul/23 06:00,25/Oct/14 02:55,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,parser,,,,0,,,,,,"While this statement is compiled normally:

{var->} ({->it})

The following one causes the compile error:

label: {var->} ({->it})

expecting EOF, found '(' at line: 1, column: 16

",,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Oct 25 02:55:10 UTC 2014,,,,,,,,,,"0|i2brjb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"25/Oct/14 02:55;pschumacher;Examples compile on current master.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problems using Groovlet / GSP from embedded Jetty,GROOVY-4820,12815642,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mortenholm,mortenholm,10/May/11 04:05,22/Dec/12 01:10,14/Jul/23 06:00,05/Dec/12 03:13,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,,Groovlet / GSP,,,,0,,,,,,"I'm trying to use Groovlet / GSP from within an embedded Jetty, and it's not working for me.

I want to distribute my web application as a single jar-with-dependencies. So i start an embedded standalone Jetty that serves the webapplication from the jar-with-dependencies build with the assembly plugin.

When I try to load a GSP I get this stacktrace:

2011-05-10 10:50:47.168:WARN::/web/groovy/test.gsp
java.lang.NullPointerException
	at java.io.File.<init>(File.java:222)
	at groovy.servlet.AbstractHttpServlet.getScriptUriAsFile(AbstractHttpServlet.java:306)
	at groovy.servlet.TemplateServlet.service(TemplateServlet.java:377)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)
	at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:511)
	at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:401)
	at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)
	at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:182)
	at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:766)
	at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:450)
	at org.mortbay.jetty.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:230)
	at org.mortbay.jetty.handler.HandlerCollection.handle(HandlerCollection.java:114)
	at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)
	at org.mortbay.jetty.Server.handle(Server.java:326)
	at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542)
	at org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:928)
	at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:549)
	at org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:212)
	at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)
	at org.mortbay.jetty.bio.SocketConnector$Connection.run(SocketConnector.java:228)
	at org.mortbay.thread.QueuedThreadPool$PoolThread.run(QueuedThreadPool.java:582)

When I try to load the Groovlet I get this stacktrace:

2011-05-10 11:00:22.961:INFO:/:GroovyServlet Error:  script: '/web/groovy/test.groovy':  Script processing failed.nulljava.lang.String.startsWith(String.java:1421)
GroovyServlet Error:  script: '/web/groovy/test.groovy':  Script processing failed.nulljava.lang.String.startsWith(String.java:1421)
java.lang.NullPointerException
	at java.lang.String.startsWith(String.java:1421)
	at java.lang.String.startsWith(String.java:1450)
	at groovy.servlet.AbstractHttpServlet.getResourceConnection(AbstractHttpServlet.java:170)
	at groovy.util.GroovyScriptEngine.loadScriptByName(GroovyScriptEngine.java:450)
	at groovy.util.GroovyScriptEngine.createScript(GroovyScriptEngine.java:528)
	at groovy.util.GroovyScriptEngine.run(GroovyScriptEngine.java:515)
	at groovy.servlet.GroovyServlet$1.call(GroovyServlet.java:120)
	at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.use(GroovyCategorySupport.java:106)
	at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.access$400(GroovyCategorySupport.java:64)
	at org.codehaus.groovy.runtime.GroovyCategorySupport.use(GroovyCategorySupport.java:246)
	at groovy.servlet.GroovyServlet.service(GroovyServlet.java:129)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)
	at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:511)
	at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:401)
	at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)
	at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:182)
	at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:766)
	at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:450)
	at org.mortbay.jetty.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:230)
	at org.mortbay.jetty.handler.HandlerCollection.handle(HandlerCollection.java:114)
	at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)
	at org.mortbay.jetty.Server.handle(Server.java:326)
	at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542)
	at org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:928)
	at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:549)
	at org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:212)
	at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)
	at org.mortbay.jetty.bio.SocketConnector$Connection.run(SocketConnector.java:228)
	at org.mortbay.thread.QueuedThreadPool$PoolThread.run(QueuedThreadPool.java:582)

When I start the webapplication using the Jetty plugin i works perfectly. 

I have attached a simple project to demonstrate the problem. Build it ""mvn install"" and start jetty either from the web app using the Jetty plugin (cd web; mvn jetty:run) or the standalone (cd standalone; java -jar target/standalone-1.0-SNAPSHOT-jar-with-dependencies.jar). The embedded Jetty listens on port 8080.

URLs to reproduce: 
http://localhost:8080/web/groovy/test.gsp
http://localhost:8080/web/groovy/test.groovy?name=myname

","Apache Maven 3.0.2 (r1056850; 2011-01-09 01:58:10+0100), Jetty 6.1.26, java version ""1.6.0_24""",blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/May/11 04:05;mortenholm;bug.zip;https://issues.apache.org/jira/secure/attachment/12722852/bug.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 05 03:13:22 UTC 2012,,,,,,,,,,"0|i2crqv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Dec/12 03:13;blackdrag;That NPE should no longer appear;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JsonSlurper's methods are package private,GROOVY-4818,12815630,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,uehaj,uehaj,07/May/11 16:12,21/Jul/11 19:06,14/Jul/23 06:00,07/May/11 16:49,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,1.9-beta-1,,,,,,0,,,,,,"JsonSlurper's methods like parse(),parseText() have package private scope.
There is problems:
(1)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 07 16:49:24 UTC 2011,,,,,,,,,,"0|i2bodz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/May/11 16:16;uehaj;(continue)

There are problems:

1) javadoc comments of those methods are not appeared in API reference.
   http://groovy.codehaus.org/api/groovy/json/JsonSlurper.html
2) Java code can't call those methods from outside of package.

;;;","07/May/11 16:49;guillaume;Well spotted, thanks a lot for reporting this!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyScriptEngine does not use configured ImportCustomizer,GROOVY-4813,12818080,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,kaklakariada,kaklakariada,06/May/11 01:37,21/Jul/11 19:06,14/Jul/23 06:00,10/May/11 04:30,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,1.9-beta-1,,,,,,0,,,,,,"When running a groovy script using {{groovy.util.GroovyScriptEngine}}, the configured {{ImportCustomizer}} is not used. When running the script with {{GroovyShell}}, it works as expected.

The problem can be reproduced using the following groovy script that tries to run a small script using {{groovy.util.GroovyScriptEngine}} and {{GroovyShell}}:

{code}
import org.codehaus.groovy.control.CompilerConfiguration;
import org.codehaus.groovy.control.customizers.ImportCustomizer;

File script = File.createTempFile('test', '.groovy')
script.deleteOnExit()
script.write """"""
println new SimpleDateFormat()
""""""

// Create compiler configuration with import customizer
CompilerConfiguration config = new CompilerConfiguration();
ImportCustomizer importCustomizer = new ImportCustomizer();
importCustomizer.addImports 'java.text.SimpleDateFormat'
config.addCompilationCustomizers importCustomizer

// Run script with groovy shell: this will work
GroovyShell shell = new GroovyShell(config)
shell.run script, []

// Run script with script engine: this will not work, import customizer is not used
GroovyScriptEngine scriptEngine = new GroovyScriptEngine(script.getParent())
scriptEngine.setConfig config
scriptEngine.run script.getName(), new Binding()
{code}

The output of this script looks like this:

{noformat}
java.text.SimpleDateFormat@3dd497a
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/C:/Users/chpi2491/AppData/Local/Temp/test8494443541360579143.groovy: 2: unable to resolve class SimpleDateFormat 
 @ line 2, column 9.
   println new SimpleDateFormat()
           ^

1 error
{noformat}

The expected output would be something like this:
{noformat}
java.text.SimpleDateFormat@???????
java.text.SimpleDateFormat@???????
{noformat}","Windows, JDK 1.6.0_21",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 10 04:30:44 UTC 2011,,,,,,,,,,"0|i2by6v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/May/11 04:30;melix;Fixed in 1.8.1 and 1.9-beta-1;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem Parsing Expression With 1.8.0,GROOVY-4812,12818085,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,brownj,brownj,05/May/11 15:48,28/Oct/11 15:39,14/Jul/23 06:00,28/Oct/11 15:39,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.4,2.0-beta-1,,Compiler,,,,1,,,,,,"The following works with 1.7.x but fails with 1.8.0

{code:title=Demo.groovy|borderStyle=solid}
class Demo  {
   
   void doit() {
       execute new Runnable(){
           void run() {
               println 'hello'
           }
       }
   }
   
   void execute(arg) {
       arg.run()
   }
   
   static void main(args) {
       new Demo().doit()
   }
}
{code}

The code fails with a MissingPropertyException:

{noformat}
$ groovy Demo
Caught: groovy.lang.MissingPropertyException: No such property: execute for class: Demo
        at Demo.doit(Demo.groovy:4)
        at Demo.main(Demo.groovy:16)
{noformat}

If I put parens around the argument to the execute method, then it appears to work:


{code:title=Demo.groovy|borderStyle=solid}
class Demo  {
   
   void doit() {
       execute(new Runnable(){
           void run() {
               println 'hello'
           }
       })
   }
   
   void execute(arg) {
       arg.run()
   }
   
   static void main(args) {
       new Demo().doit()
   }
}
{code}",,brownj,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 28 15:39:38 UTC 2011,,,,,,,,,,"0|i2crzj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/May/11 02:25;graemerocher;I found a second manifestation of this issue in Grails' functional tests. Basically this works in 1.7:

{code}
   render XML.use(""deep"") {
		render results as XML
	}
{code}

But fails in 1.8 with a MPE for 'render'

The XML class has a static method called 'use' that takes a string and a closure;;;","28/Oct/11 15:39;blackdrag;I think the fix for GROOVY-4970 also fixed the case here. I cannot reproduce the problem anymore;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
exception while compiling annotation type,GROOVY-4811,12815533,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mxm-groovy,mxm,05/May/11 07:21,02/May/17 02:03,14/Jul/23 06:00,19/Jun/15 21:18,1.8-rc-3,2.4.0-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,parser-antlr2,,,,0,,,,,,"{code}
@interface Inter {
  String[] bar() default ""1""
}
{code}
While compiling this annotation type the compiler throws

java.lang.ClassCastException: org.codehaus.groovy.ast.expr.ConstantExpression cannot be cast to org.codehaus.groovy.ast.expr.ListExpression
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitAnnotationDefaultExpression(AsmClassGenerator.java:316)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitAnnotationDefault(AsmClassGenerator.java:350)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:259)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:366)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:171)
	at org.codehaus.groovy.control.CompilationUnit$13.call(CompilationUnit.java:763)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:957)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:542)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:520)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:497)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:43)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:128)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:75)",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 19 21:18:02 UTC 2015,,,,,,,,,,"0|i2byk7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/May/11 09:20;blackdrag;{code:Java}
@interface Inter {
  String[] bar() default [""1""]
}{code}
comiles fine. So there is a work around this. The questions is (1) is that valid in Java and (2) is that something we should support in Groovy?;;;","05/May/11 10:00;mxm-groovy;It is valid in Java.
IMHO compiler should generate some more careful message than exception stack trace =) But of course it is minor bug.;;;","18/Jun/15 08:34;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/incubator-groovy/pull/41

    GROOVY-4811: exception while compiling annotation type

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy4811

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/incubator-groovy/pull/41.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #41
    
----
commit a7a5bc062640d66f42731761c2a59996276d47bb
Author: Paul King <paulk@asert.com.au>
Date:   2015-06-18T08:32:54Z

    GROOVY-4811: exception while compiling annotation type

----
;;;","19/Jun/15 20:22;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/incubator-groovy/pull/41
;;;","19/Jun/15 21:18;paulk;This can be considered a bug (unneeded difference from Java) or new feature (a convenience syntax we didn't use to support but will now). Certainly IDEA also complains about the syntax - so there is 3rd party tool implications for this change. For that reason I'll do the change just in 2.5 for now.

If there is a huge demand, we could consider back-porting to the 2_4_X branch.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Sql.eachRow documentation: actual GroovyResultSet vs. documentation GroovyRowResult,GROOVY-4806,12815484,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,mgaertner,mgaertner,04/May/11 04:33,21/Jul/11 19:06,14/Jul/23 06:00,08/May/11 05:15,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,1.9-beta-1,,,,,0,,,,,,"Sql.eachRow actually passes objects of type ""GroovyResultSet"" to the closure. Documentation says ""The row will be a GroovyRowResult"" (wrong).

The documentation example(s) are actually correct. They use ""row.toRowResult()"" to get to the desired ""GroovyRowResult""

http://groovy.codehaus.org/api/groovy/sql/Sql.html#eachRow(java.lang.String, groovy.lang.Closure, groovy.lang.Closure)

In all, six occurences of eachRow() variants show that ""The row will be a GroovyRowResult"" line.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 08 05:15:56 UTC 2011,,,,,,,,,,"0|i2ctr3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/May/11 05:15;paulk;Thanks for spotting that. Should be fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
out of memory error when running groovydoc when there are java files in packages,GROOVY-4803,12815624,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mpurdy1973,mpurdy1973,29/Apr/11 16:19,15/Feb/12 03:49,14/Jul/23 06:00,15/Feb/12 03:49,1.7.10,1.8.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.7,2.0-beta-3,GroovyDoc,parser-antlr2,,,0,,,,,,"reference: i found this bug running the ant task groovydoc; however, i then went to the command line to isolate the issue.  i started with 1.7.10 and then upgraded to 1.8.0 and got the same error.

this bug is repeatable.

follow these steps:
1) create a groovy project
2) add a package with groovy classes
3) run this command: rm -rf /tmp/docs/; mkdir -p /tmp/docs; groovydoc -verbose  -private --destdir /tmp/docs <package name>
4) everything should work fine
5) add a java file to the package
6) run this command: rm -rf /tmp/docs/; mkdir -p /tmp/docs; groovydoc -verbose  -private --destdir /tmp/docs <package name>
7) get an out of memory error when it hits the java file

i think groovy is doing a reclusive call that never ends until it runs out of memory

the project that i created using ant can be found at my github : https://github.com/matthewpurdy/purdyCommonTasks 

project directory structure looks like this:

purdyCommonTasks/
&#9500;&#9472;&#9472; README
&#9500;&#9472;&#9472; build.properties
&#9500;&#9472;&#9472; build.xml
&#9500;&#9472;&#9472; lib/
&#9474;   &#9500;&#9472;&#9472; groovy-all-1.8.0.jar
&#9474;   &#9500;&#9472;&#9472; junit-4.8.1.jar
&#9474;   &#9492;&#9472;&#9472; log4j-1.2.16.jar
&#9500;&#9472;&#9472; purdyCommonTasks.xml
&#9500;&#9472;&#9472; resources/
&#9474;   &#9492;&#9472;&#9472; log4j.xml
&#9500;&#9472;&#9472; src/
&#9474;   &#9492;&#9472;&#9472; somepackage/
&#9474;       &#9500;&#9472;&#9472; Main.groovy
&#9474;       &#9500;&#9472;&#9472; SomeClass.groovy
&#9474;       &#9492;&#9472;&#9472; SomeClass2.java
&#9492;&#9472;&#9472; test/
    &#9492;&#9472;&#9472; somepackage/
        &#9492;&#9472;&#9472; SomeClassTest.groovy


results when i run it from the commandline:

mpurdy-keywcorp:purdyCommonTasks mpurdy$ which groovy
/usr/local/groovy/bin/groovy
mpurdy-keywcorp:purdyCommonTasks mpurdy$ ls -l `which groovy`
-rwxrwxr-x@ 1 root  wheel   1.0K Apr 27 14:55 /usr/local/groovy/bin/groovy*
mpurdy-keywcorp:purdyCommonTasks mpurdy$ ls -l /usr/local/groovy
lrwxr-xr-x  1 root  wheel    12B Apr 29 16:14 /usr/local/groovy@ -> groovy-1.8.0
mpurdy-keywcorp:purdyCommonTasks mpurdy$ groovy -version
Groovy Version: 1.8.0 JVM: 1.6.0_24
mpurdy-keywcorp:purdyCommonTasks mpurdy$ rm -rf /tmp/docs/;mkdir -p /tmp/docs;groovydoc -verbose  -private --destdir /tmp/docs -windowtitle mydocs somepackage `find src/* -type f`
REDERROR [org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder] Out of memory while processing: DefaultPackage/SomeClass2.java
java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:108)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130)
Caused by: java.lang.OutOfMemoryError: Java heap space
	at antlr.ANTLRStringBuffer.append(ANTLRStringBuffer.java:36)
	at antlr.CharScanner.append(CharScanner.java:64)
	at antlr.CharScanner.consume(CharScanner.java:82)
	at antlr.CharScanner.match(CharScanner.java:205)
	at org.codehaus.groovy.antlr.java.JavaLexer.mSL_COMMENT(JavaLexer.java:1142)
	at org.codehaus.groovy.antlr.java.JavaLexer.nextToken(JavaLexer.java:401)
	at org.codehaus.groovy.antlr.java.JavaLexer$1.nextToken(JavaLexer.java:98)
	at antlr.TokenBuffer.fill(TokenBuffer.java:69)
	at antlr.TokenBuffer.LT(TokenBuffer.java:86)
	at antlr.LLkParser.LT(LLkParser.java:56)
	at org.codehaus.groovy.antlr.java.JavaRecognizer.classDefinition(JavaRecognizer.java:753)
	at org.codehaus.groovy.antlr.java.JavaRecognizer.typeDefinitionInternal(JavaRecognizer.java:674)
	at org.codehaus.groovy.antlr.java.JavaRecognizer.typeDefinition(JavaRecognizer.java:509)
	at org.codehaus.groovy.antlr.java.JavaRecognizer.compilationUnit(JavaRecognizer.java:348)
	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.parseJava(GroovyRootDocBuilder.java:86)
	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.getClassDocsFromSingleSource(GroovyRootDocBuilder.java:70)
	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.processFile(GroovyRootDocBuilder.java:205)
	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.buildTree(GroovyRootDocBuilder.java:162)
	at org.codehaus.groovy.tools.groovydoc.GroovyDocTool.add(GroovyDocTool.java:66)
	at org.codehaus.groovy.tools.groovydoc.GroovyDocTool$add.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at org.codehaus.groovy.tools.groovydoc.Main.execute(Main.groovy:198)
	at org.codehaus.groovy.tools.groovydoc.Main.main(Main.groovy:168)
	... 6 more
mpurdy-keywcorp:purdyCommonTasks mpurdy$ 
","mac os 10.6.7
java 1.6.0_24
groovy 1.8.0 (however same problem with 1.7.10)",paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Apr/11 16:19;mpurdy1973;bugTestExample.zip;https://issues.apache.org/jira/secure/attachment/12722802/bugTestExample.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 15 03:49:18 UTC 2012,,,,,,,,,,"0|i2cddj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Apr/11 20:49;paulk;I can reproduce the problem. If I add an end of line to the end of the Java file, the problem goes away. So I guess that is the workaround.

Yes, groovydoc is using a Java grammar which I don't believe is specially modified since we got it. Maybe we have to modify it or some other end of file trick to overcome this problem.;;;","02/May/11 15:30;mpurdy1973;thanx; that works for me:-)  

maybe it should be noted in the docs that you must add a 0x10 to the end of each java file before running groovydocs over that package.;;;","03/May/11 06:43;paulk;Just for the record (at least until we find a better fix) it is only Java files that have no end-of-line (i.e. no appropriate CR/LF for platform) that also have a single-line (double slash) comment on that last line that have this problem. The Antlr Java parser is looking for a CR and/or LF to close off the single-line comment and never finds it.;;;","14/Feb/12 08:46;blackdrag;Paul, I cannot reproduce the issue. I found in the grammar a change. It references to GROOVY-766 and would be about this:{code}
 // Single-line comments
 SL_COMMENT
        :       ""//""
-               (~('\n'|'\r'))* ('\n'|'\r'('\n')?)
+        (
+            options {  greedy = true;  }:
+            // '\uffff' means the EOF character.
+            ~('\n'|'\r'|'\uffff')
+        )*
                {$setType(Token.SKIP); newline();}
        ;
{code} 
can you test this?;;;","14/Feb/12 15:10;paulk;Indeed, that fixes the problem.;;;","15/Feb/12 03:49;blackdrag;I applied the fix;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Thrown exception not accessable inside catch block when class has @Category transformation applied,GROOVY-4801,12815639,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,bunglefeet,bunglefeet,28/Apr/11 06:08,07/Apr/15 19:13,14/Jul/23 06:00,28/Apr/11 08:24,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,ast builder,,,,0,,,,,,"When implementing a Category to handle exceptions, I find that the thrown exception is not available within the catch block when the class is annotated with the @Category AST transformation. Removing the @Category AST transformation gives the correct behaviour.

Example:

{code}
// Define exception handling category
@Category(Object)
class ExceptionHandler {
  def handled(Closure block) {
    try { block.call() }
    catch (Throwable t) { println t }
  }
}

// Define a class which mixes in this category
@Mixin(ExceptionHandler)
class Caller {
  def thrower() { handled { 1/0 } }
}

// Test the exception handling
new Caller().thrower()
// --> throws ""ERROR groovy.lang.MissingPropertyException: No such property: t for class: Caller""
{code}

However, if the ExceptionHandler category is defined without using the @Category AST transformation:

{code}
class ExceptionHandler {
  static def handled(Object self, Closure block) {
    try { block.call() }
    catch (Throwable t) { println t }
  }
}

@Mixin(ExceptionHandler)
class Caller {
  def thrower() { handled { 1/0 } }
}

new Caller().thrower()
// --> prints ""java.lang.ArithmeticException: Division by zero"", as expected
{code}

This behaviour is observed both in the groovy shell, and in compiled code.  Also, the erroneous behaviour is not due to the @Mixin AST transformation, as I observe the same behaviour when I replace the @Mixin AST transformation with the static initialization block {{{Caller.mixin ExceptionHandler}}} in the Caller class.
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 28 08:24:53 UTC 2011,,,,,,,,,,"0|i2clnj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Apr/11 07:05;paulk;The transformed code for {{println t}} is incorrectly looking like this:
{code}
$this.println( $this .t)
{code};;;","28/Apr/11 07:28;paulk;Adding something like this to CategoryASTTransformation seems to fix the problem:
{code}
@Override
public void visitCatchStatement(CatchStatement statement) {
    varStack.getLast().add(statement.getVariable().getName());
    super.visitCatchStatement(statement);
    varStack.getLast().remove(statement.getVariable().getName());
}
{code}
;;;","28/Apr/11 08:24;paulk;Thanks for spotting and reporting the issue. It should be fixed in the trunk and 1.8.1 snapshot jars. If you could test it out a little more, that would be great.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError when using @ListenerList,GROOVY-4797,12815645,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,26/Apr/11 07:19,07/Apr/15 19:07,14/Jul/23 06:00,26/Apr/11 07:40,1.8-rc-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.0,,,,,,,0,,,,,,"If the generic type (Object below) has methods with primitive args, e.g. {{wait(long timeout)}}, then a Verify Error occurs:
{code}
import groovy.beans.ListenerList
import java.lang.reflect.Modifier

class C {
    @ListenerList List<Object> listeners
}

assert C.class.getMethod('getObjects')
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-04-26 07:19:06.0,,,,,,,,,,"0|i2bu87:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
can't specify 'synchronize' parameter to ListenerList AST Transformation.,GROOVY-4795,12818077,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,uehaj,uehaj,25/Apr/11 16:41,27/Apr/11 19:05,14/Jul/23 06:00,26/Apr/11 06:04,1.8-rc-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.0,,,,,,,0,,,,,,"I tried this code
{code}
  import groovy.beans.ListenerList
  class C {
    @ListenerList(synchronize=true) List<java.awt.event.ActionListener> listeners;
  }
{code}
following exception occurred.
{code}
$ /tool/groovy-1.8.0-rc-4/bin/groovy  test.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during canonicalization: No signature of method: groovy.beans.ListenerListASTTransformation.addFireMethods() is applicable for argument types: (org.codehaus.groovy.control.SourceUnit, org.codehaus.groovy.ast.AnnotationNode, org.codehaus.groovy.ast.ClassNode, org.codehaus.groovy.ast.FieldNode, org.codehaus.groovy.ast.expr.ConstantExpression, org.codehaus.groovy.ast.MethodNode) values: [org.codehaus.groovy.control.SourceUnit@5117a20, org.codehaus.groovy.ast.AnnotationNode@71f1235b, C, org.codehaus.groovy.ast.FieldNode@162db19d, ConstantExpression[true], MethodNode@1047055737[void actionPerformed(java.awt.event.ActionEvent)]]
Possible solutions: addFireMethods(org.codehaus.groovy.control.SourceUnit, org.codehaus.groovy.ast.AnnotationNode, org.codehaus.groovy.ast.ClassNode, org.codehaus.groovy.ast.FieldNode, boolean, org.codehaus.groovy.ast.MethodNode)

groovy.lang.MissingMethodException: No signature of method: groovy.beans.ListenerListASTTransformation.addFireMethods() is applicable for argument types: (org.codehaus.groovy.control.SourceUnit, org.codehaus.groovy.ast.AnnotationNode, org.codehaus.groovy.ast.ClassNode, org.codehaus.groovy.ast.FieldNode, org.codehaus.groovy.ast.expr.ConstantExpression, org.codehaus.groovy.ast.MethodNode) values: [org.codehaus.groovy.control.SourceUnit@5117a20, org.codehaus.groovy.ast.AnnotationNode@71f1235b, C, org.codehaus.groovy.ast.FieldNode@162db19d, ConstantExpression[true], MethodNode@1047055737[void actionPerformed(java.awt.event.ActionEvent)]]
Possible solutions: addFireMethods(org.codehaus.groovy.control.SourceUnit, org.codehaus.groovy.ast.AnnotationNode, org.codehaus.groovy.ast.ClassNode, org.codehaus.groovy.ast.FieldNode, boolean, org.codehaus.groovy.ast.MethodNode)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:55)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:78)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:46)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at groovy.beans.ListenerListASTTransformation$_visit_closure2.doCall(ListenerListASTTransformation.groovy:75)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)
	at groovy.lang.Closure.call(Closure.java:293)
	at groovy.lang.Closure.call(Closure.java:306)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1240)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1216)
	at org.codehaus.groovy.runtime.dgm$124.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:271)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:53)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:42)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at groovy.beans.ListenerListASTTransformation.visit(ListenerListASTTransformation.groovy:74)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:129)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:172)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:957)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:542)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:520)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:497)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:283)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:267)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:197)
	at groovy.lang.GroovyShell$2.run(GroovyShell.java:215)
	at groovy.lang.GroovyShell$2.run(GroovyShell.java:213)
	at java.security.AccessController.doPrivileged(Native Method)
	at groovy.lang.GroovyShell.run(GroovyShell.java:213)
	at groovy.lang.GroovyShell.run(GroovyShell.java:159)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:514)
	at groovy.ui.GroovyMain.run(GroovyMain.java:329)
	at groovy.ui.GroovyMain.process(GroovyMain.java:315)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:112)
	at groovy.ui.GroovyMain.main(GroovyMain.java:93)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:108)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130)

1 error
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 26 06:04:09 UTC 2011,,,,,,,,,,"0|i2bugf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Apr/11 06:04;paulk;Resolved, thanks for raising the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
enum constant initializer parsing,GROOVY-4794,12815349,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mxm-groovy,mxm,25/Apr/11 02:43,17/Jun/15 20:09,14/Jul/23 06:00,29/Mar/13 03:13,1.8-rc-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,parser,,,,0,,,,,,"can't compile enum constant initializer which contains method without explicit type declaration

{code}
enum E {
  enConst {
    def foo(){}
  }
}
{code}

",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 29 03:13:25 UTC 2013,,,,,,,,,,"0|i2c8gf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Apr/11 01:55;mxm-groovy;The same thing with fields of constant initializer;;;","26/Mar/13 05:57;paulk;An example showing the field case also:
{code}
enum E {
  enConst {
    float pi = 3.14
    void foo(){ println """" + new Date() + "" "" + pi }
  }
}
E.enConst.foo()
{code}
If either the ""void"" or ""float"" types are changed to ""def"" we get a syntax error. A preceding ""def"" does not cause the issue but the grammar currently requires the type to be present regardless of whether ""def"" is found unlike other places in Groovy which allows ""def"" only.;;;","29/Mar/13 03:13;paulk;The following now works:
{code}
enum E {
  enConst {
    @Lazy pi = 3.14
    def twopi = 6.28
    def foo(){ """" + pi + "" "" + twopi }
    public bar(){ """" + twopi + "" "" + pi }
  }
}
assert E.enConst.foo() == '3.14 6.28'
assert E.enConst.bar() == '6.28 3.14'
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compilation bug with spread operator,GROOVY-4790,12818079,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,pledbrook,pledbrook,21/Apr/11 12:05,18/Jan/13 16:06,14/Jul/23 06:00,18/Jan/13 09:42,1.8-rc-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,class generator,,,,0,,,,,,"I'm afraid this happened with Grails 1.4.0.BUILD-SNAPSHOT and a Grails application. That means to reproduce, you will have to build Grails 1.4.0 from trunk or pick up [a nightly snapshot|http://hudson.grails.org/job/grails_core_1.4.x/693/artifact/build/distributions/grails-1.4.0.BUILD-SNAPSHOT.zip]. I have attached a sample application.

Here's the stacktrace when running {{grails compile}}:

{noformat}
Welcome to Grails 1.4.0.BUILD-SNAPSHOT - http://grails.org/
Licensed under Apache Standard License 2.0
Grails home is set to: /Users/pledbrook/dev/tools/git/grails-core

Base Directory: /Users/pledbrook/dev/projects/scratch/test-1.4-snap
Running script Compile.groovy
Environment set to development
    [mkdir] Created dir: /Users/pledbrook/dev/projects/scratch/test-1.4-snap/target/plugin-classes
  [groovyc] Compiling 46 source files to /Users/pledbrook/dev/projects/scratch/test-1.4-snap/target/plugin-classes
Error executing script Compile: : BUG! exception in phase 'class generation' in source unit '/Users/pledbrook/dev/projects/scratch/test-1.4-snap/target/plugins/fixtures-1.0.6/src/groovy/grails/plugin/fixtures/files/FixtureFileLoader.groovy' SpreadExpression should not be visited here
: BUG! exception in phase 'class generation' in source unit '/Users/pledbrook/dev/projects/scratch/test-1.4-snap/target/plugins/fixtures-1.0.6/src/groovy/grails/plugin/fixtures/files/FixtureFileLoader.groovy' SpreadExpression should not be visited here
	at gant.Gant$_dispatch_closure5.doCall(Gant.groovy:391)
	at gant.Gant$_dispatch_closure7.doCall(Gant.groovy:415)
	at gant.Gant$_dispatch_closure7.doCall(Gant.groovy)
	at java_util_concurrent_Callable$call.call(Unknown Source)
	at gant.Gant.withBuildListeners(Gant.groovy:427)
	at gant.Gant.this$2$withBuildListeners(Gant.groovy)
	at gant.Gant$this$2$withBuildListeners.callCurrent(Unknown Source)
	at gant.Gant.dispatch(Gant.groovy:415)
	at gant.Gant.this$2$dispatch(Gant.groovy)
	at gant.Gant.invokeMethod(Gant.groovy)
	at gant.Gant.executeTargets(Gant.groovy:590)
	at gant.Gant.executeTargets(Gant.groovy:589)
Caused by: : BUG! exception in phase 'class generation' in source unit '/Users/pledbrook/dev/projects/scratch/test-1.4-snap/target/plugins/fixtures-1.0.6/src/groovy/grails/plugin/fixtures/files/FixtureFileLoader.groovy' SpreadExpression should not be visited here
	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:116)
	at _GrailsCompile_groovy$_run_closure3_closure9.doCall(_GrailsCompile_groovy:119)
	at _GrailsCompile_groovy$_run_closure3_closure9.doCall(_GrailsCompile_groovy)
	at _GrailsCompile_groovy$_run_closure3.doCall(_GrailsCompile_groovy:106)
	at java_util_concurrent_Callable$call.call(Unknown Source)
	at _GrailsCompile_groovy$_run_closure2.doCall(_GrailsCompile_groovy:45)
	at java_util_concurrent_Callable$call.call(Unknown Source)
	at java_util_concurrent_Callable$call.call(Unknown Source)
	at gant.Gant$_dispatch_closure5.doCall(Gant.groovy:381)
	... 11 more
Caused by: BUG! exception in phase 'class generation' in source unit '/Users/pledbrook/dev/projects/scratch/test-1.4-snap/target/plugins/fixtures-1.0.6/src/groovy/grails/plugin/fixtures/files/FixtureFileLoader.groovy' SpreadExpression should not be visited here
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitSpreadExpression(AsmClassGenerator.java:575)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeDirectMethodCall(InvocationWriter.java:125)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:166)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:87)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:71)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:287)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:661)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:599)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:320)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:460)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:80)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:151)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:406)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:289)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:268)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:366)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:174)
	at org.codehaus.groovy.control.CompilationUnit$13.call(CompilationUnit.java:763)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:957)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:542)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:520)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:497)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:476)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:67)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:180)
	at org.codehaus.groovy.ant.Groovyc.compile(Groovyc.java:903)
	at org.codehaus.groovy.ant.Groovyc.execute(Groovyc.java:606)
	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)
	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)
	... 19 more
Error executing script Compile: : BUG! exception in phase 'class generation' in source unit '/Users/pledbrook/dev/projects/scratch/test-1.4-snap/target/plugins/fixtures-1.0.6/src/groovy/grails/plugin/fixtures/files/FixtureFileLoader.groovy' SpreadExpression should not be visited here
{noformat}",Grails 1.4.0.BUILD-SNAPSHOT,blackdrag,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/Apr/11 12:05;pledbrook;groovy-compile-bug.zip;https://issues.apache.org/jira/secure/attachment/12722840/groovy-compile-bug.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 18 09:42:39 UTC 2013,,,,,,,,,,"0|i2bp4n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Apr/11 02:36;guillaume;Groovy 1.7 was a bit more tolerant to such errors than Groovy 1.8 seems to be, but there is a bad usage of the spread operator in FixtureFileLoader.groovy.

To summarize what this class is doing (by trimming as much as possible):
{code}
class FixtureFileLoader {
    def load(String[] patterns) {
        doLoad(*patterns)
    }
    
    protected doLoad(String[] locationPatterns) {}
}

String[] arr = ['a', 'b', 'c']

def ffl = new FixtureFileLoader()
ffl.load(arr)
{code}

You are calling the {{doLoad()}} method from the {{load()}} method, by spreading the {{patterns}} array as arguments, but the {{doLoad()}} method actually takes the same array as parameters.

This is a bad usage of the spread operator, as the spread operator is not needed at all.
So just remove the 'star', and the code will work the same in 1.7 and 1.8.;;;","23/Apr/11 03:34;pledbrook;That's fair enough, but surely Groovy should not be printing a ""BUG! exception in phase..."" message for such an error? Now that I see that the {{String[]}} array type is important in the {{doLoad()}} method (I was trying with Object[]), it's easy to reproduce:

{code}
load(""hello"", ""world"")

def load(String[] patterns) {
    loading = true
    doLoad(*patterns)
    loading = false
}

def doLoad(String[] items) {
    println "">> args: ${items}""
}
{code}
;;;","25/Apr/11 00:34;paulk;I am also wondering whether the current behavior couldn't be improved. Firstly with a better error message, but I guess we currently don't support adding a varargs/Object[] method at runtime using e.g. EMC, and I wonder whether we should.;;;","25/Apr/11 05:51;blackdrag;A Bug! message should never appear. Either the case should be caught somewhere else or is valid and still failing. The behaviour here is a bug and should work normally;;;","27/Apr/11 19:02;paulk;reopen until we add the better error message as per Jochen's comment;;;","18/Jan/13 09:42;blackdrag;this seems to be fixed by now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BUG! exception in phase 'class generation' generating class from map in closure,GROOVY-4787,12818071,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,tim_yates,tim_yates,19/Apr/11 05:22,02/May/17 02:03,14/Jul/23 06:00,01/Jun/15 13:00,1.7.10,1.8-rc-4,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,class generator,,,,0,,,,,,"If I have a class like so:

{code}
class Person {
  String name
  int age
}
{code}

Then it is possible to create an instance of {{Person}} using the little known construct:

{code}
def tim = Person [ name:'tim', age:49 ]
{code}

This works fine.

However, if I try to do the following:

{code}
def ppl = [ [ name:'Tim', age:49 ], [ name:'Dave', age:32 ], [ name:'Steve', age:28 ] ]

ppl.collect { Person [ *it ] }
{code}

I get the class generation error

{code}
BUG! exception in phase 'class generation' in source unit 'ConsoleScript10' SpreadExpression should not be visited here
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitSpreadExpression(AsmClassGenerator.java:1871)
	at org.codehaus.groovy.ast.expr.SpreadExpression.visit(SpreadExpression.java:39)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4122)
	at org.codehaus.groovy.classgen.AsmClassGenerator.makeBinopCallSite(AsmClassGenerator.java:2268)
	at org.codehaus.groovy.classgen.AsmClassGenerator.evaluateBinaryExpression(AsmClassGenerator.java:3902)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:1662)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4122)
	at org.codehaus.groovy.classgen.AsmClassGenerator.evaluateExpression(AsmClassGenerator.java:1447)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:1408)
	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:738)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:626)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:601)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:696)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1039)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:276)
	at org.codehaus.groovy.control.CompilationUnit$12.call(CompilationUnit.java:748)
	at org.codehaus.groovy.control.CompilationUnit$12.call(CompilationUnit.java:765)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:942)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:519)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:497)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:474)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:287)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:731)
	at groovy.lang.GroovyShell.run(GroovyShell.java:516)
	at groovy.lang.GroovyShell.run(GroovyShell.java:172)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:904)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:149)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:282)
	at groovy.lang.Closure.call(Closure.java:277)
	at groovy.lang.Closure.run(Closure.java:360)
	at java.lang.Thread.run(Thread.java:680)
{code}

I know I should be doing:

{code}
ppl.collect { new Person( *:it ) }
{code}

(which works fine), but I just thought you should know about this {{BUG!}} exception",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7447,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 01 13:00:59 UTC 2015,,,,,,,,,,"0|i2bow7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Apr/11 05:24;tim_yates;PS:  For completeness, this:

{code}
ppl.collect { Person it }
{code}

gives 

{code}
The current scope already contains a variable of the name it
{code}

and 

{code}
ppl.collect { Person [ *:it ] }
{code}

gives the error

{code}
groovy.lang.MissingMethodException: No signature of method: static Person.getAt() is applicable for argument types: (groovy.lang.SpreadMap) values: [[:]]
{code} ;;;","19/Apr/11 06:45;blackdrag;{code}Person it{code} is a variable declaration, that's why it complains about a variable ""it"" already being available;;;","19/Apr/11 07:18;tim_yates;Of course!  Didn't see that! (doh);;;","01/Jun/15 13:00;paulk;Thanks for raising the issue Tim.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@EqualsAndHashCode : excludes does not work correctly ,GROOVY-4786,12815593,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,e.castro,e.castro,17/Apr/11 04:18,27/Apr/11 19:05,14/Jul/23 06:00,17/Apr/11 16:38,1.8-rc-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.0,,,ast builder,,,,0,,,,,,"The following code should work. It fails in 1.8-rc4:
{code}
import groovy.transform.EqualsAndHashCode

@EqualsAndHashCode(excludes=""b"")
class X {
    int a
    int b
}

x1 = new X(a:1, b:10)
x2 = new X(a:1, b:100)

assert x1 == x2
assert x1.hashCode() == x2.hashCode() // failure here
{code}",Ubuntu 10.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Apr 17 17:24:00 UTC 2011,,,,,,,,,,"0|i2bswf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Apr/11 06:13;e.castro;I think @EqualsAndHashCode should &#8209; by default - ignore @Lazy properties. Thoses properties are generally pure functional results of the non lazy properties, which are tested by the equals().

It might be convenient to exclude properties annotated by, say, @Transient, because their values may change without changing the general properties of the objects.;;;","17/Apr/11 06:49;e.castro;In EqualsAndHashCodeASTTransformation, the transformer test if field contains ""$"". It seems not too work with @Lazy (which produce synthetic field with a ""$""). Consider the following:

{code}
import groovy.transform.EqualsAndHashCode

def dump(x) { // I don't want the standard dump that calls hashCode()
    println x.class.declaredFields.findAll{ it.modifiers == 2 }.collect{ it.accessible=true ; [it, it.get(x)] }
}

@EqualsAndHashCode
class X { 
    String a 
    @Lazy String b = ""<$a>""
}

x1 = new X(a:""1"")
x2 = new X(a:""1"")

x1.b // force the evaluation of b
dump(x1)
dump(x2)
assert x1 == x2
dump(x1)
dump(x2) // You can see that the $b field has been evaluated and tested by ==
{code}
;;;","17/Apr/11 16:38;paulk;Thanks for spotting that! Excludes was wired up for equals but not hashCode - and previously there was no unit test for this particular case to guard against such an error. Fixed now.;;;","17/Apr/11 17:24;paulk;Just for clarification, what was fixed was the originally reported problem with {{excludes}} and {{hashCode()}}. No change was made wrt {{@Lazy}}. The default behavior (unless the {{includeFields}} attribute is set to {{true}}) is to base {{equals}} and {{hashCode}} on properties - so in the case of {{b}} being lazy above, the property {{b}} is still part of the evaluation - the backing field {{$b}} is not. If you did set {{includeFields=true}}, then because the backing field included the dollar character it would still not be included but the property would still be. Just use {{excludes='b'}} if you really don't want the '==' method to evaluate {{b}}. Or raise a separate issue if you believe there is some incorrect behavior wrt {{@Lazy}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"[ null, 'ah' ].findAll() throws a NullPointerException",GROOVY-4784,12815587,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,johann,johann,14/Apr/11 15:39,21/Jul/11 19:06,14/Jul/23 06:00,02/Jul/11 06:34,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,groovy-jdk,,,,0,,,,,,"{code}
[ null, 'ah' ].findAll()
{code}

throws a NullPointerException with no error message which is a bit odd because I can write [][1] and get null back.

Essentially, Groovy is very lax (in a good way) in most parts but not here.

I'd implement a default Closure that just casts each argument to boolean, which i think [ null, 'ah' ].findAll { it } would.

This might apply to more methods than just findAll(). ;-)",This box right here.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 02 06:34:39 UTC 2011,,,,,,,,,,"0|i2cbvr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"02/Jul/11 06:34;paulk;Due to GROOVY-4893, this is now fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@WithReadLock and @WithWriteLock creates the wrong locks,GROOVY-4781,12816523,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,hamletdrc,hamletdrc,hamletdrc,14/Apr/11 03:50,05/Apr/15 14:44,14/Jul/23 06:00,14/Apr/11 06:31,1.8-rc-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.0,1.9-beta-1,,Compiler,,,,0,,,,,,"The @WithReadLock forces a method to obtain a write lock. 
The @WithWriteLock forces a method to obtain a read lock. 

This is exactly backwards. It should be the other way around. I have a fix.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Sun Apr 17 02:53:08 UTC 2011,,,,,,,,,,"0|i2criv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"14/Apr/11 06:31;hamletdrc;fixed.;;;","15/Apr/11 15:00;guillaume;Fixed on which branches? Shouldn't it be fixed on 1_8_X, trunk, but also 1_8_RC?;;;","15/Apr/11 15:21;hamletdrc;I checked it into 1_8_x and trunk. I was under the impression that it was too late for 1_8_RC. ;;;","17/Apr/11 02:53;paulk;Anything for RC branch should be discussed as anything major would require another RC, i.e. RC-5. I chatted to Guillaume and Jochen about ReadWriteLockASTTransformation and we think it is fine for RC so I merged it onto that branch. I remove the early return (one line above your change) as otherwise the Runtime exception would never be in play.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problem with extended command expressions,GROOVY-4774,12815597,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,guillaume,guillaume,07/Apr/11 08:40,12/Apr/11 09:51,14/Jul/23 06:00,12/Apr/11 09:51,1.8-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-4,,,parser-antlr2,,,,0,,,,,,"Extended command expressions such as:
{code}
a b c d
{code}
Are equivalent to calling:
{code}
a(b).c(d)
{code}
But in the case we have something like:
{code}
a b 1 2
{code}
Which would be supposed to be equivalent to:
{code}
a(b).1(2)
{code}
But the AST represented by that call just represents the 1.call(2) part, and the a and b parts are totally absent.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 12 09:51:39 UTC 2011,,,,,,,,,,"0|i2c727:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Apr/11 09:51;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"java stub contains ""AnnotationNode"" string instead of an annotation within an annotation",GROOVY-4768,12818070,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,lgdean,lgdean,05/Apr/11 16:07,22/Jul/11 16:56,14/Jul/23 06:00,29/Jun/11 04:17,1.7.10,1.7.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,Stub generator / Joint compiler,,,,4,,,,,,"My groovy method has an annotation that some hibernate users will recognize:
{code:Java}
   @JoinTable(name = ""join_table"",
      inverseJoinColumns = @JoinColumn(name = ""otherEntity_id""),
      joinColumns = @JoinColumn(name = ""myEntity_id""))
   Set<OtherEntity> getOthers() {
      others
   }
{code}
When I compile with just groovy, no problem.  But in joint compilation mode, the java compiler gets confused by the appearance of a String instead of an annotation in the stub:
{code}
  [groovyc] C:\DOCUME~1\cyrus\LOCALS~1\Temp\groovy-generated-5778051423738941844-java-source\MyEntity.java:18: annotation value must be an annotation
  [groovyc] @javax.persistence.OneToMany(targetEntity=OtherEntity.class) @javax.persistence.JoinTable(inverseJoinColumns=""org.codehaus.groovy.ast.AnnotationNode@d4d66b"", name=""join_table"", joinColumns=""org.codehaus.groovy.ast.AnnotationNode@149105b"") public  java.util.Set<OtherEntity> getOthers() { return (java.util.Set<OtherEntity>)null;}
  [groovyc]                                                                          {code}
I've attached a simple ant project to reproduce this problem.  (To save space, I excluded the groovy jar.)",Windows XP,jhuxhorn,kurtharriger,lgray,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"05/Apr/11 16:07;lgdean;project.zip;https://issues.apache.org/jira/secure/attachment/12722837/project.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 22 16:56:48 UTC 2011,,,,,,,,,,"0|i2cpnr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"05/Apr/11 16:19;lgdean;Apparently this version of jira eats whitespace!  I had no idea.  Sorry about that.  If I could figure out how to edit the ticket, I would.
{code}
  I have learned to indent, so I can be a better citizen.
    I also now notice the nice preview button off to the side.
{code};;;","06/Apr/11 06:22;blackdrag;I edited the issue to have the code tags;;;","29/Jun/11 04:17;paulk;Fixed - thanks very much for the test case.

If you are in a position to try a SNAPSHOT jar from the CI server in your environment, that would be great.;;;","30/Jun/11 13:14;lgdean;I tried the following snapshot jar, and unfortunately, it didn't change things for me.  I still got the ""annotation value must be an annotation"" error.

groovy-all-1.8.1-SNAPSHOT.jar              30-Jun-2011 10:50  5.7M;;;","30/Jun/11 15:59;paulk;I forgot to mention, you will need to recompile using that jar not just place the new jar in the classpath.

Did you try running your sample ant project attached or some other test? Did you delete any existing class files first?;;;","19/Jul/11 17:14;lgdean;Sorry for the delay; I was traveling, and then this task fell down my list a bit once I returned.

My answer is a bit complicated.  I tried again with this snapshot:

groovy-all-1.8.1-SNAPSHOT.jar              19-Jul-2011 08:44  5.8M  

With my sample project, everything worked fine.  (I assume you tried it, too, so no surprise there!)

With the actual production code, I find the following:

1. With groovy 1.8.0, I still get this error.  (That's expected, of course, but confirms I've reproduced it correctly.)
2. With groovy 1.8.1 in the taskdef, but with 1.8.0 still in my classpath (along with 1.8.1), I still get the error.
3. With groovy 1.8.0 totally removed, I get lots of other errors instead.  They all have to do with lines like the following:
   List<DomNode> getByXPath(String xpathExpression)
(where DomNode is a java class, and the class with the compilation error is a groovy class, and specifically, the java stub from it).

I gave up on getting rid of those errors, though I tried for a while.  (First I removed packages that seemed to have a lot of the errors, and I removed references to those packages, but then more popped up.  Thus, giving up.)

I guess that means I should report the errors I'm getting when I use just the 1.8.1 snapshot for compiling.  (I assume that if something make it into a snapshot, it's worth reporting.  Is that correct?)  Which, in turn, means seeing whether someone else has reported it, which might mean waiting until tomorrow.;;;","19/Jul/11 17:50;paulk;Obviously a repeatable testcase showing your error would be ideal. But cutting and pasting a sample of the interim error messages you are getting in the meantime could be useful to try to get a fix in 1.8.1 which is due for release in a day or two.;;;","20/Jul/11 12:15;lgdean;Created GROOVY-4935 for that issue.;;;","22/Jul/11 16:56;lgdean;Looks good!  Everything compiles for me with this snapshot:
groovy-all-1.8.1-SNAPSHOT.jar              21-Jul-2011 07:46  5.8M;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compilation error for generic interface method,GROOVY-4767,12815527,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,sukhyun.cho,sukhyun.cho,05/Apr/11 15:45,21/Jul/11 19:06,14/Jul/23 06:00,02/Jul/11 00:59,1.7.5,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,Compiler,,,,0,,,,,,"Repro:

Compile

{code}
interface Foo {
    public <N extends Number> void foo()
}
{code}

Result:

{noformat}
unexpected token: public @ line 2, column 5.
       public <N extends Number> void foo()
       ^
{noformat}

Making {{Foo}} an abstract class avoids the problem:

{code}
abstract class Foo {
    public abstract <N extends Number> void foo()
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4908,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 02 00:59:41 UTC 2011,,,,,,,,,,"0|i2bvfj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jul/11 00:59;paulk;I have put in a fix and done some initial testing. Any further testing you can do would be great. Now that this is fixed, it reveals some additional checks we need to do in the compiler regarding generics that haven't been completed before now. I am expecting those checks to be done as part of fixing GROOVY-4908.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
__$swapInit not quite doing what was expected,GROOVY-4765,12815602,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,aclement,aclement,05/Apr/11 11:53,07/Apr/11 16:15,14/Jul/23 06:00,07/Apr/11 15:11,1.8-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-4,,,bytecode,,,,0,,,,,,"The new method __$swapInit was added (I think) to support reloading, enabling someone to drive re-initialization of some state (like constants, callsite arrays).  Unfortunately it doesn't quite do that - with regards to the callsite array all it does is call $getCallSiteArray.  This doesn't clear it, this just ensures it is initialized - and if initialized in the past it will not be reinitialized.  This means the reloader has to additionally null the callsite array before calling __$swapInit - which is a shame since it is all invoked by reflection.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 07 16:15:37 UTC 2011,,,,,,,,,,"0|i2csmv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Apr/11 15:11;blackdrag;the method now nulls out the field, which should do what you need;;;","07/Apr/11 16:15;aclement;great, thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Numbers as properties in command expressions,GROOVY-4762,12815582,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,mxm-groovy,mxm,05/Apr/11 03:05,06/Mar/18 23:25,14/Jul/23 06:00,02/May/17 02:12,1.8-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.6.0-alpha-1,,,parser,,,,0,,,,,,"It is allowed not to surround numbers with quotes in command expressions if they are used as properties.
Is it bug or feature?
 
{code}
def get123() {2}
def foo(i) {this}

def a = foo(2).'123'
def b = foo 2   123

println a
println b
{code}

But if you rename get123() to get123a() the line will throw an exception.
{code}
def b = foo 2   123a
{code}",,daniel_sun,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 27 02:53:01 UTC 2017,,,,,,,,,,"0|i2co3r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jan/17 02:39;daniel_sun;Fixed in the parrot branch;;;","27/Jul/17 02:53;paulk;Daniel, I can't see any change in behavior related to this if I understand correctly. Is there something you had in mind? Otherwise, shouldn't this really just be closed without a fix version and marked as a ""feature"". ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect source location for method call expression,GROOVY-4761,12815627,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,werdna,werdna,04/Apr/11 14:54,06/Mar/18 23:25,14/Jul/23 06:00,02/May/17 02:12,1.8-rc-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.6.0-alpha-1,,,parser,parser-antlr2,,,0,,,,,,"In this class, the source location for the StaticMethodCallExpression is incorrect.  The start column coincides with the column for '3' and the end includes the whitespace until the comment starts.

{code}
class StaticTrying {
	
	public static Class staticMethod(arg) {
		
	}
	
	def foo() {
		def a = staticMethod 3  // extra whitespace
	}
}
{code}

I'm not too concerned about the invalid end column, but the start column problem is affecting Groovy-Eclipse.

I delved a little bit into this.  Here is when the situation happens:

# when the method declaration takes 1 or more parameters
# the method declaration can be either static or non-static
# the method call takes exactly 1 argument
# does not use parens
# is part of a declaration expression.

Because of parts 4 and 5, this problem can only occur on Groovy 1.8 because on 1.7 it would be a parsing error.

I tracked this down to an invalid source location for the Antlr AST node being passed into {{AntlrParserPlugin.methodCallExpression()}}.

I originally reported this bug in GRECLIPSE-1031.
",,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 19 12:32:02 UTC 2017,,,,,,,,,,"0|i2bwp3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jan/17 12:32;daniel_sun;Parrot provides much more accurate AST node position information. Fixed in the parrot branch.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
compiler NPE with some finally blocks with explicit return,GROOVY-4759,12815585,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,jpertino,jpertino,04/Apr/11 12:30,17/Dec/14 13:25,14/Jul/23 06:00,25/Oct/14 02:44,1.7.10,1.8-rc-3,1.9-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,Compiler,,,,0,,,,,,"Not normally a piece of code I would write, but a post in stackoverflow.com brought to my attention this bug.

I don't know the exact trigger, but it seems that a nested try block, with an explicit return on one of the finally clauses, when written as the final statement of a function is throwing a NullPointerException at groovyjarjarasm.asm.MethodWriter#visitMaxs

This script is the shortest example I got.
{code:title=script1.groovy}
try {
  try {} finally {}
} finally {
  return 0
}
{code}

Things to note: 
It's the last statement of the script's run()
There is a nested try block. The blocks could be a try/catch, try/finally or try/catch/finally blocks with identical behavior
The explicit return could be anything, it will fail to compile.
There cannot be anything between the finally clauses and the end of the function.

a little bit longer

{code:title=script2.groovy}
try {
//  1
  try {
//    2
  } finally {
//    3
    return -1
//    4
  }
//  5
} finally {
//  6
 return -2
//  7
}
//8
{code}

There can be anything in positions 1-4,6,7
The script can be compiled when there is a statement in positions 5 or 8
Either of the explicit returns is enough, not necessarily both.

The full stacktrace is
{code}
Caught: java.lang.NullPointerException
java.lang.NullPointerException
        at org.objectweb.asm.MethodWriter.visitMaxs(Unknown Source)
        at org.objectweb.asm.MethodAdapter.visitMaxs(Unknown Source)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:595)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:686)
        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1039)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:276)
        at org.codehaus.groovy.control.CompilationUnit$12.call(CompilationUnit.java:748)
        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:942)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:519)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:497)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:474)
        at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:283)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:267)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:197)
        at groovy.lang.GroovyShell$2.run(GroovyShell.java:215)
        at groovy.lang.GroovyShell$2.run(GroovyShell.java:213)
        at java.security.AccessController.doPrivileged(Native Method)
        at groovy.lang.GroovyShell.run(GroovyShell.java:213)
        at groovy.lang.GroovyShell.run(GroovyShell.java:159)
        at groovy.ui.GroovyMain.processOnce(GroovyMain.java:496)
        at groovy.ui.GroovyMain.run(GroovyMain.java:311)
        at groovy.ui.GroovyMain.process(GroovyMain.java:297)
        at groovy.ui.GroovyMain.processArgs(GroovyMain.java:112)
        at groovy.ui.GroovyMain.main(GroovyMain.java:93)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:108)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130)
{code}

",,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Oct 25 02:44:27 UTC 2014,,,,,,,,,,"0|i2cnkf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Oct/14 02:44;pschumacher;Works on current master, probably a duplicate of [GROOVY-7065].;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Can't compile method with generic signatures and default visibiliy access,GROOVY-4757,12815603,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,aalmiray,aalmiray,04/Apr/11 04:44,06/Mar/18 23:25,14/Jul/23 06:00,02/May/17 02:12,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.6.0-alpha-1,,,parser-antlr2,,,,0,,,,,,"The following script results in a compilation error

{code}
class Foo {
    <T extends Object> void foo(T t) {}
}

f = new Foo()
// compiler output
1 compilation error:

unexpected token: < at line: 2, column: 5
{code}

Adding a visibility accessor makes it work

{code}
class Foo {
    public <T extends Object> void foo(T t) {}
}

f = new Foo()
{code}",,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4901,GROOVY-7521,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 19 11:44:57 UTC 2017,,,,,,,,,,"0|i2cfmf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Sep/11 03:44;paulk;Is this the same as GROOVY-4901?;;;","19/Jan/17 11:44;daniel_sun;Fixed in the parrot branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
wrong usage of _$st in interfaces,GROOVY-4756,12815601,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,guai,guai,02/Apr/11 10:33,07/Apr/11 10:54,14/Jul/23 06:00,07/Apr/11 10:54,1.8-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-4,,,,,,,0,,,,,,"Following code prints 1 or 2 from time to time I start it. Tried at http://groovyconsole.appspot.com. This code generates error there:
java.lang.NoSuchFieldError: __$stMC
	at I1( or I2!!!!!!!!!!!!!!!!!!!!).<clinit>(Script1.groovy)
	at Script1.run(Script1.groovy:9)
but error differs from time to time too.


interface I1{
   int VALUE = 1
}
interface I2{
   int VALUE = 2
}
class C implements I1, I2{
}
println(new C().VALUE)","wnidows xp
java version ""1.6.0_22""
Java(TM) SE Runtime Environment (build 1.6.0_22-b04)
Java HotSpot(TM) Client VM (build 17.1-b03, mixed mode, sharing)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4754,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 07 10:54:35 UTC 2011,,,,,,,,,,"0|i2cktb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Apr/11 10:33;blackdrag;I cloned this issue from GROOVY-4754, because this one is for 1.8 a blocking issue;;;","07/Apr/11 10:54;blackdrag;I disabled the optimizations for interfaces, so this field no longer appears there adn the error will not surface anymore;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error in implements statement,GROOVY-4754,12815550,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,guai,guai,02/Apr/11 06:55,28/Dec/14 08:07,14/Jul/23 06:00,28/Dec/14 08:07,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.3.0,,,Compiler,,,,0,,,,,,"Following code prints 1 or 2 from time to time I start it. Tried at http://groovyconsole.appspot.com. This code generates error there:
{noformat}
java.lang.NoSuchFieldError: __$stMC
	at I1( or I2!!!!!!!!!!!!!!!!!!!!).<clinit>(Script1.groovy)
	at Script1.run(Script1.groovy:9)
{noformat}
but error differs from time to time too.

{code}
interface I1{
   int VALUE = 1
}
interface I2{
   int VALUE = 2
}
class C implements I1, I2{
}
println(new C().VALUE)
{code}
","wnidows xp
java version ""1.6.0_22""
Java(TM) SE Runtime Environment (build 1.6.0_22-b04)
Java HotSpot(TM) Client VM (build 17.1-b03, mixed mode, sharing)",pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4756,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 11 06:59:07 UTC 2014,,,,,,,,,,"0|i2c1m7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Apr/11 10:51;blackdrag;I splitted out the __$stMC problem for 1.8, which is realted to the performance improvements I implemented and therefore should be treated with more priority as this non-critical bug. As ofr the bug here I guess the best route would be to actually disallow it by the compiler. Only that in Java, the compiler does allow this construct. Only when you request VALUE, it will be marked as error. The only way for gRoovy would be to check in the implementing part and then throw an error here. But still, what if the interfaces and C are defined in Java. We would have to flag the println part from the Java perspective. If we don't then we would still get these strange differing outputs. On the other hand, people could simply add an VALUE field per MOP, then it would not be an error. We could maybe, when creating the meta class for C recognize that there are two fields of name VALUE and then make the usage of the field throw an erro that shows the ambigouty. I guess that would be the route that would work reliable and produces similar results to Java;;;","05/Apr/11 23:56;paulk;code tags;;;","11/May/14 06:59;pschumacher;As of groovy 2.3 the code always prints '2'. Does this mean this should be closed?;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CliBuilder#expandArgumentFiles throws StringIndexOutOfBoundsException on empty arguments,GROOVY-4753,12815563,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jwadamson,jwadamson,30/Mar/11 08:48,05/Apr/15 14:44,14/Jul/23 06:00,30/Mar/11 17:18,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8-rc-4,,,,,,0,,,,,,"Pass a CliBuilder instance, in its default state with expandArugmentFiles = true, an argument array containing an empty argument ''.

expected:  the clibuilder to parse the arguments
actual: {code}java.lang.StringIndexOutOfBoundsException: String index out of range: 1
	at java.lang.String.substring(String.java:1934)
        ....
	at groovy.util.CliBuilder.expandArgumentFiles(CliBuilder.groovy:296)
        ....{code}

Attached is code showing how an argument array that parses when expandArgumentFiles is false, throws an exception when it is true.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Mar/11 08:48;jwadamson;CliBuilderFail.groovy;https://issues.apache.org/jira/secure/attachment/12722791/CliBuilderFail.groovy","30/Mar/11 08:48;jwadamson;clibuilder.patch;https://issues.apache.org/jira/secure/attachment/12722836/clibuilder.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Wed Mar 30 17:18:20 UTC 2011,,,,,,,,,,"0|i2c4h3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Mar/11 17:18;paulk;Thanks for the patch. Should be fixed in the next release.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Defensive copying doesn't work for @Immutable classes,GROOVY-4751,12815526,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,denis.solonenko,denis.solonenko,28/Mar/11 21:23,07/Apr/15 19:12,14/Jul/23 06:00,29/Mar/11 22:59,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8-rc-4,,,,,,0,,,,,,"Seems like @Immutable classes do not do defensive copying of the collection provided into constructor:
{code}
@Immutable
final class Person {
    String name
    List<String> address
}

def myAddress = [""Line1"",""Line2""]
def person = new Person(name:""Name"", address:myAddress)
assert person.address == [""Line1"",""Line2""]
myAddress << ""Line3""
assert myAddress == [""Line1"",""Line2"",""Line3""]
assert person.address == [""Line1"",""Line2""] //<- fails
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 29 22:59:16 UTC 2011,,,,,,,,,,"0|i2colz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"29/Mar/11 16:43;paulk;Workaround is to use {{ArrayList}} not {{List}} as the type for {{address}}.;;;","29/Mar/11 22:59;paulk;Thanks for spotting that. Should be fixed now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
javadoc comment problems which breaks generated HTMLs,GROOVY-4748,12815540,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,uehaj,uehaj,26/Mar/11 08:31,05/Apr/15 14:44,14/Jul/23 06:00,27/Mar/11 03:01,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-4,1.9-beta-1,,,,,,0,,,,,,"I found some problems:
 - broken links
 - lack of period(summery is broken)
 - unbalanced tags like <pre>..<pre>",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"26/Mar/11 08:31;uehaj;patch;https://issues.apache.org/jira/secure/attachment/12722833/patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Wed Mar 30 00:51:15 UTC 2011,,,,,,,,,,"0|i2ci5z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Mar/11 03:01;paulk;Patch applied - thanks. GroovyRecognizer.java is a generated file so I changed groovy.g instead. Also, for future reference a context diff is the preferred patch format.;;;","30/Mar/11 00:51;uehaj;thank you for acceptance.
This includes GROOVY-4746 so please delete that.
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClosureWriter incorrectly changes the accessedVariable field of a VariableExpression,GROOVY-4747,12817707,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,werdna,werdna,25/Mar/11 13:30,08/Apr/11 05:29,14/Jul/23 06:00,08/Apr/11 05:29,1.8-rc-2,1.8-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-4,,,class generator,,,,0,,,,,,"Since 1.8, there is a ClosureWriter class, which (among other things) corrects the accessed variable field of VariableExpressions inside of closures.  The method {{correctAccessedVariable}} looks at each VariableExpression and tries to map the variable name to a field name inside of a synthetic Closure class generated by the ClosureWriter.  If no such variable name is found, then the accessed variable field is set to null.

This last part is incorrect.  The accessed variable should not be set to null.  The accessed variable may point to a field in the class declaring the closure, or it may point to a closure parameter, or a local variable, etc.  

I am not sure if this has any runtime effect on Groovy code, but it does have an effect on Groovy-Eclipse.  Because of this problem. Field references inside of closures cannot be resolved.  This affects content assist, navigation, hovers, search, refactoring (etc).

A simple null check fixes the problem in Groovy-Eclipse.  Here is the change (from 1.8-rc2):

On line 288, change:
{code}
expression.setAccessedVariable(fn);
{code}

to:
{code}
if (fn != null) // only overwrite if we find something more specific
    expression.setAccessedVariable(fn);
{code}

I'll think about some good test cases for this.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 08 05:29:06 UTC 2011,,,,,,,,,,"0|i2c1nz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Apr/11 05:29;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
broken @link in MetaObjectProtocol.java's javadoc,GROOVY-4746,12815581,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,uehaj,uehaj,24/Mar/11 17:02,13/Apr/11 14:33,14/Jul/23 06:00,30/Mar/11 01:13,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-4,1.9-beta-1,,,,,,0,,,,,,@link,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Mar/11 17:06;uehaj;patch;https://issues.apache.org/jira/secure/attachment/12722745/patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 30 01:13:41 UTC 2011,,,,,,,,,,"0|i2c2zz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Mar/11 17:04;uehaj;Sorry for mis submitted.

@link in javadoc is broken.
{quote}
 * implemented by the reference implementation of the @link groovy.lang.MetaClass interface.
{quote}
should be:
{quote}
 * implemented by the reference implementation of the {@link groovy.lang.MetaClass} interface.
{quote}
;;;","30/Mar/11 01:13;paulk;Fixed as part of GROOVY-4748;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassNode.equals throws ClassCastException for object of other type,GROOVY-4745,12815578,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,johanneslink,johanneslink,24/Mar/11 08:44,21/Jul/11 19:06,14/Jul/23 06:00,02/Jul/11 01:17,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,,,,,0,,,,,,"ClassNode.equals(Object o) should check for different types and return false. Current Code:
{code}
 public boolean equals(Object o) {
        if (redirect!=null) return redirect().equals(o);
        ClassNode cn = (ClassNode) o;
        return (cn.getName().equals(getName()));
    }
{code}
is obviously wrong.",groovy 1.7.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 02 01:17:44 UTC 2011,,,,,,,,,,"0|i2cfdr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Mar/11 10:50;guillaume;Out of curiosity, what were you comparing that ClassNode to?
At least, the exception proved it wasn't comparable ;-);;;","24/Mar/11 11:10;johanneslink;I was comparing other ASTNode types to it.

I hit upon this problem when writing tests for an AST transformation. Something like this:
{code}
assert allVisitedNodes.contains(aCertainNode)
{code} ;;;","02/Jul/11 01:17;paulk;Thanks for spotting that. Should be fixed now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inner classes of inner classes can't find outer class method names.,GROOVY-4743,12815559,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,jimwhite,jimwhite,23/Mar/11 02:16,12/Apr/11 08:27,14/Jul/23 06:00,12/Apr/11 08:27,1.7.10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8-rc-4,,,,,,1,,,,,,"Jay Ashworth reported a problem that arose between 1.7.6 and 1.7.7.  His example used Swing events and requires manual clicking to use.  I've reduced it to a simple test case (although not in JUnit form).

The interesting thing is that it takes two levels of Runnable inner classes for the problem to show up.  Turns out threads are not part of the issue.

Demo script attached.  The output for Groovy 1.7.10 is:

Resolved
After
Resolved
Caught: java.lang.NoSuchMethodError: TestInnerRefs$2.this$dist$invoke$2(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;
	at TestInnerRefs$2$3.methodMissing(TestRunner.groovy)
	at TestInnerRefs$2$3.run(TestRunner.groovy:24)
	at TestInnerRefs$2.run(TestRunner.groovy:27)
	at TestInnerRefs.dontEvent(TestRunner.groovy:31)
	at TestRunner.run(TestRunner.groovy:49)
",,jashworth,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/Mar/11 02:16;jimwhite;TestRunner.groovy;https://issues.apache.org/jira/secure/attachment/12722787/TestRunner.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 12 08:27:36 UTC 2011,,,,,,,,,,"0|i2bmfr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"31/Mar/11 16:11;rumour;This also applies to 1.8 up to the latest available version, 1.8RC3.;;;","12/Apr/11 08:27;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Documentation for Collection.sort(Comparator comparator) is wrong,GROOVY-4742,12815579,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,tim_yates,tim_yates,22/Mar/11 10:55,12/Apr/13 16:55,14/Jul/23 06:00,20/Mar/13 15:09,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,groovy-jdk,,,,1,,,,,,"The documentation for {{Collection.sort(Comparator comparator)}} at http://groovy.codehaus.org/groovy-jdk/java/util/Collection.html#sort%28java.util.Comparator%29 states

{quote}
Sorts the Collection using the given comparator. The elements are sorted into a new list, and the existing collection is unchanged. 
{quote}

However, it does seem to mutate the original list :-(",,pschumacher,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Mar/11 07:39;paulk;groovy4742_mutationImprovements.patch;https://issues.apache.org/jira/secure/attachment/12722790/groovy4742_mutationImprovements.patch","22/Mar/11 20:24;paulk;groovy4742_sortImprovements.patch;https://issues.apache.org/jira/secure/attachment/12722742/groovy4742_sortImprovements.patch","23/Mar/11 08:09;tim_yates;groovy4742_uniqueImprovements.patch;https://issues.apache.org/jira/secure/attachment/12722788/groovy4742_uniqueImprovements.patch",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 20 15:09:11 UTC 2013,,,,,,,,,,"0|i2co7r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Mar/11 11:23;donal;Here's a test case
{code}
class ISO3LangComparator implements Comparator<Locale> {

    int compare(Locale locale1, Locale locale2) {
        locale1.ISO3Language <=> locale2.ISO3Language
    }
}

List<Locale> locales = [Locale.FRENCH, Locale.ENGLISH]
def sortedLocales = locales.sort(new ISO3LangComparator())

// This assertion fails
assert locales[0] == frenchLocale
{code};;;","22/Mar/11 20:24;paulk;Potential patch attached. Fixes Javadoc but also proposes a few new overloaded methods which allow a boolean to be provided to turn off any mutating.;;;","22/Mar/11 20:27;paulk;Same additions could be made for the Array versions of the methods. There is also the possibility of using a Map instead of the boolean to allow {{sort(mutate: true)}} etc.;;;","23/Mar/11 03:46;tim_yates;Trying to come up with a patch for {{unique}} as well;;;","23/Mar/11 05:54;tim_yates;Attached a patch which hopefully should add the {{mutate}} flag to {{Collection.unique}} as well

Included test cases which should (I think) cover the new code.

{{Iterator.unique}} does not require the flag, as it wraps the {{Iterator}} wth {{asList}} before the unique call is made, so the original {{Collection}} should remain untouched.

Hope it's ok!;;;","23/Mar/11 08:09;tim_yates;Sorry, I had {{unique(Collection, Closure, boolean)}} rather than {{unique(Collection, boolean, Closure)}}

Doing it boolean first means you can have:

{code}
def list = [ 1, 2, 3, 2, 1 ]
list.unique( false ) { it % 2 }
{code}

The other way round is clunky and non-ideomatic;;;","24/Mar/11 07:39;paulk;Extended sort patch to cover arrays plus merged in unique patch from Tim. Only considered the boolean variant as I believe the map variant could be autogenerated at a later point.

Now we can consider whether we should extend this approach for:
* addAll, removeAll, retainAll (which are modify semantics by default)
** for these I think we can refer to their copy semantics counterparts in the javadoc and vice versa (i.e. plus and findAll/grep)
** in addition we will need a plus variant that takes an index
* reverse (which is copy semantics by default in DGM but modify in Collections)
** another boolean would allow both semantics in this case
;;;","26/Mar/11 00:09;paulk;Also worth pointing out that for legacy reasons, we have the following slightly annoying discrepancy (I believe created for ease of implementation rather than a specific requirement):
* sort(T[] self, Closure closure) has copy semantics
* all other sort variants (without the boolean mutate flag) have modify semantics

The boolean variants allow this discrepancy to be worked around but I am wondering whether this should be considered a bug and all variations should be aligned.
;;;","26/Mar/11 05:19;paulk;There is also another consideration which arises that is related to earlier points. For methods which imply ordering and have modify semantics (such as {{sort}}), we currently perform them in place for lists (which by their nature are also ordered) but convert to a new list (indirectly giving copy semantics) for non-list collections, e.g. {{Set}}. However there are non-list collection types which are ordered, e.g. {{LinkedHashSet}}. Perhaps we should retain the modify semantics for such types. I.e. instead of using {{asList}} we should make a new {{asOrderedCollection}} method which catered for things like {{LinkedHashSet}} and possibly {{Queue}}.;;;","26/Mar/11 05:33;paulk;A version of above patch has been applied in trunk for review. It doesn't attempt to fix the sort discrepancy or cater for {{LinkedHashSet}} etc. ;;;","13/Apr/11 03:16;paulk;The javadoc parts from trunk (and two non-contentious methods) have been merged into the 1.8 branches.

The variants with the mutate boolean (covering sort and unique) are still pending finalization and potential merging for 1.8.1.;;;","11/Nov/12 06:02;pschumacher;Any updates on this?;;;","20/Mar/13 15:09;pschumacher;I took a look at the doc and it seems like the unique and sort methods with boolean mutate were added with 1.8.1. Therefore I'm closing this issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError: Expecting to find integer on stack,GROOVY-4741,12818068,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,dhansmann,dhansmann,22/Mar/11 07:07,07/Apr/11 13:42,14/Jul/23 06:00,07/Apr/11 13:42,1.8-rc-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-4,,,Compiler,,,,0,,,,,,"Hi, I have the same issue as in GROOVY-4587.

For the inputs 
{code}
[0.0], [], [], [543]
{code}
the function-code below does throw an Exception which can be fixed by changing
{code}
if (ReWK < 0) {
{code}
to 
{code}
if (((int)ReWK) < 0) {
{code}
Seems like a bug to me or am I doing it wrong? Various other inputs run fine.




{code}
Gesamtbetrag,Direktabzug,Prozent,Einzelbetrag->                                                               

def int ReWK = 0
def arrAbzWK = []; 

Gesamtbetrag.eachWithIndex {
                                                            
	it, index ->                                                                                                          
   
	if(Gesamtbetrag[index] > 0){ 

		                                               
        	if(Prozent[index] != 0 && Prozent[index] != null) {  
			ReWK = Math.ceil( Gesamtbetrag[index] * (100 - Prozent[index]) / 100 ) 

		} else if (Direktabzug[index] > 0 ) {           
         
			ReWK = Math.ceil( Gesamtbetrag[index] - Direktabzug[index] )    
         
			if (ReWK < 0) { 
				ReWK = 0
			}                                     

         	} 
                else if (Einzelbetrag[index] > 0) { 
			ReWK = Math.ceil( Einzelbetrag[index] )                                                                           		
		} else {			
			ReWK = 0	
		}                                                                                     
   	}                                                                                  
                                                                                                           
   	arrAbzWK.add(ReWK)    
                                                                               
}

return arrAbzWK 
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"25/Mar/11 08:57;dhansmann;gmaven-1.3.tgz;https://issues.apache.org/jira/secure/attachment/12722792/gmaven-1.3.tgz","25/Mar/11 08:55;dhansmann;test.groovy;https://issues.apache.org/jira/secure/attachment/12722879/test.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 07 13:42:22 UTC 2011,,,,,,,,,,"0|i2cu7j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Mar/11 09:38;blackdrag;this sounds indeed very like that the issue you mentioned. To really fix that bug I need a runnable test case. The example you gave does not look complete;;;","24/Mar/11 10:15;dhansmann;I'll try to provide one if I find the time - unfortunately this is only a small function in a rather complex construct of groovy-scripts running in a java-environment (hundreds of formulas using hundreds of functions doing german tax calculation), so there might be many factors at work.

As a side note: 1.8.0-rc-3 seems to work very well, but I had to make a custom gmaven version using the good (but outdated)

http://www.yeap.de/blog2.0/archives/233-Build-Groovy++-with-Maven.html

and gmaven-1.3. Is the project abandoned or so you know anybody who might wan to check the stuff in? I could send a tar file.

Greetings,

David;;;","25/Mar/11 08:41;guillaume;I'm looking forward a reproducable example. That's likely something related to our int primitive optimizations. That would really be great if we could reproduce the problem, in order to fix the underlying issue.

As for GMaven, well, it's not actively developed these days.
If you're willing to contribute to it, that would be great, for those relying on GMaven.;;;","25/Mar/11 08:55;dhansmann;Example code;;;","25/Mar/11 08:57;dhansmann;gmaven-1.3 with gmaven-runtime-1.8 so providerSelection 1.8 works;;;","25/Mar/11 09:02;dhansmann;Seems to be easily reproducible, I attached the example and wish you good luck hunting the bug down.

As for the gmaven stuff: I attached my full .tgz, can you assign it to somebody who can check the stuff in? I am not familiar how the process here works and don't want to create an issue in the GMaven-Jira if it's abandoned.;;;","25/Mar/11 09:24;guillaume;Thanks for the code sample!
I've managed to reduce the failing example to this snippet:
{code}
int a = 0
[].each { 
    if (a < 0) {}
}
{code}

For the GMaven stuff, could you please open an issue in the GMaven JIRA?
http://jira.codehaus.org/browse/GMAVEN
Thanks in advance for that.;;;","25/Mar/11 09:29;guillaume;David, as a workaround for now, till we fix the issue, you can use an Integer instead of an int, for the ReWK variable. So you can say Integer ReWK = 0, or simply def ReWK = 0;;;","25/Mar/11 10:05;dhansmann;Wow, that's a lot shorter than mine. I'll rather not touch my ((int)ReWK) workaround for now as I have to run a full build and tests then, but nice to know!

I'll open another bug for the GMaven stuff.;;;","07/Apr/11 13:42;blackdrag;works now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Deadlock when GroovyClassLoader is used in multi-threaded environment,GROOVY-4736,12815541,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,skuklewicz,skuklewicz,19/Mar/11 07:51,04/Mar/14 16:31,14/Jul/23 06:00,29/Jan/14 09:10,1.7.9,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,groovy-runtime,,,,1,closeifnofeedback,,,,,"When multiple threads uses GroovyClassLoader to get Groovy classes or just work with them (instantiation, etc.) and an other(s) threads change the sources (followed by clearCache call), then deadlock can happen related to synchronizations on InnerLoader and HashMap (GroovyClassLoader.sourceCache)

I attached simple test scenation when 3 threads load Groovy classes and instantiate them and 3 other threads replace sources and call GroocyClassLoader.clearCache(). There is a synchronization on writeToFile to be ensure that the same file is not being written at the same time but this synchronization does not take part in a deadlock.

Please just run the test and wait a moment. Deadlock happens usually in 1 second at this test scenario. I hope this test will be also useful in Your future development as a standard test case.","Multiple OS: development server: Ubuntu 32-bit, desktop machine: Windows 7 64-bit, Java 1.6 Update 21",alessiostalla,blackdrag,guillaume,shenie,skuklewicz,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"19/Mar/11 14:18;skuklewicz;GroovyEngineTest.jar;https://issues.apache.org/jira/secure/attachment/12722785/GroovyEngineTest.jar","19/Mar/11 17:38;skuklewicz;GroovyEngineTest.java;https://issues.apache.org/jira/secure/attachment/12722786/GroovyEngineTest.java","19/Mar/11 07:51;skuklewicz;GroovyEngineTest.java;https://issues.apache.org/jira/secure/attachment/12722832/GroovyEngineTest.java","21/Mar/11 15:08;guillaume;ReentrantReadWriteLock_for_the_cache_cleaning.patch;https://issues.apache.org/jira/secure/attachment/12722743/ReentrantReadWriteLock_for_the_cache_cleaning.patch","23/Mar/11 09:07;guillaume;temporary_hack_for_deadlock_in_gcl.patch;https://issues.apache.org/jira/secure/attachment/12722741/temporary_hack_for_deadlock_in_gcl.patch",,,,5.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 29 09:10:31 UTC 2014,,,,,,,,,,"0|i2c8u7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"19/Mar/11 09:57;blackdrag;The system I tested was a 4 core System with Ubuntu 64bit and JDK 1.6 update 22.

I cannot reproduce the problem with your test program on my system using trunk. And using 1.7.10 it is the same;;;","19/Mar/11 14:18;skuklewicz;Test program with extracted groovy-all-1.7.9.jar (embeddable).;;;","19/Mar/11 14:24;skuklewicz;I uploaded test.jar that you can use to test. It contains compiled class GroovyEngineTest and extracted groovy-all-1.7.9.jar from groovy-1.7.9/embeddable directory. All you need to do just type ""java -jar GroovyEngineTest.jar"" when downloaded. Sorry for this big upload but I just wanted to create as similar environment as possible.

I asked developers from my company to do some more tests using this jar so I'll prepare detailed results in 2-3 days. It should be over a dozen machine tested.;;;","19/Mar/11 14:48;skuklewicz;While waiting for test answers, I send you stack traces. Maybe you'll interested anyway. This is a dump from VisualVM.


Found one Java-level deadlock:
=============================
""Thread-8"":
  waiting to lock monitor 0x0818ae9c (object 0x9fb55368, a
java.util.HashMap),
  which is held by ""Thread-6""
""Thread-6"":
  waiting to lock monitor 0x7010334c (object 0x9ec04a58, a
groovy.lang.GroovyClassLoader$InnerLoader),
  which is held by ""Thread-7""
""Thread-7"":
  waiting to lock monitor 0x0818ae9c (object 0x9fb55368, a
java.util.HashMap),
  which is held by ""Thread-6""

Java stack information for the threads listed above:
===================================================
""Thread-8"":
    at groovy.lang.GroovyClassLoader.recompile(GroovyClassLoader.java:776)
    - waiting to lock <0x9fb55368> (a java.util.HashMap)
    at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:737)
    at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
    at
test.GroovyEngineTest.compileAndInstantiate(GroovyEngineTest.java:100)
    at test.GroovyEngineTest.access$200(GroovyEngineTest.java:19)
    at test.GroovyEngineTest$2.run(GroovyEngineTest.java:123)
""Thread-6"":
    at java.lang.Class.getDeclaredFields0(Native Method)
    at java.lang.Class.privateGetDeclaredFields(Class.java:2291)
    at java.lang.Class.getDeclaredFields(Class.java:1743)
    at
org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:313)
    at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:263)
    - locked <0x9f097de8> (a java.lang.Object)
    at org.codehaus.groovy.ast.ClassNode.getInterfaces(ClassNode.java:341)
    at
org.codehaus.groovy.ast.ClassNode.declaresInterface(ClassNode.java:929)
    at
org.codehaus.groovy.ast.ClassNode.implementsInterface(ClassNode.java:909)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.doConvertAndCast(AsmClassGenerator.java:3842)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.doConvertAndCast(AsmClassGenerator.java:3837)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.storeThisInstanceField(AsmClassGenerator.java:2840)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.visitFieldExpression(AsmClassGenerator.java:2766)
    at
org.codehaus.groovy.ast.expr.FieldExpression.visit(FieldExpression.java:38)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.evaluateEqual(AsmClassGenerator.java:4050)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:1485)
    at
org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4122)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:1466)
    at
org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
    at
org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
    at
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:738)
    at
org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
    at
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
    at
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:626)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:601)
    at
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:119)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructor(AsmClassGenerator.java:688)
    at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1035)
    at
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
    at
org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:276)
    at
org.codehaus.groovy.control.CompilationUnit$12.call(CompilationUnit.java:748)
    at
org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:942)
    at
org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:519)
    at
org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:497)
    at
org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:474)
    at
groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)
    at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:283)
    - locked <0x9fb55368> (a java.util.HashMap)
    at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:267)
    at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:263)
    at groovy.lang.GroovyClassLoader.recompile(GroovyClassLoader.java:777)
    - locked <0x9fb55368> (a java.util.HashMap)
    at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:737)
    at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
    at
test.GroovyEngineTest.compileAndInstantiate(GroovyEngineTest.java:100)
    at test.GroovyEngineTest.access$200(GroovyEngineTest.java:19)
    at test.GroovyEngineTest$2.run(GroovyEngineTest.java:123)
""Thread-7"":
    at groovy.lang.GroovyClassLoader.recompile(GroovyClassLoader.java:776)
    - waiting to lock <0x9fb55368> (a java.util.HashMap)
    at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:737)
    at
groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:449)
    at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
    at java.lang.Class.forName0(Native Method)
    at java.lang.Class.forName(Class.java:169)
    at test.A2.class$(test.A2)
    at test.A2.$get$$class$test$E2(test.A2)
    at test.A2.<init>(test.A2:4)
    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
    at
sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
    at
sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
    at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
    at
test.GroovyEngineTest.compileAndInstantiate(GroovyEngineTest.java:101)
    at test.GroovyEngineTest.access$200(GroovyEngineTest.java:19)
    at test.GroovyEngineTest$2.run(GroovyEngineTest.java:123)

Found 1 deadlock.
;;;","19/Mar/11 17:03;blackdrag;ok, using the jar I was able to reproduce the deadlock... From a short look I am not so sure what to do about this. As far as Groovy is concerned no synchronization on the loaders is directly used. The reason that there is a lock on the class loader is because of Class#forName0, a native method - afaik. The reason that the Threads is blocked is that Class#getDeclaredFields0 is also using such a lock, again a native method. 

It looks to me that adding a synchronized modifier to loadClass(String,boolean) is maybe the only way to prevent the deadlock to happen. Of course that is bad for speed then.
;;;","19/Mar/11 17:04;blackdrag;Szymon would you be able to modify a Groovy 1.7 like that and test it?;;;","19/Mar/11 17:37;skuklewicz;Yes, I did as you said but it didn't help. In fact there is another problem but I think the same fundamental as the previous one.

I overridden GroovyClassLoader to add synchronized modifier

        classLoader = new GroovyClassLoader() {
            @Override
            protected synchronized Class loadClass(String name, boolean resolve) throws ClassNotFoundException {
                return super.loadClass(name, resolve);
            }
        };

but there is now deadlock between locks on GroovyClassLoader and GroovyClassLoader.InnerLoader (previous one was between InnerLoader and sourceCache):

Java-level deadlocks have been detected
Deadlock:

Thread-8 is waiting to lock groovy.lang.GroovyClassLoader$InnerLoader@671ff436 which is held by Thread-1
Thread-1 is waiting to lock test.GroovyEngineTest$1@2fe4cbc4 which is held by Thread-8

Thread stacks

Thread-1 [BLOCKED; waiting to lock test.GroovyEngineTest$1@2fe4cbc4]
java.lang.ClassLoader.loadClass(ClassLoader.java:292)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:696)
groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:449)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
java.lang.ClassLoader.loadClass(ClassLoader.java:248)
java.lang.Class.getDeclaredConstructors0(native method)
java.lang.Class.privateGetDeclaredConstructors(Class.java:2389)
java.lang.Class.getConstructor0(Class.java:2699)
java.lang.Class.getConstructor(Class.java:1657)
test.GroovyEngineTest.compileAndInstantiate(GroovyEngineTest.java:106)
test.GroovyEngineTest.access$200(GroovyEngineTest.java:19)
test.GroovyEngineTest$3.run(GroovyEngineTest.java:128)

Thread-8 [BLOCKED; waiting to lock groovy.lang.GroovyClassLoader$InnerLoader@671ff436]
java.lang.Class.getDeclaredFields0(native method)
java.lang.Class.privateGetDeclaredFields(Class.java:2291)
java.lang.Class.getDeclaredFields(Class.java:1743)
org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:313)
org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:263)
org.codehaus.groovy.ast.ClassNode.getInterfaces(ClassNode.java:341)
org.codehaus.groovy.ast.ClassNode.declaresInterface(ClassNode.java:929)
org.codehaus.groovy.ast.ClassNode.implementsInterface(ClassNode.java:909)
org.codehaus.groovy.classgen.AsmClassGenerator.doConvertAndCast(AsmClassGenerator.java:3842)
org.codehaus.groovy.classgen.AsmClassGenerator.doConvertAndCast(AsmClassGenerator.java:3837)
org.codehaus.groovy.classgen.AsmClassGenerator.storeThisInstanceField(AsmClassGenerator.java:2840)
org.codehaus.groovy.classgen.AsmClassGenerator.visitFieldExpression(AsmClassGenerator.java:2766)
org.codehaus.groovy.ast.expr.FieldExpression.visit(FieldExpression.java:38)
org.codehaus.groovy.classgen.AsmClassGenerator.evaluateEqual(AsmClassGenerator.java:4050)
org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:1485)
org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4122)
org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:1466)
org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)
org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:738)
org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:626)
org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:601)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:119)
org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructor(AsmClassGenerator.java:688)
org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1035)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:276)
org.codehaus.groovy.control.CompilationUnit$12.call(CompilationUnit.java:748)
org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:942)
org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:519)
org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:497)
org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:474)
groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)
groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:283)
groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:267)
groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:263)
groovy.lang.GroovyClassLoader.recompile(GroovyClassLoader.java:777)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:737)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
test.GroovyEngineTest$1.loadClass(GroovyEngineTest.java:29)
java.lang.ClassLoader.loadClass(ClassLoader.java:248)
test.GroovyEngineTest.compileAndInstantiate(GroovyEngineTest.java:105)
test.GroovyEngineTest.access$200(GroovyEngineTest.java:19)
test.GroovyEngineTest$3.run(GroovyEngineTest.java:128)

I tried also to override InnerLoader to add the modifier to method of this class but couldn't do it due to protected constuctor of ClassCollector.

I regret that you cannot reproduce this deadlock using your code. Maybe it help you if I sent you most recent version of my test class.;;;","19/Mar/11 17:38;skuklewicz;New version of test class;;;","19/Mar/11 18:32;blackdrag;I am sorry, I was not explaining enough I think... this loadClass method has to be synchronized on InnerLoader as well as normal GCL. And also the synchronization on the sourceCache should be replaced with a synchronization on ""this""... maybe the whole method it occurs in;;;","19/Mar/11 19:20;skuklewicz;I did some more research. Please tell if I am wrong ...

I extended test class to get some log info when class is put into GCL.classCache (by setClassCacheEntry) and also just before trying to instantiate previously compiled classes. Look at the logs i received ...

class registered test.C5@5e29c58e by Thread-1
	at java.lang.Thread.dumpStack(Thread.java:1249)
	at test.GroovyEngineTest$1.setClassCacheEntry(GroovyEngineTest.java:30)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:314)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:283)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:267)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:263)
	at groovy.lang.GroovyClassLoader.recompile(GroovyClassLoader.java:777)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:737)
	at groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:449)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:169)
	at test.C4.class$(test.C4)
	at test.C4.$get$$class$test$C5(test.C4)
	at test.C4.<init>(test.C4:4)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at test.GroovyEngineTest.compileAndInstantiate(GroovyEngineTest.java:111)
	at test.GroovyEngineTest.access$200(GroovyEngineTest.java:19)
	at test.GroovyEngineTest$3.run(GroovyEngineTest.java:133)
class registered test.C5@5e29c58e by Thread-1
	at java.lang.Thread.dumpStack(Thread.java:1249)
	at test.GroovyEngineTest$1.setClassCacheEntry(GroovyEngineTest.java:30)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:744)
	at groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:449)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:169)
	at test.C4.class$(test.C4)
	at test.C4.$get$$class$test$C5(test.C4)
	at test.C4.<init>(test.C4:4)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at test.GroovyEngineTest.compileAndInstantiate(GroovyEngineTest.java:111)
	at test.GroovyEngineTest.access$200(GroovyEngineTest.java:19)
	at test.GroovyEngineTest$3.run(GroovyEngineTest.java:133)

I combined info above with deadlock dump:

Thread-8 is waiting to lock groovy.lang.GroovyClassLoader$InnerLoader@5e29c58e which is held by Thread-1
Thread-1 is waiting to lock java.util.HashMap@24bb6086 which is held by Thread-8

Thread-1 [BLOCKED; waiting to lock java.util.HashMap@24bb6086]
groovy.lang.GroovyClassLoader.recompile(GroovyClassLoader.java:776)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:737)
groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:449)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
java.lang.ClassLoader.loadClass(ClassLoader.java:248)
java.lang.Class.getDeclaredFields0(native method)
java.lang.Class.privateGetDeclaredFields(Class.java:2291)
java.lang.Class.getDeclaredFields(Class.java:1743)
org.codehaus.groovy.reflection.CachedClass$1$1.run(CachedClass.java:47)
java.security.AccessController.doPrivileged(native method)
org.codehaus.groovy.reflection.CachedClass$1.initValue(CachedClass.java:44)
org.codehaus.groovy.reflection.CachedClass$1.initValue(CachedClass.java:42)
org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:46)
org.codehaus.groovy.util.LazyReference.get(LazyReference.java:33)
org.codehaus.groovy.reflection.CachedClass.getFields(CachedClass.java:253)
groovy.lang.MetaClassImpl.addFields(MetaClassImpl.java:2108)
groovy.lang.MetaClassImpl.inheritFields(MetaClassImpl.java:2103)
groovy.lang.MetaClassImpl.setupProperties(MetaClassImpl.java:1993)
groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:2950)
groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:2921)
org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:166)
org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:182)
org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:210)
org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:751)
org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallConstructorSite(CallSiteArray.java:69)
org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:52)
org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:190)
org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:194)
test.C4.<init>(test.C4:4)
sun.reflect.NativeConstructorAccessorImpl.newInstance0(native method)
sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
java.lang.reflect.Constructor.newInstance(Constructor.java:513)
test.GroovyEngineTest.compileAndInstantiate(GroovyEngineTest.java:111)
test.GroovyEngineTest.access$200(GroovyEngineTest.java:19)
test.GroovyEngineTest$3.run(GroovyEngineTest.java:133)

Thread-8 [BLOCKED; waiting to lock groovy.lang.GroovyClassLoader$InnerLoader@5e29c58e]
java.lang.Class.getDeclaredFields0(native method)
java.lang.Class.privateGetDeclaredFields(Class.java:2291)
java.lang.Class.getDeclaredFields(Class.java:1743)
org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:313)
org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:263)
org.codehaus.groovy.ast.ClassNode.getInterfaces(ClassNode.java:341)
org.codehaus.groovy.ast.ClassNode.declaresInterface(ClassNode.java:929)
org.codehaus.groovy.ast.ClassNode.implementsInterface(ClassNode.java:909)
org.codehaus.groovy.classgen.AsmClassGenerator.doConvertAndCast(AsmClassGenerator.java:3842)
org.codehaus.groovy.classgen.AsmClassGenerator.doConvertAndCast(AsmClassGenerator.java:3837)
org.codehaus.groovy.classgen.AsmClassGenerator.storeThisInstanceField(AsmClassGenerator.java:2840)
org.codehaus.groovy.classgen.AsmClassGenerator.visitFieldExpression(AsmClassGenerator.java:2766)
org.codehaus.groovy.ast.expr.FieldExpression.visit(FieldExpression.java:38)
org.codehaus.groovy.classgen.AsmClassGenerator.evaluateEqual(AsmClassGenerator.java:4050)
org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:1485)
org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4122)
org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:1466)
org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)
org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:738)
org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:626)
org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:601)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:119)
org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructor(AsmClassGenerator.java:688)
org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1035)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:276)
org.codehaus.groovy.control.CompilationUnit$12.call(CompilationUnit.java:748)
org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:942)
org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:519)
org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:497)
org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:474)
groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)
groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:283)
groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:267)
groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:263)
groovy.lang.GroovyClassLoader.recompile(GroovyClassLoader.java:777)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:737)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
java.lang.ClassLoader.loadClass(ClassLoader.java:248)
test.GroovyEngineTest.compileAndInstantiate(GroovyEngineTest.java:109)
test.GroovyEngineTest.access$200(GroovyEngineTest.java:19)
test.GroovyEngineTest$3.run(GroovyEngineTest.java:133)

My interpretation is that it was Thread-1 which created InnerLoader@5e29c58e and then used it to compile some classes. However, when completed, during instantiation of just received class, it locks on this InnerLoader and waits for sourceCache (because more compilation was needed). Until now all is right. What is wrong I think is behave of Thread-8. Thread-8 also compiled some classes, it must had created it's own InnerLoader but during compilation, in particular during invocation of org.codehaus.groovy.vmplugin.v5.Java5#configureClassNode it calls native methods of class, which ClassLoader is InnerLoader@5e29c58e - I mean class compiled by another Thread/InnerLoader. Thread-8 tries to lock 3 resources: it's own InnerLoader, sourceCache and the other InnerLoader.

If I am right, no combination of extra synchronization on InnerLoader, GCL or replacement of sourceCache synchronization to ""this"" will help. With all this improvements, Thread-1 will still lock on it's InnerLoader and then GroovyClassLoader (instead of sourceCache) and Thread-8 will lock on it's InnerLoader, then GCL and futher on another InnerLoader. Switching synchronization of sourceCache to ""this"" won't help because GCL does not take part in the deadlock. Switching synchronization of sourceCache to InnerLoader could help but such change would not also be logical of course.

What I can suggest is to improve package ""vmplugin.v5"" not to call native methods on classes not from it's own InnerLoader. Maybe an information this vmplugin gathers should be cached directly by original Thread (compilation process). This is just a guess. I really don't known what this vmplugin does.;;;","20/Mar/11 02:46;blackdrag;I should maybe first explain why we have InnerLoader. Each compilation get's its own InnerLoader. If you for example compile A and it depends on B and A,B is not compiled and you do a loadClass for A, then an innerLoader will be created and A will be added to the compilation. During compilation it will find that B is also to be compiled and adds it to the same compilation process. A and B will share the same class loader in the end. Now if recompilaltion is enabled and you change the file for A, the we need to define new A. You cannot define a new class with the name of an existing class in the same loader. Each classname, classloader pair must be unique. Thus we need a new loader for this. That's why we have a new loader per compilation. Would we kill inner loader, then we would kill the recompilation feature as well. 

If you look at the native methods being called there is one case:{code}at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
at java.lang.Class.forName0(Native Method)
at java.lang.Class.forName(Class.java:169)
at test.C4.class$(test.C4){code}
forName does no locking, but forName0 does. class$ is under our control... maybe we could let it call loadClass directly and so avoid the lock since GCL#loadClass ClassLoader#loadClass here won't impose it. That might be one part we have under our control.

For the other...{code}at java.lang.Class.getDeclaredFields0(Native Method)
at java.lang.Class.privateGetDeclaredFields(Class.java:2291)
at java.lang.Class.getDeclaredFields(Class.java:1743)
at
org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:313)
at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:263){code}
if you look at what this lazyClassInit and configureClassNode is, you will see that this is about populating a ClassNode by information from reflection. There is no real alternative for that. Simply using a different loader is not going to work, since we don't use any loader by ourselves and does so in the code of reflection, locking the loader of the class the class was defined in to get the information. 

btw... there is one more... getConstructor0 is also locking.... also on the Innerloader.

But if that really resolves the deadlock problem... no idea. Normally, if there is a deadlock you have 3 strategies you can follow: 
(1) reduce the number of places doing the locking
since this is in native code that we have not really any influence over we have no real chance here unless we can avoid the call at all
(2) reduce the number of different locks
This is normally the best chance, but since the locking happens on different InnerLoader we don't have a chance with this. 
(3) guard more places with synchronization
More or less this applies only if you have the synchronization under your control. We would need this lock being set before InnerLoader is set... we could do that for vm5plugin and let it synchronize on the parent GCL. We could have GCL#loadClass synchronized... but if that really helps... no idea.
 ;;;","20/Mar/11 03:01;blackdrag;Only problem.... how to avoid Class#forName? I need at least initially to get the loader somehow and for that I already need a class.;;;","20/Mar/11 06:57;skuklewicz;When I wrote previous comment, I knew the purpose that InnerLoaders are created for so I have no doubts that InnerLoader should stay.

If you really want to mess up with ""java.lang.Class"" you can try using so called ""java agents"". For example JRebel uses that to modify bytecode for java reflection package. But changing java.lang.Class sounds like we were to close too the edge. It may not be possible.

I think no general fix can be provided, we are not living in ideal world. The only thing I see to avoid the problem is to fix this particular case: stop vmplugin from calling Class#getDeclaredFields and others which would lock on InnerLoader. Can't such change really be done? As I suspect this plugin gathers information from reflections. Can't this information be gathered immediately by original Thread/InnerLoader and cached in some Map<Class, ClassReflectionData>? If we did it, we would also add some condition to the method Java5#configureClassNode to use this cache if class loader of specified class is InnerLoader and such loader is different than InnerLoader associated with current thread.;;;","21/Mar/11 04:46;blackdrag;You misunderstood, I cannot mess with the java.lang.Class class itself. If the central point is to ensure we lock on the parent GCL, before any lock on the InnerLoader happens, then I think there is no real way to resolve this, since this provides a problem for class loading done from generated classes. 

Then about the ClassNode init... Where would it be done, if not like now? We would have to cache the ClassNode we created in a different Thread. ClassNodes are not exactly light structures and they are not thread safe... also the compiler now does not keep them. Each compilation run makes a completely new compiler atm. This would mean a big change in the design of the compiler to realize this. And we would get a compiler that requires more memory, even if not running. The alternative would be the ClassReflectionData you spoke of... actually we have something like that already. I wonder if, if we would let the compiler use ClassInfo/CachedClass objects we would really save something. The problem is that it is not the part that does the compilation, that is causing the blocking call of getDeclaredFields0. It is another thread. So we would have to generate those directly after compilation I guess... But ClassInfo/CachedClass is a lazy structure, which means the info might have been collected before we reach the compiler part that needs the information. So this may still lead to deadlock and we still have to save a lot of information not lazy.

I am worried about the memory profile


Actually I wonder if we could instead use GroovyScriptEngine.

;;;","21/Mar/11 10:23;skuklewicz;ClassInfo/CachedClass info won't be collected if you use WeakHashMap or even better if you hook a reference directly into Class (just like __timestamp). WeakHashMap would cause more memory usage and is not thread safe. Memory usage will be probably doubled for any Groovy class definition.

How GroovyScriptEngine can help? I'm not familiar with class and what is a difference between GroovyScriptEngine and GroovyClassLoader from user's point of view.;;;","21/Mar/11 12:06;blackdrag;Szymon, before we actually advice something could you explain a little bit more your use case? Why are you forcing cache clearing?;;;","21/Mar/11 12:37;skuklewicz;We are using Groovy as main language in are web framework jPALIO. Users use dedicated IDE to manage remote source code which is stored in database and compiled directly on remote server. When developer saves objects, new version is saved in database and then GroovyClassLoader.clearCache is called as we want future request to run fresh version of application code. Full cache is cleared to remove also potential dependencies. There are multiple developers and web users working simultaneously on the same server.;;;","21/Mar/11 14:12;blackdrag;clearCache is not really intended to force recompilation. Normally the intension is o enable recompilation in the compiler configuration and set an recompilation interval that fits your needs. According to our tests here this prevents the deadlock too. But I wonder.. if you want everything to reload, wouldn't it be the most simple version to just use a completely new GroovyClassLoader?;;;","21/Mar/11 15:07;guillaume;Like Jochen, I think the best and cleanest approach would actually be to use a brand new GroovyClassLoader each time you need a clean recompilation, for a clean state. That's what we'd recommend usually.
That said, the GroovyClassLoader indeed has some deadlocks when used the way you've done it. I'm going to attach a patch which adds a ReentrantReadWriteLock: read locks wherever we synchronize on the sourceCache and classCache, and a write lock on the code of the clearCache() method. With that setup, I don't get any more blocked threads.
If you could try to recompile Groovy with that patch applied, and could come back to us with feedback, that's something we could integrate.;;;","21/Mar/11 15:08;guillaume;Usage of a ReentrantReadWriteLock.;;;","22/Mar/11 17:39;skuklewicz;I'm applying the patch but before I do it, I want to ask why synchronized statements were left so now are both ReadWriteLock and standard synchronization are used?;;;","22/Mar/11 17:42;blackdrag;because during the read locks there will be still concurrent modification of the maps when removing entries. Let us first see if it works, we can then still improve from there.;;;","22/Mar/11 19:02;skuklewicz;Deadlock:

Thread-3 is waiting to lock groovy.lang.GroovyClassLoader$InnerLoader@2321b59a which is held by Thread-7
Thread-7 is waiting to lock java.util.HashMap@4bb963c4 which is held by Thread-3

Thread stacks

Thread-3 [BLOCKED; waiting to lock groovy.lang.GroovyClassLoader$InnerLoader@2321b59a]
java.lang.Class.getDeclaredFields0(native method)
java.lang.Class.privateGetDeclaredFields(Class.java:2291)
java.lang.Class.getDeclaredFields(Class.java:1743)
org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:313)
org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:263)
org.codehaus.groovy.ast.ClassNode.getInterfaces(ClassNode.java:341)
org.codehaus.groovy.ast.ClassNode.declaresInterface(ClassNode.java:929)
org.codehaus.groovy.ast.ClassNode.implementsInterface(ClassNode.java:909)
org.codehaus.groovy.classgen.AsmClassGenerator.doConvertAndCast(AsmClassGenerator.java:3842)
org.codehaus.groovy.classgen.AsmClassGenerator.doConvertAndCast(AsmClassGenerator.java:3837)
org.codehaus.groovy.classgen.AsmClassGenerator.storeThisInstanceField(AsmClassGenerator.java:2840)
org.codehaus.groovy.classgen.AsmClassGenerator.visitFieldExpression(AsmClassGenerator.java:2766)
org.codehaus.groovy.ast.expr.FieldExpression.visit(FieldExpression.java:38)
org.codehaus.groovy.classgen.AsmClassGenerator.evaluateEqual(AsmClassGenerator.java:4050)
org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:1485)
org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4122)
org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:1466)
org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)
org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:738)
org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:626)
org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:601)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructor(ClassCodeVisitorSupport.java:119)
org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructor(AsmClassGenerator.java:688)
org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1035)
org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:276)
org.codehaus.groovy.control.CompilationUnit$12.call(CompilationUnit.java:748)
org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:942)
org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:519)
org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:497)
org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:474)
groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:315)
groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:289)
groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:270)
groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:266)
groovy.lang.GroovyClassLoader.recompile(GroovyClassLoader.java:808)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:765)
groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:458)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:827)
java.lang.ClassLoader.loadClass(ClassLoader.java:248)
java.lang.Class.forName0(native method)
java.lang.Class.forName(Class.java:169)
test.B2.class$(test.B2)
test.B2.$get$$class$test$B4(test.B2)
test.B2.<init>(test.B2:5)
sun.reflect.NativeConstructorAccessorImpl.newInstance0(native method)
sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
java.lang.reflect.Constructor.newInstance(Constructor.java:513)
test.GroovyEngineTest.compileAndInstantiate(GroovyEngineTest.java:105)
test.GroovyEngineTest.access$200(GroovyEngineTest.java:21)
test.GroovyEngineTest$2.run(GroovyEngineTest.java:128)

Thread-7 [BLOCKED; waiting to lock java.util.HashMap@4bb963c4]
groovy.lang.GroovyClassLoader.recompile(GroovyClassLoader.java:807)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:765)
groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:458)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:827)
java.lang.ClassLoader.loadClass(ClassLoader.java:248)
java.lang.Class.forName0(native method)
java.lang.Class.forName(Class.java:169)
test.C5.class$(test.C5)
test.C5.$get$$class$test$E5(test.C5)
test.C5.<init>(test.C5:4)
sun.reflect.NativeConstructorAccessorImpl.newInstance0(native method)
sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
java.lang.reflect.Constructor.newInstance(Constructor.java:513)
test.GroovyEngineTest.compileAndInstantiate(GroovyEngineTest.java:105)
test.GroovyEngineTest.access$200(GroovyEngineTest.java:21)
test.GroovyEngineTest$2.run(GroovyEngineTest.java:128)

I'm sorry but patch didn't help.

Answering your previous suggestion to create new GroovyClassLoader instead of clearCache ... I have doubts that need to be resolved first:

1) It does not look good because there's no point for InnerLoader to exist anymore (because without clearing cache same class won't be loaded twice)
2) If I did it, I would like to create a chain of GroovyClassLoader where old one always points to new one (as parent) so threads any time they use GroovyClassLoader first time, this class loader is mapped to this thread and any future usages of loader uses mapped GroovyClassLoader (to end of life of such thread) and moreover if there is a class missing in a loader, the class should be taken from future loaders (following parents path) - GroovyClassLoader does not have possibility to change parent loader;;;","23/Mar/11 04:03;blackdrag;If I see it right, then basically the problem is that we have an class and a dependency is outdated, but the class itself is also actually outdated, it exists only because he test program got a reference to it. The right thing to do for that would actually be to return the old version of the class here. A crazy idea would be to let the InnerLoader have a copy of the classCache from the time it was created and then answer loadClass requests directly from there instead of causing a fatal recompilation.

We will produce a patch later today for that I think.

About using a new GCL... your point (1) sounds like if you are afraid a dependency to a class will not exist anymore. There is a classCache that keeps references to defined classes. As long as this exists the InnerLoader used to defined them cannot be collected. So if you have a reference to one of those classes or loaders, all of them are not collected, since every InnerLoader references the GCL. One important part for it not blowing up though is that if none of the classes is referenced anymore that this all can be collected. If not your test would otherwise cause memory problems over time. And that is why (2) makes imho no sense. ;;;","23/Mar/11 09:07;guillaume;Could you please try this new patch?
It's more of a hack for now, but if it's working for your use case, that'd be interesting to know.
Thanks in advance.;;;","23/Mar/11 13:31;skuklewicz;Well

With recent patch it's much better now. Average time to deadlock raised from 2-3 seconds to 20-40 seconds. It was good shot ;)

I didn't have time to analyze stack traces because i'm going home soon but I hope the new deadlock is about resources that this time we control.

Multiple threads with such stack
groovy.lang.GroovyClassLoader.recompile(URL, String, Class)
groovy.lang.GroovyClassLoader.loadClass(String, boolean, boolean, boolean)
groovy.lang.GroovyClassLoader.loadClass(String, boolean)
java.lang.ClassLoader.loadClass(String)
test.GroovyEngineTest.compileAndInstantiate()
test.GroovyEngineTest.access$200(GroovyEngineTest)
test.GroovyEngineTest$2.run()

and last 3 were different

Thread-2 [WAITING] CPU time: 0:03
sun.misc.Unsafe.park(boolean, long)
java.util.concurrent.locks.LockSupport.park(Object)
java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt()
java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireShared(int)
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireShared(int)
java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock.lock()
groovy.lang.GroovyClassLoader.getClassCacheEntry(String)
groovy.lang.GroovyClassLoader.loadClass(String, boolean, boolean, boolean)
groovy.lang.GroovyClassLoader$InnerLoader.loadClass(String, boolean, boolean, boolean)
groovy.lang.GroovyClassLoader.loadClass(String, boolean)
java.lang.ClassLoader.loadClass(String)
java.lang.Class.getDeclaredConstructors0(boolean)
java.lang.Class.privateGetDeclaredConstructors(boolean)
java.lang.Class.getConstructor0(Class[], int)
java.lang.Class.getConstructor(Class[])
test.GroovyEngineTest.compileAndInstantiate()
test.GroovyEngineTest.access$200(GroovyEngineTest)
test.GroovyEngineTest$2.run()

Thread-3 [BLOCKED] CPU time: 0:02
java.lang.Class.getDeclaredMethods0(boolean)
java.lang.Class.privateGetDeclaredMethods(boolean)
java.lang.Class.getDeclaredMethods()
groovy.lang.GroovyClassLoader.doParseClass(GroovyCodeSource)
groovy.lang.GroovyClassLoader.parseClass(GroovyCodeSource, boolean)
groovy.lang.GroovyClassLoader.parseClass(GroovyCodeSource)
groovy.lang.GroovyClassLoader.parseClass(InputStream, String)
groovy.lang.GroovyClassLoader.recompile(URL, String, Class)
groovy.lang.GroovyClassLoader.loadClass(String, boolean, boolean, boolean)
groovy.lang.GroovyClassLoader.loadClass(String, boolean)
java.lang.ClassLoader.loadClass(String)
test.GroovyEngineTest.compileAndInstantiate()
test.GroovyEngineTest.access$200(GroovyEngineTest)
test.GroovyEngineTest$2.run()

Thread-8 [WAITING] CPU time: 0:02
sun.misc.Unsafe.park(boolean, long)
java.util.concurrent.locks.LockSupport.park(Object)
java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt()
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer$Node, int)
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(int)
java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock()
groovy.lang.GroovyClassLoader.clearCache()
test.GroovyEngineTest.writeAndClearCache()
test.GroovyEngineTest.access$100(GroovyEngineTest)
test.GroovyEngineTest$2.run()

Anyway, I changed in our application server that anytime some source change, new instance of GroocyClassLoader is created. Of course few days must pass to know if that helped. In real environment deadlocks are less frequently than this test.;;;","24/Mar/11 03:54;skuklewicz;Bad news. We encountered next deadlocks on our application server. Patches you gave me weren't there uploaded but new GroovyClassLoader was created after any modification, cache was not cleared and even recompilation was disabled!

Thread ID: 50
java.lang.ClassLoader.loadClass(ClassLoader.java:292)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:696)
groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:449)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
java.lang.ClassLoader.loadClass(ClassLoader.java:248)
java.lang.Class.getDeclaredConstructors0(Native Method)
java.lang.Class.privateGetDeclaredConstructors(Class.java:2389)
java.lang.Class.getConstructor0(Class.java:2699)
java.lang.Class.newInstance0(Class.java:326)
java.lang.Class.newInstance(Class.java:308)
palio.pelements.PObject.executeAsRoot(PObject.java:273)
palio.pelements.PPage.executeBody(PPage.java:285)
palio.pelements.PPage.writeBody(PPage.java:236)
html.run.buildResponse(run.java:359)
html.run.service(run.java:443)
javax.servlet.http.HttpServlet.service(HttpServlet.java:717)

Thread ID: 48
java.lang.Class.getDeclaredFields0(Native Method)
java.lang.Class.privateGetDeclaredFields(Class.java:2291)
java.lang.Class.getDeclaredFields(Class.java:1743)
org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:313)
org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:263)
org.codehaus.groovy.ast.ClassNode.getUnresolvedSuperClass(ClassNode.java:957)
org.codehaus.groovy.ast.ClassNode.getUnresolvedSuperClass(ClassNode.java:952)
org.codehaus.groovy.control.ResolveVisitor.checkCyclicInheritence(ResolveVisitor.java:1309)
org.codehaus.groovy.control.ResolveVisitor.visitClass(ResolveVisitor.java:1286)
org.codehaus.groovy.control.ResolveVisitor.startResolving(ResolveVisitor.java:148)
org.codehaus.groovy.control.CompilationUnit$6.call(CompilationUnit.java:574)
org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:814)
org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:511)
org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:487)
org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:464)
groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:306)
groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:283)
palio.compiler.groovy.GroovyEngine$MyGroovyClassLoader.parseClass(GroovyEngine.java:75)
groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:267)
groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:263)
palio.compiler.groovy.GroovyEngine$MyGroovyClassLoader.parseClass(GroovyEngine.java:69)
groovy.lang.GroovyClassLoader.recompile(GroovyClassLoader.java:777)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:737)
groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:793)
palio.compiler.groovy.GroovyEngine$MyGroovyClassLoader.loadClass(GroovyEngine.java:61)
java.lang.ClassLoader.loadClass(ClassLoader.java:248)
palio.compiler.groovy.GroovyEngine.getCompiledClass(GroovyEngine.java:236)
palio.pelements.PObject.precompile(PObject.java:308)
palio.pelements.PObject.executeAsRoot(PObject.java:268)
palio.pelements.PPage.executeBody(PPage.java:285)
palio.pelements.PPage.writeBody(PPage.java:236)
html.run.buildResponse(run.java:359)
html.run.service(run.java:443)
javax.servlet.http.HttpServlet.service(HttpServlet.java:717)

I know that last patch probably fix it and with combination of disabled recompilation/no cache clearing there should be OK but I would like to ask you if you could prepare LightweightGroovyClassLoader where recompilation is not possible, clearing cache is not possible and thus ... InnerLoader is not used? That would rid off deadlocks for sure.;;;","25/Mar/11 08:39;guillaume;Could you try on your app server with the patch as well?;;;","25/Mar/11 10:03;skuklewicz;Yes. Of course. I started server using Groovy with patch included and there haven't been any deadlock since yesterday (but were not been heavily loaded that time);;;","25/Mar/11 13:31;guillaume;Keep me updated, so that I can see whether I should include that patch in Groovy or not.;;;","30/Mar/11 07:45;guillaume;Still no deadlock so far with that latest patch?;;;","30/Mar/11 16:28;skuklewicz;No more deadlock so far. Normally should already happen few times so I think the second patch really helps. Thanks;;;","30/Mar/11 16:32;guillaume;Okie dokie, good to know! Thanks for reporting that news back to me.
That patch is kinda... ""interesting"", in the sense that it's more of a hack to circumvent the weird locking issues happening inside JDK native code... but well, so far that's the sole workaround we've found, without too huge changes in our codebase. 
Hopefully we'll find a better solution at some point.
So in the meantime, we'll certainly add that patch in the next versions.;;;","31/Mar/11 04:24;skuklewicz;Unfortunately we encountered a deadlock. This time it's deadlock between outer and inner loader. Because it's another kind of deadlock it explains why it shows much rarlier now. Please ignore fact that we use overriden implementation of GCL - MyGroovyClassLoader is only for extra security (restricted access only to dictionary packages) and does interfere with any synchronizations.

Thread t@218
   java.lang.Thread.State: BLOCKED
	at java.lang.ClassLoader.loadClass(ClassLoader.java:292)
	- waiting to lock <158f69e2> (a palio.compiler.groovy.GroovyEngine$MyGroovyClassLoader) owned by Thread t@215
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:732)
	at groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:466)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:835)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:169)
	at eway.ui.web.portal.widget.coupon.CouponWidgetController.class$(eway.ui.web.portal.widget.coupon.CouponWidgetController.groovy)
	at eway.ui.web.portal.widget.coupon.CouponWidgetController.$get$$class$palio$Groovy(eway.ui.web.portal.widget.coupon.CouponWidgetController.groovy)
	at eway.ui.web.portal.widget.coupon.CouponWidgetController.<clinit>(eway.ui.web.portal.widget.coupon.CouponWidgetController.groovy:16)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at java.lang.Class.newInstance0(Class.java:355)
	at java.lang.Class.newInstance(Class.java:308)
	at palio.pelements.PObject.executeAsRoot(PObject.java:273)
	at palio.pelements.PPage.executeBody(PPage.java:285)
	at palio.pelements.PPage.writeBody(PPage.java:236)
	at html.run.buildResponse(run.java:359)
	at html.run.service(run.java:443)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)

   Locked ownable synchronizers:
	- None

Thread t@215
   java.lang.Thread.State: BLOCKED
	at java.lang.Class.forName0(Native Method)
	- waiting to lock <1b234cfc> (a groovy.lang.GroovyClassLoader$InnerLoader) owned by Thread t@218
	at java.lang.Class.forName(Class.java:247)
	at sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:95)
	at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:107)
	at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:31)
	at sun.reflect.annotation.AnnotationParser.parseSig(AnnotationParser.java:370)
	at sun.reflect.annotation.AnnotationParser.parseAnnotation(AnnotationParser.java:181)
	at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:69)
	at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:52)
	at java.lang.reflect.Method.declaredAnnotations(Method.java:693)
	- locked <1c207eea> (a java.lang.reflect.Method)
	at java.lang.reflect.Method.getDeclaredAnnotations(Method.java:686)
	at java.lang.reflect.AccessibleObject.getAnnotations(AccessibleObject.java:175)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:325)
	at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:263)
	- locked <12a7a16f> (a java.lang.Object)
	at org.codehaus.groovy.ast.ClassNode.getInterfaces(ClassNode.java:341)
	at org.codehaus.groovy.ast.ClassNode.declaresInterface(ClassNode.java:929)
	at org.codehaus.groovy.ast.ClassNode.implementsInterface(ClassNode.java:909)
	at org.codehaus.groovy.ast.ClassNode.isDerivedFromGroovyObject(ClassNode.java:899)
	at org.codehaus.groovy.classgen.AsmClassGenerator.loadWrapper(AsmClassGenerator.java:3225)
	at org.codehaus.groovy.classgen.AsmClassGenerator.makeCallSite(AsmClassGenerator.java:2183)
	at org.codehaus.groovy.classgen.AsmClassGenerator.makeCall(AsmClassGenerator.java:2019)
	at org.codehaus.groovy.classgen.AsmClassGenerator.makeCall(AsmClassGenerator.java:2005)
	at org.codehaus.groovy.classgen.AsmClassGenerator.makeInvokeMethodCall(AsmClassGenerator.java:1990)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:2342)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:75)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4122)
	at org.codehaus.groovy.classgen.AsmClassGenerator.evaluateExpression(AsmClassGenerator.java:1447)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:1408)
	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:626)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:601)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:696)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1039)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:276)
	at org.codehaus.groovy.control.CompilationUnit$12.call(CompilationUnit.java:748)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:942)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:519)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:497)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:474)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:315)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:289)
	- locked <3b5787fa> (a java.util.HashMap)
	at palio.compiler.groovy.GroovyEngine$MyGroovyClassLoader.parseClass(GroovyEngine.java:75)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:270)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:266)
	at palio.compiler.groovy.GroovyEngine$MyGroovyClassLoader.parseClass(GroovyEngine.java:69)
	at groovy.lang.GroovyClassLoader.recompile(GroovyClassLoader.java:816)
	- locked <3b5787fa> (a java.util.HashMap)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:773)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:835)
	at palio.compiler.groovy.GroovyEngine$MyGroovyClassLoader.loadClass(GroovyEngine.java:61)
	- locked <158f69e2> (a palio.compiler.groovy.GroovyEngine$MyGroovyClassLoader)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
	at palio.compiler.groovy.GroovyEngine.getCompiledClass(GroovyEngine.java:236)
	at palio.pelements.PObject.precompile(PObject.java:308)
	at palio.pelements.PObject.executeAsRoot(PObject.java:268)
	at palio.pelements.PPage.executeBody(PPage.java:285)
	at palio.pelements.PPage.writeBody(PPage.java:236)
	at html.run.buildResponse(run.java:359)
	at html.run.service(run.java:443)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)

   Locked ownable synchronizers:
	- None
;;;","05/Apr/11 09:54;skuklewicz;Hi

Is there any progress in resolving this deadlock?
Stability of server is much greater but still deadlock happens once few days.;;;","19/Sep/12 04:12;blackdrag;If it is possible that first a lock on inner loader is acquired and then the thread tries to lock GCL, while another Thread is locking GCL and tries to acquire a lock on inner loader, then this is nothing that we can fix I believe. The locking is done through native code. It is different with Java7, which uses less locking. There this problem should not happen. Other than that, only a structural change can help.

How can this happen? 

If you load a class from the inner loader using a class defined on inner loader, then it my cause for example through Class#forName0 a lock on that inner loader. If that class depends on a class from the outer loader, it may cause a similar lock on that loader. That's one direction.

The other direction is actually more difficult.. we start with a lock on GCL and then for example cause the init of a class defined in the innerLoader. This could happen through a compilation for example. The question is where this first lock should come from. GCL itself does not define classes, so any Class#forName0 way would start with the inner loader, same for bean property stuff and other reflection related locking.

Looking at your stack again makes me now realize, that there is:
at palio.compiler.groovy.GroovyEngine$MyGroovyClassLoader.loadClass(GroovyEngine.java:61)
locked <158f69e2> (a palio.compiler.groovy.GroovyEngine$MyGroovyClassLoader)
at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
at palio.compiler.groovy.GroovyEngine.getCompiledClass(GroovyEngine.java:236)

And I read it that ClassLoader#loadClass is calling a GCL#loadClass. After realizing this the reason becomes obvious to me... GCL is missing loadClass(String)! If GCL would override loadClass(String) without doing the locking, then this first lock cannot happen. If the first lock cannot happen, there will be no deadlock;;;","20/Sep/12 08:32;blackdrag;I made some changes to GroovyClassLoader that may or may not have improved the situation. Is it possible for someone here to test it?;;;","29/Jan/14 09:10;guillaume;Jochen made some changes, but we didn't receive any further feedback, so we close the issue for now.

If you notice a problem, please reopen the issue, or create a new one.;;;",,,,,,,
Object initializer not being called on object construction,GROOVY-4734,12815562,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,werdna,werdna,17/Mar/11 18:50,13/Apr/11 14:33,14/Jul/23 06:00,04/Apr/11 14:56,1.8-rc-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-4,,,,,,,0,,,,,,"Perhaps related to GROOVY-4733.

I would expect that this code prints ""99"", but it doesn't.  It prints ""9"":
{code}
class A {
        {
                print f
		}
        def f = 9 //
		def other = { }
		{
        	print f }
}
new A()
{code}

This code, however, prints ""99"":


{code}
class A {
        {
                print f
		}
		{
        	print f }
        def f = 9 //
		def other = { }
}
new A()
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 04 14:56:46 UTC 2011,,,,,,,,,,"0|i2cl9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Mar/11 22:58;werdna;This problem does not occur in 1.7.;;;","18/Mar/11 04:06;melix;This doesn't look like a bug to me : forward references are forbidden in initialization blocks. At least, the compiler should have failed in both cases.;;;","18/Mar/11 10:26;werdna;This is not really a forward reference.  Since the class knows all of its fields at load time, the field can be referenced in a constructor or initializer lexically before it is declared.  

Eg, this is legal in Java:

{code}
public class C {
    static {
        f = 0;
    }
    static int f;
    {
        f2 = 0;
    }
    int f2;
}
{code}

Also, the code above has worked in the 1.7 stream, so something must have changed.;;;","19/Mar/11 12:07;melix;Your last snippet in Java is valid because it's a field initialization. But this would fail (and it's the same as your report) :
{code}
static {
        System.out.println(f);
    }
    static int f = 0;
{code};;;","19/Mar/11 16:04;werdna;Try running this in Java 1.5:
{code}
public class C {
    static {
        f = 2;
    }
    static int f;
    {
        f2 = 2;
    }
    int f2;
    public static void main(String[] args) {
        System.out.println(f);
        System.out.println(new C().f2);
    }
}
{code}
I expect that you would get:
{code}
2
2
{code}

If you don't, then I would be surprised (since that is what I got when I ran the program).

Even if, as you mention, static initializers cannot contain forward references (which it seems like they can), the original problem was about object initializers.  

This is a regression from Groovy 1.7.x, which allowed this kind of code.;;;","20/Mar/11 04:56;melix;mmm, can't see any regression here. Using Groovy 1.8-rc3, there's no problem with your latest example, it works as expected. I'm still thinking your original problem is that you had println statements which were indeed forward references.

{code}
public class C {
    static {
        f = 2;
    }
    static int f;
    {
        f2 = 3;
    }
    int f2;
    public static void main(String[] args) {
        System.out.println(org.codehaus.groovy.runtime.InvokerHelper.getVersion())
        System.out.println(f);
        System.out.println(new C().f2);
    }
}
{code}

Outputs :

{code}
1.8.0-rc-3
2
3
{code};;;","20/Mar/11 10:53;werdna;Cedric,

I don't think you tried my original example.  Here is a simpler way to recreate the problem.

Execute this in RC3:

{code}
class A {
  { f }
  def f = 9
  { f }
}
new A()
{code}

This exception:
{code}
Caught: groovy.lang.MissingMethodException: No signature of method: java.lang.Integer.call() is applicable for argument types: (A$_closure1) values: [A$_closure1@4fa4ded3]
Possible solutions: wait(), abs(), any(), wait(long), any(groovy.lang.Closure), each(groovy.lang.Closure)
	at A.<init>(a.groovy:3)
	at a.run(a.groovy:7)
{code}

Now comment out the second initializer and there is no exception:

{code}
class A {
  { f }
  def f = 9
  // { f }
}
new A()
{code}

Same forward reference each time.  Different behavior.;;;","20/Mar/11 10:54;werdna;BTW- This is not exactly the same problem described at the top of this bug report, but it is probably related.  This is the issue I raised in GROOVY-4733.;;;","21/Mar/11 09:20;melix;Ok, my understanding of your last example code is that it shouldn't compile in both cases. So the bug is, to me, that we allow forward references where we shouldn't. 

{code}
{f}
def f = 9
{code}

is a forward reference (since no value is set, it only returns the value of the f field).
;;;","21/Mar/11 10:31;werdna;Why are you proposing that Groovy should disallow references as in the example I provide above?  I know that Groovy is not Java, but disallowing such references would be an unnecessary departure (IMHO) from Java semantics.  

Despite what you said earlier, forward references in Java initializer blocks are allowed.  Why should Groovy be any different?;;;","22/Mar/11 04:38;melix;From what I read here, yes, the example you provide should not compile, neither in Java nor Groovy : http://java.sun.com/docs/books/jls/second_edition/html/classes.doc.html#287406;;;","22/Mar/11 11:05;werdna;Ummmm....yes.  This does compile (in Java):

{code}
class Test {
  { j = 9; }	
  int j = 1;
}
{code}

And this:

{code}
class Test {
  static { j = 9; }	
  static int j = 1;
}
{code}

However, you are correct that this does not compile:

{code}
class Test {
  int i = j;
  int j = 1;
}
{code}
;;;","22/Mar/11 12:03;werdna;Let me rephrase my previous comment.  

{code}
class Test {
  { j = 9; }	
  int j = 1;
}
{code}

works but only because the {{j}} variable is assigned but not used.

This, however, does not work:

{code}
class Test {
  { int i = j; }	
  int j = 1;
}
{code}

I am very surprised that Javac does not flag the first program as an error.

I think the best thing to do right now is for me to come up with a very good example of what the problem is.  I feel that we have gone off track here while we talk about initializers.;;;","04/Apr/11 14:56;werdna;It seems that the real problem here was reported (and fixed) under GROOVY-4747.  The other problems that I saw were actually confusions regarding how initializers work in Java and how Groovy parses code blocks.  Thanks for your help in getting me to understand this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java5 configureClassNode does not take care of parameter annotations,GROOVY-4732,12817905,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,andre.steingress,andre.steingress,17/Mar/11 10:26,05/Apr/15 14:44,14/Jul/23 06:00,14/Jul/11 10:34,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,Compiler,,,,0,,,,,,"whenever annotation parameters are specified in byte-code, the Java5 vm-plugin does not include those annotations as AnnotationNode instances when configuring a ClassNode for that particular class.

the following code is from a local test-case: 

{code}
void testParameterAnnotation() { 

        GroovyClassLoader gcl = new GroovyClassLoader() 

        gcl.parseClass """""" 
            import java.lang.annotation.* 

            @Target(ElementType.METHOD) 
            @Retention(RetentionPolicy.RUNTIME) 
            @interface MethodAnnotation {} 

            @Target(ElementType.PARAMETER) 
            @Retention(RetentionPolicy.RUNTIME) 
            @interface ParameterAnnotation {} 

            interface MyInterface { 
                @MethodAnnotation 
                def method(@ParameterAnnotation def param) 
            } 
        """""" 

        GroovyCodeSource codeSource = new GroovyCodeSource("""""" 
            class MyInterfaceImpl implements MyInterface { 
                def method(def param) {} 
            } 
        """""", ""script"" + System.currentTimeMillis() + "".groovy"", ""/groovy/script"") 

        CompilationUnit cu = new CompilationUnit(CompilerConfiguration.DEFAULT, codeSource.codeSource, gcl) 
        cu.addSource(codeSource.getName(), codeSource.scriptText); 
        cu.compile(CompilePhase.FINALIZATION.phaseNumber) 

        def classNode = cu.getClassNode(""MyInterfaceImpl"") 
        def interfaceClassNode = classNode.getInterfaces().find { it.nameWithoutPackage == 'MyInterface' } 

        def methodNode = interfaceClassNode.getDeclaredMethods(""method"")[0] 

        // check if the AnnotationNode for 'MethodAnnotation' has been created 
        assert methodNode.getAnnotations().any { AnnotationNode an -> an.classNode.nameWithoutPackage == 'MethodAnnotation' } 
        
        // this one will fail, since parameter annotations are ignored by Java5Plugin (and above) 
        assert methodNode.getParameters()[0].getAnnotations().any { AnnotationNode an -> an.classNode.nameWithoutPackage == 'ParameterAnnotation' } 
}
{code} 

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Mar/11 10:26;andre.steingress;java5_param_annos.patch;https://issues.apache.org/jira/secure/attachment/12722739/java5_param_annos.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Thu Jul 14 10:34:56 UTC 2011,,,,,,,,,,"0|i2cgfb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"14/Apr/11 08:02;blackdrag;I make this blocker only because I want to ensure it gets in the next release, not because the issue is fatal;;;","14/Jul/11 10:34;blackdrag;patch applied, thanks for providing it;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
sample code in javadoc of Map#spreadMap() don't works,GROOVY-4731,12815557,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,uehaj,uehaj,17/Mar/11 08:52,13/Apr/11 14:33,14/Jul/23 06:00,13/Apr/11 03:58,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-4,,,groovy-jdk,,,,0,,,,,,"At the GDK document of Map#toSpreadMap(),

http://groovy.codehaus.org/groovy-jdk/java/util/Map.html#toSpreadMap()

says:
{quote}
For examples, if there is defined a function like as

    def fn(a, b, c, d) { return a + b + c + d }
, then all of the following three have the same meaning.
    println fn(a:1, [b:2, c:3].toSpreadMap(), d:4)
    println fn(a:1, *:[b:2, c:3], d:4)
    println fn(a:1, b:2, c:3, d:4)
{quote}

I think there are at least 2 problems here.

1) fn should take Map parameter like:
{quote}
    def fn(Map m) \{ return m.a + m.b + m.c + m.d \}
{quote}

2) I changed it in 1) way but I get following error at the line calling toSpreadMap().
{quote}
Caught: groovy.lang.MissingMethodException: No signature of method: d.fn() is applicable for argument types: (java.util.LinkedHashMap, groovy.lang.SpreadMap) values: [[a:1, d:4], [:]]
Possible solutions: fn(java.util.Map), run(), run(), any(), run(java.io.File, [Ljava.lang.String;), any(groovy.lang.Closure)
	at d.run(d.groovy:3)
{quote}



",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 13 03:58:56 UTC 2011,,,,,,,,,,"0|i2cg53:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Mar/11 09:11;blackdrag;you are absolutely right in assuming that the documentation is wrong.

But only the later two cases fn(a:1, *:[b:2, c:3], d:4) and fn(a:1, b:2, c:3, d:4) are supposed to be equal. The toSpreadMap() can and will not do that. Also you are right too about fn needing a Map. ;;;","20/Mar/11 09:19;uehaj;So you mean method Map#toSpreadMap() and spread map operator(*:\) have different semantics?
;;;","13/Apr/11 03:58;paulk;Javadoc has been updated - and example is now turned into test so should remain correct now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Object.toString() called instead of coerced Map toString closure,GROOVY-4729,12817888,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,travishume,travishume,16/Mar/11 16:05,14/Oct/11 00:28,14/Jul/23 06:00,10/Oct/11 06:53,1.7.9,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.4,1.9-beta-4,mocks and stubs,,,,0,,,,,,"Sorry to open a new issue, this is very similar to http://jira.codehaus.org/browse/GROOVY-2801

In this instance, I'm mocking the toString method on an Abstract class SocketAddress.

channel = [
    getRemoteAddress: { [toString: remoteAddress] as SocketAddress },
    getLocalAddress: { [toString: localAddress] as SocketAddress }
] as Channel

and during the test, I receive a failure:


org.junit.ComparisonFailure: expected:<[10.10.2.20]> but was:<[SocketAddress_groovyProxy@5a425eb9]>
	at org.junit.Assert.assertEquals(Assert.java:123)
	at org.junit.Assert.assertEquals(Assert.java:145)
	at org.junit.Assert$assertEquals.callStatic(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallStatic(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:165)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:177)


GROOVY-2801 was closed some time ago so I'm opening this new issue.","Ubuntu linux 10.10 x86_64

java version ""1.6.0_21""
Java(TM) SE Runtime Environment (build 1.6.0_21-b06)
Java HotSpot(TM) 64-Bit Server VM (build 17.0-b16, mixed mode)

Groovy Version: 1.7.9 JVM: 1.6.0_21",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 18 09:45:04 UTC 2011,,,,,,,,,,"0|i2csjz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Mar/11 16:26;travishume;Worked around by creating another class

channel = [
    getRemoteAddress: { new MockSocketAddress(address: remoteAddress) },
    getLocalAddress: { new MockSocketAddress(address: localAddress) }
] as Channel

...

class MockSocketAddress extends SocketAddress {
    def address
    
    public String toString() {
        address
    }
}
;;;","17/Mar/11 09:46;travishume;A minimal test case demonstrating the problem
{noformat}
package test

import static org.junit.Assert.*
import org.junit.Test;

class Groovy4729Test {

    @Test
    public void toStringTest() {
        def mock = [toString: { ""foo"" }]
        assertEquals(""foo"", mock.toString())
    }
}
{noformat}

Fails with:
org.junit.ComparisonFailure: expected:<[foo]> but was:<[[toString:test.GROOVY4729Test$_toStringTest_closure1@7c5b0668]]>
;;;","18/Mar/11 09:45;travishume;Bug persists in groovy-1.8.0-rc-3

{noformat}
Groovy Shell (1.8.0-rc-3, JVM: 1.6.0_21)
Type 'help' or '\h' for help.
-----------------------------------------------------------------------------------------------------
groovy:000> m = [toString: {'foo'}] as String
===> [toString:groovysh_evaluate$_run_closure1@695cd9c0]
groovy:000> assert 'foo' == m.toString()
ERROR org.codehaus.groovy.runtime.powerassert.PowerAssertionError:
assert 'foo' == m.toString()
             |  | |
             |  | [toString:groovysh_evaluate$_run_closure1@695cd9c0]
             |  [toString:groovysh_evaluate$_run_closure1@695cd9c0]
             false
        at groovysh_evaluate.run (groovysh_evaluate:2)
        ...
{noformat};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Adding ""return"" automatically in nested switch statements",GROOVY-4727,12815534,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,roshandawrani,roshandawrani,15/Mar/11 06:55,27/Aug/21 10:22,14/Jul/23 06:00,02/Mar/21 15:19,1.9-beta-1,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.15,3.0.8,4.0.0-alpha-3,Compiler,,,,0,,,,,,"The following does not work. See: http://markmail.org/message/ekm45sghpzh227ga

{code}
assert foo('x1', 'y1') == 'r1'
def foo(x, y) {
    switch(x) {
        case 'x1':
            switch(y) {
                case 'y1':
                    'r1';
                    break;
                case 'y2':
                    'r2';
                    break;
            }
    }
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-03-15 06:55:53.0,,,,,,,,,,"0|i2bpdr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Method overriding with ExpandoMetaClass is partially broken,GROOVY-4720,12817823,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,guillaume,graemerocher,graemerocher,11/Mar/11 04:57,13/Apr/11 14:33,14/Jul/23 06:00,24/Mar/11 09:31,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8-rc-4,1.9-beta-1,,,,,0,,,,,,"There is a regression whereby you cannot override methods using ExpandoMetaClass.

The reason is that ClosureMetaMethod.createMethodList creates an anonymous inner class of type MetaMethod and adds it to the returned List<MetaMethod> that are to be registered

Later the isNonRealMethod(MetaMethod) check in MetaMethodIndex does this check:

{code}
    private boolean isNonRealMethod(MetaMethod method) {
        return method instanceof NewInstanceMetaMethod ||
                method instanceof NewStaticMetaMethod ||
                method instanceof ClosureMetaMethod ||
                method instanceof GeneratedMetaMethod ||
                method instanceof ClosureStaticMetaMethod ||
                method instanceof MixinInstanceMetaMethod;
    }
{code}

Since the anonymous inner MetaMethod defined in ClosureMetaMethod is not an instance of any of these types then  the method is never registered in the MetaMethodIndex:

{code}

                    if (methodC == matchC) {
                        if (isNonRealMethod(method)) {
                            list.set(found, method);
                        }
{code}",,brownj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Mar/11 11:03;guillaume;GROOVY-4720__Method_overriding_with_ExpandoMetaClass_is_partially_broken.patch;https://issues.apache.org/jira/secure/attachment/12722738/GROOVY-4720__Method_overriding_with_ExpandoMetaClass_is_partially_broken.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 24 09:30:52 UTC 2011,,,,,,,,,,"0|i2ck2v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Mar/11 16:09;blackdrag;Graeme, if I understand you right, then the change you are speaking of is from Dez 11 2008 and a reaction to GROOVY-2951. That means that every 1.7 version has this bug, since this one was for 1.7 beta1. You said it was an regression, but really since back then? The changes in MetaMethodIndex go back to even July 15 2008 and the class was not touched since then. Can you provide a test case?;;;","15/Mar/11 07:33;guillaume;Graeme, any update on this one? How did you produce the problem? Do you have some sample we could have a look at?;;;","16/Mar/11 11:03;guillaume;Without further explanations on how to reproduce the issue, it's difficult to figure out what to do, and how to check it's the proper thing to do, despite having had several persons trying to reproduce the issue for several hours without any luck so far.
Anyhow, according to the explanations of the JIRA issue, if we follow the idea of creating a special MetaMethod class for use in ClosureMetaMethod#createMethodList() instead of the anonymous inner class, and then referencing that class in the instanceof checks of MetaMethodIndex#isNonRealMethod(), then all tests still pass.
So I've created such a patch, and am attaching it here.
It would be good if you could test it, and better if you could provide a test case showing the problem.;;;","23/Mar/11 03:56;graemerocher;Jochen/Guillaume - The regression is not new and I have a workaround so maybe it can be downgraded from blocker. I uncovered the regression as part of the new GORM/NoSQL work. 

I will try out the patch Guillaume and feedback asap, although the regression is old I'm sure we can agree this is the wrong behavior and should be fixed;;;","24/Mar/11 08:13;graemerocher;Reproducible example http://groovyconsole.appspot.com/script/440004;;;","24/Mar/11 09:30;guillaume;Exactly what I needed to test my patch.
And indeed, that fixes it.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy build fails in tests - test RedundantCastInStubTest fails,GROOVY-4719,12815539,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,mikevines,mikevines,10/Mar/11 02:41,10/Mar/11 06:02,14/Jul/23 06:00,10/Mar/11 05:57,1.7.9,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.10,1.8-rc-3,1.9-beta-1,,,,,0,,,,,,"1 error in UberTestCaseGroovySourceCodehausPackages:

-testAll:
    [mkdir] Created dir: C:\MIKEDATA\java\groovy\groovy-1.7.9\target\test-reports
    [junit] WARNING: multiple versions of ant detected in path for junit
    [junit]          jar:file:/C:/Program%20Filez/ant/lib/ant.jar!/org/apache/tools/ant/Project.class
    [junit]      and jar:file:/C:/MIKEDATA/java/groovy/groovy-1.7.9/target/lib/compile/ant-1.8.2.jar!/org/apache/tools/ant/Project.class
    [junit] Running UberTestCaseBugs
    [junit] Tests run: 420, Failures: 0, Errors: 0, Time elapsed: 16.653 sec
    [junit] Running UberTestCaseGroovySourceCodehausPackages
    [junit]
    [junit] Tests run: 461, Failures: 0, Errors: 1, Time elapsed: 85.02 sec
    [junit] Test UberTestCaseGroovySourceCodehausPackages FAILED
    [junit] Running UberTestCaseGroovySourceCodehausPackages_VM6
    [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.359 sec
    [junit] Running UberTestCaseGroovySourceRootPackage
    [junit] Tests run: 1016, Failures: 0, Errors: 0, Time elapsed: 51.935 sec
    [junit] Running UberTestCaseGroovySourceSubPackages
    [junit] Tests run: 1284, Failures: 0, Errors: 0, Time elapsed: 101.457 sec
    [junit] Running UberTestCaseGroovySourceSubPackages_VM6
    [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.265 sec
    [junit] Running UberTestCaseJavaSourceCodehausPackages
    [junit] Tests run: 610, Failures: 0, Errors: 0, Time elapsed: 42.786 sec
    [junit] Running UberTestCaseJavaSourceGroovyPackagesNonSecurity
    [junit] Tests run: 410, Failures: 0, Errors: 0, Time elapsed: 9.993 sec
    [junit] Running UberTestCaseJavaSourceGroovyPackagesSecurity
    [junit] Tests run: 16, Failures: 0, Errors: 0, Time elapsed: 10.766 sec
    [junit] Running UberTestCaseTCK
    [junit] Tests run: 231, Failures: 0, Errors: 0, Time elapsed: 6.88 sec

Error is on test RedundantCastInStubTest.
","Windows 7, Oracle Java 1.6.0_24-b07",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Mar/11 02:41;mikevines;TEST-UberTestCaseGroovySourceCodehausPackages.xml;https://issues.apache.org/jira/secure/attachment/12722831/TEST-UberTestCaseGroovySourceCodehausPackages.xml",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 10 05:15:44 UTC 2011,,,,,,,,,,"0|i2brf3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Mar/11 03:02;mikevines;TEST-UberTestCaseGroovySourceCodehausPackages.xml has been attached containing detail of the error in the test.;;;","10/Mar/11 03:03;guillaume;This test passes for me locally, as well as on our continuous integration server, and you're the first to encounter this problem it seems. 
This is mysterious to me and I can't reproduce it for now.
It fails for you in StubTestCase on line 260:
{code}
new File(stubDir, fqn.replaceAll(/\./, File.separator) + '.java').text
{code}
The java.lang.String#replaceAll() seems to be the one causing the problem.
Any idea why it could fail on your environment? (Windows file path issue???);;;","10/Mar/11 04:05;mikevines;File.Separator on Windows is the back slash character (\), which needs to be escaped in a string.

{code}
String stubDir = new File(""."").getAbsolutePath();
String fqn = ""some.ClassWithPrimitiveBoolean"";
File a = new File(stubDir, fqn.replaceAll(/\./, ""\\\\"") + '.java') ;
File b = new File(stubDir, fqn.replaceAll(/\./, File.separator) + '.java');
{code}

Setting of variable a will work, but it fails the same as the uber test on assigning b.  Also fails as you would expect if ""\\"" is put in instead of using File.separator.

Mike;;;","10/Mar/11 04:09;mikevines;My last comment didnt not appear correctly - this is effectively what I meant also fails:

{code}
String stubDir = new File(""."").getAbsolutePath();
String fqn = ""some.ClassWithPrimitiveBoolean"";
File c = new File(stubDir, fqn.replaceAll(/\./, ""\\"") + '.java');
{code}

Mike;;;","10/Mar/11 04:12;guillaume;Could you please come up with a patch that would make the test pass for you?;;;","10/Mar/11 04:26;mikevines;How about:

{code}
new File(stubDir, fqn.replace('.' as char, File.separatorChar) + '.java').text
{code};;;","10/Mar/11 04:33;guillaume;Have you tried it, and it's working for you?;;;","10/Mar/11 04:35;mikevines;Yes - has not passed all tests, and build complete.

Thanks for your help,
Mike;;;","10/Mar/11 05:15;guillaume;The proposed change works for me here.
I'm waiting the confirmation from someone else on a windows machine to confirm it's working fine with the change.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Example code in http://groovy.codehaus.org/Groovy+JmxBuilder does not work,GROOVY-4716,12815544,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,paulcager,paulcager,08/Mar/11 05:34,14/Aug/13 03:57,14/Jul/23 06:00,08/Mar/11 07:01,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,groovy-jmx,,,,0,,,,,,"Page http://groovy.codehaus.org/Groovy+JmxBuilder has some sample code for the JMX builder. In a couple of places ""writable"" is misspelt as ""writeable"" so when you copy-and-paste the code it doesn't work (attributes are read-only).",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 08 07:01:13 UTC 2011,,,,,,,,,,"0|i2c7rb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Mar/11 06:09;guillaume;Are the two writeable/writable occurences the sole issues you've come across?;;;","08/Mar/11 06:19;paulcager;Yes, just those two.;;;","08/Mar/11 07:01;guillaume;Ok, I think I've fixed those two errors.

Btw, the page is actually a wiki, so feel free to fix the documentation as you see further mistakes!
We also love documentation contributions!

Thanks for spotting these.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
StreamingMarkupBuilder can produce invalid xml,GROOVY-4715,12817781,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,ttrung.vo,ttrung.vo,07/Mar/11 16:58,13/Apr/11 14:33,14/Jul/23 06:00,12/Mar/11 00:43,1.7.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.10,1.8-rc-2,,XML Processing,,,,0,,,,,,"* From #GROOVY-4115, StreamingMarkupBuilder provides option for using double quotes around attributes. But if we use this option, it can output invalid xml:
** For example:
{code:java}
def builder = new StreamingMarkupBuilder(useDoubleQuotes: true);
builder.bind (
  {
    div(onmouseover:'foo(""some text"")')
  }
}
{code}
** Produce the following output, which is invalid.
{code:xml}
    <div onmouseout=""foo(""some text"")""></div>
{code}
** Another example: 
{code:java}
def builder = new StreamingMarkupBuilder(useDoubleQuotes: true);
builder.bind (
   {
     div(onmouseover:""foo('some text')"")
   }
}
{code}
** Produce the following output
{code:xml}
    <div onmouseout=""foo(&apos;some text&apos;)""></div>
{code}
** However, it should produce
{code:xml}
    <div onmouseout=""foo('some text')""></div>
{code}

* As far as we know, MarkupBuilder will escape the apostrophe if the value is for an attribute, as opposed to element content, and if the builder is configured to surround attribute values with single quotes.
** So if we use the MarkupBuilder to build the above html block: 
{code:java}
def builder = new MarkupBuilder();
builder.setDoubleQuotes(true)
...
{code}
** It will produce the similar xml as the above, except the apostrophe entity
{code:xml}
...
<div onmouseout= ""foo('some text')""></div>
...
{code}

* The single-quote should be displayed instead of the entity ( &amp;apos; ) in both of the builders when attributes are surrounded by double quotes. It appears that StreamingMarkupBuilder is not communicating *useDoubleQuotes* to StreamingMarkupWriter.  One solution we can think of is passing in *useDoubleQuotes* to the StreamingMarkupWriter from the StreamingMarkupBuilder in the constructor and changing StreamingMarkupWriter to use similar logic to MarkupBuilder when checking attribute value for quotes to escape.{code:java|title=StreamingMarkupBuilder.java}
public bind(closure) {
...
out = new StreamingMarkupWriter(out, enc, useDoubleQuotes)
...
}
{code}
{code:java|title=StreamingMarkupWriter}
public void write(final c) throws IOException {
   ...
   else if(c == '\'' && this.writingAttribute && !useDoubleQuotes) {
       this.writer.write(""&apos;"");
   }
   else if(c == '""' && this.writingAttribute && useDoubleQuotes) {
       this.writer.write(""&quot;"");
   }
   ...
}
{code}

Thanks
",Windows and Linux,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 11 16:00:55 UTC 2011,,,,,,,,,,"0|i2cjdz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Mar/11 07:39;paulk;Thanks for the suggestion, fixed.;;;","11/Mar/11 14:26;ttrung.vo;Hi Paul,

Adam (my colleague) and me upgraded groovy to version 1.7.9 and the fix is not included in 1.7.9 version. However, we do see the fix is included in version 1.8.0-rc-2. So it seems that you can deploy the version 1.7.9 again or you need to include this fix in 1.7.10. You also need to make sure that the release notes of v1.7.10 include the this bug (#GROOVY-4715), since this bug (#GROOVY-4715) is already included in the release-notes of v1.7.9

Thanks

PS: Thanks for using our suggestion, Adam and especially I are so proud of this. Today is the super awesome day :) :) :);;;","11/Mar/11 16:00;paulk;We always appreciate feedback and especially ones with well-considered suggestions. Thanks for spotting the problem with 1.7.9. The fix was targeted for that release but there was a glitch during the release and it didn't make it. We will probably do a 1.7.10 shortly to fix up the glitch and we'll update the version numbering in the issue to reflect the change. Thanks again!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Standalone stub generation task fails resolving classes,GROOVY-4711,12815531,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,gromopetr,gromopetr,06/Mar/11 04:55,05/Apr/15 14:44,14/Jul/23 06:00,26/Jul/11 09:08,1.7.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.2,1.9-beta-3,Stub generator / Joint compiler,,,,0,,,,,,"If you create a Java class (Foo) and a Groovy class (Bar extends Foo), and then run the stub generation Ant task (GenerateStubsTask), it'll fail because it now does all the phases up to semantic analysis which attempts to resolve all class references. AFAIU the stub generation is supposed to be run before Javac. So it should be prepared that some Java classes the Groovy code depends on aren't compiled yet.",,kurtharriger,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"07/Mar/11 07:34;blackdrag;generateStubs.patch;https://issues.apache.org/jira/secure/attachment/12722830/generateStubs.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Tue Jul 26 09:08:44 UTC 2011,,,,,,,,,,"0|i2cotr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Mar/11 07:57;blackdrag;but joint compilation using groovyc works, or not?;;;","06/Mar/11 08:53;roshandawrani;Since no other information is provided, if I just try:

Foo.java
{code}
class Foo {}
{code}
and Bar.groovy:
{code}
class Bar extends Foo {}
{code}
and compile as
{noformat}
groovyc *
{noformat}

then the joint compilation goes through just fine (using groovy 1.7.5).;;;","06/Mar/11 09:01;roshandawrani;With groovyc 1.7.8, it works too.;;;","06/Mar/11 11:56;gromopetr;The problem is that we need stub generation as a separate step, our (IntelliJ IDEA) build is a quite complex process, it consists of many stages and stub generation and javac/groovyc happen to be on different stages.

The joint compilation works indeed, because the stub generation there happens twice: once during conversion and the other time during semantic analysis. The stub generated in conversion gets immediately compiled by Javac (see JavaAwareCompilationUnit), and so it is available for resolve during the semantic analysis. In a separate standalone stub generator (GenerateStubsTask, JavaStubCompilationUnit) semantic analysis also happens, but nobody has generated and compiled the stubs together with the Java sources before that, so the resolve fails.

;;;","07/Mar/11 05:44;guillaume;Peter, perhaps you could explain a bit more concretely what you would like to see? What would help IntelliJ IDEA? That everything runs in CONVERSION phase, or something like that?;;;","07/Mar/11 06:33;gromopetr;It would help if the resolve process didn't fail the compilation. This can be achieved by making the standalone stub generation not run it (i.e. to work only up to the conversion phase) or just ignore the unresolved references during the semantic analysis. The first alternative means even wider gap between joint compilation and just stub generation, the second one looks a bit like a hack. But both would work for us.;;;","07/Mar/11 07:33;blackdrag;I attached a patch. It aligns the stub task with our joint compilation more in such that it moves the stub generation to the conversion phase and also does the VariableScopeVisitor and JavaAwareResolveVisitor runs before. Since this is a bigger change to the stub generator task we will include that only after 1.8.0

But before this can be really included we absolutely need some tests I think;;;","07/Mar/11 07:36;blackdrag;Peter if you would test that patch it would surely help us;;;","09/Mar/11 15:05;gromopetr;Jochen,

Unfortunately I don't have much time now to build Groovy and try it, but from the first shallow glance the patch looks good. And I'd include this into 1.7.x for the following reason: JavaStubCompilationUnit is used only from the commented out generatestubs task, and currently this will definitely fail (when doing clean build) when there's at least one Groovy file referencing at least one Java class. As no one but me came with this problem, I assume we're the only clients of this task. So nothing should break except possibly for us, which in turn shouldn't happen. And I agree that having a test would be great.;;;","26/Jul/11 05:36;gromopetr;Jochen, I've built Groovy with this patch and it works. You've promised me you'll apply it :);;;","26/Jul/11 09:08;blackdrag;Peter, sorry for not appllying the patch earlier, now it is done.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Creating anonymous class instance fails with some legal code structures,GROOVY-4710,12815532,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,russel,russel,05/Mar/11 08:47,24/Dec/11 03:08,14/Jul/23 06:00,05/Dec/11 09:34,1.8-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.3,,,,,,,1,,,,,,"Attached are three small code examples.  One shows that Groovy captures variables fine when using anonymous class creation using new when the expression is part of an assignment.  The second shows that using an as expression also enable proper capture of variables when an expression is the return value used in a collect expression.  The third shows the failure of Groovy to ""do the right thing"" in the case of using a new expression in a collect expression.  The error returned is:

 Caught: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: fails$1(fails, java.lang.Integer)
	at fails$_run_closure1.doCall(fails.groovy:15)
	at fails.run(fails.groovy:14)

Current hypothesis is that the fact that the function is (necessarily) called call may be a factor.","Ubuntu 10.10 Maverick Meerkat, Groovy trunk 2011-03-05T08:00+00:00",russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"05/Mar/11 08:47;russel;fails.groovy;https://issues.apache.org/jira/secure/attachment/12722829/fails.groovy","05/Mar/11 08:47;russel;works_array.groovy;https://issues.apache.org/jira/secure/attachment/12722737/works_array.groovy","05/Mar/11 08:47;russel;works_as.groovy;https://issues.apache.org/jira/secure/attachment/12722828/works_as.groovy",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 05 09:34:12 UTC 2011,,,,,,,,,,"0|i2cbvb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Dec/11 09:34;melix;This was fixed in 1.8.3 (GROOVY-5000);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Interrupt AST transformations should not be applied on abstract methods,GROOVY-4709,12811929,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,melix,melix,04/Mar/11 14:43,05/Apr/15 14:43,14/Jul/23 06:00,07/Mar/11 10:26,1.8-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-2,1.9-beta-1,,,,,,0,,,,,,"When a class is annotated with @ThreadInterrupt, @ConditionalInterrupt or @TimedInterrupt, a NullPointerException is thrown when visiting an abstract method.

{code}
java.lang.NullPointerException
    at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)
    at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
    at org.codehaus.groovy.transform.ThreadInterruptibleASTTransformation.super$3$visitMethod(ThreadInterruptibleASTTransformation.groovy)
    at sun.reflect.GeneratedMethodAccessor184.invoke(Unknown Source)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1054)
    at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:128)
    at org.codehaus.groovy.transform.ThreadInterruptibleASTTransformation.visitMethod(ThreadInterruptibleASTTransformation.groovy:73)
    at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
    at org.codehaus.groovy.transform.AbstractInterruptibleASTTransformation.visit(AbstractInterruptibleASTTransformation.java:89)
    at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:129)
    at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:172)
    at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:948)
    at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:533)
    at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:511)
    at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:488)
    at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:283)
    at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:264)
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"04/Mar/11 14:43;melix;@Interrupt_AST_transforms_should_handle_abstract_methods.patch;https://issues.apache.org/jira/secure/attachment/12722827/%40Interrupt_AST_transforms_should_handle_abstract_methods.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,2011-03-04 14:43:16.0,,,,,,,,,,"0|i2bntb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Scripts' class nodes didn't have correct source positions,GROOVY-4707,12815516,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,guillaume,guillaume,03/Mar/11 08:48,12/Mar/11 00:47,14/Jul/23 06:00,03/Mar/11 09:07,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.9,1.8-rc-2,1.9-beta-1,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2011-03-03 08:48:31.0,,,,,,,,,,"0|i2bzt3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error with null parameter in prepared statements with old DB2 driver,GROOVY-4704,12817713,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,kaklakariada,kaklakariada,03/Mar/11 02:41,12/Mar/11 00:47,14/Jul/23 06:00,06/Mar/11 17:19,1.7.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.9,1.8-rc-2,,SQL processing,,,,0,,,,,,"The DB2 JDBC driver throws an exception when setting null as parameter for a prepared statement.

Stack trace (line numbers are wrong):
{code}
Caused by: com.ibm.db2.jcc.c.SqlException: Invalid data conversion: Parameter object type is invalid for requested conversion.
        at com.ibm.db2.jcc.c.uf.setObject(uf.java:1215)
        at groovy.sql.Sql.setObject(Sql.java:2124)
        at groovy.sql.Sql.setParameters(Sql.java:2090)
        at groovy.sql.Sql.getPreparedStatement(Sql.java:2318)
        at groovy.sql.Sql.getPreparedStatement(Sql.java:2324)
        at groovy.sql.Sql.execute(Sql.java:1113)
{code}
Please use PreparedStatement.setNull() instead of setObject() in the last line of Method groovy.sql.Sql.setObject() when value is null.

Also see JavaDoc comment for setObject() about null values.

http://download.oracle.com/javase/6/docs/api/java/sql/PreparedStatement.html#setNull(int, int)
http://download.oracle.com/javase/6/docs/api/java/sql/PreparedStatement.html#setObject(int,%20java.lang.Object)

Thank you!",IBM DB2 9.1 with old DB2 JDBC driver db2jcc.jar,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 09 02:11:10 UTC 2011,,,,,,,,,,"0|i2bron:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Mar/11 06:15;paulk;Does using the sanctioned {{InParameter}} and {{OutParameter}} wrappers, e.g. use {{Sql.VARCHAR(value)}} instead of {{value}}, not work for you?;;;","04/Mar/11 06:25;kaklakariada;I didn't think of this, used another workaround. I will try using InParameter wrapper. Nevertheless it would be great to see it fixed, as other people will have the same problem, too.;;;","04/Mar/11 14:09;paulk;Well, the underlying API doesn't have a setNull without a type parameter. Do you have a suggestion for setting the type? The {{InParameter}} wrapper is our current strategy for dealing with that. The alternatives of guessing based on Java types or having an expensive query on database metadata both have serious drawbacks. Did you have something else in mind?;;;","05/Mar/11 00:46;kaklakariada;Good argument, I didn't think about this.
The most secure and user friendly solution would be to catch and re-throw the SqlException thrown by setObject. When the argument was null, you could wrap the SqlException and add a meaningful exception message like ""Maybe the JDBC driver does not support null arguments for setObject. Try using InParameter."".
This way, the user at least knows how to work around the JDBC driver restrictions without digging into the Code.;;;","06/Mar/11 06:23;paulk;Good sugestion;;;","06/Mar/11 17:19;paulk;Change to error message added;;;","08/Mar/11 04:30;paulk;Christoph, if there is any chance you could test a snapshot version of the jar in your project that would be great to confirm the improvement works for you prior to our next release which is happening shortly. Thanks.;;;","09/Mar/11 01:17;kaklakariada;Your changes work as expected: Executing the following code

{code}
db.execute(""insert into tn24_werk values (?, ?)"", [null, null])
{code}

results in this warning (when running it using the groovy ant task):

{noformat}
[groovy] 09.03.2011 08:16:20 groovy.sql.Sql execute
[groovy] WARNUNG: Failed to execute: insert into tn24_werk values (?, ?) because: Your JDBC driver may not support null arguments for setObject. Consider using Groovy's InParameter feature. (CAUSE: Invalid data conversion: Parameter object type is invalid for requested conversion.)
{noformat}

Tested with http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all/1.8.0-rc-2-SNAPSHOT/groovy-all-1.8.0-rc-2-SNAPSHOT.jar and DB2 JDBC driver version 2.10.52

Thank you for the quick fix!;;;","09/Mar/11 02:11;paulk;Excellent, thank you for the suggestion and the quick feedback!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MissingMethodException#printStackTrace() throws exception if an arguments toString() method fails,GROOVY-4701,12817703,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,sieber,sieber,02/Mar/11 06:50,10/Jul/13 04:42,14/Jul/23 06:00,28/Jan/13 19:36,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,,,,0,,,,,,"I just saw a somewhat irritating behaviour in MissingMethodException. It throws an exception if the toString() of one of the arguments of the method call fails. 

Code to reproduce the problem:

{code}
class BrokenToString{
  @Override
  public String toString() {
    throw new RuntimeException(""toString broken"")
  }
}

def exception = new MissingMethodException(""methodName"", getClass(), new BrokenToString())

exception.printStackTrace()//Throws Exception
{code}

I've provided two variants of a patch to solve the problem , but to be honest, I'm not completely happy with any of these two variants:
1) The patch for InvokerHelper.java changes a class that seems to be broadly used and I'm not sure if that change is acceptable for all clients
2) The patch for MissingMethod Exception solves the problem by returning an Error String for the whole list of arguments instead of the one argument that caused the problem. But of course this behaviour is better than throwing an Exception:)
",,blackdrag,paulk,pschumacher,rattigan,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"02/Mar/11 06:50;sieber;InvokerHelper.java.patch;https://issues.apache.org/jira/secure/attachment/12722731/InvokerHelper.java.patch","02/Mar/11 06:50;sieber;MissingMethodException.java.patch;https://issues.apache.org/jira/secure/attachment/12722735/MissingMethodException.java.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 28 19:36:50 UTC 2013,,,,,,,,,,"0|i2c4mf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jan/13 14:14;pschumacher;I guess there was no interest in applying this patch, therefore this issues should be closed.;;;","23/Jan/13 01:28;blackdrag;Pascal, actually I think the MissingMethodException variant is desirable, but I would like to have it printing the exception text only for the parts that throw it. Are you interested in implementing that?;;;","23/Jan/13 05:50;paulk;I was actually having a look at this today briefly. Perhaps it might be enough to have a try ... catch around the last line of InvokerHelper#format(Object, boolean, int) and if the toString() fails, instead output something similar to what Object#toString() would produce - could already in the start of the DGM#dump method. But then I read the GROOVY-2599 todo comment and got distracted trying (foolishly perhaps) to solve both and didn't have time to finish anything.;;;","23/Jan/13 13:20;blackdrag;if you change InvokerHelper#format, won't it influence other parts too? And do we want this behavior there?;;;","23/Jan/13 15:39;paulk;It would definitely influence other parts. In my little spike I added a boolean ""safe"" to various InvokerHelper methods: toString, toArrayString, toMapString, format, etc. and defaulted to false (current behavior). Then I wondered whether the default should really be true - it probably should for something as fundamental as toString()?

P.S. Wondering whether in Groovy 3, all these formatting methods belong in a FormatHelper (or something) rather than in InvokerHelper.;;;","24/Jan/13 02:51;blackdrag;I think it is a breaking change to some extend. Swallowing exceptions is rarely a good idea. In case of printing the text of an exception itself, well, that is ok, but for toString in general I am no fan;;;","24/Jan/13 04:11;paulk;True, safer to leave the default as is. How does this look:
https://github.com/groovy/groovy-core/pull/126
Tests to follow if it looks reasonable.;;;","24/Jan/13 04:55;blackdrag;+1;;;","28/Jan/13 19:36;paulk;now for MME, a safe representation of the exception will be displayed, e.g. exceptions are ignored for toString() and hashCode().;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Field variable can't be referred from closure,GROOVY-4700,12815513,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,uehaj,uehaj,28/Feb/11 08:34,13/Apr/11 14:33,14/Jul/23 06:00,30/Mar/11 17:19,1.8-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-4,,,,,,,0,,,,,,"attached code 
{code}
import groovy.transform.Field

@Field def xxx = 3

foo = {
  println xxx
}

foo()

{code}

generate following error:
{quote}
Caught: BUG! exception in phase 'class generation' in source unit '/Users/uehaj/tmp/bug.groovy' tried to get a variable with the name xxx as stack variable, but a variable with this name was not created
{quote}


",Mac OS X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Mar/11 11:06;melix;Fixed_GROOVY-4700.patch;https://issues.apache.org/jira/secure/attachment/12722835/Fixed_GROOVY-4700.patch","28/Feb/11 08:34;uehaj;bug.groovy;https://issues.apache.org/jira/secure/attachment/12722781/bug.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 30 17:19:27 UTC 2011,,,,,,,,,,"0|i2ckvr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Mar/11 11:06;melix;The following patch (with tests) fixes this issue;;;","29/Mar/11 23:24;paulk;Cédric's patch looks good to me. Applied in trunk. I also think it is a serious enough bug to warrant merging into 1.8 RC4 but will await Guillaume and Jochen's review/comments.;;;","30/Mar/11 02:11;melix;Thanks Paul. I looked at your commit, and you accidently changed a test case : in _testFieldShouldBeAccessibleFromClosureWithoutAssignment_, you added an assignment to {code}foo  = { ... }{code}, adding a ""def"" which changes the _BinaryExpression_ into a _DeclarationExpression_. I think it's important to test both, because I had a fix that only dealt with the _DeclarationExpression_ first and it didn't work with the _BinaryExpression_, that is to say the script which is attached as a proof for this bug :)
;;;","30/Mar/11 02:38;paulk;well the change was deliberate but the consequence was not so I changed it back :-);;;","30/Mar/11 11:50;guillaume;I think that would be good in 1.8 too.
We'll have to release an RC-4.;;;","30/Mar/11 17:19;paulk;merged in preparation for RC4. Thanks to everyone involved.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Observable List misbehaves when using retainAll with closure,GROOVY-4699,12815530,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,sharrer,sharrer,28/Feb/11 08:07,07/Sep/11 14:13,14/Jul/23 06:00,22/Jul/11 22:51,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.2,1.9-beta-3,groovy-jdk,,,,0,,,,,,"List liste = new ObservableList<String>()


liste.add ""test""
liste.add ""test2""

List andereListe = new LinkedList<String>()


liste.retainAll { elem -> andereListe.contains(elem) }

assert liste.isEmpty()
____________________________________________

This results in:
____________________________________________
Exception in thread ""main"" Assertion failed: 

assert liste.isEmpty()
       |     |
       |     false
       [test]
____________________________________________

If the ObservableList is changed to LinkedList, the testcase works. ","Eclipse Plugin, Windows 7",paulk,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 22 22:51:11 UTC 2011,,,,,,,,,,"0|i2cotz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"28/Feb/11 08:10;sharrer;workaround found: liste.retainAll(liste.findAll {andereListe.contains(it)});;;","22/Jul/11 07:36;paulk;Wondering whether this patch would fix the problem:
{noformat}
Index: src/main/groovy/util/ObservableList.java
===================================================================
--- src/main/groovy/util/ObservableList.java	(revision 21606)
+++ src/main/groovy/util/ObservableList.java	(revision )
@@ -400,14 +400,19 @@
         }
 
         public void remove() {
-            ObservableList.this.remove(cursor--);
+            int oldSize = ObservableList.this.size();
+            Object element = ObservableList.this.get(cursor);
+            iterDelegate.remove();
+            fireElementRemovedEvent(cursor, element);
+            fireSizeChangedEvent(oldSize, size());
+            cursor--;
         }
     }
{noformat};;;","22/Jul/11 08:48;tim_yates;Added a test for it (and patched with your code)

{code:none}
Index: src/test/groovy/util/ObservableListTest.groovy
===================================================================
--- src/test/groovy/util/ObservableListTest.groovy	(revision 22647)
+++ src/test/groovy/util/ObservableListTest.groovy	(working copy)
@@ -264,6 +264,18 @@
       list << value2
       assertNull( contentListener.event )
    }
+
+   void testRetainBugGroovy4699() {
+      ObservableList list = []
+      list.add ""test""
+      list.add ""test2""
+
+      LinkedList otherList = []
+      
+      list.retainAll { elem -> otherList.contains( elem ) }
+
+      assert list.isEmpty()
+   }
 }
 
 class SampleListPropertyChangeListener implements PropertyChangeListener {
{code}

As long as the patch for GROOVY-4937 is applied prior to your patch, it seems to work fine :-);;;","22/Jul/11 22:51;paulk;Patch applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Possible memory leak in Tomcat,GROOVY-4698,12815499,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,fxg,fxg,25/Feb/11 15:39,22/Feb/16 20:48,14/Jul/23 06:00,24/Jan/16 15:14,1.7.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.6,,,groovy-runtime,,,,1,,,,,,"Using Groovy 1.7.8 Groovlets on Tomcat 6.0.28 yields the following in the log files:

{code}
The web application [...] created a ThreadLocal with key of type [null] (value [groovy.util.GroovyScriptEngine$2@68aed52c]) and a value of type [org.codehaus.groovy.tools.gse.StringSetMap] (value [{}]) but failed to remove it when the web application was stopped. This is very likely to create a memory leak.
{code}","Groovy 1.7.8, Tomcat 6.0.28",fxg,githubbot,guyr,jwagenleitner,lautou,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4177,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jan 24 14:52:53 UTC 2016,,,,,,,,,,"0|i2c6fr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Dec/12 03:24;guyr;I am getting a similar error on 2.0.6 on Tomcat 7.0.25, with just a basic hello.groovy groovlet:

SEVERE: The web application [/groovy] created a ThreadLocal with key of type [org.codehaus.groovy.reflection.ClassInfo.ThreadLocalMapHandler] (value [org.codehaus.groovy.reflection.ClassInfo$ThreadLocalMapHandler@35a3ae73]) and a value of type [java.lang.ref.SoftReference] (value [java.lang.ref.SoftReference@d121b88]) but failed to remove it when the web application was stopped. Threads are going to be renewed over time to try and avoid a probable memory leak.

Fortunately, with this version of Groovy, I can continue.  With 1.8.7, Tomcat would not or could not remove the exploded WAR directory.  So the only way to deploy a new version of the groovlet WAR file was to stop Tomcat and restart it.

;;;","20/Jan/16 02:29;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/245

    GROOVY-4698 - Possible memory leak in Tomcat (GroovyScriptEngine ThreadLocal)

    Recommend reviewing each commit separately.  The first commit I think is fairly safe and addresses the issue reported.  The others I'm a little less sure about.
    
    863247f - main fix is ensuring that `localTh.remove()` (changed from `localTh.set(null)`) is always called even if an exception occurs.  Did some refactoring by pulling out the code used to update dependencies and the script cache.  Even though some changes have been made to the ThreadLocal's in this class since that JIRA, the problem remains because `set(null)` will not be called if `super.parseClass` throws.  I think this is a fairly safe change.
    
    dbfa026- If we always clean up the ThreadLocal by calling remove, I think things can be simplified by removing the `WeakReference` holder and synchronized `getLocalData` method.
    
    c32722a- Since `super.parseClass` is synchronized and the other code in that method just updates thread confined (ThreadLocal) data and ConcurrentHashMap scriptCache, it seemed like that could be done outside of synchronization.  I don't know if there might be a potential problem with ordering of the `scriptCache.put` calls.  However, if it is supposed to be synchronized, then I'm not sure a ThreadLocal is needed since that would mean all access to the ThreadLocal is synchronized.  In that case why not just have a `private LocalData localData;` field and set it with a `new LocalData()` each time `parseClass` is called?
    
    **UNIT TEST NOTE**: I'm not sure how good the added test methods are.  They were helpful in showing the issue before the changes (commit 863247f).  However, they might be brittle since they rely on poking into package-private/private members.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-4698

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/245.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #245
    
----
commit 863247f25b4092d99c8e0fcc85d573f11647cd90
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-01-20T01:55:25Z

    GROOVY-4698 - Possible memory leak in Tomcat (GroovyScriptEngine ThreadLocal)
    
    GSE uses a ThreadLocal to temporarily cache data so it can be used in the compilation phase.  Once the script is compiled the cache data is no longer necessary.  ThreadLocal.set(null) was used which leaves the ThreadLocal as a key in the Thread's ThreadLocalMap entries.  In addition, if any exceptions were thrown before that call it would leave a ThreadLocal entry with a LocalData value in the thread's ThreadLocalMap tables.  This change tries to ensure that the ThreadLocal is removed when no longer needed.

commit dbfa0266e256910a27dfa6acbcc0fabd2fcc8270
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-01-20T01:56:00Z

    Rework ThreadLocal caching

commit c32722a990d743dfc30151f719599df2a8b729e1
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-01-20T01:56:22Z

    Remove synchronized block
    
    The call to super.parseClass(GroovyCodeSource,boolean) is synchronized.  Updating local dependency cache and script cache is performed on thread confined (ThreadLocal) and scriptCache ConcurrentHashMap.

----
;;;","24/Jan/16 14:52;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/245
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
anonymous classes InnerClassNode has -1 for line numbers,GROOVY-4695,12815538,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,hamletdrc,hamletdrc,hamletdrc,25/Feb/11 02:33,12/Mar/11 00:48,14/Jul/23 06:00,26/Feb/11 01:37,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.9,1.8-rc-2,1.9-beta-1,Compiler,,,,0,,,,,,"anonymous classes InnerClassNode has -1 for line numbers

new Object() {}

produces an InnerCLassNode. The lineNUmbers are -1

This affects CodeNarc. I'd love to see this rolled back as far as possible. To 1.8 surely. ",,hamletdrc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"25/Feb/11 15:36;melix;Inner_class_has_wrong_line_number_(GROOVY-4695).patch;https://issues.apache.org/jira/secure/attachment/12722780/Inner_class_has_wrong_line_number_%28GROOVY-4695%29.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Feb 26 01:37:31 UTC 2011,,,,,,,,,,"0|i2bs0v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Feb/11 15:36;melix;Patch fixes this issue.;;;","26/Feb/11 01:14;hamletdrc;thanks for the Patch Cédric. This type of thing should be easily unit tested... I'll write one and check in;;;","26/Feb/11 01:37;hamletdrc;applied cédric's patch and wrote a unit test
applied to 1.9.x, 1.8.x, and 1.7.x (just in case there is one more build);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Grails 1.3.7 breaks bean-fields plugin,GROOVY-4691,12815505,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,goeh,goeh,22/Feb/11 09:28,29/Mar/11 10:49,14/Jul/23 06:00,29/Mar/11 10:48,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.10,1.8-rc-3,1.9-beta-1,,,,,3,,,,,,"After upgrading from grails 1.3.6 to 1.3.7 bean-fields plugin render garbage after every <bean:field> tag:
{noformat}
org.codehaus.groovy.grails.web.pages.GroovyPageOutputStack$GroovyPageProxyWriter@602d9d
{noformat}

See http://grails.1312388.n4.nabble.com/Grails-1-3-7-and-bean-fields-td3311784.html

The sample app attached show the problem in view book/index",,antony.stubbs@gmail.com,pledbrook,ricardojmendez,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"22/Feb/11 10:01;goeh;bftest.zip;https://issues.apache.org/jira/secure/attachment/12722824/bftest.zip","22/Feb/11 09:30;goeh;grails-1.3.7-bean-fields.png;https://issues.apache.org/jira/secure/attachment/12722732/grails-1.3.7-bean-fields.png",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 29 10:49:32 UTC 2011,,,,,,,,,,"0|i2cipz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Feb/11 09:30;goeh;Attached screenshot that shows the extra output after each field.;;;","22/Feb/11 10:01;goeh;Since the standard 'grails bug-report' command produces an incomplete zip (GRAILS-7300), I attached a new zip that includes all neccesary files.;;;","22/Feb/11 14:03;guillaume;Thank you Goran.
I've managed to reproduce the issue by creating a new app and copying the necessary files.
With Jochen, we've narrowed down the changes to Groovy that triggered this problem, by ""bisecting"" till finding the right commit that was causing the issue.
Interestingly, the commit which was fixing a problem Luke had with his remote closures project, but which covered some other issues that you've been facing.
We found a fix for that already, we'll release another Groovy 1.7 release next week with the fix.;;;","23/Feb/11 08:16;marc@anyware.co.uk;Great work guys, thanks for your efforts on this!;;;","25/Feb/11 11:07;marc@anyware.co.uk;Guillaume/Jochen can we get some info on the actual problem here to evaluate what other code might be affected?;;;","25/Feb/11 11:26;guillaume;You can have a look at the commits on the groovy-scm mailing-list, but it won't help you much, and is difficult to know exactly what other impacts it could have.;;;","29/Mar/11 10:43;goeh;Since no new version of Grails is released we still cannot use the bean-fields plugin.
What do we tell Grails developers on 1.3.7 that want to use bean-fields?
I created an issue for bean-fields here http://jira.grails.org/browse/GPBEANFIELDS-37;;;","29/Mar/11 10:49;guillaume;Users will probably have to wait for a Grails release including Groovy 1.7.10 which fixed the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Varargs are not displayed by GroovyDoc,GROOVY-4686,12815489,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,genie,genie,18/Feb/11 15:39,21/Jul/11 19:06,14/Jul/23 06:00,19/Jul/11 08:29,1.8-beta-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,GroovyDoc,,,,0,,,,,,"This file http://goo.gl/9K3p0 uses varargs arguments.
But its Groovydoc generated http://goo.gl/gKYgH doesn't display them.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 19 09:21:09 UTC 2011,,,,,,,,,,"0|i2c4q7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jul/11 08:29;paulk;Should be fixed - let me know if you have any issues;;;","19/Jul/11 09:21;genie;Thanks, Paul! Will check it.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
high number of generated classes,GROOVY-4678,12815348,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,blackdrag,blackdrag,15/Feb/11 14:12,15/Feb/11 14:13,14/Jul/23 06:00,15/Feb/11 14:13,1.7.7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.8,,,,,,,0,,,,,,"Due to a change of the call site meta method logic Groovy now generates an endless number of call site meta method classes, one for each time. The reason for this is one the changed conctructor and second a bytecode error.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 15 14:13:09 UTC 2011,,,,,,,,,,"0|i2bruv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Feb/11 14:13;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"java.lang.ClassFormatError: Illegal class name ""groovy/jmx/builder/package-info"" in class file groovy/jmx/builder/package-info",GROOVY-4673,12815486,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,beamerblvd,beamerblvd,10/Feb/11 20:35,21/Jul/11 19:06,14/Jul/23 06:00,20/Jul/11 03:19,1.7.7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,groovy-jdk,,,,1,,,,,,"The groovy-all-1.7.7.jar file in the embeddable directory of the binary ZIP file contains an invalid package-info file groovy.jmx.builder.package-info.class. I believe this is due to the src/main/groovy/jmx/builder/package-info.groovy file being incorrectly compiled. In Tomcat 7.0.0 and JBoss AS 6.0.0, this results in an exception like the one below and a deployment failure for any applications that bundle this JAR file.

Tomcat has since released a patch that issues this is a warning and allows the deployment to continue, but JBoss AS has not. Since the problem is ultimately that a legitimately invalid package-info class exists in the library, it seems most logical that the problem be resolved with Groovy and not JBoss.

I was able to resolve my issue for now by manually editing the distributable JAR file and removing the package-info.class file from it, but this is not a good permanent solution.

Here is the exception:

{code:title=Exception}18:02:52,225 WARN  [org.jboss.detailed.classloader.ClassLoaderManager] Unexpected error during load of:groovy.jmx.builder.package-info: java.lang.ClassFormatError: Illegal class name ""groovy/jmx/builder/package-info"" in class file groovy/jmx/builder/package-info
	at java.lang.ClassLoader.defineClass1(Native Method) [:1.6.0_23]
	at java.lang.ClassLoader.defineClassCond(Unknown Source) [:1.6.0_23]
	at java.lang.ClassLoader.defineClass(Unknown Source) [:1.6.0_23]
	at org.jboss.classloader.spi.base.BaseClassLoader.access$200(BaseClassLoader.java:52) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.base.BaseClassLoader$2.run(BaseClassLoader.java:650) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.base.BaseClassLoader$2.run(BaseClassLoader.java:609) [jboss-classloader.jar:2.2.0.GA]
	at java.security.AccessController.doPrivileged(Native Method) [:1.6.0_23]
	at org.jboss.classloader.spi.base.BaseClassLoader.loadClassLocally(BaseClassLoader.java:608) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.base.BaseClassLoader.loadClassLocally(BaseClassLoader.java:585) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.base.BaseDelegateLoader.loadClass(BaseDelegateLoader.java:156) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.filter.FilteredDelegateLoader.doLoadClass(FilteredDelegateLoader.java:141) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.filter.FilteredDelegateLoader.loadClass(FilteredDelegateLoader.java:132) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.base.ClassLoadingTask$ThreadTask.run(ClassLoadingTask.java:461) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.base.ClassLoaderManager.nextTask(ClassLoaderManager.java:262) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.base.ClassLoaderManager.process(ClassLoaderManager.java:161) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.base.BaseClassLoaderDomain.loadClass(BaseClassLoaderDomain.java:260) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.base.BaseClassLoaderDomain.loadClass(BaseClassLoaderDomain.java:1152) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.base.BaseClassLoader.loadClassFromDomain(BaseClassLoader.java:886) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.base.BaseClassLoader.doLoadClass(BaseClassLoader.java:505) [jboss-classloader.jar:2.2.0.GA]
	at org.jboss.classloader.spi.base.BaseClassLoader.loadClass(BaseClassLoader.java:450) [jboss-classloader.jar:2.2.0.GA]
	at java.lang.ClassLoader.loadClass(Unknown Source) [:1.6.0_23]
	at java.lang.Class.forName0(Native Method) [:1.6.0_23]
	at java.lang.Class.forName(Unknown Source) [:1.6.0_23]
	at org.jboss.reflect.plugins.introspection.IntrospectionTypeInfoFactoryImpl.resolveComplexTypeInfo(IntrospectionTypeInfoFactoryImpl.java:458) [jboss-reflect.jar:2.2.0.GA]
	at org.jboss.reflect.plugins.introspection.IntrospectionTypeInfoFactoryImpl.getTypeInfo(IntrospectionTypeInfoFactoryImpl.java:414) [jboss-reflect.jar:2.2.0.GA]
	at org.jboss.reflect.plugins.introspection.IntrospectionTypeInfoFactory.getTypeInfo(IntrospectionTypeInfoFactory.java:54) [jboss-reflect.jar:2.2.0.GA]
	at org.jboss.config.plugins.AbstractConfiguration.getTypeInfo(AbstractConfiguration.java:121) [jboss-reflect.jar:2.2.0.GA]
	at org.jboss.kernel.plugins.config.AbstractKernelConfig.getTypeInfo(AbstractKernelConfig.java:95) [jboss-kernel.jar:2.2.0.GA]
	at org.jboss.kernel.plugins.config.AbstractKernelConfigurator.getTypeInfo(AbstractKernelConfigurator.java:102) [jboss-kernel.jar:2.2.0.GA]
	at org.jboss.scanning.plugins.visitor.ConfiguratorReflectProvider.getTypeInfo(ConfiguratorReflectProvider.java:47) [:1.0.0.GA]
	at org.jboss.scanning.plugins.visitor.CachingReflectProvider.getTypeInfo(CachingReflectProvider.java:52) [:1.0.0.GA]
	at org.jboss.scanning.plugins.visitor.ReflectResourceVisitor.getTypeInfo(ReflectResourceVisitor.java:60) [:1.0.0.GA]
	at org.jboss.scanning.plugins.visitor.ReflectResourceVisitor.getClassInfo(ReflectResourceVisitor.java:72) [:1.0.0.GA]
	at org.jboss.scanning.plugins.visitor.ReflectResourceVisitor.doVisit(ReflectResourceVisitor.java:107) [:1.0.0.GA]
	at org.jboss.scanning.plugins.visitor.ReflectResourceVisitor.visit(ReflectResourceVisitor.java:86) [:1.0.0.GA]
	at org.jboss.scanning.hierarchy.plugins.HierarchyIndexScanningPlugin.visit(HierarchyIndexScanningPlugin.java:91) [:1.0.0.GA]
	at org.jboss.scanning.spi.helpers.ScanningPluginWrapper.visit(ScanningPluginWrapper.java:112) [:1.0.0.GA]
	at org.jboss.classloading.plugins.visitor.FederatedResourceVisitor.visit(FederatedResourceVisitor.java:101) [jboss-classloading.jar:2.2.0.GA]
	at org.jboss.classloading.plugins.vfs.VFSResourceVisitor.visit(VFSResourceVisitor.java:264) [jboss-classloading-vfs.jar:2.2.0.GA]
	at org.jboss.vfs.VirtualFile.visit(VirtualFile.java:408) [jboss-vfs.jar:3.0.0.GA]
	at org.jboss.vfs.VirtualFile.visit(VirtualFile.java:410) [jboss-vfs.jar:3.0.0.GA]
	at org.jboss.vfs.VirtualFile.visit(VirtualFile.java:410) [jboss-vfs.jar:3.0.0.GA]
	at org.jboss.vfs.VirtualFile.visit(VirtualFile.java:410) [jboss-vfs.jar:3.0.0.GA]
	at org.jboss.vfs.VirtualFile.visit(VirtualFile.java:396) [jboss-vfs.jar:3.0.0.GA]
	at org.jboss.classloading.plugins.vfs.VFSResourceVisitor.visit(VFSResourceVisitor.java:102) [jboss-classloading-vfs.jar:2.2.0.GA]
	at org.jboss.deployers.vfs.plugins.classloader.VFSDeploymentClassLoaderPolicyModule.visit(VFSDeploymentClassLoaderPolicyModule.java:181) [:2.2.0.GA]
	at org.jboss.scanning.plugins.DeploymentUnitScanner.scan(DeploymentUnitScanner.java:111) [:1.0.0.GA]
	at org.jboss.scanning.spi.helpers.UrlScanner.scan(UrlScanner.java:96) [:1.0.0.GA]
	at org.jboss.scanning.deployers.ScanningDeployer.deploy(ScanningDeployer.java:95) [:1.0.0.GA]
	at org.jboss.deployers.plugins.deployers.DeployerWrapper.deploy(DeployerWrapper.java:179) [:2.2.0.GA]
	at org.jboss.deployers.plugins.deployers.DeployersImpl.doDeploy(DeployersImpl.java:1832) [:2.2.0.GA]
	at org.jboss.deployers.plugins.deployers.DeployersImpl.doInstallParentFirst(DeployersImpl.java:1550) [:2.2.0.GA]
	at org.jboss.deployers.plugins.deployers.DeployersImpl.install(DeployersImpl.java:1491) [:2.2.0.GA]
	at org.jboss.dependency.plugins.AbstractControllerContext.install(AbstractControllerContext.java:379) [jboss-dependency.jar:2.2.0.GA]
	at org.jboss.dependency.plugins.AbstractController.install(AbstractController.java:2044) [jboss-dependency.jar:2.2.0.GA]
	at org.jboss.dependency.plugins.AbstractController.incrementState(AbstractController.java:1083) [jboss-dependency.jar:2.2.0.GA]
	at org.jboss.dependency.plugins.AbstractController.executeOrIncrementStateDirectly(AbstractController.java:1322) [jboss-dependency.jar:2.2.0.GA]
	at org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1246) [jboss-dependency.jar:2.2.0.GA]
	at org.jboss.dependency.plugins.AbstractController.resolveContexts(AbstractController.java:1139) [jboss-dependency.jar:2.2.0.GA]
	at org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:939) [jboss-dependency.jar:2.2.0.GA]
	at org.jboss.dependency.plugins.AbstractController.change(AbstractController.java:654) [jboss-dependency.jar:2.2.0.GA]
	at org.jboss.deployers.plugins.deployers.DeployersImpl.change(DeployersImpl.java:1983) [:2.2.0.GA]
	at org.jboss.deployers.plugins.deployers.DeployersImpl.process(DeployersImpl.java:1076) [:2.2.0.GA]
	at org.jboss.deployers.plugins.main.MainDeployerImpl.process(MainDeployerImpl.java:679) [:2.2.0.GA]
	at org.jboss.deployment.MainDeployer.deploy(MainDeployer.java:380) [:6.0.0.Final]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [:1.6.0_23]
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) [:1.6.0_23]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) [:1.6.0_23]
	at java.lang.reflect.Method.invoke(Unknown Source) [:1.6.0_23]
	at org.jboss.mx.interceptor.ReflectedDispatcher.invoke(ReflectedDispatcher.java:157) [:6.0.0.GA]
	at org.jboss.mx.server.Invocation.dispatch(Invocation.java:96) [:6.0.0.GA]
	at org.jboss.mx.server.Invocation.invoke(Invocation.java:88) [:6.0.0.GA]
	at org.jboss.mx.server.AbstractMBeanInvoker.invoke(AbstractMBeanInvoker.java:271) [:6.0.0.GA]
	at org.jboss.mx.server.MBeanServerImpl.invoke(MBeanServerImpl.java:670) [:6.0.0.GA]
	at org.jboss.system.server.jmx.MBeanServerWrapper.invoke(MBeanServerWrapper.java:138) [:6.0.0.Final (Build SVNTag:JBoss_6.0.0.Final date: 20101228)]
	at javax.management.remote.rmi.RMIConnectionImpl.doOperation(Unknown Source) [:1.6.0_23]
	at javax.management.remote.rmi.RMIConnectionImpl.access$200(Unknown Source) [:1.6.0_23]
	at javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(Unknown Source) [:1.6.0_23]
	at javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(Unknown Source) [:1.6.0_23]
	at javax.management.remote.rmi.RMIConnectionImpl.invoke(Unknown Source) [:1.6.0_23]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [:1.6.0_23]
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) [:1.6.0_23]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) [:1.6.0_23]
	at java.lang.reflect.Method.invoke(Unknown Source) [:1.6.0_23]
	at sun.rmi.server.UnicastServerRef.dispatch(Unknown Source) [:1.6.0_23]
	at sun.rmi.transport.Transport$1.run(Unknown Source) [:1.6.0_23]
	at java.security.AccessController.doPrivileged(Native Method) [:1.6.0_23]
	at sun.rmi.transport.Transport.serviceCall(Unknown Source) [:1.6.0_23]
	at sun.rmi.transport.tcp.TCPTransport.handleMessages(Unknown Source) [:1.6.0_23]
	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(Unknown Source) [:1.6.0_23]
	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(Unknown Source) [:1.6.0_23]
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source) [:1.6.0_23]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) [:1.6.0_23]
	at java.lang.Thread.run(Unknown Source) [:1.6.0_23]{code}","JBoss AS 6.0.0 / Tomcat 7.0.0
Windows 7",paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,86400,86400,,0%,86400,86400,,,,,,,,,,,,,,,,,,,,,,,,"13/Feb/11 13:58;melix;MyAnnotation.java;https://issues.apache.org/jira/secure/attachment/12722776/MyAnnotation.java","13/Feb/11 13:58;melix;package-info.class;https://issues.apache.org/jira/secure/attachment/12722734/package-info.class","13/Feb/11 13:58;melix;package-info.java;https://issues.apache.org/jira/secure/attachment/12722779/package-info.java",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 20 03:19:27 UTC 2011,,,,,,,,,,"0|i2bz53:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Feb/11 10:18;guillaume;I've removed the offending package-info.groovy file.;;;","11/Feb/11 10:28;beamerblvd;I figured that would be the only needed change. Thanks!;;;","11/Feb/11 21:06;paulk;Deleting the file from source isn't the correct approach - as we lose doco and have reduced functionality in groovydoc compared with javadoc. We need to make other parts of the build ignore such files. I'll work on a better fix shortly.;;;","13/Feb/11 02:57;paulk;Actually looking at the generated class file I don't see much different from what Java produces in its package-info.class files. Groovy is setting ""major version: 49"" (Java 5 had some package-info support anyway) versus Java which is setting ""major version: 50"" with my default setup but otherwise the files seem alike.;;;","13/Feb/11 06:24;melix;If I remember well, package-info.java files should only be processed by javadoc : if you compile this file with javac, no .class file should be produced. groovyc produces this file though with package-info.groovy.;;;","13/Feb/11 10:12;beamerblvd;Let my provide a few more details...

As of and after Java 1.5, package-info.java classes ARE compiled and shipped. This is because packages can retain annotations at runtime, and you annotate a package by annotating the package statement in package-info.java.

Comments, annotations and the package statement should be the only things present in a package-info.java file, and the compiler strips out comments as usual and leaves just the package statement and annotations marked as having a runtime retention policy.

The package-info.groovy file just had the package statement and comments in it (so it was rather worthless for anything other than JavaDocs), but when compiled, the following appeared in it (when decompiled):

{code}
package groovy.jmx.builder;

interface package-info {

}
{code}

The Java ClassLoader, when it sees this (empty) interface defined in the class file, throws an error because you can't have hyphens in class/interface names. That is the error you get above.

So the 100% correct solution is to fix the Groovy compiler to compile the package-info file correctly. The 90% correct solution is to have the Groovy compiler ignore the package-info.groovy file, but that may result in annotations being ignored (I don't know if Groovy even has annotations, I don't use Groovy, this is a dependency of Jasper Reports, which I use). Removing the package-info.groovy file doesn't necessarily work, because what's to stop someone (or someone's IDE) from recreating it?

Let me know if you have questions.

Thanks.;;;","13/Feb/11 11:56;blackdrag;with not correctly you mean only the name, right? How is the name supposed to be right looking?;;;","13/Feb/11 12:01;beamerblvd;Well, there isn't supposed to be anything other than the package statement and annotations in the package-info.class file. The fact that an interface is defined in it is incorrect to begin with. Apparently, however, the ClassLoader is trying to load it anyway, but choking on the hyphen.

So, no, I mean that the Groovy compiler shouldn't be putting an interface in the file at all. That is the root of the problem.;;;","13/Feb/11 13:20;blackdrag;but there is no package statement in class files. The package is part of the classname. That means I need a classname. Or it is no ordinary class, then it would be good if someone could tell me where to get such a class file, so I can check, or to attach one here (even better);;;","13/Feb/11 13:56;melix;Jochen, I've made this simple test : create an annotation like this :

{code}
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.CLASS)
@Target(ElementType.PACKAGE)
public @interface MyAnnotation {
}
{code}

Then use this annotation in a package-info.java file :
{code}
@groovy.test.MyAnnotation
package groovy.other;
{code}

Then a .class file is generated (there's no .class generated if the package is not annotated). The result of javap is then :
{code}
# javap -s -c -verbose groovy/other/package-info
Compiled from ""package-info.java""
interface groovy.other.package-info
  SourceFile: ""package-info.java""
  RuntimeInvisibleAnnotations: length = 0x6
   00 01 00 06 00 00 
  minor version: 0
  major version: 50
  Constant pool:
const #1 = class	#7;	//  ""groovy/other/package-info""
const #2 = class	#8;	//  java/lang/Object
const #3 = Asciz	SourceFile;
const #4 = Asciz	package-info.java;
const #5 = Asciz	RuntimeInvisibleAnnotations;
const #6 = Asciz	Lgroovy/test/MyAnnotation;;
const #7 = Asciz	groovy/other/package-info;
const #8 = Asciz	java/lang/Object;

{
}

{code};;;","13/Feb/11 13:58;melix;Example of package-info.class;;;","13/Feb/11 16:10;paulk;I have this same setup. The Java and Groovy class files look essentially the same to me. Can anyone confirm that a Java package-info file works with Tomcat or JBoss?;;;","15/Feb/11 15:29;melix;I created a mini webapp with both a Java annotated package-info.java file and the groovy  1.7.7 library in the classpath. Under Tomcat 7.0.8, I can't see any error nor warning...;;;","16/Feb/11 15:49;paulk;Cédric: And you can replicate the ClassFormatError by replacing the Java based package-info class file in your web app with a Groovyc'd class file?;;;","16/Feb/11 16:40;melix;No, I meant I tested both. I can't reproduce at all. I'm starting to think this is not directly related to Groovy, but rather to a ""magic library"" which performs classpath scanning. Nicolas, how do you deploy your application ? As a war file ? Do you include groovy libs in the application server lib directory ?;;;","25/Feb/11 15:37;paulk;I have reverted the package-info file in 1.8 and trunk (but for now have left it out of the 1_7_X branch). I can find no difference in Java and Groovy generated files when runtime annotations are used. Leaving open for now as we should check further the case when no runtime annotations are supplied. In theory we can leave out the class file altogether in that case - have to double check what we actually do - certainly ant leaves around a stub in that case even though it is not required.;;;","12/Jun/11 15:28;graemerocher;Raising the priority of this because it breaks deployment of Grails applications on JBoss 6. See http://jira.grails.org/browse/GRAILS-7553;;;","12/Jun/11 15:44;paulk;Lowering priority for now. Groovy 1.7.9 and 1.7.10 (and future 1.7.* versions) don't have the files which cause the error.

Groovy 1.8.0 does include the mentioned files as Tomcat and JBoss break on the Java equivalent of those files anyway - so on present information, those containers contain the bug not Groovy. Our thinking was that those app servers would fix the problem before Groovy 1.8 was widely used in a bundled Grails. Please re-raise the priority if you do not believe that to be the case and we can look at workarounds for 1.8 too (we basically throw away doco and potentially annotations - so not the long term approach we would like to take). Besides, I would suspect any users using standard Java javadoc conventions will be caught out by the same issue - though I haven't tried it.;;;","13/Jun/11 03:48;graemerocher;I don't think its acceptable for us to expect containers to fix this problem. Also since Tomcat is still issuing a warning that makes for an unpleasant experience for users. My recommendation is that a workaround be found for the problem in 1.8.1

It is not acceptable situation that people cannot deploy Groovy applications to JBoss or Tomcat cleanly. If it is a choice between worse documentation and deploying to containers then the latter wins by a mile. ;;;","13/Jun/11 07:48;paulk;Well we _should_ expect them to fix this since Java 1.5 has been out since 2004 and indeed is already EOL - they have certainly had plenty of time to become 1.5 compliant. But agree that we shouldn't rely on it. Rather than delete our doco, we hopefully can tweak our build to remove the troublesome classes after the doco is generated. Of course, users won't be able to use runtime package-level annotations nor bundle their doco if using the recommended 1.5 style in their grails war until the containers are fixed.;;;","19/Jul/11 15:15;graemerocher;Is this going to be resolved for 1.8.1? It is causing http://jira.grails.org/browse/GRAILS-7756 and should really be a blocker IMO. Has the tweak to the build been done?;;;","19/Jul/11 16:49;paulk;I have a tweak to the build files which I will commit tonight once I have better connectivity, so it should be in 1.8.1.;;;","20/Jul/11 03:19;paulk;Build has been modified to remove the package-info.class files from the binary jars for now. They can still be found in the source jars at the moment. Let me know if there are any further problems.;;;",,,,,,,,,,,,,,,,,,,,,,
groovy.ui.Console cannot be extended,GROOVY-4670,12815509,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,middlewareman,middlewareman,08/Feb/11 13:19,12/Jan/13 20:40,14/Jul/23 06:00,04/Jan/13 02:32,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.0-rc-1,,,Groovy Console,,,,3,,,,,,"A minimal extension of groovy.io.Console throws ""groovy.lang.MissingPropertyException: No such property: scriptRunning"" after successfully evaluating a script.

{code:title=GWLSTConsole.groovy|borderStyle=solid}
package com.middlewareman.mbean.weblogic.shell

class GWLSTConsole extends groovy.ui.Console {

	GWLSTConsole() {
		super()
	}

	GWLSTConsole(Binding binding) {
		super(binding)
	}

	GWLSTConsole(ClassLoader parent, Binding binding) {
		super(parent, binding)
	}

	GWLSTConsole(ClassLoader parent) {
		super(parent)
	}
}
{code}

{noformat}
Exception in thread ""Thread-5"" 
groovy.lang.MissingPropertyException: No such property: scriptRunning for class: com.middlewareman.mbean.weblogic.shell.GWLSTConsole
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:49)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.setGroovyObjectProperty(ScriptBytecodeAdapter.java:533)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:904)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:44)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:141)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:149)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:276)
	at groovy.lang.Closure.call(Closure.java:271)
	at groovy.lang.Closure.run(Closure.java:354)
	at java.lang.Thread.run(Unknown Source)
{noformat}

In general, it would be great if groovy.ui.Console would be more flexible for adapting to your own DSLs. In my case, for example, I would like to customise the title. It is currently hard-coded in two places, and extending the class would be one way of overriding these.",,blackdrag,lau,pschumacher,rui.figueira,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 04 02:32:19 UTC 2013,,,,,,,,,,"0|i2cb87:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Mar/12 06:57;rui.figueira;I'm experiencing the same problem. As a workarround, I just declared a default runningScript property and it worked:

{code}
class MyConsole extends Console
{
	boolean scriptRunning = false
	
	void newScript(ClassLoader parent, Binding binding) {
		def importCustomizer = new ImportCustomizer()
                // add default import classes
                ...
        }
}
{code};;;","18/Mar/12 06:59;rui.figueira;Well, my mistake... it's not actually working properly...;;;","20/Nov/12 17:20;lau;I have the same problem. Could someone please explain at least why it isn't working.
The property is present in the super class, how does it dissapear. I am sorry
that I do not understand groovy very well. I am trying to learn. ;;;","01/Jan/13 02:20;pschumacher;@Laurence: I guess the missing property exception occurs because scriptRunning is declared private in groovy.ui.console. This is probably related to [GROOVY-3010] or some of the other open issues concerning private visibility.;;;","01/Jan/13 04:21;pschumacher;I created a pull request [https://github.com/groovy/groovy-core/pull/100/files] which removes the private visibility of the scriptRunning and two others attributes.

Now the class should be extendable.;;;","04/Jan/13 02:32;blackdrag;merged pull request;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"""anystring"" as byte[] throws java.lang.NumberFormatException: For input string: ""anystring""",GROOVY-4669,12815514,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,wirah,wirah,08/Feb/11 07:30,08/Feb/11 10:21,14/Jul/23 06:00,08/Feb/11 10:21,1.7.7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.8,1.8-rc-1,,groovy-jdk,,,,0,,,,,,"For some reason, since Groovy 1.7.5 I can no longer coerce a String (either "" or ') to a byte[].

I instead get java.lang.NumberFormatException: For input string: ""xxx""","Groovy 1.7.7
Ubuntu 10.10",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 08 10:21:17 UTC 2011,,,,,,,,,,"0|i2bpaf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Feb/11 10:21;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
for-loop type declaration does not work,GROOVY-4667,12815483,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,joerg.schreiner,joerg.schreiner,07/Feb/11 10:40,07/Feb/11 11:30,14/Jul/23 06:00,07/Feb/11 11:30,1.7.7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-4,,,,,,,0,,,,,,"The type declaration of the iterator variable in a for-loop seems to be ignored:

{code}
List l = ['aaa'] // contains one String
try {
    for (Integer i in l) { // iterator declared Integer (not assignable from String!)
        // GroovyCastException expected in assignment to i in the previous line
        assert false // we should not get this far, expected GroovyCastException
    }
}
catch (org.codehaus.groovy.runtime.typehandling.GroovyCastException e) {
    assert true // expected exception
}
{code}
 
Exception thrown
07.02.2011 17:33:40 org.codehaus.groovy.runtime.StackTraceUtils sanitize

WARNUNG: Sanitizing stacktrace:

Assertion failed: 

assert false // we should not get this far, expected GroovyCastException

",Groovy 1.7.7 on Windows XP x86,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 07 11:30:09 UTC 2011,,,,,,,,,,"0|i2co3j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Feb/11 11:30;blackdrag;This issue gets a ""Won't Fix"" for 1.7.x and a ""Fixed"" for 1.8. In 1.8 I did a major change behind the scenes that involves also this kind of thing being fixed. But the change has a too big reach to back port it back to 1.7 and as such it will stay in 1.8 only. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
incorrect behavior of array subscript operator with reverse ranges,GROOVY-4665,12817067,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,jpertino,jpertino,06/Feb/11 20:53,14/Oct/13 16:53,14/Jul/23 06:00,22/Sep/13 02:08,1.7.7,1.8-beta-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-rc-1,,,groovy-jdk,,,,0,,,,,,"reverse ranges like {{X..-Y}} are used in lists to represent forward ranges of the form {{X..list.size()-Y}}.
this is not the case with arrays, as these special cases return a list that match the reverse range.

this can easily be tested with this snippet
{code}
def list = [1,2,3,4]
int[] array = list
assert list[2..-1] == [3,4]
assert array[2..-1] == [3,4]
{code}

which currently yields
{code}
Assertion failed: 

assert array[2..-1] == [3,4]
       |    |       |
       |    |       false
       |    [3, 2, 1, 4]
       [1, 2, 3, 4]
{code}

we can track this to the protected DGM.primitiveArrayGet(Object,Range) that is called from DGM.getAt(int[],Range) and its siblings.

this method just iterates the range to generate the returned list, whereas the list equivalent DGM.getAt(List,Range) makes use of DGMS.subListBorders(int,Range) to detect the reverse ranges.
",any,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 22 02:08:12 UTC 2013,,,,,,,,,,"0|i2btb3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Feb/11 21:24;jpertino;note the title might be misleading, as only the described special cases work differently than expected.
in fact, the problem is that the returned list matches exactly what the reverse range asked for...
but you get the idea.

(can issues be edited?);;;","22/Sep/13 02:08;pschumacher;The snippet works with Groovy-2.2.0-beta-3. I guess this was fixed by recent changes to the range operator in relation to lists.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy Console shows both full and sanitized stack trace by default,GROOVY-4663,12815490,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,asteingress,pniederw,pniederw,06/Feb/11 08:58,10/Jul/13 04:42,14/Jul/23 06:00,16/Apr/13 14:32,1.8.9,2.0.8,2.1.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,Groovy Console,,,,0,contrib,,,,,"Groovy Console with default settings (as far as I can tell; don't know how to reset them) shows both full and sanitized stack trace:

{noformat}
groovy> throw new Exception() 
 
Exception thrown
Feb 6, 2011 2:39:14 PM org.codehaus.groovy.runtime.StackTraceUtils sanitize
WARNING: Sanitizing stacktrace:
java.lang.Exception
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
	at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:190)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:194)
	at ConsoleScript1.run(ConsoleScript1:1)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:266)
	at groovy.lang.GroovyShell.run(GroovyShell.java:517)
	at groovy.lang.GroovyShell.run(GroovyShell.java:172)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:266)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:63)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:132)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:927)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:149)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:282)
	at groovy.lang.Closure.call(Closure.java:277)
	at groovy.lang.Closure.run(Closure.java:360)
	at java.lang.Thread.run(Thread.java:680)

java.lang.Exception
	at ConsoleScript1.run(ConsoleScript1:1)
groovy> throw new Exception() 
 
Exception thrown

java.lang.Exception
	at ConsoleScript2.run(ConsoleScript2:1)

{noformat}

Apparently this happens because log output of StackTraceUtils goes to standard err and Groovy Console shows standard err by default. Something should be changed so that only sanitized stack trace is shown by default.",,asteingress,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 16 14:32:44 UTC 2013,,,,,,,,,,"0|i2bsxz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Apr/13 08:37;asteingress;Here is the pull request: https://github.com/groovy/groovy-core/pull/168;;;","16/Apr/13 14:32;asteingress;Pull request merged.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
List#getAt(Range) method doesn't work with half-exclusive ranges,GROOVY-4661,12815482,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,os,os,04/Feb/11 08:46,14/Oct/13 16:53,14/Jul/23 06:00,22/Sep/13 02:12,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-rc-1,,,groovy-jdk,,,,0,,,,,,"def list = [1, 2, 3, 4]

println list[0..<1]    // [1], correct
println list[0..<2]    // [1, 2], correct
println list[0..<-1]   // [1], should be [1, 2, 3]
println list[0..<-2]   // [1, 2, 3, 4], should be [1, 2]

While this particular behavior is not covered in the Groovy JDK documentation it is intuitive to believe that indexing by such half-exclusive ranges should work just fine. But it doesn't.",Mac OS 10.6.6,os,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4911,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 22 02:12:09 UTC 2013,,,,,,,,,,"0|i2csav:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Sep/13 02:12;pschumacher;The snippet works as the poster expected with Groovy-2.2.0-beta-3. I guess this was fixed by recent changes of the range operator in relation with lists.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE in groovy.servlet.AbstractHttpServlet if deploy WAR to jetty ,GROOVY-4660,12817269,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,paulcager,paulcager,04/Feb/11 06:19,12/Feb/12 04:03,14/Jul/23 06:00,02/Feb/12 10:19,1.7.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,Groovlet / GSP,,,,0,,,,,,"I have generated a (non-grails) war using gsp's mapped to groovy.servlet.TemplateServlet. If I deploy the War to Tomcat it works. If I _unpack_ the war then it works in Jetty. But it fails with an NPE if I try to deploy it as a War with Jetty:

2011-02-04 11:04:06.030:INFO:data-pump-comparator-04.04.01-dev:GroovyTemplate: Servlet groovy.servlet.TemplateServlet initialized on
 class groovy.text.GStringTemplateEngine
2011-02-04 11:04:06.030:WARN::/data-pump-comparator-04.04.01-dev/
java.lang.NullPointerException
        at java.io.File.<init>(File.java:222)
        at groovy.servlet.AbstractHttpServlet.getScriptUriAsFile(AbstractHttpServlet.java:306)
        at groovy.servlet.TemplateServlet.service(TemplateServlet.java:388)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)
        at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:533)
        at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:475)
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:119)

I think this is down to a problm in groovy.servlet.AbstractHttpServlet

TemplateServlet.service does this:

    File file = super.getScriptUriAsFile(request);

AbstractHttpServlet.getScriptUriAsFile does this:
    String uri = getScriptUri(request);
    String real = servletContext.getRealPath(uri);
    return new File(real).getAbsoluteFile();

The Javadocs for javax.servlet.ServletContext.getRealPath say:

     * This method returns null
     * if the servlet container cannot translate the virtual path
     * to a real path for any reason (such as when the content is
     * being made available from a .war archive).

I think that is why the failure happens. AFAIK it also happens with WebLogic (http://groovy.329449.n5.nabble.com/Groovlet-GSP-NPE-when-deployed-as-a-war-to-Weblogic-td3320802.html)",Jetty: 7.2.0.v20101020,paulcager,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"09/Feb/11 12:34;paulcager;GROOVY-4660.patch;https://issues.apache.org/jira/secure/attachment/12722727/GROOVY-4660.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 02 10:19:54 UTC 2012,,,,,,,,,,"0|i2ckav:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Feb/11 06:22;guillaume;So how do you suggest fixing this? (Even better, a patch is warmly welcome);;;","04/Feb/11 06:55;paulcager;Sure - I'll see if I can work out a patch.

As far as I can see getScriptUriAsFile is used instead of getScriptUri so that the file's DateLastUpdated timestamp may be used to determine if the cache is out of date. I believe we'd need to preserve that behaviour, but fall back to using a URI if the file is not available.;;;","09/Feb/11 12:34;paulcager;Patch attached for you to look at.

Summary:

1)  Minor change to AbstractHttpServlet.getScriptUriAsFile so that it returns null (rather than an NPE) if getRealPath returns null.

2)  Change to TemplateServlet so that if getScriptUriAsFile returns null it will read the template text using {{servletContext.getResource(name)}} instead.

3)  Change to TemplateServlet's caching, to allow for the fact that we might not have a File (when it checks file.dateLastModified).

4)  Minor change to AbstractHttpServlet's test class.;;;","02/Feb/12 10:19;guillaume;The patch needed to be applied somehow manually, as it couldn't be applied automatically, making me wonder from what exact version you made the patch, but anyway, I've tried a groovlet and template in a war on Jetty, and it worked fine with the adapted patch.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
CLONE -problem compiling @Delegate to an interface that extends another interface (handle default args case),GROOVY-4658,12815488,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,brownj,brownj,02/Feb/11 06:29,08/Nov/11 08:16,14/Jul/23 06:00,08/Nov/11 08:16,1.7.4,1.7.5,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.4,2.0-beta-1,Compiler,,,,0,,,,,,"The following code compiles with 1.7.3 but fails with 1.7.4, 1.7.5 and 1.8.0-beta-3.

{code:title=SomeInterface.groovy|borderStyle=solid}
interface SomeInterface {
    void doSomething()
}
{code}

{code:title=SomeOtherInterface.groovy|borderStyle=solid}
interface SomeOtherInterface extends SomeInterface {}
{code}

{code:title=SomeClass.groovy|borderStyle=solid}
class SomeClass {
    @Delegate
    SomeOtherInterface someOtherInterface
}
{code}

Compiling with 1.7.3:

{noformat}
 $ groovy -version
Groovy Version: 1.7.3 JVM: 1.6.0_22
 $ groovyc SomeClass.groovy 
 $ 
{noformat}

Compiling with 1.7.4:

{noformat}
 $ groovy -version
Groovy Version: 1.7.4 JVM: 1.6.0_22
 $ groovyc SomeClass.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
SomeClass.groovy: 1: Can't have an abstract method in a non-abstract class. The class 'SomeClass' must be declared abstract or the method 'void doSomething()' must be implemented.
 @ line 1, column 1.
   class SomeClass {
   ^

1 error

 $ 
{noformat}

Compiling with 1.7.5:

{noformat}
 $ groovy -version
Groovy Version: 1.7.5 JVM: 1.6.0_22
 $ groovyc SomeClass.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
SomeClass.groovy: 1: Can't have an abstract method in a non-abstract class. The class 'SomeClass' must be declared abstract or the method 'void doSomething()' must be implemented.
 @ line 1, column 1.
   class SomeClass {
   ^

1 error

 $ 
{noformat}

Compiling with 1.8.0-beta-3:

{noformat}
 $ groovy -version
Groovy Version: 1.8.0-beta-3 JVM: 1.6.0_22
 $ groovyc SomeClass.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
SomeClass.groovy: 1: Can't have an abstract method in a non-abstract class. The class 'SomeClass' must be declared abstract or the method 'void doSomething()' must be implemented.
 @ line 1, column 1.
   class SomeClass {
   ^

1 error

 $ 
{noformat}

This may be related to GROOVY-4163.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 08 08:16:33 UTC 2011,,,,,,,,,,"0|i2cewf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Nov/11 03:36;melix;Under Groovy 1.8.3, it returns a different error:
{noformat}groovyc SomeClass.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
SomeClass.groovy: 2: unable to resolve class SomeOtherInterface 
 @ line 2, column 5.
       SomeOtherInterface someOtherInterface
       ^

1 error
{noformat}

But using groovyc *.groovy, it works.;;;","08/Nov/11 08:16;blackdrag;fixed in many cases. It seems not to work for me locally, but we have confirmed it works for many others;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Regression: Null element coerced to ""null"" String when containing List is coerced to String array",GROOVY-4657,12815507,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,pniederw,pniederw,01/Feb/11 23:39,03/Feb/11 10:51,14/Jul/23 06:00,03/Feb/11 10:51,1.7.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.7,1.8-beta-4,,,,,,0,,,,,,"From http://groovy.329449.n5.nabble.com/Change-in-contains-behavior-in-1-7-6-vs-1-7-5-td3367327.html:

Groovy 1.7.5:

{code}
def x = [null] as String[]
println x[0] == null  // true
println x[0]?.length() // null
{code}

Groovy 1.7.6:

{code}
def x = [null] as String[]
println x[0] == null  // false
println x[0]?.length() // 4
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 03 10:51:44 UTC 2011,,,,,,,,,,"0|i2by3j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Feb/11 10:51;blackdrag;There will be now an exception for String[], so fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovy.transform.EqualsAndHashCode annotation does not handle cycles,GROOVY-4655,12815508,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,leo.herbie,leo.herbie,01/Feb/11 10:32,12/Apr/13 16:55,14/Jul/23 06:00,09/Apr/13 05:32,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.3,2.2.0-beta-1,,groovy-jdk,,,,0,contrib,,,,,"The groovy.transform.EqualsAndHashCode AST transformation does not handle object graphs with cycles. See the attached junit tests.

Some of the test methods I included actually pass - I just included them for completeness.  Basically, the equals method handles cycles just fine.  The hashcode method does not so all the tests related to the hashcode method fail.

This is a pretty serious issue because these object structures are common with some frameworks (like orm tools)",,leo.herbie,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"01/Feb/11 10:32;leo.herbie;Bar.groovy;https://issues.apache.org/jira/secure/attachment/12722818/Bar.groovy","01/Feb/11 10:32;leo.herbie;EqualsAndHashCodeCycleTest.groovy;https://issues.apache.org/jira/secure/attachment/12722773/EqualsAndHashCodeCycleTest.groovy","01/Feb/11 10:32;leo.herbie;Foo.groovy;https://issues.apache.org/jira/secure/attachment/12722819/Foo.groovy",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 09 05:32:05 UTC 2013,,,,,,,,,,"0|i2bvlb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Apr/13 19:40;paulk;There is now minimal support (in master and 2_1_X) to handle self-references in the generated equals(), plus the doco is updated a little to better set expectations - the annotation was never meant to cover all cases - just reduce boilerplate in the standard cases. Next up is to provide similar support in hashCode() for self-references. Then I think we could probably close this issue. I am not sure a general solution could be found for arbitrary mutually recursive data structures while still following Java conventions for the respective methods.;;;","09/Apr/13 05:32;paulk;There is now code to handle hashCode() self-references and given the doco improvements (to better set expectations) I am going to resolve this issue. Mutual recursion isn't handled yet but I don't know any algorithms that would handle such recursion in a general way given the other conventions and constraints around these methods. If you have specific suggestions, please reopen or better still create a new issue with your proposal. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
stub generation fails with generic signatures,GROOVY-4650,12815454,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,leo.herbie,leo.herbie,28/Jan/11 12:12,21/Jul/11 19:06,14/Jul/23 06:00,30/Jun/11 06:13,1.7.6,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,Stub generator / Joint compiler,,,,3,,,,,,"The stub generation fails with the following classes.  It appears it may be because of the generic signatures.

{code}
//groovy code
public interface ColContract {
  List<? extends PrimitiveContract> getPrims();
  String getThing();
  List<String> getMoreThings();
}

public interface PrimitiveContract {
  String getFoo();
  String getBar();
}
{code}

{code}
import java.util.List;

public class Client3 {
    { new ColContract() {
        @Override
        public List<? extends PrimitiveContract> getPrims() {
            return null;
        }

        @Override
        public String getThing() {
            return null;
        }

        @Override
        public List<String> getMoreThings() {
            return null;
        }
    }; }
}
{code}",,luukes,orekutin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 30 06:13:05 UTC 2011,,,,,,,,,,"0|i2c787:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Jan/11 12:48;blackdrag;to you give the error message you get as well?;;;","28/Jan/11 17:58;leo.herbie;Oh sorry about that.  Here is the error message the the groovyc compiler gives me.  BTW.  This code also fails in Intellij 10.1 when using the native groovy stub generation if that helps.

{code}
C:\IdeaProjects\groovy-bugs\src\main>groovyc -j groovy/ColContract.groovy groovy/PrimitiveContract.groovy java/Client3.java
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed: Compile error during compilation with javac.

C:\DOCUME~1\schnee13\LOCALS~1\Temp\groovy-generated-4794247310035767174-java-source\ColContract.java:10: > expected java.util.List<PrimitiveContract extends PrimitiveContract> getPrims();
                                 ^
C:\DOCUME~1\schnee13\LOCALS~1\Temp\groovy-generated-4794247310035767174-java-source\ColContract.java:10: = expected java.util.List<PrimitiveContract extends PrimitiveContract> getPrims();
                                          ^
C:\DOCUME~1\schnee13\LOCALS~1\Temp\groovy-generated-4794247310035767174-java-source\ColContract.java:10: ';' expected
 java.util.List<PrimitiveContract extends PrimitiveContract> getPrims();
                                                           ^
C:\DOCUME~1\schnee13\LOCALS~1\Temp\groovy-generated-4794247310035767174-java-source\ColContract.java:10: <identifier> expected
 java.util.List<PrimitiveContract extends PrimitiveContract> getPrims();
                                                                     ^
C:\DOCUME~1\schnee13\LOCALS~1\Temp\groovy-generated-4794247310035767174-java-source\ColContract.java:10: cannot find symbol
symbol  : class getPrims location: interface ColContract java.util.List<PrimitiveContract extends PrimitiveContract> getPrims();
                                                             ^
C:\IdeaProjects\groovy-bugs\src\main\java\Client3.java:4: <anonymous Client3$1> is not abstract and does not override abstract method <error>() in ColContract { new ColContract() {
                        ^
C:\IdeaProjects\groovy-bugs\src\main\java\Client3.java:5: method does not override or implement a method from a supertype
        @Override
        ^
7 errors


1 error
{code};;;","29/Jan/11 07:03;blackdrag;ok, then I see the following problems:
* The anonymous inner class in Client3 should not be part of the stub
* ? extends PrimitiveContract is done as PrimitiveContract extends PrimitiveContract, which is wrong.;;;","24/Feb/11 09:22;orekutin;I am also seeing  (in 1.7.6) the stub generator produce ""? extends A"" as ""A extends A"".;;;","30/Jun/11 06:13;paulk;I believe this is fixed. If you could try a SNAPSHOT version, that would be great. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static inner classes are not being compiled correctly,GROOVY-4649,12815504,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,leo.herbie,leo.herbie,28/Jan/11 10:00,17/Feb/11 15:52,14/Jul/23 06:00,17/Feb/11 15:52,1.7.6,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.9,1.8-rc-1,,Compiler,,,,4,,,,,,"The groovy compiler used by eclipse & intellij are both having trouble compiling static inner classes.  The groovyc compiler does not fail but it appears to generate incorrect bytecode.  I filed a issue with intellij and they said that this is a groovy compiler problem not and intellij problem.

The following code triggers the problem:

{code}
//groovy code
class Outer {
  static class Inner {}
}
{code}

{code}
//java code
public class Client {
  { new Outer.Inner(); }
}
{code}

This is a serious issue because without any tool support we cannot use static inner classes.  The only work around for this issue is to not use static inner classes.

Here are the following issues related to this:

http://jira.codehaus.org/browse/GRECLIPSE-983
http://youtrack.jetbrains.net/issue/IDEA-64752
http://youtrack.jetbrains.net/issue/IDEA-50708

I have not looked in detail at the bytecode generated by the groovy compiler but decompiling the class files with JD Decompiler gives the following:
{code}
//notice no reference to the Inner class.  Decompiling a java compiled class like this will show the Inner class in the Outer class.
public class Outer
  implements GroovyObject
{
  public Outer()
  {
    Outer this;
    CallSite[] arrayOfCallSite = $getCallSiteArray();
    MetaClass localMetaClass = $getStaticMetaClass();
    this.metaClass = localMetaClass;
  }

  static
  {
    Long localLong1 = (Long)DefaultTypeTransformation.box(0L);
    __timeStamp__239_neverHappen1296229343062 = DefaultTypeTransformation.longUnbox(localLong1);
    Long localLong2 = (Long)DefaultTypeTransformation.box(1296229343062L);
    __timeStamp = DefaultTypeTransformation.longUnbox(localLong2);
  }
}
{code}
",,leo.herbie,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 17 15:52:07 UTC 2011,,,,,,,,,,"0|i2co8f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Feb/11 11:17;leo.herbie;Guys, any chance of this being fixed for the 1.8 release?;;;","17/Feb/11 11:42;blackdrag;Let's see... If I compile this in java with the public modifier then I get an entry in Outer that looks like this{code}  // access flags 9
  public static INNERCLASS Outer$Inner Outer Inner{code} and the same for Inner too. If done with Groovy I see that this inner class reference is missing and the modifier for the inner class is actually 41, meaning that static is set... which is wrong. Since it works without those inner class entries I strongly assume this static flag being set is the major problem here.;;;","17/Feb/11 11:54;leo.herbie;Hey, thanks for the quick response!  If there is any way that I can help out with this I'd be glad too.  Even if it's just testing or something :-);;;","17/Feb/11 14:25;blackdrag;I answered quick, because I wanted this bug fixed already and then forgot about it... anyway, I have a fixed version of this in trunk now. A nice benefit from fixing the entries is that javac suddenly is much faster in compiling the java files of groovy. I can only assume javac got irritated by the wrong entries or has an optimization for inner classes that could not kick in.;;;","17/Feb/11 15:33;leo.herbie;Jochen,

Will this be in the next 1.8 release (RC or beta)?  I think I heard somewhere that trunk is now considered groovy 1.9;;;","17/Feb/11 15:52;blackdrag;I am closing this issue as the fix is now available in 1.8, 1.9 and 1.7
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Pasting into groovy console using shift+insert turns overwrite mode on.,GROOVY-4648,12812025,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,dclifton,dclifton,28/Jan/11 04:02,22/Dec/12 01:10,14/Jul/23 06:00,14/Dec/12 15:01,1.6.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,2.1.0-beta-1,,,,,1,,,,,,"On windows there are two keyboard shortcut keys for pasting:

Ctrl+V
Shift+Insert

When pasting using the Shift+Insert into the groovy console script area text-overwrite mode is accidentally enabled by the code.

This doesn't happen when using Ctrl+V, I think there may be a bug in the keyboard handling code.

As a side note I'm left handed and thus often use shift+insert to paste so I leave one hand on the mouse (and i don't have to stretch my fingers as far).

Not had the chance to test with the latest version of the console, if it's already fixed please close this bug report.","Windows 7 x64, via 'grails console'.",dominicclifton,paulk,seanf,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 14 15:08:16 UTC 2012,,,,,,,,,,"0|i2ci33:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Dec/12 06:24;seanf;I created a pull request: https://github.com/groovy/groovy-core/pull/81
;;;","14/Dec/12 15:01;paulk;Fixed, thanks!;;;","14/Dec/12 15:08;dclifton;Thanks guys, I look forward to the next release that contains this fix.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Having a setter with a return value causes the stub generator to generate multiple setters and then fail to compile,GROOVY-4646,12817053,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,leo.herbie,leo.herbie,27/Jan/11 21:54,21/Jul/11 19:06,14/Jul/23 06:00,29/Jun/11 20:51,1.7.6,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,Compiler,,,,2,,,,,,"Having a class with a property and then explicitly defining the setter but giving it a return value (common for Builder classes) will compile fine with groovyc without joint compiling.  When using joint compiling the java stubs generated are invalid.  They end up with multiple setters - one normal void setter and one with the return value.  Obviously this is not valid code.  See the following example:

{code}
class SetterWithReturn {
  String foo
  def String bar

  SetterWithReturn setFoo(String foo) { this.foo = foo; return this; }
  SetterWithReturn setBar(String bar) { this.bar = bar; return this; }
}
{code}

{code}
public class SetterWithReturnClient {
    { new SetterWithReturn(); }
}
{code}

Here is the error the compiler gives:

{code}

C:\IdeaProjects\groovy-bugs>groovyc -j src\main\groovy\SetterWithReturn.groovy src\main\java\SetterWithReturnC
lient.java
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Compile error during compilation with javac.
C:\DOCUME~1\schnee13\LOCALS~1\Temp\groovy-generated-1842144177968937199-java-source\SetterWithReturn.java:22:
setFoo(java.lang.String) is already defined in SetterWithReturn
public  SetterWithReturn setFoo(java.lang.String foo) { return (SetterWithReturn)null;}
                         ^
C:\DOCUME~1\schnee13\LOCALS~1\Temp\groovy-generated-1842144177968937199-java-source\SetterWithReturn.java:23:
setBar(java.lang.String) is already defined in SetterWithReturn
public  SetterWithReturn setBar(java.lang.String bar) { return (SetterWithReturn)null;}
                         ^
2 errors


1 error

{code}",,leo.herbie,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 29 20:51:31 UTC 2011,,,,,,,,,,"0|i2cbrz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jun/11 17:14;paulk;Looks like Groovy actually produces both the void and returning type in its generated bytecode and doesn't complain. It seems to always pick the non-void method but that could be VM-specific behavior. I guess we should fix that behavior and then the joint compilation may just work if the same compiler visitor is involved.;;;","29/Jun/11 17:43;blackdrag;I changed the component to compiler, because I think the stub generator is not at fault here at all. This code should either not compile or no additional setter added.;;;","29/Jun/11 18:53;paulk;Looks like {{ClassNode#getSetterMethod}} always looks for a {{VOID}} method. Either that needs to change (possibly dangerous?) or {{Verifier}} needs to use a different approach.;;;","29/Jun/11 20:51;paulk;As per Jochen's hunch, fixing the compiler automatically fixed the joint compilation issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Convariant returns causes compiler to fail when generating property getters,GROOVY-4645,12817243,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,leo.herbie,leo.herbie,27/Jan/11 21:07,24/Dec/11 03:07,14/Jul/23 06:00,29/Nov/11 11:15,1.7.6,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.5,2.0-beta-2,Compiler,,,,4,,,,,,"When attempting to compile the following groovy code I get the compiler error under groovy 1.7.6 and 1.8.3-beta-3.  This has to do with defining an interface (or class) with getters and then defining properties (or final members variables) on a subclass using covariant returns.  I can work around this issue by explicitly defining the required getter in the subclass which is rather annoying b/c I like groovy getter generation and in our codebase we are running into this a lot.  This is also a problem when using ""def"" types.  I would be glad to assist in any way if I can.  Thanks.


For example:
{code}
interface CovariantReturns {
  Foo getGood()
  Object getBad()
}

class Foo {}

class CovariantReturnsImpl implements CovariantReturns {
  //getter is generated by groovy as required by the interface
  final Foo good

  //this variable is defined as the subtype of Object
  final Foo bad

  /*
   I would expect that the following method would be generated by groovy
   which is using Java's covariant returns feature.  Including the method below
   will allow the groovy compiler to succeed but is annoying that it has to be explicitly
   defined in code.

   public Foo getBad() { return bad }
   */
}
{code}

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
CovariantReturns.groovy: 8: Can't have an abstract method in a non-abstract class. The class 'CovariantReturns
Impl' must be declared abstract or the method 'java.lang.Object getBad()' must be implemented.
 @ line 8, column 1.
   class CovariantReturnsImpl implements CovariantReturns {
   ^

1 error
{noformat}
",,leo.herbie,moss,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4415,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 29 10:52:56 UTC 2011,,,,,,,,,,"0|i2brfr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Sep/11 03:46;paulk;add code tags;;;","22/Sep/11 03:46;paulk;Possibly overlaps with GROOVY-4415?;;;","29/Nov/11 10:52;melix;Same issue, two different ways of demonstrating.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Defining an abstract method in enum,GROOVY-4641,12815471,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,subzero66,subzero66,24/Jan/11 07:58,12/Apr/13 16:55,14/Jul/23 06:00,23/Mar/13 21:42,1.7.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.8,2.1.3,2.2.0-beta-1,Compiler,,,,16,,,,,,"In Java you can define abstract methods for an enum type to override it with a concrete method in a constant-specific class body (see Effective Java, 2nd Ed., page 152). When I try to do the same in Groovy I get a compilation error:

Can't have an abstract method in a non-abstract class. The class 'Day' must be declared abstract or the method 'java.lang.String getAction()' must be implemented. 

This compilation error can be reproduced with this enum:

{code}
enum Day {
   SUNDAY {
      String getAction() {
         'Relax'
      }
   },
   MONDAY {
       String getAction() {
          'Work'
       }
   }

   abstract String getAction()
}
{code}

An enum in Groovy should provide the same behavior for enums as Java.","Mac OS X 10.6.6
IntelliJ 10.0.1",bmuschko,donal,ilialewis,mauromol,mikedeck,nobeans,olandere,paulk,snekoval,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Jan/11 07:58;bmuschko;DayTest.groovy;https://issues.apache.org/jira/secure/attachment/12722724/DayTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Mar 23 21:42:13 UTC 2013,,,,,,,,,,"0|i2cs0f:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"03/Feb/11 06:31;paulk;add code tags;;;","23/Oct/12 13:44;mauromol;I'm also missing this feature.;;;","31/Jan/13 09:46;donal;If you don't define the method as abstract, this will work. So if you replace

{code}
abstract String getAction()
{code}

with:

{code}
String getAction() {
  throw new UnsupportedOperationException()
}
{code}

then you almost have the behaviour you're looking for. Admittedly, you will only find out at runtime if you forget to implement the method for a constant, but that's why I said ""almost"" :)
;;;","23/Mar/13 21:42;paulk;Should now be supported - thanks for raising the issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
XmlSlurper Unable to Access Attributes with Same Name but in Different Namespaces,GROOVY-4637,12816683,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,krizsan,krizsan,22/Jan/11 04:54,05/Apr/15 14:44,14/Jul/23 06:00,21/Dec/12 01:01,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,2.1.0-beta-1,,XML Processing,,,,3,,,,,,"When using XMLSlurper to parse XML in which there is an element with two attributes having the same name but belonging to different namespaces, one of the attribute values will be unaccessible.
This is due to XMLSlurper using the local attribute name as a key to a map in which data about the attributes are inserted and thus a key-collision will occur.
Adding the following method to the groovy.util.XmlSlurperTest in the Groovy source-code will expose the problem:
{code}
    void testSameNameAttributes() {
        def theInputData = """"""
        <RootElement xmlns=""http://www.ivan.com/ns1"" xmlns:two=""http://www.ivan.com/ns2"">
            <ChildElement ItemId=""FirstItemId"" two:ItemId=""SecondItemId"">Child element data</ChildElement>
        </RootElement>""""""
        def theXml = new MyXmlSlurper().parseText(theInputData).declareNamespace(one:""http://www.ivan.com/ns1"", two: ""http://www.ivan.com/ns2"")
        
        assert theXml.ChildElement.@'ItemId' == ""FirstItemId""
        assert theXml.ChildElement.@'two:ItemId' == ""SecondItemId""
    }
{code}

The following patches will make the above test pass, but I am not entirely sure it is the best solution:
Patching the XmlSlurper.startElement method:
{code}
public void startElement(final String namespaceURI, final String localName,
        final String qName, final Attributes atts) throws SAXException
    {
        addCdata();

        final Map attributes = new HashMap();
        final Map attributeNamespaces = new HashMap();

        for (int i = atts.getLength() - 1; i != -1; i--)
        {
            if (atts.getURI(i).length() == 0)
            {
                attributes.put(atts.getQName(i), atts.getValue(i));
            } else
            {
                // PATCHED START - Use fully qualified attribute names instead of just local attribute names
                attributes.put(atts.getQName(i), atts.getValue(i));
                attributeNamespaces.put(atts.getQName(i), atts.getURI(i));
                // PATCH END

            }

        }

        final Node newElement;
        ...
{code}

Patching groovy.util.slurpersupport.Attributes, method iterator() to use namespace-qualified attribute names when looking up attribute value. This is the patch I am unsure whether it is the best solution.
{code}
    public Iterator iterator() {
        return new NodeIterator(nodeIterator()) {
            protected Object getNextNode(final Iterator iter) {
                while (iter.hasNext()) {
                    final Object next = iter.next();
                    if (next instanceof Attribute) {
                        return next;
                    } else {
                        // PATCH START - Added namespace prefix when looking up attribute.
                        String attributeKey = """";
                        if (Attributes.this.namespacePrefix != null &&
                            !""*"".equals(Attributes.this.namespacePrefix) &&
                            Attributes.this.namespacePrefix.length() > 0) {
                            attributeKey = Attributes.this.namespacePrefix + "":"";
                        }
                        attributeKey += Attributes.this.attributeName;
                        final String value = (String) ((Node) next).attributes().get(attributeKey);
                        // PATCH END
                        if (value != null) {
                            return new Attribute(Attributes.this.attributeName,
                                    value,
                                    new NodeChild((Node) next, Attributes.this.parent.parent, """", Attributes.this.namespaceTagHints),
                                    """",
                                    Attributes.this.namespaceTagHints);
                        }
                    }
                }
                return null;
            }
        };
    }
{code}
",JDK 6,paulk,stigat,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Dec 21 01:01:52 UTC 2012,,,,,,,,,,"0|i2cjfr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"19/Jun/12 04:53;holger.hagedorn;Would be nice to have it solved in the 2.0 release.
Lot of XMLs use namespaces so it would be very useful for me (and for others as well)?;;;","10/Dec/12 13:56;stigat;I would also find a fix for this very useful;;;","21/Dec/12 01:01;paulk;Fixed with a slight variation to your proposal since in XML the URI is the important thing not the prefix, hence the following assert would also work for your example:
{code}
assert theXml.ChildElement.@'one:ItemId' == ""FirstItemId""
{code}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@InheritConstructors does not work on inner classes,GROOVY-4633,12815481,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,owensr,owensr,20/Jan/11 08:47,13/May/12 03:30,14/Jul/23 06:00,22/Feb/12 01:06,1.7.5,1.7.6,1.8.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-beta-3,,,class generator,,,,0,breaking,,,,,"When you use the @InheritConstructors to pull all the constructors of a super class into a subclass this fails to work when it is used on an Inner Class. Below is an example of code that fails with error:
{noformat}
groovy.lang.GroovyRuntimeException: Could not find matching constructor for: D$F(D, java.lang.Integer)
{noformat}
when you would expect it to run.
{code}
import groovy.transform.InheritConstructors

class A {
    def arg
    A(int arg) {this.arg=arg}
}

@InheritConstructors //add it here just in case that worked!
class D {
    class E extends A {
        E(int arg) {super(arg)}
    }
    @InheritConstructors //this should make class F identical to class E
    class F extends A{}
   
    public test() {
        def test1=new E(1) //Works FINE.
        println test1.arg  // prints 1 as expected  
        def test2=new F(1) //throws GroovyRuntimeException here due to missing constructor.
        println test2.arg
    }
}

def test3=new D()
test3.test()
{code}
",Tested on Fedora and Windows 7. Both show same issue.,owensr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Jan/11 08:56;owensr;innerClassError.groovy;https://issues.apache.org/jira/secure/attachment/12722778/innerClassError.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 22 01:38:32 UTC 2012,,,,,,,,,,"0|i2chiv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jan/11 08:48;owensr;Sorry - typo in description - exception should be:
groovy.lang.GroovyRuntimeException: Could not find matching constructor for: D$F(D, java.lang.Integer)

(The class is D$F no D$E);;;","20/Jan/11 08:56;owensr;Code that pasted in issue, but seems to have lost end-of-lines.
;;;","29/Jun/11 05:55;paulk;add code tags;;;","22/Feb/12 01:06;paulk;This should be working now. For 2.0, part of the logic for handling inner classes (constructor tweaking) was moved until a later phase. AST transforms which add constructors during the SEMANTIC_ANALYSIS or CANONICALIZATION phases can leave handling related to inner class constructors up to the normal compiler phases.;;;","22/Feb/12 01:38;paulk;adding breaking label - shouldn't break user code, nor most transforms but might impact transforms that play with constructors;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
in eachRow's closures rows do not always respond to getClass() ,GROOVY-4632,12816485,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,dariusan,dariusan,19/Jan/11 04:05,04/Jul/13 00:21,14/Jul/23 06:00,04/Jul/13 00:21,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.1.5,,,SQL processing,,,,0,,,,,,"When I try to execute:

{code}
def sqlq = Sql.newInstance(""jdbc:oracle:thin:@${host}:1521:${sid}"", ""user"",
                     ""pw"", ""oracle.jdbc.OracleDriver"")
sqlq.eachRow('select * from dual where rownum<?',[2] ){ row ->
    println (row.getClass())
}
sqlq.close()
{code}

i get:

groovy.lang.MissingMethodException: No signature of method: groovy.sql.GroovyResultSet.getClass() is applicable for argument types: () values: []
Possible solutions: getClass(), metaClass(groovy.lang.Closure), getMetaClass(), getMetaClass(), equals(java.lang.Object), getAt(java.lang.String)


Following code gives:

{code}
def sqlq = Sql.newInstance(""jdbc:oracle:thin:@${host}:1521:${sid}"", ""user"",
                     ""pw"", ""oracle.jdbc.OracleDriver"")
sqlq.eachRow('select * from dual where rownum<?',[2] ){ row ->
    println (row)
}
sqlq.close()
{code}

[DUMMY:X]

I suppose object.getClass() method calls should always work.
",,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 04 00:21:02 UTC 2013,,,,,,,,,,"0|i2cjg7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Feb/13 13:40;pschumacher;Can somebody comment on this? Is this a bug or a feature? Is this related to [GROOVY-5924]?

Thanks!;;;","03/Feb/13 16:48;paulk;Not related to GROOVY-5924;;;","26/Jun/13 17:17;paulk;I'll need to check but perhaps this issue was fixed as part of GROOVY-6187.;;;","04/Jul/13 00:21;paulk;I just ran numerous examples and this is more or less the same as GROOVY-6187, so I am closing it. If you notice anything that doesn't seem right now, please reopen.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE in OptimizingStatementWriter,GROOVY-4630,12815472,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,pniederw,pniederw,18/Jan/11 03:48,29/Jan/11 07:48,14/Jul/23 06:00,29/Jan/11 07:48,1.8-beta-4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-4,,,Compiler,,,,1,,,,,,"With the very latest (but not any earlier) 1.8-beta-4 snapshot, I'm getting the following exception when compiling spock-core (1.8 branch on GitHub). No transforms are involved here.

{noformat}
[10:44:57]: [org.spockframework:spock-core] Caused by: java.lang.NullPointerException
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter$OptVisitor.visitBinaryExpression(OptimizingStatementWriter.java:467)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.ast.CodeVisitorSupport.visitReturnStatement(CodeVisitorSupport.java:73)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitReturnStatement(ClassCodeVisitorSupport.java:210)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter$OptVisitor.visitReturnStatement(OptimizingStatementWriter.java:370)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:47)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter$OptVisitor.visitBlockStatement(OptimizingStatementWriter.java:492)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:69)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1056)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter$OptVisitor.visitClass(OptimizingStatementWriter.java:365)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.setNodeMeta(OptimizingStatementWriter.java:343)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:127)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.control.CompilationUnit$13.call(CompilationUnit.java:754)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:948)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:533)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:511)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:488)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:467)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.gmaven.runtime.v1_7.ClassCompilerFeature$ClassCompilerImpl.compile(ClassCompilerFeature.java:148)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.gmaven.plugin.compile.AbstractCompileMojo.compile(AbstractCompileMojo.java:200)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.gmaven.plugin.compile.AbstractCompileMojo.process(AbstractCompileMojo.java:164)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.gmaven.plugin.ComponentMojoSupport.doExecute(ComponentMojoSupport.java:60)
[10:44:57]: [org.spockframework:spock-core] 	at org.codehaus.gmaven.plugin.MojoSupport.execute(MojoSupport.java:69)
{noformat}",,ldaley,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jan 29 07:48:27 UTC 2011,,,,,,,,,,"0|i2cf9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jan/11 23:44;pniederw;Still getting the same NPE. Problem is caused by BinaryIntExpressionHelper.getType returning null (line 142, meta.type is null). After that, dereferencing ltype in ltype.getComponentType() (OptimizingStatementWriter:467) throws an NPE. Easy to debug by running ""mvn compile"", connecting to JVM, and setting breakpoint for NPE in OptimizingStatementWriter.OptVisitor.;;;","28/Jan/11 02:02;blackdrag;The NPE fix is in my local pipeline, just hadn't had enough time yet to complete what is else in there;;;","28/Jan/11 21:44;ldaley;This seems like it should a @ blocker priority.;;;","29/Jan/11 07:48;blackdrag;should be fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
typo in document comment of Immuable,GROOVY-4628,12815480,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,guillaume,uehaj,uehaj,15/Jan/11 16:38,05/Apr/15 14:44,14/Jul/23 06:00,17/Jan/11 03:06,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.7,1.8-beta-4,,,,,,0,,,,,,{#code BigDecimal} should be {@code BigDecimal} ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"15/Jan/11 16:38;uehaj;patch;https://issues.apache.org/jira/secure/attachment/12722815/patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,2011-01-15 16:38:30.0,,,,,,,,,,"0|i2c0w7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Binding support for group attribute,GROOVY-4627,12816895,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,aalmiray,zoerb,zoerb,13/Jan/11 15:26,22/Dec/12 01:10,14/Jul/23 06:00,11/Dec/12 10:42,1.7.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,Swing,,,,0,,,,,,"Binding classes do not support the ""group"" attribute.  Here's the relevant code (using Griffon):

bindGroup(id: 'formElements')
textField(text: bind(target: model.currentRecord, 'count',
                     value: '0',
                     id: 'countBinding',
                     group: formElements))

When run, produces ""No such property: group for class: groovy.swing.binding.JTextComponentTextBinding"".  From Andres Almiray of Griffon:

""The problem appears to be in BindFactory.groovy:321, where the group: attribute is set on the binding instance, which may or may nor support he property (in this case it does not). this is certainly a bug in BindFactory ...""",,aalmiray,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 05 05:10:45 UTC 2012,,,,,,,,,,"0|i2bv1j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Dec/12 05:10;aalmiray;Pull request @ https://github.com/groovy/groovy-core/pull/79;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Console launched from groovy-all-1.7.6.jar now has ivy dependancy,GROOVY-4626,12815478,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mikevines,mikevines,13/Jan/11 05:23,15/Feb/11 14:35,14/Jul/23 06:00,06/Feb/11 01:22,1.7.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.8,1.8-rc-1,,Groovy Console,,,,1,,,,,,"Previous to 1.7.6, I have been launching a Groovy console in my application by a call to:

groovy.ui.Console.main(new String[0]);

My appliction makes use of the emmbedable grovy-all-1.7.X.jar.

However, in 1.7.6, the console is now dependent on Ivy (through the additional code in the Console constructor).  But the org.apache.ivy classes are not in the grovy-all-1.7.6.jar.

I suggest that either:
- The org.apache.ivy classes are also included in the all jar file
- The dependency is documented (it may be already but I have missed it)
- It is made possible to launch the Console without the dependency","Windoes, but expect it to be cross platform",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"05/Feb/11 01:10;paulk;groovy4626.patch;https://issues.apache.org/jira/secure/attachment/12722726/groovy4626.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Feb 06 01:25:28 UTC 2011,,,,,,,,,,"0|i2bt1r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Feb/11 11:20;mikevines;It would be useful to know your thoughts on this, so I know if it is something that will be addressed in a future Groovy build, or if it is something I need to deal with in my application.

Thanks,
Mike;;;","05/Feb/11 01:10;paulk;Proposed patch attached to remove dependency - if ivy jar not in classpath you won't get ivy notifications - but in that case you wouldn't have any ivy functionality, i.e. no @Grab at all;;;","05/Feb/11 13:43;guillaume;The patch looks elegant to me.;;;","06/Feb/11 01:22;paulk;patch applied;;;","06/Feb/11 01:25;mikevines;Thanks for your comments and continued efforts.

Mike;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
problem compiling @Delegate to an interface that extends another interface,GROOVY-4619,12815473,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,brownj,brownj,05/Jan/11 14:10,08/Feb/11 23:25,14/Jul/23 06:00,02/Feb/11 06:30,1.7.4,1.7.5,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.7,1.8-beta-4,,Compiler,,,,0,,,,,,"The following code compiles with 1.7.3 but fails with 1.7.4, 1.7.5 and 1.8.0-beta-3.

{code:title=SomeInterface.groovy|borderStyle=solid}
interface SomeInterface {
    void doSomething()
}
{code}

{code:title=SomeOtherInterface.groovy|borderStyle=solid}
interface SomeOtherInterface extends SomeInterface {}
{code}

{code:title=SomeClass.groovy|borderStyle=solid}
class SomeClass {
    @Delegate
    SomeOtherInterface someOtherInterface
}
{code}

Compiling with 1.7.3:

{noformat}
 $ groovy -version
Groovy Version: 1.7.3 JVM: 1.6.0_22
 $ groovyc SomeClass.groovy 
 $ 
{noformat}

Compiling with 1.7.4:

{noformat}
 $ groovy -version
Groovy Version: 1.7.4 JVM: 1.6.0_22
 $ groovyc SomeClass.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
SomeClass.groovy: 1: Can't have an abstract method in a non-abstract class. The class 'SomeClass' must be declared abstract or the method 'void doSomething()' must be implemented.
 @ line 1, column 1.
   class SomeClass {
   ^

1 error

 $ 
{noformat}

Compiling with 1.7.5:

{noformat}
 $ groovy -version
Groovy Version: 1.7.5 JVM: 1.6.0_22
 $ groovyc SomeClass.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
SomeClass.groovy: 1: Can't have an abstract method in a non-abstract class. The class 'SomeClass' must be declared abstract or the method 'void doSomething()' must be implemented.
 @ line 1, column 1.
   class SomeClass {
   ^

1 error

 $ 
{noformat}

Compiling with 1.8.0-beta-3:

{noformat}
 $ groovy -version
Groovy Version: 1.8.0-beta-3 JVM: 1.6.0_22
 $ groovyc SomeClass.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
SomeClass.groovy: 1: Can't have an abstract method in a non-abstract class. The class 'SomeClass' must be declared abstract or the method 'void doSomething()' must be implemented.
 @ line 1, column 1.
   class SomeClass {
   ^

1 error

 $ 
{noformat}

This may be related to GROOVY-4163.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"05/Jan/11 21:26;paulk;Groovy4619.patch;https://issues.apache.org/jira/secure/attachment/12722814/Groovy4619.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 01 06:42:00 UTC 2011,,,,,,,,,,"0|i2bmzb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jan/11 21:26;paulk;Proposed patch attached;;;","06/Jan/11 03:20;blackdrag;Assuming I have interface X{void m(); void n();}, interface Y extends X{}, abstract class A implements Y{void m(){}}. And class B{ @Delegate A a}. This this (a) not cause duplicated methods with your patch and (b) does it really add stubs for m and n?;;;","06/Jan/11 04:35;paulk;It seems to add m and n. Certainly Jeff's example passes. It also handled abstract classes without methods. I had already determined that it didn't work for abstract classes with duplicate methods and have some code to stop that but it still isn't good enough for default params where the shorter forms can also be duplicates. I'll tweak it a bit more for that case.;;;","25/Jan/11 05:42;blackdrag;I made it a blocker for the time being as I think this issue should go into the next release and there seems not much work left on it. I suggest that later we set the priority to major again before we close it.;;;","01/Feb/11 06:42;paulk;Looks like the full solution will take some time, so I will leave this issue to fix Jeff's problem and split off the issue when mixing super interfaces with classes having methods with default params.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error when running groovysh with verbose option (-v),GROOVY-4617,12815389,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,eniosp,eniosp,05/Jan/11 03:16,12/Feb/12 04:03,14/Jul/23 06:00,17/Jan/12 08:33,1.7.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,Groovysh,,,,0,,,,,,"When starting groovysh with the verbose option (-v) ""groovy.lang.MissingPropertyException"" is thrown.
See bellow:
**********
C:\>groovysh -v
Groovy Shell (1.7.6, JVM: 1.6.0_07)
Type 'help' or '\h' for help.
-------------------------------------------------------------------------------
groovy:000> a = """"
ERROR groovy.lang.MissingPropertyException:
No such property: buffer for class: org.codehaus.groovy.tools.shell.Groovysh
Possible solutions: buffers, runner
        at java_lang_Runnable$run.call (Unknown Source)
groovy:000>
**********


","Windows 5.1.2600 Service Pack 3 Build 2600
java version ""1.6.0_07""
Groovy Shell 1.7.6",eniosp,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 16 20:42:29 UTC 2012,,,,,,,,,,"0|i2cchj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jan/11 05:48;daniel_sun;C:\Documents and Settings\daniel_sun>groovysh -v
Groovy Shell (1.8.0-beta-2, JVM: 1.6.0_16)
Type 'help' or '\h' for help.


1.8.0-beta-2 works fine.;;;","05/Jan/11 06:23;blackdrag;you tried the a = """" part too?;;;","05/Jan/11 10:26;eniosp;you have to create any variable. a = 1, myName = ""Joe"". anything;;;","16/Jan/12 18:30;jwagenleitner;Same problem also occurs for me on Linux, so not a Windows specific issue (maybe the description should be updated to remove the Windows reference).  Looks some rework in [commit 4cb39a2879491|https://github.com/groovy/groovy-core/commit/4cb39a287949182f5b7156088c48092157b92abc#L0L236] may have caused the issue.  

Based on [this old line|https://github.com/groovy/groovy-core/commit/4cb39a287949182f5b7156088c48092157b92abc#L0L250] 

{code}def source = (imports + [ 'true' ] + buffer).join(NEWLINE){code}

and [this new line|https://github.com/groovy/groovy-core/commit/4cb39a287949182f5b7156088c48092157b92abc#L0R135]

{code}def buff = imports + [ 'true' ] + current{code}

I think the correct variable to reference in the [if (io.verbose)|https://github.com/groovy/groovy-core/commit/4cb39a287949182f5b7156088c48092157b92abc#L0R130] line is {{current}} instead of {{buffer}}.

I've submitted a pull request for this at https://github.com/groovy/groovy-core/pull/15.;;;","16/Jan/12 20:42;paulk;summary updated;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BUG! exception in phase 'conversion' in source unit with NumberFormatException,GROOVY-4615,12815599,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,roshandawrani,roshandawrani,04/Jan/11 23:58,27/Jan/13 07:13,14/Jul/23 06:00,27/Jan/13 07:13,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.6,,,,,,,0,,,,,,"{code}
def upperLong = 0
new UUID(upperLong, 0xC000000000000000L)
{code}

The code above fails with
{noformat}
BUG! exception in phase 'conversion' in source unit 'Script1.groovy' For input string: ""C000000000000000""
Caused by: java.lang.NumberFormatException: For input string: ""C000000000000000""
{noformat}

I put the above code in Java after facing this issue and it worked fine.

If I reduce the size to ""0xC0000000000L"", it works fine.",,blackdrag,pschumacher,roshandawrani,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jan 27 07:13:35 UTC 2013,,,,,,,,,,"0|i2ceef:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jan/13 09:09;blackdrag;seems to be fixed;;;","19/Jan/13 03:01;roshandawrani;Still fails with the same error on http://groovyconsole.appspot.com/, which seems to have Groovy v2.0.0.

Maybe it is fixed on a newer Groovy version, but since ""fix version"" is not indicated, I am not sure.;;;","19/Jan/13 03:28;pschumacher;Works on 2.0.6 and master. I guess [http://groovyconsole.appspot.com/] should be updated.;;;","27/Jan/13 07:13;pschumacher;This works in 2.0.6. Therefore I added this as fix version (the actual fix might have occurred earlier) and closed this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
what does a static outer class declaration mean?,GROOVY-4614,12815421,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,aclement,aclement,04/Jan/11 16:21,08/Feb/11 23:25,14/Jul/23 06:00,03/Feb/11 15:33,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-4,,,,,,,0,,,,,,"I'm not sure what is supposed to happen here - you might just need to clarify what it means and close it....

If I write this

{code}
static class C {
}
{code}

groovyc will compile it.  It will produce (as far as I can tell) a classfile identical to:

{code}
class C {
}
{code}

Does static have some special meaning?  Maybe it should be getting policed? I imagine static has only been supported in that position since inner type support was added.  Doing the same thing in Java shows:

{code}
C.java:1: modifier static not allowed here
static class C {
       ^
1 error
{code}

I could imagine static might have forced singleton behaviour in some way but it doesn't - the generated class still has a constructor, I can write my own constructor, etc.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 03 15:33:37 UTC 2011,,,,,,,,,,"0|i2c6xz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jan/11 02:28;blackdrag;I think it is a bug and there should be a check for the modifier;;;","03/Feb/11 15:33;guillaume;I've added a check to disallow static for outer classes, as this has no meaning.
However, I've committed the fix only in 1.8, as it may be a breaking change (ie. code possibly not compiling anymore) if users used that modifier on some of their classes. Fortunately, the presence or absence of this modifier in that context has no impact whatsoever (it's just that it's useless to use it, but the compiler doesn't treat that in any way).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static import of method with default parameter value broken again: MissingMethodException,GROOVY-4613,12816435,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,avalon,avalon,03/Jan/11 00:28,01/Feb/11 23:31,14/Jul/23 06:00,03/Jan/11 04:17,1.5.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,,,,,,,0,,,,,,"A static method with a default parameter is not found, when it is imported statically and called without prefixing his class:

{code:title=test.groovy}

import static Settings.*
import static ConsoleUI.*

class Settings
{
    static void initialize() {
        writeln(""working"", 100)
        writeln(""failing"")
    }
}

class ConsoleUI
{
    static void writeln(String s, int delay = 0) {
        sleep delay
        println s
    }
}

Settings.initialize()
{code}

Output:
{noformat}
working
Caught: groovy.lang.MissingMethodException: No signature of method: static Settings.writeln() is applicable for argument types: (java.lang.String) values: {""failing""}
	at Settings.initialize(test.groovy:8)
	at test.run(test.groovy:20)
	at test.main(test.groovy)

Exited: 256
{noformat}
","Java 1.6, Ubuntu and Windows XP",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-2746,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 03 04:17:19 UTC 2011,,,,,,,,,,"0|i2crhb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"03/Jan/11 00:32;avalon;This is a clone of GROOVY-2746
I couldn't reopen it and cannot edit this issue any more so I'm writing relevant information in this comment.

Basically the same issue is back in groovy 1.7.5
When I use 1.7.1 I can use a statically imported method with default parameters but with 1.7.5 I need to use the full qualified name /e.g. MyClass.myMethod(x,y,z)/.;;;","03/Jan/11 03:33;paulk;code tags;;;","03/Jan/11 03:38;paulk;The example works fine for me on the 1_7 branch and on trunk. I believe there might have been a regression but think an issue we fixed earlier has resolved the regression.;;;","03/Jan/11 04:17;avalon;Sorry, I didn't notice 1.7.6 is out. I checked with it and static import is working fine in there. Perhaps that's worth a test case...;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyInterceptable (AOP) not working with closures,GROOVY-4610,12815415,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,blusynergy,blusynergy,31/Dec/10 13:55,03/Feb/22 22:34,14/Jul/23 06:00,18/May/21 13:41,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,3.0.9,4.0.0-beta-1,,groovy-runtime,,,,1,,,,,,"I've got a grails app with service classes that implement {{GroovyInterceptable}}: 
{code:groovy}
class customerService implements GroovyInterceptable { 
    private List<Customer> customers 
    def invokeMethod(String name, args) { 
        log.debug ""=======>INVOKING method [$name] with args:$args"" 
    } 
    void foo() { 
        customers.each { doSomething(it) } 
    } 
    void doSomething(Customer cust) {
        log.debug ""doSomething invoked with $cust""
    } 
} 
{code}

If I call foo() or doSomething() *directly* from another class, the invokeMethod gets called like it is supposed to. However, when foo() calls doSomething(), that call is not intercepted in invokeMethod. 

If I change from   
{code:groovy}
customers.each { doSomething(it) }
{code}
  to   
{code:groovy}
for(Customer cust: customers) { doSomething(cust) }
{code}
then the invokeMethod gets called just fine. 

There appears to be an {{ExpandoMetaClass}} bug that prevents closures and {{GroovyInterceptable}} from working together.","JDK 1.6.x, Grails 1.2.1",emilles,moaxcp,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon May 17 15:36:26 UTC 2021,,,,,,,,,,"0|i2c5dj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Sep/17 16:57;moaxcp;Is there a workaround for this issue?;;;","17/May/21 15:36;emilles;https://github.com/apache/groovy/pull/1577;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using log variable created with @Log or @Log4j causes compiler error if used in static method,GROOVY-4609,12815414,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,krush,krush,31/Dec/10 07:43,19/Oct/11 04:04,14/Jul/23 06:00,12/Feb/11 15:34,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-1,1.9-beta-1,,,,,,0,,,,,,"If I have a class with it and use the 'log' variable in a static method I get a compilation error. 


Log4jTest.groovy:
import groovy.util.logging.Log4j

@Log4j
class TestLog4j {

  public static void main(String[] args) {
    log.info ""Hello World""
  }
}

Error Message:
Apparent variable 'log' was found in a static scope but doesn't refer to a local variable, static field or class. Possible causes:
You attempted to reference a variable in the binding or an instance variable from a static context.
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method 'log' but left out brackets in a place not allowed by the grammar. ",,smartini,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 19 04:04:40 UTC 2011,,,,,,,,,,"0|i2c5m7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Dec/10 07:46;krush;I am not sure if this is related but here is a blog that describes the same problem and his attempt to fix. But his fix does not work either (you will get a NPE if you use his).

http://enfranchisedmind.com/blog/posts/with-log-groovy-ast-transform/

;;;","11/Feb/11 09:19;guillaume;The logger injected in the classes is a field, but not a static one, hence why you're seeing this error message.
So should the logger be a static field instead? I think that's the question to ask.;;;","12/Feb/11 05:40;krush;I think it should be static for several reasons. First it is a defacto Java standard to have a static logger variable and I think most Java devs would expect it to be that way. So anyone coming from the Java world would be surprised that it was not static. Secondly, the non-static version does not work in one important use case which is inside the main() function.

Is there any reason for it to *not* be static?;;;","12/Feb/11 06:41;melix;Guillaume, the injected field is static, but the compiler fails before the phase where the field is injected. It fails at semantic analysis where the field is injected at canonicalization. Changing from 
{code}
@GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
public class LogASTTransformation implements ASTTransformation {
{code}

to

{code}
@GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
public class LogASTTransformation implements ASTTransformation {
{code}

solves the problem. I'm not sure why the original transform phase is CANONICALIZATION though.
[update] Changing the phase doesn't break any test. If the phase is important, there should be test cases for that.;;;","12/Feb/11 07:15;guillaume;Yup, I've changed the compile phase and noticed things were fine too.
I haven't added tests yet though.
I'm wondering if there were some reason for the canonicalization phase for being chosen though.;;;","12/Feb/11 07:15;guillaume;So it looks like the Log transformation happens in canonicalization phase, which is after the semantic analysis phase where the static verifier kicks in, and throws the exception you've been seeing.;;;","12/Feb/11 07:15;guillaume;Weird, my comment didn't get through initially... hmmm... the JIRA mysteries...;;;","19/Oct/11 04:04;smartini;Hi all,
sorry but I think the issue is still valid (at least for the @Log annotation, my use case).
I'm using Groovy-1.8.2 (from latest eclipse plugin) and I have the same error described here.
Tell me if you need another ticket (I'm not able to reopen this).

Thanks,
Sandro
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy doesn't correctly check for weaker access privileges when using inheritance,GROOVY-4607,12818026,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,30/Dec/10 20:46,07/Apr/15 19:07,14/Jul/23 06:00,30/Dec/10 23:19,1.7.6,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.7,1.8-beta-4,,,,,,0,,,,,,"The example below is rejected by Java but currently accepted by groovy:
{code}
abstract class Super {
    abstract myMethod()
}
class Child extends Super {
    protected myMethod() { true }
}
new Child()
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-12-30 20:46:04.0,,,,,,,,,,"0|i2cd0f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stub generator doesn't escape double quotes in String annotation values,GROOVY-4604,12815438,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pniederw,pniederw,pniederw,30/Dec/10 08:13,08/Mar/11 09:36,14/Jul/23 06:00,30/Dec/10 08:50,1.7.6,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.7,1.8-beta-4,,Stub generator / Joint compiler,,,,0,,,,,,"{code}
@StringAnn('are you ""really"" sure?')
class Foo {}
{code}

Generated stub looks like this:
{code}
@StringAnn(value=""are you ""really"" sure?"")
public class Foo {}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4601,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-12-30 08:13:11.0,,,,,,,,,,"0|i2c6hj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stub generator doesn't escape strings with mixed single and double quotes,GROOVY-4601,12816211,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,mgryszko,mgryszko,28/Dec/10 13:59,12/Mar/11 00:47,14/Jul/23 06:00,08/Mar/11 10:33,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.9,1.8-rc-2,1.9-beta-1,Compiler,,,,0,,,,,,"Single and double quotes when mixed in Groovy strings within annotations are not translated correctly into Java strings in generated stubs. Internal quotes are not escaped.

This issue is related to GROOVY-4470. I used the same source code to demonstrate it.

{code:title=StringAnno.groovy}
@interface StringAnno {
  String val()
}
{code}

{code:title=StringAnnoUser.groovy}
@StringAnno(val = 'single quote string with ""double quote string""')
class StringAnnoUser {}
{code}


{code:title=StringAnnoUser.java (generated stub)}
import java.lang.*;
import java.io.*;
import java.net.*;
import java.util.*;
import groovy.lang.*;
import groovy.util.*;

@StringAnno(val=""single quote string with ""double quote string"""") public class StringAnnoUser
  extends java.lang.Object  implements
    groovy.lang.GroovyObject {
public StringAnnoUser
() {}
public  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}
public  void setMetaClass(groovy.lang.MetaClass mc) { }
public  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}
public  java.lang.Object getProperty(java.lang.String property) { return null;}
public  void setProperty(java.lang.String property, java.lang.Object value) { }
}
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4470,GROOVY-4604,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 08 10:33:22 UTC 2011,,,,,,,,,,"0|i2c4kv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Mar/11 10:33;guillaume;Added a test for this case.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Exception java.lang.VerifyError ""Expecting to find object/array on stack"" when overriding a notyped method with a typed method",GROOVY-4599,12815431,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,avilches,avilches,27/Dec/10 17:30,16/Feb/11 07:59,14/Jul/23 06:00,16/Feb/11 07:59,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.9,1.8-rc-1,,Compiler,,,,0,,,,,,"This script works fine:
{code:title=|borderStyle=solid}
new Child()
abstract class Super {
    abstract boolean myMethod()
}
class Child extends Super {
    boolean myMethod() { true }
}
{code}

But it fails if I remove the ""boolean"" type to myMethod() in the Super class

{code:title=|borderStyle=solid}
new Child()
abstract class Super {
    abstract myMethod()
}
class Child extends Super {
    boolean myMethod() { true }
}
{code}

And throws

{noformat} 
Caught: java.lang.VerifyError: (class: Child, method: myMethod signature: ()Ljava/lang/Object;) Expecting to find object/array on stack
	at VerifyError.class$(VerifyError.groovy)
	at VerifyError.$get$$class$Child(VerifyError.groovy)
	at VerifyError.run(VerifyError.groovy:2)
{noformat} ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 16 07:59:37 UTC 2011,,,,,,,,,,"0|i2cffz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Feb/11 07:59;blackdrag;the compiler will now prevent this error with a compile time error;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
TestNG classes do not run within groovyConsole,GROOVY-4590,12815437,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,dariusan,dariusan,20/Dec/10 06:44,28/Oct/15 07:07,14/Jul/23 06:00,28/Oct/15 07:07,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Groovy Console,,,,0,,,,,,"Following code:

{code}
import org.testng.annotations.Test;

class A{
    @Test
    void a(){
        println ""hello""
    }

}
{code}

leads to:
{code}
org.testng.TestNGException: 
Cannot find class in classpath: A
{code}

while changing import to:
{code}
import org.junit.Test
{code}

works as expected within groovyConsole and gives:
{code}
hello
JUnit 4 Runner, Tests: 1, Failures: 0, Time: 16
Result: org.junit.runner.Result@a42c89
{code}

Should TestNG classes not also run using groovyConsole?",,jwagenleitner,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 28 07:07:07 UTC 2015,,,,,,,,,,"0|i2ccun:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Dec/10 06:31;guillaume;It doesn't work by default, since we don't bundle TestNG with the distribution.
But I think if you add the TestNG dependency, that should be working.
You can try that out quickly by adding the TestNG JARs in the $GROOVY_HOME/lib.;;;","22/Dec/10 06:12;paulk;Also, adding something like:
{code}
@Grab('org.testng:testng:5.12.1')
{code}
before the import should allow it to work.
It fails for me with the 5.14.5 version of TestNG.
Leaving issue open until this can be investigated.;;;","22/Dec/10 06:13;dariusan;TestNG is in the classpath of groovy! It is only from within the GroovyConsole where it does not run.

If I run it from command line I get:

{code}
D:\>A.groovy
[TestNG] Running:
  Command line suite

hello

===============================================
Command line suite
Total tests run: 1, Failures: 0, Skips: 0
===============================================


D:\>
{code};;;","22/Dec/10 13:54;paulk;Does using the @Grab work?;;;","23/Dec/10 08:40;dariusan;Yes, using @Grab('org.testng:testng:5.12.1') it does work from within the GroovyConsole if TestNG jar is not referenced in groovy-starter.conf

But when I added:
{code}
load D:/lib/*.jar
{code}
in groovy-starter.conf it did not, even though it could resolve the import, it failed to load the class under test A.groovy.;;;","28/Oct/15 05:01;jwagenleitner;I can't reproduce this anymore.  Looks like since 2.x testng is now included in the distribution.  Wonder if this can be resolved?;;;","28/Oct/15 07:07;pascalschumacher;As [~jwagenleitner] can no longer reproduce the problem I'm closing the issue. Thanks for looking into this John. :);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError after int optimizations,GROOVY-4587,12815448,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,melix,melix,17/Dec/10 03:18,27/Dec/10 15:18,14/Jul/23 06:00,27/Dec/10 15:18,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-4,,,,,,,0,,,,,,"The test case attached shows a very small piece of code which triggers a VerifyError.
",,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"17/Dec/10 03:18;melix;Verify_error_with_int.patch;https://issues.apache.org/jira/secure/attachment/12722479/Verify_error_with_int.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 27 15:18:08 UTC 2010,,,,,,,,,,"0|i2bmxb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"17/Dec/10 04:40;melix;This doesn't work either :

{code}
int i = 0
x { i-1 } // java.lang.VerifyError: (class: Script1$_run_closure1, method: doCall signature: (Ljava/lang/Object;)Ljava/lang/Object;) Expecting to find integer on stack
{code}

while this works :

{code}
int i = 0
x { i } // compiles fine
{code};;;","27/Dec/10 15:18;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError with nonstatic category references in static methods,GROOVY-4584,12815403,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jpertino,jpertino,16/Dec/10 09:07,08/Feb/11 23:25,14/Jul/23 06:00,22/Dec/10 05:20,1.7.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.7,1.8-beta-4,,class generator,Compiler,,,0,,,,,,"
when an inner class annotated with @Category is referenced from a static method,
it fails at runtime with a VerifyError

without the @Category annotation it works just fine,
so perhaps its something with the transformation


attached is a simple example","wxp sp3, jdk 1.6.0_20, groovy 1.7.6",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/Dec/10 06:09;paulk;GROOVY4584_staticInnerClasses.patch;https://issues.apache.org/jira/secure/attachment/12722717/GROOVY4584_staticInnerClasses.patch","16/Dec/10 09:07;jpertino;innerCategory.groovy;https://issues.apache.org/jira/secure/attachment/12722713/innerCategory.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Dec 23 22:02:27 UTC 2010,,,,,,,,,,"0|i2c8xz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Dec/10 06:09;paulk;proposed patch attached;;;","22/Dec/10 05:20;paulk;{{InnerClassVisitor}} performed numerous functions including adding some default methods like {{propertyMissing}} to the inner class. This was done before the {{@Category}} transform was run even though this aspect of {{InnerClassVisitor}}'s functionality didn't need to be this early in the compiler phases. The {{@Category}} transform was turning these into static methods which broke the intended functioning of those methods. So {{InnerClassVisitor}} was split into two. Adding the default methods is now done at the end of the {{Canonical}} phase of the compiler.;;;","23/Dec/10 22:02;jpertino;groovy's internals are still obscure to me,
but i imagined something like that might be happening
thanks for the explanation (and the fix of course, latest 1.7.x snapshot is working for me);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
vmplugin throws NPE when trying to throw a GroovyBugException,GROOVY-4580,12815440,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,wirah,wirah,14/Dec/10 05:27,12/Apr/11 13:43,14/Jul/23 06:00,12/Apr/11 13:43,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8-rc-4,,class generator,,,,0,,,,,,"When running unit tests in IntelliJ I regularly get the following stacktrace:
{code}
java.lang.NullPointerException
	at org.codehaus.groovy.vmplugin.v5.Java5.configureType(Java5.java:95)
	at org.codehaus.groovy.vmplugin.v5.Java5.makeClassNode(Java5.java:374)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:320)
	at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:263)
	at org.codehaus.groovy.ast.ClassNode.getInterfaces(ClassNode.java:341)
	at org.codehaus.groovy.ast.ClassNode.declaresInterface(ClassNode.java:929)
	at org.codehaus.groovy.ast.ClassNode.implementsInterface(ClassNode.java:909)
	at org.codehaus.groovy.ast.ClassNode.isDerivedFromGroovyObject(ClassNode.java:899)
	at org.codehaus.groovy.classgen.AsmClassGenerator.isGroovyObject(AsmClassGenerator.java:2741)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitPropertyExpression(AsmClassGenerator.java:2717)
	at org.codehaus.groovy.ast.expr.PropertyExpression.visit(PropertyExpression.java:55)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4111)
	at org.codehaus.groovy.classgen.AsmClassGenerator.makeCallSite(AsmClassGenerator.java:2175)
	at org.codehaus.groovy.classgen.AsmClassGenerator.makeCall(AsmClassGenerator.java:2012)
	at org.codehaus.groovy.classgen.AsmClassGenerator.makeCall(AsmClassGenerator.java:1998)
	at org.codehaus.groovy.classgen.AsmClassGenerator.makeInvokeMethodCall(AsmClassGenerator.java:1981)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:2335)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:72)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4111)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:1458)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:729)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:51)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:616)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:591)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:686)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1039)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:276)
	at org.codehaus.groovy.control.CompilationUnit$11.call(CompilationUnit.java:738)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:932)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:509)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:487)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:464)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:43)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.main(GroovycRunner.java:128)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:75)
{code}
This has already been reported to JetBrains IntelliJ team, as I think the initial bug is theirs, however, there should not be a NullPointerException here, but a GroovyBugException because it can't find the correct type.

The block of code looks like this:
{code}
   83       private ClassNode configureType(Type type) {
   84           if (type instanceof WildcardType) {
   85               return configureWildcardType((WildcardType) type);
   86           } else if (type instanceof ParameterizedType) {
   87               return configureParameterizedType((ParameterizedType) type);
   88           } else if (type instanceof GenericArrayType) {
   89               return configureGenericArray((GenericArrayType) type);
   90           } else if (type instanceof TypeVariable) {
   91               return configureTypeVariableReference((TypeVariable) type);
   92           } else if (type instanceof Class) {
   93               return configureClass((Class) type);
   94           } else {
   95               throw new GroovyBugError(""unknown type: "" + type + "" := "" + type.getClass());
   96           }
   97       }
{code}
on line 95 - I believe that type.getClass() is being called when 'type' is null, hence the NPE.","Ubuntu 10.10, Grails 1.3.6, IntelliJ Idea 10",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 12 13:43:35 UTC 2011,,,,,,,,,,"0|i2cj7b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Apr/11 13:43;blackdrag;The reason of that null value is normallysome generics stuff copied wrong. I made an exception that will say something along these lines, which should be much better than the NPE.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static star ImportNode has invalid constructor?,GROOVY-4578,12815394,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,werdna,werdna,10/Dec/10 17:45,15/Dec/10 16:56,14/Jul/23 06:00,12/Dec/10 05:23,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Compiler,,,,0,,,,,,"I came across something curious in the constructor for static star {{ImportNode}}{color:black}{color}s.  This constructor {{public ImportNode(ClassNode type)}} has the following doc comment:

{code}
    /**
     * Represent a static import of a Class, i.e. import static package.Classname.*
     *
     * @param type the referenced class
     */
{code}

Yet, inside the constructor, {{this.isStatic = false;}}.  This seems like a bug to me since the generated ImportNode is obviously supposed to be static.  Is there something I'm missing here?",,hamletdrc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 12 05:23:52 UTC 2010,,,,,,,,,,"0|i2c85j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Dec/10 05:23;paulk;Yes, that was a copy and paste glitch I suspect. I am not sure groovy-core was affected as static star import nodes were placed in a map anyway and used from there but it should be fixed now in any case.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
null as boolean should be false,GROOVY-4573,12815381,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,codevise,codevise,09/Dec/10 15:50,10/Dec/10 01:58,14/Jul/23 06:00,10/Dec/10 01:58,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,"{code}
def i = null
assert i.asBoolean() == false
{code}

should work as a test case but fails",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 10 01:58:38 UTC 2010,,,,,,,,,,"0|i2crb3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"09/Dec/10 16:39;hamletdrc;this works fine for me with the trunk. ;;;","09/Dec/10 16:46;codevise;Did you try this literally?
Because

null as Boolean

correctly returns false but not

null.asBoolean()

in 1.7.5;;;","10/Dec/10 00:22;hamlet.darcy@canoo.com;I literally copy and pasted your code into groovyConsole in 1.8.3-SNAPSHOT and ran it with no exceptions. 

I agree the code should pass. I was just commenting that it is only broken in the 1.7.5 build and not 1.8. ;;;","10/Dec/10 01:43;codevise;ok, thanks!
So it only needs to be fixed for the 1.7.x branch.;;;","10/Dec/10 01:45;roshandawrani;it already works on 1.7.6-snapshot also - done as part of GROOVY-4443;;;","10/Dec/10 01:58;codevise;already fixed and has been a duplicate to begin with - sorry for the hassle;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@ToString does not work for enum types,GROOVY-4570,12815447,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,hamlet.darcy@canoo.com,hamlet.darcy@canoo.com,09/Dec/10 01:25,21/Jul/11 19:06,14/Jul/23 06:00,06/Jun/11 00:25,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.1,,,Compiler,,,,0,,,,,,"@ToString does not appear to work for enums. This code does not cause a toString method to be generated and it should: 
{code}
@groovy.transform.ToString 
enum MyEnum {
  FOO('foo'), 
  BAR('bar'); 
  String prop
  MyEnum(String p) {prop = p }
}

println MyEnum.FOO.toString()
{code}

THere might be a larger issue with AST Transforms on Enums in general. See thread here: http://groovy.329449.n5.nabble.com/AST-transformations-for-enum-td3295912.html",tested on windows,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 06 00:25:24 UTC 2011,,,,,,,,,,"0|i2cer3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jun/11 00:25;paulk;fixed - should also fix other transforms too;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AST Browser throws exception for enum classes,GROOVY-4569,12815450,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,hamletdrc,hamlet.darcy@canoo.com,hamlet.darcy@canoo.com,09/Dec/10 01:23,10/Nov/11 03:05,14/Jul/23 06:00,10/Nov/11 03:05,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Groovy Console,,,,0,,,,,,"This code produces a stack overflow error in the ast browser of the trunk: 
{code}
enum MyEnum {
  FOO, 
  BAR; 
}
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Dec 09 13:55:29 UTC 2010,,,,,,,,,,"0|i2cnzj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Dec/10 13:55;hamletdrc;fixed in trunk and branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AST browser decompiled source is missing parens for StaticMethodCallExpressions,GROOVY-4567,12815434,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,hamletdrc,hamlet.darcy@canoo.com,hamlet.darcy@canoo.com,08/Dec/10 07:14,15/Dec/10 16:57,14/Jul/23 06:00,08/Dec/10 13:00,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Groovy Console,,,,0,,,,,,"AST browser decompiled source is missing parens for StaticMethodCallExpressions

Check out the toString output for: 
{code}
@groovy.transform.ToString
class Person {
    String firstName, lastName
}{code}

It has this line: 
{code}_result.append(org.codehaus.groovy.runtime.InvokerHelper.toString lastName ){code}



when it should say this: 
{code}_result.append(org.codehaus.groovy.runtime.InvokerHelper.toString(lastName)){code}

I will fix this when I get home. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 08 13:00:10 UTC 2010,,,,,,,,,,"0|i2cq4n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Dec/10 13:00;hamletdrc;fixed in both 1.8 and 1.7.6. However, I don't actually know how to test it in 1.7.6 b/c it is only visible when using the @ToString annotation. It should all work though just in case. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
AbstractASTTransformation should not reference ImmutableASTTransformation,GROOVY-4566,12815383,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,hamletdrc,melix,melix,08/Dec/10 02:42,05/Apr/15 14:44,14/Jul/23 06:00,08/Dec/10 12:09,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-3,,,,,,,0,,,,,,AbstractASTTransformation incorrectly references ImmutableASTTransformation. The provided patch fixes that.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"08/Dec/10 02:42;melix;AbstractASTTransformation_should_not_reference_ImmutableASTTransformation.patch;https://issues.apache.org/jira/secure/attachment/12722709/AbstractASTTransformation_should_not_reference_ImmutableASTTransformation.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Wed Dec 08 12:09:17 UTC 2010,,,,,,,,,,"0|i2bn33:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Dec/10 12:09;hamletdrc;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
VerifyError when debugging Groovy core tests,GROOVY-4561,12815432,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,pniederw,pniederw,05/Dec/10 07:12,10/Dec/10 13:52,14/Jul/23 06:00,10/Dec/10 13:52,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-3,,,Compiler,,,,0,,,,,,"For many test classes in package org.codehaus.groovy.classgen, I get a VerifyError when trying to debug them in IDEA 10. Examples:

org.codehaus.groovy.classgen.ForTest:

{noformat}
java.lang.VerifyError: (class: org/codehaus/groovy/ast/builder/AstBuilderTransformation, method: <clinit> signature: ()V) Attempt to split long or double on the stack
	at java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2389)
	at java.lang.Class.getConstructor0(Class.java:2699)
	at java.lang.Class.newInstance0(Class.java:326)
	at java.lang.Class.newInstance(Class.java:308)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.addPhaseOperationsForGlobalTransforms(ASTTransformationVisitor.java:299)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.doAddGlobalTransforms(ASTTransformationVisitor.java:266)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.addGlobalTransforms(ASTTransformationVisitor.java:187)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.addPhaseOperations(ASTTransformationVisitor.java:150)
	at org.codehaus.groovy.control.CompilationUnit.<init>(CompilationUnit.java:184)
	at org.codehaus.groovy.control.CompilationUnit.<init>(CompilationUnit.java:113)
	at groovy.lang.GroovyClassLoader.createCompilationUnit(GroovyClassLoader.java:480)
	at groovy.lang.GroovyClassLoader.defineClass(GroovyClassLoader.java:177)
	at org.codehaus.groovy.classgen.TestSupport.loadClass(TestSupport.java:96)
	at org.codehaus.groovy.classgen.ForTest.testNonLoop(ForTest.java:73)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at com.intellij.junit3.JUnit3IdeaTestRunner.doRun(JUnit3IdeaTestRunner.java:109)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:65)
{noformat}

org.codehaus.groovy.classgen.CastTest:

{noformat}
Exception in thread ""main"" java.lang.VerifyError: (class: groovy/util/GroovyShellTestCase, method: <clinit> signature: ()V) Attempt to split long or double on the stack
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:169)
	at com.intellij.junit3.TestRunnerUtil.loadTestClass(TestRunnerUtil.java:152)
	at com.intellij.junit3.TestRunnerUtil.createClassOrMethodSuite(TestRunnerUtil.java:105)
	at com.intellij.junit3.TestRunnerUtil.getTestSuite(TestRunnerUtil.java:79)
	at com.intellij.junit3.JUnit3IdeaTestRunner.startRunnerWithArgs(JUnit3IdeaTestRunner.java:41)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:196)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:65)
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 10 13:52:53 UTC 2010,,,,,,,,,,"0|i2chf3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Dec/10 07:56;blackdrag;only when debugging, not normally? Could you check if 21227 and 21179 have the same problem?;;;","05/Dec/10 10:06;pniederw;Yes, only when debugging. Same problem with 21227 and 21179.;;;","05/Dec/10 10:59;blackdrag;but if I got it right, then 21179 is before my big changes, so it is a bit strange, since I would have assumed they are at fault here. Can you test if at least beta2 works?;;;","05/Dec/10 15:27;pniederw;beta-2 doesn't have this problem.;;;","05/Dec/10 15:38;blackdrag;that means between beta2 and 21179... actually another big change was before that... 20947 should be still ok. If I am right, then 20965 introduced that problem. Peter, would you be willing to test once more if 20964 is ok and if 20965 has the problem?

If it is in 20965 it is going to be difficult, since that is a big commit with a huge structual change impossible to find out why it is wrong unless I have some test case;;;","05/Dec/10 16:20;pniederw;Yes, 20965 introduces the problem.;;;","09/Dec/10 04:54;blackdrag;AstBuilderTransform clinit looks like this: {code}
  static <clinit>()V
    LDC 0
    INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.box (J)Ljava/lang/Object;
    CHECKCAST java/lang/Long
    ASTORE 0
    ALOAD 0
    INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.longUnbox (Ljava/lang/Object;)J
    PUTSTATIC org/codehaus/groovy/ast/builder/AstBuilderTransformation.__timeStamp__239_neverHappen1291891067850 : J
    ALOAD 0
    POP
    LDC 1291891067849
    INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.box (J)Ljava/lang/Object;
    CHECKCAST java/lang/Long
    ASTORE 1
    ALOAD 1
    INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.longUnbox (Ljava/lang/Object;)J
    PUTSTATIC org/codehaus/groovy/ast/builder/AstBuilderTransformation.__timeStamp : J
    ALOAD 1
    POP
    RETURN
    RETURN
    NOP
    MAXSTACK = 2
    MAXLOCALS = 2
{code}
In the first two lines there is a 0 const loaded and boxing action for it to get the long... well in fact it is first creating a Long, just to unbox it, but let us ignore that part for a moment. When doing my optimizations I had once the case that the verifier insisted on using LCONST_0 instead of LDC 0. It is one possiblity that this is what is the problem here as well. Besides that, there are no long constants involved, so that should be it.;;;","09/Dec/10 05:24;blackdrag;I changed trunk to use LCONST_0 and LCONST_1 for this, could you please check if trunk has still a problem?;;;","09/Dec/10 13:25;hamletdrc;trunk still has the problem. ;;;","10/Dec/10 08:49;blackdrag;ok, new try... could Peter or Hamlet check again?;;;","10/Dec/10 13:49;hamletdrc;works for me;;;","10/Dec/10 13:52;blackdrag;then I close it as fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong return subtypes of collectEntries{},GROOVY-4555,12815419,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mojojojo,mojojojo,03/Dec/10 10:04,15/Dec/10 22:31,14/Jul/23 06:00,07/Dec/10 03:28,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-3,,,,,,,0,,,,,,"{code}
class A {}
class B {}
Map<A, A> m1
Map<A, B> m2 = m1.collectEntries {
	[new A(), new B()]
}
{code}
As you can see {{m2}} gets assigned a Map<A,B> value, but DefaultGroovyMethods collectEntries says it should be assigned a Map<A,A> value:
{code}
public static <K, V> Map<K, V> collectEntries(Map<K, V> self, Closure closure) {
    return collectEntries(self, createSimilarMap(self), closure);
}
{code}
This bug starts troubles with smart editors like IDEA. Here's a link to related issue on their tracker: http://youtrack.jetbrains.net/issue/IDEA-62245",,mojojojo,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 03 20:17:06 UTC 2010,,,,,,,,,,"0|i2cesf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"03/Dec/10 15:02;blackdrag;So the correct signature would be:

public static <K1, K2, V1, V2> Map<K1, V1> collectEntries(Map<K2, V2> self, Closure closure);;;","03/Dec/10 18:14;paulk;Albeit a bit of a hack, I wonder if this is good enough:
{code}
public static Map collectEntries(Map<?, ?> self, Closure<?> closure)
{code}
;;;","03/Dec/10 20:17;paulk;I have committed these changes to trunk:
{code}
public static Map<?, ?> collectEntries(Map<?, ?> self, Closure<?> closure)

public static <K, V> Map<K, V> collectEntries(Map<?, ?> self, Map<K, V> result, Closure<?> closure)
{code}
I won't close the issue just yet until others have had a chance to review.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JavaStubGenerator doesn't play nicely with package-info.groovy files,GROOVY-4554,12812024,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,02/Dec/10 16:00,22/Apr/20 02:29,14/Jul/23 06:00,22/Apr/20 02:29,1.7.5,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,3.0.4,,,Stub generator / Joint compiler,,,,2,,,,,,It thinks they are a script. It should mostly leave them alone.,,beamerblvd,darxriggs,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 22 02:29:36 UTC 2020,,,,,,,,,,"0|i2ceev:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Feb/11 12:43;rene.scheibe;I also have a problem with package-info files when using Ant.

What works:
- Compiling a package-info.java file with the single javac task generates a package-info.class file.
- Compiling a package-info.groovy file with the single groovyc task generates a package-info.class file.
- Compiling a package-info.groovy file with the joint groovyc + javac task combination generates a package-info.class file.

What doesn't work:
- Compiling a package-info.java file with the joint groovyc + javac task combination does not generate a package-info.class file. I just tells that it compiles a source file but no class file is created. Due to this package-info files are always compiled (even if no sources have been changed) which increases build time.;;;","22/Apr/20 02:27;paulk;[~rene.scheibe] It appears to be a Javac feature to only generate the package-info.class file when annotations are present. You can force creation using the ""-Xpkginfo:always"" flag.;;;","22/Apr/20 02:29;paulk;It is working for the next release of Groovy. It is possibly partially fixed in earlier versions but some recent changes have improved support in this area.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Method Closure.curry() returns raw type,GROOVY-4551,12812028,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mxm-groovy,mxm,02/Dec/10 04:13,17/Jun/15 20:09,14/Jul/23 06:00,04/Dec/10 02:47,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-3,,,groovy-jdk,,,,0,,,,,,Now Closure implements Callable and has type parameter V. But method 'curry' returns raw Closure type and loses information about V.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Dec 04 02:47:31 UTC 2010,,,,,,,,,,"0|i2cd8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Dec/10 06:31;paulk;Added for curry, rcurry and ncurry. No tests yet.;;;","02/Dec/10 06:32;paulk;I think we should also cover closure composition (leftShift and rightShift) but I will create an additional issue for that.;;;","04/Dec/10 02:47;paulk;Tests added in {{ClosureJavaIntegrationTest}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Regression with @Immutable: @Immutable fields not recognised,GROOVY-4550,12815395,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,02/Dec/10 03:02,07/Apr/15 19:06,14/Jul/23 06:00,02/Dec/10 05:38,1.7.5,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-3,,,,,,,0,,,,,,An @Immutable class should be allowed to have fields whose type is annotated with @Immutable. I thought this was working but there doesn't seem to be a relevant unit test. Certainly the intention and JavaDoc was for this to work.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-12-02 03:02:27.0,,,,,,,,,,"0|i2c8un:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Source locations dropped inside of StaticImportVisitor,GROOVY-4549,12815911,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,werdna,werdna,01/Dec/10 18:01,15/Dec/10 16:56,14/Jul/23 06:00,03/Dec/10 08:49,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Compiler,,,,0,,,,,,"Inside the StaticImportVisitor, I would have expected that the PropertyExpressions generated by the visitor contain proper source locations.  There are several places where an existing ConstantExpression or VariableExpression is found to be a reference to a statically imported field.  In this case, a synthetic PropertyExpression is created.  The source location for the synthetic PropertyExpression is set to be the source location for the original Constant/Variable Expression, but the expression returned by PropertyExpression.getExpression() no longer has an sloc.

For example the script:

{code}

import static javax.swing.text.html.HTML.*

NULL_ATTRIBUTE_VALUE
{code}

after the StaticImportVisitor does its magic, the NULL_ATTRIBUTE_VALUE constant expression is converted into HTML.NULL_ATTRIBUTE_VALUE PropertyExpression.  The new PropertyExpression has the same sloc as the original NULL_ATTRIBUTE_VALUE expression, but the contained expressions do not have any slocs.

Note that this may be a problem for StaticMethodCalls as well, but so far I cannot reproduce it.

Proposed solution:

In StaticImportVisitor.java, create method:

{code}
    private void setSourcePosition(Expression toSet, Expression origNode) {
        toSet.setSourcePosition(origNode);
        if (toSet instanceof PropertyExpression) {
            ((PropertyExpression) toSet).getProperty().setSourcePosition(origNode);
        }
    }
{code}

And in this file replace all calls to ASTNode.setSourcePosition(ASTNode) with a call to the new setSourcePosition method.  If the ASTNode toSet is not a property expression, then no change in behavior occurs, but if it is, then slocs are set properly.

I have made this change to Groovy-Eclipse and everything is working fine.  It would be nice to see this contributed back to groovy core.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-12-01 18:01:53.0,,,,,,,,,,"0|i2burz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Field cannot annotate a multiple assignment expression. throws a ClassCastException,GROOVY-4548,12815384,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,hamlet.darcy@canoo.com,hamlet.darcy@canoo.com,01/Dec/10 03:47,15/Dec/10 22:31,14/Jul/23 06:00,02/Dec/10 15:51,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-3,,,,,,,0,,,,,,"@Field cannot annotate a multiple assignment expression. throws a ClassCastException

This was found become because DeclarationExpression.getVariableExpression() was deprecated. 

A failing test case is: 
{code}
@groovy.transform.Field 
def (awe, awe2) = [[1, 2, 3], [1, 2, 3]]

def awesum() { awe.sum() }
assert awesum() == 6
{code}",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Dec 02 15:51:23 UTC 2010,,,,,,,,,,"0|i2ck4n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Dec/10 07:10;paulk;I have removed the ClassCastException with a compile time error saying that the multiple assignment isn't currently supported. We now need to decide if we want to support that form.;;;","01/Dec/10 07:21;hamlet.darcy@canoo.com;Thanks Paul. Is there a reason not to support multiple assignments on @Field? Is it hard to implement?;;;","02/Dec/10 06:29;paulk;It is a little tricky but not impossible. There are arguments for and against. I guess the fact that we don't support such syntax for normal class fields worries me a little. I.e. the following is not currently allowed:
{code}
class Foo {
  def (bar, baz) = [1, 2]
}
{code}
So, in some sense we are providing a backdoor way to write such things for the main script class.;;;","02/Dec/10 08:03;hamlet.darcy@canoo.com;seems reasonable to disallow it then. ;;;","02/Dec/10 15:51;paulk;Let's close it then for now. Someone can always make a strong case for why we should go further.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
A few UI issues in AST Browser,GROOVY-4547,12815653,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,hamletdrc,roshandawrani,roshandawrani,01/Dec/10 00:08,10/Nov/11 03:07,14/Jul/23 06:00,10/Nov/11 03:07,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,ast builder,,,,0,,,,,,"In AST Browser UI, if I change some parameters like Show Script flag (free form/class form) or Compile Phase and then press Refresh

1) There is no proper progress indicator of the work that is happening in the background in the non-UI threads. The hourglass also appears if I move the mouse on the small area that shows the AST tree. In most of the remaining screen, mouse pointer looks normal. A progress indicator is needed.

2) As soon as the refresh is pressed, the tree and property tables can be cleared as they take time to get populated and decompiled data comes up very fast and they look out-of-sync till the whole work is completed.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 03 14:25:07 UTC 2010,,,,,,,,,,"0|i2c10n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Dec/10 00:28;hamlet.darcy@canoo.com;For issue 1 - This is correct behavior... the component that is loading has an hourglass but not the full window. The decompiler runs a lot faster than the tree view, so the decompiler comes up quick and you can work with it. This feature needs to remain in the browser. But you are correct... somehow the Loading message disappeared and we need to put a progress bar or loading tree node back in. 

It would be possible to create a progress bar based on the number of methods in every class in the AST, and then tick the progress bar forward once each time the ScriptToTreeNodeAdapter finds a method. ;;;","01/Dec/10 00:32;roshandawrani;Probably there is no need to come up with some complicated progress bar technique. Just a ""Loading AST"" message will be enough. Right now ""loading"" message is not correctly placed because the decompiler area gets refreshed much faster while most of the work is still going on.

In http://groovyastbrowser.appspot.com/, as soon as refresh is pressed, I clear the AST in the tree and put a root node there that says ""Loading""..may be something like that or a status bar message that remains there till the whole ""refresh"" operation is complete.;;;","01/Dec/10 00:34;roshandawrani;The AST data population in the tree/table is very inconsistent. 9 out of 10 times, it is still remaining empty. I have waited for minutes for the worker threads to ""suddenly"" come :-);;;","01/Dec/10 00:36;roshandawrani;Hamlet, since the AST controls are still not correctly getting populated most of the times, and you are working on it, I am moving the issue to your name.;;;","01/Dec/10 12:39;hamletdrc;fixed in 1.8;;;","03/Dec/10 14:24;hamletdrc;fixing on 1.7 branch;;;","03/Dec/10 14:25;hamletdrc;fixing on 1.7 branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Several bugs with @Category,GROOVY-4546,12816833,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,30/Nov/10 23:02,07/Apr/15 19:06,14/Jul/23 06:00,01/Dec/10 05:52,1.7.5,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"In the following code:
{code}
@Category(Integer)
class MyOps {
  def multiplesUpTo4() { [this * 2, this * 3, this * 4] }
  def multiplesUpTo(num) {
    (2..num).collect{ i -> this * i }
  }
  def alsoMultiplesUpTo(num) {
    def ans = (2..num).collect{ i -> this * i }
    ans
  }
//  def twice() { 
//    def (twice, thrice, quad) = multiplesUpTo4()
//    twice
//  }
}

use(MyOps) {
  println 21.multiplesUpTo4()       // => [42, 63, 84]
  println 21.multiplesUpTo(6)       // => [42, 63, 84, 105, 126]
//  println 21.alsoMultiplesUpTo(6) // (A)
//  println 21.twice()              // (B)
}
{code}
If the line marked (A) is uncommented, then it fails at runtime with
{noformat}
groovy.lang.MissingPropertyException: No such property: i for class: java.lang.Integer
{noformat}
Looking at the transformed code for {{alsoMultiplesUpTo}} as per the AST browser, it is easy to see why we get that error:
{code}
java.lang.Object ans = (2.. num).collect({ java.lang.Object i -> $this * $this.i })
{code}
Meanwhile the code for the nearly identical earlier method {{multiplesUpTo}} is as expected:
{code}
(2.. num).collect({ java.lang.Object i -> $this * i })
{code}
If the ""twice"" method is uncommented, then we get a {{ClassCastException}} at compile time.
Also, if you create the category long hand (i.e. not using the AST transform) both problems go away.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 01 00:47:20 UTC 2010,,,,,,,,,,"0|i2cp7b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Dec/10 00:47;roshandawrani;On issue #1 (MissingPropertyException): while v1 below works, its slight variation v2 does not work.

{code:title=v1 works}
@Category(Integer)
class MyOps {
  def alsoMultiplesUpTo(num) {
       (2..num).collect{ i -> this * i }
  }
}

use(MyOps) {
  assert 21.alsoMultiplesUpTo(6) == [42, 63, 84, 105, 126]
}
{code}

Following fails with ""groovy.lang.MissingPropertyException: No such property: i for class: java.lang.Integer""

{code:title=v2 fails}
@Category(Integer)
class MyOps {
  def alsoMultiplesUpTo(num) {
       def res = (2..num).collect{ i -> this * i }
       res
  }
}

use(MyOps) {
  assert 21.alsoMultiplesUpTo(6) == [42, 63, 84, 105, 126]
}
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Invalid closure name generated when containing method name has spaces,GROOVY-4545,12815426,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,roshandawrani,roshandawrani,30/Nov/10 21:49,15/Dec/10 16:57,14/Jul/23 06:00,30/Nov/10 22:50,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,class generator,,,,0,,,,,,"{code}
import org.junit.Test

class ClosureProblem {
   @Test
   void 'not working'() {
       def cl = { true }
       println cl.class
   }
}
{code}

The above code fails with 
{noformat}
Caught: java.lang.ClassFormatError: Illegal class name ""ClosureProblem$_not working_closure1"" in class file ClosureProblem$_not working_closure1
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 30 22:50:38 UTC 2010,,,,,,,,,,"0|i2bq5r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Nov/10 22:50;roshandawrani;The fix takes care of the closure class name mangling.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Thread.join appears to not work correctly in at least one special case,GROOVY-4534,12815418,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,roshandawrani,rnimz,rnimz,24/Nov/10 14:35,15/Dec/10 16:57,14/Jul/23 06:00,25/Nov/10 08:00,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"While writing test code for a networking component I ran into the following issue. I created a thread to read from a socket, started it and then wrote to a client socket. After writing called thread.join() and expected it to finish executing my server socket thread before continuing. Instead what I get is non-deterministic behavior. Sometimes the thread finishes sometimes not. Since the thread isn't doing much if I add a sleep the code works (my work around in my test code). To be clear I'm not expecting that the print statements execute in any particular order - I'm concerned that the lines won't get added to the list and thus the current thread hasn't actually waited for the spawned thread to exit.

I've attached a sample groovy class that exhibits the problem and the equivalent Java code that does not have the issue.","32 bit Windows XP, Groovy 1.7.5. Also using Eclipse 3.6 + groovy plugin",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"25/Nov/10 03:35;roshandawrani;4534_v17x.diff;https://issues.apache.org/jira/secure/attachment/12722706/4534_v17x.diff","24/Nov/10 14:35;rnimz;JoinProblemG.groovy;https://issues.apache.org/jira/secure/attachment/12722463/JoinProblemG.groovy","24/Nov/10 14:35;rnimz;JoinProblemJ.java;https://issues.apache.org/jira/secure/attachment/12722462/JoinProblemJ.java",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 25 08:00:17 UTC 2010,,,,,,,,,,"0|i2ct1j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"25/Nov/10 03:35;roshandawrani;Attaching a patch for review.

What is causing the non-deterministic behavior in the groovy code is that there are 2 new threads involved (with incorrect one being joined) unlike the Java code, where only 1 gets created.

The closure being passed to socket.accept({...}) is invoked by groovy in a new thread - see http://groovy.codehaus.org/groovy-jdk/java/net/ServerSocket.html#accept(groovy.lang.Closure). That's why doing join() on the thread created by Thread.start {..} does not give the deterministic behavior - because internally a new thread gets created by server.socket({..}) that runs independently of the main thread.

Above mentioned behavior has been there since groovy 1.0, so it can't be changed as it will break existing code.

I am attaching a patch that introduces a new accept() that accepts a boolean flag that tells it whether the closure should be run in a new thread or the calling thread, and it can be used as below for same results as the Java example

{code}
        Thread thread = Thread.start {
// false = don't run in a new thread
            socket.accept(false, { socket ->
.....
.....
                println ""all done""
            })
        }
.....
.....
        thread.join()
{code}

So, the existing socket.accept({..}) continues to run closure in a new thread but this new socket.accept([true|false], {..}) gives the users a choice.;;;","25/Nov/10 04:01;paulk;So, to finish the discussion, the existing method is designed for the case where the server socket would be in its own process. In which case you could use:
{code}
Thread thread = socket.accept { socket -> ... }
{code}
But of course in that case it would typically be running as the main thread and hence join wouldn't be needed.

The proposed patch allows for additional use cases, so +1 from me.;;;","25/Nov/10 04:42;blackdrag;looks good, yes... ;;;","25/Nov/10 08:00;roshandawrani;Done;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyClassLoader script caching not working properly if scripts not in root dir,GROOVY-4529,12812607,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,mrembisz,mrembisz,24/Nov/10 09:53,14/Oct/11 00:28,14/Jul/23 06:00,12/Oct/11 10:04,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.4,1.9-beta-4,,class generator,,,,0,,,,,,"GroovyClassLoader caches class files compiled from scripts not in root dir under keys not matching original name.
{code}
GroovyClassLoader loader = new GroovyClassLoader();
loader.addURL(myScriptRoot);

Class class1, class2;

try {
  class1 = loader.loadClass(""test/script1"");
  class2 = loader.loadClass(""test/script1"");
  assertSame(class1, class2);  // this fails
} catch (ClassNotFoundException e) {
  fail(""Class node found!"");
}
{code}
If I write as above, class is cached by GroovyClassLoader under key ""test.script1"" so looking it up under ""test/script1"" fails. If I try with loader.loadClass(""test.script1"") it will be cached under ""test.test"" which seems even worse.

Is there any workaround other than creating my own cache for compiled classes?

As a fix in the groovy code, we could move the line 
{code}
String className = name.replace('/', '.');
{code}
to the beginning of the loadClass(String, boolean, boolean, boolean) method and using it instead of name in the entire method. GroovyResourceLoader will handle dots fine and className will be proper cache key then.

This would fix looking up scripts with '/' as package separator. It is quite possible this is not recommended way of loading scripts anyway. To fix it for dot separated script paths the problem lies I believe here (GroovyClassLoader):
{code}
    protected Class recompile(URL source, String className, Class oldClass) throws CompilationFailedException, IOException {
        if (source != null) {
            // found a source, compile it if newer
            if ((oldClass != null && isSourceNewer(source, oldClass)) || (oldClass == null)) {
                sourceCache.remove(className);
                return parseClass(source.openStream(), className);
            }
        }
        return oldClass;
    }
{code}
parseClass second argument is fileName and we pass dot-separated className here. I would change it to 
return parseClass(source.openStream(), className.replace('.','/'));",Windows Vista,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"15/Dec/10 04:26;blackdrag;gcl.patch;https://issues.apache.org/jira/secure/attachment/12722768/gcl.patch","11/Oct/11 10:45;mrembisz;test_case_and_fix_for_GROOVY-4529.patch;https://issues.apache.org/jira/secure/attachment/12722525/test_case_and_fix_for_GROOVY-4529.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 11 10:47:10 UTC 2011,,,,,,,,,,"0|i2bw0f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Nov/10 09:56;mrembisz;Ops, sorry for not formatting source properly, I don't use Jira usually.;;;","14/Dec/10 15:14;blackdrag;the normal contract for a ClassLoader is that you give to loadClass a class name. In your case you give a path. But the path is supposed to be added as root in addURL and then you would have had to call loadClass(""script1"") instead. What laodClass does is seeing the ""/"" as part of classname, but later interpreting it as path. This is surely not the best way, but since the method was used wrong form the beginning strange results are not really surprising. 

If you want that, I suggest you use your own subclass of GroovyClassLoader with the path corrected to your liking.;;;","14/Dec/10 15:23;mrembisz;Thanks for your comment. So trying to load script through loadClass(""package.script1"") where ""package"" is dir under script root is also wrong? I have tried it and included such case in my report. It resulted in class with name ""package.script1"" being cached under name ""package.package"".;;;","14/Dec/10 15:31;blackdrag;if the script has a package statement defining it is in a package called ""package"", then it should have been right to load it through ""package.script1"", assuming there is a script1.groovy in a folder package, that is under one of the root folders. ""package.package"" is of course wrong. ive me afew minutes to verify that
;;;","14/Dec/10 15:33;mrembisz;I attach the test case so it's less confusing, sorry for misleading example in the first place:

{code}
GroovyClassLoader loader = new GroovyClassLoader();
loader.addURL(myScriptRoot);

Class class1, class2;

try {
  class1 = loader.loadClass(""test.script1"");
  class2 = loader.loadClass(""test.script1"");
  assertSame(class1, class2);  // this also fails
} catch (ClassNotFoundException e) {
  fail(""Class not found!"");
}
{code}

The second fix in my original post should take care of that I believe. Intentional deny of package prefix when calling scripts would be a pity.;;;","14/Dec/10 15:44;blackdrag;may test showed, that if I put a script named script1 with the package foo into a folder foo in script1.groovy, add the parent of foo to the root urls and then load the script via loadClass(""foo.script1""), then the class is loaded and cached correctly, as the second loading returns the same class.;;;","14/Dec/10 15:45;blackdrag;in other words your test passes for me on trunk;;;","14/Dec/10 15:46;blackdrag;ah wait, there might be a classpath problem and I may have executed the wrong test;;;","14/Dec/10 15:50;blackdrag;nope, all fine;;;","14/Dec/10 16:08;mrembisz;Thank you very much for your time, I'll do some more investigation with trunk. This test passes for me when I do it for a class but fails in case of a script on versions 1.7.1-1.7.5. If it comes up with trunk, I'll prepare and attach proper test case.;;;","14/Dec/10 16:49;blackdrag;ok, just tested with a script and then it fails, so I now can confirm the problem;;;","15/Dec/10 02:51;mrembisz;Reopening the issue then, thanks again. The second part of the original post contains suggested solution.;;;","15/Dec/10 04:16;blackdrag;actually I am going to do a bit more. If the URL is a file I will use parseClass(File) and in case of the text I will add a dummy "".groovy"" at the end.;;;","15/Dec/10 04:26;blackdrag;I attached the fix as patch;;;","15/Dec/10 09:18;blackdrag;sadly the patch does fix the issue at hand, but does break other code. It seems generating that file name is causing a problem here for GroovyScriptEngine;;;","11/Oct/11 10:45;mrembisz;Contains a fix passing all tests and two tests demonstrating the issue. Both problems are related and appear only for scripts (not classes) having non-empty packages. First one affects performance since such scripts are compiled every time they are called. The second one makes using log4j etc annoying since script classes have misleading names.;;;","11/Oct/11 10:47;mrembisz;Patch is against trunk, made today (11 Oct 2011).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovydoc does not work with java 5,GROOVY-4528,12815430,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,adammurdoch,adammurdoch,24/Nov/10 02:59,05/Apr/15 14:44,14/Jul/23 06:00,24/Nov/10 04:06,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,GroovyDoc,,,,0,,,,,,Attached is a patch for this problem.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Nov/10 02:59;adammurdoch;java5.patch;https://issues.apache.org/jira/secure/attachment/12722703/java5.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Wed Nov 24 04:06:07 UTC 2010,,,,,,,,,,"0|i2bq3z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Nov/10 04:06;roshandawrani;Patch applied. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovydoc does not include a super-type which is referenced in the source using a fully-qualified name,GROOVY-4527,12815393,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,adammurdoch,adammurdoch,24/Nov/10 02:57,05/Apr/15 14:44,14/Jul/23 06:00,29/Nov/10 08:59,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,GroovyDoc,,,,0,,,,,,"In the following example, neither {{SuperClass}} or {{Interface}} are included in the groovydoc output for {{SomeClass}}:
{code}
class SomeClass extends some.fully.qualified.SuperClass implements some.fully.qualified.Interface {
}
{code}

Attached is a patch for this. The patch also fixes a NullPointerException introduced in the fix for GROOVY-4514 when a fully-qualified super type name is found in the source.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Nov/10 02:57;adammurdoch;fullyQualifiedNames.patch;https://issues.apache.org/jira/secure/attachment/12722704/fullyQualifiedNames.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Mon Nov 29 08:59:10 UTC 2010,,,,,,,,,,"0|i2brbr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"29/Nov/10 08:59;guillaume;Thank you Adam.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy AntBuilder reset InputHandler when use <groovy> task ,GROOVY-4524,12815377,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,ice,ice,22/Nov/10 12:35,15/Dec/10 16:56,14/Jul/23 06:00,24/Nov/10 13:05,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Ant integration,,,,0,,,,,,When use <groovy> task in ant build file and run ant with custom InputHandler(-inputHandler parameter) all <input> tasks which executed after <groovy> task use DefaultInputHandler for input. The DefaultInputHandler setted in AntBuilder constructor. When I comment it all works fine.,ubuntu linux,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 24 13:05:02 UTC 2010,,,,,,,,,,"0|i2ciyf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Nov/10 13:05;roshandawrani;Looked at some ant sources to confirm and then fixed as suggested here. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Inconsistency between CompilerConfiguration, groovy -c and groovysh ?",GROOVY-4521,12815367,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,gjoseph,gjoseph,22/Nov/10 06:49,15/Dec/10 16:56,14/Jul/23 06:00,24/Nov/10 23:30,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,command line processing,Compiler,Groovysh,,0,,,,,,"Given the following script, saved as {{enc_test.groovy}}
{noformat}
import org.codehaus.groovy.control.CompilerConfiguration
println ""File source encoding is probably set to "" + CompilerConfiguration.DEFAULT.getSourceEncoding()
{noformat}

I would assume all three executions below to print ""UTF-8"", but they don't:
{noformat}
$ groovy -c UTF-8 enc_test.groovy
File source encoding is probably set to MacRoman

$ groovy -Dgroovy.source.encoding=UTF-8 enc_test.groovy
File source encoding is probably set to MacRoman

$ groovysh -Dgroovy.source.encoding=UTF-8
groovy:000> org.codehaus.groovy.control.CompilerConfiguration.DEFAULT.getSourceEncoding()
===> UTF-8
{noformat}

The reason I was printing this info was to track down an encoding issue I had; turns out *the -c flag actually works* for me (i.e my sources are properly decoded) (while the {{-Dgroovy.source.encoding}} option doesn't), but I was looking for a way to ensure my scripts are executed with {{-c UTF-8}}, but the above snippet obviously doesn't help.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 25 06:05:03 UTC 2010,,,,,,,,,,"0|i2cu8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Nov/10 23:30;roshandawrani;The consistency between groovy and groovysh is fixed now.

Source encoding on CompilerConfiguration.DEFAULT is manipulatable using the system property groovy.source.encoding and it now works with both groovy/groovysh as shown below.

{code}
$groovy -Dgroovy.source.encoding=UTF-8 enc_test.groovy
File source encoding is probably set to UTF-8

$groovysh -Dgroovy.source.encoding=UTF-8
groovy:000> org.codehaus.groovy.control.CompilerConfiguration.DEFAULT.getSourceEncoding()
===> UTF-8
{code}

""groovy -c "" allows you to override the CompilerConfiguration that is made-up from system properties. So, it also works correctly (as you already noticed), but it won't modify the source encoding on CompilerConfiguration.DEFAULT configuration.;;;","25/Nov/10 04:37;gjoseph;Sounds good, thanks!

Now is there a safe way to get the current source encoding at runtime? Can I access the CompilerConfiguration instance that was used to compile/execute my script ?;;;","25/Nov/10 06:05;roshandawrani;No, as far as I know, that particular CompilerConfiguration instance is not exposed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java stub generator does not set correct value for annotations that expect a Class as a value,GROOVY-4517,12813838,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,yoelspotts,yoelspotts,19/Nov/10 12:02,05/Apr/15 14:44,14/Jul/23 06:00,23/Nov/10 07:15,1.7.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Compiler,,,,0,,,,,,"This issue is related to http://jira.codehaus.org/browse/GROOVY-4434. 

If an annotation expects a class (not a classname, but a class) as its value, the java stub compiler does not seem to write out the java stub annotation value correctly. Here is some groovy code that shows an example:

<code>
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner
@RunWith(SpringJUnit4ClassRunner.class)
class someClass{
...
}
</code>

The @RunWith annotation expects an actual class (not a class name) as its parameter.

In the above mentioned issue, the annotation value is at least expanded to a fully qualified class name. Using the 1.7.6-SNAPSHOT (which includes the patch from GROOVY-4434), I can confirm the classname is expanded. However, this is the output of the java file the stub compiler creates:

<code>
@org.junit.runner.RunWith(value=org.springframework.test.context.junit4.SpringJUnit4ClassRunner) 
class someClass{
...
}
</code>

The trouble is that then javac chokes since org.springframework.test.context.junit4.SpringJUnit4ClassRunner is not an actual class reference. Interestingly, groovyc handles this same code just fine, but javac expects the .class suffix to make the class reference explicit. Thus, the generated code does not compile. 

I have attached a very simple patch which seems to address this issue. I do not know, however if this might break something else. 
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4354,,,,,,,,,,,,,,,,,"19/Nov/10 12:02;yoelspotts;classannotation.diff;https://issues.apache.org/jira/secure/attachment/12722464/classannotation.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Tue Nov 23 07:15:26 UTC 2010,,,,,,,,,,"0|i2cdkf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Nov/10 05:34;paulk;I don't think your patch will cover all cases but it probably can't hurt - so can probably be easily added.;;;","23/Nov/10 07:15;roshandawrani;Applied the patch. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Delegate does not work with default method parameters,GROOVY-4516,12815655,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,luizzfar,luizzfar,19/Nov/10 11:27,15/Dec/10 16:56,14/Jul/23 06:00,23/Nov/10 11:28,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,class generator,,,,0,,,,,,"Hi!

I am having problems with the following code:

class Del {
public void doSomething(boolean flag = true) {
println flag
}
}

class AClass {
@Delegate Del del = new Del()
}

def a = new AClass()
a.doSomething(true) // works fine
a.doSomething() // methodMissingException

Thank you!",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 23 11:28:42 UTC 2010,,,,,,,,,,"0|i2bmz3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Nov/10 11:28;roshandawrani;Done;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovydoc does not include all the implemented interfaces of a type,GROOVY-4514,12815353,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,adammurdoch,adammurdoch,18/Nov/10 18:17,07/Apr/15 19:13,14/Jul/23 06:00,22/Nov/10 05:57,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,GroovyDoc,,,,0,,,,,,"There are a couple of problems with interface handling in Groovydoc:

* Only the first implemented/extended interface of a Java type is listed
* No implemented/extended interfaces for a Groovy type are listed

Attached is a patch to fix this, along with some test cases. It also fixes a couple of TODO items in the groovydoc test cases.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"18/Nov/10 18:17;adammurdoch;javadoc.patch;https://issues.apache.org/jira/secure/attachment/12722465/javadoc.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Mon Nov 22 05:57:16 UTC 2010,,,,,,,,,,"0|i2bx8n:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Nov/10 05:57;paulk;Patch applied. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Method invocation syntax does not work properly with ComposedClosures,GROOVY-4512,12815409,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,hendersk,hendersk,14/Nov/10 16:34,15/Dec/10 22:31,14/Jul/23 06:00,14/Nov/10 20:43,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-3,,,,,,,0,,,,,,"The problem is with metaprogramming and the ComposedClosure class. Because the ComposedClosure class does not implement the doCall method and the MetaClassImpl.invokeMethod method does not provide any special handling for ComposedClosures as it does for CurriedClosures and MethodClosures, the invocation of the doCall method in the method resolution process will fail. For example:
 
class ComposedTest {
        def closure1 = {}
        def closure2 = {}
        def composed = closure1 >> closure2

}
def inst = new ComposedTest()
 
// This is fine because ComposedClosure implements the call method.
//inst.composed.call()
 
// This fails because ComposedClosure does not implement the doCall method.
inst.composed()",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 14 20:43:15 UTC 2010,,,,,,,,,,"0|i2byu7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Nov/10 20:43;paulk;Fixed. Thanks for reporting the issue!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"NPE during ""record"" command with relative path file name",GROOVY-4510,12815379,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,rareddy,rareddy,09/Nov/10 14:26,15/Dec/10 16:56,14/Jul/23 06:00,23/Nov/10 13:33,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"After starting the interactive shell, I executed 

record start foo.txt

then shell exited with following error message

Exception in thread ""Thread-5"" java.lang.NullPointerException: Cannot invoke method flush() on null object
	at org.codehaus.groovy.runtime.NullObject.invokeMethod(NullObject.java:77)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:45)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.NullCallSite.call(NullCallSite.java:32)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:54)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:121)
	at org.codehaus.groovy.tools.shell.commands.RecordCommand$_closure2.doCall(RecordCommand.groovy:115)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        {lot more stack}",,rareddy,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 23 13:33:32 UTC 2010,,,,,,,,,,"0|i2bt9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Nov/10 13:33;roshandawrani;Done;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect stub code generated for constructor with optional parameters,GROOVY-4508,12815410,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,pniederw,pniederw,07/Nov/10 18:04,15/Dec/10 16:56,14/Jul/23 06:00,24/Nov/10 09:33,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Compiler,,,,0,,,,,,"{code}
class Base {
  Base(String str) {}
}
{code}

{code}
class Derived extends Base {
  Derived(String foo, String bar = ""bar"") {
    super(foo)
  }
} 
{code}

Generated stub has super call in Derived(String, String) body but not in Derived(String) body, resulting in a javac compile error.

{code}
public class Derived
  extends Base  implements
    groovy.lang.GroovyObject {
public Derived
(java.lang.String foo) {}
public Derived
(java.lang.String foo, java.lang.String bar) {
super ((java.lang.String)null);
}
{code}

Tested with Groovy 1.7.5 and GMaven 1.3.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 24 09:33:03 UTC 2010,,,,,,,,,,"0|i2cq2f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Nov/10 09:33;roshandawrani;Done. The constructors now get rendered as
{code}
public Derived
(java.lang.String foo) {
this((java.lang.String)null, (java.lang.String)null);
}
public Derived
(java.lang.String foo, java.lang.String bar) {
super((java.lang.String)null);
}
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Rogue line number for method declarations confuses IDE debuggers,GROOVY-4505,12815405,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,werdna,werdna,05/Nov/10 17:43,15/Dec/10 16:56,14/Jul/23 06:00,29/Nov/10 09:54,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,bytecode,,,,0,,,,,,"Do a javap -l on the following code:

{code}
class Runner {
	public void printit() {
		x(""III"")
		x(""III"")
 	}
}
{code}

and the printit method will look something like this:

{code}
public void printit();
  LineNumberTable: 
   line 2: 4
   line 3: 4
   line 4: 17
  LocalVariableTable: 
   Start  Length  Slot  Name   Signature
   0      31      0    this       LRunner;
{code}

Notice that the LineNumberTable has 3 entries, but the original method has only 2 instruction lines of code.  The first, rogue line number corresponds to the method's block statement.

The problem is that there are 2 entries corresponding to the #4 instruction.  This occasionally confuses the debugger when it is trying to install the breakpoint on a running app (ie- sometimes it works and sometimes it does not).

I tracked the problem down to AsmClassGenerator.visitBlockStatement(), which calls the onLineNumber method and (incorrectly, it seems) adds a line number entry for the start of the block statement.  Simply commenting this line out (line 721 on version 1.7.5) appears to work for me.

Is there any reason why we should not go ahead with the fix?",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 23 15:05:00 UTC 2010,,,,,,,,,,"0|i2c7tr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Nov/10 18:28;guillaume;When visiting a block statetement, it can be nice to not have to go through all the statements when you only need to know when the block start and ends.
For example in the AST viewer, in the Groovy Console, I think you see the whole block highlighted when it's selected, because you've got those line informations for that block.;;;","05/Nov/10 19:01;werdna;As far as I can tell, the behavior in the AST view is no different with or without that extra line number in the class file.  Selecting the method will highlight the entire method.  Selecting the block statement will highlight the first statement in that block.

Also, doesn't the AST viewer work off of the source, and uses the antlr attributes for line numbers?  These line numbers that I am describing only affect things that read the byte code.;;;","06/Nov/10 05:20;guillaume;Indeed, I just tried and it seems the blocks are still correctly highlighted.;;;","23/Nov/10 15:05;werdna;I am re-opening this issue because there is an additional place where rogue line numbers are cropping up.

In AsmClassGenerator.visitTryCatchFinally(), the first statement is onLineNumber(block, ""visitBlockStatement"");

This should be commented out as well.  See GROOVY-892 for this bugs manifestation in Groovy-Eclipse.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy compilation results in warnings in generated code,GROOVY-4504,12815382,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,russel,russel,05/Nov/10 15:18,12/Mar/11 00:47,14/Jul/23 06:00,04/Mar/11 05:54,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.9,1.8-rc-2,1.9-beta-1,,,,,0,,,,,,"The Groovy compilation is creating generated files that contain code that generates warning.  This leads to an impossible situation for those who want warning free compilation.

e.g. from the GPars code:
{code}
/tmp/groovy-generated-2342688056285823602-java-source/groovyx/gpars/dataflow/operator/DataFlowProcessor.java:18: warning: [cast] redundant cast to boolean
protected  boolean shouldBeMultiThreaded(java.util.Map channels) { return (boolean)false;}
{code}","Ubuntu Maverick, OpenJDK, Groovy 1.7.5, Gradle",russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-11-05 15:18:43.0,,,,,,,,,,"0|i2bmrj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
The delete key doesn't work as expected on groovysh on Linux,GROOVY-4503,12812116,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pschumacher,rosenfeld,rosenfeld,04/Nov/10 14:24,05/Apr/15 14:44,14/Jul/23 06:00,22/May/13 11:09,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,Groovysh,,,,0,,,,,,"The delete key is deleting backward instead of forward, simulating the behavior for MacOSX.

Follows patches for jLine for supporting both Linux and MacOSX.",Linux,pschumacher,rosenfeld,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5344,,,,,,,,"04/Nov/10 14:24;rosenfeld;0001-Fix-.jlinebindings.properties-overriding.patch;https://issues.apache.org/jira/secure/attachment/12722701/0001-Fix-.jlinebindings.properties-overriding.patch","04/Nov/10 14:24;rosenfeld;0002-Revert-commit-95730df-fix-behavior-for-the-delete-ke.patch;https://issues.apache.org/jira/secure/attachment/12722467/0002-Revert-commit-95730df-fix-behavior-for-the-delete-ke.patch","04/Nov/10 14:24;rosenfeld;0003-Separate-normal-unix-bindings-from-Mac-OS-bindings.patch;https://issues.apache.org/jira/secure/attachment/12722702/0003-Separate-normal-unix-bindings-from-Mac-OS-bindings.patch",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Wed May 22 11:09:53 UTC 2013,,,,,,,,,,"0|i2c0iv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Nov/10 14:56;guillaume;You've sent the JLine patches to the JLine project too?;;;","04/Nov/10 15:03;rosenfeld;Yes, but the project seems to be dead:

http://sourceforge.net/tracker/?atid=506056&group_id=64033&func=browse
http://sourceforge.net/tracker/?func=detail&aid=3090708&group_id=64033&atid=506056
http://sourceforge.net/tracker/?func=detail&aid=3090685&group_id=64033&atid=506056

The red ones are mine. I've sent the patches to Charles Nutter from JRuby project also, by e-mail.;;;","21/May/13 04:47;pschumacher;Maybe the update to JLine 2.0 fixed this issue? Can somebody check it with the newest snapshot of 2.2? Thanks in advance!;;;","21/May/13 08:29;rosenfeld;Actually, even in 1.8.6 it seems to be working here. I'm using Debian unstable, but it seems this is the same package as stable: groovy-1.8.6-1. 2.0.0~beta2-1 is available on experimental and I may give it a try later, but I guess there won't be any regressions...;;;","21/May/13 08:31;rosenfeld;Yep, it still works on 2.0.0-beta-2. I hope this isn't patched by the Debian team to work this way...;;;","22/May/13 01:57;pschumacher;Thanks for the quick response. :) I do not know if the Debian team patches groovy. Can you check the [2.2-beta-snapshot|http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-binary/2.2.0-SNAPSHOT/groovy-binary-2.2.0-20130522.020809-132.zip] from codehaus?;;;","22/May/13 07:05;rosenfeld;I know jline 1 has my patches, so groovysh is probably fixed since using any jline 1 version after those patches have been commited:

https://github.com/jline/jline/commit/d65234151d3b8fce2233cd4fe6d9821cb4636566
https://github.com/jline/jline/commit/fb81820d61f39fe0b121365c85081eb92c2357a3
https://github.com/jline/jline/commit/3582abca134ace8d1cc351204f70813506ea4a64
https://github.com/jline/jline/commit/be1515737d105bb8fb295be76e5b7e6aef784a68

But since you're now using jline 2, I can't be sure about that... I'll test the version from the link above and will let you know...;;;","22/May/13 07:07;rosenfeld;Just tested the vanilla snapshot. I can confirm the delete key works correctly on groovysh under Debian unstable.;;;","22/May/13 11:09;pschumacher;Thanks your for creating the patches and for testing the snapshot!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Issues with remote closures,GROOVY-4500,12815390,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,ldaley,ldaley,03/Nov/10 06:45,15/Dec/10 16:56,14/Jul/23 06:00,03/Nov/10 10:48,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"The following usages of groovy remote do not work.

{code}
remote.exec { new GregorianCalendar().time = new Date() }
remote.exec { new GregorianCalendar().""$methodName""(new Date()) }
{code}

Both of these constructs cause a NoClassDefFoundError because somehow a reference to the owner class is embedded in the closure.

See: http://permalink.gmane.org/gmane.comp.lang.groovy.user/51193",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-11-03 06:45:10.0,,,,,,,,,,"0|i2cl3r:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Only the root exception in a script is printed ,GROOVY-4498,12815404,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,ldaley,ldaley,02/Nov/10 01:46,21/Jul/11 19:06,14/Jul/23 06:00,15/Jun/11 05:41,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,1.9-beta-1,,,,,2,,,,,,"Can be seen by running the following in a script with the `groovy` command.

{code}
throw new Exception(""root"", new Exception(""cause""))
{code}

",,daniel_henrique,david_beutel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 04 16:50:14 UTC 2010,,,,,,,,,,"0|i2ccwv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Nov/10 04:34;guillaume;May be related to http://jira.codehaus.org/browse/GROOVY-4486?
Which got fixed recently in 17 and trunk.;;;","02/Nov/10 04:48;blackdrag;I can now verify that the cause is not printed. The lines in GroovyMain, that print out the eception most probably simply ignore the cause in that case... which is still a bit strange, since I did see nested exceptions on the command line;;;","04/Nov/10 16:50;david_beutel;You had debug enabled on GROOVY-4486, so GroovyMain:324 did an e.printStackTrace(), unsanitized.  The else after that sanitizes and prints, but not the cause chain.

So, the issue is printing a sanitized cause chain, by default.  Something like this?
{code}
if (!debug) {
    StackTraceUtils.deepSanitize(e)
}
e.printStackTrace()
{code}

GroovyMain filters any file name ending with "".java"", while deepSanitize() filters on a list of packages and configurable tests (and logs the full trace to the StackTrace log, if it has a Handler configured).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"IllegalAccessError when accessing base class property with ""super.propertyName""",GROOVY-4497,12815442,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,pniederw,pniederw,30/Oct/10 20:25,15/Dec/10 16:56,14/Jul/23 06:00,30/Nov/10 00:23,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Compiler,,,,0,,,,,,"The following code...

{code}
class Base {
  def x = 1   
}

class Derived extends Base {
  def x = 2 
  
  def foo() { println super.x }
}

new Derived().foo()
{code}

...produces the exception shown below. Problem goes away if base class declares a field rather than a property, or when derived class uses ""super.getX()"".

{noformat}
java.lang.IllegalAccessError: tried to access field Base.x from class Derived
	at Derived.foo(ConsoleScript6:8)
	at Derived$foo.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
	at ConsoleScript6.run(ConsoleScript6:11)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:264)
	at groovy.lang.GroovyShell.run(GroovyShell.java:513)
	at groovy.lang.GroovyShell.run(GroovyShell.java:170)
	at groovy.lang.GroovyShell$run$0.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:890)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:149)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:276)
	at groovy.lang.Closure.call(Closure.java:271)
	at groovy.lang.Closure.run(Closure.java:354)
	at java.lang.Thread.run(Thread.java:680)
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 30 00:23:35 UTC 2010,,,,,,,,,,"0|i2cjhz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Nov/10 00:23;roshandawrani;If super field is found to be private, ACG does not do a direct field access now and avoids IllegalAccessError.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bug in groovy.util.GroovyScriptEngine isSourceNewer() results in gratuitous recompilations and lost of static state in groovlets,GROOVY-4492,12812602,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,timur,timur,28/Oct/10 07:33,15/Dec/10 16:57,14/Jul/23 06:00,29/Oct/10 01:47,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Groovlet / GSP,,,,0,,,,,,"isSourceNewer() method in groovy.util.GroovyScriptEngine does evaluate script sources for recompilation (it will return true) in cases where 'nextPossibleRecompilationTime >= lastMod'. This is wrong and results in gratuitous recompilations of scripts.

An ugly side effect of this bug is, that groovlet state (static objects kept in a static class) is being lost between incoming requests, due to gratuitous recompilation and subsequent restart of groovlets.

The attached patch fixes the issue.
",Bug is independent of OS and JVM. I'm running Ubuntu 10.10 with OpenJDK 1.6.0_18.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Oct/10 18:50;timur;patchfile-all3.txt;https://issues.apache.org/jira/secure/attachment/12722748/patchfile-all3.txt","28/Oct/10 07:33;timur;patchfile.txt;https://issues.apache.org/jira/secure/attachment/12722696/patchfile.txt","28/Oct/10 15:54;timur;patchfile2.txt;https://issues.apache.org/jira/secure/attachment/12722459/patchfile2.txt","28/Oct/10 18:50;timur;patchfile3.txt;https://issues.apache.org/jira/secure/attachment/12722747/patchfile3.txt",,,,,4.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 29 01:30:05 UTC 2010,,,,,,,,,,"0|i2cp4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Oct/10 10:46;guillaume;Running the two related GroovyScriptEngine (GSE for short) tests make one fail.
You can try running them with
{code}
ant -DtestCase=groovy.util.GroovyScriptEngineTest test
ant -DtestCase=groovy.util.GroovyScriptEngineReloadingTest test
{code}
That's GroovyScriptEngineTest which is failing here with your patch.
Any idea why the test is failing?
{code}

    [junit] Testcase: testReloadingInterval(groovy.util.GroovyScriptEngineTest):	FAILED
    [junit] assert gse.run(scriptName, binding) == 12
    [junit]        |   |   |           |        |
    [junit]        |   1   |           |        false
    [junit]        |       |           groovy.lang.Binding@23b17d49
    [junit]        |       gse4241425475617288650.groovy
    [junit]        groovy.util.GroovyScriptEngine@599855ed
    [junit] junit.framework.AssertionFailedError: assert gse.run(scriptName, binding) == 12
    [junit]        |   |   |           |        |
    [junit]        |   1   |           |        false
    [junit]        |       |           groovy.lang.Binding@23b17d49
    [junit]        |       gse4241425475617288650.groovy
    [junit]        groovy.util.GroovyScriptEngine@599855ed
    [junit] 	at org.codehaus.groovy.runtime.InvokerHelper.assertFailed(InvokerHelper.java:386)
    [junit] 	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.assertFailed(ScriptBytecodeAdapter.java:658)
    [junit] 	at groovy.util.GroovyScriptEngineTest.testReloadingInterval(GroovyScriptEngineTest.groovy:245)
    [junit] 
{code}
Perhaps in some cases the logic was reloading the class too often... but in this case, the reloading should have happened, but has not with the patch applied.;;;","28/Oct/10 15:53;timur;Well well well.. this is a completely different bug. The issue here is that URLConnection.getLastModified() truncates up to 999 ms from the time value when the file was originally modified. This is how it works: 

  Date.parse(getHeaderField(""last-modified""));

In other words: getLastModified() works based on seconds, not ms. 

What the test case is falling over: Because of the issue with getLastModified(), the value of lastMod may appear up to 999 ms OLDER than it really is. And so, it may look as if nextPossibleRecompilationTime is not yet due. While in reallity it is! 

To fix this, I propose to adjust the value of lastMod in the following way:

            lastMod = ((lastMod /1000)+1)*1000-1;

I'm attaching a 2nd patch relative to my other patch.
;;;","28/Oct/10 18:50;timur;You will notice that there is still an issue with the code. This is really a separate problem, that is preventing patchfile1 + patchfile2 from working in some cases.

This remaining 3rd issue is that we want to accept re-compilation of a script only

if(depEntry.lastModified < lastMod)

(that is: if the cached version is older than the script in the filesystem)

and not

if(nextPossibleRecompilationTime < lastMod)

I am attaching patchfile3.txt to solve this. I'm also attaching a combined patchfile-all3.txt.
Thank you.
;;;","29/Oct/10 01:30;guillaume;Well spotted for the last modified stuff! I've spent a moment on the logic of this method, but never really thought about how the last modification was really computed, which makes the granularity up to a second. Interesting.
The ""all"" patch works fine for me, thanks a lot.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Generics compilation error occurs when using less then (<) operator,GROOVY-4489,12812641,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,asandor,asandor,25/Oct/10 03:00,02/May/21 09:22,14/Jul/23 06:00,02/Mar/21 21:43,1.7.4,1.7.5,2.4.3,2.5.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,3.0.4,,,Compiler,,,,0,,,,,,"The following code is throwing a compilation error (the strange code is a DSL):
{code}
def FloatComparison() {
    when:
    o.PROPerty1 < o.PROPerty2
    
    then:
    result = true
}

Missing closing bracket '>' for generics types;
   solution: Please specify the missing bracket! at line: 5, column: 5
{code}

Here are some snippets that don't produce this error:
{code}
def FloatComparison() {
    when:
    o.pROPerty1 < o.PROPerty2 //the first letter of the first variable is lowercase
    
    then:
    result = true
}
{code}

{code}
def FloatComparison() {
    when:
    o.PROPerty1 < o.PROPerty2
    
//the label is removed and .x is added after result (without .x the exception occurs)
    result.x = true
}
{code}

Looking at the samples that work, this whole mess doesn't make any sense. It seems like a minor but very annoying bug in the compiler. We are working on a DSL, so we can't influence the names of the properties or anything significant that would be a proper workaround.

(This is technically not a JUnit test case, but I think it's enough because it can be simply copied into the Groovy console and run)",,aalmiray,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 29 08:34:33 UTC 2020,,,,,,,,,,"0|i2c0pj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"26/Aug/18 03:08;paulk;This still happens in 2.5.2 but doesn't happen in the parrot parser.;;;","27/Jun/20 08:03;aalmiray;This no longer fails in 2.5.5 and 3.0.4.

Verified at Hack.Commit.Push 2020;;;","29/Jun/20 08:34;paulk;I agree with 3.0.4 (as expected) but still get failures for the first example in 2.5.5 and 2.5.12.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
No stacktrace or message for exceptions in the main constructor,GROOVY-4486,12815365,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,ripper234,ripper234,21/Oct/10 04:19,09/Nov/11 05:21,14/Jul/23 06:00,09/Nov/11 05:21,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8.0,,,,,,0,,,,,,"This script should generate a complete stacktrace including the call to ""doSomething()"" and the message, but it only writes ""This script or class was runnable but cold not be run.""

{code}
public class Foo implements Runnable
{
  public Foo()
  {
     doSomething();
  }

  public void run()
  {
     println(""B"");
  }

  public doSomething()
  {
     println(""A"");
     throw new Exception(""A specific Error Message"");
  }
}
{code}
",windows,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 25 15:56:27 UTC 2010,,,,,,,,,,"0|i2cm73:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"21/Oct/10 04:48;blackdrag;with debug output enabled I get this:{code}
Caught: groovy.lang.GroovyRuntimeException: This script or class was runnable but could not be run. 
groovy.lang.GroovyRuntimeException: This script or class was runnable but could not be run. 
	at groovy.lang.GroovyShell.runRunnable(GroovyShell.java:331)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:275)
	at groovy.lang.GroovyShell.run(GroovyShell.java:227)
	at groovy.lang.GroovyShell.run(GroovyShell.java:157)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:514)
	at groovy.ui.GroovyMain.run(GroovyMain.java:329)
	at groovy.ui.GroovyMain.process(GroovyMain.java:315)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:112)
	at groovy.ui.GroovyMain.main(GroovyMain.java:93)
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:530)
	at groovy.lang.GroovyShell.runRunnable(GroovyShell.java:320)
	... 8 more
Caused by: java.lang.Exception: A specific Error Message
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:530)
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:77)
	at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:54)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:190)
	at Foo.doSomething(test.groovy:189)
	at Foo$doSomething.callCurrent(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:46)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:133)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:137)
	at Foo.<init>(test.groovy:178)
	... 13 more
{code};;;","21/Oct/10 04:50;blackdrag;the InvocationTargetException needs to be replaced in org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:102) or else Groovy's error reporting will not work properly;;;","21/Oct/10 04:57;blackdrag;ok, wrong... It should be in CachedConstructor:77 (the line above) and there is already code for that.;;;","21/Oct/10 05:41;blackdrag;and since there is already code for that it is not the place of problem.

In fact we have a Runnable here, so groovy first creates and instance of this class and then executed the run method. Since the instance creation fails it is in GroovyShell, where the InvocationTargetException is created. So the place is in fact GroovyShell:323;;;","21/Oct/10 09:37;blackdrag;it is actually not so easy to write a test case for this... Ron, can you explain again, when exactly this happens? It is when executing Groovy from the command line using the groovy command, is it?;;;","21/Oct/10 12:06;ripper234;Yes, I ran Groovy from the command line on the script I attached.;;;","25/Oct/10 15:56;blackdrag;fixed... if only bamboo would be happy... still I close it now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
enum does not support default map constructors,GROOVY-4485,12815388,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ddurham,ddurham,20/Oct/10 09:40,10/Jul/13 04:42,14/Jul/23 06:00,30/Mar/13 03:10,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,,,,,2,,,,,,"This enum should compile, but it does not.

{code}
enum ExportFormat {

    EXCEL_OOXML(mime: ""application/vnd.ms-excel"", extension: ""xlsx""),
    EXCEL_BINARY(mime: ""application/vnd.ms-excel"", extension: ""xls""),
    EXCEL_HTML(mime: ""application/vnd.ms-excel"", extension: ""xls"")
    
    String mime
    String extension

}
{code}",should not matter,paulk,poundex,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4568,,GROOVY-4582,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Mar 30 03:10:57 UTC 2013,,,,,,,,,,"0|i2cmzb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Oct/10 09:45;roshandawrani;Added format tags;;;","20/Oct/10 09:49;roshandawrani;Error on 1.8.x and 1.7.x:

{noformat}
Caught: BUG! exception in phase 'class generation' in source unit 'D:\Roshan\GroovyDevSetup\Workspace17x\TryGroovy\src\TryGroovy.groovy' MapEntryExpression should not be visited here
{noformat}
;;;","18/Apr/11 16:41;paulk;Still not supported, but just noting that currently a better error message is produced.
{noformat}
The usage of a map entry expression to initialize an Enum is currently not supported, please use an explicit map instead.
{noformat}
;;;","30/Mar/13 03:10;paulk;support added for 2.2.0, no need for the above mentioned error message - thanks for raising the issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
changelist 20965 Broke AST Browser in Groovy Console,GROOVY-4484,12811578,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,hamletdrc,hamletdrc,20/Oct/10 06:36,21/Oct/10 04:31,14/Jul/23 06:00,21/Oct/10 04:31,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-3,,,,,,,0,,,,,,"changelist 20965 Broke AST Browser in Groovy Console

Open up groovyConsole, write some code in window and press Ctrl+T
You get an exception about cannot cast JComboBox to groovy Reference. 

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 21 04:31:10 UTC 2010,,,,,,,,,,"0|i2cthr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Oct/10 10:46;blackdrag;looks like the problem can be reduced to this:{code:Java}
import groovy.swing.SwingBuilder

        swing = new SwingBuilder()
        def phasePicker
        
        swing.frame {
                phasePicker = comboBox(actionPerformed: {phasePicker})
        }
{code};;;","20/Oct/10 10:47;blackdrag;I tried to get someting wihout swingBuilder, but no success so far. Also the assignment seems to be required;;;","20/Oct/10 12:25;roshandawrani;Here is how to simulate it in plain terms - no SwingBuilder now

{code}
def phasePicker

def c = {
    phasePicker = foo(bar: {phasePicker})
}

Dummy foo(arg){new Dummy()}

class Dummy{}

c()
{code};;;","21/Oct/10 04:31;blackdrag;I fixed the issue and added a test case (thanks Roshan for providing the test);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closure.memoize fails on Google App Engine,GROOVY-4482,12815362,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,tim_yates,tim_yates,18/Oct/10 09:46,15/Dec/10 22:31,14/Jul/23 06:00,24/Nov/10 10:40,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-3,,,groovy-jdk,,,,0,,,,,,"Running the following code on the Groovy Web Console:

{code}
cl = {a, b ->
    sleep(3000) // simulate some time consuming processing
    a + b
}
mem = cl.memoize()

def callClosure(a, b) {
    def start = System.currentTimeMillis()

    mem(a, b)

    println ""Inputs(a = $a, b = $b) - took ${System.currentTimeMillis() - start} msecs.""
}

callClosure(1, 2)
callClosure(1, 2)
callClosure(2, 3)
callClosure(2, 3)
callClosure(3, 4)
callClosure(3, 4)

callClosure(1, 2)
callClosure(2, 3)
callClosure(3, 4)
{code}
(taken from http://roshandawrani.wordpress.com/2010/10/18/groovy-new-feature-closures-can-now-memorize-their-results/)

Throws the following exception (when caught and printed to stdout)

{code}
java.security.AccessControlException: access denied (java.lang.RuntimePermission accessDeclaredMembers)
	at com.google.appengine.runtime.Request.process-<unknown>(Request.java)
	at java.security.AccessControlContext.checkPermission(AccessControlContext.java:355)
	at java.security.AccessController.checkPermission(AccessController.java:567)
	at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)
	at java.lang.SecurityManager.checkMemberAccess(SecurityManager.java:1679)
	at java.lang.Class.checkMemberAccess(Class.java:2174)
	at java.lang.Class.getDeclaredMethods(Class.java:1807)
	at java.lang.Class.getEnclosingMethod(Class.java:919)
	at sun.reflect.generics.scope.ClassScope.computeEnclosingScope(ClassScope.java:50)
	at sun.reflect.generics.scope.AbstractScope.getEnclosingScope(AbstractScope.java:74)
	at sun.reflect.generics.scope.AbstractScope.lookup(AbstractScope.java:90)
	at sun.reflect.generics.factory.CoreReflectionFactory.findTypeVariable(CoreReflectionFactory.java:109)
	at sun.reflect.generics.visitor.Reifier.visitTypeVariableSignature(Reifier.java:165)
	at sun.reflect.generics.tree.TypeVariableSignature.accept(TypeVariableSignature.java:43)
	at sun.reflect.generics.visitor.Reifier.reifyTypeArguments(Reifier.java:68)
	at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:138)
	at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)
	at sun.reflect.generics.repository.ClassRepository.getSuperclass(ClassRepository.java:84)
	at java.lang.Class.getGenericSuperclass(Class.java:694)
	at com.sun.beans.TypeResolver.prepare(TypeResolver.java:274)
	at com.sun.beans.TypeResolver.<init>(TypeResolver.java:243)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:172)
	at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:93)
	at java.beans.FeatureDescriptor.getParameterTypes(FeatureDescriptor.java:385)
	at java.beans.MethodDescriptor.setMethod(MethodDescriptor.java:116)
	at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:74)
	at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:58)
	at java.beans.Introspector.getTargetMethodInfo(Introspector.java:1181)
	at java.beans.Introspector.getBeanInfo(Introspector.java:408)
	at java.beans.Introspector.getBeanInfo(Introspector.java:180)
	at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:2937)
	at java.security.AccessController.doPrivileged(AccessController.java:63)
	at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:2935)
	at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:2918)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:166)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:182)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:214)
	at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:751)
	at groovy.lang.GroovyObjectSupport.<init>(GroovyObjectSupport.java:32)
	at groovy.lang.Closure.<init>(Closure.java:106)
	at groovy.lang.Closure.<init>(Closure.java:117)
	at org.codehaus.groovy.runtime.memoize.Memoize$1.<init>(Memoize.java:55)
	at org.codehaus.groovy.runtime.memoize.Memoize.buildMemoizeFunction(Memoize.java:55)
	at groovy.lang.Closure.memoize(Closure.java:530)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:43)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:39)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
	at Script1.run(Script1.groovy:7)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:576)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:614)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:585)
	at groovy.lang.GroovyShell$evaluate.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
	at executor.run(executor.groovy:25)
	at groovy.util.GroovyScriptEngine.run(GroovyScriptEngine.java:515)
	at groovy.servlet.GroovyServlet$1.call(GroovyServlet.java:120)
	at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.use(GroovyCategorySupport.java:99)
	at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.access$300(GroovyCategorySupport.java:61)
	at org.codehaus.groovy.runtime.GroovyCategorySupport.use(GroovyCategorySupport.java:239)
	at groovy.servlet.GroovyServlet.service(GroovyServlet.java:129)
	at groovyx.gaelyk.GaelykServlet.super$5$service(GaelykServlet.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:43)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1055)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.invokeMethodOnSuperN(ScriptBytecodeAdapter.java:127)
	at groovyx.gaelyk.GaelykServlet$_service_closure1.doCall(GaelykServlet.groovy:68)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:43)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:149)
	at groovyx.gaelyk.GaelykServlet$_service_closure1.doCall(GaelykServlet.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:43)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:885)
	at groovy.lang.Closure.call(Closure.java:288)
	at groovy.lang.Closure.call(Closure.java:282)
	at org.codehaus.groovy.runtime.GroovyCategorySupport$ThreadCategoryInfo.use(GroovyCategorySupport.java:111)
	at org.codehaus.groovy.runtime.GroovyCategorySupport.use(GroovyCategorySupport.java:250)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.use(DefaultGroovyMethods.java:415)
	at org.codehaus.groovy.runtime.dgm$740.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoMetaMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:307)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:51)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:153)
	at groovyx.gaelyk.GaelykServlet.service(GaelykServlet.groovy:67)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:806)
	at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:511)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:43)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoCachedMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:229)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:128)
	at groovyx.gaelyk.routes.RoutesFilter.doFilter(RoutesFilter.groovy:156)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)
	at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:388)
	at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)
	at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:182)
	at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:765)
	at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:418)
	at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)
	at org.mortbay.jetty.Server.handle(Server.java:326)
	at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542)
	at org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:923)
	at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)
	at com.google.net.rpc.impl.BlockingApplicationHandler.handleRequest(BlockingApplicationHandler.java:24)
	at com.google.net.rpc.impl.RpcUtil.runRpcInApplication(RpcUtil.java:418)
	at com.google.net.rpc.impl.Server$RpcTask.runInContext(Server.java:572)
	at com.google.tracing.TraceContext$TraceContextRunnable$1.run(TraceContext.java:448)
	at com.google.tracing.TraceContext.runInContext(TraceContext.java:688)
	at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContextNoUnref(TraceContext.java:326)
	at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContext(TraceContext.java:318)
	at com.google.tracing.TraceContext$TraceContextRunnable.run(TraceContext.java:446)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)
	at java.lang.Thread.run(Thread.java:636)
{code}

Seems to go bang when {{GroovyObjectSupport}} calls {{InvokerHelper.getMetaClass}} in the constructor on line 32",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"19/Oct/10 05:10;roshandawrani;Memoize_on_GAE.patch;https://issues.apache.org/jira/secure/attachment/12722588/Memoize_on_GAE.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 24 10:40:32 UTC 2010,,,,,,,,,,"0|i2cn5r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Oct/10 05:08;roshandawrani;Attaching a patch that has the workaround for making memoize() work on google app engine.

The {{java.lang.RuntimePermission accessDeclaredMembers}} permission check was failing at the following place in OpenJDK VM:

{code:title=java.lang.SecurityManager}
    if (which != Member.PUBLIC) {
        Class stack[] = getClassContext();
        /*
         * stack depth of 4 should be the caller of one of the
         * methods in java.lang.Class that invoke checkMember
         * access. The stack should look like:
         *
         * someCaller                        [3]
         * java.lang.Class.someReflectionAPI [2]
         * java.lang.Class.checkMemberAccess [1]
         * SecurityManager.checkMemberAccess [0]
         *
         */
        if ((stack.length<4) ||
            (stack[3].getClassLoader() != clazz.getClassLoader())) {
            checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
        }
    }
{code}

The {{clazz}} here was the anonymous inner class used in {{Memoize.buildMemoizeFunction()}} and {{Memoize.buildSoftReferenceMemoizeFunction()}} calls and the JVM was bombing at the above permission check when initializing the metaclass of the AIC because of the classloader that was loading the AIC.

So, a potential workaround was to make a change that will influence the class loader that loads the inner classes needed by Memoize() - because everywhere else, the initializing of metaclasses had no issues. 

That's what the patch does - by converting the anonymous inner classes into non-anonymous inner classes, so they get loaded before {{buildMemoizeFunction()}} and {{buildSoftReferenceMemoizeFunction()}} try creating their instances.

I am no classloader expert and I have no way of proving the above on GAE, but that was the reasoning I went by and the change made makes memoize() functions work - I have deployed the patched version on my local copy of groovy webconsole - http://roshandawrani.appspot.com/, where it can be checked out;;;","19/Oct/10 05:10;roshandawrani;Sorry - attached the wrong patch earlier.;;;","19/Oct/10 07:15;roshandawrani;Why exactly is the issue assigned to Guillaume with no comments on the fix? 

Should I take it as that I am not to do any commits now? 

If that is the case, someone should have had the courtesy to say so. 

Else, it is the rudest thing I saw!;;;","19/Oct/10 07:38;blackdrag;sorry Roshan, I did not intend to be rude. You commented your patch in a way that sounded as if you are not sure it will fix the problem, so I assigned it to Guillaume, since he can actually test it. He is on the road, otherwise I would not have done it in JIRA.

If on the other hand you think that will fix the issue for sure, then feel free to commit.;;;","19/Oct/10 07:49;roshandawrani;It is something that is absolutely not locally reproducible and absolutely not debuggable on GAE at that deep level in JVM. So, a bit of ""workaround"" flavor to it! It's not a straight-forward thing to fix anyway. More of troubleshooting.

I even deployed a copy of groovy webconsole under my own google app engine account to demonstrate that it works - not sure why should you think that the it has not fixed the issue. It can be tested at http://roshandawrani.appspot.com/ right away, if anyone wants to. I even tweeted(where it was reported) asking people to test it. Anything more I should have done?

The only help I later need is that when groovy has my fix, the patched version will need to be deployed to official webconsole because I don't have the rights to do that.;;;","19/Oct/10 08:07;blackdrag;ah, ok, then I did misread something in an earlier comment. Fell free to commit and close the issue then;;;","19/Oct/10 08:11;roshandawrani;I will commit the fix (since you don't have any comments on the patch, as such)

But we will close the issue after the groovy web console app is deployed with the patched groovy and it is verified there. I guess that will need to wait for Guillaume - or do you have the rights to do that?;;;","19/Oct/10 12:48;roshandawrani;Patch applied. To be verified on webconsole once it has the patched groovy.;;;","23/Nov/10 11:31;roshandawrani;Its verification has been pending for quite some time now. 

Can the latest groovy (trunk) be pushed to groovy web console?;;;","23/Nov/10 15:55;guillaume;Sorry Roshan for that, this has slipped somehow, I'll try and have a look tomorrow.
And ping me on IM if ever I forget again :-);;;","24/Nov/10 10:40;guillaume;Groovy Web Console updated!
I had some other changes I had in parallel and had not finished them and didn't want to upgrade till I was fully done, but that's now okay.
And memoize does work fine now.
Well done and thank you!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MetaClassRegistry listener isn't triggered and iterator is not returning updated MCs,GROOVY-4481,12815375,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,guillaume,guillaume,16/Oct/10 11:20,15/Dec/10 16:57,14/Jul/23 06:00,29/Oct/10 15:04,1.7.5,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-10-16 11:20:44.0,,,,,,,,,,"0|i2cm07:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Parsing seems to have changed in 1.8,GROOVY-4480,12815345,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,tim_yates,tim_yates,15/Oct/10 08:56,08/Mar/11 09:13,14/Jul/23 06:00,08/Mar/11 09:13,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-rc-2,1.9-beta-1,,parser,,,,0,,,,,,"Running this script on the webconsole used to work prior to 1.8

http://groovyconsole.appspot.com/script/192001

However, now it fails with an exception:

{code}
Script1.groovy: 83: unexpected token: else @ line 83, column 67.
   1).type == type2 ) token += 2 else false
{code}
To get the script working again, you need to change line 83 from:

{code}
    if( get(0).type == type1 && get(1).type == type2 ) token += 2 else false
{code}
to

{code}
    if( get(0).type == type1 && get(1).type == type2 ) { token += 2 } else false
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 08 09:13:01 UTC 2011,,,,,,,,,,"0|i2cgzr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Oct/10 09:52;pniederw;In a sense, the behavior is more consistent now, because you always need a separator. In 1.7 you could get by without a separator in some cases (*1) but not in others (*2).

(*1) {{if (true) x += 2 else false // works in 1.7 but not in 1.8}}

(*2) {{if (true) x else false // works neither in 1.7 nor in 1.8; either need to wrap x with braces, or add a semicolon after it}}

Ideally, neither example would need a separator, similar to statements like {{if (true) println 1 else println 2}}.;;;","08/Mar/11 09:13;guillaume;I added a test case.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Exceptions do not get unwrapped from InvokerInvocationException,GROOVY-4477,12818313,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,roller_vaclav,roller_vaclav,13/Oct/10 14:12,15/Dec/10 10:31,14/Jul/23 06:00,15/Dec/10 10:31,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"Based on the brief exchange on the mailing list, here's the problem:

Groovy code calls a Java library passing in a Groovy instance (which was created using the ""{...} as SomeInterface"" dynamic cast) as parameter. The Java library calls the passed-in Groovy object. The Groovy object throws an exception. The Java library doesn't see the exception, as it is wrapped (because of the groovy bug) inside InvokerInvocationException, so the catch clause inside the library doesn't trigger and the library cannot react. My Groovy code gets an unexpected library-specific exception thrown up to its face.

I revealed the issue when trying to make Multiverse (STM) work with Groovy. Please find below a distilled code example reproducing the problem.

{code:title=MyFoo.java}
public interface MyFoo {
    void baz() throws MyException;
}
{code}

{code:title=MyException.java}
public class MyException extends Exception {
    public MyException(final String message) {
        super(message);
    }
}
{code}

Processor.java representing a third-party library
{code:title=Processor.java}
public class Processor {
    public static void bar(final MyFoo code) {
        try {
            code.baz();
        } catch (MyException e) {
            System.out.println(""Just swallowed the error"");
        }
    }
}
{code}

Groovy script
{code}
Processor.bar( {
    throw new MyException('test')
} as MyFoo)
{code}

The problem is probably related to the dynamic casting, since the following script works fine:

{code}
Processor.bar new MyFoo() {
    void baz() {
        throw new MyException('test')
    }
}
{code}

The failing script uses a dynamic cast.",,venca,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 15 10:31:57 UTC 2010,,,,,,,,,,"0|i2cs7b:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"13/Oct/10 20:48;roshandawrani;Added code tags;;;","15/Dec/10 10:31;blackdrag;hopefully fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Boolean seems to support toBoolean() but yields incorrect results,GROOVY-4475,12811702,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,guillaume,marc@anyware.co.uk,marc@anyware.co.uk,12/Oct/10 11:56,15/Dec/10 16:57,14/Jul/23 06:00,14/Oct/10 10:08,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,1,,,,,,"This is curious (with groovy shipped with grails 1.3.4)

{code}
boolean b = true
def x = b.toBoolean()

println x
assert x
{code}

1) where is no-arg toBoolean() coming from
2) why does it return false for true input.
",,burtbeckwith,ldaley,pledbrook,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 14 10:43:29 UTC 2010,,,,,,,,,,"0|i2bzhr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Oct/10 12:37;roshandawrani;See GROOVY-3704.;;;","12/Oct/10 14:40;marc@anyware.co.uk;Jochen - this may be a duplicate - but the duplicate is closed and the problem still exists.

There is a violated user expectation. This warrants some discussion and a solution.

e.g. no-arg instance method toBoolean() should be supported on Boolean in GDK, most likely. Having this behaviour makes no sense at all. Yes we know the reason for it, but that does not mean the behaviour makes sense to users.;;;","12/Oct/10 14:52;marc@anyware.co.uk;The question here really is:

Should Boolean.toBoolean(null) be called at all in this case. Is this documented, defined behaviour in Groovy? I've not come across this before for method invocations (closures yes). Are we 100% sure its not an accidental leakage of functionality from closures

If yes, this is desired behaviour, then we need GDK instance method toBoolean() to stop this nonsense happening for users. The workaround of always doing toString().toBoolean() on polymorphic values is wasteful, and won't always work if the toString representation of the object is not compatible with String.toBoolean() behaviour.

At the very bottom line, every coder of every other language will surely laugh at Groovy users for having an out of the box implementation of true.toBoolean() that returns false.
;;;","12/Oct/10 14:53;burtbeckwith;Perhaps this comment belongs on 3704, but what are the negative implications of adding a proper toBoolean method to the Boolean metaclass? Any code that relies on the behavior of the private static method (i.e. true == false) is badly broken anyway.;;;","12/Oct/10 14:59;marc@anyware.co.uk;I agree re: 3704 but I'm not sure it matters much.

I'm wondering if actually toBoolean() should exist on all classes and defer to the customizable groovy truth implementation? Surely that makes more sense?;;;","12/Oct/10 15:15;blackdrag;Would you be happy if that would throw an Exception? Like{code:Java}
    public static boolean toBoolean(Boolean b){
        throw new MissingMethodException(""toBoolean"",Boolean.class,new Object[0]);
    }
{code}
Then the call would be causinga MissingMethodException... Or we throw a different and suggest the usage of asBoolean or booleanValue.

As for if toBoolean() should exist on all classes and defer to groovy truth... well, that would be asBoolean... I don't think it is wise to promote a different method here.

On the matter of if toBoolean should be called with null here at all... Yes and no. It is a private staticmethod, so the answer would be no, but answering like this makes the issue a 2.0 thing and there is an issue for things like these already. shold it actually be called with null as value, then yes, that is general Groovy method invocation logic... One that I don't intend to support for 2.0 anymore. I don't know if this was originally a leakage from Closures, it is not now.;;;","12/Oct/10 15:35;marc@anyware.co.uk;I don't think toBoolean( x ) should throw an exception because this is a valid JDK method. The problem is how groovy invokes it

I think non-static toBoolean() with no args should be implemented and work as expected.

Why?

{code}
assert ""Logic"".toString() == ""Logic""
assert 5.toInteger() == 5
assert [1,2].toArray() == [1,2]
{code}

All these pass. Except assert true.toBoolean() == true

This is not rocket science, we are essentially broken :)

[A caveat here - there is no non-static Character.toCharacter() either]
;;;","12/Oct/10 15:38;blackdrag;I suggested to capture toBoolean(), not toBoolean(String). ;;;","12/Oct/10 15:53;marc@anyware.co.uk;OK my bad, but still throwing an exception on toBoolean() makes no sense to the user. Especially when they know they have a boolean.

But anyway, why would toBoolean(boolean) be called when you are invoking (accidentally) toBoolean(null)?

what is the problem with:

{code}
public Boolean toBoolean() { this }
{code}
;;;","12/Oct/10 16:47;blackdrag;seems like some more explanations are needed.... The idea is that this method normally does not exist. As such it would normally throw a MissingMethodException. The code I showed is for DefaultGroovyMethods, which stores the methods it adds to objects in category style. The first argument is actually ""this"" then. So toBoolean(Boolean) becomes Boolean#toBoolean(). People can still call toBoolean(null) and get the strange behaviour of course. But since this is all about toBoolean() without arguments, and since that is with what people expect, I would think this as a reasonable solution. The pro side is that this is the least invasive change I can think of here. Adding toBoolean() to everyting is very invasive.;;;","12/Oct/10 22:59;roshandawrani;But if are introducing a DGM toBoolean(Boolean) to stop the boolean.toBoolean() call from going to that private static JDK method, then why is 
{code}
public static boolean toBoolean(Boolean self){
    return self;
}
{code}
not preferred over
{code}
public static boolean toBoolean(Boolean self){
    throw some exception....
}
{code}

What am I missing?;;;","13/Oct/10 02:59;pledbrook;Just to throw myself into the ring. I know that Groovy now has an asBoolean() method, but it also has polymorphich {{toInteger()}} and {{toLong()}} methods. That's why Marc and I expect a {{Boolean.toBoolean()}} as well as a {{String.toBoolean()}}. It seems amazingly inconsistent not to have it.

Also, I believe that bringing {{asBoolean()}} into this discussion is a red herring. Consider this code:
{code}
println ""false"".toBoolean()
println ""false"".asBoolean()
{code}
This prints out
{noformat}
false
true
{noformat}
Hence {{toBoolean()}} and {{asBoolean()}} have different semantics. This must suggest that {{Boolean.toBoolean()}} should be added?;;;","13/Oct/10 03:03;pledbrook;Perhaps I should just throw my hat into the ring instead? :);;;","13/Oct/10 06:13;blackdrag;toInteger(), toLong() and such are relicts of code that is now in DefaultTypeTransformation using those methods Groovy made internal conversion mechanisms visible to the outside. But internal code and API requirements may differ over time, so the parts developed into different directions. As you can see, those methods are mostly from Groovy 1.0, the most early version possible.

I am a bit puzzled as of why nobody did yet answer if toBoolean() throwing an exception is not good enough for them. Making toBoolean() mirror asBoolean() is for me quite bad. In that case it would be much better to deprecate asBoolean() and use toBoolean() instead. If that had not been introduced in 1.7 already, then I would have suggested this route instead. This route could be considered maybe for 2.0... even though I am not happy with such small changes, that are hard to recognize. 

;;;","13/Oct/10 07:59;pledbrook;Hmmm...I don't remember {{""1234"" as Integer}} working before. I see why that now makes toInteger() rather redundant.

That still leaves the problem that {{""false""}} as Boolean returns {{true}}, whereas {{true.toString()}} gives {{""true""}}. But then you would be breaking the current meaning of Groovy Truth. Having a {{Boolean.toBoolean()}} convenience method would at least give us a behaviour that matches the reverse of {{String.toBoolean()}}. So to be explicit, throwing a {{MissingMethodException}} wouldn't be sufficient because I think a proper implementation of {{Boolean.toBoolean()}} is required.;;;","13/Oct/10 11:10;blackdrag;String#toBoolean() goes btw back to GROOVY-1292 and GROOVY-1293

a Boolean#toBoolean() does not help with (""false"" as Boolean)... 

I am still not sure what you guys actually want. toInteger() and such where added as numeric conversion methods. Of course toBoolean() is not by default in that set, as it is not toClosure, toGString, and many other basic types. ;;;","13/Oct/10 11:50;pledbrook;Correct, Boolean#toBoolean() won't suddenly change the behaviour of (""false"" as Boolean), but that's fine. That's not the intention. The idea is to have a method that matches String#toBoolean() on Boolean itself, so you can deal with the two types polymorphically, i.e. given:
{code}
b1 = ""false""
b2 = false
b3 = ""true""
b4 = true
{code}
then these assertions pass
{code}
assert !b1.toBoolean()
assert !b2.toBoolean()
assert b3.toBoolean()
assert b4.toBoolean()
{code}
Why is this a bad idea? I mean, toInteger() et al. may not have been intended for the uses we have put it to, but it has become a standard approach for dealing with values that may be a string or an integer. That's why we'd like the same behaviour for toBoolean().

Hope that explains what we want better.

Also I would argue that a boolean is a numeric type although it has a limited range ;);;;","13/Oct/10 12:07;blackdrag;can you give a more real world example?;;;","13/Oct/10 14:47;marc@anyware.co.uk;{code}
@Validateable
class InviteForm {
    String email
    boolean approved
}

class TestController {
    def inviteService

    def inviteUser = { InviteForm form ->
        inviteService.inviteUser(form)
    }
}

class InviteService = {
    def inviteUser(args) {
        def invite = new Invite()
        invite.email = args.email
        // BOOM - we want args.approved to be anything - string or boolean etc
        invite.approved = args.approved.toBoolean()
        invite.save()
    }    
}
{code}

The above fails. It is a simplification of the real world problem I fixed in a grails plugin.

The workaround involves something like:

{code}
invite.approved = args.approved.toString().toBoolean() 
{code}

Which is counterintuitive when you know it may be a boolean or string, and inefficient.
;;;","13/Oct/10 17:59;blackdrag;to understand the example... why is inviteUser called one time with a boolean and one time with a String? and why is it there ok to have a String like ""foo bar"" eval to... well I think it is false, and only strings like ""true"", ""y"" or ""yes"" should eval to true? Doesn't that mean you will have to check the String befroe hand? Waht do you do if args.approved is a Integer?;;;","14/Oct/10 03:39;marc@anyware.co.uk;This is a web app, and we are using ""duck typing"" in our APIs to make things as flexible as possible for users.

So they may have a grails command object (statically typed properties) or it might be the ""params"" map with string values in. Or it might be a mock object.

This is simply about making lenient ""do the right thing"" APIs.;;;","14/Oct/10 03:40;marc@anyware.co.uk;Re: Integer. Wouldn't it be nice if toBoolean existed on Integer.

Unfortunately you can't use customizable groovy truth (as Boolean) for this as of the unintended side effects of the implementation of String.asBoolean
;;;","14/Oct/10 04:01;pledbrook;A little more context. The {{InviteService}} may be provided by a plugin. Users would have their own controllers that use that service and pass in an {{approved}} value. In the above example, the user is using a command object, so {{approved}} is a boolean. Another user might have:
{code}
class TestController {
    def inviteService

    def inviteUser = {
        inviteService.inviteUser(params)
    }
}
{code}
in which case the {{approved}} value is a string ('params' does not type conversion).

Another example is in tag libraries. Consider this tag:
{code:xml}
<g:someTag absolute=""false""/>
{code}
The tag in this case will see the attribute {{absolute}} with a string value, but if you change the tag to
{code:xml}
<g:someTag absolute=""${isAbsolute}""/>
{code}
where {{isAbsolute}} is a boolean value, then the tag will see the {{absolute}} attribute as a boolean. Being able to treat the two identically in the tag code is a great boon and one of the advantages of Groovy over Java. If it worked as we would expect of course.;;;","14/Oct/10 04:10;marc@anyware.co.uk;Furthermore, the ${isAbsolute} example is bang on - the value of that should be duck-typed. This is standard behaviour in grails tags, but is painful to achieve as you must do x.toString().toBoolean() (after you discover later that x.toBoolean() goes wrong). asBoolean in this case does not work.

Jochen - I'm starting to thing the root cause here is that customizable Groovy Truth has caused the problem by being implemented as a coercion to Boolean. This is not I think, in hindsight, correct - at least not in the traditional implementation of Groovy's String > boolean coercion methods.

e.g. if Groovy Truth customization had been implemented like an operator instead of part of the ""asXXXX"" coercion mechanisms, this problem would not be happening because you could say to everyone ""toXXXXX is deprecated, use 'as Y' from now on"".

Except we can't do this now because String.asBoolean() implements groovy truth, the world where ""false"" == true.

Is it really too late to fix this? Can we be brave and fix (break) it in 2.0? Use Object.truthValue() or similar for groovy truth evaluation, and make asBoolean the same as Boolean.valueOf(String). ?
;;;","14/Oct/10 09:25;blackdrag;gee, this issue turned out to be more complicated than expected...

What I got from the GSP example is that Grails GSP allow you not in a very good way to give primitives and keep their type. I would not have it implemented like this, but ok, that part is given. And I take it as a inconsistency in Grails that we are supposed to fix in Groovy-Core by adding workarounds. There would not have been any need for this discussion if both had been handled in the same way.. that is both as boolean or both as String.

The argument with duck typing here is a bit strange to me. What for example prevents me to put in there any arbitrary class? Nothing. So it is normal that if you don't provide an object that supports the used API, that the code fails with a MissingMethodException. I don't see why this then automatically means to provide a toBoolean() method on Object. Because judging from your code, that is what you are requesting in the end. All I see is that the toBoolean() method on Boolean should not have been visible and none of this would have mattered. 

You seem to think that String#toBoolean() does handle only true and false... that is not right:
{code:Java}
    public static Boolean toBoolean(String self) {
        final String trimmed = self.trim();

        if (""true"".equalsIgnoreCase(trimmed) || ""y"".equalsIgnoreCase(trimmed) || ""1"".equals(trimmed)) {
            return Boolean.TRUE;
        } else {
            return Boolean.FALSE;
        }
    }
{code}
code like this is what brings localization nightmares. 

And if I would go and change asBoolean to truthValue, then wouldn't you normally be one of the first complaining? The only reason I mentioned asBoolean and Groovy truth is, because I was back then not yet in the clear about what you actually want and that toBoolean and asBoolean are quite similar, with the tendency to take one for the other. Back then I thought you wanted to let that be Groovy truth, but now I know you really want something else. So let us put the name similarity issue beside.

What you really want is a conversion function that works with different types and is specific to what is allowed in your app. Right?;;;","14/Oct/10 09:44;marc@anyware.co.uk;There is no inconsistency in Grails.

Attributes are passed to tags as specified by the user. String literals are usually passed with x=""y"" notation, which makes perfect sense. Users can also pass specific data values in using the GSP EL which evaluates native groovy expressions and returns their values. Hence x=""${true}"".

Coercing x=""true"" automatically to x=""${true}"" would be bad (and probably cause issues with JSP compatibility) and x=""${'something'}"" to pass any string literals would be extremely annoying.

This is about philosophy. The Grails (and I assume, perhaps wrongly, Groovy) way is to make things as easy as possible for the user. Assume as little as possible, ""do the right thing"" as much as possible. Funnily enough this has turned out very popular with developers.

I would not have complained about truthValue(), especially if asBoolean worked i.e. ""false"".asBoolean() == false. It isn't. For most people, this is intuitively broken, seeing as the other asXXXX coercions are (off the top of my head) much more literal and not ""fudged"" like groovy truth is for String (which is a good thing - just not in asBoolean).

Please can this get some high level discussion in the whole groovy team?


;;;","14/Oct/10 09:56;guillaume;We'll go with Boolean#toBoolean() and be done with this issue.
We've got no intention to do any breaking change in Groovy Truth as of now.
With this new method, b.toBoolean() will return true for b being ""true"" or Boolean.TRUE, so ""duck typing"" is preserved.;;;","14/Oct/10 10:01;graemerocher;Jochen I'm not sure something so simple has evolved into such a complicated discussion. Groovy is a dynamic language that is supposed to support duck typing and be intuitive.

The fact that ""true"".toBoolean() and true.toBoolean() return different values is a bug to me and it has nothing to do with Grails. The fact that Groovy is under the covers calling into a static method toBoolean(null) is even more of a bug. I am unsure as to why we are even debating this.;;;","14/Oct/10 10:43;blackdrag;That Boolean#toBoolean(null) is called is something I wanted to fix even before the 1.0 release, but I got no majority for this. So in fact it is no bug, it is an unlucky feature, back then with the argument that SwingBuilder needs that. I did see it as evil doing. Funny thing is, I was also for not allowing static methods being called using an instance. I see that of a thing broken in Java and having that in Groovy is a bug for me too. But again no majority here. Any of those two would have prevented Boolean#toBoolean() being a successful call. That the method is private and that we want to fix that in Groovy 2 is well known I think. From my view the fact this method is callable is then based on 3 bugs. Fixing one of them would have nullified this issue, because then a MissingMethodException had been thrown. Then there would have been indeed no discussion.

I wonder what code then would have been produced.;;;",,,,,,,,,,,,,,,,
NPE in property access in anonymous inner classes,GROOVY-4471,12815361,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,roshandawrani,roshandawrani,11/Oct/10 11:28,14/Oct/11 00:28,14/Jul/23 06:00,12/Oct/11 03:36,1.8-beta-3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.4,1.9-beta-4,class generator,,,,0,,,,,,"{code}
class X {
    private A a = new A()
    public B b
    public X() {
        b = new B() {
            public String getFoo() {a}
        }
    }
}

class A {}
class B {
    B(){getFoo()}
    def getFoo(){}
}

def x = new X()
{code}

The code above fails with
{noformat}
Caught: java.lang.NullPointerException
	at X$1.propertyMissing(TryGroovy.groovy)
	at X$1.getFoo(TryGroovy.groovy:6)
	at X$1.getFoo(TryGroovy.groovy)
	at B.<init>(TryGroovy.groovy:13)
	at X$1.<init>(TryGroovy.groovy)
	at X.<init>(TryGroovy.groovy:5)
	at TryGroovy.run(TryGroovy.groovy:16)
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 11 11:28:29 UTC 2011,,,,,,,,,,"0|i2c2if:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Oct/11 11:28;melix;Fixed in master and 1.8.x branch. However, I'm not closing it since backporting to 1.7.x is still under discussion.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stub generator cannot handle multi-line strings as annotation values,GROOVY-4470,12811532,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pniederw,pniederw,pniederw,11/Oct/10 10:56,08/Mar/11 09:37,14/Jul/23 06:00,30/Dec/10 07:43,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.7,1.8-beta-4,,Compiler,,,,0,,,,,,"Relevant part of generated stub:

{code}
@StringAnno(val="" 
multi
line
string
"") public class StringAnnoUser
  extends java.lang.Object  implements
    groovy.lang.GroovyObject {
public StringAnnoUser
() {}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4601,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 11 12:40:02 UTC 2010,,,,,,,,,,"0|i2bzun:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Oct/10 12:33;roshandawrani;If you have the sources readily available to reproduce it, it will save time if you can provide it.;;;","11/Oct/10 12:40;pniederw;{code}
@interface StringAnno {
  String val()
}
{code}

{code}
@StringAnno(val = ''' 
multi
line
string
''')
class StringAnnoUser {}
{code}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
http://groovy.codehaus.org/gapi/ - empty/duplicate/missing Javadocs,GROOVY-4469,12815343,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,genie,genie,10/Oct/10 17:57,15/Dec/10 16:56,14/Jul/23 06:00,12/Oct/10 22:55,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"Please, see http://goo.gl/nDrx:

* Some javadocs are empty (MetaObjectProtocol, MetaClass, GroovyObject)
* Some javadocs contain duplicate methods (Date, Process)
* Some javadocs are missing (EncodingGroovyMethods)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 13 02:51:02 UTC 2010,,,,,,,,,,"0|i2bslz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Oct/10 18:58;paulk;Regarding {{EncodingGroovyMethods}}, that is a limitation of Antlr. When running groovydoc you will notice the following warning:
{noformat}
[groovydoc] ignored due to TokenStreamException: org\codehaus\groovy\runtime\EncodingGroovyMethods.java [expecting '""', found ' ']
{noformat}
Not sure there is much we can do about that error prior to upgrading to Antlr 3 and seeing if the problem is still there.

Perhaps refactoring whatever is causing antlr to have problems into a helper auxiliary file might also work.;;;","10/Oct/10 19:11;genie;Ah, I see http://groovy.codehaus.org/api/ is available as well! 
May be this link could be added to http://groovy.codehaus.org/Reference as a ""backup"" solution for Groovydoc bugs.;;;","12/Oct/10 14:45;paulk;Even though looking at the {{EncodingGroovyMethods}} doco under {{gapi}} is not normally the preferred way to peruse the contained GDK methods ({{groovy-jdk}} is preferred) I made it work by moving the troublesome constant into a separate support file. That file doesn't mke it into the docs but it only contains an internal constant anyway.;;;","12/Oct/10 14:49;paulk;The duplicate methods were caused by {{DocGenerator}} not ignoring legacy {{@Deprecated}} methods even though these are ignored when adding DGM methods. It now does.;;;","12/Oct/10 14:52;paulk;The missing methods/fields in Interfaces was caused by special logic to distinguish between how Java and Groovy treat components without an explicit visibility modifier. This was updated.;;;","12/Oct/10 15:32;genie;Great, thank you! When will we able to see the updates online?;;;","12/Oct/10 19:19;genie;http://groovy.codehaus.org/gapi/org/codehaus/groovy/control/CompilePhase.html - ""Enum Constant Summary"" is missing
http://groovy.codehaus.org/api/org/codehaus/groovy/control/CompilePhase.html
;;;","13/Oct/10 02:51;guillaume;We'll update the docs for the next release.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy JDK's java.util.Date page has double method definitions,GROOVY-4467,12811469,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jaswartz@ebay.com,jaswartz@ebay.com,08/Oct/10 15:51,15/Dec/10 16:56,14/Jul/23 06:00,12/Oct/10 14:55,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"On the java.util.Date page in Groovy JDK:
http://groovy.codehaus.org/groovy-jdk/java/util/Date.html

All of the methods appear twice: once with no comment, and again with the javadoc comment.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 12 15:02:23 UTC 2010,,,,,,,,,,"0|i2bowf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Oct/10 21:14;roshandawrani;Same case for http://groovy.codehaus.org/groovy-jdk/java/sql/Date.html at least.;;;","12/Oct/10 14:55;paulk;I don't particularly like issues with multiple aspects but GROOVY-4469 covers this issue as well as some other aspects. Please see that issue for more details.;;;","12/Oct/10 15:02;jaswartz@ebay.com;Not sure what the multiple aspects are but thanks for fixing this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE in org.codehaus.groovy.runtime.dgmimpl.NumberNumberPlus$DoubleInteger,GROOVY-4458,12815355,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,uwekirsch,uwekirsch,05/Oct/10 06:54,16/Feb/13 00:47,14/Jul/23 06:00,28/Jan/13 14:21,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.7,2.1.1,,,,,0,,,,,,"We enhance the NullObject to have a more graceful null handling. 

{code}
def emc = new ExpandoMetaClass( org.codehaus.groovy.runtime.NullObject.getNullObject().getClass())
emc.plus = {b -> b}
emc.initialize()
org.codehaus.groovy.runtime.NullObject.getNullObject().setMetaClass(emc)

It works fine except for some variants of array access:
Double[][] a = new Double[10][10]
for (def i = 0; i <= 9; i++ ) {
    for (def j = 0; j <= 9; j++ ) {
        println(""i=$i j=$j a[0][i]=$a[0][i]"")
        a[0][i] = a[0][i] + 1
    }
}
{code}

We get a NPE:
{noformat}
java.lang.NullPointerException
    at org.codehaus.groovy.runtime.dgmimpl.NumberNumberPlus$DoubleInteger.call(NumberNumberPlus.java:170)
    at ConsoleScript6.run(ConsoleScript6:10)
    at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:264)
    at groovy.lang.GroovyShell.run(GroovyShell.java:513)
    at groovy.lang.GroovyShell.run(GroovyShell.java:170)
    at groovy.lang.GroovyShell$run$0.call(Unknown Source)
    at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:890)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
    at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
    at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:149)
    at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
    at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
    at groovy.lang.Closure.call(Closure.java:276)
    at groovy.lang.Closure.call(Closure.java:271)
    at groovy.lang.Closure.run(Closure.java:354)
    at java.lang.Thread.run(Thread.java:619) 
{noformat}

A script to reproduce this in the GroovyConsole is attached.
","Windows XP SP3, JDK 1.6.0",blackdrag,uwekirsch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"05/Oct/10 06:54;uwekirsch;arrayaccess.groovy;https://issues.apache.org/jira/secure/attachment/12722697/arrayaccess.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 28 14:21:14 UTC 2013,,,,,,,,,,"0|i2cr0f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Oct/10 11:34;roshandawrani;Added formatting tags.;;;","13/Dec/10 17:28;blackdrag;I am closing this bug... I personally find it in most cases better if the NPE contains more details. Very often you have to guess, reformat, redo, guess again and so on. I prefer it the way it is, as it is giving away more information

I assume that is mostly a matter of taste ;;;","11/Jan/11 10:34;uwekirsch;Why is this bug marked as ""Fixed""?
I can still reproduce it in 1.7.6

Please check, if it could be fixed in 1.7.7 and/or 1.8;;;","11/Jan/11 13:30;blackdrag;I am sorry, I think I closed this issue accidentally... 

This looks like a call site caching bug actually.;;;","11/Jan/11 13:32;blackdrag;it works the first time, then goes one time through all j for i=0 and is happy. When i==1 it fails, because then it does not resolve to the EMC version anymore.

The question is... is that right or not?;;;","28/Jan/13 14:21;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
generic type declarations leaking across all files in a build,GROOVY-4457,12812178,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,melix,aclement,aclement,04/Oct/10 17:21,24/Dec/11 03:08,14/Jul/23 06:00,09/Dec/11 03:03,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.5,2.0-beta-2,Compiler,,,,0,,,,,,"Simple file, A.groovy:

{code}
class A<String> {
}

class B {
  void foo(String s) {}
}
{code}

groovyc A.groovy
javap -private B | grep foo

produces:
{code}
public void foo(java.lang.Object);
{code}

The 'String' is treated as a type parameter name.  The reference 'String' in the foo method is mapped to this type parameter (clearly it shouldn't be) and when producing the code, String is erased to its upper bound of Object, hence foo(Object) in the bytecode.

Change it to this:
{code}
class A<T> {
}

class B {
  void foo(String s) {}
}
{code}
and it produces what you expect:
{code}
 public void foo(java.lang.String);
{code}

The problem is the genericParameterNames collection in the ResolveVisitor is never cleared, only augmented with new entries.

My solution that seems to work in groovy eclipse is to clear the parameter names at the end of visiting a classnode in ResolveVisitor. So at the end of

{code}
public void visitClass(ClassNode node) {
{code}

add
{code}
genericParameterNames.clear();
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/Dec/11 05:52;melix;GROOVY-4457.patch;https://issues.apache.org/jira/secure/attachment/12721719/GROOVY-4457.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 06 05:52:40 UTC 2011,,,,,,,,,,"0|i2c0lr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Oct/10 22:44;roshandawrani;I can later look into it a bit more to confirm but on a quick glance, I think that the solution suggested may not work when there are (anonymous)inner classes involved where outer class' generic parameter names remain valid inside the inner classes too.

We don't want to end visitClass() for an inner class and clear the genericParameterNames for the outer class as well.;;;","05/Oct/10 03:15;aclement;Yep, after sleeping on it, you need to allow for inner classes to, I'd probably just use a similar mechanic in visitClassNode that you already have in the visitConstructorOrMethod code.;;;","05/Oct/10 04:09;blackdrag;a proposed Testcase:

{code:Java}
assertScript """"""
class A<String> {}
class B {
  void foo(String s) {}
}
// use the name to check the class, since the error was that String was seen as 
// a symbol resolved to Object, not as the class String, thus a ...==String would
// not have failed
assert B.class.methods.find{it.name==""foo""}.parameterTypes[0].name.contains(""String"")
""""""
{code}

;;;","05/Oct/10 10:58;roshandawrani;As suspected, the fix seems to have impact on the generics handling for inner classes.

The following code does not work now (doesn't even compile actually)

{code}
class A<T> {
    class B {
      void foo(T s) {}
    }
}
assert A.B.class.methods.find{it.name==""foo""}.parameterTypes[0].name.contains(""java.lang.Object"")
{code}

It fails with
{noformat}
D:\Roshan\GroovyDevSetup\Workspace17x\TryGroovy\src\TryGroovy.groovy: 3: unable to resolve class T 
 @ line 3, column 16.
         void foo(T s) {}
                  ^

1 error
{noformat};;;","05/Oct/10 12:50;aclement;Indeed, I see that the visit to the inner class does not happen during the visit to the outerclass, it happens after the outer class has been finished with.  So the code from visitMethodOrConstructor cannot be used as when visiting the inner node the type variables of the outer have been forgotten.;;;","05/Oct/10 12:52;blackdrag;There are possibly 3 solutions to the inner class problem. 
(1) add a map to the inner class and set it from the resolve visitor and reuse it when parsing the inner class
(2) have some kind of memory persistent map ClassNode->SymbolMap.... I absolutely don't like this one
(3) start the resolving of inner classes after the outer class is done, without using the normal iteration used by CompilationUnit.

I prefer number 3 since it does not require keeping additional information in the AST. ;;;","29/Oct/10 04:17;graemerocher;Any progress on this?;;;","29/Oct/10 05:05;blackdrag;since Roshan seems not to have capacity to fix this (which is not his fault), there is no progress atm;;;","29/Oct/10 05:06;blackdrag;I guess someone else will have to take this over, unless Roshan says he still wants to fix this one;;;","29/Oct/10 09:45;aclement;If I can find time, I'll take a proper look at the right fix.;;;","06/Dec/11 05:07;melix;Master includes the fix which breaks the non static inner class case. I will try to commit a fix.;;;","06/Dec/11 05:52;melix;Here is the patch against master. Added a unit test for the non static inner class case. If you are ok, I will commit it.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
multiple assignment code makes Groovy AST Browser throw Exception,GROOVY-4455,12815354,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,hamletdrc,hamletdrc,hamletdrc,02/Oct/10 11:13,10/Nov/11 03:06,14/Jul/23 06:00,10/Nov/11 03:06,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Groovy Console,,,,0,,,,,,"Type this code into GroovyConsole: 
def (bar, x, bif, qux) = [1, 2, 3, 4]$
View AST Browser
There is an exception. 

This should be easy to fix. ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 03 14:24:44 UTC 2010,,,,,,,,,,"0|i2bwq7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Oct/10 01:23;roshandawrani;This issue's fix could be a little tricky.

DeclarationExpression#getVariableExpression() doesn't seem to consider the case that its LeftExpression can be a non-VariableExpression (like a TupleExpression in case of multiple assignments)

Since it's a public method, you can't easily change the return type. 

Returning null(in case of multiple assignment) also will not serve Ast Browser's purpose, because it still can't correctly display multiple assignment's left expression in that case.;;;","30/Nov/10 14:40;hamletdrc;fixed in 1.8;;;","03/Dec/10 14:24;hamletdrc;fixing for 1.7 branch;;;","03/Dec/10 14:24;hamletdrc;fixed in 1.8 and 1.7.x;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
PATHEXT environment var overwritten in windows installer,GROOVY-4454,12815318,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jbaumann,gjmathews1,gjmathews1,01/Oct/10 16:05,15/Dec/10 22:31,14/Jul/23 06:00,04/Nov/10 10:09,1.5.7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,,,windows installer,,,,0,,,,,,"After installing Groovy using groovy-1.5.7-installer.exe, I noticed problems to start my WebLogic server...
After investigation it turned out it was no longer possible to run 'java' from command line, it did work when using 'java.exe'
Some further investigation showed that the environment variable PATHEXT was now PATHEXT=;.groovy;.gy in stead of the usual value PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH

Needless to say Groovy left the building in the mean time... :-((",WinXP SP3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 04 10:09:11 UTC 2010,,,,,,,,,,"0|i2bmmv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Oct/10 16:19;gjmathews1;This was attempt to reopen bug GROOVY-3117.
I've been bitten by this twice using latest Windows-Installer [Binary Release] for 1.7.5 and some previous version.
Appears to override the PATHEXT when .groovy might already exist on PATHEXT. I uninstalled 1.7.4 then installed 1.7.5 with default settings after which PATHEXT was set [PATHEXT=;.groovy;.gy] and .exe commands no longer executed as such. Need to review appending .groovy to PATHEXT in installer and/or preserve PATHEXT doing the uninstall.;;;","02/Oct/10 03:18;jbaumann;Uninstalling Groovy does not change the PATHEXT variable. Thus the only explanation I have is that somehow the PATHEXT variable gets deleted when writing the new value. Since the procedure for writing is the same as for writing the PATH variable, this in itself shouldn't be a problem. I just tested the installer again, on a 32-bit system (WIN XP SP3) and on a 64-bit system (Win 7), with and without change to PATHEXT selected in the installer, and all worked as expected.

Could you please add more information about the contents of the PATHEXT-variable before and after the installation, and whether or not the installer option to change PATHEXT is preselected.;;;","02/Oct/10 12:43;gjmathews1;I tried it again repeating the same steps but this time no PATHEXT overwrite.
Last time uninstalled 1.7.4 then installed 1.7.5 but PATHEXT was pre-selected in installer.
This time set PATHEXT option *NOT* preselected in installer

before uninstall
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS;.groovy;.gy 

after uninstall
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS;.groovy;.gy 

Note after uninstall GROOVY_HOME variable still exists and GROOVY_HOME\bin still appears in system PATH

INSTALL options:
[x] modify variables
[x] Create GROOVY_HOME
[x] Add to Sys Environment

[x] Add File Association
[ ] Add to PATHEXT

after install
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.JS;.WS;.groovy;.gy 
;;;","05/Oct/10 03:57;jbaumann;First off, the installer for 1.7.4 and 1.7.5 use the same code base, which means that uninstalling 1.7.5 and installing it again should have the same effects as using 1.7.4.

When installing the installer checks whether .groovy exists in PATHEXT before offering to change it. This is why the option was deselected. But even if you select it by hand it simply appends the extensions a second time.

When uninstalling the installer does _not_ change any variables because I deemed it to dangerous. 

So, this looks like it is supposed to. Right now, I'm a bit stumped. That the PATHEXT option was preselected when you first installed 1.7.5 suggests that at that point PATHEXT didn't contain .groovy. Since the uninstaller does not change the variables this might point to something else. Maybe the installer wasn't able to read the PATHEXT variable but then wrote a new value into the selfsame variable. Could this possibly have to do with reduced rights?

;;;","04/Nov/10 05:04;blackdrag;Joachim, the fix version for this one is 1.6.1, should I remove that?;;;","04/Nov/10 09:54;jbaumann;Jochen, yes please. The problem was irreproducible with later versions, so I believe it to be fixed.
;;;","04/Nov/10 10:09;jbaumann;Problem is fixed with version 1.7.4 onward. Uninstalling earlier versions is no problem.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Duplicate methods added by stub generator in joint compilation when method parameters have default values.,GROOVY-4453,12812186,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,marcel166,marcel166,01/Oct/10 10:28,15/Dec/10 16:57,14/Jul/23 06:00,02/Oct/10 02:05,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,class generator,,,,0,,,,,,"A new grails project.
In the src folder a groovy class like:
{code}
package de.app

class User {
    String name

    public void setName(String name, String t = """") {
          this.name = name
    }
}
{code}
and in the src folder a java class like:
{code}
package de.me;

import de.app.User;

public class App {

    public void make() {
        User u = new User();
    }
}
{code}
result:
{code}
[groovyc] /tmp/groovy-generated-5423173608487992496-java-source/de/app/User.java:22: setName(java.lang.String) is already defined in de.app.User
  [groovyc] public  void setName(java.lang.String value) { }
  [groovyc]              ^
  [groovyc] 1 error
{code}
removing the optional parameter (String t = """") works.",ubuntu,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-10-01 10:28:29.0,,,,,,,,,,"0|i2buhz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stub generation for annotation types doesn't work,GROOVY-4451,12811797,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,pniederw,pniederw,30/Sep/10 07:51,15/Dec/10 16:57,14/Jul/23 06:00,30/Sep/10 16:56,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Compiler,,,,0,,,,,,"Generated stub code looks similar to a regular interface definition. Something like:

{code}
public interface MyAnno extends java.lang.Annotation { ... }
{code}

Obviously, javac doesn't like this.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-09-30 07:51:16.0,,,,,,,,,,"0|i2ckv3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Vararg parameter allowed in non-last position but fails at runtime,GROOVY-4449,12815320,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,pniederw,pniederw,30/Sep/10 07:32,15/Dec/10 16:56,14/Jul/23 06:00,01/Oct/10 13:53,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Compiler,,,,0,,,,,,"Groovy doesn't give an error when a vararg parameter doesn't come last in a parameter list, but then fails at runtime when the method is called in vararg-style. For example, the following code...

{code}
def foo(String... strs, int i) { println i }
foo(""me"", ""you"", 42)
{code}

...produces:
{noformat}
groovy.lang.MissingMethodException: No signature of method: ConsoleScript11.foo() is applicable for argument types: (java.lang.String, java.lang.String, java.lang.Integer) values: [me, you, 42]
{noformat}

I assume the underlying reason is that groovyc currently simply treats String... as syntactic sugar for String[], without any further checks.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"01/Oct/10 07:25;roshandawrani;4449_v17x.diff;https://issues.apache.org/jira/secure/attachment/12722456/4449_v17x.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 01 13:53:22 UTC 2010,,,,,,,,,,"0|i2ctpb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Sep/10 08:09;pniederw;Similar problem exists when vararg parameter is followed by an optional parameter:

{code}
def foo(String... strs, int i = 0) { println i}
{code}

Calling this method in vararg-style only works if no value is given for i.;;;","01/Oct/10 07:25;roshandawrani;Attaching a patch that disallows a var-arg parameter if it is not the last one.;;;","01/Oct/10 08:09;blackdrag;hmmm... I find a bit troublesome to have a change to the AST, just to find an error in APP, which creates the AST. We should look for a more local change I think;;;","01/Oct/10 09:01;roshandawrani;Actually I could have made the change local to APP to begin with but I was surprised to see that AST does not retain this information at all that a method parameter was syntactically marked as var-arg.

Later on in the compilation cycle, it goes by the last parameter being an array to determine whether it is a var-arg method, which is not really so reliable, is it?

If we retain this information in AST, it will have support for differentiating between the cases where a parameter was marked as String... vs String[]. Now that people integrated with groovy at AST level, it could of use to some, if not all. So, that was the intention behind adding that info to Parameter. Of-course the change can be made local to APP and AST be left as is.

Your call.;;;","01/Oct/10 09:33;pniederw;I have nothing against extending the AST (in fact I think that some of the newer Groovy features have too little AST representation), but I'd like to bring up one lesson here that I recently learned the hard way: Because Groovy doesn't provide a standard way to copy an AST node (say with a copy method), it's very dangerous to introduce new fields. Not only do you have to find all locations in the Groovy codebase where the AST node is manually copied (which isn't too difficult), but chances are that external AST transforms will also manually copy the AST node. Such transforms will continue to compile after a new field is introduced, but their usage will lead to the field's value getting lost. This can lead to bugs that are extremely hard to find.
I should probably make a separate issue for this, but I thought I'd mention it here.

By the way, here is some AST information that I've missed in the past (for Spock and other stuff):

- Is the method name in this method definition given as a string literal?
- Is the method name in this method invocation given as a string literal?
- Did the method caller pass named arguments or a map? (this one I actually needed at runtime, for a DSL)
- What's the (exact) source code for this AST node?;;;","01/Oct/10 09:58;blackdrag;from the Groovy side saying a varg is a method that has as last parameter an array is exactly that what it should be. For Groovy there is no difference between String[] and String... as last parameter. The only reason I did not close this as a Won't Fix is, that people coming from Java would maybe be too perplexed by seeing a String... in the middle of a method signature. 

As for Peter's questions... 

the first two are easily solvable I think. The problem is more the one of a use case and a test confirming the issue according to the use case. I never had use to know if it is a String based version or a normal name.

""Did the method caller pass named arguments or a map?"" This is too is probably not too difficult to solve... Instead of using a normal Map we can use a special Map sub class. A simple instanceof in the method can then show what it was.

""What's the (exact) source code for this AST node?"" that is actually more difficult I think and I have no real answer to this.;;;","01/Oct/10 12:24;roshandawrani;For it to be marked as ""Won't Fix"", the feature needs to be not half-baked, but full. If it only compiles but doesn't work at runtime, there is something to be ""fixed"" - one way or other.

Since no value is seen in maintaining in the ""String... vs String[]"" info in AST, I am making the change local to APP to disallow var-arg if not the last parameter.;;;","01/Oct/10 13:53;roshandawrani;Fixed. Compiler now rejects a var-arg parameter if it is not in the last position.

Any other valid but unrelated requirements that have been discussed here, please take them forward on mailing-list/separate issue(s).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
SwingBuilder TitledBorder not recognizing justification attribute correctly,GROOVY-4448,12816630,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,solidjb,solidjb,30/Sep/10 07:01,05/Apr/15 14:44,14/Jul/23 06:00,02/Oct/10 03:48,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Swing,,,,0,,,,,,"I was attempting to move my titled border around the panel by modifying the justification attribute.

{code}
panel(border: titledBorder(border: etchedBorder(), title: 'Project', justification: 'right', position: 'bottom')) {
{code}

It seemed no matter what value I put into the justification attribute, it would stay on the left of my panel.  I looked into the source code, and it appears as though there may be a copy paste error from the section processing the position attribute.  The current version of TitledBorderFactory reads the justification attribute from the builder, and then tries to look the value up in the position map instead of the justification map.  I think a simple code change to look things up in the justification map would fix things.

i.e. change this:
{code}
def justification = attributes.remove(""justification"")
justification = positions[justification] ?: justification

{code}

to this:
{code}
def justification = attributes.remove(""justification"")
justification = justifications[justification] ?: justification
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Sep/10 07:01;solidjb;TitledBorderFactoryJustificationTest.groovy;https://issues.apache.org/jira/secure/attachment/12722695/TitledBorderFactoryJustificationTest.groovy","30/Sep/10 07:01;solidjb;justificationFix.diff;https://issues.apache.org/jira/secure/attachment/12722339/justificationFix.diff",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Sat Oct 02 03:48:21 UTC 2010,,,,,,,,,,"0|i2bw4n:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"30/Sep/10 09:13;solidjb;I left the priority as major, as I don't know that there is a work around.  Also, I marked that it affects version 1.7.5, but it looked like it was still broken on the trunk.  I don't know if the trunk feeds the 1.8.X development or the 1.7.X development.  If the trunk feeds 1.8.X, then it would affect all 1.8.X versions as well.;;;","02/Oct/10 03:48;roshandawrani;Thanks for investigating and providing the patch. I have applied it to 1.7.x and trunk (1.8.x).

;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
A few issues in stubgenerator testing infrastructure,GROOVY-4447,12812177,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,30/Sep/10 04:17,15/Dec/10 16:56,14/Jul/23 06:00,30/Sep/10 06:10,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"The documentation of org.codehaus.groovy.tools.stubgenerator.StringSourcesStubTestCase says that the source mappings for testing joing compilation stub generation can be given as below:
{code}
['com/foo/Bar.groovy': '''
    package com.foo
    class Bar {}
''']
{code}

However this doesn't currently work because the sub-folders for the package structure are not recursively created physically and hence writing to 'com/foo/Bar.groovy' fails with FileNotFoundException.

Another small improvement needed is an option to not-delete the temp folder created for stubs.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-09-30 04:17:42.0,,,,,,,,,,"0|i2c2v3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ImmutableASTTransformation puts initialization of static fields into instance constructor,GROOVY-4445,12815324,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,29/Sep/10 10:13,15/Dec/10 16:57,14/Jul/23 06:00,29/Sep/10 12:58,1.7.5,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"{code}
@Immutable class Foo {
    private static final String BAR = 'baz'
}
{code}

For the above code, the initialization statements for the static field should be added only to <clinit> and not to <init>.

The instructions below are taken from <init> and they show the initialization statements are getting added to instance initializers also, which is wrong.
{noformat}
108 ifeq 136 (+28)
111 ldc #84 <baz>
113 aconst_null
114 invokestatic #54 <org/codehaus/groovy/runtime/ScriptBytecodeAdapter.compareEqual>
117 ifeq 123 (+6)
120 goto 133 (+13)
123 ldc #84 <baz>
125 dup
126 checkcast #86 <java/lang/String>
129 putstatic #88 <Foo.BAR>
132 pop
133 goto 154 (+21)
136 aload_2
137 ldc #89 <4>
139 aaload
140 aload_1
141 invokeinterface #69 <org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty> count 2
146 dup
147 checkcast #86 <java/lang/String>
150 putstatic #88 <Foo.BAR>
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-09-29 10:13:03.0,,,,,,,,,,"0|i2c5xr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Constructor chaining in enums doesn't work,GROOVY-4444,12815352,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,pniederw,pniederw,28/Sep/10 10:52,15/Dec/10 16:57,14/Jul/23 06:00,29/Sep/10 06:18,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Compiler,,,,0,,,,,,"The following code...
{code}
enum Foo {
  ONE(1), TWO(1, 2)
  
  int i
  int j
  
  Foo(int i) {
    this(i, 0) // if we set i and j manually here, all is fine
  }
  
  Foo(int i, int j) {
    this.i = i
    this.j = j
  }
}

def foos = [Foo.ONE, Foo.TWO]
{code}

...causes this exception:
{noformat}
java.lang.ExceptionInInitializerError
    at java.lang.Class.forName0(Native Method)
    at java.lang.Class.forName(Class.java:169)
    at ConsoleScript12.class$(ConsoleScript12)
    at ConsoleScript12.$get$$class$Foo(ConsoleScript12)
    at ConsoleScript12.run(ConsoleScript12:17)
    at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:264)
    at groovy.lang.GroovyShell.run(GroovyShell.java:513)
    at groovy.lang.GroovyShell.run(GroovyShell.java:170)
    at groovy.lang.GroovyShell$run$0.call(Unknown Source)
    at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:890)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
    at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
    at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:149)
    at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
    at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
    at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
    at groovy.lang.Closure.call(Closure.java:276)
    at groovy.lang.Closure.call(Closure.java:271)
    at groovy.lang.Closure.run(Closure.java:354)
    at java.lang.Thread.run(Thread.java:637)
Caused by: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: Foo(java.lang.String, java.lang.Integer, java.lang.Integer)
    at groovy.lang.MetaClassImpl.selectConstructorAndTransformArguments(MetaClassImpl.java:1415)
    at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.selectConstructorAndTransformArguments(ScriptBytecodeAdapter.java:237)
    at Foo.$INIT(ConsoleScript12)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
    at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
    at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.invoke(StaticMetaMethodSite.java:43)
    at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.callStatic(StaticMetaMethodSite.java:99)
    at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallStatic(CallSiteArray.java:48)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:165)
    at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:181)
    at Foo.<clinit>(ConsoleScript12)
    ... 33 more
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-09-28 10:52:42.0,,,,,,,,,,"0|i2cbjb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
null.asBoolean() should be false,GROOVY-4443,12815325,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,guillaume,guillaume,28/Sep/10 09:13,15/Dec/10 16:56,14/Jul/23 06:00,28/Sep/10 09:20,1.7.5,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"As per the thread [groovy-user] Groovy truth and null, null.asBoolean() should return false, not true.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-09-28 09:13:08.0,,,,,,,,,,"0|i2cs33:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
method File.eachFile is not returning full directory content,GROOVY-4441,12815357,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,gorisis,gorisis,27/Sep/10 10:02,15/Dec/10 16:57,14/Jul/23 06:00,30/Sep/10 09:34,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"Hi,

We have got a weird issue. A directory contains several files having extended chars in their filenames due to some changes made on the server back and forth.

When trying to loop of those files with the method File.eachFile(Closure), we will get only the files with names made of ascii chars only, not the others.

We have found a workaround with File.traverse which gives us the full content of the directory.

Can you confirm there is a bug with File.eachFile(Closure) ?

Thx","Linux almach.cc.cec.eu.int 2.6.18-194.3.1.el5 #1 SMP Sun May 2 04:17:42 EDT 2010 x86_64 x86_64 x86_64 GNU/Linux
Red Hat Enterprise Linux Server release 5.5 (Tikanga)
Groovy Version: 1.7.3 JVM: 1.6.0_20",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 29 10:45:50 UTC 2010,,,,,,,,,,"0|i2bwo7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Sep/10 10:15;guillaume;Looking at File#eachFile, I don't see anything that would lead me to think we're not iterating over all the files. We're calling Java's file.listFiles() which I'd expect to return the full list of files.;;;","28/Sep/10 10:19;gorisis;Ok, but can you compare File.traverse and File.eachFile.

There mus be a diff between the two, as on our case, File.traverse successfully reports all the files...;;;","28/Sep/10 16:58;blackdrag;comparing them is not so easy, the traverse version is very complex... let us look at eachFile...
{code}
checkDir(self);
final File[] files = self.listFiles();
// null check because of http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4803836
if (files == null) return;
for (File file : files) {
  if ((fileType != FileType.FILES && file.isDirectory()) ||
      (fileType != FileType.DIRECTORIES && file.isFile())){
    closure.call(file);
  }
}
{code}
let us reduce that to this version:
{code:Java}
public void eachFile(File self) {
  final File[] files = self.listFiles();
  if (files == null) return;
  for (File file : files) {
    System.out.println(file);
  }
}
{code}
Issa, I suggest you try out if this little piece of code does show you all the files or not. If it does, then the only possible error I see is in the if-statement. This way we can maybe pinpoint the problem fast.;;;","29/Sep/10 09:07;gorisis;Yes, the 2nd version is working fine...;;;","29/Sep/10 10:30;guillaume;In the loop, could you print ""File ${file} Dir? ${file.isDirectory()} File? ${file.isFile()}"" and tell us what it gives?
It looks like some files which aren't directories are not considered ""files"" by Java.;;;","29/Sep/10 10:36;gorisis;Right on the spot, the files which method eachFile is not working for are returning both false for the two tests (neither file nor directory).

I guess I should open a bug at Oracle then ?;;;","29/Sep/10 10:37;blackdrag;is it a normal file you can open?;;;","29/Sep/10 10:38;blackdrag;we can still ""fix"" this issue by testing explicitly for FileType.ANY and then skip the other tests;;;","29/Sep/10 10:41;blackdrag;the if would then be 
{code:Java}
(fileType == FileType.ANY ||
 fileType != FileType.FILES && file.isDirectory() ||
 fileType != FileType.DIRECTORIES && file.isFile())
{code}


;;;","29/Sep/10 10:42;gorisis;Here are some outputs

{code}
(CITnet-Acc1@COMREF-107) $ ll
total 388
-rwxrwxrwx 1 studio users 62976 Sep 10 13:15 45521_[EACEA] Autorisation d'accÃ¨s pour NOTIS.msg
-rwxrwxrwx 1 studio users 57856 Sep 10 13:15 45522_[EAHC] Autorisation d'accÃ¨s pour NOTIS.msg
-rwxrwxrwx 1 studio users 97280 Sep 10 13:15 45523_[ERC] Autorisation d'acc?s pour NOTIS.msg
-rwxrwxrwx 1 studio users 65536 Sep 10 13:15 45524_[REA] Autorisation d'acc?s pour NOTIS.msg
-rwxrwxrwx 1 studio users 68096 Sep 10 13:15 45525_[TENEA] Autorisation d'acc?s pour NOTIS.msg
-rw-r--r-- 1 studio users    71 Sep 29 11:45 48730_NewÃ©Ã Ã§Ã Ã¨.txt
-rwxrwxrwx 1 studio users  1419 Sep 27 17:10 ls.class
-rwxrwxrwx 1 studio users   355 Sep 29 17:33 ls.groovy
-rwxrwxrwx 1 studio users  1054 Sep 27 17:10 ls.java
{code}

{code}
(CITnet-Acc1@COMREF-107) $ groovy ls.groovy
45521_[EACEA] Autorisation d'accÃ¨s pour NOTIS.msg
48730_NewÃ©Ã Ã§Ã Ã¨.txt
ls.java
45522_[EAHC] Autorisation d'accÃ¨s pour NOTIS.msg
ls.groovy
ls.class
File /ec/acc/server/citnet/jira/data/jira3/attachments/attachments/COMREF/COMREF-107/45521_[EACEA] Autorisation d'accÃ¨s pour NOTIS.msg Dir? false File? true
File /ec/acc/server/citnet/jira/data/jira3/attachments/attachments/COMREF/COMREF-107/48730_NewÃ©Ã Ã§Ã Ã¨.txt Dir? false File? true
File /ec/acc/server/citnet/jira/data/jira3/attachments/attachments/COMREF/COMREF-107/ls.java Dir? false File? true
File /ec/acc/server/citnet/jira/data/jira3/attachments/attachments/COMREF/COMREF-107/45524_[REA] Autorisation d'accï¿½s pour NOTIS.msg Dir? false File? false
File /ec/acc/server/citnet/jira/data/jira3/attachments/attachments/COMREF/COMREF-107/45522_[EAHC] Autorisation d'accÃ¨s pour NOTIS.msg Dir? false File? true
File /ec/acc/server/citnet/jira/data/jira3/attachments/attachments/COMREF/COMREF-107/45523_[ERC] Autorisation d'accï¿½s pour NOTIS.msg Dir? false File? false
File /ec/acc/server/citnet/jira/data/jira3/attachments/attachments/COMREF/COMREF-107/ls.groovy Dir? false File? true
File /ec/acc/server/citnet/jira/data/jira3/attachments/attachments/COMREF/COMREF-107/ls.class Dir? false File? true
File /ec/acc/server/citnet/jira/data/jira3/attachments/attachments/COMREF/COMREF-107/45525_[TENEA] Autorisation d'accï¿½s pour NOTIS.msg Dir? false File? false
{code}


{code}
(CITnet-Acc1@COMREF-107) $ cat ls.groovy
import java.io.File;

        new File(System.getProperty(""user.dir"")).eachFile { File att ->
                println att.name
        }
self = new File(System.getProperty(""user.dir""))
final File[] files = self.listFiles();
  if (files == null) return;
  for (File file : files) {
    System.out.println(""File ${file} Dir? ${file.isDirectory()} File? ${file.isFile()}"");
  }
{code};;;","29/Sep/10 10:45;gorisis;I have made the test in pure Java, and there is definitely a problem inside the JVM. We're talking about version java version ""1.6.0_20""
Java(TM) SE Runtime Environment (build 1.6.0_20-b02)
Java HotSpot(TM) 64-Bit Server VM (build 16.3-b01, mixed mode)


I will open a issue at Oracle's and see.

Thank for your support!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy Console looking for wrong LAF on Snow Leopard,GROOVY-4440,12815321,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,ctwise,ctwise,27/Sep/10 09:49,14/Aug/13 03:57,14/Jul/23 06:00,10/Nov/11 03:06,1.0,1.0-beta-1,1.0-beta-10,1.0-beta-2,1.0-beta-3,1.0-beta-4,1.0-beta-5,1.0-beta-6,1.0-beta-7,1.0-beta-8,1.0-beta-9,1.0-JSR-1,1.0-JSR-2,1.0-JSR-3,1.0-JSR-4,1.0-JSR-5,1.0-JSR-6,1.0-RC-1,1.0-RC-2,1.1-beta-1,1.1-beta-2,1.1-beta-3,1.1-rc-1,1.1-rc-2,1.1-rc-3,1.5,1.5.1,1.5.2,1.5.3,1.5.4,1.5.5,1.5.6,1.5.7,1.5.8,1.6,1.6.1,1.6.2,1.6.3,1.6.4,1.6.5,1.6.6,1.6.7,1.6.8,1.6.9,1.6-beta-1,1.6-beta-2,1.6-rc-1,1.6-rc-2,1.6-rc-3,1.7.0,1.7.1,1.7.2,1.7.3,1.7.4,1.7.5,1.7.6,1.7-beta-1,1.7-beta-2,1.7-rc-1,1.7-rc-2,1.8-beta-1,1.8-beta-2,1.8-beta-3,3.0.0-alpha-1,1.7.6,1.8-beta-3,,Groovy Console,,,,0,,,,,,The Groovy Console is looking for the wrong LAF on Snow Leopard and not using the OS/X LAF as a result. The code is checking for 'apple.laf.AquaLookAndFeel' but the LAF was moved to 'com.apple.laf.AquaLookAndFeel'. The switch statement is in groovy.ui.ConsoleView.groovy but I assume groovy.ui.view.MacOSXDefaults.groovy and groovy.ui.view.MacOSXMenuBar.groovy will also need to be updated.,Mac OS/X Snow Leopard,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 13 12:36:52 UTC 2010,,,,,,,,,,"0|i2c5zj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Sep/10 10:36;guillaume;When was the laf moved? Was it moved only for Snow Leopard? Or is it for all Leopards? (ie. non-snow as well);;;","27/Sep/10 10:44;ctwise;I'm not sure when it was moved, I just know that I'm running Snow Leopard and it has been moved. Some Googling around indicates it might have been moved in the Java 1.6 timeframe which would seem to indicate all Leopards are affected.

You have a closed task for making this same change to Swing Builder (http://jira.codehaus.org/browse/GROOVY-4230).;;;","13/Oct/10 12:36;aalmiray;Added check for {{'com.apple.laf.AquaLookAndFeel'}}.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Use of an inner enum causes compilation to go into infinite loop,GROOVY-4438,12815303,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,daniel_sun,roshandawrani,roshandawrani,26/Sep/10 00:40,03/Jul/19 06:09,14/Jul/23 06:00,02/May/17 02:12,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.6.0-alpha-1,3.0.0-alpha-1,,class generator,,,,0,,,,,,"The following piece of code causes the compilation to go into infinite loop

{code:title=Groovy Compiler - To infinity and beyond..|titleBGColor=#FF6666}
enum Outer {
    A, B
    enum Inner{X, Y}
}
{code}",,blackdrag,daniel_sun,paulk,,,,,,,,,,"eric-milles commented on pull request #940: GROOVY-4438: enumConstants: reduce ambiguity within loop
URL: https://github.com/apache/groovy/pull/940
 
 
   Allows Eclipse IDE to work with the project.  Without this change, the indexer thread(s) and others get into the infinite loop described in GROOVY-4438.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;28/May/19 17:54;githubbot;600","eric-milles commented on issue #940: GROOVY-4438: enumConstants: reduce ambiguity within loop
URL: https://github.com/apache/groovy/pull/940#issuecomment-496644108
 
 
   **NOTE**: Please hold on merging this.  During additional testing I have found that parsing fails for an enum like this:
   
   ```groovy
   enum Orientation
   {
       LANDSCAPE, PORTRAIT
   
       @Override
       String toString()
       {
           name().toLowerCase().capitalize()
       }
   }
   ```
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;28/May/19 18:55;githubbot;600","eric-milles commented on issue #940: GROOVY-4438: enumConstants: reduce ambiguity within loop
URL: https://github.com/apache/groovy/pull/940#issuecomment-496644108
 
 
   ~**NOTE**: Please hold on merging this.~  During additional testing I have found that parsing fails for an enum like this:
   
   ```groovy
   enum Orientation
   {
       LANDSCAPE, PORTRAIT
   
       @Override
       String toString()
       {
           name().toLowerCase().capitalize()
       }
   }
   ```
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;28/May/19 21:58;githubbot;600","eric-milles commented on issue #940: GROOVY-4438: enumConstants: reduce ambiguity within loop
URL: https://github.com/apache/groovy/pull/940#issuecomment-496644108
 
 
   ~**NOTE**: Please hold on merging this.~  During additional testing I have found that parsing fails for an enum like this:
   
   ```groovy
   enum Orientation
   {
       LANDSCAPE, PORTRAIT
   
       @Override
       String toString()
       {
           name().toLowerCase().capitalize()
       }
   }
   ```
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;06/Jun/19 16:11;githubbot;600","asfgit commented on pull request #940: GROOVY-4438: enumConstants: reduce ambiguity within loop
URL: https://github.com/apache/groovy/pull/940
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;03/Jul/19 06:09;githubbot;600",,,,,,,,,,,,,0,3000,,,0,3000,,GROOVY-9184,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 24 16:48:33 UTC 2017,,,,,,,,,,"0|i2c4sn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Dec/11 03:25;melix;Seems to be a parsing issue: infine loop is in GroovyRecognizer.;;;","29/Mar/13 04:21;paulk;Workaround (if you don't have a constructor, method or field) is to add a semicolon.;;;","21/Aug/13 06:32;blackdrag;setting fix version to 4.0 for now to reflect the parser change maybe needed here;;;","24/Jan/17 16:48;daniel_sun;Fixed in the parrot branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static import don't work in scripts in default packages,GROOVY-4437,12815323,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,roshandawrani,roshandawrani,25/Sep/10 23:59,26/Dec/10 21:40,14/Jul/23 06:00,26/Dec/10 21:38,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,1,,,,,,"{code:title=Test.groovy}
/* both the .* or .foo/.bar ways of static importing don't work
import static Helper.*

//import static Helper.foo
//import static Helper.bar
 
println foo() // fails MissingMethodException
println bar // fails MissingPropertyException
{code}
{code:title=Helper.groovy}
class Helper {
    static foo(){
        println 'foo called'
    }
    static bar = 'bar'
}
{code}

But the following static import, which uses a class under a package, works:
{code}
import static java.lang.Integer.*
println MIN_VALUE
{code}",,gjoseph,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 26 21:38:58 UTC 2010,,,,,,,,,,"0|i2bv4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Nov/10 08:28;gjoseph;dupe of GROOVY-4386 ?;;;","23/Nov/10 08:35;roshandawrani;Not sure - the conditions causing it in this issue seem a little different, so can't confirm the duplication without investigating further. Static imports have been very fluid for some time and there are many slight variants exposing different kinds of issues.

Maybe we the 2 issues can be linked and if the underlying reason turns out to be the same, they can be marked fixed together.;;;","26/Dec/10 21:38;paulk;This appears to be fixed with GROOVY-4386.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inconsistent handling of final fields,GROOVY-4435,12815282,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,24/Sep/10 12:56,15/Dec/10 16:56,14/Jul/23 06:00,29/Sep/10 14:39,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"Snippets v1 and v2 below are equivalent but v1 compiles and v2 does not. v1 should also not compile.

{code:title=v1|borderStyle=dashed|titleBGColor=#FFFFCE}
class Test {
    private final String prop = """"
    void setProp(val) {
        this.prop = val /* compiles, when it shouldn't */
    }
}
{code}

{code:title=v2|borderStyle=dashed|titleBGColor=#F7D6C1}
class Test {
    private final String prop = """"
    void setProp(val) {
        prop = val /* correctly fails to compile saying ""cannot modify final field 'prop'"" */
    }
}
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-09-24 12:56:40.0,,,,,,,,,,"0|i2bv73:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java stub generator doesn't use FQN for annotation values,GROOVY-4434,12815337,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,roshandawrani,pniederw,pniederw,23/Sep/10 17:37,04/Jan/12 19:32,14/Jul/23 06:00,11/Oct/10 12:46,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Compiler,,,,1,,,,,,"After upgrading our app from 1.7.4 to 1.7.5, we got several (joint) compile errors for seemingly simple Groovy classes. Looking at the generated stub code, I found that imports for annotations were always missing. After debugging groovyc, I found the following:

AntlrParserPlugin:333: addImport() is called with alias==null, which is correct since no import alias is used
ASTHelper:131: if(aliasName==null) aliasName=name // now alias is non-null
JavaStubGenerator:679: if (imp.getAlias() == null) imports.add(...); // because getAlias() is non-null, import isn't added
 
Code example:

{code}
import foo.Foo // details of Foo don't matter
   
@Foo
class Bar {} 
{code}

For GMaven users this means that if just one Groovy class in the whole project contains an annotation, the project cannot be compiled.",,gorshing,jstell,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Sep/10 13:29;roshandawrani;4434_v18x.diff;https://issues.apache.org/jira/secure/attachment/12722587/4434_v18x.diff",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 11 18:31:25 UTC 2010,,,,,,,,,,"0|i2bndj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Sep/10 07:58;pniederw;Correction: The problem isn't the missing imports for the annotation types themselves (because the stub generator now uses fully qualified class names for them), but the missing imports for class names appearing in annotation attributes. Example:

{code}
package bar

import foo.Foo
import other.MyEnum

// generated stub code: @foo.Foo(MyEnum.MY_VALUE)
@Foo(val = MyEnum.MY_VALUE)
class Bar {}
{code}

Same problem exists for variations like {{@Foo(val=MyClass)}} and {{@Foo(val=MyClass.SOME_CONST)}}.
;;;","30/Sep/10 11:47;blackdrag;shouldn't the stub generator use fully qualified names there too then?;;;","30/Sep/10 12:52;pniederw;Maybe. I don't know the exact reason for the switch to fully qualified class names in 1.7.5, and if it's done for all class names.;;;","30/Sep/10 13:29;roshandawrani;Attaching a patch that fixes the 3 related issues highlighted in here.;;;","30/Sep/10 13:37;guillaume;Looking great!;;;","11/Oct/10 10:47;pniederw;I'm still getting the same problem with https://svn.codehaus.org/groovy/branches/GROOVY_1_7_Xtrunk, rev. 20934:

foo/MyAnno.java:
{code}
package foo;

public @interface MyAnno {
  MyEnum val();
}
{code}

foo/MyEnum.java:
{code}
package foo;

public enum MyEnum { ONE, TWO }
{code}

bar/MyUser.groovy:
{code}
package bar

import foo.MyAnno
import foo.MyEnum

@MyAnno(val = MyEnum.ONE)
class MyUser {}                  
{code}

Generated stub for class MyUser:
{code}
package bar;

import java.lang.*;
import java.io.*;
import java.net.*;
import java.util.*;
import groovy.lang.*;
import groovy.util.*;

@foo.MyAnno(val=MyEnum.ONE) public class MyUser
  extends java.lang.Object  implements
    groovy.lang.GroovyObject {
public MyUser
() {}
public  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}
public  void setMetaClass(groovy.lang.MetaClass mc) { }
public  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}
public  java.lang.Object getProperty(java.lang.String property) { return null;}
public  void setProperty(java.lang.String property, java.lang.Object value) { }
}
{code}

Compile error:
{noformat}
[ERROR] /swd/prj/joints/target/generated-sources/groovy-stubs/main/bar/MyUser.java:[10,16] cannot find symbol
symbol: variable MyEnum
@foo.MyAnno(val=MyEnum.ONE) public class MyUser

[ERROR] /swd/prj/joints/target/generated-sources/groovy-stubs/main/bar/MyUser.java:[10,22] an enum annotation value must be an enum constant
{noformat};;;","11/Oct/10 11:22;roshandawrani;I just ran the following test on trunk and stub gets generated just fine. You want to check what's wrong with your thing?

{code}
package org.codehaus.groovy.tools.stubgenerator

class Test4434Again extends StringSourcesStubTestCase {

    Map<String, String> provideSources() {
        debug = true
        delete = false
        [
            'foo/MyAnno.java': '''
                package foo;

                public @interface MyAnno {
                  MyEnum val();
                }
            ''',
            'foo/MyEnum.java': '''
                package foo;

                public enum MyEnum { ONE, TWO }
            ''',
            'bar/MyUser.groovy': '''
                package bar

                import foo.MyAnno
                import foo.MyEnum
                
                @MyAnno(val = MyEnum.ONE)
                class MyUser {}
            '''
        ]
    }

    void verifyStubs() {
        // all is well
    }
}
{code}

Here is how the stub gets generated (notice the part - @foo.MyAnno(val=foo.MyEnum.ONE) )
{noformat}
Sources compiled successfully
>>> Stubs generated
 -> MyUser.java
package bar;

import java.lang.*;
import java.io.*;
import java.net.*;
import java.util.*;
import groovy.lang.*;
import groovy.util.*;

@foo.MyAnno(val=foo.MyEnum.ONE) public class MyUser
  extends java.lang.Object  implements
    groovy.lang.GroovyObject {
public MyUser
() {}
public  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}
public  void setMetaClass(groovy.lang.MetaClass mc) { }
public  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}
public  java.lang.Object getProperty(java.lang.String property) { return null;}
public  void setProperty(java.lang.String property, java.lang.Object value) { }
}
{noformat};;;","11/Oct/10 11:30;pniederw;No idea what's going on then. I'm definitely using the latest 1.7.6-SNAPSHOT. The only difference is that I'm building with GMaven because I don't know of a good way to diagnose joint compilation problems with groovyc (other than with a debugger).;;;","11/Oct/10 11:34;roshandawrani;I have no idea about GMaven. 

The new joint compilation test infrastructure is one of my favorite pieces in groovy now!

Please run that test I have provided and tell me how the stub gets generated. If that is fine, the GMaven bit needs to be taken forward outside this JIRA issue.;;;","11/Oct/10 12:05;pniederw;All tests passed. No idea how I can find this test in the JUnit report because class names are missing in the report, but I assume it got run.;;;","11/Oct/10 12:10;roshandawrani;Which all tests? (if you mean the ones that are checked-in, of-course they pass!)

If u run the one test I provided just a few minutes back, it is run with 2 flags (debug = true, delete = false), which means that it will output stub code created and also leave the stub file un-deleted, which you should be able to go and inspect.

Both with trunk and 1.7.6, the code generated is fine.;;;","11/Oct/10 12:16;pniederw;> Which all tests?
All existing tests, plus the one you provided. I just added it to the sources (locally).

> If u run the one test I provided just a few minutes back
How do I run a single test class in the Ant build? Running tests in the Groovy project from IDEA is always problematic.;;;","11/Oct/10 12:21;roshandawrani;> How do I run a single test class in the Ant build? Running tests in the Groovy project from IDEA is always problematic.

Set testCase=<full test class name> in build.properties;;;","11/Oct/10 12:25;pniederw;Thanks for the Ant hint. I've meanwhile managed to run the test from IDEA and it passes. Output looks fine. Seems I'll have to debug GMaven again.;;;","11/Oct/10 12:29;pniederw;By the way, ""ant test -DtestCase=org.codehaus.groovy.tools.stubgenerator.Test4434Again"" also works.;;;","11/Oct/10 12:29;roshandawrani;Great. So I will mark this one back as Resolved since it's in GMaven domain now?;;;","11/Oct/10 12:31;guillaume;Btw, for running a single test, on the command-line, you can do:
{code}
ant -DtestCase=groovy.bugs.ABug test
{code};;;","11/Oct/10 12:38;pniederw;> Great. So I will mark this one back as Resolved since it's in GMaven domain now?
Do as you please. Depending on my findings, I will reopen, add a GMaven issue, or bang my head against the wall (if it's a problem with my setup).;;;","11/Oct/10 12:42;roshandawrani;Reopen anytime you can be sure it is a core groovy issue, but don't just pick blindly from your 3 choices and reopen :-);;;","11/Oct/10 12:46;roshandawrani;Not a core groovy issue - explained why/how.;;;","11/Oct/10 18:31;pniederw;Looking at this with the debugger, the only explanation I have is that GMaven's JavaStubCompilationUnit behaves slightly differently than groovyc's JavaAwareCompilationUnit (JavaStubCompilationUnit vs. JavaAwareCompilationUnit is the only difference in the stack trace). With groovyc, AST for annotation attribute value {{MyEnum.ONE}} looks like this:

{noformat}
org.codehaus.groovy.ast.expr.PropertyExpression@4cdf4bfc[object: org.codehaus.groovy.ast.expr.ClassExpression@57f5b4d1[type: foo.MyEnum] property: ConstantExpression[ONE]]
{noformat}

But with GMaven, it looks like this:
{noformat}
org.codehaus.groovy.ast.expr.PropertyExpression@65f4ba51[object: org.codehaus.groovy.ast.expr.VariableExpression@25f45022[variable: MyEnum] property: ConstantExpression[ONE]]
{noformat}

I've opened GMAVEN-84.;;;",,,,,,,,,,,,,,,,,,,,,,,,
Groovy Console binding's output-transform missing yields a stacktrace when context is cleared,GROOVY-4431,12815338,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,guillaume,guillaume,23/Sep/10 08:37,15/Dec/10 16:56,14/Jul/23 06:00,23/Sep/10 08:42,1.7.5,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"The Groovy Console uses a mechanism that users can use to define visual representations of outputs in the console (for instance displaying a map in the form of a JTable).

Such ""output transforms"" are stored in a special variable in the binding.

When calling the ""clear context"" action, a new binding is created, but the output transforms variable is not added back to the binding. And when you execute a script which will yield some resulting output, Groovy Console won't find the output transforms variable, and will throw a stacktrace complaining about that.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-09-23 08:37:07.0,,,,,,,,,,"0|i2cl1b:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Verify Error when using wrong enum syntax,GROOVY-4430,12815329,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,pniederw,pniederw,23/Sep/10 07:03,22/Sep/13 03:50,14/Jul/23 06:00,22/Sep/13 03:50,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0.0,,,Compiler,,,,0,,,,,,"I've tried to declare an enum and made the mistake to put the constructor before the values:

{code}
enum Foo {
  Foo(String str) {}, // first I tried with ; but this got me some other error
  ONE(""one""), TWO(""two"")
}
{code}

What got me distracted is that Groovy throws a VerifyError here:

java.lang.VerifyError: (class: Foo, method: <clinit> signature: ()V) Unable to pop operand off an empty stack",,paulk,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 22 03:50:32 UTC 2013,,,,,,,,,,"0|i2cct3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Sep/10 13:32;roshandawrani;Following snippet also reproduces the VerifyError

{code}
enum Foo {
    Foo(String str) {}
}
{code};;;","23/Sep/10 14:04;roshandawrani;And it looks like an enum-grammar issue because instead of getting declared as constructor in both the above examples, Foo gets defined as an enum constant.;;;","29/Jun/11 06:04;paulk;the above examples seem to be ok on trunk - should we close this issue?;;;","29/Jun/11 06:07;blackdrag;does it work in 1.7 now as well? I would suggest to at least add a testcase;;;","29/Jun/11 06:42;paulk;Hmmm? I was using below as my testcase in the Groovy Console. But this seems to work even in 1.7.5 so perhaps I am doing something wrong?
{code}
enum Bar {
  Bar(String str) {}, // first I tried with ; but this got me some other error
  ONE(""one""), TWO(""two"")
}
enum Foo {
    Foo(String str) {}
}
println 'done'
{code}
;;;","29/Mar/13 03:07;paulk;After recent changes the following:
{code}
enum Foo {
  ONE(""x"") { }  // enum const but note missing constructor
}
{code}
produces this compilation error:
{noformat}
java.lang.ExceptionInInitializerError
  ...
Caused by: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: Foo$1(java.lang.String, java.lang.Integer, java.lang.String)
  ...
{noformat}
which, while not a fantastic error message, seems consistent with how Groovy implements enums.

Replacing ""ONE"" with ""Foo"" yields the same result.

Replacing the supplied String param with ""String str"" has the same exception with this cause:
{noformat}
java.lang.ExceptionInInitializerError
  ...
Caused by: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: Foo$1(java.lang.String, java.lang.Integer, null)
  ...
{noformat}
So, perhaps this isn't too bad now?

Incidentally, the code below works (although it may not win many style points):
{code}
enum Foo {
  Foo(""x"") { }          // enum constant also called Foo
  Foo(String str) { }   // constructor of Foo
}
assert Foo.values() == [Foo.Foo]
{code};;;","22/Sep/13 03:50;pschumacher;After reading the comments I guess this was fixed and can be closed. If somebody disagrees please reopen. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
An Interface nested within a class fails to parse.,GROOVY-4422,12815302,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,jwadamson,jwadamson,17/Sep/10 13:48,15/Dec/10 16:56,14/Jul/23 06:00,03/Oct/10 06:15,1.7.4,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Compiler,,,,0,,,,,,"Attempting to compile/evalute the following groovy code
{code:java}
 public class Foo {
   static public class Bar {}
   static public interface Baz {}
 }
{code}
produces
{quote}
1 compilation error:
 Unknown type: INTERFACE_DEF at line: 3 column: 3. File: ConsoleScript8 at line: 3, column: 3
{quote}",,jwadamson,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Oct 03 06:15:04 UTC 2010,,,,,,,,,,"0|i2c6lz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Oct/10 06:15;roshandawrani;Done;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unqualified reference in subclass static method to superclass static fields fails to compile,GROOVY-4418,12815309,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,astral,astral,14/Sep/10 09:06,15/Dec/10 22:19,14/Jul/23 06:00,15/Sep/10 00:30,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,,,,,0,,,,,,"{code:title=Base.groovy}
public class Base {
    
    public static String field;

}
{code}

{code:title=Subclass.groovy}
public class Subclass extends Base {
    
    static void method() {
        System.out.println(field);
    }

}
{code}

I get a compile error stating:

Groovy:Apparent variable 'field' was found in a static scope but doesn't refer to a local variable, static field or class. Possible causes:	... Subclass.groovy	line 8

If I rename Subclass.groovy to Subclass.java, it compiles fine. If I fully qualify field with Base.field or this.field, it compiles fine. However, unqualified access, as above, produces an error.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 14 19:54:52 UTC 2010,,,,,,,,,,"0|i2bvtb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Sep/10 18:14;paulk;Trunk doesn't have this problem but the 1_7_X branch does.;;;","14/Sep/10 19:54;paulk;Looks like a mishap when merging an earlier issue fix from trunk and the only test in trunk doubles up as a test on a 1.8 feature so wasn't merged back into the 1.7 branch. I'll merge the fix now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Accessing outer properties/methods from inner classes results in NPE,GROOVY-4416,12815319,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,13/Sep/10 04:11,15/Dec/10 22:19,14/Jul/23 06:00,13/Sep/10 06:33,1.7.4,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,,,,,0,,,,,,"The outer property access and method invocations from inner class seem to be resulting in NPE, as shown by examples below:

Case 1: Outer property access from inner class
{code}
class ReflectionToolboxTest {
   static final PROPERTY_VALUE = ""property_value""
   class Bean {
       String property = PROPERTY_VALUE
   }

   def bean = new Bean()
}

def test = new ReflectionToolboxTest()
{code}
results in
{noformat}
java.lang.NullPointerException
    at ReflectionToolboxTest$Bean.propertyMissing(Script1.groovy)
    at ReflectionToolboxTest$Bean.<init>(Script1.groovy)
    at ReflectionToolboxTest.<init>(Script1.groovy:7)
    at Script1.run(Script1.groovy:10)
{noformat}
Case 2: Outer method access from inner class
{code}
class Dummy {
   def foo(){}
   class Bean {
       String property = foo()
    }
   def bean = new Bean()
}
new Dummy()
{code}
results in
{noformat}
java.lang.NullPointerException
    at Dummy$Bean.methodMissing(Script1.groovy)
    at Dummy$Bean.<init>(Script1.groovy:4)
    at Dummy.<init>(Script1.groovy:6)
    at Script1.run(Script1.groovy:8)
{noformat}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-09-13 04:11:14.0,,,,,,,,,,"0|i2bw9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error implementing a Java or Groovy generic interface,GROOVY-4415,12815332,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,lucianogreiner,lucianogreiner,12/Sep/10 20:44,24/Dec/11 03:08,14/Jul/23 06:00,29/Nov/11 11:15,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.5,2.0-beta-2,,,,,0,,,,,,"Hello.

  I have an issue creating a Groovy class implementing an interface coded in Java with Generics:
Here is the code:
{code}
/* Java interface */
public interface Entity<T> {
	T getId();	
}

/* Groovy class */
class Car implements Entity<Long> {
      Long id;
}
{code}
Car groovy class has a Long getId() method already, but it doesn't recognize it's enough to implement the interface method:
""Can't have an abstract method in a non-abstract class. The class 'Car' must be declared abstract or the method 'java.lang.Object getId()' must be implemented.""

The same happens when the interface is coded in Groovy instead of Java.

I believe it's an important thing to support.

I am using Groovy 1.7.3.

Thank you.",Groovy 1.7.3 - Eclipse ,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4645,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 29 11:12:28 UTC 2011,,,,,,,,,,"0|i2c0n3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Nov/11 11:12;melix;Formatting tags;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
unaryMinus fails for Short and Byte,GROOVY-4414,12815341,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,dsrkoc,dsrkoc,11/Sep/10 16:24,05/Apr/15 14:44,14/Jul/23 06:00,12/Sep/10 02:53,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,,,,,0,,,,,,"The code:
{code}
Short s = 1
println(-s)
{code}
fails with the following exception:
{{groovy.lang.MissingMethodException: No signature of method: java.lang.Short.negative() is applicable for argument types: () values: []}}

This happens because {{org.codehaus.groovy.runtime.InvokerHelper#unaryMinus}} doesn't negate {{Short}} and {{Byte}} directly, but falls through to a call to non-existent function {{negative}} on those objects.

Please find attached a patch for a test case ({{InvokerHelperTest}}), and a patch for a proposed fix.

The patches are done with git, hope this is OK. If it isn't, please let me know for future reference.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Sep/10 16:24;dsrkoc;InvokerHelper.patch;https://issues.apache.org/jira/secure/attachment/12722453/InvokerHelper.patch","11/Sep/10 16:24;dsrkoc;InvokerHelperTest.patch;https://issues.apache.org/jira/secure/attachment/12722452/InvokerHelperTest.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Sun Sep 12 02:53:27 UTC 2010,,,,,,,,,,"0|i2cp7j:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Sep/10 17:01;roshandawrani;The patches created using svn would be more convenient as that is what groovy uses as of now. However, it is not a big problem for small patches :-)

Thanks for investigating it and supplying the patch.;;;","12/Sep/10 02:53;roshandawrani;Patch applied. {{unaryPlus}} calls also had the same issue. 

{code}
Short s = 1
println(+s)
{code}
was failing with
{noformat}
groovy.lang.MissingMethodException: No signature of method: java.lang.Short.positive() is applicable for argument types: () values: []
{noformat}
Those are also fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
FindBugs errors for new Integer() vs. Integer.valueOf() like calls,GROOVY-4412,12815292,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,11/Sep/10 13:06,15/Dec/10 22:19,14/Jul/23 06:00,11/Sep/10 16:56,1.7.5,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,,,,,0,,,,,,"Groovy compiler seems to be generating calls like {{ new Integer() }} and {{ new Long() }} (also for other number wrapper types), which FindBugs tool calls out as performance issues and suggests that the equivalent calls {{ Integer.valueOf() }} and {{ Long.valueOf() }} be used.

Class generation needs to change a bit to support it to reduce the errors reported by FindBugs for groovy classes.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4152,,,,,,"11/Sep/10 13:16;roshandawrani;4412_v18x.diff;https://issues.apache.org/jira/secure/attachment/12722451/4412_v18x.diff","11/Sep/10 14:47;roshandawrani;v2_4412_v18x.diff;https://issues.apache.org/jira/secure/attachment/12722580/v2_4412_v18x.diff",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Sep 11 15:27:22 UTC 2010,,,,,,,,,,"0|i2c7y7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Sep/10 13:16;roshandawrani;Patch attached for review.;;;","11/Sep/10 14:00;blackdrag;the patch looks mostly good to me... good but one point... may I suggest to split the number case in such with valueOf and those with constructor to handle the constructor version like in BigDecimal before the remaining mnumber cases? Then we can use for int, long and such also the full signature instead of having to build it there every time.;;;","11/Sep/10 14:47;roshandawrani;Silly mistake. It was like trading one performance issue for another due to those string concatenations.

I am attaching the revised patch.;;;","11/Sep/10 15:19;blackdrag;well that was a performance bug in the compiler instead of the generated class...anyway.. ehm.. I hope you don't fell annoyed yet, but I was actually thinking about checking for the Bigs before the others and then only check for Number before breaking up into the concrete parts for Short Integer and such.

Meaning more or less the reverse order of what you have;;;","11/Sep/10 15:27;roshandawrani;No problem. Since that if-else cannot have a 3rd branch, I will reverse the order and check-in. :-);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassFormatError extending generic interface that has a method with an Array argument returning the generic type,GROOVY-4410,12815328,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,achuggardlee,achuggardlee,10/Sep/10 18:40,15/Dec/10 22:19,14/Jul/23 06:00,14/Sep/10 06:40,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,,,,,2,,,,,,"Real world example where I run into this... javax.ws.rs.ext.MessageBodyReader<T>

Basically what happens is that a duplicate method marked ""public bridge synthetic"" method (according to jclasslib bytecode viewer) is generated after the <clinit> with an few extras in the method signature:

(L[Ljava/lang/String;;)Ljava/lang/Object;

The first (correct generated method) has the proper signature:

([Ljava/lang/String;)Ljava/lang/Object;

But changing the return type from the overridden generic type, to def or Object eliminates this extra method (and thus the issue disappears as well). hence the minor classification.

Attached:
Producer.java (simple interface)
StringProducer.groovy (bad food)
HackProducer.groovy (good food)
MainClass.java (test case)","Groovy 1.7.4 
Sun JDK 1.6.0_18
Windows 7",achuggardlee,kpshek,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Sep/10 18:40;achuggardlee;ArrayBug.zip;https://issues.apache.org/jira/secure/attachment/12722691/ArrayBug.zip","11/Sep/10 09:21;achuggardlee;non-generic.zip;https://issues.apache.org/jira/secure/attachment/12722579/non-generic.zip",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Sep 11 09:21:46 UTC 2010,,,,,,,,,,"0|i2coav:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Sep/10 09:21;achuggardlee;Actually figured out it doesn't have to do with generics, but with returning a subtype in the overriding method implementation. (Generics make it more likely that one would do this though). In the attached file I've changed Producer to be non generic and gimme to return Object. Having the implementing interface return String still results in the issue, but Object does not. I've also included a .java for comparison. The generated bytecode of the java file has the bridge method, but with the proper signature. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy snapshot source archives for 1.8 beta-1 and beta-2 are having everything packaged twice,GROOVY-4409,12815299,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,10/Sep/10 08:56,15/Dec/10 22:20,14/Jul/23 06:00,14/Sep/10 01:51,1.8-beta-1,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-2,,,,,,,0,,,,,,"The source archives at for 1.8.0 beta-1 and beta-2 both are having all the files duplicated.
* http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all/1.8.0-beta-1-SNAPSHOT/groovy-all-1.8.0-beta-1-SNAPSHOT-sources.jar
* http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all/1.8.0-beta-2-SNAPSHOT/groovy-all-1.8.0-beta-2-SNAPSHOT-sources.jar

The source archive for 1.7.5 is correct (for cross-checking)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-09-10 08:56:20.0,,,,,,,,,,"0|i2cgsn:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy truth of groovy.util.slurpersupport.NoChildren should be false,GROOVY-4408,12815335,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,lhotari,lhotari,10/Sep/10 05:24,15/Dec/10 22:19,14/Jul/23 06:00,12/Sep/10 20:30,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,XML Processing,,,,0,,,,,,"Add a ""asBoolean"" method to NoChildren so that it's groovy truth will evaluate as false.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 12 20:30:14 UTC 2010,,,,,,,,,,"0|i2ctqf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Sep/10 20:30;paulk;Fixed. Thanks for the suggestion.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Script extension set on groovyc does not flow down to the CompilerConfiguration,GROOVY-4406,12815300,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,08/Sep/10 21:00,15/Dec/10 16:57,14/Jul/23 06:00,03/Oct/10 08:16,1.7.5,1.8-beta-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"Groovyc supports an attribute called scriptExtension, that is used to compile the files with that particular extension instead of standard *.groovy extension.

It seems like Groovyc doesn't pass this information to CompilerConfiguration - in forked or non-forked compilation both, which continues to see as ""*.groovy"" always and it may cause to compilation inconsistencies.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-09-08 21:00:38.0,,,,,,,,,,"0|i2cbef:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Variable scope of BlockStatement getting lost inside ReturnAdder,GROOVY-4404,12815308,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,werdna,werdna,07/Sep/10 23:06,15/Dec/10 22:19,14/Jul/23 06:00,08/Sep/10 06:21,1.7.4,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,class generator,,,,0,,,,,,"Inside of of ReturnAdder, there is the code:

{code}
BlockStatement newBlock = new BlockStatement();
newBlock.setVariableScope(node.getVariableScope());
{code}

This is meant to ensure that the variable scope of the new block statement has the appropriate variable scope.  However, node is of type MethodNode.  The code block should be as follows:


{code}
BlockStatement newBlock = new BlockStatement();
Statement code = node.getCode();
if (code instanceof BlockStatement) {
  newBlock.setVariableScope(((BlockStatement) code).getVariableScope());
}
{code}

If code is not of type BlockStatement, then we don't need to set the variable scope.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 08 06:21:47 UTC 2010,,,,,,,,,,"0|i2clhr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Sep/10 23:08;werdna;Forgot to mention that this is in method addReturnIfNeeded at line 40.;;;","08/Sep/10 06:21;guillaume;Thank you Andrew!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Delegate broken in Groovy 1.8.0-beta-2-SNAPSHOT,GROOVY-4397,12815316,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,tim_yates,tim_yates,07/Sep/10 03:22,15/Dec/10 22:31,14/Jul/23 06:00,15/Oct/10 08:10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,groovy-jdk,,,,0,,,,,,"Running this with Groovy pre 1.8.0 works:

{code}
class ListDelegate {
  @Delegate List aList = []
}

def list = new ListDelegate() << 'a' << 'b' << 'c'
{code}

to give:

{code}
Result: [""a"", ""b"", ""c""]
{code}

However, on the GroovyWebConsole (running Groovy 1.8.0-beta-2-SNAPSHOT), it gives the following exception:

{code}
java.lang.NullPointerException
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:321)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:303)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:351)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:172)
	at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:93)
	at Script1.run(Script1.groovy:5)
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4391,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 15 08:10:54 UTC 2010,,,,,,,,,,"0|i2bx7r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Sep/10 03:27;guillaume;It's working with the latest 1.8-beta-2 code from trunk on my machine... hmmm... perhaps that's just a problem on the Groovy Web Console?;;;","07/Sep/10 03:32;guillaume;Even just the following seems to fail on Google App Engine:
{code}
class ListDelegate {
  @Delegate List aList = []
}

def list = new ListDelegate()
{code}
No need to append anything to the delegate.
And I don't see anything in the logs of GAE.
No idea what's going on.;;;","02/Oct/10 08:49;roshandawrani;I think this failure is similar to what Hamlet/Marlyn have faced on their attempt to support OpenJDK 7.

Google App Engine JDK ('java.version' == 1.6.0-google-internal on groovy web console) is also a derivative of OpenJDK, I believe, and hence this error.;;;","07/Oct/10 15:11;roshandawrani;Guillaume, can you update the Groovy Web Console to 1.8.0-beta-3 snapshot? This error should be fixed now.;;;","08/Oct/10 08:44;roshandawrani;Fix of GROOVY-4391 should have fixed this too.

Waiting for update of groovy library on groovy web console to verify it.;;;","15/Oct/10 08:10;roshandawrani;Fixed through GROOVY-4391;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JavaStubGenerator doesn't properly generate annotations with properties of array type,GROOVY-4394,12811696,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,gfouquet,gfouquet,06/Sep/10 08:45,15/Dec/10 22:19,14/Jul/23 06:00,12/Sep/10 04:59,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,Stub generator / Joint compiler,,,,0,,,,,,"Annotation properties of array type are generated with null walue in java stubs. Subsequently, stub compilation fail.

For example : 

{code}
// ArrayAnnotation.java
public @interface ArrayAnnotation {
String[] value() default {};
}

// AnnotatedClass.groovy
@ArrayAnnotation([""foo"", ""bar""])
class AnnotatedClass { }
{code}

generates the stub : 

{code}
@ArrayAnnotation(value=null)
public class AnnotatedClass extends java.lang.Object implements groovy.lang.GroovyObject {
// irrelevent stuff removed
}
{code}

Compilation fails with the message : 
{code}
Compilation failure: \...\target\generated-sources\groovy-stubs\main\groovystubs\AnnotatedClass.java:[4,23] attribute value must be constant
{code}",jdk 1.6.0_18,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"09/Sep/10 06:22;paulk;groovy4394_javastubgenarrays.patch;https://issues.apache.org/jira/secure/attachment/12722690/groovy4394_javastubgenarrays.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 12 04:59:31 UTC 2010,,,,,,,,,,"0|i2cjq7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Sep/10 06:22;paulk;proposed patch attached;;;","12/Sep/10 04:59;paulk;Patch fixes the immediate problem.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
asymmetry of closure parameter type among String#replaceAll/String#eachMatch/Pattern#each,GROOVY-4392,12815287,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,uehaj,uehaj,05/Sep/10 09:25,15/Dec/10 16:56,14/Jul/23 06:00,21/Sep/10 10:52,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,groovy-jdk,,,,0,,,,,,"The closure which passed to String#replaceAll() takes arguments in two patterns:

1) Object[]
2) Arguments correspond to matcher's group(0), group(1), group(2) ...

but the closure for Pattern#match(Closure) and String#eachMatch(Closure) takes:

1) List
2) Arguments correspond to matcher's group(0), group(1), group(2) ...

So there is an asymmetry about 1).

If this issue should be fixed, IMHO, to change replaceAll() to take a list like
match/eachMatch is better. Because you can write simply:
{code}
assert ""ABDE"" == ""abcdef"".replaceAll(/(..)(.)/) { it[1].toUpperCase() } // (A)
{code}
rather than:
{code}
assert ""ABDE"" == ""abcdef"".replaceAll(/(..)(.)/) { Object[] it -> it[1].toUpperCase() } //(B)
{code}
(A) is same as: 
{code}
assert ""ABDE"" == ""abcdef"".replaceAll(/(..)(.)/) { List it -> it[1].toUpperCase() } // (C)
{code}

I attach small patch for 1.8-trunk and some test cases for this.
This patch leads small backward-incompatibility so that (B) would fail because
of the difference of parameter type of the closure. But current test cases
don't include this.",MacOS X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"05/Sep/10 09:25;uehaj;patch;https://issues.apache.org/jira/secure/attachment/12722450/patch","18/Sep/10 10:34;uehaj;patch2;https://issues.apache.org/jira/secure/attachment/12722454/patch2","21/Sep/10 09:50;uehaj;patch3;https://issues.apache.org/jira/secure/attachment/12722694/patch3",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 21 10:52:39 UTC 2010,,,,,,,,,,"0|i2caqv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"05/Sep/10 23:26;uehaj;> This patch leads small backward-incompatibility

by checking the parameter type of the the replacement closure,
we can avoid this backward-incompatibility.

pseudo code is:
{code}
if (the closure's parameter is Object[]) {
    replacement = InvokerHelper.toString(closure.call(groups.toArray()));
}
else {
    replacement = InvokerHelper.toString(closure.call(groups));
}
{code}
;;;","15/Sep/10 09:56;guillaume;Do you have an updated patch including your comment on backward-incompatibility?;;;","18/Sep/10 10:31;uehaj;Yes I have.
I added testcases for Object[] pattern for backward compatibility check.

;;;","18/Sep/10 10:34;uehaj;patch which accepts the closure whose parameter is Object[] for backward compatibility.
I appreciate your consideration.;;;","18/Sep/10 14:51;guillaume;Thank you, I'll integrate your patch soon!;;;","20/Sep/10 10:31;guillaume;Did you make some other changes?
Running the Groovy build with those changes, and I get 2 failing tests:
{code}
Testcase: testReplaceAllClosure took 0,007 sec
	Caused an ERROR
assert ""1 a 2 b 3 c 4"".replaceAll(""\\p{Digit}"") {it * 2} == ""11 a 22 b 33 c 44""
                       |                                 |
                       [1, 1] a [2, 2] b [3, 3] c [4, 4] false
Assertion failed: 

assert ""1 a 2 b 3 c 4"".replaceAll(""\\p{Digit}"") {it * 2} == ""11 a 22 b 33 c 44""
                       |                                 |
                       [1, 1] a [2, 2] b [3, 3] c [4, 4] false

	at org.codehaus.groovy.runtime.InvokerHelper.assertFailed(InvokerHelper.java:386)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.assertFailed(ScriptBytecodeAdapter.java:662)
	at groovy.GroovyMethodsTest.testReplaceAllClosure(GroovyMethodsTest.groovy:513)

Testcase: testReplaceAllClosurePattern took 0,002 sec
	Caused an ERROR
assert ""1 a 2 b 3 c 4"".replaceAll(~""\\p{Digit}"") {it * 2} == ""11 a 22 b 33 c 44""
                       |          |                       |
                       |          \p{Digit}               false
                       [1, 1] a [2, 2] b [3, 3] c [4, 4]
Assertion failed: 

assert ""1 a 2 b 3 c 4"".replaceAll(~""\\p{Digit}"") {it * 2} == ""11 a 22 b 33 c 44""
                       |          |                       |
                       |          \p{Digit}               false
                       [1, 1] a [2, 2] b [3, 3] c [4, 4]

	at org.codehaus.groovy.runtime.InvokerHelper.assertFailed(InvokerHelper.java:386)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.assertFailed(ScriptBytecodeAdapter.java:662)
	at groovy.GroovyMethodsTest.testReplaceAllClosurePattern(GroovyMethodsTest.groovy:517)

{code};;;","20/Sep/10 23:03;uehaj;Thanks for checking.
Sorry for the tests failure.
those are come from my patch. 

I'd like to create new one as soon as possible.

*analysis*

each&eachMatch are using Matcher#iterator() to
get each matched groups. And the next()
method of the Iterator which returned from Matcher#iterator()
doing following process:
{code}
if (the regular expression has capturing group) {
  return List<String> of matching groups;
}
else {
  return whole of match;
}
{code}
so, to emulate above behavior in replaceAll,
it should change the parameter to the closure
according to the value of matcher.hasGroup().
;;;","21/Sep/10 08:14;guillaume;So a new patch coming? :-);;;","21/Sep/10 08:15;guillaume;Make sure to run at least the two tests:
* groovy.RegularExpressionsTest
* groovy.GroovyMethodsTest
when you submit your udpated patch.
Looking forward to it :-);;;","21/Sep/10 09:50;uehaj;This is new patch. I hope this is final :)

I extracted a method named 'getReplacement()' from replaceAll().
I'm not native English speaker so please check or rewrite the javadoc comments.

I tested the following cases:
{code}
 ant -DtestCase=groovy.RegularExpressionsTest test
 ant -DtestCase=groovy.GroovyMethodsTest test
{code}
;;;","21/Sep/10 10:52;guillaume;This time was the good one ;-) Thanks for the patch!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy build fails test target using Java 1.7.0,GROOVY-4391,12815295,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,malbery,malbery,04/Sep/10 23:28,15/Dec/10 16:56,14/Jul/23 06:00,08/Oct/10 08:41,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,0,,,,,,"These two tests fail and error respectively when running the Ant test target using Java 1.7.0-ea-b108:

org.codehaus.groovy.ant.GroovycTest.testGroovyc_Joint_NoFork_NestedCompilerArg_WithGroovyClasspath
org.codehaus.groovy.transform.DelegateTransformTest.testLock",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4397,,,GROOVY-4390,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 08 10:41:02 UTC 2010,,,,,,,,,,"0|i2bqjb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Sep/10 23:49;malbery;Regarding DelegateTransformTest.testLock:

This will work:
$ groovy -e 'class MyList { private List list } ; new MyList()'

and this will NPE:
$ groovy -e 'class MyList { @Delegate private List list } ; new MyList()'
;;;","05/Sep/10 00:07;malbery;The code that's failing in MetaClassImpl does work in isolation:

$ groovy -e 'class MyList { private List list } ; java.security.AccessController.doPrivileged({ println java.beans.Introspector.getBeanInfo(MyList) } as java.security.PrivilegedExceptionAction)'
;;;","05/Sep/10 00:17;malbery;From looking at com.sun.beans.TypeResolver I'm guessing it's trying to inspect a List method parameter type that's badly formed (an array with no type):

        if (formal instanceof GenericArrayType) {
            Type comp = ((GenericArrayType)formal).getGenericComponentType();
            comp = resolve(comp);

;;;","05/Sep/10 00:18;malbery;This is the stack trace generated by the erroring test:

java.lang.NullPointerException
at com.sun.beans.TypeResolver.resolve(TypeResolver.java:321)
at com.sun.beans.TypeResolver.resolve(TypeResolver.java:303)
at com.sun.beans.TypeResolver.resolve(TypeResolver.java:351)
at com.sun.beans.TypeResolver.resolve(TypeResolver.java:172)
at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:93)
at java.beans.FeatureDescriptor.getParameterTypes(FeatureDescriptor.java:387)
at java.beans.MethodDescriptor.setMethod(MethodDescriptor.java:114)
at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:72)
at java.beans.MethodDescriptor.<init>(MethodDescriptor.java:56)
at java.beans.Introspector.getTargetMethodInfo(Introspector.java:1148)
at java.beans.Introspector.getBeanInfo(Introspector.java:431)
at java.beans.Introspector.getBeanInfo(Introspector.java:172)
at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:2931)
at java.security.AccessController.doPrivileged(Native Method)
at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:2929)
at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:2912)
at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:166)
at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:182)
at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:214)
at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:741)
at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallConstructorSite(CallSiteArray.java:69)
at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:52)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:190)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:194)
at Script1.run(Script1.groovy:12)
at groovy.lang.GroovyShell.evaluate(GroovyShell.java:576)
at groovy.lang.GroovyShell.evaluate(GroovyShell.java:614)
at groovy.lang.GroovyShell.evaluate(GroovyShell.java:585)
at groovy.lang.GroovyShell$evaluate.call(Unknown Source)
at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:124)
at org.codehaus.groovy.transform.DelegateTransformTest.testLock(DelegateTransformTest.groovy:55);;;","05/Sep/10 00:36;malbery;The @Delegate issue may be specific to Collection and it's implementations.;;;","25/Sep/10 03:42;hamletdrc;this error does not occur on Java 1.7.0-ea-b111 64 bit ubuntu. 

Merlyn, what operating system are you using? 
Which maven target in Groovy did you invoke. ""mvn clean install"" worked find for me. 
;;;","07/Oct/10 15:22;roshandawrani;Merlyn/Hamlet, these issues should be fixed now. I have done the needed changes on 1.7.6 as well as on trunk(1.8-beta-3) and tested them locally with OpenJDK 7.

Can you confirm from your ends?;;;","08/Oct/10 08:41;roshandawrani;Locally tested with OpenJDK(7) by me and then also verified by Merlyn.;;;","08/Oct/10 10:41;malbery;Thanks for fixing this, Roshan.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
static import does not work in Groovy 1.7.4,GROOVY-4386,12812172,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,frodesto,frodesto,01/Sep/10 01:21,07/Apr/15 19:13,14/Jul/23 06:00,13/Dec/10 16:59,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,15,,,,,,"Static import does not work from Groovy scripts.

Example:

foo/Constants.groovy:

{noformat}
package foo

class Constants {
    static final PI = 3.14
}
{noformat}

foo/Test.groovy

{noformat}
package foo
import static foo.Constants.PI

class Test {
    static main(args) {
        println(""pi="" + PI)
    }
}
{noformat}

When you try to run this (without compling with groovyc first), you get:

{noformat}
groovy -cp . foo\Test.groovy
Caught: groovy.lang.MissingPropertyException: No such property: PI for class: foo.Test
        at foo.Test.main(Test.groovy:6)
{noformat}

If you first run ""groovyc foo\Constants.groovy"" the above command succeeds.




","Windows, Groovy Version: 1.7.4 JVM: 1.6.0_21
",achernyakevich,frodesto,gjoseph,pinus,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"13/Dec/10 12:08;blackdrag;p1.patch;https://issues.apache.org/jira/secure/attachment/12722759/p1.patch","13/Dec/10 12:09;blackdrag;p2.patch;https://issues.apache.org/jira/secure/attachment/12722710/p2.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 13 16:59:53 UTC 2010,,,,,,,,,,"0|i2bmuf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Oct/10 06:13;frodesto;Same problem with Groovy 1.7.5;;;","23/Nov/10 08:26;gjoseph;Any feedback on this ?;;;","23/Nov/10 09:02;blackdrag;I am assigning this to Paul as static imports are his baby...;;;","23/Nov/10 09:03;blackdrag;unless Roshan wants to take care of this... I am sure Paul is not intending on keeping this one;;;","07/Dec/10 09:22;alexeysergeev;This is very serious bug and the main reason why I can't migrate my applications to latest Groovy & Grails. Could anybody from Groovy team cope with the this?;;;","07/Dec/10 10:31;hamletdrc;Is this really a bug? PI is defined in a class named Constants. if you run ""groovy Test.groovy"" without first compiling COnstants.groovy into  Constants.class then the class is not available and it is not found. If you compile Constants.groovy then Constants.class exists on the classpath and it is found. This used to work in a past version? That surprises me. ;;;","08/Dec/10 06:40;achernyakevich;This is serious backward compatibility issue. Because, for example, for me the same as for Mr. Sergeev this completely prevent from migration to newer version of Grails 1.3.5 that use Groovy 1.7.5 because huge number of customer specific scripts will need to be manually updated to avoid this issue as soon as in older version of Groovy 1.7.2 that Grails 1.3.1 is based on there was not this bug.

And there was only minor version number changes but so radical influence.;;;","08/Dec/10 07:19;blackdrag;when compiling Test.groovy, the compiler should recognize, that there is a class foo.Constants and enqueue it for compiling. But in the end that is not even important. The compiler should recognize the static import and see that PI is imported that way. In theory the compiler could, without compiling  Constants, issue the needed bytecode for this. The Groovy compiler does normally not inline, so that would be a PropertyExpression with foo.Constants as ClassExpression in the object part and PI as property string. There is one problem though with this. from the static import alone and without looking at the class the compiler cannot easily know if we import a method or an constant/static property. Also the problem is on what to do should the name PI reappear in the class... which is not the case here, but it is a potential problem.


Maybe we should make our lifes here more easy than we did in the past. Maybe we should simply say that if you static import, that you cannot declare a property or method of that name and that if you use the name as property or method, that then we will do the redirection. 

@Alexander, that radical influence was surely not intended and was by accident. Actually it is not easy to write test cases for this kind of thing.;;;","12/Dec/10 16:21;paulk;Just confirming that it is a regression between 1.7.3 and 1.7.4.;;;","13/Dec/10 12:11;blackdrag;I attached two possible patches. Both try somehow to give ResolveVisitor its own phase, without disturbing too muhc of the overall infrastructure. Both are quite a hack. While p1 makes a more fundamental change in that every SourceUnitOperation might be run again, p2 is very specific to ResolveVisitor. I am not sure yet they really fix the issue at hand though, would be nice if that could be confirmed. If p2 fixes the problem I would vote for having p2 in 1.8 and 1.7. p1 is maybe good only for 1.8;;;","13/Dec/10 16:59;paulk;Applied Jochen's patch (p2).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Response already committed on Google App Engine when serving blobs,GROOVY-4385,12812171,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,guillaume,guillaume,31/Aug/10 17:27,15/Dec/10 22:19,14/Jul/23 06:00,31/Aug/10 17:30,1.7.4,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,Groovlet / GSP,,,,0,,,,,,"When using the BlobstoreService from Google App Engine to serve blob content from a Groovlet, whether through direct streaming or through getting an input stream / reader over the blob content, the GAE server would complain that the response is already committed.
What ""commits"" the response is the calls by GroovyServlet to response.setStatusCode() and response.flushBuffer().
The former sets the default 200 status code, which is usually set by default at 200 anyway by servlet containers.
The latter is also done by servlet containers when the servlet terminates.
At least, this is what I gathered from glancing through Tomcat and Jetty sources.
So the suggested fix is to remove the call to these two methods which ""commit"" the response too early.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-08-31 17:27:16.0,,,,,,,,,,"0|i2brun:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Round-tripping XML which contains a newline character reference in an attribute's value removes the character reference,GROOVY-4380,12811966,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,aogail,aogail,25/Aug/10 19:43,05/Apr/15 14:43,14/Jul/23 06:00,28/Aug/10 04:32,1.6.4,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,XML Processing,,,,0,,,,,,"Given an XML file which contains a newline character reference (&#10;) in the value of an attribute, the following groovy code incorrectly outputs the actual newline character instead of the original character reference. This is a significant problem because the XML standard dictates that newlines found in the value of an attribute must be treated as a space. Thus, if any XML parser reads the output of this groovy snippet, it is as if the newline is gone.

newline.xml:
<option name=""LINE_SEPARATOR"" value=""&#10;""/>

groovy:

def fileWriter = new FileWriter('./newline-roundtrip.xml')
def input = new XmlParser().parse('./newline.xml')
PrintWriter printWriter = new PrintWriter(fileWriter)
new XmlNodePrinter(printWriter).print(input)
printWriter.flush()

I've attached a junit test which demonstrates the problem.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"26/Aug/10 14:21;aogail;GROOVY-4380-1_7_x.diff;https://issues.apache.org/jira/secure/attachment/12722574/GROOVY-4380-1_7_x.diff","25/Aug/10 19:43;aogail;NewlineEntityFailure.groovy;https://issues.apache.org/jira/secure/attachment/12722446/NewlineEntityFailure.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Sat Aug 28 04:32:08 UTC 2010,,,,,,,,,,"0|i2cs0n:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"25/Aug/10 19:45;aogail;Sorry, I meant to mark 1.6.4 and 1.7.4 in Affected versions, not Fix versions. I don't see a way for me to change it now.;;;","25/Aug/10 20:41;roshandawrani;Corrected fix/affected versions.;;;","26/Aug/10 14:21;aogail;Patch to fix this bug. Diff is against the GROOVY_1_7_X branch.;;;","28/Aug/10 04:32;paulk;Patch applied. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect handling of unicode escape sequences when calculating source locations,GROOVY-4378,12815315,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,werdna,werdna,23/Aug/10 15:59,03/Jun/17 15:43,14/Jul/23 06:00,09/Mar/11 08:15,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.9,1.8-rc-2,,,,,,0,,,,,,"When compiling this code with Groovy 1.7.3:


{code}
class One {
	 /*\u00E9*/ Stack<F> plates;
}
{code}

I get the following error message:


{code}
$ groovy One.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/private/tmp/One.groovy: 2: unable to resolve class F 
 @ line 2, column 15.
   	 /*\u00E9*/ Stack<F> plates;
                 ^

1 error
{code}
I would expect the ^ to be under the 'F'.  It appears that the unicode sequence is being considered a single character, rather than 6 characters.
",,blackdrag,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,0,0,,0%,0,0,,,,,,,,,,,,,,,,,,,,,,,,"03/Mar/11 21:56;werdna;GROOVY-4378.patch;https://issues.apache.org/jira/secure/attachment/12722826/GROOVY-4378.patch","04/Mar/11 03:10;blackdrag;unicode.patch;https://issues.apache.org/jira/secure/attachment/12722736/unicode.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jun 03 15:43:33 UTC 2017,,,,,,,,,,"0|i2cbrr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Aug/10 16:03;werdna;I believe that at least part of the problem comes from org.codehaus.groovy.antlr.UnicodeEscapingReader, where an escape sequence is translated into a single character.  But, I think there is also a problem with the GroovyRecognizer in that it creates source locations based on the translated escape sequences, rather than the raw text.

Please note that this problem is much bigger for Groovy-Eclipse since it is reliant on precise source locations in order to get editor operations (like content assist and underlining) working.;;;","24/Aug/10 05:32;blackdrag;If UnicodeEscapingReader would not replace the sequence with the unicode ""character"" alone, but instead fills up using spaces, then the source position would be right again. And then no change to GroovyRecognizer would be needed, especially no manual sourceposition translation. Andrew, do you think that could work?;;;","24/Aug/10 10:16;werdna;No, this probably won't work.  An escape sequence in the middle of an identifier would cause problems.  Eg:

{code}
foo\u8706foo
{code}

Would be sent to the recognizer as:
{code}
foo&#8706;     foo
{code}

(oops---when I first entered it, &#8706 was an actual unicode character)

Now, what was once 1 identifier would become two.;;;","25/Aug/10 15:46;blackdrag;the problem is how to resolve the issue then... allowing unicode escape sequences in identifiers?;;;","25/Aug/10 16:18;werdna;Another possibility (and I admit that I haven't completely thought this through) would be to add a new method to UnicodeEscapingReader that returns the number of chars read on the last call to read (eg- getBytesRead() ).  Then GroovyLexer would presumably update its source locations appropriately after it calls getBytesRead().;;;","25/Aug/10 16:20;werdna;Since GroovyLexer is a subclass of an antlr class and it looks like the call to read() happens in library code, the suggestion above may not work.

So, another possibility that I can see would be for GroovyLexer to perform the unescaping of unicode chars itself.  This would of course require a change to the grammar.;;;","18/Nov/10 16:37;werdna;Any chance that we can have this fixed?  Users are hitting the occasionally (but regularly) and it is always confusing and disruptive for them.;;;","19/Nov/10 02:45;blackdrag;the current state seems to be that we need to change the grammar and convert unicode by ourselfes;;;","19/Nov/10 04:21;blackdrag;another example:{code:Java}\u00E9 = new I_AM_WRONG(){code};;;","19/Nov/10 06:19;blackdrag;I tried modifying the LETTER Lexer rule, but then this swallowed all \, so that alone does not do it.;;;","10/Feb/11 10:25;werdna;Here is a potential solution for this problem:

When I say the actual text, I mean the text in the source file.  When I say the parser text, I mean the text that the parser sees and that has the text collapsed around unicode escapes.

# It is easy enough to have the lexer keep track of where unicode characters are in the parser text.
# This would be some sort of datastructure that can translate from pasrer text locations to actual text locations and is built up during lexing.
# Then, in GroovyRecognizer.create(), if the passed in AST is of type GroovySourceAST, we use the datastructure created above to translate the source locations from parser text to source text.

I'm not really a big fan of this solution, but it is minimally invasive and would probably work.  The hardest part would be to get the datastructure right so that it is efficient in time and in space (although even that shouldn't be too hard).;;;","03/Mar/11 18:51;werdna;I committed a fix for this to Groovy-Eclipse.  I am attaching the patch that I used.  See GRECLIPSE-805 for a description of what the changes are.  The changes are minimally invasive, and negligible in overhead.  The patch will not apply directly to groovy core since Groovy-Eclipse uses a patched 1.7.8 version.  However, you should be able to look at it and determine what should be done.;;;","03/Mar/11 21:56;werdna;Forgot to attach the patch.;;;","04/Mar/11 03:10;blackdrag;I attached the pach I am going to apply. It is a bit different from yours, as several parts in your patch don't seem to apply to normal Groovy. That is mainly the SourceBuffer part. We don't have a getLocationSupport method and no lineendings list for example. And we also have no error recovery ast class.
Another change to your code is that our unicdoe reader seems to allow multiple u in a escape sequence. So I added a counter for them instead of having the hard coded 5 offset alone.;;;","04/Mar/11 10:59;werdna;Thanks for this.  As I mentioned, I had to create the patch off of Groovy-Eclipse, where we have already made quite a few changes in this area.

Do you think that accepting escape sequences like {{\uuuuuAE09}} is a bug?  I can't see any reason why this would be acceptable. 

Until I hear back from you one way or the other, I will amend the fix for GroovyEclipse so that it can accept multiple 'u' chars.;;;","04/Mar/11 14:08;blackdrag;well, be it bug or not, it was accepted before, so I think it is not good to have that changed now for 1.7. I ahd to change the patch a bit more, because of some tests that use the Reader without a lexer. I added a dummy lexer that is used if no lexer is set that gives some fake line and column numbers, just to satisfy the tests. I committed this changed version to 1.7, 1.8 and 1.9 already;;;","03/Jun/17 00:40;daniel_sun;Jochen, Unicode escape sequences are allowed to define identifiers currently, can we stop supporting such a strange feature in Parrot(Groovy 3)? And can  \uuuuu9fa5 be deprecated too(i.e. just. to support the standard Unicode escape sequences)?;;;","03/Jun/17 15:43;blackdrag;I think unicode escape sequences in identifiers must be supported. But it might be ok to not to support something like \uuuuu9fa5;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,
deprecated @groovy.lang.Immutable feature broken on current trunk (1.8-beta-2),GROOVY-4376,12815209,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,roshandawrani,roshandawrani,21/Aug/10 15:44,15/Dec/10 22:19,14/Jul/23 06:00,27/Aug/10 19:07,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-2,,,,,,,0,,,,,,"The following code is not supposed to go through, as it defeats the whole purpose of @Immutable. It correctly fails with ReadOnlyPropertyException on 1.7.5, but on trunk it works.
{code}
@Immutable final class Person {
     boolean married
}
  
person = new Person(married:false)

/* should not be allowed as it is mutating the object after it is formed */
person.married = true 
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 28 02:18:25 UTC 2010,,,,,,,,,,"0|i2c4dz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Aug/10 01:48;paulk;Using the non-deprecated transform works:
{code}
@groovy.transform.Immutable class Person {
     boolean married
}  
person = new Person(married:false)
/* will fail with ReadOnlyPropertyException */
person.married = true
{code}
We need to investigate why the deprecated version from groovy.lang is not even calling the transform.;;;","27/Aug/10 19:07;paulk;Some initial tests are now in place. Feel free to add more tests if you are worried about coverage but I think coverage should be taken care of by none deprecated tests - what was missing was some check that deprecated version was working or not.;;;","27/Aug/10 19:40;roshandawrani;No, I am not worried. It just seemed totally wrong that a feature existed but had 0 tests!;;;","28/Aug/10 02:18;paulk;Indeed. Good catch. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Java stubs should never need to explicitly include alias imports,GROOVY-4374,12811679,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,paulk,,20/Aug/10 06:58,08/Mar/22 12:16,14/Jul/23 06:00,03/Jan/22 03:14,1.7.4,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Stub generator / Joint compiler,,,,0,,,,,,"Given that an import with an alias always has the fully qualified path we should always be able to substitute the fqn and hence don't need an explicit import. Java code has no visibility to the alias.

See: http://groovy.markmail.org/thread/z2prm3z33a5olb2y
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-08-20 06:58:33.0,,,,,,,,,,"0|i2cmpb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Groovlet generated error ""The requested resource () is not available.""",GROOVY-4373,12815297,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,wnagy,wnagy,19/Aug/10 09:18,22/Dec/12 01:10,14/Jul/23 06:00,05/Dec/12 03:22,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.9,2.0.6,,Groovlet / GSP,,,,1,,,,,,"Groovy Script is in 
WEB-INF/groovy/start.groovy


URL: http://localhost:8080/mframev200
First call run fine

If I call the script again the following error is displayed:

The requested resource () is not available.

On the console:

GroovyServlet Error:  script: '/start.groovy':  Script not found, sending 404.

","Servlet Engine: Apache Tomcat/6.0.10
Windows XP",blackdrag,mystix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Aug/11 15:07;mystix;test-169.war;https://issues.apache.org/jira/secure/attachment/12722900/test-169.war","24/Aug/11 07:41;mystix;test-181-classes.war;https://issues.apache.org/jira/secure/attachment/12722877/test-181-classes.war","24/Aug/11 07:41;mystix;test-181-groovy.war;https://issues.apache.org/jira/secure/attachment/12722878/test-181-groovy.war","16/Aug/11 15:07;mystix;test-181.war;https://issues.apache.org/jira/secure/attachment/12722876/test-181.war","20/Sep/11 07:39;wnagy;v181-ny.war;https://issues.apache.org/jira/secure/attachment/12722584/v181-ny.war","19/Aug/10 09:18;wnagy;web.xml;https://issues.apache.org/jira/secure/attachment/12722688/web.xml",,,6.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 05 03:22:28 UTC 2012,,,,,,,,,,"0|i2cta7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Sep/10 04:30;guillaume;I couldn't reproduce the issue you've encountered.
Could you provide a small war with everything needed and precise steps for reproducing the issue?
Or have you found out what was causing this in the meantime?;;;","01/Sep/10 04:34;wnagy;> Or have you found out what was causing this in the meantime?
Sorry, no. This problem is comming with 1.7.0

> Could you provide a small war with everything needed and precise steps for reproducing the issue?
I make this in the next days

Thank you;;;","18/Dec/10 00:16;virtualeyes;Same here, groovlet script loads fine, than all subsequent requests result in 404, ""The requested resource () is not available""

I notice that there is a lag of 2-3 seconds on the initial request (i.e. the one that actually loads), and then instant 404 on refresh, even if I strip down the groovlet script to a simple println ""test""

Nothing in catalina.out that would indicate a problem with the working request (only log entry is the 404 on subsequent page refresh). 

Only solution is to restart tomcat, and that only works for a single request, madness.

Simple println tests work endlessly (i.e. can refresh multiple times without problem), so something must be amiss in my Groovy code -- would be better if it didn't compile in the first place; at least then I'd have an error message to work with...;;;","18/Dec/10 01:25;virtualeyes;Found a workaround.

I saved problem .groovy file to a different file name and the application again works as designed.

Not exactly a solution, but can at least resume testing.

Tomcat 6.0.26/Groovy 1.7.5/Fedora 13 on Vaio F12 laptop;;;","16/Aug/11 15:07;mystix;I'm hitting the same error with Groovy 1.8.1.

I'm running java 1.6.0_26 (on the mac), and tested this on both Tomcat 6.0.29 and 7.0.20, and on both OSX Snow Leopard and Lion.

I've attached 2 war files containing bare-bones test cases to be dropped into either version of Tomcat.

test-169.war uses groovy-all-1.6.9.jar, while test-181.war uses groovy-all-1.8.1.jar.

Both test cases contain a simple test.groovy groovlet which displays ""Hello world!"" in the browser.

Accessing
http://localhost:8080/test-169/test.groovy
any number of times always displays ""Hello world!"" successfully in the browser.

Accessing
http://localhost:8080/test-181/test.groovy
more than once results in a ""The requested resource () is not available"" error being thrown.

Let me know if you need any more information.


[update - 2011/08/22]
This appears to affect Tomcat only.
I tested both test-169.war and test-181.war on Jetty 6.1.26 and both wars ran just fine no matter how many times i refreshed the test.groovy page.;;;","24/Aug/11 07:40;mystix;I've managed to find a workaround / solution:

Placing script sources (i.e. .groovy files) in WEB-INF/groovy, and compiled script sources (i.e. .class files) in WEB-INF/classes, seems to have resolved the problem (see attached .war files test-181-groovy.war and test-181-classes.war for drop-in examples).

The GroovyServlet documentation (http://groovy.codehaus.org/api/groovy/servlet/GroovyServlet.html) states:
""Your script sources can be placed either in your web application's normal web root (allows for subdirectories) or in /WEB-INF/groovy/* (also allows subdirectories).""
but .groovy files placed in WEB-INF/classes were always loaded by Tomcat for groovy <= 1.6.9, so this problem did not surface then.
;;;","24/Aug/11 07:41;mystix;Added drop-in tomcat webapps running on groovy 1.8.1 (test-181-groovy.war and test-181-classes.war);;;","20/Sep/11 07:38;wnagy;I tested the test-181-groovy.war It running fine.
But this ist not the problem:
When I added paramert in the URL 
eq: http://localhost:8080/v181-ny/test.groovy?p1=1&p2=4
the first run is OK the second run going wrong.
Tomcat: The requested resource () is not available.
I tested this with Tomcat 6, Tomcat 7 and jetty

Warfile (v181-ny.war) included.


;;;","05/Dec/12 03:22;blackdrag;this should work now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Implicit this fails to get passed correctly from one non-static inner class to another,GROOVY-4367,12815202,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,13/Aug/10 06:45,15/Dec/10 22:31,14/Jul/23 06:00,13/Aug/10 08:00,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,,,class generator,,,,0,,,,,,"{code}
class A {
    void foo() {
        new B().r()
    }

    class B {
        def r() {
            new C("""")
        }
    }

    class C {
        C(s) {}
    }
}

new A().foo()
{code}

The code above fails with the following error
{noformat}
Caught: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: A$C(java.lang.String)
	at A$B.r(TryGroovy.groovy:8)
	at A.foo(TryGroovy.groovy:3)
	at TryGroovy.run(TryGroovy.groovy:17)
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 13 07:02:24 UTC 2010,,,,,,,,,,"0|i2brxr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Aug/10 06:50;roshandawrani;Sorry, wrong example. Will modify it in a bit.;;;","13/Aug/10 07:02;roshandawrani;Modified snippet that reproduces the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compilation error in using inheritance and generics together,GROOVY-4366,12815289,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,13/Aug/10 05:42,15/Dec/10 22:31,14/Jul/23 06:00,13/Aug/10 06:33,1.7.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,,,class generator,,,,0,,,,,,"The following code does not compile on 1.7.5, but compiles successfully on 1.8-beta-2.

{code}
class Factory {
    abstract static class Machine<E> {
        abstract void make(E what)
    }
}

class PizzaFactory {
    static class PizzaMachine<E extends SimplePizza> extends Factory.Machine<E> {
        void make(E what) {}
    }
}

class SimplePizza {}
{code}

On 1.7.5, it fails with the following error
{noformat}
...\PizzaMaking.groovy: 8: Can't have an abstract method in a non-abstract class. The class 'PizzaFactory$PizzaMachine' must be declared abstract or the method 'void make(java.lang.Object)' must be implemented.
 @ line 8, column 5.
       static class PizzaMachine<E extends SimplePizza> extends Factory.Machine<E> {
       ^
{noformat}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-08-13 05:42:28.0,,,,,,,,,,"0|i2cl9z:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler does not do access check at classgen time and invalid class fails with IllegalAccessError later,GROOVY-4365,12815276,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,roshandawrani,roshandawrani,13/Aug/10 05:05,08/Mar/22 12:16,14/Jul/23 06:00,17/May/21 15:31,1.7.5,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,class generator,,,,0,,,,,,"{code}
class MyHashMap extends HashMap {
    static class MyEntry extends HashMap.Entry { }
}

println MyHashMap.MyEntry
{code}

Code above fails with
{noformat}
Caught: java.lang.IllegalAccessError: class MyHashMap$MyEntry cannot access its superclass java.util.HashMap$Entry
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-08-13 05:05:35.0,,,,,,,,,,"0|i2bpen:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DGM.eachLine() returns wrong result,GROOVY-4364,12815277,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pniederw,pniederw,pniederw,12/Aug/10 13:08,15/Dec/10 22:19,14/Jul/23 06:00,12/Aug/10 13:27,1.7.4,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,,,,,0,,,,,,"DGM.eachLine() should return the last value returned by the closure, but actually returns the last line. For trunk the code change has already been made as part of GROOVY-4361, but we also need a fix for the 1.7 branch.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-08-12 13:08:44.0,,,,,,,,,,"0|i2bqhb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"@Immutable class, failure when trying to define private static members",GROOVY-4363,12818059,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jlamsa,jlamsa,12/Aug/10 11:06,02/Feb/23 22:46,14/Jul/23 06:00,03/Sep/10 16:19,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,,,,,0,,,,,,"Attempt to add 'private static' field to a class that has been
annotated as @Immutable causes an error.

Groovy Shell (1.7.4, JVM: 1.6.0_20)
Type 'help' or '\h' for help.
------------------------------------------------------------------------------------------------------------------
groovy:000> @Immutable class AClass {
groovy:001>    static final String FOO = 'bar'
groovy:002> }
===> true
groovy:000> @Immutable class BClass {
groovy:001>    private static final String FOO = 'bar'
groovy:002> }
ERROR org.codehaus.groovy.control.MultipleCompilationErrorsException:
startup failed:
groovysh_evaluate: -1: cannot modify static final field 'FOO' outside
of static initialization block.
 @ line -1, column -1.
groovysh_evaluate: -1: cannot modify static final field 'FOO' outside
of static initialization block.
 @ line -1, column -1.
2 errors
...

In Groovy 1.7.3 it does not cause an error.
Groovy Shell (1.7.3, JVM: 1.6.0_20)
Type 'help' or '\h' for help.
------------------------------------------------------------------------------------------------------------------
groovy:000> @Immutable class AClass  {
groovy:001>    static final String FOO = 'bar'
groovy:002> }
===> true
groovy:000> @Immutable class BClass {
groovy:001>    private static final String FOO = 'bar'
groovy:002> }
===> true
groovy:000>
...","Mac OSX 10.6.3, JVM 1.6.0_20, Groovy 1.7.4",jlamsa,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10925,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 03 16:19:28 UTC 2010,,,,,,,,,,"0|i2c0f3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Aug/10 11:09;jlamsa;And the reply from Paul King (Aug 12 2010)
-----
This happens on the 1_7_X branch but not on trunk.
So, we've presumably fixed something in trunk but not
back-ported the fix. It needs further investigation.
-----;;;","01/Sep/10 17:16;paulk;This should be fixed in the 1_7_X branch. There are some edge cases with initialization that I am looking at before committing a test and resolving the issue.;;;","03/Sep/10 16:19;paulk;Code fixed and test added.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Node.text() returns empty string for non-String or Collection values,GROOVY-4362,12815293,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,jspeakman,jspeakman,12/Aug/10 07:15,01/Apr/12 21:41,14/Jul/23 06:00,01/Apr/12 21:41,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,XML Processing,,,,0,,,,,,"The text() method of groovy.util.Node is coded to return an empty string ("""") if you set a value that is not a string or a collection. This means if you set the value as a number you get back an empty string.

Should this method return value.toString() in all cases where value is not a collection?

For instance -
{code}
def xml = ""<root><node1/></root>""
def root = new XmlParser().parseText(xml)
root.node1[0].replaceNode() {
    node2() {
       childN(5)
       childS('5')
    }
}

assert root.node2[0].childS[0].text() == '5'
assert root.node2[0].childN[0].text() == '5'
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/Aug/10 07:15;jspeakman;NodeTextNonString.groovy;https://issues.apache.org/jira/secure/attachment/12722336/NodeTextNonString.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Apr 01 21:41:22 UTC 2012,,,,,,,,,,"0|i2byzj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"01/Apr/12 15:04;paulk;add code tags;;;","01/Apr/12 21:41;paulk;I believe this was fixed as a side-effect of GROOVY-5257. At least the fix I was going to apply for this issue was already applied even though it doesn't seem specifically related to GROOVY-5257. Perhaps I was working on both issues and committed both changes back then or perhaps it was required because of the tests required for that issue. Anyway, please report any problems if you still observe them.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Generic types are incorrectly shared/resolved within the module,GROOVY-4359,12815576,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,roshandawrani,roshandawrani,10/Aug/10 13:27,17/Dec/14 13:25,14/Jul/23 06:00,29/Oct/14 15:51,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,class generator,,,,0,,,,,,"The following code should not compile, as class A is defined as a generic class and not class B, but type variables' resolution is spilling over from A to other non-related classes in the same module.
{code:title=Test.groovy}
class A<T>{}

class B {
    T f
}
{code}


However, the following should continue to work
{code}
class A<T>{
    class B {
        T f
    }
}
{code}",,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 29 15:51:15 UTC 2014,,,,,,,,,,"0|i2ch9r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Oct/14 15:51;pschumacher;On current master this causes a compilation error:
{quote} 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
test.groovy: 4: unable to resolve class T
 @ line 4, column 5.
       T f
       ^

1 error
{quote}

so I'm resolving this.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static members should not be able to access class-level generic types,GROOVY-4356,12815291,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,roshandawrani,roshandawrani,08/Aug/10 13:45,02/May/17 02:03,14/Jul/23 06:00,29/Aug/16 00:42,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,class generator,,,,0,,,,,,"The following code compiles, but it shouldn't because T is a non-static generic type, and difference instances of Outer will have different concrete representations of T. Hence it makes no sense that static inner classes should be able to use such generic type variables.
{code}
class Outer<T> {
    T ofoo
    static class Inner {
        T ifoo
    }
}
{code}

Similarly, all the cases below should not compile as well:
{code}
class Test1<T> {
    static T f1
}

class Test2<T> {
    static foo(T param1) {}
}

class Test3<T> {
    static foo() {
        T localVar1
    }
}
{code}",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 29 00:42:33 UTC 2016,,,,,,,,,,"0|i2c1hb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Aug/10 06:17;roshandawrani;{code:title=Tests that should pass}
class Groovy4365Bug extends gls.CompilableTestSupport {

    void testGenericTypeVariablesUsedInStaticSuccessV1() {
        shouldCompile """"""
            class OuterS1<T> {
                T ofoo
                static class InnerS1<T> {
                    T ifoo
                }
            }
        """"""
    }

    void testGenericTypeVariablesUsedInStaticSuccessV2() {
        shouldCompile """"""
            class TestS2 {
                static <T> void foo(T param1){}
            }
        """"""
    }
    
    void testGenericTypeVariablesUsedInStaticSuccessV3() {
        shouldCompile """"""
            class TestS3 {
                static <T> void foo() {
                    T localVar1
                }
            }
        """"""
    }
    
    void testGenericTypeVariablesUsedInStaticV1() {
        shouldNotCompile """"""
            class Outer<T> {
                T ofoo
                static class Inner {
                    T ifoo
                }
            }
        """"""
    }

    void testGenericTypeVariablesUsedInStaticV2() {
        shouldNotCompile """"""
            class Test1<T> {
                static T f1
            }
        """"""
    }

    void testGenericTypeVariablesUsedInStaticV3() {
        shouldNotCompile """"""
            class Test2<T> {
                static foo(T param1) {}
            }
        """"""
    }

    void testGenericTypeVariablesUsedInStaticV4() {
        shouldNotCompile """"""
            class Test3<T> {
                static foo() {
                    T localVar1
                }
            }
        """"""
    }
}
{code};;;","24/Aug/16 07:30;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/393

    GROOVY-4356: Static members should not be able to access class-level …

    …generic types

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy4356

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/393.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #393
    
----
commit 74731579d4a857adaf1c4eab1b7812c72a639600
Author: paulk <paulk@asert.com.au>
Date:   2016-08-24T07:28:27Z

    GROOVY-4356: Static members should not be able to access class-level generic types

----
;;;","29/Aug/16 00:38;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/393
;;;","29/Aug/16 00:42;paulk;While technically a bug fix I will make this change just on master to target Groovy version 2.5 since even in our own code base we were sloppy with using some class-level generics within static methods - just example test code. So, there might be existing code that will (and should) break. The expectations about breakages are slightly greater for more major releases.

But feedback welcome and I am certainly open to porting back to the 2_4_X branch if there is sufficient demand.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot get a closure's resolve strategy with property syntax,GROOVY-4348,12815270,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pniederw,pniederw,pniederw,02/Aug/10 10:08,15/Dec/10 22:19,14/Jul/23 06:00,03/Aug/10 17:35,1.7.4,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-2,,,Compiler,,,,0,,,,,,"Closure.getProperty() gives no special treatment to ""resolveStrategy"", hence ""closure.resolveStrategy"" is simply forwarded to delegate/owner.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 04 18:20:25 UTC 2010,,,,,,,,,,"0|i2c3kn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Aug/10 18:17;pniederw;Is it safe to add the missing properties to Closure.getProperty() and Closure.setProperty()? It's ""resolveStrategy"" and ""thisObject"" for the former, and ""directive"" for the latter.;;;","03/Aug/10 08:53;paulk;I would probably like to see ""directive"" removed from getProperty(). In some sense ""directive"" is internal (and can be accessed using .@ if needed). Removing it from getProperty() would remove that part of the inconsistency.;;;","03/Aug/10 09:23;pniederw;Don't you think a property should either be accessible both with property and method syntax, or with neither of them? Everything else will be very hard to understand.
;;;","03/Aug/10 16:24;paulk;Perhaps fixing the inconsistency is the better short-term strategy. And if we later ""fix"" it to be deprecated or totally internal it shouldn't be visible with either property or method syntax from normal code.;;;","03/Aug/10 17:35;pniederw;Added handling for ""resolveStrategy"" and ""thisObject"" to Closure.getProperty(), and handling for ""directive"" to Closure.setProperty(). Only applied to trunk because it constitutes a breaking change.;;;","03/Aug/10 18:00;blackdrag;use closure.@resolveStrategy instead? Also thisObject is not supposed to be accessed  from outside the closure, it is an implementation detail only. ;;;","03/Aug/10 18:06;pniederw;It doesn't make sense to me that closure.getResolveStrategy() works, but closure.resolveStrategy doesn't. I assume Closure.getProperty()/setProperty() simply got out of sync when new properties where added to class Closure.

If these properties shouldn't be publicly accessible, they shouldn't have a public getter/setter method in the first place. Also, this not only affects what's accessible from outside the closure, but also what's accessible from inside the closure.;;;","03/Aug/10 18:25;blackdrag;That inside and outside a closure are the same is part of the problem. Another problem is that every setter used is decreasing the availability of that name in builders. That might be the reason why there is a getter, but no setter. Another take on the  problem is that internal API and external API are not separated here, which I not see how it should be done atm.

Anyway.. thisObject is different from resolveStrategy and we should discuss it different from the others. There will be for example no setter, thus no need for the special handling in Closure. Actually, if we don't want any special handling of properties from the Groovy side, then there is no need for a getProperty on Closure at all. It could like all others simply delegate to the meta class. Most of the logic is in there anyway;;;","03/Aug/10 18:32;pniederw;> Another problem is that every setter used is decreasing the availability of that name in builders.
That's why I called it a breaking change. 

> Anyway.. thisObject is different from resolveStrategy and we should discuss it different from the others.
OK, so how should I proceed? Revert the thisObject change, or revert the whole thing?

> There will be for example no setter, thus no need for the special handling in Closure.
I only added it to getProperty() to align it with public getThisObject().;;;","04/Aug/10 07:12;blackdrag;maybe the getter for thisObject should be deprecated. 

Before I say revert or not, may I ask what the use case was, that made you filling this issue? Do you *need* any of those changes?;;;","04/Aug/10 18:20;pniederw;I needed a decorator for closures that acts as a two-way interceptor, i.e. intercepts both calls to the closure and calls to the closure's delegate. Therefore I created a subclass of groovy.lang.Closure and added a few properties to it (only meant to be used from the ""outside""). When I tried to set these properties from Groovy code, I noticed it didn't work. Experimenting further, I noticed that I could get/set most of the properties declared in groovy.lang.Closure, but not all of them. At this point I was close to give up and rewrite everything in Java. It just looked like a big mess. But then I discovered Closure.getProperty()/setProperty() and understood why I could get/set some properties but not others. While I couldn't do anything to make the properties on my own subclass work, it seemed like an oversight that some groovy.lang.Closure properties weren't gettable/settable with property syntax, so I went ahead and fixed this.

Having property syntax not aligned with method syntax will cause problems because it's against the general rule and people won't understand what's going on (nor should they have to). In summary, I'd expect closures to behave like regular objects from the outside, and have an inside view that's separated from the outside view.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"DGM#consumeProcessOutput(Process, StringBuffer, StringBuffer) accepts only StringBuffers",GROOVY-4347,12815273,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,veita,veita,31/Jul/10 08:02,15/Dec/10 22:19,14/Jul/23 06:00,01/Aug/10 02:27,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,groovy-jdk,,,,0,,,,,,This is too restrictive. Appendable would be better.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 01 02:27:02 UTC 2010,,,,,,,,,,"0|i2cayn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Aug/10 02:27;paulk;Added. Thanks for the suggestion.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Curry method fails when using it in a chain with IllegalArgumentException,GROOVY-4340,12818396,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mszalbach,mszalbach,30/Jul/10 05:41,15/Dec/10 22:19,14/Jul/23 06:00,04/Sep/10 22:09,1.7.2,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,,,,,0,,,,,,"Curry method did not work like stated on http://groovy.codehaus.org/JN2515-Closures. The feature described there to chain curry on a closure to generate more specific ones did not work.

I tried to use these code example:

{code}
def c = { arg, Object[] extras -> arg + ', ' + extras.join(', ') }
def d = c.curry( 1 ) //curry first param only
assert d( 2, 3, 4 ) == '1, 2, 3, 4'
def e = c.curry( 1, 3 ) //curry part of Object[] also
assert e( 5 ) == '1, 3, 5'
def f = e.curry( 5, 7, 9, 11 ) //currying continues on Object
assert f( 13, 15 ) == '1, 3, 5, 7, 9, 11, 13, 15'
{code}

The following code example shows what works and what did not:

{code}
def a = { arg, Object[] extras -> arg + ', ' + extras.join(', ') }
//def b = a.curry( 1,2,3 ) //did not work
def c = a.curry( 1,[ 2,3 ] ) //works
def d = a.curry( 1,2 ) //works
//def e = d.curry( 3 ) //did not work
//def e = d.curry( [3] ) //did not work
{code}

The exception thrown is:

{code}
java.lang.IllegalArgumentException: To curry 4 argument(s) expect index range 0..-4 but found 0
	at org.codehaus.groovy.runtime.CurriedClosure.<init>(CurriedClosure.java:60)
	at org.codehaus.groovy.runtime.CurriedClosure.<init>(CurriedClosure.java:66)
	at groovy.lang.Closure.curry(Closure.java:370)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:225)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:63)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:137)
	at ConsoleScript0.run(ConsoleScript0:6)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:264)
	at groovy.lang.GroovyShell.run(GroovyShell.java:513)
	at groovy.lang.GroovyShell.run(GroovyShell.java:170)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:865)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:44)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:143)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:151)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:276)
	at groovy.lang.Closure.call(Closure.java:271)
	at groovy.lang.Closure.run(Closure.java:354)
	at java.lang.Thread.run(Thread.java:619)
{code}",Linux 2.6.32-24-generic i686 GNU/Linux,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Sep 04 22:09:47 UTC 2010,,,,,,,,,,"0|i2cg7z:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"09/Aug/10 01:57;mszalbach;Retested this issue with groovy 1.7.4 and it is also affected.;;;","01/Sep/10 17:18;paulk;I have a fix for curry locally (for trunk and 1.7 branch) but there are some edge cases with rcurry and ncurry that I am sorting out first before applying it - both should be there for 1.7.5 and 1.8 beta-2.;;;","04/Sep/10 22:09;paulk;Changes applied;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Generated createCallSiteArray is too big for JVM,GROOVY-4337,12815244,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,guillaume,tschneider,tschneider,28/Jul/10 11:41,05/Apr/15 14:44,14/Jul/23 06:00,01/Sep/10 10:45,1.6.9,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,1.7.5,1.8-beta-2,class generator,,,,0,,,,,,"We are using groovy as a DSL engine and we have a script that is 4000 lines long.  We've split it up into several methods, but we still receive an error about 'Invalid method Code length 66090 in class file script1280242156093619159538'.  I analyzed the generated code and the issue is that the groovy generated method $createCallSiteArray is too big.  This is happening because we have over 8000 entries in our call site array.  I've implemented a fix where the initialization of the String array for the callsite array is split up over several methods if it would generate code that is too big. (Patch attached)  In our preliminary testing, this has resolved our issue.",,schneidh,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Jul/10 11:41;schneidh;groovy-1.6.9-invalidmethodcodelength-fix.patch;https://issues.apache.org/jira/secure/attachment/12722521/groovy-1.6.9-invalidmethodcodelength-fix.patch","01/Sep/10 09:16;schneidh;groovy-1.7.x-invalidmethodcodelength-fix.patch;https://issues.apache.org/jira/secure/attachment/12722447/groovy-1.7.x-invalidmethodcodelength-fix.patch","01/Sep/10 09:17;schneidh;groovy-trunk-invalidmethodcodelength-fix.patch;https://issues.apache.org/jira/secure/attachment/12722333/groovy-trunk-invalidmethodcodelength-fix.patch",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Wed Sep 01 11:14:58 UTC 2010,,,,,,,,,,"0|i2chfj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Sep/10 02:44;guillaume;Could you also provide the same patch for Groovy 1.7/1.8?
Or aren't 1.7/1.8 not affected by this?;;;","01/Sep/10 09:16;tschneider;Fix for 1.7.x branch.;;;","01/Sep/10 09:17;tschneider;Fix for trunk.;;;","01/Sep/10 09:20;tschneider;Definitely still an issue for trunk and 1.7.  That's the first thing I checked when I ran across this issue.  I've attached patches for both 1.7/trunk.;;;","01/Sep/10 10:45;guillaume;I've committed those changes on all the branches.
We don't plan to do an 1.6.x release though, but we can potentially build a snapshot if really needed.
So prefer 1.7.
Thanks a lot for the contribution!;;;","01/Sep/10 11:14;tschneider;Great!  Thanks for applying the patches.  We already have our own version of 1.6 with this fix., so we'll probably look at upgrading to 1.7. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
EMC DSL is broken for some methods on Closure,GROOVY-4336,12815290,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,28/Jul/10 05:59,07/Apr/15 19:06,14/Jul/23 06:00,03/Aug/10 08:44,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-2,,,,,,,0,,,,,,"The Groovy EMC DSL breaks for method names within the Closure class:
{code}
def o = new Object()
o.metaClass {
  foo { 'foo' }
  curry { 'curry' }
  rcurry { 'rcurry' }
}
println o.foo()
//println o.curry()   // MissingMethodException
//println o.rcurry()  // MissingMethodException
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Jul/10 06:10;paulk;groovy4336_EMCDSL.patch;https://issues.apache.org/jira/secure/attachment/12722576/groovy4336_EMCDSL.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 03 08:44:49 UTC 2010,,,,,,,,,,"0|i2cq8n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Jul/10 06:07;paulk;I am excluding ""call"" and ""doCall"" from the scope of this issue. Note that methods like ""toString"", ""wait"", ""hashCode"" seem overridable. The ""equals"" method seems to go through to Object#equals(). Though I haven't fully traced the logic through for the latter examples.;;;","28/Jul/10 06:10;paulk;Attached patch is one (ugly) way to fix the problem. I need to explore a bit further - there must be a better way! Patch also covers potential ""leftShift"" and ""rightShift"" operators for Closure composition but these would be dependent on inclusion of this feature (see GROOVY-4322).

(Note for patch readers: a big chunk in the middle of the patch just has an extra level of indenting but the diff produced doesn't ignore that whitespace change);;;","03/Aug/10 08:44;paulk;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy 1.7.4 wont build from source,GROOVY-4330,12818056,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,mikevines,mikevines,26/Jul/10 11:27,15/Dec/10 22:19,14/Jul/23 06:00,27/Jul/10 05:55,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,GroovyScriptEngine,,,,0,,,,,,"I have just downloaded the Groovy 1.7.4 source and tried to compile on Windows 7 with Sun/Oracle JDK 1.6.0_21.  The build failed while performing the -testAll phase:

    [junit] Running UberTestCaseBugs
    [junit] Tests run: 400, Failures: 0, Errors: 0, Time elapsed: 4.977 sec
    [junit] Running UberTestCaseGroovySourceCodehausPackages
    [junit] Tests run: 429, Failures: 0, Errors: 0, Time elapsed: 54.605 sec
    [junit] Running UberTestCaseGroovySourceCodehausPackages_VM6
    [junit] Tests run: 1, Failures: 0, Errors: 0, Time elapsed: 0.074 sec
    [junit] Running UberTestCaseGroovySourceRootPackage
    [junit] Tests run: 1000, Failures: 0, Errors: 0, Time elapsed: 27.002 sec
    [junit] Running UberTestCaseGroovySourceSubPackages
    [junit] Tests run: 1187, Failures: 0, Errors: 1, Time elapsed: 66.116 sec
    [junit] Test UberTestCaseGroovySourceSubPackages FAILED

From groovy-1.7.4/target/reports/junit/all-tests.html

Class: UberTestCaseGroovySourceSubPackages
Name: testReloadingInterval
Status: Error
Type:

assert gse.run(scriptName, binding) == 3 | | | | | | 23 | | false | | groovy.lang.Binding@1769afe | gse6921152879800224663.groovy groovy.util.GroovyScriptEngine@1b9caa8

Assertion failed:

assert gse.run(scriptName, binding) == 3
| | | | |
| 23 | | false
| | groovy.lang.Binding@1769afe
| gse6921152879800224663.groovy
groovy.util.GroovyScriptEngine@1b9caa8

at org.codehaus.groovy.runtime.InvokerHelper.assertFailed(InvokerHelper.java:378)
at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.assertFailed(ScriptBytecodeAdapter.java:662)
at groovy.util.GroovyScriptEngineTest.testReloadingInterval(GroovyScriptEngineTest.groovy:246)


I had a quick look at groovy.util.GroovyScriptEngineTest.testReloadingInterval(GroovyScriptEngineTest.groovy:246).  Looks as if the test that is failing was introduced to test previous issues (GROOVY-2811 and GROOVY-4286) - maybe still an issue?

Kind regards,
Mike

","Windows 7, Sun/Oracle JDK 1.6.0_21",mikevines,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Jul/10 03:13;mikevines;reports.zip;https://issues.apache.org/jira/secure/attachment/12722686/reports.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 27 06:27:17 UTC 2010,,,,,,,,,,"0|i2cgyv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jul/10 13:13;guillaume;Is it failing consistently for you?
The build runs fine for everybody, including our continuous integration servers.;;;","26/Jul/10 14:22;mikevines;I have run the build twice, and it failed both times. Ican try a few more times in the morning if you wish.

Mike;;;","26/Jul/10 14:24;guillaume;also please look at the test reports to see if there's a bit more information;;;","27/Jul/10 03:13;mikevines;Full target/reports and target/test-reports directories;;;","27/Jul/10 03:23;mikevines;Guillaume,

I have run the build again a few times this morning, and it fails consistently.  I tried a previous Java version (1.6.0_16), but that made no difference.  (Although not really expecting it to make a difference, I also updated to the latest version of ant - still failed).

As per previous comment, I have attached the full contents of the target/reports and target/test-reports directory.  I was not exactly sure what you wanted to see, so I attachched the lot.  Hopefully I have provided you with everything you need - let me know if there is anything else I should have attached.

Thanks for your attention,
Mike;;;","27/Jul/10 03:31;mikevines;A little further info . . .

In the method testReloadingInterval(), is the code:

            f.delete()
            f << ""2""
            sleep 1000
            // the file was updated, and we waited for more than the minRecompilationInterval
            assert gse.run(scriptName, binding) == 2

            f.delete()
            f << ""3""
            sleep 100
            // still the old result, as we didn't wait more than the minRecompilationInterval
            assert gse.run(scriptName, binding) == 2

I have now seen that the file mentioned in the error report (gse5373281359525925393.groovy) is present in the target directory.  My expection was that it would contain:

        3

But instead it contains

        23

So the issue may not be that that the gse has not detected the change, but that the file did not get deleted before ""3"" was written to the file.

Mike
;;;","27/Jul/10 04:59;guillaume;I downloaded the sources deliverable, and ran the full clean build again just fine.
But your analysis is very interesting.
I've read in a few places that File#delete() doesn't always work reliably across systems.
And you may be on such a system!
I've seen implementations of custom delete() methods doing some retries till a delete really works.
So, what you see is probably the exhibit of such behaviour.
What system are you running?;;;","27/Jul/10 05:11;mikevines;I'm running Windows 7.  I think that in Unix OS's you can delete a file that is open (the file just gets removed from the directory structure), and then it is feasible to create a new version of the file.  The process/thread that still has the open file handle can continue happily unaffected.  However in Windows, the delete will not succeed - you cant delete an open file.

Mike;;;","27/Jul/10 05:16;guillaume;Windows 7, interesting.
But the files are closed when doing <<.
But perhaps it's kept open a bit longer by the OS.
Could you please try to introduce some delay here or there, to make the test pass for you?
You could also look into printing the result of the file deletion (since that returns a boolean), to check that's what we're seeing here.;;;","27/Jul/10 05:22;guillaume;For instance, add a 100ms delay between a delete() and a write <<.;;;","27/Jul/10 05:33;guillaume;Actually, a better idea would even be to not rely on delete() at all.
And do the following:
{code}
f << ""1""
sleep 200
// first time, the script is compiled and cached
assert gse.run(scriptName, binding) == 1

f << ""2""
sleep 1000
// the file was updated, and we waited for more than the minRecompilationInterval
assert gse.run(scriptName, binding) == 12

f << ""3""
sleep 100
// still the old result, as we didn't wait more than the minRecompilationInterval
assert gse.run(scriptName, binding) == 12

sleep 1000
// we've waited enough, so we get the new output
assert gse.run(scriptName, binding) == 123
{code}

We just keeping on appending to the file.
So there's no need for relying on delete() to work consistently on all systems.;;;","27/Jul/10 05:37;guillaume;And to avoid running the full build each time for each change, you can do:
{code}
ant -DtestCase=groovy.util.GroovyScriptEngineTest test
{code};;;","27/Jul/10 05:49;guillaume;I've committed my suggested fix, and Paul will also try that test on his Windows 7 box.;;;","27/Jul/10 05:55;guillaume;Seems to be working on Windows 7 now -- thanks Paul for checking this for me.
I'll close the issue for now, Mike. Please re-open it in case it still doesn't work for you.;;;","27/Jul/10 06:17;mikevines;Thanks - that has sorted it for me.  Builds OK now.

Thanks,
Mike;;;","27/Jul/10 06:27;guillaume;Now that you're fully setup to work on the Groovy code base, I'll warmly welcome your code contributions ;-);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stub generator exhibits a synthetic method in the stubs it should not,GROOVY-4329,12815271,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,guillaume,guillaume,26/Jul/10 09:23,15/Dec/10 22:19,14/Jul/23 06:00,27/Jul/10 05:56,1.7.4,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,,,,,0,,,,,,"The stub generator generates the following method:
{code}
MetaClass $getStaticMetaClass()
{code}
which is an internal method not intended to be called directly, so should not be present in the stubs.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-07-26 09:23:57.0,,,,,,,,,,"0|i2bpkn:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler does not mind multiple default cases for a switch statement,GROOVY-4325,12815106,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,25/Jul/10 10:49,15/Dec/10 22:19,14/Jul/23 06:00,10/Aug/10 04:26,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,class generator,,,,0,,,,,,"The following code compiles, when it shouldn't. Compiler does not mind any number of default cases.

{code}
def foo() {
    def x = 1
    switch(x) {
       case 1: println '1'
       default: println 'default 1'
       default: println 'default 2'
       default: println 'default 3'
       default: println 'default 4'
       }
}

foo()        
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-07-25 10:49:44.0,,,,,,,,,,"0|i2c173:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Joint compiler + @Delegate fail to recognize method signature with default value,GROOVY-4320,12811716,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,aalmiray,aalmiray,23/Jul/10 09:09,22/Feb/22 03:12,14/Jul/23 06:00,18/May/21 00:42,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.16,3.0.10,4.0.0-beta-1,Compiler,,,,1,,,,,,"Spotted this problem when upgrading Griffon to Groovy 1.7.4.

Start with a base contract defined in java

{code}
import java.util.List;
public interface IApp {
    void event(String name);
    void event(String name, List params);
}
{code}

Implement said contract in Groovy
{code}
class BaseApp implements IApp {
    private IApp appDelegate
    BaseApp(IApp app) {
        this.appDelegate = app
    }
    void event(String name, List params = []) {
        // empty
    }
}
{code}

Now create a Groovy class where the previous will be used as delegate

{code}
class RealApp {
    @Delegate BaseApp _base
    RealApp() {
        _base = new BaseApp(this)
    }
}
{code}

Compile the code

{code}
groovyc IApp.java BaseApp.groovy RealApp.groovy
{code}

With Groovy 1.7.3 you get the following method signatures

{code}
$ javap BaseApp | grep event
    public void event(java.lang.String, java.util.List);
    public void event(java.lang.String);
$ javap RealApp | grep event
    public void event(java.lang.String);
    public void event(java.lang.String, java.util.List);
{code}

However 1.7.4 fails to recognize that the second argument to event() has a default value

{code}
$ groovy -version
Groovy Version: 1.7.4 JVM: 1.6.0_17
$ groovyc IApp.java BaseApp.groovy RealApp.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
RealApp.groovy: 1: Can't have an abstract method in a non-abstract class. The class 'RealApp' must be declared abstract or the method 'void event(java.lang.String)' must be implemented.
 @ line 1, column 1.
   class RealApp {
   ^

1 error
{code}","MacOSX Snow Leopard, Groovy 1.7.4, Java 1.6.0_17",aalmiray,emilles,oreissig,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3683,,,,,,"24/Jul/10 17:34;guillaume;GROOVY-4320.patch;https://issues.apache.org/jira/secure/attachment/12722445/GROOVY-4320.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 22 05:11:48 UTC 2012,,,,,,,,,,"0|i2ciof:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jul/10 17:21;paulk;related to or overlaps with or duplicates GROOVY-3683?;;;","24/Jul/10 17:34;guillaume;A patch representing this scenario leveraging the stub generator test infrastructure.
This adds the 3 sample classes, and exhibits the behaviour encountered by Andres.

(of course, I'm not committing this, as it would break the build till we fix the issue);;;","25/Jul/10 03:09;guillaume;Be careful with the patch, the BaseStubTest class was renamed to StubTestCase, so the patch will have to be updated.;;;","22/Nov/12 05:11;aalmiray;New error when compiling the code with 2.0.5

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
RealApp.groovy: -1: The method with default parameters ""void event(java.lang.String, java.util.List)"" defines a method ""void event(java.lang.String)"" that is already defined.
. At [-1:-1]  @ line -1, column -1.
1 error
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Add test/coverage (for CLONE of Joint compilation fails for interfaces with primitive fields),GROOVY-4316,12815256,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,pniederw,pniederw,22/Jul/10 07:37,15/Dec/10 22:19,14/Jul/23 06:00,16/Sep/10 05:19,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,Compiler,,,,0,,,,,,"Try to joint-compile the following Groovy interface:

{code}
interface Bar {
  int bar = 42
}
{code}

Output:
{noformat}
Compile error during compilation with javac.
/var/folders/ak/akL02VQpE-qytx-wR1FH3++++TI/-Tmp-/groovy-generated-7418703305781250498-java-source/Bar.java:10: incompatible types
found   : <nulltype>
required: int
int bar = null;
          ^
1 error
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-07-22 07:37:45.0,,,,,,,,,,"0|i2c54v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Empty primitive arrays evaluate to true,GROOVY-4312,12815119,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,guillaume,pniederw,pniederw,20/Jul/10 11:33,22/Jul/10 17:32,14/Jul/23 06:00,21/Jul/10 04:14,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,Compiler,,,,0,,,,,,"In contrast to other empty collections, empty primitive arrays evaluate to true:

{code}
def x = [] as int[]
assert !x // fails!
{code}

Empty non-primitive arrays behave as expected:

{code}
def x = [] as String[]
assert !x // passes
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"20/Jul/10 14:20;pniederw;GROOVY-4312.patch;https://issues.apache.org/jira/secure/attachment/12722334/GROOVY-4312.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 21 04:14:10 UTC 2010,,,,,,,,,,"0|i2cg5j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jul/10 14:20;pniederw;Here is a patch.;;;","21/Jul/10 04:14;guillaume;Thanks for the quick fix Peter!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"printf not bound to ""out"" in groovlet context as in print/println",GROOVY-4309,12818055,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,gjmathews1,gjmathews1,19/Jul/10 12:11,22/Jul/10 17:32,14/Jul/23 06:00,22/Jul/10 03:30,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,Groovlet / GSP,,,,0,,,,,,"In groovlet print and println are bound to the response.Writer() or out variable so lone print ... and println ... calls are written th the response output Writer as is calls to out.

However, printf calls in goovlet context is still bound to System.out so calls to printf write to System.out not out.

printf method getting invoked is following:
{code}
package org.codehaus.groovy.runtime.DefaultGroovyMethods

    public static void printf(Object self, String format, Object arg) {
        if (self instanceof PrintStream) {
            printf((PrintStream) self, format, arg);
        else
            printf(System.out, format, arg); **** this branch is getting invoked
    }
{code}
Object self is Groovlet class itself which is not instance of PrintStream so System.out is getting used.

Work-around is not using ""printf"" short-cut but explicitly call print/println and String.format() instead.

Test output:
{code}
groovy script output:
1. println test
2. this is a test
3. this is a test

groovlet response:
1. println test
3. this is a test
4. test out.println
{code}

Groovlet test.gsp
{code}
try {
 response.contentType = 'text/plain'
 groovylet = true
} catch (RuntimeException rte) {
 groovylet = false
}

// output to groovlet response
println ""1. println test""

//************************************************************************
// in groovyet context this gets output to System.out not out which is bound to response.getWriter()
printf ""2. this is a %s%n"", 'test' // this is the problem case in groovlet mode
//************************************************************************

print String.format(""3. this is a %s%n"", 'test')

if (groovylet) {
  out.println ""4. test out.println""
}
{code}",Windows/Linux running within Apache Tomcat/6.0.26,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-07-19 12:11:01.0,,,,,,,,,,"0|i2brd3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Grapes doesn't handle properties correctly used in the organisation field of a POM.,GROOVY-4307,12815253,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,seanparsons,seanparsons,18/Jul/10 15:55,14/Sep/10 07:39,14/Jul/23 06:00,18/Jul/10 18:06,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,Grape,,,,0,,,,,,"It would appear that properties can't be used in the organisation field (potentially others) of a POM, which is certainly valid for Maven projects.  I'm not sure how many other things relating to parent projects (as in my example).

Here's the top lines of the stack trace I get from depending on a project that in turn depends on Guava:
General error during conversion: Error grabbing Grapes -- [unresolved dependency: com.google.guava#guava-collections;r03: java.text.ParseException: inconsistent module descriptor file found in 'file:/home/sean/.m2/repository/com/google/guava/guava-collections/r03/guava-collections-r03.pom': bad organisation: expected='com.google.guava' found='${parent.groupId}'; ]

java.lang.RuntimeException: Error grabbing Grapes -- [unresolved dependency: com.google.guava#guava-collections;r03: java.text.ParseException: inconsistent module descriptor file found in 'file:/home/sean/.m2/repository/com/google/guava/guava-collections/r03/guava-collections-r03.pom': bad organisation: expected='com.google.guava' found='${parent.groupId}'; ]
","Linux laptop 2.6.32-24-generic #38-Ubuntu
Groovy Version: 1.7.3 JVM: 1.6.0_20",paulk,sdevitt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 14 07:39:08 UTC 2010,,,,,,,,,,"0|i2bx47:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jul/10 16:46;paulk;I think this is a known problem with Ivy. Can you drop the Ivy jar from here:

http://repo2.maven.org/maven2/org/apache/ivy/ivy/2.2.0-rc1/ivy-2.2.0-rc1.jar

into your Groovy distribution (removing the old one - probably called something like ivy-2.1.0.jar) and see if that helps?

Cheers, Paul.
;;;","18/Jul/10 17:51;seanparsons;Ah, that does appear to have fixed the issue, thanks for the prompt response!;;;","18/Jul/10 18:06;paulk;I upgraded Groovy's version of Ivy, so the next release should also come with the fix.;;;","14/Sep/10 06:32;sdevitt;There is still a problem.   Groovy (or Ivy) seems to be assuming that the packaging = type.  This is not a requirement in a maven repository.  Example the packaging might be a custom packaging which results in an artifact with a type ""jar"". 
;;;","14/Sep/10 07:06;paulk;Can you give an example, i.e. a @Grab statement that doesn't currently work?;;;","14/Sep/10 07:39;sdevitt;Given:

<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>company</groupId>
    <artifactId>tools</artifactId>
    <version>0.0.0.1</version>
    <packaging>mypackaging</packaging>
    
	<properties>
	  <configFile>myjar.conf</configFile>
	</properties>
    
    <build>
        <plugins>
            <plugin>
    			<groupId>company</groupId>
    			<artifactId>tools-maven-plugin</artifactId>
                <version>1.0.1</version>
                <extensions>true</extensions>
            </plugin>
        </plugins>
    </build>
</project>

which deploys an artifact of ""type"" jar,   

@Grab( group=""company"" , module=""tools"" , version=""0.0.0.1"")

complains that it cannot find    company#tools;0.0.0.1!mypackaging  

It still fails if I clean out my grapes folder and change this to 

@Grab( group=""company"" , module=""tools"" , ext=""jar"" , version=""0.0.0.1"" )

The parser is happy with the ""ext="" part  (i.e. it complains if I use something else than ""ext""),  but it still complains about not finding something with an ext = ""mypackaging"".   

The only way I was able to get this to work was to hard code the ivy pattern match to ""jar"" until the artifact was installed.  

Stan;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy Console Icon for Mac OS X broken,GROOVY-4306,12815117,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,guillaume,stefanscheidt,stefanscheidt,15/Jul/10 08:39,21/Jul/11 19:06,14/Jul/23 06:00,21/Jul/11 05:29,1.7.3,1.7.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,1.9-beta-1,Groovy Console,,,,2,,,,,,The icns file includes in groovy-1.7.3 seems to be broken. Find mine enclosed,Mac OS X,ingorichter,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/Jul/11 04:06;tim_yates;groovy.icns;https://issues.apache.org/jira/secure/attachment/12722955/groovy.icns","15/Jul/10 08:39;groovy.icns;https://issues.apache.org/jira/secure/attachment/12722578/groovy.icns","21/Jul/11 05:55;tim_yates;groovyicon.psd;https://issues.apache.org/jira/secure/attachment/12722863/groovyicon.psd",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 21 05:55:35 UTC 2011,,,,,,,,,,"0|i2c0nr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Jul/10 08:39;stefanscheidt;See also GROOVY-4183;;;","15/Jul/10 08:43;stefanscheidt;Replaced my local groovy.icns with this one: http://fisheye.codehaus.org/browse/groovy/trunk/groovy/groovy-core/src/bin/groovy.icns.
That solves the ""problem"".;;;","28/Jul/10 10:26;ingorichter;The groovy.icns is broken with 1.7.4 as well.;;;","16/Sep/10 05:25;guillaume;Andres, did you see what garbles the icon?;;;","21/Jul/11 04:06;tim_yates;Still broken in 1.7.8 and 1.8.0

I created a new groovy.icns file (attached) as well, as the existing icon shows some harsh scaling artifacts when above 32x32 px in size...;;;","21/Jul/11 05:29;guillaume;Hopefully with the new icon the problem's gone.
Thanks Tim for the graphics!;;;","21/Jul/11 05:31;tim_yates;Should I attach the psd?

I think it's something between building the install packages, and pushing the release that is chewing up the icns file, but I have no idea what

Fingers crossed though ;-);;;","21/Jul/11 05:47;guillaume;Yeah, the PSD, we could put it in the graphics folder of SVN.

Regarding the build, we have this which should take care of not chewing the icns file hopefully:
{code}
<fixcrlf srcdir=""${installDirectory}/bin"" eol=""lf"" excludes=""*.bat, *.icns""/>
{code};;;","21/Jul/11 05:55;tim_yates;Cool :-) Fingers crossed!

Here's the PSD (and I'm not precious about this sort of thing, so I really don't mind if someone more visual than me uses it, changes it, or replaces it with something else :-);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"OptimizerVisitor may run twice, corrupting constants",GROOVY-4304,12818054,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,pniederw,pniederw,14/Jul/10 10:15,22/Jul/10 17:32,14/Jul/23 06:00,22/Jul/10 07:32,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,Compiler,,,,0,,,,,,"The issue came up when Paul King showed me a Spock spec behaving in strange ways:

TestSpock.groovy:
{code}
@Grab('org.spockframework:spock-core:0.4-groovy-1.7')
class TestSpock extends spock.lang.Specification {
  def convert = new Converter()

  def 'important scenarios'() {
    expect:
    c == convert.toCelsius(f)

    where:
    c   | f   | scenario
    0   | 32  | 'Freezing'
    20  | 68  | 'Garden party conditions'
    35  | 95  | 'Beach conditions'
    100 | 212 | 'Boiling'
  }
}
{code}

Converter.groovy:
{code}
class Converter {
  def toCelsius (fahrenheit) { (fahrenheit - 32) * 5 / 9 }
}
{code}

If you run this with 'groovy TestSpock.groovy', you will notice that the values for 'c' and 'f' get mixed up. After debugging groovyc, I came to the following conclusion:

Compilation of SpockTest advances until end of phase ""semantic analysis"", then CompilationUnit.dequeued() sets the phase back to ""initialization"". On the second pass, SourceUnitOperation's that have already run are skipped due to this check in CompilationUnit.applyToSourceUnits():

{code}
if ((source.phase < phase) || (source.phase == phase &&
!source.phaseComplete)) ...
{code}

However, Compilation.applyToPrimaryClassNodes() has a slightly different check:

{code}
if (context == null || context.phase <= phase) ...
{code}

source.phaseComplete is not checked here, hence OptimizerVisitor (among others) runs a second time. This leads to wrong results, at least in the case where an AST transform has added additional constants. The TODO in OptimizerVisitor.setConstField() is on the spot.

Adding the source.phaseComplete check to Compilation.applyToPrimaryClassNodes() seemed to solve the problem for Paul. I haven't investigated further if this is the correct approach.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 14 22:16:39 UTC 2010,,,,,,,,,,"0|i2bzb3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Jul/10 22:16;paulk;Patch applied to trunk (changeset 20443) and the 1_7_X branch (changeset 20444). I don't have time at present to write an appropriate test, so leaving open. At least we can test downstream in the meantime.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bug on compiler when using ==~ operator,GROOVY-4299,12815261,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,hoodwgs,hoodwgs,09/Jul/10 19:12,09/Jul/10 20:56,14/Jul/23 06:00,09/Jul/10 20:56,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Compiler,,,,0,,,,,,"A correct expression can't be evaluated by compiler when it ends with \\ (when using ==~ operator),
forcing the user of Pattern.compile()
The code below should run normally and matches strings that starts whith an \ and ends with an \


package h.gr.pat

import java.util.regex.Pattern;
import java.io.BufferedReader;
import groovy.ui.Console;


class TestClass {
	static main(args) {
		println(""start"");
		String str = new BufferedReader(new InputStreamReader(System.in)).readLine();		
		if( str ==~ /\\.*\\/ )
			println(""ok"");
		else
			println(""oops"");
	}

}
","Tested on Windows, but probably it occurs on any environment.",paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 09 20:54:04 UTC 2010,,,,,,,,,,"0|i2c39r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jul/10 20:54;paulk;This isn't anything to do with the ==~ operator but a current limitation on slashy strings which can't have a backslash as the last character. There is an existing issue GROOVY-2701 to fix this limitation. Until that is fixed, the current workarounds are to avoid slashy strings or have some kind of dummy character after the backslash, e.g.:
{code}
str ==~ '\\\\.*\\\\'
{code}
or
{code}
def bs = '\\\\'
str ==~ /$bs.*$bs/
{code}
or
{code}
def dummy = ''
str ==~ /\\.*\\$dummy/
{code}
or
{code}
str ==~ /\\.*\\${''}/
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Joint compilation fails for interfaces with primitive fields,GROOVY-4295,12815254,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,pniederw,pniederw,07/Jul/10 07:01,22/Jul/10 17:32,14/Jul/23 06:00,22/Jul/10 07:38,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,Compiler,,,,0,,,,,,"Try to joint-compile the following Groovy interface:

{code}
interface Bar {
  int bar = 42
}
{code}

Output:
{noformat}
Compile error during compilation with javac.
/var/folders/ak/akL02VQpE-qytx-wR1FH3++++TI/-Tmp-/groovy-generated-7418703305781250498-java-source/Bar.java:10: incompatible types
found   : <nulltype>
required: int
int bar = null;
          ^
1 error
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 07 21:04:12 UTC 2010,,,,,,,,,,"0|i2br13:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Jul/10 21:04;paulk;Trunk and 1_7_X now produce output like the following in the stubs:
{code}
java.lang.String foo0 = null;
char foo1 = new java.lang.Character((char)0);
byte foo2 = new java.lang.Byte((byte)0);
int foo3 = new java.lang.Integer((int)0);
short foo4 = new java.lang.Short((short)0);
long foo5 = new java.lang.Long((long)0);
float foo6 = new java.lang.Float((float)0);
double foo7 = new java.lang.Double((double)0);
boolean foo8 = new java.lang.Boolean((boolean)false);
{code}
Leaving open for now as we still need test coverage and I don't have time straight away to add that.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BUG! exception in phase 'parsing' in source unit 'Script1.groovy' null,GROOVY-4293,12811855,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,livelock,livelock,06/Jul/10 07:43,22/Jul/10 17:32,14/Jul/23 06:00,07/Jul/10 21:48,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,,,,,0,,,,,,"I am encountering another parser ""bug""

does not work:
{code}
def params = new Expando()
params.newValue = 23
def trendMap = ['worsening': (-2), 'slightly worsening':(-1), 'neutral':0 ,'slightly improving': 1,'improving':2]

def obj = []
def el = [obj]
if (!el[1]) el[1] = ""1""

Eval.x(el[0],""x[1]=""+ el[2] ? trendMap[params.newValue.toInteger()] : params.newValue.toInteger() )
{code}
changing the last line to include brackets makes it work
{code}
Eval.x(el[0],""x[1]=""+ (el[2] ? trendMap[params.newValue.toInteger()] : params.newValue.toInteger()) )
{code}

Exception thrown

BUG! exception in phase 'parsing' in source unit 'Script1.groovy' null

	at groovy.util.Eval.me(Eval.java:50)

	at groovy.util.Eval.x(Eval.java:60)

	at groovy.util.Eval$x.call(Unknown Source)

	at ConsoleScript24.run(ConsoleScript24:9)

Caused by: java.lang.NullPointerException

	at java.io.StringReader.<init>(StringReader.java:33)

	... 4 more
Result: 23 
Exception thrown

BUG! exception in phase 'parsing' in source unit 'Script1.groovy' null

	at groovy.util.Eval.me(Eval.java:50)

	at groovy.util.Eval.x(Eval.java:60)

	at groovy.util.Eval$x.call(Unknown Source)

	at ConsoleScript26.run(ConsoleScript26:9)

Caused by: java.lang.NullPointerException

	at java.io.StringReader.<init>(StringReader.java:33)

	... 4 more

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"07/Jul/10 07:27;roshandawrani;4293_v17x.patch;https://issues.apache.org/jira/secure/attachment/12722326/4293_v17x.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 07 21:48:34 UTC 2010,,,,,,,,,,"0|i2c2kf:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"07/Jul/10 05:21;roshandawrani;The only improvement I can think of making here is giving a proper exception when the script is null instead of letting it go further in compilation and fail with a BUG! message.

Apart from that, the behavior you are seeing is same as the behavior of 
{code}
Eval.x(1, null)
{code}

Now, the Eval.x() is receiving null as the script because the + operator has higher precedence than ?:

So, 
{code}
""x[1]=""+ el[2] ? trendMap[params.newValue.toInteger()] : params.newValue.toInteger()
becomes
(""x[1]=""+ el[2]) ? trendMap[params.newValue.toInteger()] : params.newValue.toInteger()
which becomes
(""x[1]=""+ el[2]) ? trendMap[23] : 23
which results in null because boolean expression is true and trendMap[23] is null
{code}

To get the operators right as per their precedence order, you need to use () as you have used and make it
{code}
""x[1]=""+ (el[2] ? trendMap[params.newValue.toInteger()] : params.newValue.toInteger())
{code};;;","07/Jul/10 07:27;roshandawrani;Proposed patch attached.

After the patch

{code:title=Test.groovy}
def params = new Expando()
params.newValue = 23
def trendMap = ['worsening': (-2), 'slightly worsening':(-1), 'neutral':0 ,'slightly improving': 1,'improving':2]

def obj = []
def el = [obj]
if (!el[1]) el[1] = ""1""

Eval.x(el[0],""x[1]=""+ el[2] ? trendMap[params.newValue.toInteger()] : params.newValue.toInteger() )
{code}
fails with
{noformat}
Caught: java.lang.IllegalArgumentException: Script text to compile cannot be null!
	at Test.run(Test.groovy:9)

{noformat};;;","07/Jul/10 11:15;blackdrag;looks good;;;","07/Jul/10 21:48;roshandawrani;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassHelper.ClassHelperCache#classCache is not thread-safe,GROOVY-4292,12815224,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,gromopetr,gromopetr,05/Jul/10 12:48,15/Jun/12 22:56,14/Jul/23 06:00,23/May/12 06:05,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.7,2.0-rc-1,class generator,,,,9,,,,,,"When parsing Groovy scripts from multiple threads at a time, the call to WeakHashMap.get() may never return due to internal corruption due to the concurrent access. Since IntelliJ IDEA does its GDSL parsing in parallel threads, this blocks it completely.",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 23 06:05:17 UTC 2012,,,,,,,,,,"0|i2bqyn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jul/10 13:53;blackdrag;No wonder, mos of the compiler infrastructure is designed for single thread usage only. I would have suggested to use makeWithoutCaching, but that ends in makeCached too, which uses the map. I think that must be changed then. 

As for a workaround... is it impossible to do some kind of warmup?;;;","05/Jul/10 14:07;gromopetr;As a workaround, we'll now do the parsing in a single thread. But that may take quite long. A warmup could help, if I knew exactly what to invoke to ensure everything's warmed up.

If it were IDEA sources, I'd just replace WeakHashMap with ConcurrentWeakHashMap, as we have one :);;;","05/Jul/10 14:21;blackdrag;the warmup would have to contain all the ClassHelper#make calls you usually do. The problem cannot be there for the static stuff that is in that class, since the WeakHashMap may not be able to handle concurrent writes, but concurrent reads are no problem;;;","05/Jul/10 15:22;gromopetr;The problem is that I don't do any ClassHelper#make calls. I just say new GroovyShell().parse(text) for different script texts. So it's not clear to me which classes should be cached in the map to account for any possible script text.;;;","23/May/12 06:05;blackdrag;I replaced the map with an internal concurrent version from our runtime;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyScriptEngine can't refresh class from url other than file,GROOVY-4288,12815239,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,wonder365,wonder365,02/Jul/10 01:45,05/Apr/15 14:43,14/Jul/23 06:00,01/Sep/10 09:20,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,GroovyScriptEngine,,,,0,,,,,,"the class GroovyScriptEngine loaded from a url other than file will never be updated. I made a patch for it.

exam:
gse = new groovy.util.GroovyScriptEngine(new String[] { ""scripts"",
				""http://localhost/"" });
gse.getConfig().setMinimumRecompilationInterval(0);

the class from http://localhost/ will never refresh.

I found this when made a URL type for JDBC.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4175,,,,,,"29/Jul/10 21:59;wonder365;GroovyScriptEngine.java.patch;https://issues.apache.org/jira/secure/attachment/12722331/GroovyScriptEngine.java.patch","02/Jul/10 01:45;wonder365;GroovyScriptEngine.patch;https://issues.apache.org/jira/secure/attachment/12722633/GroovyScriptEngine.patch","29/Jul/10 21:59;wonder365;test.zip;https://issues.apache.org/jira/secure/attachment/12722571/test.zip",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Thu Jul 29 21:59:08 UTC 2010,,,,,,,,,,"0|i2cblj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jul/10 07:22;guillaume;The approach seems to be working fine here.
I also tested on Google App Engine that had some issues with the rewrite of GroovyScriptEngine in the past, and all seems to be working fine there.;;;","29/Jul/10 21:57;wonder365;1.7.4 also has this bug.
I made a patch and a test case.;;;","29/Jul/10 21:59;wonder365;in test.zip I write a URL use Map, and test the IsSourceNewer function.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyScriptEngine doesn't recompile updateted script,GROOVY-4286,12811856,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,peddn,peddn,01/Jul/10 03:16,22/Jul/10 17:32,14/Jul/23 06:00,21/Jul/10 18:24,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,GroovyScriptEngine,,,,0,,,,,,"If you run the following java code and alter the executed script while running, it is unpredictable when GroovyScriptEngine recompiles the script. Sometimes it works, sometimes not.

{code:title=GroovyScriptEngineTest.java|borderStyle=solid}
public class GroovyScriptEngineTest {

	public static void main(String[] args) throws Exception {

		GroovyScriptEngine groovyScriptEngine = new GroovyScriptEngine(""/home/peddn/groovy"");
		
		groovyScriptEngine.getConfig().setMinimumRecompilationInterval(0);
		
		while (true) {

			Class<?> groovyClass = groovyScriptEngine.loadScriptByName(""TestPrint.groovy"");

			GroovyObject groovyObject = (GroovyObject) groovyClass.newInstance();

			Object[] groovyArgs = {};

			groovyObject.invokeMethod(""testPrint"", groovyArgs);

                        //check for recompile every half second
			Thread.sleep(500L);

		}

	}

}
{code}

{code:titel=TestPrint.groovy|borderStyle=solid}
class TestPrint {

	public void testPrint() {
		
		System.out.println(""hello World"");
		
	}
	
}
{code}

here some suggestions from a [discussion|http://groovy.329449.n5.nabble.com/GroovyScriptEngine-doesn-t-recompile-updateted-script-tp511841p511841.html] at the mailing list:


I fact I think its kind of bug in GroovyScriptEngine here is code 
snippet: 

{code}
    protected boolean isSourceNewer(ScriptCacheEntry entry) throws 
ResourceException  { 
        if (entry == null) return true; 
        long time = System.currentTimeMillis(); 

        ScriptCacheEntry newEntry = new 
ScriptCacheEntry(depEntry.scriptClass, time, depEntry.dependencies); 
        scriptCache.put(scriptName, newEntry); 
    } 
{code}
I think more right solution is using aomthing like this: 
{code}
    protected boolean isSourceNewer(ScriptCacheEntry entry) throws 
ResourceException  { 
        if (entry == null) return true; 
        long time = long time = <get entry file lastModified 
timestamp> 

        ScriptCacheEntry newEntry = new 
ScriptCacheEntry(depEntry.scriptClass, time, depEntry.dependencies); 
        scriptCache.put(scriptName, newEntry); 
    }
{code}
",,peddn,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 21 18:24:32 UTC 2010,,,,,,,,,,"0|i2cgcf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jul/10 07:41;guillaume;I'm wondering which version of Groovy's source code you're looking at, as isSourceNewer seems to be pretty different from what you're quoting. And GroovyScriptEngine does some checks like if (entryChangeTime > lastMod) to ensure we're reloading when appropriate.;;;","21/Jul/10 08:18;guillaume;I've reproduced the behaviour with two scripts in the same directory:

With runner.groovy
{code}
def gse = new GroovyScriptEngine(""."")
gse.config.recompileGroovySource = true
gse.config.minimumRecompilationInterval = 0
		
while (true) {
	def groovyClass = gse.loadScriptByName(""script.groovy"")
	def groovyObject = groovyClass.newInstance()
	groovyObject.run()
	sleep 500
}
{code}

And script.groovy
{code}
println ""hello Groovy World !""
{code}

Changes to the script are sometimes picked up and sometimes not.
I've not really figured out why yet.;;;","21/Jul/10 08:30;guillaume;Using
{code}
gse.run(""script.groovy"", binding)
{code}
doesn't change much either, anyway, it's calling the same loadScriptByName() method in the end.;;;","21/Jul/10 18:24;guillaume;Should be fixed now.
There was indeed an issue with the reloading and in light of the minimum reloading interval.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
XmlUtil.serialize doesn't seem to pick right method for GPathResult,GROOVY-4285,12815229,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,tim_yates,tim_yates,01/Jul/10 02:33,22/Jul/10 17:32,14/Jul/23 06:00,01/Jul/10 08:44,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,groovy-jdk,XML Processing,,,0,,,,,,"The following gives an error:

{code}
import groovy.xml.XmlUtil
import groovy.xml.StreamingMarkupBuilder

def xmlStr = """"""<?xml version=""1.0"" encoding=""UTF-8""?>
<stuff ver=""1.0"">
  <properties>
    <foo>bar</foo>
  </properties>
</stuff>""""""

def gpr = new XmlSlurper().parseText( xmlStr )
println XmlUtil.serialize( gpr )
{code}

Gives the following error:

{code}
[Fatal Error] :1:1: Content is not allowed in prolog.
ERROR:  'Content is not allowed in prolog.'
<?xml version=""1.0"" encoding=""UTF-8""?>
{code}

However if we change the println to:

{code}
println XmlUtil.serialize( (groovy.util.slurpersupport.GPathResult)gpr )
{code}

We get the correct output:

{code}
<?xml version=""1.0"" encoding=""UTF-8""?>
<stuff ver=""1.0"">
  <properties>
    <foo>bar</foo>
  </properties>
</stuff>
{code}

Looks like Groovy is picking the wrong method somewhere... (though I can't see how)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 01 08:44:32 UTC 2010,,,,,,,,,,"0|i2bv9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jul/10 05:03;roshandawrani;The issue is that groovy.util.slurpersupport.Node#writeTo(Writable) does not generate the String form of the nodes correctly.

Where it should generate 
{noformat}
<stuff ver='1.0'><properties><foo>bar</foo></properties></stuff>
{noformat}
it generates
{noformat}
bar
{noformat}

And then with the xml string going simply as ""bar"", it throws the ""Content is not allowed in prolog."" error correctly.;;;","01/Jul/10 05:16;roshandawrani;Apart from the issue highlighted in the previous comment, there also seems to be some method selection bug in here.

Here are 2 snippets that highlight the difference in method selections made by groovy:
1)
{code}
interface I {}

class C implements I {}

class Methods {
    def foo(I i) {
        println ""foo(Interface) called""
    }
    def foo(C i) {
        println ""foo(Class) called""
    }
} 

new Methods().foo(new C())
{code}
results in 
{noformat}
foo(Class) called
{noformat}

2) But if I have a slight variant
{code}
interface I {}

class P implements I {}
class C extends P {}

class Methods {
    def foo(I i) {
        println ""foo(Interface) called""
    }
    def foo(P p) {
        println ""foo(Class) called""
    }
} 

new Methods().foo(new C())
{code}
now the method selection is different and it outputs
{noformat}
foo(Interface) called
{noformat}

Because of this method selection bug, it chooses 
{code}
String serialize(Writable writable)
{code}
over
{code}
String serialize(GPathResult writable)
{code}
and goes into the buggy method.;;;","01/Jul/10 08:44;roshandawrani;Discussed the method selection with Jochen and the difference highlighted in comments above is by design and desired in other scenarios. 

So fixed the serialization bit in XMLUtil.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Constant integer and double expressions in AstBuilder.buildFromCode { } cause NoSuchFieldErrors at runtime,GROOVY-4272,12815242,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,bcarr,bcarr,30/Jun/10 12:42,22/Jul/10 17:32,14/Jul/23 06:00,01/Jul/10 12:50,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,ast builder,,,,0,,,,,,"the following blocks of code cause a NoSuchFieldError at runtime in the transformed class due to failure to look up a constant:

new AstBuilder.buildFromCode{ return 1 }
new AstBuilder.buildFromCode{ return 1.0 }
new AstBuilder.buildFromString(""return 1"")

I've attached an example and the test that shows the failure.

The current workaround is to use the String constructor of their java.lang.Number equivalents:

new AstBuilder.buildFromCode{ return new Integer(""1"") }
new AstBuilder.buildFromCode{ return new Double(""1.0"") }

My suspicion is that the compiler is optimizing the inline constants away, but that the reference to those constants are in some intermediary generated class which is thrown away later instead of the intended target classes.
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"01/Jul/10 00:57;roshandawrani;4272_v17x.patch;https://issues.apache.org/jira/secure/attachment/12722442/4272_v17x.patch","30/Jun/10 12:42;bcarr;MyConstants.java;https://issues.apache.org/jira/secure/attachment/12722682/MyConstants.java","30/Jun/10 12:42;bcarr;MyConstantsASTTransformation.groovy;https://issues.apache.org/jira/secure/attachment/12722567/MyConstantsASTTransformation.groovy","30/Jun/10 12:42;bcarr;MyConstantsTest.groovy;https://issues.apache.org/jira/secure/attachment/12722515/MyConstantsTest.groovy",,,,,4.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 01 12:50:24 UTC 2010,,,,,,,,,,"0|i2c5f3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"30/Jun/10 23:18;roshandawrani;The issue is there because local annotations processing and OptimizerVisitor processing both happen in SEMANTIC_ANALYSIS phase.

Since the transformation in the given example creates some methods in CANONICALIZATION phase, OptimizerVisitor does not get a chance to add const$ fields and hence the NoSuchFieldError.

Should we close this as ""Won't fix"" - as it is always possible to shoot yourself in the foot by introducing nodes late in the compilation cycle for which some of the normal compilation (previous phases) are skipped?;;;","30/Jun/10 23:57;roshandawrani;A slightly more specific reason is that when we do AstBuilder.buildFromCode(), the code passed to it goes through all phases and also OptimizerVisitor and that's why return new Integer(""1"") becomes return $const$0 but the constant pool is added to the temporary script class that the string passed to AstBuilder.buildFromCode() becomes a part of.

Later on when the return statement gets attached to another ClassNode, that other classnode does not have any constant pool attached to it, because OptimizerVisitor did not visit it.

That's where the issue comes from - the statement refers to $const$0 but the class does not have it - this never happens when a class normally gets compiled by the compiler.;;;","01/Jul/10 00:57;roshandawrani;Attaching a patch for review.

Earlier OptimizerVisitor was clubbed with StaticImportVisitor and did its thing in staticImport operation in SEMANTIC_ANALYSIS phase. 

The patch now moves OptimizerVisitor to a separate operation 'optimize' in CANONICALIZATION phase.

With this patch, if MyConstantsASTTransformation is modified to be executed in SEMANTIC_ANALYSIS phase, then the sequence of events becomes:

1)  AstBuilder.buildFromCode() compiles the given expression which has $const$0 reference.

2)  MyConstantsASTTransformation attaches the method having the above expression to a new classnode.

3)  Since the MyConstantsASTTransformation is now in SEMANTIC_ANALYSIS phase and OptimizerVisitor comes later in CANONICALIZATION phase (its new position in compilation cycle), OptimizerVisitor now processes the new ClassNode and creates the constant pool correctly.

The only thing I am not sure of is whether moving OptimizerVisitor to later in compilation cycle will have any impact on deeply-integrating frameworks like Groovy++ or Spock, etc. I guess, it won't, but I am not sure.;;;","01/Jul/10 12:50;roshandawrani;Fixed. OptimizerVisitor moved to classgen now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
metaClosure not called when using named parameters in Sql.rows,GROOVY-4269,12815211,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,aperry,aperry,30/Jun/10 03:36,13/May/12 03:30,14/Jul/23 06:00,05/May/12 00:24,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0-beta-3,,SQL processing,,,,1,,,,,,"Running the following code shows the problem:
{code}
import groovy.sql.*

def sql = Sql.newInstance([...])

def metaClosure = { meta ->
  meta.each { col ->
    println col.columnName
  }
}

println ""Named:""

sql.rows(""SELECT COUNT(*) AS Number FROM Table WHERE Id BETWEEN :start AND :end"", [start: 10000, end: 11000], metaClosure).each { res ->
  println res[0]
}

println ""Ordinal:""

sql.rows(""SELECT COUNT(*) AS Number FROM Table WHERE Id BETWEEN ? AND ?"", [10000, 11000], metaClosure).each { res ->
  println res[0]
}
{code}

Result on my computer:
{code}
Named:
994
Ordinal:
Number
994
{code}

Showing the metaClosure that prints the column name is not called when using named parameters.","Windows XP SP3, JVM 1.6.0_07",aperry,paulk,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 05 00:24:34 UTC 2012,,,,,,,,,,"0|i2bxwn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Jun/10 03:55;paulk;What happens if you put your map in a list, e.g.:
{code}
[[start: 10000, end: 11000]]
{code}
I suspect we don't support metaClosure with the arbitrary params required for ordinal params. We could do some smart looking up of the last param I guess.;;;","30/Jun/10 04:56;roshandawrani;Yes, method selection seems at fault here. 

For the args (String, Map params, Closure), it chooses rows(String query, Object[] params) over rows(String query, List params, Closure metaClosure) and thus metaClosure fails to get executed.;;;","30/Jun/10 04:58;roshandawrani;For me, wrapping params in a list as [[start: 1, end: 5]] worked.;;;","30/Jun/10 05:03;roshandawrani;Paul, the javadoc of Sql#rows(String sql, List<Object> params, Closure metaClosure) needs to be updated if metaClosure support is not there with arbitrary params required for ordinal params. 

Javadoc for the metaClosure version of rows() can be updated with a named parameter example (with the extra list wrapping);;;","30/Jun/10 05:30;paulk;Roshan, are you suggesting some clarification, e.g. changing this:
{quote}
This method supports named and named ordinal parameters.
{quote}
to this:
{quote}
This method supports named and named ordinal parameters by supplying such parameters in the {{params}} list.
{quote};;;","30/Jun/10 05:41;roshandawrani;Yes. The current javadoc has the following example:
{code}
sql.rows(""select * from PERSON where lastname like ?"", ['%a%'], metaClosure)
{code}
but there is no named parameters example, and the first natural attempt is probably to try 
{code}
sql.rows(""select * from PERSON where lastname like :alastname"", [alastname: '%a%'], metaClosure)
{code}
but what the current method selection logic requires is
{code}
sql.rows(""select * from PERSON where lastname like :alastname"", [[alastname: '%a%']], metaClosure)
{code}

I think this point/example needs to come in the javadoc - as it suits best.;;;","30/Jun/10 08:05;paulk;Comment updated.

Wondering whether we can do some smarts to detect when a (meta) closure is the last param for the Object[] case. And allow that method to also support named and ordinal params.
;;;","30/Jun/10 08:38;roshandawrani;Wondering whether we will then want to go beyond the last param and do smarts for detecting the following method as well, for example:
{code}
def foo(String, List, Closure, Closure){...}
{code};;;","05/May/12 00:24;paulk;The fix for GROOVY-5405 should also fix this issue. Let me know if you have any further problems.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Breaking change in enum syntax,GROOVY-4268,12815219,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pniederw,pniederw,29/Jun/10 17:44,22/Jul/10 17:32,14/Jul/23 06:00,02/Jul/10 21:36,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,Compiler,,,,0,,,,,,"The following code compiles in 1.7.2, but not in 1.7.3:

{code}
private enum EnumWithToString {
  VALUE
  String toString() { ""I'm a value"" }
}
{code}

groovyc output:

{noformat}
unexpected token: VALUE @ line 337, column 3.
     VALUE
     ^

1 error
{noformat}

The compile error goes away when adding a semicolon after ""VALUE"".
",,paulk,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"01/Jul/10 19:45;paulk;groovy4268_enum_regression.patch;https://issues.apache.org/jira/secure/attachment/12722516/groovy4268_enum_regression.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jul 02 21:36:07 UTC 2010,,,,,,,,,,"0|i2cet3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jun/10 23:47;roshandawrani;Looks to be caused by r19830 (on groovy.g) - changes made for GROOVY-3986 and GROOVY-3047. 

If I revert that change, the given example compiles fine again.

I suspect that in particular, it is due to GROOVY-3047(enum definition does not allow trailing comma), but I can't be sure as fixes for 2 JIRAs are combined in the same revision (which I wish weren't but may be they were too inter-dependent).

Anyway we seem to have the regression r19830 onwards.;;;","01/Jul/10 19:45;paulk;proposed patch attached;;;","02/Jul/10 11:12;roshandawrani;I tried testing it and found no further issues.;;;","02/Jul/10 21:36;paulk;Patch applied. Peter, thanks for spotting this and Roshan, thanks for the cross-check.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unable to import static for static inner classes,GROOVY-4267,12811798,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,28/Jun/10 06:58,07/Apr/15 19:07,14/Jul/23 06:00,01/Jul/10 04:17,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,,,,,0,,,,,,"This issue tracks partial implementation of this functionality. See note at end of description.

----

Given this Java class (note the _static_ inner class):
{code}
package pkg;

public class Outer {
    public static class Inner {}
}
{code}
The inner class can be printed from Java using this:
{code}
import pkg.Outer.Inner;
//import static pkg.Outer.Inner;

public class Main {
    public static void main(String[] args) {
        System.out.println(Inner.class.getName());
    }
}
{code}
Note that both the non-static or static version (shown commented out) will work.

For Groovy, the non-static version works:
{code}
import pkg.Outer.Inner

println Inner.class.name
{code}

but the static version doesn't:
{code}
import static pkg.Outer.Inner

println Inner.class.name
{code}
instead, it fails with:
{noformat}
Caught: groovy.lang.MissingPropertyException: No such property: Inner for class: TestStaticImport
{noformat}

NOTE: The initial implementation of functionality for this issue works for external jars/classes on the classpath and for classes included in the same file but doesn't work for the critical case of external groovy files. As that case also doesn't work for attempts to import using a non-static variation of import, I think it is worthy of its own issue and so GROOVY-4287 has been created to track remaining work.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 01 04:17:08 UTC 2010,,,,,,,,,,"0|i2ci13:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jun/10 04:16;paulk;Java also supports star import variation:
{code}
import static pkg.Outer.*
{code}
the _star_ can be an inner class not just a field or method.
;;;","29/Jun/10 07:56;roshandawrani;The static import of the inner class does not work in the following scenario. Run Test.groovy to reproduce with both files in the same directory.

{code:title=Test.groovy}
import static Outer.*

assert PI == 3.14
assert Inner.class.name != null
{code}

{code:title=Outer.groovy}
class Outer {
    static PI = 3.14
    static class Inner {}
}
{code}

Output:
{noformat}
Caught: groovy.lang.MissingPropertyException: No such property: Inner for class: Test
        at Test.run(Test.groovy:4)
{noformat};;;","29/Jun/10 21:37;paulk;If you change the import in {{Test.groovy}} to either:
{code}
import static Outer.PI
import Outer.*
{code}
or
{code}
import static Outer.PI
import Outer.Inner
{code}
it still won't run.

I suspect we need to go through a bunch of edge cases and clarify behaviour.;;;","29/Jun/10 21:51;roshandawrani;Import of static inner classes that only works if the importer and importee are in the same file looks a half-baked feature to me. It is not an edge case to have your code in more than one file. 

Useless to say that groovy now supports imports of static inner classes alongwith fields and methods but which breaks as soon as we spread code outside 1 file.

You point to non-static import here, which does not work - but I see it as 2 incomplete features both of which we should try to fix.;;;","29/Jun/10 22:05;paulk;I agree with your points and think all cases need fixing. I don't think it is to do with being in the same file but pre-compiled vs not.;;;","29/Jun/10 22:23;roshandawrani;Don't know about the internals. I haven't looked at it yet. So you may be right that the cause is pre-compiled or not. I meant that at the usage level it works only if in one file and not otherwise.

Even when you have importer and importee in one file, there are still bugs in the implementation:

1) The following example works only when the module has a package. If you uncomment ""package test"", it works, but if the code is in default package, it does not work.
{code}
//package test

import static Outer.Inner

assert Inner.class != null

class Outer {
    static class Inner {}
}
{code}

2) Another issue is that the code changes made wrongly enable ""resolve"" of non-static inner classes through ""import static"" as well

The following code works, but should not
{code}
import static Outer.* /* this is the line that enables non-static Outer$Inner's resolution */

// import static Outer.Inner - if instead this form is used, the behavior is correct

assert Inner.class != null

class Outer {
    class Inner {} /* this is a non-static inner class */
}
{code};;;","30/Jun/10 07:28;paulk;Above examples now work but still more testing would be useful;;;","30/Jun/10 08:05;roshandawrani;Looks ok, except the first issue reported. I understand from Paul that it is intentionally commented out for now, but just for completeness of the picture here, the following example still doesn't work, i.e., if you have a script in a separate file, you cannot import its static inner classes.

{code:title=Outer.groovy}
class Outer {
    static class Inner {}
}
{code}

{code:title=Test.groovy}
import static Outer.*

println Inner.class
{code}
fails with
{noformat}
Caught: groovy.lang.MissingPropertyException: No such property: Inner for class: Test
        at Test.run(Test.groovy:4)
{noformat}

I will update if I find any further issues.;;;","30/Jun/10 08:17;paulk;But ok if there is a package?;;;","30/Jun/10 08:29;roshandawrani;Import of static inner classes from other files is failing with the package or without package.;;;","30/Jun/10 08:57;paulk;Strange. This works fine for me:
{code:title=pkg/Outer.groovy}
package pkg
class Outer {
    static class Inner {}
}
{code}

{code:title=Test.groovy}
import static pkg.Outer.Inner
// import static pkg.Outer.* // or this

println Inner.class.name
{code}
succeeds with
{noformat}
pkg.Outer$Inner
{noformat}
;;;","30/Jun/10 09:02;roshandawrani;I had the Test.groovy also in the same package and then it did not work. Can u check if that works for you?;;;","30/Jun/10 09:06;roshandawrani;Even the pkg/Outer.groovy + Test.groovy combination does not work for me. Maybe someone else can give it a try.

How about no-package scenario? Does that work for you as well?;;;","30/Jun/10 18:46;paulk;I had a precompiled {{pkg.Outer}} hiding there from an earlier test. That is gone now and I think I have the same results as you now. Of course if I just use a PI field or property I get the same result so nothing to do with static Inner classes per se.;;;","30/Jun/10 19:14;roshandawrani;I am not sure I understand your comparison with PI.
If I have the following code
{code:title=Test.groovy}
import static Outer.*

println PI

println Inner.class
{code}
and
{code:title=Outer.groovy}
class Outer {
    static PI = 3.14
    static class Inner {}
}
{code}
then I get the output as
{code}
3.14
Caught: groovy.lang.MissingPropertyException: No such property: Inner for class: Test
        at Test.run(Test.groovy:5)
{code}

Doesn't that mean that PI is working as expected but static inner is not?;;;","30/Jun/10 21:47;paulk;Sorry, ignore the PI reference - also due to the temporary test case I deleted. Can you try:
{code}
import static Outer.PI
import Outer.Inner
{code}
;;;","30/Jun/10 23:02;roshandawrani;Paul, I think you are again going back to what we started with. ;-)

{code:title=PreviouslyRaised.Roshan}
Import of static inner classes that only works if the importer and importee 
are in the same file looks a half-baked feature to me. It is not an 
edge case to have your code in more than one file. 

...

You point to non-static import here, which does not work - but I see it 
as 2 incomplete features both of which we should try to fix.
{code}

{code:title=Replied.Paul}
I agree with your points and think all cases need fixing.
{code}

Anyway, here is the output you asked for:
{noformat}
import static Outer.PI // works - I think we can ignore this now, as it always works
import Outer.Inner // does not work 
import static Outer.Inner // does not work 
import static Outer.* // does not work 
{noformat}
;;;","01/Jul/10 02:54;paulk;Yes, just trying to draw a line in the sand now with current codebase - which I think we have well and truly done! ;-);;;","01/Jul/10 04:17;paulk;I thought the svn changes and comments were already getting long and tracking further changes including the non-static stuff all under the one issue might have been messy, so I split out remaining work into GROOVY-4287.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,
CLONE -Wrong generation of import statements in stubs,GROOVY-4266,12815231,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,rnd,rnd,27/Jun/10 02:45,03/Feb/22 22:35,14/Jul/23 06:00,10/Jan/22 15:07,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,4.0.0,,,Stub generator / Joint compiler,,,,1,,,,,,"NOTE: Below is fixed, this issue is for tracking additional impots added at end of other imports, e.g. {{import java.io.*;}}

----

Single-type import declarations in Groovy files are collected/converted into type-on-demand import declarations by the stub compiler -- in other words,
{code}
import my.package.Type1
import my.package.Type2
{code}
becomes
{code}
import my.package.*;
{code}

This breaks the type shadowing mechanisms described in Section 7.5.1 of the Java Language Specification (3rd edition) and leads to Java compiler errors like ""cannot decide which of the classes to use"".

Moreover, current implementations is based on an unordered set, thus destroying the order of import declarations.

Attached patch solves these issues by preserving both the form and the order of original import declarations.","Windows XP, Sun JDK 1.6.0_19",emilles,jstell,paulk,,,,,,,,,,"eric-milles opened a new pull request #1669:
URL: https://github.com/apache/groovy/pull/1669


   https://issues.apache.org/jira/browse/GROOVY-4266
   
   Types are written out fully-qualified.  Only non-type static imports are required for variable expressions.


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;03/Jan/22 03:10;githubbot;600","eric-milles merged pull request #1669:
URL: https://github.com/apache/groovy/pull/1669


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jan/22 15:06;githubbot;600",,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Wed Jan 12 07:34:28 UTC 2022,,,,,,,,,,"0|i2buvr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jun/10 02:51;paulk;I found an example (GroovyServ project) where removing the default imports means their project no longer compiles using the joint compiler. I am keeping the patch from GROOVY-4225 in place so extra ""*"" imports aren't added but will temporarily add back in the default imports (java.io, java.net, etc.) - though at the end not at the start where they were before. This will allow them to compile their project using a SNAPSHOT.

This issue is a placeholder. We need to work out why the classes aren't being fully resolved, fix it and then remove the default import code.;;;","03/Jan/22 01:55;emilles;[~paulk]
The only thing I can think of that would still require the imports is annotation values.  If you have ""@Tag(value=Type.NAME)"" it does not print out ""Type"" fully-qualified.;;;","10/Jan/22 15:07;emilles;https://github.com/apache/groovy/commit/36d2c3baccfcd7635806db820f7857c42175d6ab;;;","12/Jan/22 07:34;paulk;[~emilles] The project which had trouble (quite a few years back now) when we removed the default imports was groovyserv. I couldn't see any annotation values in that codebase that referenced types. I did however successfully build that project using a local Groovy 3 snapshot with the changes related to this issue applied, so I think this is safe for Groovy 4.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Delegate's dealing with static methods seems incorrect,GROOVY-4265,12815205,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,roshandawrani,roshandawrani,26/Jun/10 08:50,22/Jul/10 17:32,14/Jul/23 06:00,26/Jun/10 17:46,1.7.4,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,,,,,0,,,,,,"@Delegate's dealing with static methods seems incorrect

In the code below, shouldn't the call from B#main() go to C#foo()?

If for a delegate method (which can only be an instance method), if the owner class has a static method, the delegate method should be the one used.

{code:title=A.groovy}
class A {
     static foo(){println ""A->foo()""}
}
{code}
{code:title=B.groovy}
class B extends A {
     @Delegate C c = new C()
     static main(args){
        new B().foo()
     }
}
{code}
{code:title=C.groovy}
class C {
     def foo(){println ""C->foo()""}
}
{code}

The above code outputs
{noformat}
A->foo()
{noformat}
but it should output
{noformat}
C->foo()
{noformat}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jun 26 22:25:04 UTC 2010,,,,,,,,,,"0|i2bn5b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jun/10 17:36;paulk;Yes, definitely think this is wrong and inconsistent. Static from super should have lower priority.;;;","26/Jun/10 17:46;paulk;fixed but please comment if you think of any issues with provided solution;;;","26/Jun/10 22:25;roshandawrani;Seems perfect. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovyc Ant task hard-codes,GROOVY-4259,12815240,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,jonbrisbin,jonbrisbin,23/Jun/10 16:50,05/Apr/15 14:44,14/Jul/23 06:00,24/Jun/10 01:02,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,Ant integration,,,,0,,,,,,"The ant task for Groovy hard-codes the glob pattern ""*.groovy"" when searching for source files. This obviously doesn't work for those of us who use a different extension (like "".g""). I've attached a patch that adds a property called ""scriptExtension"" to the task, which parallels GMaven's defaultScriptExtension property. This makes the extension configurable. It defaults to "".groovy"" but can be changed if one uses something different.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/Jun/10 16:50;jbrisbin;script-extension-patch.txt;https://issues.apache.org/jira/secure/attachment/12722566/script-extension-patch.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Thu Jun 24 01:02:54 UTC 2010,,,,,,,,,,"0|i2ccdj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Jun/10 01:02;roshandawrani;Thanks for the patch. Applied after a minor change.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
wiki-snapshot.pdf is not searchable. Text can't be copied.,GROOVY-4258,12815246,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,guillaume,ladermann@hbg.dpa.de,ladermann@hbg.dpa.de,23/Jun/10 03:44,10/Jul/13 04:42,14/Jul/23 06:00,04/Jul/13 12:12,1.7.0,1.7.1,1.7.2,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-beta-1,,,GroovyDoc,,,,1,,,,,,"The wiki-snapshot.pdf is only searchable on the first few pages. On most of the pages it is neither possible to search or to copy text. The latter produces unreadable and unusable text. E.g on page 5 marking and copying the text ""class A"" leads to ""½´¿-- ß"". Probably there is something wrong with embedded fonts?","Linux, KDE, okular",pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 04 12:12:30 UTC 2013,,,,,,,,,,"0|i2bnsf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Jul/13 12:12;pschumacher;Is fixed now that Guillaume created a new snapshot a few days ago.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Collection.unique() method might remove not duplicate items,GROOVY-4257,12811795,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,fangyixun,fangyixun,22/Jun/10 01:54,22/Jul/10 17:33,14/Jul/23 06:00,23/Jun/10 15:39,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-1,,,groovy-jdk,,,,0,,,,,,"list=[[3035, 26972], [2795, 34412]]
list.unique()
println list

Result: [[3035, 26972]]

list=[[3035, 26972], [2795, 34412]]
list.unique{it}
println list

Result: [[3035, 26972]]

Because the unique method use NumberAwareComparator<T> to compare elements in the collection, and NumberAwareComparator<T> will use object's hashCode to compare two object when the object doesn't have a compareTo method, then the two list [3035, 26972], [2795, 34412] are considered to be duplicate(because they have the same hashCode).

Will it be better to use equals method to decide whether two elements are duplicate? 
As the document say:
""A convenience method for making a collection unique using a Closure to determine duplicate (equal) items. If the closure takes a single parameter, the argument passed will be each element, and the closure should return a value used for comparison (either using {@link Comparable#compareTo(Object)} or {@link Object#equals(Object)}). If the closure takes two parameters, two items from the collection will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique).""
","Windows XP, JDK 1.6.0_19, GROOVY 1.7.0",paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"22/Jun/10 15:51;paulk;groovy4257_SetUnique.patch;https://issues.apache.org/jira/secure/attachment/12722680/groovy4257_SetUnique.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 22 19:44:50 UTC 2010,,,,,,,,,,"0|i2c6xj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jun/10 02:06;fangyixun;set=[[3035, 26972], [2795, 34412]].asType(Set)
set.unique()
println set

Result: [[2795, 34412], [3035, 26972]]

set=[[3035, 26972], [2795, 34412]].asType(Set)
set.unique{it}
println set

Result: [[2795, 34412]]

when the collection is a Set, unique() and unique{it} will return different results, because the unique() method will return self but unique{it} method will convert self to a list before remove duplicate items.
;;;","22/Jun/10 15:51;paulk;Proposed patch attached;;;","22/Jun/10 19:44;paulk;Patch applied currently to trunk (for 1.8).;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
BUG! exception in phase 'class generation' ... SpreadExpression should not be visited here,GROOVY-4255,12815178,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,livelock,livelock,19/Jun/10 16:57,02/May/17 02:03,14/Jul/23 06:00,01/Jun/15 13:04,1.7.3,2.4.0-rc-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.5.0-alpha-1,,,Compiler,,,,0,,,,,,"this code produces the error:
println [*it.albumId.text().split("","")]&#8203;

BUG! exception in phase 'class generation' in source unit 'Script1.groovy' SpreadExpression should not be visited here",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/Jun/10 12:01;roshandawrani;4255_v18x.patch;https://issues.apache.org/jira/secure/attachment/12722274/4255_v18x.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 01 13:04:27 UTC 2015,,,,,,,,,,"0|i2bmhb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jun/10 17:24;blackdrag;additionally comment: println ([*it.albumId.text().split("","")]) works and is most probably what the Andre wanted;;;","20/Jun/10 00:16;roshandawrani;Slightly shorter version that reproduces the BUG!
{code}
println [*it]
{code};;;","20/Jun/10 00:54;roshandawrani;Where x([*y]) results in the AST MethodCallExpression[ArgumentsListExpression[SpreadExpression]],

x[*y] results in the AST BinaryExpression[VariableExpression( x ), operation(""getAt""/""[""), SpreadExpression]

I am wondering what will be a good fix for this BUG! - not allow SpreadExpression with ""["" in a BinaryExp?

Usages like x = [*y] and x in [*y] result in [*y] becoming ListExpr[SpreadExpr], which takes care of spread handling, but when it is x[*y], ListExpr wrapping does not happen because then ""["" becomes the getAt operator.;;;","20/Jun/10 01:03;roshandawrani;Or should we change BinaryExp[VarExp, ""["", SpreadExp] to BinaryExp[VarExp, ""["", ListExp[SpreadExp]]?;;;","20/Jun/10 07:58;blackdrag;I think we have two possible options to give x[*y] a meaning.

1) follow the method call version: x\(*y) turns into a method call with as many arguments as y contains. So x[*y] would become equal to x.getAt\(*y)

2) make it producing a list: [*y] creates a list with as many elements as y has. [*y,1] creates a list with the elements of y and ""1"" as additional element. So the option would be to make x[*y] into x[[*y]]

I personally think that (1) is more fitting, since x[*y] is a getAt and not a list, even if that is maybe what was originally intended. Also it is perfectly fine in Groovy to have a getAt with more than one element, but it is almost never used;;;","20/Jun/10 10:28;livelock;though while x[2,3] is maybe really never used x[2..3] and the likes are actually used, eg. in x[1..-3]

I believe though the problem is another one, it is that the alternative syntax for 1 paramter calls, like i intuitively tried ""x ..."" is not equivalent to ""x(...)"" in groovy at the moment
OR stated differently: that as well as ""x[...]"" also ""x [...]"" is a valid getAt - which is nowhere documented, if you check  http://groovy.codehaus.org/JN1035-Maps for example you will not find a single example with an extra space and also personally i would haved assumed that only ""x[..]"" converts to getAt while ""x [..]"" (extra space) does not.

it may be a breaking change for some programs (i personally have never seen getAt access involve an additional space), but I would vote to
 disallow an extra space in map access
making ""println [2,3]"" not result in property access (current behaviour) but in ""println([2,3])""
this *might* be a breaking change, but then it is nowhere documented that it should work and i think its counter-intuitive and i have seen no programmer use it -> x[*y] then becomes x.getAt(*y) and ""x [*y]"" becomes x([*y])

def x = [2,3]
println [*x] equivalent to println([2,3])
println[*x] equivalent to println[2,3]
that may break a little % of programs but it´s intitively right i feel;;;","20/Jun/10 14:12;roshandawrani;@Andre, I don't think the usage of space in ""println [2,3]"" is going to change its meaning.
{code}
""abc"" [
1]
{code}
works just alright, and also the following
{code}
""abcd"" .
size()
{code}

Letting the whitespace introduce a semantic difference when in general, it doesn't do so looks to me something that it will introduce unnecessary inconsistency besides being a breaking change.

People migrating stuff from Java may find it extremely uneasy that their code like following does not work because groovy now turns astr [0] into astr([0])
{code}
String[] astr = new String[1];
astr[0] = ""X"";
String str1 = astr [0];
{code};;;","20/Jun/10 14:21;roshandawrani;Jochen, I am not sure I understand the difference between your 2 suggestions. They look same to me.

1) You say x[*y] becomes equals to x.getAt( *y ) with as many args as y has - so if y has 2 args, it becomes x.getAt(a, b)

2) x[*y] turns into x[[*y]] === x.getAt[*y] === x.getAt(a, b) - This is what ACG does now, right?

So, don't both of them end up becoming the same? Or, I didn't understand the difference properly?;;;","20/Jun/10 16:24;blackdrag;x.getAt[*y] is not the transformation for x[[*y]]. It is x.getAt([*y]). Instead x.getAt[*y] would first get a property ""getAt"" from x and then execute res[*y], with res being x.getAt. And infact this resolving logic would lead into an endless loop. Again...

(1) x[*y] -> x.getAt\(*y) -> x.getAt(a,b)
(2) x[*y] -> x[[*y]] -> x.getAt([*y]) -> x.getAt([a,b])

The major difference is if we make the call to getAt with a,b directly, or with them wrapped in a list. 
;;;","20/Jun/10 16:26;blackdrag;Andre, I know that some languages have this difference for list and getAt wiht the space. It is not documented as being a difference, because there is normally not much need to say that something makes no difference in a language that has not much white space sensitvity at all. Groovy is never sensitive to tab or space. It is sensitive to newlines, but that is all. ;;;","20/Jun/10 17:30;livelock;if its between option 1 and 2, option 1 is definitely what you would expect
i like the groovy paradigm of being greedy and not space sensitive, still in this case it conflicts with the ease of groovys one parameter method call syntax which is also extremely popular
if you think about it, 90% of users will assume that println [2,3] does indeed print alist
i just also found an exception case, assert!
&#8203;assert [1,2] != &#8203;[1,2]&#8203; <- also here we don´t have a property access
and even the example that fails for println works here
assert [*[1,2]] == [1,2]&#8203;;;;","20/Jun/10 23:11;roshandawrani;@Jochen, I am gathering from your last comment that you dropped the ""res being x.getAt"" idea half-way through the comment - getAt as a property access(without any args) doesn't make much sense to me anyway. I think it should be a method call that makes sense with the arguments it takes (which is what 1) and 2) in the later part of your comment look like).

So, just to confirm, the choice is now between how to pass the arguments to the ""getAt"" method call, right?

1) x[*y] -> x.getAt(a,b), or

2) x[*y] -> x.getAt([a,b])

I incline towards the first one.;;;","21/Jun/10 03:30;guillaume;The first one also seems the most natural to me. (ie. x[*y] -> x.getAt(a,b));;;","21/Jun/10 08:11;blackdrag;the first one it is then ;;;","21/Jun/10 12:01;roshandawrani;Attaching a patch for review. After patching, the following becomes the behavior:

A)  Following snippet compiles without any BUG! now but 
    fails at runtime because println [*xxx] is equivalent to println.getAt(*xxx)
{code}
println [*it.albumId.text().split("","")]
{code}

B)  Following snippet compiles without any BUG! now but 
    fails at runtime because println [*it] is equivalent to println.getAt(*it)
{code}
println [*it]
{code}

C)  Following compiles and executes fine now
{code}
def indices = [1,2]
def foo = [1,2,3,4,5]
assert foo[*indices, 3] == foo[1, 2, 3]
assert foo[*indices] == foo[1, 2]
{code};;;","21/Jun/10 21:22;paulk;Looks good to me. I would probably add something like:
{code}
// expected to parse but would fail with MissingPropertyException if run
{code}
as a comment on first two testcases;;;","21/Jun/10 22:34;roshandawrani;Thanks for reviewing the patch, Paul. I will add the comments to the tests. Good point.

I'll wait for a few hours to see if Guillaume/Jochen have any further comments, else check-in.;;;","22/Sep/11 03:11;paulk;Was this progressed? Can it be closed?;;;","01/Jun/15 13:04;paulk;Thanks for everyone involved in this issue.

This was essentially solved as part of GROOVY-6212 but I tweaked the error message a little for the case of trying to despread a map in case a spread-map operator was intended.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler wrongly compiles a ClosureListExpression that results in NoSuchMethodError at runtime,GROOVY-4254,12815195,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,18/Jun/10 04:37,22/Jul/10 17:33,14/Jul/23 06:00,18/Jun/10 05:27,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-1,,,class generator,,,,0,,,,,,"r19740 removed the following constructor from CurriedClosure class
{code}
public CurriedClosure(Closure uncurriedClosure, int i) {
    this(uncurriedClosure, new Object[]{Integer.valueOf(i)});
}
{code}

ACG still calls this non-existent constructor in the bytecode it generates for ClosureListExpression and the compiled code results in the following error at runtime
{noformat}
java.lang.NoSuchMethodError: org.codehaus.groovy.runtime.CurriedClosure.<init>(Lgroovy/lang/Closure;I)V
{noformat}

Here is the test to reproduce it:
{code}
import org.codehaus.groovy.runtime.CurriedClosure

class GroovyXXXXBug extends GroovyTestCase {
    void testClosureListExpressionUsage() {
        def clList = (1;2)
        assert clList[0] instanceof CurriedClosure
        assert clList[1] instanceof CurriedClosure
    }
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 18 05:27:49 UTC 2010,,,,,,,,,,"0|i2ck5b:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"18/Jun/10 05:27;roshandawrani;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Invalid code crashes the compiler,GROOVY-4252,12815201,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,aclement,aclement,17/Jun/10 19:01,22/Jul/10 17:32,14/Jul/23 06:00,21/Jun/10 07:21,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,Compiler,,,,0,,,,,,"This code:

{code}
class Crasher {
	public void m() {
		def fields = [1,2,3]
		def expectedFieldNames = [""patentnumber"", ""status""].
		for (int i=0; i<fields.size(); i++) {
			Object f = fields[i] 
			System.out.println(f); 
		}
	}
}
{code}

is not valid (I believe?).  There is an extraneous '.' on the end of the second 'def' line.  Instead of a nice error message about having done something wrong, we get this stack on compilation:

{code}
>>> a serious error occurred: BUG! exception in phase 'class generation' in source unit 'Crasher.groovy' tried to get a variable wit
h the name i as stack variable, but a variable with this name was not created
>>> stacktrace:
BUG! exception in phase 'class generation' in source unit 'Crasher.groovy' tried to get a variable with the name i as stack variable
, but a variable with this name was not created
        at org.codehaus.groovy.classgen.CompileStack.getVariable(CompileStack.java:263)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitClosureExpression(AsmClassGenerator.java:1759)
        at org.codehaus.groovy.ast.expr.ClosureExpression.visit(ClosureExpression.java:46)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4071)
        at org.codehaus.groovy.classgen.AsmClassGenerator.makeCallSite(AsmClassGenerator.java:2147)
        at org.codehaus.groovy.classgen.AsmClassGenerator.makeCall(AsmClassGenerator.java:1984)
        at org.codehaus.groovy.classgen.AsmClassGenerator.makeCall(AsmClassGenerator.java:1970)
        at org.codehaus.groovy.classgen.AsmClassGenerator.makeInvokeMethodCall(AsmClassGenerator.java:1953)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:2300)
        at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:72)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4071)
        at org.codehaus.groovy.classgen.AsmClassGenerator.assignmentCastAndVisit(AsmClassGenerator.java:4012)
        at org.codehaus.groovy.classgen.AsmClassGenerator.evaluateEqual(AsmClassGenerator.java:3962)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitDeclarationExpression(AsmClassGenerator.java:1442)
        at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:53)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4071)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:1430)
        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
{code}",Windows 7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"19/Jun/10 05:26;roshandawrani;4252_v17x.patch;https://issues.apache.org/jira/secure/attachment/12722565/4252_v17x.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 21 07:21:34 UTC 2010,,,,,,,,,,"0|i2chen:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jun/10 02:51;roshandawrani;Looked a bit into it and I have a few questions.

1) Should the following compile
{code}
[].foo(1;2;3)
{code}

2) What is a ClosureListExpression? Is it of use outside for loops? In what kind of code? For def x = (1;2;3), do multiple closures get generated?

The AST for the JIRA example takes the form def expectedFieldNames = [].for(ClosureListExpression) {for loop body as a ClosureExpression}, and then ACG runs into this BUG because for variable i, no variable is declared because it is not really treated as a for loop here but separate scope ClosureListExpression and ClosureExpression.;;;","18/Jun/10 04:55;blackdrag;first.. a BUG! message must not happen. Then about the ClosureListExpression. I added that quite some time before I added the for loop. It is not an official feature, because it was mostly rejected by the people. I use it sometimes though. (1;2;3) generates a list of closures, but behind it there is a single closure and the list contains only closures with jump points. The structure behind was thought to be used for some kind of continuations, but not really thought through.

The variable is treated right in the variable scope stuff, but asm does not know about this well enough. And so it fails in a way it should not. The code whould have been rejected way before reaching that point or simply work.

Now... if the example would produce a message, that list has no ""for"" method... would that be too strange?;;;","18/Jun/10 05:01;roshandawrani;>> Now... if the example would produce a message, that list has no ""for"" method... would that be too strange?

To do that, we need to get rid of the compilation error first, right? Such a message makes sense only at runtime due to possible MOP injections, right?

I thought too that it was a grammar/AST issue but then ClosureListExpression processing makes it correct grammar/AST-wise, in a sense. So I wasn't sure which way to get rid of the issue.;;;","18/Jun/10 05:18;blackdrag;In the light of GROOVY-4252 I suggest to let the compiler recognize the ClosureExpression as error in APP;;;","18/Jun/10 05:21;roshandawrani;You mean ClosureListExpression? (recognizing ClosureExpression as an error would be quite suicidal :-) )

And you mean we get rid of that unofficial ClosureListExpression feature (at least block the entry to it and keep rest of the code behind for now)?;;;","18/Jun/10 06:00;blackdrag;ahem.... ClosureListExpression of course, sorry ;)
I suggest we don't change the grammar and let the compiler fail in APP if something returns a ClosureListExpression, which should not take one. The removal of the ClosureListExpression itself may cause problems, since I think the for-loop uses it internally - even if it does, in the end, not create a list of closures.

This still means that for the issue at hand, the compiler would then through an error for the ClosureListExpression usage after the for and not for the wrongly used ""."". In fact the ""."" is not wrong, a method called ""for"" is very well allowed in Groovy. We need a good message for this, otherwise the user will be majorly confused. 

What would be a good message here?;;;","18/Jun/10 06:16;roshandawrani;Just to understand better, you are suggesting that we block the use of ClosureListExpression everywhere but in the for loop, right? That java-like for loop would remain the only legal use and other places need to reject the code?;;;","18/Jun/10 06:51;blackdrag;yes, I don't want to remove it completely, since I think we may have it at a later point maybe. So for now let's block it;;;","18/Jun/10 06:52;blackdrag;unles someone here says that we maybe should instead enable this fully;;;","19/Jun/10 05:26;roshandawrani;Attaching a patch for review.

A ClosureListExpression anywhere except the for loop is rejected by APP now. Below is how the output looks like in various scenarios:

A)
{code}
a)  [].bar(1;2;3)

b)  def x = (1;2;3)

c)  [].for(1;2;3){println ""in loop"";break}

{code}
produces
{noformat}
Invalid use of the list of expressions here. 
It is supported only for traditional java-like for loops. 
A possible cause could be that for loop is invoked as a method by mistake. at line: 1 column: 8.
a)   [].bar(1;2;3)
            ^
  
b)   def x = (1;2;3)
              ^
c)   [].for(1;2;3){println ""in loop"";break}
            ^
{noformat}

B)
{code}
class Crasher {
    public void m() {
        def fields = [1,2,3]
        def expectedFieldNames = [""patentnumber"", ""status""].
        for (int i=0; i<fields.size(); i++) {
            Object f = fields[i] 
            System.out.println(f); 
        }
    }
}
{code}
produces
{noformat}
Invalid use of the list of expressions here. 
It is supported only for traditional java-like for loops. 
A possible cause could be that for loop is invoked as a method by mistake. at line: 5 column: 14.
           for (int i=0; i<fields.size(); i++) {
                ^
{noformat}

C) The following compiles successfully as the only permitted use of ClosureListExpression (under for loop).
{code}
for(int i = 0; i < 5; i++){println i}
{code};;;","19/Jun/10 06:17;roshandawrani;An alternative message could be:
{noformat}
Invalid use of the expression list. Either the for loop has been invoked 
as a method by mistake, or the list of expressions is not supported in this context.
{noformat};;;","20/Jun/10 23:12;roshandawrani;Hi. anyone got a chance to review the patch?;;;","21/Jun/10 03:17;guillaume;I've not looked at the patch itself, but the rationale and behaviour you explained look fine to me.;;;","21/Jun/10 03:19;roshandawrani;The patch itself is quite small and simple too. It's more of taking a call on the behavior after the patch and the friendliness of the error message.;;;","21/Jun/10 03:27;guillaume;Indeed, the patch was pretty simple, sorry for not having had a look at it before commenting.
The patch does look good to me too.
I'm wondering if someday we could have some use for this syntax though, but that's another story :-) (and we can reenable things later if needed anyway)
Otherwise, the error message is okay to me.
The sole thing I'm wondering about it is: ""list of expressions"". [a, b, c] is also a list of expressions. So perhaps we should just say a ""closure list of the form (a; b; c)"" is not supported in this context?;;;","21/Jun/10 03:33;roshandawrani;But on the face of it, ""(a;b;c)"" and even ""for(int i=0; i<1;i++)"" don't really to seem to have anything to do with the closures, I think.

How about ""expression list of the form (a; b; c) is not supported in this context""?;;;","21/Jun/10 03:41;guillaume;""expression list of the form (a; b; c) is not supported in this context"" sounds good to me.;;;","21/Jun/10 07:21;roshandawrani;Done.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,
Power assert doesn't pretty-print empty String,GROOVY-4250,12815217,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,nobeans,nobeans,16/Jun/10 20:22,22/Jul/10 17:32,14/Jul/23 06:00,18/Jun/10 02:29,1.7.3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,,,,,0,,,,,,"expected:
{code}
$ groovy -e 'assert new String() == ""xxx"";'
Caught: Assertion failed: 

assert new String() == ""xxx""
       |            |
       |            false
       """"
{code}

but actual:
{code}
$ groovy -e 'assert new String() == ""xxx"";'
Caught: Assertion failed: 

assert new String() == ""xxx""
       |            |
       |            false
       java.lang.String@45c3987
{code}",,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Jun/10 23:14;roshandawrani;v17x_4250.patch;https://issues.apache.org/jira/secure/attachment/12722325/v17x_4250.patch","17/Jun/10 23:36;roshandawrani;v17x_4250_v2.patch;https://issues.apache.org/jira/secure/attachment/12722279/v17x_4250_v2.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 18 02:29:45 UTC 2010,,,,,,,,,,"0|i2c21r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jun/10 23:14;roshandawrani;Currently it is by design that AssertionRenderer gives a null or blank ("""") value a representation like <class_name>@<hash_code>.

But I think the String classes can be excused from this design. 
For them it does not make much sense and a better representation may be the requested ("""").

I am attaching a patch for the same.

After the change assert new String() == ""xxx"", assert new StringBuilder() == ""xxx"" and assert new StringBuffer() == ""xxx"" all result in the following output

{noformat}
Caught: Assertion failed: 

assert new String[Buffer|Builder]() == ""xxx""
       |            |
       """"           false

    at TryGroovy.run(TryGroovy.groovy:1)
{noformat};;;","17/Jun/10 02:16;guillaume;What if the string contaings """"? ;-)
But in general, yes, I've hit by this aspect myself: ""Why doesn't it shows the class/hashcode stuff instead of the string? Ah, yeah, that's because the string is empty"".
So a better representation is needed.
I was wondering if something more explicit like <empty string> or something like that would be better? (ie. the case someone really puts """" in a string).
But +1 for the patch anyway as it's better than the current behaviour. 
We just need to be sure what's the best representation of an empty string is in power asserts.;;;","17/Jun/10 02:20;roshandawrani;And what if someone gives ""<empty string>"" as the string? ;-);;;","17/Jun/10 02:50;nobeans;+1 <empty string>

I changed my mind ;-)
because power assert currently doesn't use double quotations for not-empty string.
I think that using double quotations is not very good in view point of symmetric only when it's empty string.

I think either of followings is good:
(A) not-empty string: ""xxx"", empty string: """"
(B) not-empty string: xxx, empty string: <empty string>
;;;","17/Jun/10 02:54;roshandawrani;Ok. Let's be symmetric for now and see if any other suggestions/objections arise.

Else, I will apply the patch by end of the day.

Thanks for sharing the views.;;;","17/Jun/10 04:14;guillaume;Actually, Yasuharu's idea of quoting strings always is not a bad idea at all. That way, """" will always the empty string, and if ever the string is composed of two double quotes, then the result would be """"""""... not very valid syntax though... hmmm...;;;","17/Jun/10 04:22;roshandawrani;I say """"(empty) and xxx(non-empty). Simple. What symmetry?;;;","17/Jun/10 10:31;blackdrag;There would be another alternative... <class_name>@<hash_code> (empty toString())
This would then be a general ""solution"", not limited to String;;;","17/Jun/10 10:42;roshandawrani;Too long, I think, to represent """".

But if we do it, then may be for toString() returning null, we should render <class_name>@<hash_code> (null toString()) or <class_name>@<hash_code> (null)?

Currently if toString() returns null or """", it prints out <class_name>@<hash_code>.;;;","17/Jun/10 10:58;blackdrag;hmm... how about j.l.String@45c3987(toString()=="""") and j.l.String@45c3987(toString()==null)? Well the later obviously will not happen, it is just for the general pattern... what I suggest is basically shortening the package name and use a groovy expression style text to explain ""the situation"".;;;","17/Jun/10 11:06;russel;Avoid shortening java.lang to j.l. on the grounds that it is not guaranteed that j.l. is actually java.lang. ?;;;","17/Jun/10 11:09;roshandawrani;I don't like j.l.String either. I still think """" conveys an empty String well enough and j.l.String(toString() == """") is not really needed.;;;","17/Jun/10 11:43;guillaume;Yeah, let's stick with """" and null.;;;","17/Jun/10 11:53;pniederw;To give you some background: I had almost every solution mentioned in this thread implemented at some point ("""", (toString() returned null), etc.), but I always came across another case where the output was misleading. That's why in the end, I decided to implement the simplest conceivable solution and then wait for external feedback. Seems that has now happened.

Using new String() in an assertion makes no sense, so I assume the question is how to render the following:

{code}
def x = """"
assert x == ""123""
{code}

My favorite rendering for the empty String is """" because I find it more intuitive than, say, <empty String>. We could certainly wrap all Strings with """", the advantage being that the value wouldn't be disconnected from the bar if the String contained leading control characters like \n or \b. On the other hand, once you open the Jeannie bottle, follow-up questions arise:

- What if Foo's toString() returns ""foo""?
- Should we wrap chars with '' (or display them as: ""x"" as Char) ?
- Should we escape control characters in Strings?
- etc.

And yes, I had implemented all this at some point. :-)

As for the null value, it is already rendered as: null;;;","17/Jun/10 12:03;pniederw;To be more precise, I'm proposing the following:

if the value is null, render: null
if the value is the empty String, render: """" // only this should have to be added
if the value's toString() method returns null or the empty String, fall back to Object.toString();;;","17/Jun/10 12:09;roshandawrani;Going by your last proposal, for ""new StringBuilder()/new StringBuffer()"" will still get rendered as StringBuilder@123456 and StringBuffer@123456.

I propose:
if the value is null, render: null
if the value is the empty String, render: """" // modified behavior
if the value's toString() method returns null, render <class>@<hashcode>(null) // modified behavior
if the value's toString() method returns empty String, render """" // modified behavior

With this, for all empty instance of String/StringBuffer/StringBuilder, we get """" rendered.;;;","17/Jun/10 12:41;pniederw;>> Going by your last proposal, for ""new StringBuilder()/new StringBuffer()"" will still get rendered as StringBuilder@123456 and StringBuffer@123456.

Not sure about these two classes, but do we really want to render any object whose toString() method returns the empty String as: """"

>> if the value's toString() method returns null, render <class>@<hashcode>(null) // modified behavior

We already have:
{noformat}
Foo@3495868c (toString() threw java.lang.Exception)
{noformat}
We could print similar messages if toString() returns null or the empty String.
;;;","17/Jun/10 23:41;roshandawrani;Attaching the consolidated patch here (v2).

Following is the output in various scenarios now:

A)
{code}
assert new String() == ""xxx""
{code}
produces
{noformat}
assert new String() == ""xxx""
       |            |
       """"           false
{noformat}

B)
{code}
assert new StringBuffer() == ""xxx""
{code}
produces
{noformat}
assert new StringBuffer() == ""xxx""
       |                  |
       """"                 false
{noformat}

C)
{code}
assert new StringBuilder() == ""xxx""
{code}
produces
{noformat}
assert new StringBuilder() == ""xxx""
       |                   |
       """"                  false
{noformat}

D)
{code}
class EmptyToString {
    String toString(){""""}
}
def e = new EmptyToString()
assert e == ""xxx""
{code}
produces
{noformat}
assert e == ""xxx""
       | |
       | false
       EmptyToString@19da4fc (toString() == """")
{noformat}

E)
{code}
class NullToString {
    String toString(){null}
}
def n = new NullToString()
assert n == ""xxx""
{code}
produces
{noformat}
assert n == ""xxx""
       | |
       | false
       NullToString@19da4fc (toString() == null)
{noformat}

F)
And as before (no change here), the following
{code}
class ExceptionToString {
    String toString(){throw new RuntimeException()}
}
def ex = new ExceptionToString()
assert ex == ""xxx""
{code}
produces
{noformat}
assert ex == ""xxx""
       |  |
       |  false
       ExceptionToString@13c6a22 (toString() threw java.lang.RuntimeException)
{noformat};;;","17/Jun/10 23:46;guillaume;It looks like a great concensus to me, Roshan.;;;","18/Jun/10 02:29;roshandawrani;Done.;;;",,,,,,,,,,,,,,,,,,,,,,,,,
CLONE -JavaStubGenerator doesn't generate annotations available in Groovy code - More Tests required,GROOVY-4248,12811776,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,genie,genie,14/Jun/10 13:13,08/Jul/14 15:28,14/Jul/23 06:00,13/Jun/14 00:07,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.3.4,2.4.0-beta-2,,Stub generator / Joint compiler,,,,0,,,,,,"We made some progress on the original issue GROOVY-4118 and so we closed it for the 1.7.3 release. This issue captures remaining work, primarily some additional test cases.
{quote}
Looking at org.codehaus.groovy.tools.javac.JavaStubGenerator (http://goo.gl/ob23) I see it doesn't generate annotations that are originally available in Groovy sources.

I think it causes those issues later:
* http://jira.codehaus.org/browse/GMAVEN-68 - ""GMaven: generateStubs generates stubs without original Javadocs or annotations""
* http://jira.codehaus.org/browse/GMAVEN-4  - ""GMaven: Stub generation should generate annotations""

I'm trying to use AnnoMojo annotations (http://goo.gl/rbRw) when developing my MOJOs in Groovy.
GMaven's ""generateStubs"" goal doesn't produce Java sources with original AnnoMojo annotations
{quote}
",,paulk,unquietcode,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 13 00:07:03 UTC 2014,,,,,,,,,,"0|i2bz9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Nov/12 14:09;unquietcode;What is the status of parameter annotations? This has implications for some of the JAX-RS tooling which I work with daily.

A simple example for clarity's sake:{noformat}
@Path(""/myURL/{pathVariable}"")
public Response getView(@PathParam(""pathVariable"") String pathVariable) {
    // ...
}
{noformat}

Here the {{@Path}} annotation makes it to the stub just fine, but not the {{@PathParam}}.;;;","13/Jun/14 00:07;paulk;OK, I added support for keeping Parameter annotations in stubs. I think that covers all of the use cases discussed in this issue. If any more use cases are found, please open a new issue with details.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Issue with incrementing array when using Random number generation,GROOVY-4246,12815222,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,krstn,krstn,11/Jun/10 05:24,22/Jul/10 17:32,14/Jul/23 06:00,23/Jun/10 12:39,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,,,,,0,,,,,,"I have found an issue with array incrementation, when using randomly generated number as array index.
The idea was to randomly increment one of the indexes.
For array of size = 3 and 10 incrementations I can see array was modified like this [example from system.out]:
[0, 0, 1]
[0, 0, 1]
[2, 0, 1] should be [1,0,1]
[2, 3, 1] should be [1,1,1]
[3, 3, 1] should be [2,1,1]
[3, 2, 1] now I'm puzzled as the digit is decremented!
[3, 2, 1] what was incremented? no one knows! ;]
[3, 2, 2] 
[3, 2, 3]
[3, 3, 3]

See the code attached.

Additional info:
When the randomiser invocation is moved to assign value to a variable, and then variable is used as array index it works fine.",Windows 7 64 bit,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/Jun/10 00:42;roshandawrani;4246_v18x.patch;https://issues.apache.org/jira/secure/attachment/12722436/4246_v18x.patch","11/Jun/10 05:24;krstn;Bug.groovy;https://issues.apache.org/jira/secure/attachment/12722441/Bug.groovy",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 23 14:25:41 UTC 2010,,,,,,,,,,"0|i2cm5z:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Jun/10 06:08;blackdrag;after playing around a bit I think that the call to rand() is done multiple times... I added a simple counter to the method and found, that rand() is called 30 here. I think that a[exp]++ is converted into: {code:Java}
a.putAt(exp, a.getAt(exp).next())
a.getAt(exp)
{code}
while the correct code should look more like:
{code:Java}
tmp = exp
a.putAt(tmp,a.getAt(tmp).next())
a.getAt(tmp)
{code}
arguably the code could be improved further to do:
{code:Java}
tmp = exp
res = a.getAt(tmp).next()
a.putAt(tmp,res)
res
{code}
This would save one more getAt call, increasin performance a little.;;;","11/Jun/10 06:10;roshandawrani;The given code consistently works if I change 
{code}
arr[rand()]++
{code}
to
{code}
int x = rand()
arr[x]++
{code}

More after some more investigation.;;;","11/Jun/10 06:11;roshandawrani;Simultaneous posts. Looks like Jochen already investigated the cause.;;;","23/Jun/10 00:42;roshandawrani;Hello.

Attaching here a patch for review. Here is how the bytecode looks like after applying the patch for the postfix evaluation part of ""arr[exp]++"":

{code}
Object tmp = exp;
Object localObject1 = ""getAt"".call(arr, tmp);
Object localObject2 = ""next"".call(localObject1);
""putAt"".call(arr, tmp, localObject2); 
return localObject1;
{code}

As captured in the test, the rand() expression is now correctly evaluated only 10 times instead of 30.;;;","23/Jun/10 10:09;blackdrag;good work;;;","23/Jun/10 12:39;roshandawrani;Thanks Jochen. :-);;;","23/Jun/10 14:25;krstn;Thanks guys. Looking forward to stable release with this fix.
Groovy will become groovier.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyScriptEngine breaks with UnsupportedClassVersionError using JDK 1.4,GROOVY-4245,12815215,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,wrschneider99,wrschneider99,09/Jun/10 10:17,23/Jun/10 15:51,14/Jul/23 06:00,09/Jun/10 20:59,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,"Exception:

java.lang.UnsupportedClassVersionError: groovy/util/GroovyScriptEngine (Unsupported major.minor version 49.0)
        at java.lang.ClassLoader.defineClass0(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java(Compiled Code))
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java(Co
mpiled Code))
        at com.ibm.ws.classloader.CompoundClassLoader._defineClass(CompoundClass
Loader.java(Compiled Code))
        at com.ibm.ws.classloader.CompoundClassLoader.findClass(CompoundClassLoa
der.java(Compiled Code))
        at com.ibm.ws.classloader.CompoundClassLoader.loadClass(CompoundClassLoa
der.java(Compiled Code))
        at java.lang.ClassLoader.loadClass(ClassLoader.java(Compiled Code))
",JDK 1.4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 09 20:59:39 UTC 2010,,,,,,,,,,"0|i2cf4v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jun/10 10:28;guillaume;Perhaps a bit more background would be needed.
Groovy requires Java 5+ starting from Groovy 1.7.
We still provide a JDK 1.4 compliant version of Groovy, but it's only Groovy 1.6.8.;;;","09/Jun/10 11:54;wrschneider99;Sorry, I get exactly the same error with groovy-1.6.8.jar instead.

;;;","09/Jun/10 11:56;roshandawrani;Did you try http://dist.groovy.codehaus.org/distributions/groovy-binary-jdk14-1.6.8.zip ?;;;","09/Jun/10 12:20;wrschneider99;Thanks, that worked.  

So this is really a documentation issue: 
- ""getting started"" tutorial says 1.4 or higher is required but does not indicate that 1.4 requires special treatment.
http://groovy.codehaus.org/Tutorial+1+-+Getting+started
- the JDK 1.4 version isn't linked from the download page.;;;","09/Jun/10 12:25;roshandawrani;True. It can provide links to JDK 1.4 versions for 1.6.x entries on the download page and also mention at http://groovy.codehaus.org/Tutorial+1+-+Getting+started that 1.7+ require minimum 1.5.;;;","09/Jun/10 12:48;roshandawrani;Guillaume, on the download page, can we change
{noformat}
Groovy 1.6.8

You can have a look at the JIRA release notes.

Download zip: Binary Release | Source Release
{noformat}
to
{noformat}
Groovy 1.6.8

You can have a look at the JIRA release notes.

Download zip: Binary Release (JDK 1.4 version) | Source Release
{noformat}
and link ""JDK 1.4 version"" to the corresponding JDK 1.4 zip?

1.5.8 is also linked from download page but its 1.4 version is not published at http://dist.groovy.codehaus.org/distributions/. Not sure what to do about that.;;;","09/Jun/10 14:04;guillaume;Please go ahead and make the changes you deem fit! Don't hesitate.;;;","09/Jun/10 15:08;blackdrag;Wasn't 1.5.8 based on jdk 1.4 ?;;;","09/Jun/10 15:46;guillaume;I think for 1.5 we were using 1.4 bytecode, except where we needed 1.5 bytecode.
So 1.5.8, out of the box, is already compatible with JDK 1.4 as far as I remember.;;;","09/Jun/10 20:59;roshandawrani;Updated the documentation.

http://groovy.codehaus.org/Tutorial+1+-+Getting+started - now mentions that ""while groovy 1.6 supports JDK 1.4 or greater, for groovy 1.7 onwards, minimum JDK 1.5 is needed""

http://groovy.codehaus.org/Download - now also links to JDK 1.4 versions of 1.6.8 and 1.6.7;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Properties cannot be set through a @Delegate,GROOVY-4244,12815172,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,cdanielw,cdanielw,09/Jun/10 03:15,23/Jun/10 15:45,14/Jul/23 06:00,09/Jun/10 11:27,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"When accessing a non-final property through a @Delegate as below, a ReadOnlyPropertyException is thrown.

{code}
class DelegateTests extends GroovyTestCase {
    void testNonFinalPropertiesCanBeSet() {
        def foo = new Foo()
        foo.baz = ""baz""
        assert foo.baz == ""baz""
    }
}

class Foo {
    @Delegate Bar bar = new Bar()
}

class Bar {
    String baz
}
{code}

{noformat}
groovy.lang.ReadOnlyPropertyException: Cannot set readonly property: baz for class: test.Foo
	at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:2406)
	at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:3307)
	at test.Foo.setProperty(DelegateTests.groovy)
	at org.codehaus.groovy.runtime.InvokerHelper.setProperty(InvokerHelper.java:179)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.setProperty(ScriptBytecodeAdapter.java:483)
	at test.DelegateTests.testNonFinalPropertiesCanBeSet(DelegateTests.groovy:11){noformat}",,cdanielw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 09 11:27:09 UTC 2010,,,,,,,,,,"0|i2bsb3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"09/Jun/10 11:27;roshandawrani;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Incorrect super class for script containing an anonymous inner class,GROOVY-4243,12818051,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,adammurdoch,adammurdoch,08/Jun/10 18:45,23/Jun/10 15:45,14/Jul/23 06:00,09/Jun/10 05:54,1.7.0,1.7.1,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"When a script contains an anonymous inner class, then the compiler seems to ignore the {{scriptBaseClass}} property of {{CompilerConfiguration}}. Here's a test case which (hopefully) demonstrates this problem. The test case fails on the last assert statement.

{code}
class ScriptTest {
    @Test
    public void scriptWithAnonymousInnerClass() {
        def configuration = new CompilerConfiguration()
        configuration.scriptBaseClass = TestScript.name
        def classLoader = new GroovyClassLoader(getClass().classLoader, configuration)

        // This works
        def scriptClass = classLoader.parseClass('''
            def r = new TestRunnable()
            class TestRunnable implements Runnable {
                public void run() {}
            }
''')
        assert TestScript.isAssignableFrom(scriptClass)

        // This does not work
        scriptClass = classLoader.parseClass('''
            def r = new Runnable() {
                public void run() { }
            }
''')
        assert Script.isAssignableFrom(scriptClass)
        assert TestScript.isAssignableFrom(scriptClass) // <-- fails here    
    }
}

abstract class TestScript extends Script {

}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 09 05:54:49 UTC 2010,,,,,,,,,,"0|i2bqpz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"09/Jun/10 05:54;roshandawrani;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Problems with the 'as' operator,GROOVY-4241,12815164,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,poiati,poiati,05/Jun/10 19:03,16/Jun/10 03:50,14/Jul/23 06:00,06/Jun/10 11:08,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.9,1.7.3,1.8-beta-1,,,,,0,,,,,,"The following code reproduce the error:

class Foo {}

Foo.metaClass.invokeMethod = { String name, args ->
    for (arg in args) {
        arg.getClass()
    }
}

def f = new Foo()

f.echo(f as Foo)",Mac OSX 10.6 with Java 1.6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"05/Jun/10 23:16;paulk;v18x_4241B.patch;https://issues.apache.org/jira/secure/attachment/12722434/v18x_4241B.patch","05/Jun/10 21:45;roshandawrani;v18x_4241_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722513/v18x_4241_Patch.txt","06/Jun/10 04:32;roshandawrani;v2_v18x_4241_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722561/v2_v18x_4241_Patch.txt",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 06 11:08:20 UTC 2010,,,,,,,,,,"0|i2ckrj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"05/Jun/10 19:48;roshandawrani;Recording here the issue originally raised by Paulo on the mailing list
{code}
class Foo {
    def echo() { println 10 }
}

class Bar {}

Foo.metaClass.invokeMethod = { String name, args ->
    for (arg in args) {
        println arg.getClass()
    }
}

def f = new Foo()

// This works
def bar = [key: 'foo'] as Bar
f.echo(bar)

// This throws a NullPointerException
f.echo([key: 'foo'] as Bar)
{code}

The example raised in the JIRA is the shortened version of the original issue but I think it's not the same because in my shortened example ""asType"" call also goes through overridden invokeMethod and since that does not delegate any further to do the actual asType, the shortened version is a little contrived.

So, the real issue to solve is the one here in the comment (raised originally on the mailing list by Paulo).;;;","05/Jun/10 21:45;roshandawrani;Attaching a patch for review.;;;","05/Jun/10 23:16;paulk;Alternative patch - should be run against Roshan's test.

Looks to me like Wrapper could do with some cleanup. Remove all the commented out code which is effectively in the subclasses now and probably remove the protected field too (I suspect no one is using it but to be sure, I would deprecate in 1.7.3 first then remove in 1.8.0).
;;;","06/Jun/10 04:32;roshandawrani;I have tested the other patch as well and that with the test is again attached for review.

Clean-up not touched yet just to quickly get the fix reviewed and have the issue reported out of the way.;;;","06/Jun/10 07:41;paulk;I did the trivial cleanup items but not the change on the protected field nor anything related this patch of course. We can do any remaining cleanup after the patch if needed.;;;","06/Jun/10 11:08;roshandawrani;Done.

It's also fixed on 1.6.9 as it seemed to me like a small bug fix - if anyone thinks otherwise, please let me know.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
LocalVariableTable index attributes aren't consecutive,GROOVY-4237,12815171,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,johann,johann,04/Jun/10 14:42,14/Dec/10 08:37,14/Jul/23 06:00,14/Dec/10 08:31,1.7.0,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,bytecode,class generator,,,0,,,,,,"The background: [media.io|http://media.io] is built on Groovy and Pico Web Remoting (PWR). I was observing in one case that PicoContainer would not pick up the URL parameters correctly, i.e. you would have
{code}
class Keks {
void blorb(String rofl) {
...
{code}
and calling {{http://bla.bla/Keks/blorb?rofl=copter}} would result in PicoContainer not finding the right method.
PicoContainer uses [Paranamer|http://paranamer.codehaus.org/] which in turn is based on ASM. I found that the generated class files have a LocalVariableTable with non-consecutive index values.
Paranamer expects consecutive index values in the LocalVariableTable and so is unable to find them for the method.
I'm attaching a screenshot of what this looks like in jclasslib.
I don't really know if this is legal as per the class file spec -- if it is, close this.
I'll try to get a patch done for Paranamer, too.",,johann,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"04/Jun/10 14:42;johann;Screenshot.png;https://issues.apache.org/jira/secure/attachment/12722630/Screenshot.png",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 14 08:37:44 UTC 2010,,,,,,,,,,"0|i2cfyf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jun/10 14:06;blackdrag;actually your comment is abit surprising for me. On the first parameters we have no influence. The first parameters are ""this"", if the method is not static (always index 0) and then, in a consecutive way, all the parameters. Only after that the local variables do follow. I am pretty sure ""rofl"" in your example has the index 1. The local variable table does not define the local variables. Instead it says, that if that an that index is used in that and that line, it means it is that and that variable. It is for example perfectly right to use index x firts for the variable ""foo"" and later for the variable ""bar"". Also the index does not have to be consecutive, we don't even have to ""declare"" all variables we use there. The first purpose of this table is so that a debugger can use the information to display values under a name. The standard does not really limit how the indexes are used. Only that the first few are for ""this"" and the method parameters is predefined. Ah yes, if I use a long or double, then this ""variable"" would need two index places. A consecutive with the next index being the one before+1 would be an impossible requirement then. So I strongly assume PicoContainer gets confused internally. 

I haven't closed this yet, because your example still is puzzling me a bit. Can you confirm the index for the first parameter is 1? Because if it is... why does PicoContainer even care?;;;","05/Jun/10 14:15;johann;If you say that the index order isn't specified (apart from the {{this}} parameter you mentioned), that's fine with me. The problem then exists in Paranamer (which I'm already trying to patch).

On Groovy classes that PWR works fine with, the first parameter is assigned index 1. Only in this class, the indices are different and start at 3. And that throws off Paranamer and in turn PWR.

PicoContainer itself doesn't care, Pico Web Remoting (PWR) does. Pico Web Remoting uses Paranamer to extract the parameter names from classes so you can do the {{http://bla.bla/Keks/blorb?rofl=copter}} style URLs mentioned above.;;;","05/Jun/10 14:30;blackdrag;No I said the prder is specified for ""this"" and the parameter. And with that I mean that index 0 is (in a non static method) ""this"" and the first parameter starts always at 1. If that is reflected in the local variable table or not, is a different thing. There is one case where this could differ. If a parameter is used in a closure, then it is very possible the parameter is wrapped in a groovy.lang.Reference and this one will use the the name of the parameter with of course a different index. Can you verify this is the case? If it is, then it should be good enough to add the parameter to the variable table for the very small part that it is not wrapped in a Reference. ;;;","06/Jun/10 07:24;johann;You are right about closures changing the behaviour. When I use method parameters in a closure, the indexes aren't 0, 1, 2 but 0, 3, 4 as you can see in the screenshot.;;;","07/Jun/10 02:06;blackdrag;To summarize: the ""bug"" would be, that PicoContainer cannot find the parameter name, because for this parameter we have no local variablte table entry anymore, and instead we use a local varibale, which is not a parameter as replacement. The fix would be to let the parameter have a LocalVariableTable entry for the time it is used (which is not much), before the wrapping happens.;;;","14/Dec/10 08:31;blackdrag;should be fixed now;;;","14/Dec/10 08:37;johann;Thanks Jochen, will give it a try. This should make my classes look really clean again because the workaround was quite ugly.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Closure returned from static method cannot access class properties through ""this""",GROOVY-4235,12815220,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,roshandawrani,jcoleman,jcoleman,02/Jun/10 13:44,16/Jun/10 03:50,14/Jul/23 06:00,06/Jun/10 11:25,1.6.7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.9,1.7.3,1.8-beta-1,,,,,0,,,,,,"Given this code:

class Foo {
    static prop = ""sadfs""
    static foo() {
        return { -> println this.prop }
    }
}

Foo.foo().call()


A ClassCastException will be thrown even though printing out ""this"" inside of the closure prints out ""class Foo"".",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 06 11:25:36 UTC 2010,,,,,,,,,,"0|i2c08n:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"02/Jun/10 13:46;jcoleman;Note this is not a duplicate of: http://jira.codehaus.org/browse/GROOVY-3863 which does not access the properties from within a returned closure.;;;","06/Jun/10 11:25;roshandawrani;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
DOMCategory.setValue is unable to handle newly created elements,GROOVY-4231,12815226,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ragedog,ragedog,01/Jun/10 06:06,02/Apr/12 04:43,14/Jul/23 06:00,02/Apr/12 04:43,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.6,2.0-beta-3,,groovy-jdk,XML Processing,,,0,,,,,,"If a newly created element has no children then a NullPointerException is thrown.

IMO in these cases the method should create a new TextElement and add the contents to it.

How to reproduce:
{code}
import groovy.xml.dom.DOMCategory

use(DOMCategory) {
    def prop = doc.createElement('property')
    prop.setAttribute('name', 'cache.class')
    prop.setValue('true')
}
{code}",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 02 04:43:36 UTC 2012,,,,,,,,,,"0|i2bwhb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jun/10 08:03;paulk;add code tags;;;","02/Jun/10 02:25;ragedog;Thanks for the tip.;;;","02/Apr/12 04:43;paulk;I believe this was fixed as part of GROOVY-5280. Let me know if you have any further problems. Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Grails 1.3.1 groovysh render incorrect char encoding in prompt and messages,GROOVY-4227,12818050,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,jneira,jneira,30/May/10 16:19,23/Jun/10 15:44,14/Jul/23 06:00,03/Jun/10 21:22,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,Groovysh,,,,0,,,,,,"Hi, the issue is related to appearance. In the output there are chars in a incorrect encoding i think:

&#8592;[32mGroovy Shell&#8592;[m (1.7.2, JVM: 1.6.0_18)
Type '&#8592;[1mhelp&#8592;[m' or '&#8592;[1m\h&#8592;[m' for help.
-------------------------------------------------------------------------------
&#8592;[1mgroovy:&#8592;[m000&#8592;[1m>&#8592;[m help

For information about &#8592;[32mGroovy&#8592;[m, visit:
    &#8592;[36mhttp://groovy.codehaus.org&#8592;[m

Available commands:
  &#8592;[1mhelp    &#8592;[m  (&#8592;[1m\h &#8592;[m) Display this help message
  &#8592;[1m?       &#8592;[m  (&#8592;[1m\? &#8592;[m) Alias to: &#8592;[1mhelp&#8592;[m
  &#8592;[1mexit    &#8592;[m  (&#8592;[1m\x &#8592;[m) Exit the shell
  &#8592;[1mquit    &#8592;[m  (&#8592;[1m\q &#8592;[m) Alias to: &#8592;[1mexit&#8592;[m
  &#8592;[1mimport  &#8592;[m  (&#8592;[1m\i &#8592;[m) Import a class into the namespace
  &#8592;[1mdisplay &#8592;[m  (&#8592;[1m\d &#8592;[m) Display the current buffer
  &#8592;[1mclear   &#8592;[m  (&#8592;[1m\c &#8592;[m) Clear the buffer
  &#8592;[1mshow    &#8592;[m  (&#8592;[1m\S &#8592;[m) Show variables, classes or imports
  &#8592;[1minspect &#8592;[m  (&#8592;[1m\n &#8592;[m) Inspect a variable or the last result with the G
UI object browser
  &#8592;[1mpurge   &#8592;[m  (&#8592;[1m\p &#8592;[m) Purge variables, classes, imports or preferences

  &#8592;[1medit    &#8592;[m  (&#8592;[1m\e &#8592;[m) Edit the current buffer
  &#8592;[1mload    &#8592;[m  (&#8592;[1m\l &#8592;[m) Load a file or URL into the buffer
  &#8592;[1m.       &#8592;[m  (&#8592;[1m\. &#8592;[m) Alias to: &#8592;[1mload&#8592;[m
  &#8592;[1msave    &#8592;[m  (&#8592;[1m\s &#8592;[m) Save the current buffer to a file
  &#8592;[1mrecord  &#8592;[m  (&#8592;[1m\r &#8592;[m) Record the current session to a file
  &#8592;[1mhistory &#8592;[m  (&#8592;[1m\H &#8592;[m) Display, manage and recall edit-line history
  &#8592;[1malias   &#8592;[m  (&#8592;[1m\a &#8592;[m) Create an alias
  &#8592;[1mset     &#8592;[m  (&#8592;[1m\= &#8592;[m) Set (or list) preferences
  &#8592;[1mregister&#8592;[m  (&#8592;[1m\rc&#8592;[m) Registers a new command with the shell

For help on a specific command type:
    help &#8592;[1mcommand&#8592;[m

-Some system properties could be util:

grails.version=1.3.1
sun.boot.library.path=C:\Program Files\Java\jdk1.6.0_18\jre\bin
java.vm.version=16.0-b13
grails.env=development
java.vm.name=Java HotSpot(TM) Client VM
file.encoding.pkg=sun.io
user.country=ES
sun.os.patch.level=Service Pack 2
java.runtime.version=1.6.0_18-b07
grails.env.set=true
user.variant=
os.name=Windows Vista
tools.jar=C:\Program Files\Java\jdk1.6.0_18\lib\tools.jar
sun.jnu.encoding=Cp1252
disable.grails.plugin.transform=false
os.version=6.0
user.timezone=Europe/Paris
file.encoding=UTF-8
java.specification.version=1.6
grails.env.default=true
java.vm.specification.version=1.0
sun.arch.data.model=32
user.language=es
java.specification.vendor=Sun Microsystems Inc.
awt.toolkit=sun.awt.windows.WToolkit
java.version=1.6.0_18
sun.io.unicode.encoding=UnicodeLittle
groovy.starter.conf=\Users\atreyu\dev\java\grails\grails-1.3.1\conf\groovy-start
er.conf
","Windows vista SP 2
Grails 1.3.1
",jneira,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 03 21:22:14 UTC 2010,,,,,,,,,,"0|i2couf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/May/10 02:30;paulk;Not sure this is a bug per se. Groovysh is assuming you are using a ansi compatible terminal.
So, it there is a bug it is in detection logic/defaults.
You can override terminal settings manually as per the doco here:
http://groovy.codehaus.org/Groovy+Shell
In particular you can do things like:
groovysh --terminal=none
Or if running under cygwin see the special notes.
Not sure whether the grails wrapping of groovysh keeps all command line options.;;;","31/May/10 12:10;jneira;Thanks for the point, the fact is with older grails+groovy versions in same environment the character encoding works fine. So yes it seems the problem can be in detection of env.

In the script under ""grails shell"" i have seen this lines:

def shell = new Groovysh(classLoader,b, new IO(System.in, System.out, System.err))
	shell.run([] as String[])

i cannt find the  Groovysh constructor declaration in google to indentify the String[] argument 
i try to shell.run  ([""--terminal=none""] asString[]) just in case but i get a kilometric stacktrace .-(

PD: I configure groovysh.bat to use the grails installation libs (jansi,jline,commons-cli,groovy-all) and the shell show chars correctly;;;","02/Jun/10 05:26;roshandawrani;I don't think you can pass options like [""--terminal=none""] directly to Groovy.sh. To achieve the equivalent of ""--terminal=none"" with the usage like below, you may set the system property ""jline.terminal"" to ""jline.UnsupportedTerminal""

{code}
def shell = new Groovysh(classLoader,b, new IO(System.in, System.out, System.err))
shell.run([] as String[])
{code};;;","02/Jun/10 10:04;jneira;Thanks for you proposal. i have added the property in startGrails.bat
set JAVA_OPTS=%JAVA_OPTS% -Djline.terminal=""jline.UnsupportedTerminal""
and i get the value in shell with System.getProperty (""jline.terminal"") but  
i am afraid the change dont fix the problem.
Therefore the console executed by groovysh.bat with same libraries and env render
the character set fine :-/

Well at the end i have found the javadoc of groovy shell package
in http://groovy.codehaus.org/gapi/org/codehaus/groovy/tools/shell/Main.html
there is a static method setTerminalType (String)
with this adding in Shell.groovy i have fixed the problem:

Main.setTerminalType (""none"")
def shell = new Groovysh(classLoader,b, new IO(System.in, System.out, System.err))
shell.run([""""] as String[]);

But i dont know if i have to close the issue cause the detection of console still not working

I see a org.codehaus.groovy.tools.shell.AnsiDetector and it could be there the problem with
non-ansi autodetection problem.

 ;;;","02/Jun/10 10:17;roshandawrani;I am just comparing here what happens in usual groovysh case and what you are doing - there is one more thing that you may want to try - in addition to the system property that you have set, can you also set ""Ansi.enabled = false"" (org.fusesource.jansi.Ansi)

If that also does not work, we will need others to share more inputs - as far as setting the ""terminal to none"" idea was concerned, that has been tried here after the current suggestion (""Ansi.enabled = false"");;;","02/Jun/10 10:52;roshandawrani;Well, Main.setTerminalType(none) does those 2 things only - sets the system property and sets Ansi.enabled = false - that is where my inputs were coming from. So, doing them via or not via Main.setTerminalType() - either way achieves the same thing.

So, happy to note that with those 2 things it is working for you.;;;","02/Jun/10 11:20;roshandawrani;Did you try calling ""Ansi.setDetector(new AnsiDetector())"" before new Groovysh(...) to see if it helps with the auto-detection?;;;","02/Jun/10 14:13;jneira;thanks for your feedback! i have tried 
org.fusesource.jansi.Ansi.setDetector(new AnsiDetector());
and i am afraid dont work 

PD: with  Main.setTerminalType (""win"") the characters are correct;;;","02/Jun/10 14:45;jneira;OK i have revised the code of org.codehaus.groovy.tools.shell.Main (it was clear that the console with Main works and with Groovysh not) and
there is a static block:
static {
        // Install the system adapters
        AnsiConsole.systemInstall()

        // Register jline ansi detector
        Ansi.setDetector(new AnsiDetector())
    }
One of them you previous porposal. I added both to the shell.groovy and works fine
I think the fix could be add this static block to Groovysh class (statically or not);;;","02/Jun/10 22:45;roshandawrani;Hi. I have made the change. Could you please try the snapshot available at http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all/1.7.3-SNAPSHOT/ and let me know if it works for you?;;;","03/Jun/10 16:13;jneira;perfect! thanks for your interest and feedback, ;;;","03/Jun/10 21:22;roshandawrani;Done.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Wrong generation of import statements in stubs,GROOVY-4225,12815193,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,rnd,rnd,26/May/10 10:53,05/Apr/15 14:44,14/Jul/23 06:00,28/May/10 11:04,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,Compiler,,,,0,,,,,,"Single-type import declarations in Groovy files are collected/converted into type-on-demand import declarations by the stub compiler -- in other words,
{quote}
{{import my.package.Type1}}
{{import my.package.Type2}}
{quote}
becomes
{quote}
{{import my.package.*;}}
{quote}

This breaks the type shadowing mechanisms described in Section 7.5.1 of the Java Language Specification (3rd edition) and leads to Java compiler errors like ""cannot decide which of the classes to use"".

Moreover, current implementations is based on an unordered set, thus destroying the order of import declarations.

Attached patch solves these issues by preserving both the form and the order of original import declarations.","Windows XP, Sun JDK 1.6.0_19",paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"26/May/10 10:53;rnd;groovy-patch-20100526.patch;https://issues.apache.org/jira/secure/attachment/12722511/groovy-patch-20100526.patch","28/May/10 04:48;rnd;test1.zip;https://issues.apache.org/jira/secure/attachment/12722323/test1.zip",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri May 28 11:04:22 UTC 2010,,,,,,,,,,"0|i2ctqn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/May/10 20:56;paulk;Patch seems to do the right thing. Need to work out a good way to test it before applying.;;;","28/May/10 00:14;paulk;Hi Dmytro, thanks for the patch. Do you have an example where the current imperfect import statements are causing a problem? I applied your patch and found no problems but upon investigating further I am wondering whether output of any imports is now required. From reading some of the source code comments, it seems that at one stage we didn't generate the fully qualified names all the time and the imports were required. But my current testing hasn't been able to find a case where we now don't generate a fully qualified name - hence I think we can remove all imports.;;;","28/May/10 04:48;rnd;Hi Paul,
I attach a sample Maven project.  Its compilation (mvn compile) leads to the following errors:
{quote}
C:\workspace\test1\target\generated-sources\groovy-stubs\main\package2\Test1.java:[22,15] reference to Type is ambiguous, both class java.lang.reflect.Type in java.lang.reflect and class package1.Type in package1 match

C:\workspace\test1\target\generated-sources\groovy-stubs\main\package2\Test1.java:[22,40] reference to Type is ambiguous, both class java.lang.reflect.Type in java.lang.reflect and class package1.Type in package1 match
{quote}
;;;","28/May/10 06:37;paulk;Hi Dmytro, applied the patch. Any chance you could try the snapshot here:
http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all/1.7.3-SNAPSHOT/groovy-all-1.7.3-SNAPSHOT.jar
just rename your groovy-all-1.7.2.jar file in your ~/.m2 repo to have a .bak extension, ditto for sha1 file, then drop the above into that directory and rename it
;;;","28/May/10 06:51;rnd;Hi Paul, it works now, thank you!;;;","28/May/10 11:04;paulk;patch applied - thanks;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Lazy has incorrect behavior for static fields,GROOVY-4222,12811683,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,24/May/10 08:08,07/Apr/15 19:07,14/Jul/23 06:00,25/May/10 21:22,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"The fragment:
{code}
@Lazy static Type myField
{code}
is transformed into a static private field {{$myField}} but an instance method {{getMyField()}}. The method should be static and in the case of synchronization, would need to synch on the class not '{{this}}'. But there is also a question as to whether double checked locking is best for static, perhaps holder class idiom is better.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/May/10 17:06;paulk;groovy4222_lazy_static.patch;https://issues.apache.org/jira/secure/attachment/12722627/groovy4222_lazy_static.patch","25/May/10 11:28;paulk;groovy4222_lazy_static_holder.patch;https://issues.apache.org/jira/secure/attachment/12722626/groovy4222_lazy_static_holder.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 25 21:22:34 UTC 2010,,,,,,,,,,"0|i2cfsn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/May/10 08:41;paulk;Proposed patch if we just want to fix the bug and leave DCL in place for the static case even though it strictly isn't needed - and might be improved using holder class idiom;;;","24/May/10 10:14;blackdrag;from the patch alone it is quite difficult to get what you actually changed. I suggest to split the patch in a refactoring and in an actual patch. Because I think the actual pach is not much more than one line, but this here has a lot of lines;;;","24/May/10 17:06;paulk;Updated patch without refactoring;;;","24/May/10 17:16;paulk;The other general question I have is what preference we have for the performance of the generated code. Currently we have traditional DCL code:
{code}
@Lazy volatile T x
{code}
becomes
{code}
private volatile T $x

T getX() {
   if ($x != null)
      return $x
   else {
      synchronized(this) {
         if ($x == null) {
            $x = new T()
         }
         return $x
      }
   }
}
{code}
but Effective Java suggests:
{code}
private volatile T $x

T getX() {
   T result = $x
   if (result == null)
      synchronized(this) {
         result = $x
         if (result == null) {
            $x = result = new T()
         }
      }
   }
   return result
}
{code}
Claim in Effective Java is that use of local variable {{result}} means that {{$x}} is read once in common case which can be 25% faster.

I wonder whether other Groovy processing means this claim isn't applicable?;;;","24/May/10 21:00;paulk;fix to static issues applied in trunk but I think for static fields, a solution using the class holder idiom is still worth exploring;;;","25/May/10 11:28;paulk;attached is working patch (includes a few minor refactoring changes too) - now uses holder class idiom if soft flag not set and static modifier is used;;;","25/May/10 21:22;paulk;Optimization added;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy-all-jdk14-1.6.8 fails on Java 1.4 (java/util/concurrent/locks/AbstractQueuedSynchronizer),GROOVY-4220,12815203,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,paulk,sebb,,22/May/10 07:53,07/Apr/15 18:54,14/Jul/23 06:00,15/Jun/10 11:38,1.6.7,1.6.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.9,,,,,,,0,,,,,,"groovy-all-jdk14-1.6.8.jar fails on Java 1.4.

The following Java code shows the problem:

{code}
GroovyClassLoader loader = new GroovyClassLoader();
loader.parseClass("""");
{code}

This produces the following stack trace:
{code}
java.lang.NoClassDefFoundError: java/util/concurrent/locks/AbstractQueuedSynchronizer
	at java.lang.ClassLoader.defineClass0(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:539)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:55)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:194)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:187)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:289)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:235)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)
	at java.lang.ClassLoader.defineClass0(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:539)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:55)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:194)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:187)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:289)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:235)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)
	at groovyjarjarbackport.java.util.concurrent.ConcurrentHashMap.<init>(ConcurrentHashMap.java:602)
	at groovyjarjarbackport.java.util.concurrent.ConcurrentHashMap.<init>(ConcurrentHashMap.java:653)
	at groovyjarjarretroruntime.impl.WeakIdentityTable.<init>(WeakIdentityTable.java:42)
	at groovyjarjarretroruntime.java.lang.Enum_$1.<init>(Enum_.java:49)
	at groovyjarjarretroruntime.java.lang.Enum_.<clinit>(Enum_.java:47)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.addPhaseOperations(ASTTransformationVisitor.java:160)
	at org.codehaus.groovy.control.CompilationUnit.<init>(CompilationUnit.java:180)
	at org.codehaus.groovy.control.CompilationUnit.<init>(CompilationUnit.java:117)
	at groovy.lang.GroovyClassLoader.createCompilationUnit(GroovyClassLoader.java:444)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:267)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:250)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:245)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:206)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:216)
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 15 15:19:13 UTC 2010,,,,,,,,,,"0|i2ckdz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/May/10 18:54;paulk;This is kind of a known issue which I thought we had fixed in the early days of 1.6:
http://groovy.markmail.org/thread/vx3xetircpvcgu2z
Maybe there has been a regression or the change was never actually checked in - it surprises me though as the Retro test suite passes fine.
;;;","22/May/10 20:13;sebb;Perhaps you can add that code to the test suite?;;;","27/May/10 05:24;paulk;I bumped the version of retrotranslator from 1.2.7 -> 1.2.9 and the problem goes away for me. It would be great if you could also verify you have no problems with the version of groovy produced by one of the CI builds.;;;","27/May/10 19:21;paulk;And there is now also a jar in the snapshots repo you can check against too:
http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all-jdk14/1.6.9-SNAPSHOT/;;;","01/Jun/10 19:45;sebb;Just tried using groovy-all-jdk14-1.6.9-20100527.234947-1.jar (MD5 396825d192142c7b5429cefe52614896) using the code snippet posted originally, and I still get the same error:

java.lang.NoClassDefFoundError: java/util/concurrent/locks/AbstractQueuedSynchronizer
	at java.lang.ClassLoader.defineClass0(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:539)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:55)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:194)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:187)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:289)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:235)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)
	at java.lang.ClassLoader.defineClass0(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:539)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:55)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:194)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:187)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:289)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:235)
	at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)
	at groovyjarjarbackport.java.util.concurrent.ConcurrentHashMap.<init>(ConcurrentHashMap.java:602)
	at groovyjarjarbackport.java.util.concurrent.ConcurrentHashMap.<init>(ConcurrentHashMap.java:653)
	at groovyjarjarretroruntime.impl.WeakIdentityTable.<init>(WeakIdentityTable.java:42)
	at groovyjarjarretroruntime.java.lang.Enum_$1.<init>(Enum_.java:49)
	at groovyjarjarretroruntime.java.lang.Enum_.<clinit>(Enum_.java:47)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.addPhaseOperations(ASTTransformationVisitor.java:160)
	at org.codehaus.groovy.control.CompilationUnit.<init>(CompilationUnit.java:180)
	at org.codehaus.groovy.control.CompilationUnit.<init>(CompilationUnit.java:117)
	at groovy.lang.GroovyClassLoader.createCompilationUnit(GroovyClassLoader.java:444)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:267)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:250)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:245)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:206)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:216)
	at Groovy.main(Groovy.java:4)
Exception in thread ""main"";;;","01/Jun/10 19:59;paulk;How did you do your test?

Might be useful if you try this:
java -cp groovy-all-jdk14-1.6.9-20100527.234947-1.jar groovy.ui.Console

Then cut and paste above lines into console, then run the script.;;;","01/Jun/10 20:11;sebb;=== Groovy.java ===
public class Groovy {
    public static void main(String[] args) {
        groovy.lang.GroovyClassLoader loader = new groovy.lang.GroovyClassLoader();
        loader.parseClass("""");
    }
}

set CLASSPATH=groovy-all-jdk14-1.6.9-20100527.234947-1.jar;.

javac Groovy.java

java Groovy

Using:
java version ""1.4.2_19""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.2_19-b04)
Java HotSpot(TM) Client VM (build 1.4.2_19-b04, mixed mode)
;;;","01/Jun/10 20:12;sebb;Also:

> java -cp groovy-all-jdk14-1.6.9-20100527.234947-1.jar groovy.ui.Console
Exception in thread ""main"" java.lang.NoClassDefFoundError: java/util/concurrent/locks/AbstractQueuedSynchronizer
        at java.lang.ClassLoader.defineClass0(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:539)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:55)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:194)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:187)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:289)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:235)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)
        at java.lang.ClassLoader.defineClass0(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:539)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:123)
        at java.net.URLClassLoader.defineClass(URLClassLoader.java:251)
        at java.net.URLClassLoader.access$100(URLClassLoader.java:55)
        at java.net.URLClassLoader$1.run(URLClassLoader.java:194)
        at java.security.AccessController.doPrivileged(Native Method)
        at java.net.URLClassLoader.findClass(URLClassLoader.java:187)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:289)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:235)
        at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302)
        at groovyjarjarbackport.java.util.concurrent.ConcurrentHashMap.<init>(ConcurrentHashMap.java:602)
        at groovyjarjarbackport.java.util.concurrent.ConcurrentHashMap.<init>(ConcurrentHashMap.java:653)
        at org.codehaus.groovy.runtime.GroovyCategorySupport$MyThreadLocal.<init>(GroovyCategorySupport.java:235)
        at org.codehaus.groovy.runtime.GroovyCategorySupport$MyThreadLocal.<init>(GroovyCategorySupport.java:233)
        at org.codehaus.groovy.runtime.GroovyCategorySupport.<clinit>(GroovyCategorySupport.java:150)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.<init>(AbstractCallSite.java:46)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.<init>(CallSiteArray.java:35)
        at groovy.ui.Console.$createCallSiteArray(Console.groovy)
        at groovy.ui.Console.$getCallSiteArray(Console.groovy)
        at groovy.ui.Console.<clinit>(Console.groovy:69);;;","01/Jun/10 20:39;sebb;Note that not all of the class files in the jar have been updated recently. 

In particular, groovyjarjarbackport.java.util.concurrent.ConcurrentHashMap is dated 2007-06-14.
Only groovyjarjarbackport.java.util.concurrent.locks.ReentrantLock is dated 2010-05-28 - all the other classes in groovyjarbackport are dated 2007-06-14.
Looks like the build may have failed to apply retroweaver to all the relevant classes in the jar.
;;;","01/Jun/10 20:52;paulk;ok, will look into it further ...;;;","15/Jun/10 02:54;paulk;How about this version - Roshan applied another fix:

http://snapshots.repository.codehaus.org/org/codehaus/groovy/groovy-all-jdk14/1.6.9-SNAPSHOT/groovy-all-jdk14-1.6.9-20100615.074507-2.jar
;;;","15/Jun/10 05:18;guillaume;SebbASF, as soon as you give us your feedback that everything's okay now, we should be able to make a release for 1.6.9.
Thanks in advance for your feedback.

Also, please notice going forward, it may be the last version of the 1.6.x branch, so also the last version of Groovy being compatible with JDK 1.4.
So if you can consider moving to a newer JDK, that would be a good thing -- JDK 1.5 is even already End-of-life'd!;;;","15/Jun/10 11:38;sebb;java -cp groovy-all-jdk14-1.6.9-20100615.074507-2.jar groovy.ui.Console

works on

java -version
java version ""1.4.2_19""
Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.2_19-b04)
Java HotSpot(TM) Client VM (build 1.4.2_19-b04, mixed mode)

So I think you have fixed the problem - thanks!;;;","15/Jun/10 15:19;guillaume;Great news, SebbASF, thank you for your feedback and testing this snapshot.
Now, time to find a suitable date for the release.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error during class generation for simple java/groovy program,GROOVY-4219,12815188,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,aclement,aclement,21/May/10 16:58,14/Dec/10 10:03,14/Jul/23 06:00,14/Dec/10 10:03,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,Compiler,,,,0,,,,,,"Reported against groovy eclipse but appears to be a groovy problem.  Similar stack to GROOVY-3613, but wasn't clear what was happening in that bug.

Zip is attached.  Compile with: 
groovyc -j de\brazzy\nikki\Texts.java de\brazzy\nikki\model\Image.groovy de\brazzy\nikki\model\ImageSortField.groovy

produces

{code}
>>> a serious error occurred: BUG! exception in phase 'class generation' in source unit 'de\brazzy\nikki\model\ImageSortField.groovy
' MapEntryExpression should not be visited here
>>> stacktrace:
BUG! exception in phase 'class generation' in source unit 'de\brazzy\nikki\model\ImageSortField.groovy' MapEntryExpression should no
t be visited here
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitMapEntryExpression(AsmClassGenerator.java:3123)
        at org.codehaus.groovy.ast.expr.MapEntryExpression.visit(MapEntryExpression.java:37)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4078)
        at org.codehaus.groovy.classgen.AsmClassGenerator.makeCallSite(AsmClassGenerator.java:2148)
        at org.codehaus.groovy.classgen.AsmClassGenerator.makeCall(AsmClassGenerator.java:1982)
        at org.codehaus.groovy.classgen.AsmClassGenerator.makeCall(AsmClassGenerator.java:1968)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitStaticMethodCallExpression(AsmClassGenerator.java:2376)
        at org.codehaus.groovy.ast.expr.StaticMethodCallExpression.visit(StaticMethodCallExpression.java:43)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4078)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitCastExpression(AsmClassGenerator.java:1891)
        at org.codehaus.groovy.classgen.AsmClassGenerator.assignmentCastAndVisit(AsmClassGenerator.java:4017)
        at org.codehaus.groovy.classgen.AsmClassGenerator.evaluateEqual(AsmClassGenerator.java:3969)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:1446)
        at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitAndAutoboxBoolean(AsmClassGenerator.java:4078)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:1427)
        at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
        at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:165)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:700)
        at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:51)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:101)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:112)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:587)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:562)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:123)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:657)
        at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1039)
        at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
        at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:275)
        at org.codehaus.groovy.control.CompilationUnit$11.call(CompilationUnit.java:751)
        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:958)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:517)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:495)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:472)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:456)
        at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:57)
        at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:170)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:138)
        at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:152)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:108)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130)
{code}",,brazzy,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3613,,,,,,,,"21/May/10 16:58;aclement;bug.zip;https://issues.apache.org/jira/secure/attachment/12722276/bug.zip","21/May/10 21:36;paulk;groovy4219_enumMapConstructor.patch;https://issues.apache.org/jira/secure/attachment/12722431/groovy4219_enumMapConstructor.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 14 10:03:23 UTC 2010,,,,,,,,,,"0|i2crpz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/May/10 17:49;paulk;Is related to map-based part of GROOVY-3613;;;","21/May/10 21:36;paulk;Possible potential patch attached - perhaps stepping stone towards full support of automatic map style support.

The patch gets rid of the error BUG error message and instead at least complains about missing a user provided Map constructor.

Test case:
{code}
enum T {
  ALPHA(x:1, y:2),
  BETA(3, y:4),
  GAMMA(5, 6)

  def T(Object[] args) {
    this.y = args[0].y
    this.x = args[1]
  }

  T(int x, int y) {
    this.x = x
    this.y = y
  }

  T(Map m) {
    this.x = m.x
    this.y = m.y
  }

  def x, y

  @Override String toString() { ""T[x: $x, y: $y]"" }
}
    
println T.ALPHA
println T.BETA
println T.GAMMA
{code}
Output:
{noformat}
T[x: 1, y: 2]
T[x: 3, y: 4]
T[x: 5, y: 6]
{noformat}
If you leave out the Map and Object[] constructors you will get something like:
{noformat}
groovy.lang.GroovyRuntimeException: Could not find matching constructor for: T(java.lang.String, java.lang.Integer, java.util.LinkedHashMap)
{noformat}
The error message includes the implicit params for enums but that is what we do elsewhere too at the moment.

The patch isn't perfect. Unfortunately, at the moment if you leave in the Object[] constructor but provide the plain Map style usage you get something like:
{noformat}
java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to [Ljava.lang.Object;
{noformat}
;;;","16/Jun/10 08:57;roshandawrani;I think, until we can support it fully, it may be better to reject the unhandled code at compilation time instead of letting it compile and then fail at runtime with GroovyRuntimeException or ClassCastException depending on what constructors have or have not been provided.

What about giving a clear error message that tells the user to provide the expected constructors, if they are not?;;;","17/Jun/10 10:13;blackdrag;the correct way for the runtime to react if there is a Object[] is to wrap the LinkedHashMap in a Object[] and then call the Object[] constructor with it. If additionally a Map based constructor is provided, then this one is to take. A Bug! message is not acceptable. And the runtime message after Paul's patch isn't that good either. 

So for the beginning I think that making it fail at compile time is a good choice. But I would not close this issue for this.;;;","14/Dec/10 10:03;blackdrag;The issue is now fixed with a new error message, that will ensure there won't be any BUG! error message. For implementing the feature itself I created GROOVY-4582;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Causes application to crash due to too many files being open,GROOVY-4218,12815183,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,gustavo.gomesc@gmail.com,gustavo.gomesc@gmail.com,21/May/10 15:23,09/Nov/11 05:14,14/Jul/23 06:00,09/Nov/11 05:14,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,groovy-jdk,,,,0,,,,,,"I am executing several scripts within a web application. In a moment, the following exception occur:

groovy.util.ResourceException: Cannot open URL: file:/home/jboss-deploy/app/pharmania/scripts/criticas/pharmania/validaUsandoCpf.groovy
	at groovy.util.GroovyScriptEngine.getResourceConnection(GroovyScriptEngine.java:298)
	at groovy.util.GroovyScriptEngine.loadScriptByName(GroovyScriptEngine.java:407)
	at groovy.util.GroovyScriptEngine.createScript(GroovyScriptEngine.java:481)
	at groovy.util.GroovyScriptEngine.run(GroovyScriptEngine.java:468)
	at com.prana.critica.CriticaScript.execute(CriticaScript.java:167)
	at com.prana.critica.CriticaRegistro.valida(CriticaRegistro.java:51)
	at com.prana.critica.CriticaManager.valida(CriticaManager.java:156)
	at com.prana.critica.CriticaManager.getLotesCarga(CriticaManager.java:200)
	at com.prana.pharmania.session.CargaPontuacaoAction.analisa(CargaPontuacaoAction.java:217)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:616)
	at org.jboss.seam.util.Reflections.invoke(Reflections.java:22)
	at org.jboss.seam.intercept.RootInvocationContext.proceed(RootInvocationContext.java:32)
	at org.jboss.seam.intercept.SeamInvocationContext.proceed(SeamInvocationContext.java:56)
	at org.jboss.seam.transaction.RollbackInterceptor.aroundInvoke(RollbackInterceptor.java:28)
	at org.jboss.seam.intercept.SeamInvocationContext.proceed(SeamInvocationContext.java:68)
	at org.jboss.seam.core.BijectionInterceptor.aroundInvoke(BijectionInterceptor.java:77)
	at org.jboss.seam.intercept.SeamInvocationContext.proceed(SeamInvocationContext.java:68)
	at org.jboss.seam.transaction.TransactionInterceptor$1.work(TransactionInterceptor.java:97)
	at org.jboss.seam.util.Work.workInTransaction(Work.java:47)
	at org.jboss.seam.transaction.TransactionInterceptor.aroundInvoke(TransactionInterceptor.java:91)
	at org.jboss.seam.intercept.SeamInvocationContext.proceed(SeamInvocationContext.java:68)
	at org.jboss.seam.core.MethodContextInterceptor.aroundInvoke(MethodContextInterceptor.java:44)
	at org.jboss.seam.intercept.SeamInvocationContext.proceed(SeamInvocationContext.java:68)
	at org.jboss.seam.intercept.RootInterceptor.invoke(RootInterceptor.java:107)
	at org.jboss.seam.intercept.JavaBeanInterceptor.interceptInvocation(JavaBeanInterceptor.java:185)
	at org.jboss.seam.intercept.JavaBeanInterceptor.invoke(JavaBeanInterceptor.java:103)
	at com.prana.pharmania.session.CargaPontuacaoAction_$$_javassist_seam_6.analisa(CargaPontuacaoAction_$$_javassist_seam_6.java)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:616)
	at org.jboss.el.util.ReflectionUtil.invokeMethod(ReflectionUtil.java:335)
	at org.jboss.el.util.ReflectionUtil.invokeMethod(ReflectionUtil.java:348)
	at org.jboss.el.parser.AstPropertySuffix.invoke(AstPropertySuffix.java:58)
	at org.jboss.el.parser.AstValue.invoke(AstValue.java:96)
	at org.jboss.el.MethodExpressionImpl.invoke(MethodExpressionImpl.java:276)
	at com.sun.facelets.el.TagMethodExpression.invoke(TagMethodExpression.java:68)
	at javax.faces.component.MethodBindingMethodExpressionAdapter.invoke(MethodBindingMethodExpressionAdapter.java:88)
	at com.sun.faces.application.ActionListenerImpl.processAction(ActionListenerImpl.java:102)
	at javax.faces.component.UICommand.broadcast(UICommand.java:387)
	at org.ajax4jsf.component.AjaxViewRoot.processEvents(AjaxViewRoot.java:329)
	at org.ajax4jsf.component.AjaxViewRoot.broadcastEventsForPhase(AjaxViewRoot.java:304)
	at org.ajax4jsf.component.AjaxViewRoot.processPhase(AjaxViewRoot.java:261)
	at org.ajax4jsf.component.AjaxViewRoot.processApplication(AjaxViewRoot.java:474)
	at com.sun.faces.lifecycle.InvokeApplicationPhase.execute(InvokeApplicationPhase.java:82)
	at com.sun.faces.lifecycle.Phase.doPhase(Phase.java:100)
	at com.sun.faces.lifecycle.LifecycleImpl.execute(LifecycleImpl.java:118)
	at javax.faces.webapp.FacesServlet.service(FacesServlet.java:265)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.jboss.seam.servlet.SeamFilter$FilterChainImpl.doFilter(SeamFilter.java:83)
	at org.jboss.seam.web.IdentityFilter.doFilter(IdentityFilter.java:40)
	at org.jboss.seam.servlet.SeamFilter$FilterChainImpl.doFilter(SeamFilter.java:69)
	at org.jboss.seam.web.MultipartFilter.doFilter(MultipartFilter.java:86)
	at org.jboss.seam.servlet.SeamFilter$FilterChainImpl.doFilter(SeamFilter.java:69)
	at org.jboss.seam.web.ExceptionFilter.doFilter(ExceptionFilter.java:64)
	at org.jboss.seam.servlet.SeamFilter$FilterChainImpl.doFilter(SeamFilter.java:69)
	at org.jboss.seam.web.RedirectFilter.doFilter(RedirectFilter.java:45)
	at org.jboss.seam.servlet.SeamFilter$FilterChainImpl.doFilter(SeamFilter.java:69)
	at org.ajax4jsf.webapp.BaseXMLFilter.doXmlFilter(BaseXMLFilter.java:206)
	at org.ajax4jsf.webapp.BaseFilter.handleRequest(BaseFilter.java:290)
	at org.ajax4jsf.webapp.BaseFilter.processUploadsAndHandleRequest(BaseFilter.java:388)
	at org.ajax4jsf.webapp.BaseFilter.doFilter(BaseFilter.java:515)
	at org.jboss.seam.web.Ajax4jsfFilter.doFilter(Ajax4jsfFilter.java:56)
	at org.jboss.seam.servlet.SeamFilter$FilterChainImpl.doFilter(SeamFilter.java:69)
	at org.jboss.seam.web.LoggingFilter.doFilter(LoggingFilter.java:60)
	at org.jboss.seam.servlet.SeamFilter$FilterChainImpl.doFilter(SeamFilter.java:69)
	at org.jboss.seam.servlet.SeamFilter.doFilter(SeamFilter.java:158)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.jboss.web.tomcat.filters.ReplyHeaderFilter.doFilter(ReplyHeaderFilter.java:96)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:235)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)
	at org.jboss.web.tomcat.security.SecurityAssociationValve.invoke(SecurityAssociationValve.java:190)
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:433)
	at org.jboss.web.tomcat.security.JaccContextValve.invoke(JaccContextValve.java:92)
	at org.jboss.web.tomcat.security.SecurityContextEstablishmentValve.process(SecurityContextEstablishmentValve.java:126)
	at org.jboss.web.tomcat.security.SecurityContextEstablishmentValve.invoke(SecurityContextEstablishmentValve.java:70)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)
	at org.jboss.web.tomcat.service.jca.CachedConnectionValve.invoke(CachedConnectionValve.java:158)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:330)
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:829)
	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:601)
	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:447)
	at java.lang.Thread.run(Thread.java:636)
Caused by: groovy.util.ResourceException: Cannot open URL: file:/home/jboss-deploy/app/pharmania/scripts/criticas/dbmax/validaUsandoCpf.groovy
	at groovy.util.GroovyScriptEngine.getResourceConnection(GroovyScriptEngine.java:296)
	... 91 more

And after, the server throw the following exception:

2010-05-21 16:09:41,476 ERROR [org.apache.catalina.core.ContainerBase.[jboss.web].[localhost].[/].[default]] (http-0.0.0.0-80-3) Servlet.service() for servlet default threw exception
java.io.FileNotFoundException: /var/lib/jboss-5.0.1.GA/server/default/deploy/ROOT.war/favicon.ico (Too many open files)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(FileInputStream.java:137)
	at org.apache.naming.resources.FileDirContext$FileResource.streamContent(FileDirContext.java:921)
	at org.apache.catalina.servlets.DefaultServlet.copy(DefaultServlet.java:1703)
	at org.apache.catalina.servlets.DefaultServlet.serveResource(DefaultServlet.java:800)
	at org.apache.catalina.servlets.DefaultServlet.doGet(DefaultServlet.java:332)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:617)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.jboss.web.tomcat.filters.ReplyHeaderFilter.doFilter(ReplyHeaderFilter.java:96)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:235)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)
	at org.jboss.web.tomcat.security.SecurityAssociationValve.invoke(SecurityAssociationValve.java:190)
	at org.jboss.web.tomcat.security.JaccContextValve.invoke(JaccContextValve.java:92)
	at org.jboss.web.tomcat.security.SecurityContextEstablishmentValve.process(SecurityContextEstablishmentValve.java:126)
	at org.jboss.web.tomcat.security.SecurityContextEstablishmentValve.invoke(SecurityContextEstablishmentValve.java:70)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)
	at org.jboss.web.tomcat.service.jca.CachedConnectionValve.invoke(CachedConnectionValve.java:158)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:330)
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:829)
	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:601)
	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:447)
	at java.lang.Thread.run(Thread.java:636)

This problem is similar to the issue GROOVY-3570 reported to version 1.6.3. When I compare the code between the version 1.6.8, that works fine in the same environment, and the version 1.7.2 of the class GroovyScriptEngine, I realize that the patch applied to the version 1.6.8 is not present on 1.7.2.
The solution applied in the version 1.6.8 was close the input stream retrieved by URLConnection.
To complement this issue, I testing run my web application in Windows XP and it works fine there with both versions (1.6.8 and 1.7.2).
This can be fixed?","Operating System: Ubuntu 9.04
        Linux 2.6.28-17-generic #58-Ubuntu SMP Tue Dec 1 18:57:07 UTC 2009 i686 GNU/Linux
Java: OpenJDK Runtime Environment (IcedTea6 1.4.1) (6b14-1.4.1-0ubuntu12)
        OpenJDK Client VM (build 14.0-b08, mixed mode, sharing)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3570,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 03 11:06:56 UTC 2010,,,,,,,,,,"0|i2ctif:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jun/10 11:50;roshandawrani;This seems a duplicate of GROOVY-3570.

The fix wasn't done on 1.7.x then, so it is still there only on 1.6.x.;;;","02/Jun/10 11:52;roshandawrani;Looks like a duplicate to me, but for now, I am just linking the issues for information sake.;;;","03/Jun/10 01:21;paulk;Is a duplicate - but other issue is important;;;","03/Jun/10 11:06;paulk;Please see the other issue about a fix for 1.7.3 currently available in the snapshot repo. Any feedback you have would be great.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
exception trying to define method in closure,GROOVY-4215,12811780,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ittayd,ittayd,21/May/10 00:46,13/Apr/11 14:33,14/Jul/23 06:00,07/Apr/11 04:38,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8-rc-4,,,,,,0,,,,,,"{code}
{->
    def say(String msg) {
      println(msg)
    }
}()
{code}

throws:
{noformat}

1 compilation error:

Unknown type: METHOD_DEF at line: 2 column: 5. File: predef.groovy at Exception in thread ""AWT-EventQueue-0"" 
groovy.lang.MissingPropertyException: No such property: column for class: org.codehaus.groovy.antlr.ASTParserException
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:49)
	at org.codehaus.groovy.runtime.callsite.GetEffectivePojoPropertySite.getProperty(GetEffectivePojoPropertySite.java:63)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callGetProperty(AbstractCallSite.java:237)
	at groovy.ui.Console$_finishException_closure9.doCall(Console.groovy:636)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:276)
	at groovy.lang.Closure.call(Closure.java:289)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1176)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:1152)
	at org.codehaus.groovy.runtime.dgm$111.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:270)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at groovy.ui.Console.finishException(Console.groovy:619)
	at sun.reflect.GeneratedMethodAccessor441.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:361)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:151)
	at groovy.ui.Console$_runScriptImpl_closure16_closure29.doCall(Console.groovy:868)
	at sun.reflect.GeneratedMethodAccessor655.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:151)
	at groovy.ui.Console$_runScriptImpl_closure16_closure29.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor654.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:276)
	at groovy.lang.Closure.call(Closure.java:271)
	at groovy.lang.Closure.run(Closure.java:354)
	at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:209)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:597)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:269)
	at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:184)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:174)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:169)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:161)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:122)
{noformat}",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/May/10 06:31;paulk;groovy4215_betterErrorMsg.patch;https://issues.apache.org/jira/secure/attachment/12722322/groovy4215_betterErrorMsg.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 07 04:38:29 UTC 2011,,,,,,,,,,"0|i2c9iv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/May/10 06:23;paulk;Yes, a better error message would be good. The fact that this is running in GroovyConsole adds a bit of noise to the stack trace (itself a smell, but we'll ignore that here). For the purposes of fixing this issue, here is a better view of the cause - obtained by running from the command-line:
{noformat}
Caused by: org.codehaus.groovy.antlr.ASTRuntimeException: Unknown type: METHOD_DEF at line: 2 column: 5
        at org.codehaus.groovy.antlr.AntlrParserPlugin.unknownAST(AntlrParserPlugin.java:2952)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:1856)
        ...
{noformat}
;;;","21/May/10 06:31;paulk;Attached patch gives a slightly better error message:
{noformat}
Caused by: org.codehaus.groovy.antlr.ASTRuntimeException: Found a method definition when expecting an expression. Possible attempt to define a method inside a closure? Define the method outside or use an inner closure. at line: 2 column: 5
        at org.codehaus.groovy.antlr.AntlrParserPlugin.unknownAST(AntlrParserPlugin.java:2953)
        at org.codehaus.groovy.antlr.AntlrParserPlugin.expressionSwitch(AntlrParserPlugin.java:1856)
        ...
{noformat}
but we need to be sure that this error can't be stopped at the grammar level first or indeed if we might want to support such definitions at some point.
;;;","10/Jun/10 01:04;roshandawrani;I think it might be better not to guess the enclosing syntax.

Say I run the code
{code}
switch(1) {
	case 1: def say(){}
}
{code}
The guess and the suggestion are not applicable now as the wrong method def is not inside a closure and not an ""inner"" closure, but a closure would help.

How about just saying ""Method definition not expected here. Please define the method at an appropriate place or try using a closure instead.""?;;;","24/Jun/10 06:39;roshandawrani;Just looking through issues - this one seems on the verge of getting resolved :-), if we can finalize the error message.;;;","26/Dec/10 03:33;paulk;Roshan, I like your suggested error message.;;;","26/Dec/10 04:42;blackdrag;I suggest a small change to the error message: ""Method definition not expected here. Please define the method at an appropriate place or try using a block instead.""? We should be a bit carefull what we justify as closure;;;","07/Apr/11 04:38;paulk;improved error message was added - thanks for filing the issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Inconsistent handling of boolean properties,GROOVY-4206,12815145,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pniederw,pniederw,15/May/10 13:42,16/Jun/10 03:50,14/Jul/23 06:00,15/May/10 19:48,1.6.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.9,1.7.3,1.8-beta-1,Compiler,,,,0,,,,,,"Boolean getters with ""is"" prefix can be accessed with property syntax:

{code}
class Foo {
  boolean isValid() { true }
}
new Foo().valid
{code}

However, this doesn't work for static properties:

{code}
class Bar {
  static boolean isValid() { true }
}
Bar.valid // groovy.lang.MissingPropertyException: No such property: valid for class: Bar
{code}",,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 15 17:19:40 UTC 2010,,,,,,,,,,"0|i2cmjb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/May/10 17:19;paulk;Also doesn't work for DGM methods but perhaps not the same thing:
{code}
def d = new Date()
println d.getDateString() // 16/05/10
println d.dateString      // 16/05/10

def s = '1.1E2'
println s.isBigDecimal()  // true
println s.bigDecimal      // No such property: bigDecimal for class: java.lang.String
{code}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
successive metaclass modification for class then instance fails.,GROOVY-4202,12815156,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,rovrevik,rovrevik,12/May/10 13:06,23/Jun/10 15:45,14/Jul/23 06:00,03/Jun/10 06:16,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,groovy-jdk,,,,0,,,,,,"define a groovy class (an empty class declaration will do).

class TestClass0 {}

Muck with the metaclass using the class and an instance. the second closure assignment throws an exception (java.lang.ClassCastException: groovy.lang.MetaClassImpl cannot be cast to groovy.lang.GroovyObject at  org.codehaus.groovy.runtime.HandleMetaClass.replaceDelegate(HandleMetaClass.java:71)).

	void testSomething1() {
		def inst = new TestClass0();
		TestClass0.metaClass.addedMethod0 = { return 'hello0'}
		inst.metaClass.addedMethod1 = { return 'hello1'}
	}

note that simply changing the order of the closure assignments executes without throwing exceptions.
","groovy 1.7, jdk 1.6.20, win 7",trashhalo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 03 06:16:05 UTC 2010,,,,,,,,,,"0|i2cozj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/May/10 20:39;trashhalo;I can confirm that this issue also manifests itself on the HEAD of trunk (Rev 20002)

Code executed:

class TestClass0 {} 
def inst = new TestClass0(); 
TestClass0.metaClass.addedMethod0 = { return 'hello0'} 
inst.metaClass.addedMethod1 = { return 'hello1'} 
 
Exception thrown
May 12, 2010 9:36:02 PM org.codehaus.groovy.runtime.StackTraceUtils sanitize
WARNING: Sanitizing stacktrace:
java.lang.ClassCastException: groovy.lang.MetaClassImpl cannot be cast to groovy.lang.GroovyObject
	at org.codehaus.groovy.runtime.HandleMetaClass.replaceDelegate(HandleMetaClass.java:71)
	at org.codehaus.groovy.runtime.HandleMetaClass.setProperty(HandleMetaClass.java:91)
	at org.codehaus.groovy.runtime.InvokerHelper.setProperty(InvokerHelper.java:179)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.setProperty(ScriptBytecodeAdapter.java:483)
	at ConsoleScript0.run(ConsoleScript0:4)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:264)
	at groovy.lang.GroovyShell.run(GroovyShell.java:513)
	at groovy.lang.GroovyShell.run(GroovyShell.java:170)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:875)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:44)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:143)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:151)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:273)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:276)
	at groovy.lang.Closure.call(Closure.java:271)
	at groovy.lang.Closure.run(Closure.java:354)
	at java.lang.Thread.run(Thread.java:637);;;","03/Jun/10 06:16;roshandawrani;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Immutable cannot handle List,GROOVY-4201,12815191,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pledbrook,pledbrook,12/May/10 12:06,23/Jun/10 15:45,14/Jul/23 06:00,12/May/10 23:51,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"This doesn't compile:
{code}
@Immutable
class Person {
    String name
    List likes
}
{code}
If I declare the {{likes}} property as {{Collection}} instead, the compilation works. Huh?",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 12 23:51:37 UTC 2010,,,,,,,,,,"0|i2ce67:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/May/10 23:51;paulk;A minor glitch in the interface checking logic. Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Source locations not correct for some return and block statements created in ReturnAdder class,GROOVY-4196,12811778,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,werdna,werdna,10/May/10 14:41,23/Jun/10 15:45,14/Jul/23 06:00,11/May/10 07:29,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,parser-antlr2,,,,0,,,,,,"ReturnAdder.addReturnsIfNeeded() does not add source locations in the following places (in Groovy 1.7.2):

line 126:

{code}
            return new BlockStatement(list,block.getVariableScope());
{code}

Should be:
{code}
            BlockStatement newBlock = new BlockStatement(list,block.getVariableScope());
            newBlock.setSourcePosition(block);
            return newBlock;
{code}


line 135:

{code}
            return new BlockStatement(list,new VariableScope(scope));
{code}

Should be:
{code}
            BlockStatement newBlock = new BlockStatement(list,new VariableScope(scope));
            newBlock.setSourcePosition(statement);
            return newBlock;
{code}

Apologies for not sending a proper patch file, but I am working off the source jar, rather than the svn project.  If you prefer, I can send a proper patch.  Thanks.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-05-10 14:41:57.0,,,,,,,,,,"0|i2bsnz:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ImportNode.getClassName() throws NPE when type is null,GROOVY-4193,12815189,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,werdna,werdna,06/May/10 21:28,23/Jun/10 15:45,14/Jul/23 06:00,07/May/10 00:10,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,parser-antlr2,,,,0,,,,,,"ImportNode has the following method:

{code}
    public String getClassName() {
    	return type.getName();
    }
{code}

When type is null, this throws an NPE.  I think the following is preferable (i.e., the equivalent of Groovy's safe dereferencing operator):


{code}
    public String getClassName() {
    	return type == null ? null : type.getName();
    }
{code}
",Groovy 1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 07 00:10:37 UTC 2010,,,,,,,,,,"0|i2cg5b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/May/10 00:10;roshandawrani;Done.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Class ReleaseInfo isn't thread-safe,GROOVY-4192,12815169,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,pniederw,pniederw,06/May/10 08:15,14/Aug/13 03:57,14/Jul/23 06:00,07/May/10 09:55,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,Current implementation of class ReleaseInfo doesn't look like it's thread-safe.,,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/May/10 09:48;roshandawrani;ReleaseInfo.java;https://issues.apache.org/jira/secure/attachment/12722319/ReleaseInfo.java",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 07 09:55:44 UTC 2010,,,,,,,,,,"0|i2cg13:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/May/10 09:00;blackdrag;Since we don't use the class in the runtime itself and it is only for the purpose of others reading that information I suggest to make all initialization in the static initlizer. The boolean can be removed then and the read access to the properties should then be safe enough. Of course a write operation may still cause problems.


Another way of ""fixing"" would be by documenting that this class is not thread safe and requires external synchronization.;;;","06/May/10 09:48;roshandawrani;Will the attached version do?;;;","07/May/10 08:07;blackdrag;unless Peter thinks different I would say it should be good to go;;;","07/May/10 08:31;pniederw;Looks good. Additionally, I'd make all fields final.
;;;","07/May/10 09:55;roshandawrani;Done. Thanks for the inputs, guys.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
 java.lang.ArrayStoreException on attempt to assign number to an element of a string array for a second time,GROOVY-4191,12818049,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,boriskob,boriskob,05/May/10 12:54,23/Jun/10 15:45,14/Jul/23 06:00,06/May/10 06:56,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"The following code demonstrates the problem:

{code}
def recreateProblem() {
    val = ""a;2"".split("";"");
    val[1] = 1;
}

recreateProblem();

// this second call will throw java.lang.ArrayStoreException
//
recreateProblem();
{code}

When I run this in the console I get this:

{code}

Exception thrown
5-May-2010 1:49:44 PM org.codehaus.groovy.runtime.StackTraceUtils sanitize
WARNING: Sanitizing stacktrace:
java.lang.ArrayStoreException: java.lang.Integer
	at org.codehaus.groovy.runtime.dgmimpl.arrays.ObjectArrayPutAtMetaMethod$MyPojoMetaMethodSite.call(ObjectArrayPutAtMetaMethod.java:81)
	at ConsoleScript6.recreateProblem(ConsoleScript6:4)
	at ConsoleScript6$recreateProblem.callCurrent(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:44)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:143)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:147)
	at ConsoleScript6.run(ConsoleScript6:12)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:264)
	at groovy.lang.GroovyShell.run(GroovyShell.java:513)
	at groovy.lang.GroovyShell.run(GroovyShell.java:170)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:857)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:151)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:276)
	at groovy.lang.Closure.call(Closure.java:271)
	at groovy.lang.Closure.run(Closure.java:354)
	at java.lang.Thread.run(Thread.java:619)

java.lang.ArrayStoreException: java.lang.Integer
	at ConsoleScript6.recreateProblem(ConsoleScript6:4)
	at ConsoleScript6$recreateProblem.callCurrent(Unknown Source)
	at ConsoleScript6.run(ConsoleScript6:12)
{code}



",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/May/10 02:18;roshandawrani;4191_v18x_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722509/4191_v18x_Patch.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 06 06:56:37 UTC 2010,,,,,,,,,,"0|i2c2pr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"06/May/10 02:18;roshandawrani;Attaching a patch.;;;","06/May/10 06:06;blackdrag;looks ok to me;;;","06/May/10 06:56;roshandawrani;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static generic method invocation with explicitely stated type doesn't compile,GROOVY-4190,12815182,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,aless,aless,04/May/10 10:23,23/Jun/10 15:45,14/Jul/23 06:00,08/May/10 01:59,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,Compiler,,,,0,,,,,,"Cannot compile statements like SomeClass.<Integer>create(). Example code:
{code:title=Test.groovy}
class Test<E> {
        E someVariable;

        protected Test() {
        }

        public static <E> Test<E> create() {
                return new Test<E>();
        }

        public static void main(String[] args) {
                Test<Integer> t = Test.<Integer>create();
        }
}
{code}
The error is:
{noformat}
$ groovy Test.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/home/aless/Test.groovy: 12: Unknown type: TYPE_ARGUMENTS at line: 12 column: 26. File: /home/aless/Test.groovy @ line 12, column 26.
                Test<Integer> t = Test.<Integer>create();
                            ^

1 error
{noformat}
Exactly the same file (with a .java extension) compiles with javac.
","Groovy Version: 1.7.2 JVM: 1.6.0_12
Running in Debian lenny amd64 with linux kernel 2.6.32",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/May/10 11:55;roshandawrani;4190_v18x_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722625/4190_v18x_Patch.txt","07/May/10 11:53;roshandawrani;v2_4190_v18x_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722269/v2_4190_v18x_Patch.txt","07/May/10 13:37;roshandawrani;v3_4190_v18x_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722268/v3_4190_v18x_Patch.txt",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 08 01:59:34 UTC 2010,,,,,,,,,,"0|i2cf0n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/May/10 07:17;blackdrag;I am reducing the visibility, since that does not make Groovy unusable;;;","05/May/10 07:18;blackdrag;I agree that this should be fixed, but even if the compiler accepts it, it does only mean the compiler will ignore it. Groovy does not apply any generics based type tests unless it is in some kind of signature.;;;","06/May/10 11:55;roshandawrani;Attaching a patch that lets the given code compiled successfully (but discards the type arguments);;;","07/May/10 08:10;blackdrag;that should do the trick, yes. I think the AST is not giving away the possibility to store the generics information. Even though we don't use it, it would be nice to have for people using the AST. But this could be handled in its own issue as improvement;;;","07/May/10 11:53;roshandawrani;@Jochen, attaching another patch. I have tried to do the remaining part also now itself.

Instead of totally discarding the type arguments, it now preserves them in MethodCallExpression to support future utilization of the information.;;;","07/May/10 13:06;blackdrag;The approach looks good so far, but I guess one missing part is a visiting in ResolveVisitor to resolve the classes used in the generics information.;;;","07/May/10 13:37;roshandawrani;Ok. I have added that bit too now. (and I will add the testcase with the snippet provided in the issue);;;","08/May/10 01:59;roshandawrani;Done. To summarize - the code now compiles and the generics info on method call expression is preserved during compilation, but currently not used for any purposes.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"NoSuchFieldError when defining a field named ""metaClass""",GROOVY-4188,12815150,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,pniederw,pniederw,03/May/10 14:44,23/Jun/10 15:44,14/Jul/23 06:00,06/May/10 03:47,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,Compiler,,,,0,,,,,,"The following script causes a NoSuchFieldError. It would be better if all Groovy-internal members started with ""$"", or at least caused a sensible compile error.

{code}
class Foo {
  private String metaClass
}
  
  
new Foo()
{code}",,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"04/May/10 03:11;roshandawrani;4188_v18x.txt;https://issues.apache.org/jira/secure/attachment/12722318/4188_v18x.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 05 08:03:16 UTC 2010,,,,,,,,,,"0|i2cr6v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/May/10 03:11;roshandawrani;Attaching a patch that makes the compiler throw an error when it sees a metaClass field defined that is of the wrong type. It doesn't try to do any mass changes to rename all groovy-internal members to start with '$'.;;;","05/May/10 07:15;blackdrag;In general I agree with the patch, but maybe CompileableSupport should be used and a test case with shouldCompile and shouldNotCompile be provided instead the manual usage of like in the current test case;;;","05/May/10 07:19;roshandawrani;I don't really like using just shouldNotCompile...because it doesn't verify what was the reason behind the failure...and if compilation changes a bit and there is a regression tomorrow and it starts failing for a reason different than the one desired, then it won't be caught by the test.;;;","05/May/10 07:56;blackdrag;But isn't that exactly what your test does?;;;","05/May/10 08:03;roshandawrani;shouldNotCompile() simply tests whether the compilation failed or not.

My test verifies whether the compilation failed due to the expected failure or not.

Say tomorrow due to some changes, the very same scenario fails due to some other compilation error - shouldNotCompile() will happily be green because there is ""some"" compilation failure, but my test will crib because it is no longer the expected failure.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"GDK should make the File method  setText(String text, String charset)    an alias for   write(String text, String charset)",GROOVY-4187,12815173,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,jcox,jcox,03/May/10 14:02,23/Jun/10 15:44,14/Jul/23 06:00,06/May/10 01:21,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"Because GDK makes the File method setText(String text) an alias for  write(text),
and because it's possible to say both  getText()  and getText(String charset),
it feels clunky that there is no  setText(String text, String charset).

In short, the following is annoying:
{code}
myfile.getText(charset)   
...
myfile.write(text,charset)     // Hm... I wish   myfile.setText(text,charset) just worked here too.
{code}

It seems like adding this alias would not break anybody's code,
and would remove a silly-thing-you-gotta-remember.

",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 13 10:07:07 UTC 2010,,,,,,,,,,"0|i2cm27:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/May/10 05:52;paulk;I probably agree that such a method is useful, but another way to look at it is that most people use the write method (which already has two variants) unless they plan to make use of the property style notation, e.g.
{code}
file.text = 'baz'
{code}
but given that such notation isn't easily supported when there is also a charset argument, then by adding the new method we are creating more confusion for developers - one more thing they have to remember.

But having said that, I think it is slightly more useful than more confusing. Possible patch:
{code}
    /**
     * Synonym for write(text, charset) allowing:
     * <pre>
     * file.setText('foo', charset)
     * </pre>
     *
     * @param file a File
     * @param charset the charset used when writing to the file
     * @param text the text to write to the File
     * @throws IOException if an IOException occurs.
     * @see #write(java.io.File, java.lang.String, java.lang.String)
     * @since 1.7.3
     */
    public static void setText(File file, String text, String charset) throws IOException {
        write(file, text, charset);
    }
{code}
;;;","06/May/10 01:21;paulk;Method added;;;","13/May/10 10:07;jcox;Thanks!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
very bad performance in GroovyCategorySupport because of static AtomicInteger use,GROOVY-4182,12815099,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,vkorehov,vkorehov,28/Apr/10 06:25,14/Dec/10 10:43,14/Jul/23 06:00,14/Dec/10 10:43,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-3,,,,,,,0,,,,,,"Profiler shows average 1ms per call in our multi-threaded (20 threads) application in most of the calls to PojoMetaClassSite.call()
because of static atomic Inreger is used (categoriesInUse) in GroovyCategorySupport.hasCategoryInCurrentThread():

    public static boolean hasCategoryInCurrentThread() {
        return categoriesInUse.get() != 0 && threadInfo.getInfo().level != 0;
    }
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 14 10:43:48 UTC 2010,,,,,,,,,,"0|i2covb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Apr/10 12:37;blackdrag;funny, just a few days ago I had a look at this method. I replaced it locally with a simple boolean instead of the usage of the AtomicIntger. But the performance was going up by maybe 1% in my test only, with a very big range of times, so that this 1% might be below the border an effect gets really measurable. AtomicInteger#get does read from a volatile, an action that people say can be realized on SPARC and Ix86/Ix64 architecture by a simple load without memory fences and thus without wait times for the value. A volatile read can cost much if it is on a different architecture. Is that the case for you? If yes, then my boolean version may help you, since it does not use any volatiles or atomics. But if you are on one of the architectures metioned above, it will not make a major difference. 

The matter is entirely different if you actually use categories. I have assumed you do not.

Are you sure the AtomicInteger#get is responsible for the timing you see?;;;","28/Apr/10 14:25;vkorehov;Ubuntu 9.10 Linux Sun JDK 1.6
NetBeans profiler shows total 35ms spent in method GroovyCategorySupport.hasCategoryInCurrentThread() for about 30 calls.
And this is for trivial 30 field xml dom access in 40 line groovy script.

GroovyCategorySupport.hasCategoryInCurrentThread eats 95% of the whole processing time.

As I mention I have 20 threads running concurrently and doing same task in groovy (dom access).
And this is EXTREMELY important!
With a single threaded test you will never be able to see real performance impact.

Not sure if u're up to date on volatile implementation in Java 5: http://www.javamex.com/tutorials/synchronization_volatile_java_5.shtml

So it's essentially a global lock now.
I'm pretty sure it can be avoided easily in your case.;;;","28/Apr/10 14:28;vkorehov;CPU: x86;;;","28/Apr/10 15:50;blackdrag;The test I did was calculating a fibonacci number in a couple of threads in parallel. My test was on Sun JDK6 on a 64bit machine on Ubuntu. I am aware of the Java Memory Model as it exists since Java5. The information I gave you about the volatile read is according to that memory model and from several people from the concurrent area (including Doug Lea). A volatile read does not need a hardware lock because of the memory model the CPUs use on those platforms.

But I get the feeling that in your case the program does not run long enough to be compiled by hotspot. You can add these JVM parameters {code}
-XX:+UnlockDiagnosticVMOptions -XX:PrintAssemblyOptions=hsdis-print-bytes -XX:CompileCommand=print,org/codehaus/groovy/runtime/GroovyCategorySupport.hasCategoryInCurrentThread
{code]
to see if you get some assembler code for the method. This way you could be sure it is really compiled.

But as I said, giving an example I can use to reproduce the problem would help me.;;;","03/May/10 11:06;vkorehov;Hi,
I'm running on 32bit x86 architecture not 64bit.
Memory barrier is essentially a lock for a duration of memory operation, but just a hardware based lock and all this is quantitative rather then qualitative difference...
Unfortunately I cannot attach test case because it is part of application.
In thread payloads I'm just reading XML similar to this:
http://groovy.codehaus.org/Reading+XML+using+Groovy's+XmlParser
While Fibbonachi calculation is a syntetic test.

But does use of this lock is totally necessary from the design point of view? cannot be enough with thread local?
It is very easy to add locks and it is very difficult to remove them after.;;;","05/May/10 07:07;blackdrag;A memory barrier is a bit more, since it requires are synchronization of the main memory with the processor cache. This operation is of course much slower, than just reading from the CPU cache. In that regard, there is of course a major difference between reading from the local cache and having to sync. Of course a cache miss may cause something like that too.

A volatile has in general better performance than a ThreadLocal, at least if you have to get the ThreadLocal on each request.

As for the test case.. I was hoping you cold provide something that exhibits the same problem. It doesn't have to be exactly what you do in your application. But as it is, it may very well be, that my change from the volatile boolean to not being volatile will not have any effect.;;;","08/May/10 06:39;vkorehov;Excuse me, but this is complete nonsense!
First of all memory barriers not only involve cache synchronizations but the also serialize the memory operations by different contexts.
http://en.wikipedia.org/wiki/Memory_barrier
Please re-read this arcicle http://www.javamex.com/tutorials/synchronization_volatile_java_5.shtml which clearly states that  volatile keyword semantics DID CHANGE in Java 5, which reduced concurrency and now is comparable with synchronized().

Your statement about ThreadLocal just shows major incompetence in the subject!
ThreadLocal is using simple non-synchronized memory access from thread local storage. This is a simple read operation, in comparison to a synchronized read which is implemented! This memory is part of thread storage space allocated by oerating system. This is the SAME memory as the stack or heap is using! there is NO any performance penalty on accesing this memory!
http://en.wikipedia.org/wiki/Thread-local_storage
;;;","08/May/10 07:12;blackdrag;Don't get me wrong, I am talking here only about java5, not before. I am aware that it changed and I am not questioning that. Not sure were you got this idea from. What I was saying is, that volatile read can be done on x86 without going through a memory barrier, because of the memory model used. This is not my personal believe. Some comments from the concurrency-interest list: Hans Boehm, April 27, 2010: ""On X86 or SPARC TSO or similar, there no memory fence/barrier instruction is needed on the read side, even if volatiles are used.  Ever."". I could verify that by looking at the assembler code generated for such a volatile access. My statement that ThreadLocal is slower than a volatile depends on personal experience and confirmation from several sides. ThreadLocal can be equally fast, if not faster than volatile, if, and only if you don't have to go and get the ThreadLocal object anew - meaning you don't have to get the thread local space first. I am not talking about object creation here. ThreadLocal has kind of a map that stores the thread local spaces and getting the current thread and using that to go through the map to finally get the thread local storage is what slows it down. Since exactly that would have to be done at the place in question, you will end up slower than with using a volatile. And yes, I tested this. We are not talking about a big difference here of course, but it is a difference.

But who cares. I announced I will replace categoriesInUse.get() with a simple boolean I already said. Then it is a direct memory access for sure. I only warned that in my tests this was not giving a major improvement. That is also why I asked for a testcase.

Another reasons I was asking for one is, because I think the time is not spend in the AtomicBoolean, I think it is spend in the threadInfo.getInfo().level part. Which should be only the case if you have categories active in your code while this part is handled. 

But ok... since we seem to have a major difference somewhere, there is a simple way of testing if the approach will be ok or not. I can give you a patch or something like that and you test it on your system. Are you willing to do that?;;;","09/May/10 07:37;vkorehov;Hi.
that would be great (patch).
I can teest. it will be much easier here. I can share profilig results after.
Thanks and regards.;;;","15/Oct/10 04:47;blackdrag;took quite some time, sorry.... trunk would now contain a fixed version for this... you want to try it?
;;;","14/Dec/10 10:43;blackdrag;I declare it as fixed until further notice. Vladislavs, should the issue not be fixed in your view, feel free to reopen the issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc appears to be broken with java.util.NoSuchElementException,GROOVY-4180,12818053,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,graemerocher,graemerocher,23/Apr/10 04:13,23/Jun/10 15:45,14/Jul/23 06:00,30/Apr/10 07:24,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,GroovyDoc,,,,0,,,,,,"groovydoc in grails 1.3 (groovy 1.7.2) applications is broken with the following error occuring:

{code}
java.util.NoSuchElementException
	at java.util.HashMap$HashIterator.nextEntry(HashMap.java:796)
	at java.util.HashMap$EntryIterator.next(HashMap.java:834)
	at java.util.HashMap$EntryIterator.next(HashMap.java:832)
	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.processFile(GroovyRootDocBuilder.java:209)
	at org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder.buildTree(GroovyRootDocBuilder.java:163)
	at org.codehaus.groovy.tools.groovydoc.GroovyDocTool.add(GroovyDocTool.java:65)
	at org.codehaus.groovy.ant.Groovydoc.execute(Groovydoc.java:391)
	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:288)
	at sun.reflect.GeneratedMethodAccessor81.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at 
{code}",,marcusb,quexer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 30 07:24:03 UTC 2010,,,,,,,,,,"0|i2cclz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Apr/10 04:01;paulk;The exception should no longer be thrown. The exception was only occurring when trying to create GroovyDoc for a script. An interesting question is what defaults we might consider/could support for 
Groovydoc for scripts - at the moment, they are ignored.;;;","29/Apr/10 11:00;graemerocher;Should the issue be closed then?;;;","30/Apr/10 07:24;paulk;Yes, issue is resolved. There is now also partial GroovyDoc support for Scripts (method JavaDoc only). It would be great if this could be tested against the Grails codebase.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy categories cause tomcat memory leak and prevent tomcat shutting down,GROOVY-4177,12811922,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,jwagenleitner,graemerocher,graemerocher,20/Apr/10 06:45,04/Mar/16 03:13,14/Jul/23 06:00,21/Jan/16 19:15,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.0,,,groovy-runtime,,,,1,,,,,,"Any Groovy application (including Grails apps) that deploy to Tomcat 6.0.26 and above has this issue because basically Tomcat clears thread locals not manually shutdown by the application to prevent memory leaks.

This can lead to problems starting and stopping Groovy based application with errors like the following occuring:

{code}
    [java] Exception in thread ""Thread-3"" java.lang.NullPointerException
     [java] 	at org.codehaus.groovy.runtime.GroovyCategorySupport.hasCategoryInCurrentThread(GroovyCategorySupport.java:216)
     [java] 	at groovy.lang.MetaClassImpl.getMethodWithCaching(MetaClassImpl.java:1128)
     [java] 	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:904)
     [java] 	at groovy.lang.ExpandoMetaClass.invokeMethod(ExpandoMetaClass.java:915)
     [java] 	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
     [java] 	at groovy.lang.Closure.call(Closure.java:276)
     [java] 	at groovy.lang.Closure.call(Closure.java:271)
     [java] 	at groovy.lang.Closure.run(Closure.java:354)
{code}

Groovy needs to include the ability to manually shutdown the any categories that exist in any threads and also re-instate the categories if they are nulled (like what happens with Tomcat)",,fxg,goeh,jhuxhorn,jwagenleitner,quexer,shenie,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4130,,,,,,,,,GROOVY-4698,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 21 19:14:49 UTC 2016,,,,,,,,,,"0|i2bv2v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Apr/10 07:44;blackdrag;This looks very much like the threadInfo filed in GroovyCategorySupport got nulled. We use TheadLocals at several places. From your description I see that all of them would be having that problem. The problem is, that the threadInfo is a final static variable and is so for a good reason. The any way to ""fix"" this inside Groovy will cost performance. I would for example have to synchronize access to this field. Is there no way to prevent tomcat from cleaning ThreadLocals used by the Groovy runtime?;;;","21/Jan/16 19:14;jwagenleitner;Based on the [code in GroovyCategorySupport.java|https://github.com/apache/groovy/blob/425362539843a686b9ab2a0c199d1c2b0a184331/src/main/org/codehaus/groovy/runtime/GroovyCategorySupport.java] at the time this JIRA was created it looks like the problem was that the ThreadLocal was never cleaned up.  Since that time [code has been added to call {{ThreadLocal.remove()}}|https://github.com/apache/groovy/blob/7cb20675e1f166fed1dc87bafc8203f91e7b5627/src/main/org/codehaus/groovy/runtime/GroovyCategorySupport.java#L88] in [commit 7cb20675e|https://github.com/apache/groovy/commit/7cb20675e1f166fed1dc87bafc8203f91e7b5627] as a fix for GROOVY-4130.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Currying private methods,GROOVY-4170,12818397,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roller_vaclav,roller_vaclav,13/Apr/10 13:25,23/Jun/10 15:45,14/Jul/23 06:00,14/Apr/10 01:21,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"Private methods cannot be curried any more under 1.7.2. I'm pretty sure the code worked fine under earlier Groovy versions.

The code:
{code}
class CurryFoo {
    protected void foo1(String s, int i) {
        println 'Hurray! Foo1 can be curried.'
    }

    private void foo2(String s, int i) {
        println 'Hurray! Foo2 can be curried.'
    }

    public void bar() {
        this.&foo1.curry('anything', 1).call()
        this.&foo2.curry('anything', 1).call()
    }
}

new CurryFoo().bar()
{code}

outputs:

{noformat}
Hurray! Foo1 can be curried.
Caught: java.lang.IllegalArgumentException: To curry 2 argument(s) expect index range 0..-2 but found 0
    at groovyx.gpars.samples.safe.CurryFoo.bar(CurrySample.groovy:30)
    at groovyx.gpars.samples.safe.CurrySample.run(CurrySample.groovy:34)

Process finished with exit code 1 
{noformat}

Roshan Dawrani commented on the mailing list:
True. Doesn't work under 1.7.3 as reported and works on 1.6.9.
This seems to have been caused (unintentionally) by some recent changes in closure currying (rcurry / ncurry).
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 14 02:55:01 UTC 2010,,,,,,,,,,"0|i2bu5b:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"13/Apr/10 16:06;roshandawrani;I looked a bit into it.

What is happening is that in MethodClosure, it selects the method that responds to the method whose pointer MethodClosure holds.

This method selection is made by call ""InvokerHelper.getMetaClass(clazz).respondsTo(owner, method)"". While this works ok for non-private methods, it doesn't for private methods - because method selected for ""foo2"" is the MOP method ""this$2$foo2"".

Since MethodClosure matches the name to get the # of parameters, in this case, because of the name mismatch, it continues to have 0 as the # of parameters, even though foo2() has 2 parameters - that causes the index calculation to go wrong in CurriedClosure and the newly added check for ncurry/rcurry rejects the code with an exception.;;;","13/Apr/10 16:29;roshandawrani;Here is the patch I propose. After the matching methods have been found through the call ""InvokerHelper.getMetaClass(clazz).respondsTo(owner, method)"", there is no need to further match the name. 

It's not right to match the name anyway, as for private methods (""foo""), it is the MOP methods(""this$2$foo2"") that receive the call and then delegate to the private methods they cover.

{noformat}
Index: src/main/org/codehaus/groovy/runtime/MethodClosure.java
===================================================================
--- src/main/org/codehaus/groovy/runtime/MethodClosure.java (revision 19867)
+++ src/main/org/codehaus/groovy/runtime/MethodClosure.java (working copy)
@@ -44,7 +44,7 @@
         List<MetaMethod> methods = InvokerHelper.getMetaClass(clazz).respondsTo(owner, method);

         for(MetaMethod m : methods) {
-            if (method.equals(m.getName()) && m.getParameterTypes().length > maximumNumberOfParameters) {
+            if (m.getParameterTypes().length > maximumNumberOfParameters) {
                 Class[] pt = m.getNativeParameterTypes();
                 maximumNumberOfParameters = pt.length;
                 parameterTypes = pt;
{noformat};;;","13/Apr/10 17:10;paulk;Looks good to me. So, I suspect even though one level of currying was working, if the # of params was wrong, then possibly further currying even prior to the recent changes may have broken things.;;;","14/Apr/10 01:21;roshandawrani;Fixed.;;;","14/Apr/10 02:55;roller_vaclav;Wow, that was quick. Thank you.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compile error on annotations for closure parameters,GROOVY-4169,12815144,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,herrmama,herrmama,13/Apr/10 10:49,23/Jun/10 15:45,14/Jul/23 06:00,13/Apr/10 11:58,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,Compiler,,,,0,,,,,,"I get a compile error on annotations which are defined for closure parameters. This is a minimal and complete example where the problem occurs:


public @interface description {
   String value()
}

newClassImpl = { @description(""Whether the class is abstract"") boolean abstr ->
}


The compile error in this case says ""class description is not an annotation in @description"".",Windows XP,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 13 11:58:32 UTC 2010,,,,,,,,,,"0|i2c87b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Apr/10 11:58;roshandawrani;Fixed - by resolving the annotation types.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MapWithDefault doesn't have correct equals functionality,GROOVY-4168,12815096,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,13/Apr/10 05:56,07/Apr/15 19:06,14/Jul/23 06:00,13/Apr/10 06:07,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"In this example, the last line fails but shouldn't:
{code}
def m = [:].withDefault {k -> k * 2}
m[1] = 3
assert m[1] == 3
assert m[2] == 4
assert [1:3, 2:4] == m
assert m == [1:3, 2:4]
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-04-13 05:56:50.0,,,,,,,,,,"0|i2ciwv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovyc is unable to compile a class which implements interface and uses @Delegate annotation,GROOVY-4163,12815155,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pdolega,pdolega,11/Apr/10 19:27,22/Jul/10 17:32,14/Jul/23 06:00,25/Jun/10 19:22,1.7.1,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.4,1.8-beta-1,,Compiler,,,,0,,,,,,"Groovy source file is attached.

I am trying to compile this file with the command:
groovy Temp.groovy

Compiler's output is as follows:

org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Temp.groovy: 4: Can't have an abstract method in a non-abstract class. The class 'Temp' must be declared abstract or the method 'void run()' must be implemented.
 @ line 4, column 1.
   class Temp implements Runnable {
   ^

1 error
","linux x86_64 - Fedora 12,
Groovy 1.7.2 (also 1.7.1)
Java 1.6.0_18 (64-bit)",paulk,pdolega,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Apr/10 19:27;pdolega;Temp.groovy;https://issues.apache.org/jira/secure/attachment/12722560/Temp.groovy","25/Jun/10 04:53;paulk;groovy4163_delegateWithImplementsC.patch;https://issues.apache.org/jira/secure/attachment/12722681/groovy4163_delegateWithImplementsC.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jun 26 08:51:13 UTC 2010,,,,,,,,,,"0|i2bujb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Apr/10 12:22;blackdrag;This could be solved if @Delegate runs before that check is done... only question is, if that is possible. ;;;","12/Apr/10 12:36;pdolega;Well, it compiles with no problem under Eclipse...
I need to compile groovy sources in my Gradle build, so Eclipse build is of no help to me actually but I thought it may be useful to look how guys are doing the compilation there. 

Thanks !;;;","12/Apr/10 16:26;blackdrag;the eclipse plugin in is not the reference. They do what they need to do and sometimes their solution is good for eclipse, but not for Groovy. Also their are largely using the normal compiler. So if it works there now, there is no guarantee it will work there tomorrow too.;;;","24/Jun/10 09:29;roshandawrani;Jochen, regarding your 1st comment here - @Delegate does already run before(canonicalization) the check takes place (classgen).;;;","24/Jun/10 10:23;blackdrag;then why is there no run method?;;;","24/Jun/10 10:32;roshandawrani;Explanation in the comments inline:

{code}
class DelegateASTTransformation -> 
private void addDelegateMethod(...Map<String, MethodNode> ownMethods, 
    Map.Entry<String, MethodNode> e, ...) {
    MethodNode method = e.getValue();

    if (!method.isPublic() || method.isStatic() || 0 != (method.getModifiers () & Opcodes.ACC_SYNTHETIC))
        return;

    if (!method.getAnnotations(DEPRECATED_TYPE).isEmpty() && !deprecated)
        return;

    MethodNode existingNode = ownMethods.get(e.getKey());

    /*
        Roshan: the following condition is not met for run() and hence it is not added
        as a delegate method

        ownMethods collection here is filled up for class Temp's interfaces, superclasses and itself
        and hence has run() already from java.lang.Runnable
    */
    if (existingNode == null || existingNode.getCode() == null) {
        // add the delegate method
    }
}
{code};;;","24/Jun/10 15:35;blackdrag;I think the test for getCode()==null is wrong. Every method from a precompiled class will have that being abstract or not. If the method really is from Runnable and not from Thread, then this test should be replaced with a test for abstract instead. Because then the runnable method should be ignored and Thread#run method should be used. Of course, if for some reason the Threadd#run method does not even appear, that is yet another part of this bug;;;","24/Jun/10 15:45;roshandawrani;Precompiled classes never seem to have getCode()==null. org.codehaus.groovy.vmplugin.v5.Java5#setMethodDefaultValue() ensures that all the methods of precompiled classes have getCode() != null.

I already tried adding existingNode.isAbstract() in there. That helped in this case but broke other cases because then methods of GroovyObject (getMetaClass()/setMetaClass(), etc) also started coming in loop (DelegateAstTransformation comes before Verifier - so by the time @Delegate is happening, if we add isAbstract() check, then this adds getMetaClass()/setMetaClass() delegate methods as well, which interferes with what Verifier tries to do later - provide the standard getMetaClass()/setMetaClass(), etc);;;","24/Jun/10 16:36;blackdrag;I didn't mean to add it if abstract, I did mean to ignore it if abstract. This way an interface method should not be added ever. There should be an addition of the run method only because of an existing run method in Thread.;;;","24/Jun/10 17:06;roshandawrani;No, no that is opposite of how it should be. In DelegateASTTransformation#addDelegateMethod(), it is looping over java.lang.Thread's method. It does not add Thread's run() to class Temp because it sees an existing run() on Temp (coming from Temp implementing Runnable). So what ends up being is that when it comes to ClassCompletionVerifier, it sees that Temp has an abstract run() (Runnable's) but no implementation of run() (because Thread's run() didn't get added to it).

The solution will be to add the delegate run() to Temp's method in DelegateASTTransformation#addDelegateMethod() and not ignore it.

Currently it is being ignored already and that is what is raising the issue in the first place. And it is being ignored because existingNode != null and existingNode.getCode() != null for run().

And the getCode() != null because of that stupid org.codehaus.groovy.vmplugin.v5.Java5#setMethodDefaultValue() adding a return statement even to abstract methods of precompiled interfaces.;;;","24/Jun/10 17:41;blackdrag;it does not add Thread#run, because there is an existing run method? The code was {code:Java}import groovy.lang.Delegate;


class Temp implements Runnable {
	@Delegate 
	private final Thread runnable
	
	def static main(args) {
		def thread = Thread.currentThread();
		def temp = new Temp(runnable: thread)
	}
}{code}
If you now imply that the ""implements Runnable"" is causing a run method to appear on Temp, then this is clearly not the intention. Unless the method is declared in Temp itself, the method should be override-able through the delegate. This of course creates a problem for GroovyObject implementing Java classes. @Delegate would then have to skip those special groovy methods.;;;","24/Jun/10 17:48;roshandawrani;ownMethods collection that addDelegateMethod() uses for the following check comes from ClassNode#getDeclaredMethodsMap() and it has methods from all its interfaces too. So, when Temp doesn't provide an implementation, the above collection will still have a run() coming from Runnable. Looking at that, DelegateASTTransformation doesn't add the overriding run() that comes from Thread - causing ClassCompletionVerifier to see it as an abstract method whose implementation has not been provided.
{code}
        MethodNode existingNode = ownMethods.get(e.getKey());

        if (existingNode == null || existingNode.getCode() == null) {
        }
{code};;;","24/Jun/10 18:03;blackdrag;and I think that getDelcaredMethodsMap is maybe the wrong way, Either it should be only all non abstract methods or only the methods implemented in the current class that are used for this check. So for sure abstract methods originating from interfaces should be filtered out or other means to get the methods we need should be used... for example only getMethods(). Of yourse the later would mean a delegate would be overriding a method defined in the superclass if I am not wrong. Actually we need first discuss on the lists if this is correct behavior. Judging from backwards compatibility it surely is not. So in the end filtering our the ""abstract methods not declared in the delegate using class"" should be the way to go.;;;","24/Jun/10 18:08;roshandawrani;Yes, now it seems on the right track - only that I don't know how to explain it all on the mailing list :-) Someone with more background of current Delegate design can better ask that - like, what all it is designed to let the user override, etc (super class methods, for ex, as you point out);;;","24/Jun/10 22:07;paulk;The workaround for this case is to leave out the _implements_ clause, e.g.:
{code}
class Temp {
    @Delegate
    private Thread runnable
    
    static main(args) {
        def thread = Thread.currentThread()
        def temp = new Temp(runnable: thread)
    }
}

//println Temp.class.interfaces
{code}
The Delegate transform will add in any interfaces found on the delegates class unless ""interfaces=false"" is provided as a param to the annotation.;;;","24/Jun/10 23:46;paulk;Potential patch - but breaks GroovyShellTestCase which uses @Delegate with a protected field - investigating that now.;;;","25/Jun/10 00:20;roshandawrani;Y'day I tried multiple ways of fixing it too, but all got stuck with that @Delegate use in GroovyShellTestCase :-) Sometimes it couldn't find setUp() on NullObject, other times, some interference started happening with those special methods of GroovyObject and its getMetaClass(), etc started getting affected.

Then only I resorted to discussing it with Jochen. :-)
;;;","25/Jun/10 01:07;paulk;Yes, not much doco and poor test coverage in this territory! :-(
Revised attached patch is better.
We'll have to make coverage testing more visible and maybe GSoC spec project can help us in spec area.;;;","25/Jun/10 02:31;paulk;Possibly it would be better to skip methods from Object too - or at least prohibit Object from being the delegate type, i.e. give a warning if you leave out the type.;;;","25/Jun/10 02:34;roshandawrani;That seems like a harmless restriction and makes sense too, but what is the issue if Object methods are not filtered?;;;","25/Jun/10 03:53;paulk;Stops this:
{noformat}
You are not allowed to override the final method wait(long) from class 'java.lang.Object'.
{noformat};;;","25/Jun/10 04:01;roshandawrani;But doesn't that point to the breaking change that Jochen was pointing to? That after this change we will start overriding methods of super classes (because we now use ClassNode.getMethods() and not getDeclaredMethodMap())

What if we filter out Object but we still have a structure like below:

{code}
class A {
     final def foo(){}
}

class B extends A {
     @Delegate C c
}

class C {
     def foo(){}
}
{code}

Now you have a base class A that provides the final method foo() that that base class is not Object. How do we take care of it? I think that is the breaking change Jochen was pointing to.;;;","25/Jun/10 04:53;paulk;Revised patch - this one gives supplied method (direct or inherited) precedence over delegated method.;;;","25/Jun/10 19:22;paulk;Patch applied;;;","26/Jun/10 00:11;roshandawrani;I was testing the example from my last comment, but made a typo and it highlighted an issue that has been introduced.

{code:title=A.groovy}
class A {
     final def foo(){}
}
{code}

{code:title=B.groovy}
class B extends A {
     @Delegate C c = new C()
     static main(args){
        c.foo()
     }
}
{code}

{code:title=C.groovy}
class C {
     def foo(){}
}
{code}


{code:title=Expected error}
Apparent variable 'c' was found in a static scope but doesn't refer to a local variable, static field or class.
{code}

{code:title=Actual error}
Caught: java.lang.VerifyError: (class: B, method: main signature: ([Ljava/lang/String;)V) Incompatible type for getting or setting field
{code};;;","26/Jun/10 01:20;paulk;Does the fragment below also fail for you? Doesn't seem related to @Delegate if that is the case.
{code}
class B {
  def c = new Object()
  static main(args) {
    c.foo()
  }
}
{code}
I suspect it was introduced when we split out StaticVerifier and we mustn't have coverage for that case. :-(;;;","26/Jun/10 01:36;paulk;OK, found the issue. It was a missing line from GROOVY-4228.;;;","26/Jun/10 01:46;paulk;Can you try again?;;;","26/Jun/10 03:39;roshandawrani;Seems fine now.;;;","26/Jun/10 05:02;roshandawrani;Possibly one more issue here. The check introduced before deciding whether to add a delegate a method or not is based on type descriptor of the method alone and that may not be sufficient.

In the code below, shouldn't the call from B#main() go to C#foo()?

So, if for a delegate candidate method (which can only be an instance method), if in DelegateASTTransformation#addDelegateMethod(), a match(existingNode) is found but is static, it should be ignored.

{code:title=A.groovy}
class A {
     static foo(){println ""A->foo()""}
}
{code}
{code:title=B.groovy}
class B extends A {
     @Delegate C c = new C()
     static main(args){
        new B().foo()
     }
}
{code}
{code:title=C.groovy}
class C {
     def foo(){println ""C->foo()""}
}
{code}
;;;","26/Jun/10 05:26;roshandawrani;I just checked that the static/instance issue last raised is present in 1.7.3 too.

Should I open a new issue? I am not doing it right away to also check if others see it is a valid issue.;;;","26/Jun/10 06:42;paulk;A new issue might be best;;;","26/Jun/10 08:51;roshandawrani;Raised GROOVY-4265 for the issue related to @Delegate wrongly dealing with static matches.;;;",,,,,,,,,,,,
Source locations for added default constructors are incorrect,GROOVY-4161,12815138,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,werdna,werdna,09/Apr/10 16:43,23/Jun/10 15:45,14/Jul/23 06:00,13/Apr/10 13:11,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"Groovy Eclipse has just upgraded to Groovy 1.7.2 from 1.7.0 and there is a change to Verifier.addDefaultConstructors() that is breaking us.

The code is now:

{code}
BlockStatement empty = new BlockStatement();
empty.setSourcePosition(node); 
ConstructorNode constructor = new ConstructorNode(ACC_PUBLIC, empty);
constructor.setSourcePosition(node);
{code}

Is there a reason why the source location for the empty blockstatement and its containing constructor is set to be the source location of the entire class?

This is breaking content assist in Groovy-Eclipse.  We would prefer to have these kinds of synthetic methods not have any source location at all.

I propose to change it to this:

{code}
BlockStatement empty = new BlockStatement();
ConstructorNode constructor = new ConstructorNode(ACC_PUBLIC, empty);
{code}

(As above, but just remove the calls to ""setSourcePosition"".)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 13 15:47:10 UTC 2010,,,,,,,,,,"0|i2c03j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Apr/10 18:48;blackdrag;The change was done to align it with Java. Even though the constructor is synthetic, you can still have exceptions in it caused for example bye variable initialization. Java does use here the source position of the class definition, so it sounded like a good idea to have that for Groovy too. ;;;","09/Apr/10 21:07;roshandawrani;The constructor added in Verifier.addDefaultConstructors() is public and not synthetic.

Cobertura used to crib about such constructors because they didn't have any source location information.;;;","10/Apr/10 16:39;werdna;This constructor is not synthetic in the Java sense (ie- it does not have the synthetic flag on it and it *can* be called by user code), but it is synthetic in a different sense in that it was generated by the verifier.

Currently, as far as I can tell, there is no way to distinguish such a constructor from actual, user constructors.  Since it seems like the source locations are required here, would it be possible to add some sort of flag to this kind of constructor?  Something like isDefaultConstructor(), which returns true iff it was generated by the verifier.;;;","10/Apr/10 20:47;roshandawrani;Yes, a flag can be added, but could you tell what is so particular about the constructors? 

Groovy compiler also adds getters/setters for properties - and for them also, I don't think, there is any way to distinguish whether they were user provided or groovy generated.;;;","10/Apr/10 23:28;roshandawrani;Or, instead of introducing a new flag, isSynthetic() can also be utilized for this purpose.

Anyway, there is no inter-relation between synthetic flag and its modifiers for any node. So, 'synthetic' flag can be set by groovy and utilized by greclipse without affecting modifiers of the constructor in any way.

Jochen, a new flag or existing synthetic flag?;;;","10/Apr/10 23:41;werdna;I'd be concerned about changing the meaning of isSynthetic to something other than pertaining to the synthetic modifier.  That goes against my intuition of what the method should mean.

And your first point, I agree, it would be nice to know if a getter/setter was generated rather than from code.  Or any other field/method/property for that matter (as a side note...aren't all properties genterated?).;;;","11/Apr/10 00:01;roshandawrani;You can write

{code}
class Test {
    String foo
}
{code}

or you can write
{code}
class Test {
    String foo
    public String getFoo() {
        return foo + foo
    }    
}
{code}

In first case, getter is generated by groovy, in next case, it is user provided.

If you need to know about every method/field, it will be a much wider change as things get added for many reasons at many places - like core groovy adding property accessors, doing enum processing or usage of some AST transform like @Immutable/@Delegate, etc, etc.

So, if your request right now is limited to the default constructor having a flag that distinguishes it (to tackle any immediate problem), I can do it. For a general/common change, I need to leave it open for discussion here.;;;","11/Apr/10 18:25;werdna;My request right now is limited to just the default constructor, but I can see a general benefit of having this spread to all such generated fields and methods.

It seems to me that any field, method, or class created in AntlrParserPlugin would have the isGenerated() flag (or whatever it winds up being called) set to false, everywhere else, it would be set to true.

So, perhaps the best way to design this would be to have the flag originally set to true, and then there could be some logic withing AntlrParserPlugin that sets it to false for all methods, fields, and classes created directly from the source.  It does not seem to me to be a big change, but I may be wrong.

But as I said for now, the only real problem that I am having is with these default constructors.;;;","11/Apr/10 22:13;roshandawrani;Handling the flag in AntlrParserPlugin (APP) will cover it partially, because not all user written code goes into MethodNode/ClassNode, etc in APP.

1) If you write the script below, the code doesn't go into ""run"" MethodNode and ""script"" ClassNode in APP, but in ModuleNode.
{code}
def foo = ""1""
def bar = ""2""
{code}

2) If you write the code with closure expression as below, the closure code does not go into ""doCall"" MethodNode and ""closure"" ClassNode in APP, but in AsmClassGenerator.
{code}
def cl = {-> println ""x""}
{code}

3) Another thing that can come in the way is that there are various transforms that take place after APP, which transform an existing node to another node - (say, in case of enum constants, etc). The ""isGenerated"" state may have to be transferred from old nodes to new nodes where such transformations are taking place.

There may be other such cases as well. So, you see, there is no one central place where ""isGenerated"" marking can be done.

So, I suggest splitting the requirements here - I will make the change for the default constructor as part of this JIRA and open an ""improvement"" JIRA for the generic change (so that it can follow its analysis/discussion cycle).

Can you please tell me why this information is of use to GRECLIPSE whether the method/constructor/field was user provided or groovy generated? I thought what would matter is whether the stuff is synthetic or not. 

Of what use is this further differentiation - why is a hand written default constructor different from a groovy-added (but non-synthetic) default constructor?;;;","12/Apr/10 12:06;werdna;Inside of Groovy-Eclipse, we make heavy use of AST Visitors to translate the source location of the carat into an AST node.  Often, we try to shortcut the visitor and not walk down branches of the AST that we know the carat cannot be in.  So, if the current selection is outside the source location of an AST node, then we know that we do not need to visit it.

However, there are two complications here:

* Generated AST nodes (eg- default constructors that contain the object initializer blocks) must be visited regardless of what their source location is.  This is because even if a generated node has a source location outside of the current selection, its contained nodes might actually be relevant.
* Generated AST nodes (again, such as the default constructors) sometimes have source locations that overlap with other source locations.  Groovy-Eclipse needs to be able to distinguish these synthetic source locations from the real source location.  For example, when a default constructor has an overlapping source location with its declaring class, it needs to be able to know that the source location for the constructor is not relevant for invoking content assist (or navigation or search, etc).;;;","12/Apr/10 20:57;roshandawrani;Thanks for explaining that, Andrew.

So, for now, I will just set a ""isGenerated"" flag on the ConstructorNode that will tell whether the default constructor is added by groovy or not.

Anyone has any concern with that or wants to do it in an alternative way, please raise it now. Thanks.;;;","13/Apr/10 06:35;blackdrag;how about: ""hasNoRealSourcePosition""? ;;;","13/Apr/10 06:39;roshandawrani;Will be added on the base AnnotatedNode but set only on the default ConstructorNode added by Verifier, for now?;;;","13/Apr/10 11:59;blackdrag;ok;;;","13/Apr/10 13:11;roshandawrani;Made the change.

ConstructorNode#hasNoRealSourcePosition() == true indicates that it is a default constructor added by groovy.

For other nodes, this flag is not set and has no meaning yet.;;;","13/Apr/10 15:47;werdna;Thanks, Roshan, for getting this done.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
hang on exception in synchronized block,GROOVY-4159,12811641,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,san,san,09/Apr/10 03:55,10/Jun/10 09:11,14/Jul/23 06:00,10/Jun/10 09:11,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"Following script hangs on 1.7.2:

obj = 1
synchronized(obj) {
    obj.e
}",,alexanderkl,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 10 09:11:29 UTC 2010,,,,,,,,,,"0|i2ctrz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Apr/10 07:06;blackdrag;sigh... looks like after my rewrite the snychronized block is not handled right anymore. It should not hang, that makes it a blocker of course;;;","10/Jun/10 09:11;blackdrag;fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
cannot mix rcurry and ncurry together,GROOVY-4158,12815159,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,hamletdrc,hamletdrc,09/Apr/10 00:41,23/Jun/10 15:45,14/Jul/23 06:00,09/Apr/10 09:03,1.7.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"Groovy is not letting me mix ncurry and rcurry.

def operation = { int x, Closure f, int y -> f(x, y) }
def divider = operation.ncurry(1) { a, b -> a / b }
def halver = divider.rcurry(2)
assert 50 == halver(100)

the last line fails with the parameters out of order, even though it
should not:

Caught: groovy.lang.MissingMethodException: No signature of method:
NewInGroovy_1_7_2$_run_closure4.doCall() is applicable for argument
types: (NewInGroovy_1_7_2$_run_closure5, java.lang.Integer,
java.lang.Integer) values: [NewInGroovy_1_7_2$_run_closure5@6179d854,
100, 2]
Possible solutions: doCall(int, groovy.lang.Closure, int)
       at NewInGroovy_1_7_2.run(NewInGroovy_1_7_2.groovy:73)",Tested on Ubuntu,hamletdrc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 09 11:04:56 UTC 2010,,,,,,,,,,"0|i2cotb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Apr/10 09:03;paulk;Clone was not updated when other method were updated. Would be great if you can play with it some more before we do 1.7.3 release. Just dropping the 1.7.3-SNAPSHOT jar from the CI server into your 1.7.2 install should suffice if you don't have time to rebuild. Trunk has fix also.;;;","09/Apr/10 11:04;hamletdrc;great. i will test with the new version. If you don't hear anything then it all worked good for me. ;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"println ""$this"" fails in inner class, but println ''+this works",GROOVY-4151,12815122,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,mlzarathustra,mlzarathustra,05/Apr/10 12:58,17/May/18 16:55,14/Jul/23 06:00,08/Apr/10 08:50,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"{code}
class C {
  class S {
   //  S() { println ""$this"" } // compilation error: unexpected token: this
    S() { println ''+this } // OK
  }
}
{code}","linux, java 1.6",githubbot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 17 16:55:52 UTC 2018,,,,,,,,,,"0|i2bst3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Apr/10 13:15;mlzarathustra;Actually, it doesn't work in a regular class, either.

;;;","05/Apr/10 22:10;roshandawrani;For both regular as well as inner classes, you can use println ""${this}"";;;","05/Apr/10 22:34;roshandawrani;Although I don't really see any real need for it, if we want it, the following patch helps:

{noformat}
Index: src/main/org/codehaus/groovy/antlr/groovy.g
===================================================================
--- src/main/org/codehaus/groovy/antlr/groovy.g	(revision 19756)
+++ src/main/org/codehaus/groovy/antlr/groovy.g	(working copy)
@@ -2854,6 +2854,7 @@
 stringConstructorValuePart
     :
     (   identifier
+    |   ""this"" |   ""super""
     |   openOrClosableBlock
     )
     ;
{noformat}

After the change, the code [def x = 1; println ""$x - $this - $x""] outputs ""1 - Test@ee6681 - 1"" in non-static context and ""1 - class Test - 1"" in static context.;;;","05/Apr/10 23:53;mlzarathustra;It's useful if the class has toString() defined.  

It makes the language inconsistent not to allow it.  That would be my take on it.

Thanks,
  = miles =;;;","06/Apr/10 10:34;guillaume;Also ""${this}"" works.;;;","06/Apr/10 11:05;roshandawrani;Is it worth a change in grammar - to allow ""$this"" - or the workaround ""${this}"" is good enough?;;;","06/Apr/10 12:10;blackdrag;I guess it is ok to make $this work;;;","06/Apr/10 12:47;guillaume;Yes, this and super as you hinted at in our patch are okay.;;;","06/Apr/10 12:50;roshandawrani;Great. Thanks for confirming. I will make the change.;;;","17/May/18 16:55;githubbot;Github user danielsun1106 commented on the pull request:

    https://github.com/apache/groovy/commit/c9eea7c30ececdc0a24939fb780c56c27eec798f#commitcomment-29020550
  
    GROOVY-4151 test has been recovered by https://github.com/apache/groovy/commit/ef2fbe68d25ae7dce57ee2580c975c54e3dbaace
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Timecategory strange format (too many '-' signs) when printing 'negative' date,GROOVY-4147,12815092,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,alpheratz,alpheratz,03/Apr/10 18:23,07/Apr/15 19:13,14/Jul/23 06:00,03/Apr/10 19:14,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.9,1.7.2,1.8-beta-1,,,,,0,,,,,,"{code}
use(groovy.time.TimeCategory) {
  def first = Calendar.instance.time
  Thread.sleep 4200
  def second = Calendar.instance.time
  
  println first - second
}
{code}

When run in GroovyConsole this gives gives:

{code}
-4.-201 seconds
{code}
","win 7 64-bit, 64-bit Java 1.8.0_18",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Apr 03 19:14:23 UTC 2010,,,,,,,,,,"0|i2bmjj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Apr/10 19:14;paulk;fixed - thanks for the issue;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Statically imported fields & properties,GROOVY-4145,12815091,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,mxm-groovy,mxm,03/Apr/10 03:14,17/Jun/15 20:09,14/Jul/23 06:00,04/Apr/10 10:51,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"Create class Foo
{code}
class Foo {
  static foo=2
  static getFoo(){
    return 3
  } 
}
{code}

and a script 
{code}
import static Foo.foo

print foo
{code}

This script calls getter getFoo and prints ""3"".
But if you delete declaration ""static foo=2"" from the class the script fails with MissingPropertyException. 
IMHO the script should call getter in both cases.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4153,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 12 09:16:24 UTC 2010,,,,,,,,,,"0|i2cban:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Apr/10 22:50;paulk;Groovy has never (intentionally) supported
{code}
import static Foo.foo
{code}
as anything other than a shorthand for getting to a {{foo}} field. But as this issue showed, there was an unintentional case where the property rather than the field was used.

Given that there is another issue open about this topic (GROOVY-4153), instead of reopening this one, any further clarifications wrt desired behavior will occur as part of that issue.
;;;","10/Apr/10 01:08;roshandawrani;I thought is was half not-working. Now coming to know that it was half working by mistake.

I assumed that absence of any comments refuting the requirements of this JIRA meant that the requirements were valid. I guess I should have explicitly asked.;;;","10/Apr/10 02:06;paulk;No problems Roshan, no-one picked up the error. Now we have to work out best way forward. Affects GROOVY-3945 too which is even older!

There is nothing inherently wrong with supporting some kind of property shorthand. It just hasn't been covered yet and there are some tricky cases which might make it harder than it looks.;;;","12/Apr/10 09:16;paulk;OK, I added in the property syntax in other places, so the fix shouldn't affect this issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy JDK documentation has mismatch between signatures and explanation,GROOVY-4140,12815135,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,russel,russel,02/Apr/10 05:18,07/Apr/15 19:13,14/Jul/23 06:00,02/Apr/10 19:08,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,The Groovy JDK documentation shows the signatures of the methods but without any variable names for the parameters.  The documentation uses only the variable names so there is no connect between the variables to be provided to teh call and the explanation.  cf the String page of the Groovy JDK documentation.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 02 19:08:38 UTC 2010,,,,,,,,,,"0|i2cljr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Apr/10 09:36;paulk;Thanks for spotting that. They were there until recently.

I think there was a cut and paste glitch while fixing up another issue and no test coverage for the output at the moment.

Should be easy to fix. I'll take a look tomorrow.
;;;","02/Apr/10 19:08;paulk;Fixed. Thanks.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Assigning with empty String as hash key (i.e. a['']=t) yields StringIndexOutOfBoundsException,GROOVY-4139,12815126,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,mlzarathustra,mlzarathustra,02/Apr/10 03:17,07/Apr/10 23:45,14/Jul/23 06:00,02/Apr/10 06:35,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,Groovlet / GSP,,,,0,,,,,,"This is a bizarre one - and I can't always get it to replicate; but where it fails, it ALWAYS fails.  (e.g. in my IDE, it works fine.  In a standalone Tomcat instance, it reliably seems to bomb on two different machines - even though the IDE is using the exact same version of Tomcat.  Seems OK when I run it on the command line - no failure.

The line looks about like this :

topics[id] = t
where id.getClass() is java.lang.String and id==''
t is a complex class, with various fields.
i.e. topics[''] = t

It's the '' that seems to throw it.  (other assignments using non-empty strings work fine).

At the bottom is the stack trace, with the topics['']=t line on the very bottom.  (it goes down further, and I will gladly provide it if needed, but I don't think that part is probably useful).

A few other bizarre details: 

1) after this error occurs (if I catch it and keep going) 'topics' will contain the key/value pair, but groovy will not be able to fetch them by key.  However, by casting 'topics' as a map and going from java (or jsp) I can use topics.get("""") to successfully retrieve the correct value.

2) at this same point (after the error), java can see the entry by enumerating the values; but groovy cannot see the '' when it enumerates the keys (using keySet())

My question is, regarding the below stack trace, why the hell is doing all this crap just to put a value into a hash?  I count 15 stack frames, most of which involve groovy classes.  Shouldn't it just be map.put(key,value) ???

Whatever.  It bombed.

If I find out more, I'll post it here.


[from catalina.out]:------------------------------------

id is ''
GroovyServlet Error:  script: '/index.groovy':  Script processing failed.String index out of range: -1java.lang.String.substring(String.java:1938)
java.lang.StringIndexOutOfBoundsException: String index out of range: -1
        at java.lang.String.substring(String.java:1938)
        at java.lang.String.substring(String.java:1905)
        at org.codehaus.groovy.runtime.MetaClassHelper.capitalize(MetaClassHelper.java:453)
        at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:2312)
        at groovy.lang.MetaClassImpl.setProperty(MetaClassImpl.java:3306)
        at org.codehaus.groovy.runtime.InvokerHelper.setProperty(InvokerHelper.java:183)
        at org.codehaus.groovy.runtime.DefaultGroovyMethods.putAt(DefaultGroovyMethods.java:185)
        at org.codehaus.groovy.runtime.dgm$504.doMethodInvoke(Unknown Source)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1058)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
        at org.codehaus.groovy.runtime.callsite.PojoMetaClassSite.call(PojoMetaClassSite.java:44)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:129)
        at kb.TopList$_refresh_closure1.doCall(TopList.groovy:58)

",SuSE Linux 10 / JDK 1.6 / Tomcat 6.0.20,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 02 05:13:10 UTC 2010,,,,,,,,,,"0|i2c3wn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Apr/10 05:13;roshandawrani;Reproducible using
{code}
use (groovy.time.TimeCategory) {
    topics = [:]
    topics[''] = 1
}
{code};;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy JDK File.eachFileMatch insufficient documentation to use the method.,GROOVY-4138,12815121,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,russel,russel,02/Apr/10 03:09,07/Apr/15 19:13,14/Jul/23 06:00,02/Apr/10 18:49,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,The documentation in the File.eachFilematch entry of the Groovy JDK does not give enough information to make use of the method quickly and easily.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 02 18:49:46 UTC 2010,,,,,,,,,,"0|i2clfb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Apr/10 09:37;paulk;I am thinking even just one simple example embedded in the Javadoc would be enough to make this passable.;;;","02/Apr/10 18:49;paulk;The doc now includes the following examples:
{code}
// collect names of files in baseDir matching supplied regex pattern
import static groovy.io.FileType.*
def names = []
baseDir.eachFileMatch FILES, ~/foo\d\.txt/, { names << it.name }
assert names == ['foo1.txt', 'foo2.txt']

// remove all *.bak files in baseDir
baseDir.eachFileMatch FILES, ~/.*\.bak/, { File bak -> bak.delete() }

// print out files > 4K in size from baseDir
baseDir.eachFileMatch FILES, { new File(baseDir, it).size() > 4096 }, { println ""$it.name ${it.size()}"" }
{code}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Default constructor added by groovy does not have source information set on it,GROOVY-4137,12815115,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,roshandawrani,roshandawrani,01/Apr/10 10:21,07/Apr/10 23:45,14/Jul/23 06:00,01/Apr/10 11:19,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"If no constructor is provided, groovy compiler adds a default constructor, which is public / non-synthetic. This constructor does not have source information set on it.

Java sets the source information of the class on such constructors - e.g., class starting line number.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-04-01 10:21:15.0,,,,,,,,,,"0|i2ct73:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Closure default values cannot be static constants,GROOVY-4134,12815152,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,bodiam,bodiam,31/Mar/10 03:28,07/Apr/10 23:45,14/Jul/23 06:00,31/Mar/10 06:17,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.9,1.7.2,1.8-beta-1,,,,,0,,,,,,"I'd like to use a default value in a closure argument, but at the moment,
it's not working, and I was wondering if the thing I'm trying is not
supported...

This is my code:

Sheet.metaClass.dump = { Integer maxRows = Integer.MAX_VALUE ->

}

Code from Tim Yates:

This works:

def max = Integer.MAX_VALUE
String.metaClass.dump = { Integer maxRows = max ->
  delegate.substring( 0, delegate.length() < maxRows ? delegate.length() : maxRows )
}
assert 'hello'.dump( 2 ) == 'he'
assert 'hello'.dump() == 'hello'

but as you say, putting the Integer.MAX_VALUE in the closure definition throws the MissingPropertyException.
",,tim_yates,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 31 07:14:53 UTC 2010,,,,,,,,,,"0|i2c38n:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"31/Mar/10 03:57;tim_yates;Seems to be similar to GROOVY-1347 but for closures rather than methods;;;","31/Mar/10 04:35;blackdrag;the example works on trunk... somehow this looks familiar... haven't we fixed that already?;;;","31/Mar/10 04:37;roshandawrani;I just fixed it on trunk. Builds on 1.7.x and 1.6.x have not completed yet.;;;","31/Mar/10 05:55;blackdrag;but it worked here without your fix... strange;;;","31/Mar/10 05:57;roshandawrani;I hope you are talking about the first part of the JIRA code here. 2nd part is the workaround Tim suggested. :-)

Anyway, I first reproduced the error and then fixed it.;;;","31/Mar/10 06:00;roshandawrani;Below is what should fail without my current fix (as it does on http://groovyconsole.appspot.com/):

{code}
class Sheet{}

Sheet.metaClass.dump = { Integer maxRows = Integer.MAX_VALUE ->  }

new Sheet().dump()
{code};;;","31/Mar/10 06:02;blackdrag;ah, sorry for the confusion, I had a bug in my test, that made it work.. lol ;;;","31/Mar/10 06:17;roshandawrani;Fixed;;;","31/Mar/10 07:09;paulk;I haven't looked at your fix yet. Does it help with GROOVY-3278?;;;","31/Mar/10 07:14;paulk;OK, just looking, fix only applies to closures. Feel free to look at GROOVY-3278 if you have time. ;-);;;","31/Mar/10 07:14;roshandawrani;I hardly see any overlap between the two issues. So, I guess not - my fix deals just with initial values of closure parameters and has nothing to do with annotations.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Delegate does not handle native methods correctly,GROOVY-4133,12815056,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,roshandawrani,roshandawrani,27/Mar/10 04:43,07/Apr/10 23:45,14/Jul/23 06:00,27/Mar/10 06:01,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.9,1.7.2,1.8-beta-1,,,,,0,,,,,,"{code}
class MyString {
    @Delegate String str
}

assert MyString != null
{code}

The code above fails with the error below
{noformat}
Caught: java.lang.ClassFormatError: Code attribute in native or abstract methods in class file MyString
{noformat}

It happens because String class has a native intern(). The delegate method that @Delegate adds to MyString continues to be marked native and now has code body added to it, which causes the ClassFormatError.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-03-27 04:43:07.0,,,,,,,,,,"0|i2c65b:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler allows 2 main methods in a script,GROOVY-4131,12815058,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,roshandawrani,roshandawrani,26/Mar/10 01:08,07/Apr/10 23:45,14/Jul/23 06:00,26/Mar/10 03:15,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"The code below works fine with groovy. Compiler picks up the 1st main() and ignores the 2nd one. The code should not compiled because it has repetitive methods/

{code}
static main(args) {
    println ""Bar""
}
static main(args) {
    println ""Foo""
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-03-26 01:08:39.0,,,,,,,,,,"0|i2cptr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Using categories results in multiple thread locals being retained that Tomcat has to forcibly clear,GROOVY-4130,12815123,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,ait,graemerocher,graemerocher,25/Mar/10 05:13,21/Jan/16 22:23,14/Jul/23 06:00,10/Jun/10 09:57,1.6.7,1.6.8,1.7.0,1.7.1,1.7-rc-1,1.7-rc-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,1,,,,,,See GRAILS-5823 basically we need a way for frameworks like Grails to clear out the thread locals Groovy uses otherwise Tomcat will forcibly clear them resulting in errors,,marcusb,mecameron,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4177,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 10 09:57:18 UTC 2010,,,,,,,,,,"0|i2bnnz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Apr/10 05:21;guillaume;The Tomcat developers pointed me at their techniques for clearing the threadlocals, and to be frank, it's a bit of a hack, using an empiric approach to getting all the threads, and then using reflection (only working on Sun's VMs) to clear some internal private data structures containing the threadlocals.
If we tried to keep a list of the existing threads where a category was installed is a bit dangerous as well, as we may keep some strong references that would prevent garbage collection as well, so the cure may be more risky than the current situation.;;;","10/Jun/10 09:57;ait;The issue is fixable. We always deal with ThreadLocals in try {} finally {} block, so we can make sure that there is no garbage after we are done.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Implicit 'this' reference not being passed if inner class instance is created in outer class instance initializer,GROOVY-4129,12815086,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,24/Mar/10 05:48,07/Apr/10 23:45,14/Jul/23 06:00,24/Mar/10 08:39,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"{code}
class Test {
    {
        new A()
    }
    class A {}
}
{code}

The code above fails with the following error indicating that the implicit 'this' is not being passed. It should be.
{noformat}
No enclosing instance passed in constructor call of a non-static inner class
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 24 08:39:20 UTC 2010,,,,,,,,,,"0|i2buuf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Mar/10 08:39;roshandawrani;Done;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
deadlock in concurrent calls of GroovyShell.parse method against the same GroovyShell object,GROOVY-4127,12815125,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,giamby,giamby,23/Mar/10 08:51,01/Jun/10 09:49,14/Jul/23 06:00,01/Jun/10 09:49,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,,,,,,,0,,,,,,"Two threads calling GroovyShell.parse from the same GroovyShell instance enter in deadlock (see the stack below).
I'm not sure whether this multi-threaded use is supposed to be supported or not, so feel free to reject it in case GroovyShell is supposed to be used only from one thread or from multiple threads but with explicit synchronization.
Anyway this seems similar to GROOVY-4050



Java stack information for the threads listed above:
===================================================
""pool-4-thread-2"":
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:712)
	- waiting to lock <0x00002aaab42d2a50> (a java.util.HashMap)
	at groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:426)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:773)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
	at java.beans.Introspector.instantiate(Introspector.java:1453)
	at java.beans.Introspector.findExplicitBeanInfo(Introspector.java:425)
	- locked <0x00002aaaaecd26c0> (a java.lang.Class for java.beans.Introspector)
	at java.beans.Introspector.<init>(Introspector.java:374)
	at java.beans.Introspector.getBeanInfo(Introspector.java:168)
	at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:2931)
	at java.security.AccessController.doPrivileged(Native Method)
	at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:2929)
	at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:2912)
	- locked <0x00002aaad57f7700> (a groovy.lang.MetaClassImpl)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:166)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:182)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:211)
	at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:701)
	at groovy.lang.GroovyObjectSupport.<init>(GroovyObjectSupport.java:32)
	at groovy.lang.Script.<init>(Script.java:40)
	at groovy.lang.Script.<init>(Script.java:37)
	at Script288.<init>(Script288.groovy)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at java.lang.Class.newInstance0(Class.java:355)
	at java.lang.Class.newInstance(Class.java:308)
	at org.codehaus.groovy.runtime.InvokerHelper.createScript(InvokerHelper.java:400)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:739)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:766)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:757)
	at com.iontrading.punit.itdb.c.<init>(SupplyProcessorUnit.java:68)
	at com.iontrading.punit.itdb.a.<init>(SupplyProcessorUnit.java:162)
	at com.iontrading.punit.itdb.SupplyProcessorUnit.processUpdate(SupplyProcessorUnit.java:266)
	at com.iontrading.punit.core.PUnitBase.notifySinks(PUnitBase.java:83)
	at com.iontrading.punit.jdbc.JDBCQueryUnit.notifySinks(JDBCQueryUnit.java:744)
	at com.iontrading.punit.jdbc.JDBCQueryUnit$a.run(JDBCQueryUnit.java:493)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:619)
""pool-6-thread-1"":
	at java.beans.Introspector.getPublicDeclaredMethods(Introspector.java:1271)
	- waiting to lock <0x00002aaaaecd26c0> (a java.lang.Class for java.beans.Introspector)
	at java.beans.Introspector.internalFindMethod(Introspector.java:1321)
	at java.beans.Introspector.findMethod(Introspector.java:1392)
	at java.beans.Introspector.findMethod(Introspector.java:1372)
	at java.beans.PropertyDescriptor.getReadMethod(PropertyDescriptor.java:179)
	- locked <0x00002aaab4279358> (a java.beans.PropertyDescriptor)
	at groovy.lang.MetaClassImpl.applyPropertyDescriptors(MetaClassImpl.java:2209)
	at groovy.lang.MetaClassImpl.setupProperties(MetaClassImpl.java:1993)
	at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:2941)
	at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:2912)
	- locked <0x00002aaad58d5290> (a groovy.lang.MetaClassImpl)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:166)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:195)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:215)
	at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:697)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createPojoSite(CallSiteArray.java:107)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:148)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:54)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at org.codehaus.groovy.ast.builder.AstBuilderInvocationTrap.visitMethodCallExpression(AstBuilderTransformation.groovy:177)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:67)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoCachedMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:229)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callSafe(AbstractCallSite.java:90)
	at org.codehaus.groovy.ast.builder.AstBuilderTransformation.visit(AstBuilderTransformation.groovy:57)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$3.call(ASTTransformationVisitor.java:303)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:845)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:521)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:497)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:474)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:292)
	- locked <0x00002aaab42d2a50> (a java.util.HashMap)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:727)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:739)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:766)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:757)
	at com.iontrading.punit.itdb.c.<init>(SupplyProcessorUnit.java:68)
	at com.iontrading.punit.itdb.a.<init>(SupplyProcessorUnit.java:162)
	at com.iontrading.punit.itdb.SupplyProcessorUnit.processUpdate(SupplyProcessorUnit.java:266)
	at com.iontrading.punit.core.PUnitBase.notifySinks(PUnitBase.java:83)
	at com.iontrading.punit.jdbc.JDBCQueryUnit.notifySinks(JDBCQueryUnit.java:744)
	at com.iontrading.punit.jdbc.JDBCQueryUnit$a.run(JDBCQueryUnit.java:493)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:619)",,anttip,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4050,GROOVY-4002,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 01 09:49:14 UTC 2010,,,,,,,,,,"0|i2c6x3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Mar/10 09:38;guillaume;Indeed looks like the same problem (and stacktrace);;;","23/Mar/10 11:06;guillaume;Till we properly support parallel compilation (which is not yet supported), you'd better either use a GroovyShell and/or GroovyClassLoader per thread, or synchronize on the shared one, to avoid such issues.;;;","05/Apr/10 13:31;anttip;The locking patterns on issues GROOVY-4050 and GROOVY-4127 look very similar to GROOVY-4002. I've just attached a test case and a suggested patch for GROOVY-4002.

hm.. looking at the comment on parallel compilation not yet being supported, I'm thinking that there's more to it than I thought. I thought parallel compilation was working, and this locking issue was just a minor bug in it. GroovyServlet seems to assume that parallel compilation is working.;;;","01/Jun/10 09:49;guillaume;Duplicate of GROOVY-4002;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler fails to do assignment-to-final-fields checks on fields made final by @Immutable (was: @Immutable does not make fields immutable),GROOVY-4121,12815055,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,roshandawrani,johanneslink,johanneslink,22/Mar/10 05:55,07/Apr/10 23:45,14/Jul/23 06:00,23/Mar/10 03:49,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"@Immutable annotation does not prevent changing fields:
{code}
@Immutable
class Account {
    BigDecimal balance
    String customer
    
    Account deposit(amount) {
        balance = balance + amount
        this
    }
    
    String toString() {
        ""Account[balance: $balance, customer: $customer]""   
    }
}

def acc = new Account(0.0, ""Test"")
acc.deposit(3.1) //should raise exception, shouldn't it?
assert 3.1 == acc.balance 
{code}

Maybe I got the description in http://groovy.codehaus.org/api/groovy/lang/Immutable.html wrong:
""Properties automatically have private, final backing fields with getters. Attempts to update the property will result in a ReadOnlyPropertyException."" ?","osx, groovyConsole",johanneslink,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"22/Mar/10 12:24;roshandawrani;4121_v18x_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722313/4121_v18x_Patch.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 23 03:49:15 UTC 2010,,,,,,,,,,"0|i2cf9z:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"22/Mar/10 05:58;johanneslink;A newline got lost in the deposit-method of my test case (sorry). Should read:
Account deposit(amount) { 
  balance = balance + amount; 
  this 
};;;","22/Mar/10 10:02;roshandawrani;Applied code tags.;;;","22/Mar/10 10:09;roshandawrani;The documentation may need a little update but I think the idea is that you want to write an immutable class to save it from changes from outside (acc.balance = 1.0 does throw ReadOnlyPropertyException). If the class itself decides to break its own immutability, then @Immutable does not prevent it from doing so.

Another way of a class breaking its own immutability is providing an explicit setter for the property, as mentioned in the @Immutable documentation:

{noformat}
You don't have to follow Groovy's normal property conventions, e.g. you can 
create an explicit private field and then you can write explicit get and set methods. 
Such an approach, isn't currently prohibited (to give you some wiggle room to get 
around these conventions) but any fields created in this way are deemed not 
to be part of the significant state of the object and aren't factored 
into the equals  or hashCode methods. Use at your own risk! 
{noformat}

@Immutable needs the support of good intentions of the class author :-);;;","22/Mar/10 10:40;johanneslink;Does that mean that fields don't get the ""final"" modifier automatically added during AST transformation? But without the final modifier you won't get the guarantees from the Java memory model as for thread-safe publication of immutable objects. In other words: Many @Immutable examples presented on the web and on conferences would be wrong then. 

Moreover http://groovy.codehaus.org/Immutable+AST+Macro would also be wrong;;;","22/Mar/10 10:59;roshandawrani;The @Immutable does make the field final and the compiler should reject the code ""balance = balance + amount""

There is some ordering issue within the compiler. @Immutable AST transformation happens after the compiler has made its usual checks to see if final fields are being assigned to and that's why the compiler fails to reject the assignment ""balance = balance + amount"".;;;","22/Mar/10 11:02;roshandawrani;Jochen, u there?

Do you think the check VariableScopeVisitor#checkFinalFieldAccess() can be moved to a later point in compilation - to the Verifier, may be?;;;","22/Mar/10 12:24;roshandawrani;Attaching the patch for review. 

It pushes the checkFinalFieldAccess from VariableScopeVisitor (resolve) to ClassCompletionVerifier (classgen) so that it now also covers the fields made final by ImmutableASTTransformation.;;;","22/Mar/10 12:28;roshandawrani;After the patch, the example provided above fails with the compilation error ""cannot modify final field 'balance' outside of constructor"";;;","23/Mar/10 01:39;paulk;+1 from me - perhaps title of issue is no longer accurate?;;;","23/Mar/10 03:49;roshandawrani;Fixed.

Johannes, sorry about the partially incorrect comment early on.

Thanks for the patch feedback, Paul.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Non static inner class usage fails with MethodSelectionException,GROOVY-4120,12815023,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,22/Mar/10 03:11,07/Apr/10 23:45,14/Jul/23 06:00,22/Mar/10 04:54,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,class generator,,,,0,,,,,,"{code}
class Test {
    static main(args) {
        new A()
    }
    class A {
        def A() {}
        def A(num){}
    }
}
{code}

The above code fails with the following error
{noformat}
Caught: org.codehaus.groovy.runtime.metaclass.MethodSelectionException: Could not find which method <init>() to invoke from this list:
  public Test$A#<init>(Test, java.lang.Object)
  public Test$A#<init>(Test)
	at Test.main(Try.groovy:3)
{noformat}

I think it is happening because the inner class is non-static and no enclosing ""this"" instance is being passed to it. The compiler should enforce it at compile time instead of letting it get compiled and fail at runtime.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-03-22 03:11:03.0,,,,,,,,,,"0|i2c92v:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Implicit construtor call fails with NoSuchMethodError when an inner class extends another,GROOVY-4119,12815062,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,roshandawrani,roshandawrani,21/Mar/10 11:24,23/Jun/10 15:45,14/Jul/23 06:00,09/May/10 02:12,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,class generator,,,,0,,,,,,"{code}
class Test {
    static main(args) {
        new Test().foo()
    }
    void foo() {
        new B()
    }
    class A {}
    class B extends A {}
}
{code}

Running the above code results in the following error
{noformat}
Caught: java.lang.NoSuchMethodError: Test$A: method <init>()V not found
	at Test$B.<init>(Try.groovy)
	at Test.foo(Try.groovy:6)
	at Test.main(Try.groovy:3)
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 09 02:12:52 UTC 2010,,,,,,,,,,"0|i2bwzb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/May/10 02:12;roshandawrani;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
JavaStubGenerator doesn't generate annotations available in Groovy code,GROOVY-4118,12818392,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,genie,genie,20/Mar/10 15:48,06/Sep/10 08:49,14/Jul/23 06:00,16/Jun/10 09:31,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,class generator,,,,0,,,,,,"Looking at org.codehaus.groovy.tools.javac.JavaStubGenerator (http://goo.gl/ob23) I see it doesn't generate annotations that are originally available in Groovy sources.

I think it causes those issues later:
* http://jira.codehaus.org/browse/GMAVEN-68 - ""GMaven: generateStubs generates stubs without original Javadocs or annotations""
* http://jira.codehaus.org/browse/GMAVEN-4  - ""GMaven: Stub generation should generate annotations""

I'm trying to use AnnoMojo annotations (http://goo.gl/rbRw) when developing my MOJOs in Groovy.
GMaven's ""generateStubs"" goal doesn't produce Java sources with original AnnoMojo annotations",,gregfqt,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/Jun/10 23:36;paulk;groovy4118_JavaStubGenerator_annotations.patch;https://issues.apache.org/jira/secure/attachment/12722514/groovy4118_JavaStubGenerator_annotations.patch","09/Jun/10 00:05;paulk;groovy4118_JavaStubGenerator_annotations_B.patch;https://issues.apache.org/jira/secure/attachment/12722562/groovy4118_JavaStubGenerator_annotations_B.patch",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 06 08:49:17 UTC 2010,,,,,,,,,,"0|i2c6sv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jun/10 23:36;paulk;Potential patch;;;","06/Jun/10 23:38;paulk;Jochen, let me know if there are any issues with patch otherwise I will apply in a few days.;;;","07/Jun/10 02:10;blackdrag;the patch seems to be only allowing for numbers and constants that are ten interpreted as String. Missing are classes and enums (both clear name, the same as for numbers);;;","07/Jun/10 02:11;blackdrag;ah yes... another part would be to print the annotations only if the ""java5"" field is true.;;;","07/Jun/10 05:36;paulk;Yes, both very good points. I might have to leave those changes and some kind of test to someone else unless I get a good Internet connection in San Fran and get time to look again.;;;","09/Jun/10 00:05;paulk;revised patch addressing Jochen's raised points;;;","10/Jun/10 13:44;paulk;So the one thing that I am still unsure of is whether we need to add back in the default imports which I commented out in genImports a few weeks back - everything else is fully qualified but I don't that is the case with Annotation constants.;;;","11/Jun/10 03:21;blackdrag;If the fully qualified class name would be used, then there is no need for an annotaton. Since there seems to be a class resolving phase I think that it is not needed;;;","14/Jun/10 01:45;paulk;For the Resolving Phase to occur before we print out the Java stub annotation info, I moved the stubGenerator visitor from CONVERSION to SEMANTIC_ANALYSIS phase. I still need to create a bunch of tests covering all of the cases.;;;","14/Jun/10 01:52;paulk;A quick check for import aliasing was also added. Again tests pending but works locally for me for the testcase given in GMAVEN-75.;;;","14/Jun/10 11:34;guillaume;Paul made some changes in this area, please reopen the issue if it's still not working as expected.;;;","16/Jun/10 06:22;genie;Just tried it with Groovy 1.7.3.
Annotations put on properties are not generated.

*{{""src/main/scripts/com/clearforest/plugins/springbatch/SpringBatchMojo.groovy""}}*:

{code}
package com.clearforest.plugins.springbatch

import org.jfrog.maven.annomojo.annotations.MojoPhase
import org.jfrog.maven.annomojo.annotations.MojoGoal
import org.codehaus.gmaven.mojo.GroovyMojo
import org.jfrog.maven.annomojo.annotations.MojoParameter

/**
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * Spring Batch invoker
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 */
@MojoGoal( ""run"" )
@MojoPhase( ""install"" )
class SpringBatchMojo extends GroovyMojo
{

    @MojoParameter ( required = true )
    String sth

    void execute ()
    {
        System.out.println( ""[[[[[[[[$sth]]]]]]]]]]]"" );
    }
}
{code}

generates the following code at *{{""target/generated-sources/groovy-stubs/main/com/clearforest/plugins/springbatch/SpringBatchMojo.java""}}*:

{code}
package com.clearforest.plugins.springbatch;

import org.jfrog.maven.annomojo.annotations.MojoGoal;
import org.codehaus.gmaven.mojo.GroovyMojo;
import org.jfrog.maven.annomojo.annotations.MojoParameter;
import org.jfrog.maven.annomojo.annotations.MojoPhase;

@MojoGoal(value=""run"") @MojoPhase(value=""install"") public class SpringBatchMojo
  extends org.codehaus.gmaven.mojo.GroovyMojo  implements
    groovy.lang.GroovyObject {
public SpringBatchMojo
() {}
public  groovy.lang.MetaClass getMetaClass() { return (groovy.lang.MetaClass)null;}
public  void setMetaClass(groovy.lang.MetaClass mc) { }
public  java.lang.Object invokeMethod(java.lang.String method, java.lang.Object arguments) { return null;}
public  java.lang.Object getProperty(java.lang.String property) { return null;}
public  void setProperty(java.lang.String property, java.lang.Object value) { }
public  String getSth() { return (String)null;}
public  void setSth(String value) { }
public  void execute() { }
protected  groovy.lang.MetaClass $getStaticMetaClass() { return (groovy.lang.MetaClass)null;}
}
{code}

*{{@MojoParameter}}* annotation isn't generated;;;","16/Jun/10 06:27;guillaume;By the way, note that sth is not a field, but a property.;;;","16/Jun/10 06:40;genie;Yeah, right, I mean properties, sorry;;;","16/Jun/10 07:34;roshandawrani;So, how do we handle properties here? Normally the stub generator doesn't print-out the private fields. A property becomes (a private field + getter/setter methods).

In properties case, do we start printing out the code for wrapped private fields also?

Not sure if it will make sense to print the annotation provided on the property on the getter/setter methods.;;;","16/Jun/10 07:49;genie;My use case are Groovy MOJOs and I try to use AnnoMojo (http://goo.gl/rbRw) for Java5 annotations. 
That's the reason for annotation properties, they become plugin configurations later;;;","16/Jun/10 07:59;roshandawrani;Don't know about MOJOs. So, a question.

From your use case point of view, if ""String sth"" internally becomes ""private String sth + public getSth()/setSth()"" - will it help for the plugin configuration later if the annotation remained on the private field or moved on to accessor methods?;;;","16/Jun/10 08:06;roshandawrani;Not sure whether it's an option for you or not, but a change from
{code}
@MojoParameter ( required = true )
String sth
{code}
to
{code}
@MojoParameter ( required = true )
public String sth
{code}
will make sure that you get the following in the output
{code}
@org.jfrog.maven.annomojo.annotations.MojoParameter(required=true) public java.lang.String sth;
{code}
;;;","16/Jun/10 09:08;genie;Yeap! It worked. Thanks a lot :));;;","16/Jun/10 09:10;genie;Is this requirement for ""public"" modifier is something that I'll always need to use or it may be relaxed in the following versions?;;;","16/Jun/10 09:10;roshandawrani;So, shall we close it back? :-);;;","16/Jun/10 09:18;roshandawrani;Instead of a direct answer, there are a few indirect things there to be told:

1) ""String sth"" is a property in groovy code that gets changed internally to ""private String sth + getSth()/setSth()""

2) ""public String sth"" is a field in groovy code and it remains unchanged as a field.

3) Stub generators currently generates annotations only for non-private fields and not for properties.

Going forward:

4) The stub generator may start doing something for properties as well - not sure at this point what that will be - whether the annotation will go on to stick to private field or accessors.

5) It is highly unlikely that property ""String sth"" will later translate to ""public String sth"" field instead of (private field + accessors).;;;","16/Jun/10 09:25;genie;Ok, I see, thanks for the explanation. In this case the issue can be closed again, I suppose. 
I've just updated 3 of our Maven plugins to use AnnoMojo annotations instead of Javadoc ones, we'll see in a couple of days if everything is Ok.
But from what I saw, the generation works Ok now .. 

Many thanks again. We were waiting for a long time to make this switch.;;;","16/Jun/10 09:31;roshandawrani;You are welcome. Forwarding ""many thanks"" to Paul for the original implementation :-);;;","23/Aug/10 10:33;gfouquet;It seems to me annotation properties of array type are still not handled correctly. For example, with Groovy 1.7.3 and 1.7.4 :
{code}
// ArrayAnnotation.java
public @interface ArrayAnnotation {
String[] value() default {};
}

// AnnotatedClass.groovy
@ArrayAnnotation([""foo"", ""bar""])
class AnnotatedClass { }
{code}
generates the stub : 
{code}
@ArrayAnnotation(value=null)
public class AnnotatedClass extends java.lang.Object implements groovy.lang.GroovyObject {
// irrelevent stuff removed
}
{code}
;;;","23/Aug/10 16:59;paulk;Yes, there are a few known limitations of the current stub generator - one of them being that we can't easily resolve constant expressions for the general case (at least not without significant overheads) and we handle constant-looking things as best we can by hand-coded ""sniffing"" of such expressions - and arrays/lists are not in the list of what we currently look for - but could be.

Does the above cause you particular problems? Obviously the real constants will be in the Groovy byte code just not in the stubs which are only short-lived.

In any case, probably worth a new issue to handle arrays/lists as that may not be too hard.;;;","24/Aug/10 07:48;gfouquet;You are right, it turns out I can successfully deactivate stub generation for the offending classes (they are unit tests). Thanks for your insight.

Shall I file a new issue anyway ?;;;","24/Aug/10 16:48;paulk;Might be good to add. We can always close it if there is no interest or problems arise in solving it easily.;;;","06/Sep/10 08:49;gfouquet;With some delay, I opened issue GROOVY-4394;;;",,,,,,,,,,,,,,,,
org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl#registerMethods should not call System.exit,GROOVY-4117,12815140,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,roshandawrani,hucmuc,hucmuc,20/Mar/10 11:14,07/Apr/10 23:45,14/Jul/23 06:00,21/Mar/10 07:46,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"After an unexpected exit from our app, I saw that org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl#registerMethods has an System.exit routine.

We are using groovy from within our Java application. It actually killed our app due to a configuration issue.

The groovy engine should throw an exception not System.exit.

I suggest to review all System.exit calls and replace them with throwing an exception.",,hucmuc,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Mar 21 07:46:15 UTC 2010,,,,,,,,,,"0|i2bxt3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Mar/10 11:15;hucmuc;The title should be : org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl#registerMethods should NOT call System.exit;;;","20/Mar/10 11:58;hucmuc;Also it called System.exit(0) indicating that it is a clean exit which it is not. 

My suggestion to anyone integrating this groovy library to install their own security manager and override the checkExit method. ;;;","20/Mar/10 12:31;roshandawrani;Corrected the issue title as noted in the comment.;;;","20/Mar/10 12:41;roshandawrani;One more place from where System.exit() should be replaced by an exception is org.codehaus.groovy.reflection.GeneratedMetaMethod.Proxy#createProxy().

Anyone sees any issue with replacement of these 2 instances by throwing an exception?;;;","21/Mar/10 03:44;paulk;+1 for both cases;;;","21/Mar/10 07:46;roshandawrani;Done;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Call to an interface method results in IllegalAccessError when not implemented as ""public""",GROOVY-4116,12815031,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,roshandawrani,roshandawrani,20/Mar/10 07:31,07/Apr/10 23:45,14/Jul/23 06:00,20/Mar/10 12:17,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"{code}
class C implements I {
    protected foo() {}
}

interface I {
    def foo()
}

def c = new C()
c.foo()
{code}

The code above results in the error below
{noformat}
Caught: java.lang.IllegalAccessError: C.foo()Ljava/lang/Object;
	at Try.run(Try.groovy:10)
{noformat}

If the interface methods are not implemented with public visibility, the compiler should crib.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-03-20 07:31:16.0,,,,,,,,,,"0|i2cqf3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Joint compilation fails if Groovy method with array parameter is called in vararg style from Java,GROOVY-4112,12815030,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pniederw,pniederw,19/Mar/10 16:49,21/Jul/11 19:06,14/Jul/23 06:00,30/Jun/11 08:13,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.11,1.8.1,,Compiler,,,,0,,,,,,"Foo.groovy:
{code}
class Foo {
  static foo(String[] args) {}
}
{code}

Bar.java:
{code}
public class Bar {
  public static void main(String[] args) {
    Foo.foo(""one"", ""two"", ""three"");
  }
}
{code}

This compiles fine separately, but with joint compilation I get:

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Compile error during compilation with javac.
Bar.java:3: foo(java.lang.String[]) in Foo cannot be applied to (java.lang.String,java.lang.String,java.lang.String)
		Foo.foo(""a"", ""b"", ""c"");
		       ^
1 error
{noformat}

I suppose stub generation is to blame.
",,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 30 08:13:43 UTC 2011,,,,,,,,,,"0|i2c4v3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Jun/11 08:13;paulk;Java stubs now have vararg looking types if the last parameter's type is an array. Any additional testing you can do would be gaeatly appreciated.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Possible NPE in Groovy Ant task,GROOVY-4108,12815132,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,,17/Mar/10 23:29,07/Apr/15 19:12,14/Jul/23 06:00,17/Mar/10 23:33,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,Ant integration,,,,0,,,,,,In Groovy#createClasspathParts() there is a call to getSysProperties().getVariables() which according to the Ant JavaDoc can return null but we don't check for that case.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-03-17 23:29:41.0,,,,,,,,,,"0|i2cp9z:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ResolveVisitor falsely resolves an import against itself,GROOVY-4107,12815139,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,17/Mar/10 11:58,14/Aug/13 03:57,14/Jul/23 06:00,17/Mar/10 13:46,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"ResolveVisitor seems to be resolving an unqualified import against itself by mistake.

The following code should fail with a ""Unable to resolve class Test"" error, but due to the ResolveVisitor bug, it reaches ACG and then fails.

{code}
import Test

Test.foo()
{code}

It is failing with the following message:
{noformat}
Caught: BUG! exception in phase 'class generation' in source unit 'D:\Roshan\GroovyDevSetup\Workspace18x\Try18X\src\Try.groovy' ClassNode#getTypeClass for Roshan is called before the type class is set 
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4149,GROOVY-4128,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 23 21:24:31 UTC 2010,,,,,,,,,,"0|i2by4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Mar/10 13:46;roshandawrani;Fixed;;;","23/Mar/10 21:24;roshandawrani;Corrected typos :-);;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ExpandoMetaClassCreationHandle does infinite recursion for ExpandoMetaClass,GROOVY-4106,12815130,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,roshandawrani,misterd,misterd,16/Mar/10 14:38,05/Apr/15 14:44,14/Jul/23 06:00,17/Mar/10 09:10,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.9,1.7.2,1.8-beta-1,,,,,0,,,,,,"in ExpandoMetaClassCreationHandle line 49 (else clause in createNormalMetaClass(Class,MetaClassRegistry)), there is a call
{code}super.create(theClass, registry){code}
which should be replaced by a call
{code}super.createNormalMetaClass(theClass, registry){code}
since, if createNormalMetaClass is invoked, this call came from super.create. Thus the call to super.create(..) creates infinite recursion.

This occurs for example when executing code like this:
{code}
MetaClassCreationHandle handle = new ExpandoMetaClassCreationHandle();
println handle.create(ExpandoMetaClass, GroovySystem.getMetaClassRegistry());
{code}
",any,misterd,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Wed Mar 17 09:10:30 UTC 2010,,,,,,,,,,"0|i2bstj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"17/Mar/10 09:10;roshandawrani;Done;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MethodClosure for a protected method in a super class not working properly,GROOVY-4104,12815136,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,cdanielw,cdanielw,16/Mar/10 04:34,07/Apr/10 23:45,14/Jul/23 06:00,17/Mar/10 06:53,1.6.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.9,1.7.2,1.8-beta-1,,,,,0,,,,,,"The below java code outputs 1 and 0

{code:title=A.java}
public class A {
    public MethodClosure createMethodClosure() {
        return new MethodClosure(this, ""someMethod"");
    }

    protected void someMethod(int someParameter) {}
}
{code}
{code:title=B.java}
public class B extends A {
}
{code}
{code:title=Test.java}
public class Test {
    public static void main(String[] args) {
        System.out.println(new A().createMethodClosure().getMaximumNumberOfParameters());
        System.out.println(new B().createMethodClosure().getMaximumNumberOfParameters());
    }
}
{code}",,cdanielw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 17 06:53:12 UTC 2010,,,,,,,,,,"0|i2celr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Mar/10 06:53;roshandawrani;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
remove timestamp fields for better hotswap,GROOVY-4102,12815134,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,stephen.friedrich,stephen.friedrich,12/Mar/10 16:42,17/Dec/14 13:25,14/Jul/23 06:00,06/Nov/14 14:08,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.0-beta-4,,,bytecode,,,,3,,,,,,"While debugging I try to hot swap a groovy class.
It always fails with messages ""Schema change not implemented. Operation not supported by VM"".

With Java classes there is no such problem - hot swap works as long as I don't add/remove any field or method or change a method signature.

I had hoped to gradually convert my Java app to groovy, but this made me refrain from using groovy for anything more complex than ""java"" beans.

Looking at the bytecode with javap, it is obvious where the problem is:
There is an artifical  field that changes its name on each compilation.
Initial:
   public static java.lang.Long __timeStamp__239_neverHappen1268432715287;
After recompilation:
   public static java.lang.Long __timeStamp__239_neverHappen1268433121889;

What is this field used for? Can't we get rid of it?
All other fields/methods look the same after recompilation, so I am pretty sure that hot swap will work without this field change.
",,aclement,cameronbraid,pschumacher,stephen.friedrich,windchiller,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5390,GROOVY-6308,,,,,,,,,,,,,,,,,,"18/Jul/11 15:31;blackdrag;timestamp.patch;https://issues.apache.org/jira/secure/attachment/12722894/timestamp.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 06 14:08:56 UTC 2014,,,,,,,,,,"0|i2copz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Apr/10 19:34;aclement;Groovy-Eclipse no longer produces the timestamp fields (to facilitate hotswap), but I would like to see a change in groovy to remove them (or make their creation optional) so that I didn't need a private change in groovy-eclipse.

Stephen - although you will then be able to replace them without seeing the schema changed error, you are unlikely to get the experience you expect.

Due to call site caching you won't usually pickup any changes you make to the methods that are invoked (you'll need to use something like the agent described here to get these changes picked up: http://andrewclement.blogspot.com/2010/03/groovy-eclipse-groovy-hotswap-support.html )

Also, due to local variable assignments becoming constants that get set in the static initializer (see GROOVY-4152), you won't see any changes you make to those local variables after a hotswap.;;;","09/Apr/10 01:17;stephen.friedrich;Thanks, I am already a happy user of the IntelliJ IDEA plugin that integrates that agent into the IDE.;;;","17/Jul/11 13:39;blackdrag;Since GROOVY-4152 is closed and since an agent was mentioned... is this issue still to be kept open?;;;","18/Jul/11 11:06;aclement;I'd probably still vote for removing the timestamps unless there is a very good reason to keep them.

My agent was updated to call the method outlined in 4152 (download link in comments here: http://andrewclement.blogspot.com/2010/03/groovy-eclipse-groovy-hotswap-support.html). I think we're going to always have to use something like that (an agent) in order for hotswapping to work reasonably for groovy code.;;;","18/Jul/11 15:31;blackdrag;An solution idea is to let Groovy, defined by an option, for the command line compiler generated classes with equal timestamps. This way hotswapping would have no problem with changed values and changed field names. If eclipse uses the same configuration option. I think it would not limit the eclipse usage.

The patch I am attaching is not a solution, because it does strangely not pass all tests. ;;;","03/Sep/14 14:43;pschumacher;Can this be closed due to [GROOVY-6990: Do not add timestamp fields if possible|https://github.com/groovy/groovy-core/pull/499]?;;;","06/Nov/14 14:08;pschumacher;CÃ©dric removed the generation of timestamp fields with [GROOVY-6990: Do not add timestamp fields if possible|https://github.com/groovy/groovy-core/pull/499], so I'm resolving this issue.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
clearTime() fails for times in the afternoon,GROOVY-4100,12815760,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,gconboy,gconboy,12/Mar/10 08:11,07/Apr/15 19:12,14/Jul/23 06:00,12/Mar/10 15:37,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.9,1.7.2,1.8-beta-1,groovy-jdk,,,,0,,,,,,"Calendar.clearTime() fails if the time part of the date is in the afternoon.

The gdk seems to be doing:
{code}
self.clear(Calendar.HOUR_OF_DAY);
self.clear(Calendar.HOUR);
{code}

I think that second line is unnecessary and breaking things.

Some test code:
{code}
// clearTime works for times in the morning
def morning = GregorianCalendar.getInstance()
morning.set(Calendar.AM_PM, Calendar.AM)
morning.clearTime()
assert morning.get(Calendar.HOUR_OF_DAY) == 0

// clearTime fails for times in the afternoon
def afternoon = GregorianCalendar.getInstance()
afternoon.set(Calendar.AM_PM, Calendar.PM)
afternoon.clearTime()
assert afternoon.get(Calendar.HOUR_OF_DAY) == 0  // fails in Groovy 1.7.1
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 29 17:19:36 UTC 2010,,,,,,,,,,"0|i2cd7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Mar/10 15:37;paulk;The javadoc says to use {{set(Calendar.HOUR_OF_DAY, 0)}} for that case. Seems to work in my testing. Changed.;;;","29/Mar/10 16:13;kons;Can you please port this fix to the 1.6.x branch too?
Grails 1.2.2 recently updated to Groovy 1.6.8 which contains this feature (and now defect) as well.  I wouldn't expect Grails to be using 1.7 as quickly as they could a 1.6 update;;;","29/Mar/10 17:19;paulk;Merged onto 1_6_X branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Immutable annotation does not allow untyped static fields,GROOVY-4099,12815141,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,marcusb,marcusb,11/Mar/10 10:42,07/Apr/10 23:45,14/Jul/23 06:00,11/Mar/10 23:29,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"I cannot compile a class with @Immutable if it has a static field declared with def. I don't think the transform should touch static fields.

{code}
~$ cat ImmutableTest.groovy
@Immutable                                 
class ImmutableTest {                      
  static foo = {}                          
}                                          
marcus@better:~$ groovyc ImmutableTest.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during canonicalization: @Immutable processor doesn't know how to handle field 'foo' of type 'java.lang.Object or def' while compiling class ImmutableTest.                                                                         
@Immutable classes currently only support properties with known immutable types or types where special handling achieves immutable behavior, including:                                                                                           
- Strings, primitive types, wrapper types, BigInteger and BigDecimal                                                     
- enums, other @Immutable classes and known immutables (java.awt.Color)                                                  
- Cloneable classes, collections, maps and arrays, and other classes with special handling (java.util.Date)              
Other restrictions apply, please see the groovydoc for @Immutable for further details                                    

java.lang.RuntimeException: @Immutable processor doesn't know how to handle field 'foo' of type 'java.lang.Object or def' while compiling class ImmutableTest.                                                                                    
@Immutable classes currently only support properties with known immutable types or types where special handling achieves immutable behavior, including:                                                                                           
- Strings, primitive types, wrapper types, BigInteger and BigDecimal
- enums, other @Immutable classes and known immutables (java.awt.Color)
- Cloneable classes, collections, maps and arrays, and other classes with special handling (java.util.Date)
Other restrictions apply, please see the groovydoc for @Immutable for further details
        at org.codehaus.groovy.transform.ImmutableASTTransformation.createConstructorStatement(ImmutableASTTransformation.java:373)
        at org.codehaus.groovy.transform.ImmutableASTTransformation.createConstructorMap(ImmutableASTTransformation.java:324)
        at org.codehaus.groovy.transform.ImmutableASTTransformation.createConstructor(ImmutableASTTransformation.java:310)
        at org.codehaus.groovy.transform.ImmutableASTTransformation.visit(ImmutableASTTransformation.java:113)
        at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:129)
        at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:173)
        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:957)
        at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:517)
        at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:495)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:472)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:456)
        at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:57)
        at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:170)
        at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:138)
        at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:152)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:616)
        at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:108)
        at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:130)

1 error
{code}
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Mar/10 10:42;marcusb;ImmutableTest.groovy;https://issues.apache.org/jira/secure/attachment/12722264/ImmutableTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 12 06:09:43 UTC 2010,,,,,,,,,,"0|i2c4s7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Mar/10 20:52;roshandawrani;It's not really related to field being static. Even untyped instance level fields are rejected:

{code}
@Immutable                                 
class ImmutableTest {                      
  def x = """"                          
} 
{code}

@Immutable's documentation says ""Fields that are enums or other @Immutable classes are allowed but for an otherwise possible mutable property type, an error is thrown."". So the behavior, to me, seems in line with the documentation.;;;","11/Mar/10 23:06;paulk;Statics are usually a bad idea for Immutable objects, e.g. consider this example:
{code}
@Immutable class Person {
   String first, last
   static species = 'Human'
   String getFullname() {
     ""$first $last""
   }
   String getDescription() {
     ""$fullname is a $species""
   }
}

def spock = new Person('Leonard', 'Nimoy')
assert spock.species == 'Human'
assert spock.fullname == 'Leonard Nimoy'
assert spock.description == 'Leonard Nimoy is a Human'

spock.species = 'Romulan'
assert spock.species == 'Romulan'

Person.species = 'Vulcan'
assert spock.species == 'Vulcan'
assert spock.fullname == 'Leonard Nimoy'
assert spock.description == 'Leonard Nimoy is a Vulcan'
{code}
Normally for an immutable object you typically expect method calls to be idempotent. In this context, by that I mean that I can call any of the methods of a Person instance multiple times and I should get the same result. E.g. no matter how many times I call {{getFullname()}} it always yields the same value. Code which is dealing with such objects can get away with caching results (if it wanted to) assuming this characteristic. As can be seen above, calls to {{getDescription()}} yields changing results because of the static property. Code assuming idempotency could yield subtle bugs.

Having said that, in the spirit of the design of {{@Immutable}}, it isn't fully locking the objects down to be immutable, just providing a framework to make it easy for you to do the right thing. So, it makes sense for the annotation to allow but not touch (as you point out) static properties.

Just for the record, I do deem the above to be bad design. Decide whether 'species' is part of your domain object or not. If it is, add it in as a normal property. If not, remove it. Place it in some kind of system Species class.;;;","11/Mar/10 23:19;paulk;The alternative would be to ban statics altogether (perhaps allowing just final initialized values) which is somewhat attractive but I suspect too restrictive. We could provide an optional flag to turn on a strict mode in the future which might turn this on.
;;;","11/Mar/10 23:29;paulk;Added. Design and javadoc changed to not consider static properties.;;;","12/Mar/10 02:54;marcusb;FYI my use-case was a domain class in Grails, which has static fields like ""constraints"".
;;;","12/Mar/10 06:09;paulk;Hi Marcus, that will probably be fine. I added the example in the issue not specifically in response to your example but for future searches. People will see the feature has been added but might not realize the downsides.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
setter and getter destroy meta properties,GROOVY-4098,12817491,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,misterd,misterd,10/Mar/10 10:30,07/Apr/15 19:13,14/Jul/23 06:00,06/Apr/10 18:26,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"When a class offers a getter or setter (but not both) for a property, which is also accessible without that getter or setter breaks, the MOP's according MetaProperty is broken in terms of access permission: A (visible) property with additional setter is marked ""write only"", and one with additional getter ""read only"".

I have attached a test case which shows all four possible variants, two of which are broken:
For each variant, first, read and write access to the property are done by simply accessing the property. This proves, that both read and write access should be possible to that property.
Then, read and write access are done again, this time using the properties MetaProperty.

h4. No getter, no setter.

for propertyOne (line 6), neither a getter, nor a setter is defined. The according test (line 27 to 34) passes: The normal access and the MetaProperty can be read and written. It is neither marked read-only, nor write-only, just as it is supposed to be.

h4. Setter only.

for propertyTwo(line 7), only a setter is defined (line 11 to 13). The according test (line 36 to 43) fails: The normal access works fine, also setting the MetaProperty is possible, but when trying to read the MetaProperty, a GroovyRuntimeException is thrown: ""Cannot read write-only property: propertyTwo"", although it should be possible to read it directly without a setter (as done in line 38), but the MOP does not respect that.

h4. Getter only.
for propertyThree(line 8), only a getter is defined (line 15 to 17). The according test (line 45 to 52) fails just like the previous one, except this time read access is possible and write access fails, and the exception states, this was a read-only property, which it is not. Direct write access without a setter (as done in line 46) should be possible.

h4. Getter and Setter
for propertyFour(line 9), both a getter (lines 19 to 21) and a setter (lines 23 to 25) are defined. The according test (lines 54 to 61) passes just like the first test, where neither were defined. Again, the meta property is neither marked write-only or read-only, as it is supposed to be.

h5. few final words
This bug prevents MetaClasses, from implementing get/setProperty(object, name[, value]) by forwarding it to getMeta/hasProperty(name).get/setProperty(object[, value]). This is very disturbing if you redefined getMetaProperty or hasProperty (where's the difference in these methods by the way?) to perform additional searches to find properties, and you simply want to invoke the returned meta property instead of first determining, if you should ignore the returned meta property and call super.get/setProperty(..) because the meta property invocation might fail with such a misplaced access violation.","Tested on an AMD Turion64 under WinXP with Eclipse Galileo, Java 6u17, will occur on any platform though since this are groovy source code bugs.",misterd,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Mar/10 10:30;misterd;PropertyTest.groovy;https://issues.apache.org/jira/secure/attachment/12722267/PropertyTest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 06 18:26:20 UTC 2010,,,,,,,,,,"0|i2co4f:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"10/Mar/10 18:42;paulk;If you print out the class of {{metaProperty}} for your four test cases you will see that the first case it is {{org.codehaus.groovy.reflection.CachedField}} while for the other three it is {{groovy.lang.MetaBeanProperty}}. This explains (but doesn't excuse) the different behavior you are seeing.;;;","10/Mar/10 20:58;paulk;Fixed. If the field is public (and for setProperty also not final) then MetaBeanProperty delegates through to the field if no relevant explicit getter/setter is found.;;;","14/Mar/10 09:06;misterd;Sadly, this solution does not solve the whole problem. The same problem can be reproduced for all visibilitys of fields. for example, if a subclass acesses a protected field, of a superclass, which only has a getter and no setter (or vice versa), and that call is ""caught"" by a meta class and executed via getMetaProperty(name).getProperty(object), that still fails. I am unsure, if that could be constructed for private fields aswell, but for package visibility and protected fields, it can. I also do not know how this could be fixed, since the returned meta property should probably be different, depending on who is using it's reference, or at least depending on who requested it.

My recommended fix would be, to make all meta properties generated for fields both write and readable: Since even for a class with a private field without getters or setters, using the meta property of this private field, the field can be set and read from outside the class. This behavior is again simply destroyed by defining either a getter or a setter. And since, without getter and setter, the property could be set anyways, why try to make it unaccessible when getters or setters are defined? you can't separate the source of the call anyways to implement proper behavior.;;;","14/Mar/10 19:37;paulk;Yes, it needs more work. We'll discuss further and decide which way to proceed but I suspect the ideal solution won't be possible until the MOP in Groovy 2.0.;;;","16/Mar/10 08:17;misterd;Yes i agree, the optimal solution currently is neither possible, nor implemented for simlar cases (visibility of meta properties). However, i think the MetaBeanProperties, generated from source code bean getters and setters, should - if a property by the matching name exists - always be readable and writeable, since otherwise some code may break. It's not a pretty solution since it breaches visibility, but so does most of the other MOP implementation, and at least it would not break any code then. And that is possible to be implemented for now and does not require MOP 2.0, so at least it could be used as a more or less dirty fix.;;;","16/Mar/10 15:41;paulk;That is the way that I am leaning too at the moment ...;;;","17/Mar/10 07:29;paulk;Change now made regardless of whether field is public.;;;","17/Mar/10 22:21;paulk;Leaving open for now as it still isn't quite right ...;;;","06/Apr/10 18:26;paulk;We discussed a bit more about further improving this and decided to make further changes in the 1.8 timeframe.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
MOP implementation does not handle method calls in relation with class objects properly!,GROOVY-4097,12815078,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,emilles,misterd,misterd,10/Mar/10 09:37,15/Apr/23 15:45,14/Jul/23 06:00,15/Apr/23 15:45,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,groovy-runtime,,,,0,,,,,,"In a few places, the Meta Object Protocoll implementation uses parameter objects classes to look up the matching meta methods. But if one of these arguments already is of type Class, instead of using Class<Class<?>>, the original class parameter is used. This leads to a couple of bugs.

My attached TestCase includes two methods, each demonstrating on of these bugs.

h4. First example:

The first method, testClassArguments(), presents a major issue.
The TestClass has two methods: getSomething(String) and getSomething(Class).

Using the MetaObjectProtocol, i first retrieve the MetaMethod of getSomething (line 23) for an argument set [String] (line 22). MetaClassImpl looks up this method by taking the classes of [String] (namely  [Class<String>]), and looking for a method with a signature, that matches [Class<String>]. This works fine, the result printed (line 24) is the correct method, and the assertion (line 25) passes.

Now i do the same thing again, but this time using an argument set [Class<String>] (line 27). getMetaMethod returns a method (line 28). But, as one can see in the output (line 29), the method is once again getSomething(String): Since MetaClassImpl internally looks up the method, by taking the parameters classes, but in the process _skipping_ class transformation for class arguments, it once again looks for a method with signature [Class<String>] instead of [Class<Class<String>>]. Now, invoking getSomething(String) with Class<String> as parameter of course leads to an IllegalArgumentException, thereby failing the test.

h4. Second example

This second example, method testInvokeStaticMethod(), demonstrates, how a call to getSuperclass, a normal public instance method for Class<T>, is wrongly executed as a static method call on T.

This bug does not occur, when using a default MetaClass: since all default MetaClasses are subclasses of MetaClassImpl, and the class org.codehaus.groovy.runtime.callsite.CallSiteArray has an instanceof test at the third line of it's method createCallStaticSite(CallSite,Class,Object[]), this does not happen for any of MetaClassImpl subclasses.

So the first thing this test does is, to replace its MetaClass with a DelegatingMetaClass, which does nothing except forward all calls to the original MetaClassImpl, but it is not a subclass of MetaClassImpl, so the mentioned instanceof test does not work.

Firstly, the test now retrieves it's own Class object (line 38), which works as expected.

Now, the tests asserts, that its own superclass is GroovyTestCase (line 39), but this assertion fails. The actually returned value of the clazz.getSuperclass() call is ""This was the wrong method!"", which is returned by the test cases static getSuperclass() method (lines 42 to 44).

So what happened here? That is pretty simple:

A normal static call to the getSuperclass() method at lines 42 to 44 would be translated to invokeStaticMethod(GroovyTestCase.class, ""getSuperclass"", []) on the MetaClass of GroovyTestCase.

The superclass call at line 39 *should* have been translated to invokeMethod(clazz, ""getSuperclass"", []) on the MetaClass of Class<T>.

But what happened instead is, since clazz == GroovyTestCase.clazz, the call site was simply ""mistaken"" for a static call site, and delegated to the wrong MetaClass.

h5. some final words

though the displayed test cases may seem a little artificially constructed, i actually stumbled over both of these bugs in my project, after renaming a few java files to groovy. So please note that these are real issues, the examples only may seem that surreal because i reduced them to a minimum. This stuff does  regularly break code when doing some heavy MOP related work.","Tested on an AMD Turion64 under WinXP with Eclipse Galileo, Java 6u17, will occur on any platform though since this are groovy source code bugs.",emilles,misterd,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10820,,,,,,,,,,,,,,"10/Mar/10 09:37;misterd;GroovyTestClass.groovy;https://issues.apache.org/jira/secure/attachment/12722552/GroovyTestClass.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Apr 15 15:45:46 UTC 2023,,,,,,,,,,"0|i2bwnj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"15/Apr/23 15:45;emilles;https://github.com/apache/groovy/commit/cbcf64e9a233cb7ad4c64e132acf83c781561f57

NOTE: {{getMetaMethod}} and others like it specify Object[] for argument types, but do indeed expect types.  Not sure if this is legacy, but it can't be changed to Class[].  The expectation is you call ""getMetaMethod('getSomething',Class)"" if looking for method that accepts class.

I cleaned up a couple places where indeed call arguments are passed and types are expected, so they will now check {{Class<Class>}} instead of whatever kind of class is given in arguments array.

As for the second issue, I can't quite find the right issue to link.  GROOVY-10820 speaks to the static compilation handling of similar situations.  I would be very careful adding static methods like ""getSuperclass()"" or ""getCanonicalName()"".  If you need, you can switch to static compilation to ensure the intended method is called.  Groovy prefers to call static method declared on given class over instance method of Class when receiver is a class instance.

Maybe it would be useful to generate a warning for any static method that is an instance method of Class.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyConsole cosmetic annoyances,GROOVY-4096,12811639,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,10/Mar/10 06:31,07/Apr/15 19:12,14/Jul/23 06:00,10/Mar/10 07:00,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,,,,,,,0,,,,,,GroovyConsole has some issues with linespacing in the output window. This is particularly noticeable when usign large fonts as per the attached screenshot.,Seems worse on Windows. Screen shot using Groovy 1.7.0 on Win 7 with jdk1.6.0_18.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Mar/10 06:32;screenshot-1.jpg;https://issues.apache.org/jira/secure/attachment/12722260/screenshot-1.jpg",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 10 07:00:59 UTC 2010,,,,,,,,,,"0|i2ckdr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Mar/10 07:00;paulk;I couldn't work out the root cause but put in place a ""hack"" which seems to dramatically improve the problem. The problem seems to be due to having troubles sizing a line if no newline has been output and the style has recently changed. The hack is to output a newline in a few choice spots and then remove it. This seems to settle down the sizing algorithm but possibly may still have problems in highly concurrent scenarios. If any anomalies are noticed please add comments here or raise a separate jira.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Labeled statements have wrong source position,GROOVY-4095,12815026,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,pniederw,pniederw,09/Mar/10 16:07,06/Mar/18 23:25,14/Jul/23 06:00,02/May/17 02:12,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.6.0-alpha-1,,,parser,,,,0,,,,,,"Example:

{code}
mylabel:
foo()
{code}

Source position of this statement is [1,8]-[1,9], which is the position of the ':' token. Same for all other labeled statements I've checked.",,daniel_sun,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4071,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 20 02:44:33 UTC 2017,,,,,,,,,,"0|i2cdbb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Mar/10 21:30;roshandawrani;After the GROOVY-4071 fix, the labeled asserts don't get rendered correctly. 
For the code snippet
{code}
mylabel:
assert true == false
{code}

Here is how it looks now:
{noformat}
Caught: Assertion failed: 

:


	at Try.run(Try.groovy:2)
{noformat}

Should a separate JIRA be opened for this assert message rendering issue?;;;","09/Mar/10 22:08;roshandawrani;As noted in GROOVY-4071, both the source location and message rendering issues are interlinked and once we get the source position right on the AssertStatement, the error message should get its empty portions filled again.;;;","15/Mar/10 09:36;roshandawrani;Hi Jochen, you seem to be back on the mailing lists, so here is a pending question for you. :-)

I was comparing the source position of assert statement case with some other statements and noticed that for other cases the position of the ':' token was getting set on the statement but the actual position was getting carried by the expressions inside them. Whereas in case of AssertStatement, it was having an impact because Power-Assert code uses the source position from the AssertStatement itself, which is wrong.

So, by comparison, one potential solution could be to have a AssertExpression wrapped inside a AssertStatement, and make assert code use the source position from AssertExpression instead of AssertExpression.

Do you think it is a worthwhile thing to try that change? Or, do you see a simpler solution?;;;","15/Mar/10 09:50;pniederw;> So, by comparison, one potential solution could be to have a AssertExpression wrapped inside a AssertStatement, and make assert code use the source position from AssertExpression instead of AssertExpression.
Not sure what you are saying here, but why not just fix the source position of labeled statements? It's never good to have wrong source positions in the AST.;;;","15/Mar/10 09:58;roshandawrani;For now, I am just checking it as an alternative to avoid modifying the ANTLR AST to groovy AST conversion code. I haven't checked it yet, but I think there could be an overlap in the AST formation/conversion code with the map key:value scenario, and I want the changes to be as confined as possible.;;;","15/Mar/10 18:43;blackdrag;What does making an expression fix the issue? Also such a change has the problem of possibly breaking code, or not?;;;","16/Mar/10 00:43;roshandawrani;@Jochen, If instead of AssertStatement we have ExpressionStatement wrapping a AssertExpression, then initially both AssertExpression/ExpressionStatement have the same source location, then when "":"" token sets its source information on the ExpressionStatement, the wrapped AssertExpression remains isolated and still continues to have the correct source information. That's how it is working fine for various other labeled expressions.

Regarding the possibility of breaking code, yes, it will impact the users that hook deep into groovy compiler.

Let me know if you think that this direction of solving it is not worth exploring. The only reason was to avoid AST formation code because the place where "":"" sets its source information on the following statement seems like a generic place.;;;","17/Mar/10 06:35;blackdrag;Well, then no AssertStatement wrapping a AssertExpression would be needed, instead ExpressionStatement could warp it... still.. What you write here will essentially be a problem for all statements, or not? I prefer fixing the issue in the current setup, to not to break code;;;","17/Mar/10 06:46;roshandawrani;AssertStatement wrapping a AssertExpression was a typo that I later corrected - I did mean ExpressionStatement doing the wrapping.

A basic doubt - does the source information on the statement matter much? Let's take some example - of a ForStatement or BlockStatement or IfStatement, etc - is it not good enough in general if the expressions carry the source information correctly? When does the source info on the statements matter? Don't statements act as holders for expressions?

It is surely correct that all the labeled statements are affected - but I couldn't reproduce a usage highlighting an issue with some other labeled statement - probably because ACG seems to be taking correct source information from the expressions, or because I am not clear where statement source info really matter.;;;","17/Mar/10 06:57;roshandawrani;I am not trying now to push that we should go the AssertExpression way - just trying to understand how much and where Statement source info matters.

May be it is best to solve this issue through some grammar or AST formation change.;;;","17/Mar/10 07:04;pniederw;> A basic doubt - does the source information on the statement matter much?
I can't see why the source position of a statement should be less important than the source position of an expression. 

if (x) {
  foo()
} else {
  bar()
}

No one expression captures the extents of the statement.

> When does the source info on the statements matter?
For example, power asserts intentionally use the assert statement's source position s.t. the full statement appears in the output, and not just the boolean expression. Spock also uses statement source positions.

>or because I am not clear where statement source info really matter
As long as statements have a source position, it should be correct. Are you proposing to remove source position for statements? ;;;","17/Mar/10 07:11;roshandawrani;Peter - I am not saying one is less important or the other is more, nor I am proposing removal of source information from statements. Why do you have to read between the lines for no reason? I am just trying to become clearer about their use.

My doubt is about what you totally forgot/skipped to explain in the if-else that you typed - that if source information of 'if boolean expression' or 'if block expressions', or 'else block expressions' are all intact - then I am just not clear how the source info on the if BlockStatement or else BlockStatement or IfStatement matters.

I can ask questions about what I am not clear about, can't I?;;;","17/Mar/10 07:25;roshandawrani;Maybe it's too silly a question. Let's please move on. Maybe for tools/IDEs/other frameworks source information on statements is just no less important than the expressions. May for general programming usage, source information on expressions is more visible in error messages and so, and may be that's what was confusing me.

I agree that it's best to get the source information correct on the statements. Let's move on to see how we can solve it now.

Thanks.;;;","20/Jan/17 02:44;daniel_sun;Fixed in the parrot branch;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException on every() ,GROOVY-4086,12815024,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,xjia,xjia,04/Mar/10 10:08,07/Apr/15 19:12,14/Jul/23 06:00,06/Mar/10 07:06,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,,,Compiler,,,,0,,,,,,"The following code throws a ClassCastException 

int[] a = [ 2, 2, 2, 2, 2]

println (1..4.every { a[it] == a[0] } )",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Mar 06 07:21:15 UTC 2010,,,,,,,,,,"0|i2ch2v:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"04/Mar/10 20:16;roshandawrani;Range operator has a lower precedence here, so your code is becoming println (1..(4.every { a[it] == a[0] }) ), which in turn becomes println (1..true), which is not correct.

You need to use parentheses around the range and make it
{code}
int[] a = [ 2, 2, 2, 2, 2]
println ((1..4).every { a[it] == a[0] } )
{code}

For some relevant details of range operator precedence, see GROOVY-254.;;;","06/Mar/10 07:05;paulk;While on the one hand there is nothing to fix, it might be useful to improve our error message for this case.;;;","06/Mar/10 07:06;paulk;Now the example given wraps original error within the following slightly more informative exception:
{noformat}
java.lang.IllegalArgumentException: Unable to create range due to incompatible types: Integer..Boolean (possible missing brackets around range?)
{noformat}
;;;","06/Mar/10 07:13;paulk;It is worth noting that this improved error message doesn't help in certain cases, e.g.:
{code}
int[] a = [2, 2, 2, 2, 2]
1..4.each { println a[it] == a[0] }
{code}
Here {{4.each { println a[it] == a[0] }}} will loop once for the value 4 then return 4 as the result.
Then 1..4 will create a range of size 4.
So, there will be no error but the behavior may not be as naively expected.
;;;","06/Mar/10 07:21;roshandawrani;Yes, the new error message makes the situation much clearer.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Compiler should not allow enum constructor calls from outside the enum,GROOVY-4081,12815087,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,26/Feb/10 10:28,07/Apr/10 23:45,14/Jul/23 06:00,26/Feb/10 13:12,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"Currently groovy compiler lets enum constructor invocations from outside the enum class (and its sub-classes) get compiled. Such calls fail at runtime because enum constructors are transformed to add 2 additional parameters in front of the user-provided parameters - 1) identifier, 2) ordinal.

{code}
enum Alphabet {
	A(1), Z(26)
	private int m_pos;

	public Alphabet( int pos ) {
		m_pos = pos;
	}
}

/* compiler should reject this invocation as enum constructor are only for internal purposes */
println new Alphabet(2) 
{code}

In the code above, the call ""new Alphabet(2)"" fails at runtime because including the 2 internally added parameters, the constructor is <(String,II)V> and not <(I)V>.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 26 13:12:34 UTC 2010,,,,,,,,,,"0|i2c4tb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Feb/10 13:12;roshandawrani;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Invalid class generated for an annotation when @Grab is used with it.,GROOVY-4080,12815118,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,26/Feb/10 06:43,07/Apr/10 23:45,14/Jul/23 06:00,26/Feb/10 09:58,1.7.2,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,1,,,,,,"{code}
@Grab(group='commons-primitives', module='commons-primitives', version='1.0')
import java.lang.annotation.*

@Retention(RetentionPolicy.RUNTIME)
@interface Require {
    String value()
}
{code}

The code above produces a class that is invalid and whose loading fails with the error below:
{noformat}
Caught: java.lang.VerifyError: (class: Require, method: <clinit> signature: ()V) Empty code
{noformat}

It seems that the static initializer method (<clinit>) gets written in bytecode without its body.",,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4079,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 26 09:58:28 UTC 2010,,,,,,,,,,"0|i2bnh3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Feb/10 09:58;roshandawrani;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
@Grab fails with ClassCastException,GROOVY-4079,12815085,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,pniederw,pniederw,25/Feb/10 18:32,01/Mar/10 19:07,14/Jul/23 06:00,26/Feb/10 00:16,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,Grape,,,,0,,,,,,"{code}
@GrabResolver(
  name = 'm2repo.spockframework.org',
  root = 'http://m2repo.spockframework.org/snapshots')
@Grab('org.groovyext:groovyext:0.1-SNAPSHOT')
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy

@Retention(RetentionPolicy.RUNTIME)
@interface Require {
  Class value()
}


class Validator {
  def isValid(pogo) {
    pogo.getClass().declaredFields.every {
      isValidField(pogo, it)
    }
  }

  def isValidField(pogo, field) {
    def annotation = field.getAnnotation(Require)
    !annotation || meetsConstraint(pogo, field, annotation.value())
  }

  def meetsConstraint(pogo, field, constraint) {
    def closure = constraint.newInstance(null, null)
    field.setAccessible(true)
    closure.call(field.get(pogo))
  }
}

class Person {
  @Require({ it ==~ /[a-z A-Z]+/ })
  String name
  @Require({ it in (0..130) })
  int age
}

def validator = new Validator()

def fred = new Person(name: ""Fred Flintstone"", age: 43)
assert validator.isValid(fred)

def barney = new Person(name: ""!!!Barney Rubble!!!"", age: 37)
assert !validator.isValid(barney)

def dino = new Person(name: ""Dino"", age: 176)
assert !validator.isValid(dino)
{code}

Running this code in GroovyConsole gives:
{noformat}
java.lang.ClassCastException: org.codehaus.groovy.ast.stmt.BlockStatement cannot be cast to org.codehaus.groovy.ast.stmt.ReturnStatement
	at org.codehaus.groovy.classgen.ExtendedVerifier.visitConstructorOrMethod(ExtendedVerifier.java:92)
	at org.codehaus.groovy.classgen.ExtendedVerifier.visitMethod(ExtendedVerifier.java:71)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1044)
	at org.codehaus.groovy.classgen.ExtendedVerifier.visitClass(ExtendedVerifier.java:59)
	at org.codehaus.groovy.control.CompilationUnit$11.call(CompilationUnit.java:736)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:971)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:519)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:497)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:474)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:292)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:727)
	at groovy.lang.GroovyShell.run(GroovyShell.java:512)
	at groovy.lang.GroovyShell.run(GroovyShell.java:170)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:857)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:44)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:143)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:151)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:276)
	at groovy.lang.Closure.call(Closure.java:271)
	at groovy.lang.Closure.run(Closure.java:354)
	at java.lang.Thread.run(Thread.java:637)
{noformat}

Problem seems to be related to where I put @Grab/@GrabResolver. If I put it on the annotation type, I get the same exception as shown above. If I put it on Validator, the script succeeds.

General question: Is it relevant where I put a @Grab? There is no logical place for the @Grab in this code, it ""just"" pulls in a global AST transform.

Maybe the @Grab transform and my transform are incompatible, but I doubt it. My transform only rewrites the arguments of the @Require annotations (not the annotation type).","Mac OS 10.6.2
Java 1.6.0_17",pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4080,,,,,,,,"26/Feb/10 05:26;roshandawrani;groovyext_src.JPG;https://issues.apache.org/jira/secure/attachment/12722316/groovyext_src.JPG",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 01 19:07:36 UTC 2010,,,,,,,,,,"0|i2c62n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Feb/10 00:16;roshandawrani;I have fixed the ClassCastException issue and it compiles fine now. 

However, at runtime it is throwing VerifyError, but, I guess, first the ball is in your court, to see if you are getting the AST modification right in receiving closures as annotation attribute values.;;;","26/Feb/10 03:57;pniederw;Roshan, without @Grab I never get a VerifyError. Do you nevertheless think the issue is on ""my"" side?;;;","26/Feb/10 04:15;roshandawrani;That's interesting. I'd like to look into it a bit more in that case and compare the 2 cases - with grab and with groovyext jar normally on the classpath.

I think having the code for groovyext-0.1-SNAPSHOT.jar may help. It may, I think. If it is not a concern sharing it, I will have everything needed to debug it.

Did you try the snapshot to confirm if the VerifyError was coming for you as well?;;;","26/Feb/10 04:29;pniederw;No, I haven't yet tried. Will do so tonight. Source code for the transformation is here: http://github.com/pniederw/groovy-extensions/blob/master/groovyext/src/main/java/org/groovyext/annclosure/AnnotationClosureTransformation.java;;;","26/Feb/10 04:32;pniederw;Maybe the transforms step on each other's toes because mine also adds code to the static initializer. But it's just a wild guess at this point.;;;","26/Feb/10 04:54;roshandawrani;Yes, both GrabAnnotationTransformation and your AnnotationClosureTransformation playing with <clinit> must be the reason for the breakage. After looking a bit more, hopefully, we will know which transformation can adjust so that the two don't step on each other's toes.

In the meantime, as a workaround, you can use the ""initClass"" attribute of @Grab to tell it to not add its explicit grab() call from its static initilizer, as shown in the snippet below:

{code}
@GrabResolver(
  name = 'm2repo.spockframework.org',
  root = 'http://m2repo.spockframework.org/snapshots')
@Grab(value = 'org.groovyext:groovyext:0.1-SNAPSHOT', initClass='false')
import java.lang.annotation.Retention
import java.lang.annotation.RetentionPolicy

@Retention(RetentionPolicy.RUNTIME)
@interface Require {
  Class value()
}
....
....
{code};;;","26/Feb/10 04:58;roshandawrani;I don't see the code for org.groovyext.annclosure.ClassRewriter at http://github.com/pniederw/groovy-extensions/blob/master/groovyext/src/main/java/. Can that also be shared please?;;;","26/Feb/10 05:22;pniederw;Does this link work any better for you? http://github.com/pniederw/groovy-extensions/tree/master/groovyext/src/main/java/org/groovyext/annclosure/;;;","26/Feb/10 05:26;roshandawrani;No. It still has only AnnotationClosureTransformation.java. I am attaching a screenshot for reference.

It is just 2 source files - could you mail them?;;;","26/Feb/10 05:28;pniederw;It IS just one file. The file contains two classes, one of which has package visibility.;;;","26/Feb/10 05:34;roshandawrani;Sorry, sorry. I don't know who told me that AST transforms needed at least 2 files! ;-);;;","26/Feb/10 06:39;roshandawrani;The VerifyError where your example is stuck currently has nothing to do with your AST transformation. There looks to be some issue in class generation for an annotation with @Grab involved. In such a case, it is not writing the code block for <clinit> and then the classloading fails when it sees this non-abstract, non-native method with no code body.

I am able to reproduce the issue with the example below.
{code}
@Grab(group='commons-primitives', module='commons-primitives', version='1.0')
import java.lang.annotation.*

@Retention(RetentionPolicy.RUNTIME)
@interface Require {
    String value()
}
{code}

I will open a separate JIRA for this and link here. After that is solved, we'll come back here and see if there are any further obstacles in your example.;;;","26/Feb/10 06:43;pniederw;Just to make it clear: I do have a workaround for my example, which is to place @Grab/@GrabResolver on class Validator rather than an import or the annotation type.;;;","26/Feb/10 06:45;roshandawrani;There is also the initClass='false' workaround mentioned above, but that's not the point now. There is a separate @Grab related issue that your example has highlighted. I have created GROOVY-4080 for it.;;;","26/Feb/10 10:07;roshandawrani;Peter, the VerifyError is also fixed now (GROOVY-4080) and now your JIRA example works as is.;;;","26/Feb/10 10:09;pniederw;Thanks a lot, Roshan. I'll give it a try tonight.;;;","01/Mar/10 19:07;pniederw;works fine now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,
Number.step incorrectly believes there is an infinite loop,GROOVY-4078,12815114,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,jpertino,jpertino,24/Feb/10 18:03,07/Apr/10 23:45,14/Jul/23 06:00,25/Feb/10 00:04,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,groovy-jdk,,,,0,,,,,,"
recently i noticed that an exception is thrown with something like
0.step 0, 10, {}

i checked the dgm (version 1.7.0 i think) and found that self and to equality is never considered as a possibility.

i believe it should just do nothing like, say
(0..<0).step 10, {}
or
for (int i=0; i<0; i++) {}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 25 06:02:28 UTC 2010,,,,,,,,,,"0|i2bn0f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Feb/10 00:04;roshandawrani;Fixed.

Please let me know if it needs to be back-ported to 1.6.x as well.;;;","25/Feb/10 05:35;jpertino;
checked another environment with 1.6.7, would need patching as well

thanks;;;","25/Feb/10 05:45;roshandawrani;The patching on 1.6.x line can only be done on currently active 1.6.9 line. 1.6.7 will then need to be upgraded to 1.6.9 (whenever it comes out) or it can be locally patched.

Not all fixes are being back-ported to 1.6.x line these days (just more critical ones), that's why I wanted to double check with the project members if in this case it needs to be done.;;;","25/Feb/10 06:02;jpertino;sorry, i misunderstood your comment and thought you wanted to know if it was present in 1.6 releases.

actually moving that project to 1.7 is in my todo list i don't really need it
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
shouldFailWithCause no longer works for unchecked exceptions,GROOVY-4075,12815477,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,achuggardlee,achuggardlee,23/Feb/10 11:29,07/Apr/10 23:45,14/Jul/23 06:00,08/Mar/10 00:21,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,2,,,,,,"So we upgraded from 1.6.3 to Groovy 1.7.0 and realized that one of our tests started failing... it seems that in 1.7.0 unchecked exceptions are simply rethrown (groovy.lang.Closure#throwRuntimeException(Throwable) called from #call(Object[])). Which in groovy.util.GroovyTestCase#shouldFailWithCause(Class,Closure), the exception falls to the catch Throwable branch and the cause is not attempted to be determined beyond that, which causes the test to fail.

Example test showing a successful checked and unsuccessful unchecked exception:
{code}
package dummy;

import groovy.util.GroovyTestCase;

import java.io.IOException;

import org.junit.Test;

/**
 * Demonstrates cases of should fail with cause.
 * @author Charlie Huggard-Lee 
 */
class DummyTest extends GroovyTestCase {
    
    public static void failChecked() throws Exception {
        throw new Exception(new IOException());
    }
    
    public static void failUnchecked() {
        throw new RuntimeException(new IOException());
    }
    
    
    @Test
    public void testcheckedFailure() {
        //Hurray!
        shouldFailWithCause(IOException.class, {DummyTest.failChecked()})    
    }
    
    @Test
    public void testuncheckedFailure() {
        //BOO!!!
        shouldFailWithCause(IOException.class, {DummyTest.failUnchecked()})    
    }
    
}
{code}",,kpshek,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"09/Mar/10 05:17;GroovyTestCase_groovy4075.patch;https://issues.apache.org/jira/secure/attachment/12722505/GroovyTestCase_groovy4075.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 11 06:56:03 UTC 2010,,,,,,,,,,"0|i2cnzz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"23/Feb/10 12:27;roshandawrani;I don't think it is related to groovy.lang.Closure#throwRuntimeException(Throwable) simply rethrowing unchecked exceptions. Even in 1.6.3, it does the same thing - https://svn.codehaus.org/groovy/tags/GROOVY_1_6_3/src/main/groovy/lang/Closure.java

I think it is possibly related to - http://fisheye.codehaus.org/browse/groovy/trunk/groovy/groovy-core/src/main/org/codehaus/groovy/reflection/CachedMethod.java?r1=12759&r2=17769;;;","23/Feb/10 12:46;roshandawrani;I am pretty sure that above mentioned change in CachedMethod exception handling is causing it.

The above change was done on 1.7-beta-2. Upto 1.7-beta-1, the reported issue is not there. It's also not there on current 1.6.9 because this change was not done on 1.6.x line.;;;","06/Mar/10 04:05;roshandawrani;Should we try to revert a part of changes from the above revision to fix the regression? 

The changes were done under ""faster exception handling"" thread - http://marc.info/?l=groovy-dev&m=125412236814260&w=2.;;;","06/Mar/10 09:59;paulk;I suspect so.;;;","06/Mar/10 11:25;achuggardlee;I'll readily admit I personally am relatively new to Groovy and this could indeed be a semantic issue requiring the partial reversion of the changes you cite. 

But the simplest solution to me seems to be to update shouldFailWithCause to reflect this change by making it closer to the shouldFail code and just evaluate cases based upon the cause instead of the throwable itself) somewhat like the following:  

{code}
    protected String shouldFailWithCause(Class clazz, Closure code) {
        Throwable th = null;
        try {
            code.call();
        } catch (GroovyRuntimeException gre) {
            th = ScriptBytecodeAdapter.unwrap(gre);
        } catch (Throwable e) {
            th = e;
        }
        
        if (th==null) {
            fail(""Closure "" + code + "" should have failed"");
        } else {
            th = th.getCause();
            if (th==null) {
                fail(""Closure "" + code + "" should have failed with an exception cause of type "" + clazz.getName());
            } else if (! clazz.isInstance(th)) {
                fail(""Closure "" + code + "" should have failed with an exception cause of type "" + clazz.getName() + "", instead got Exception "" + th);
            }
        }
        return th.getMessage();
    }
{code};;;","06/Mar/10 18:31;roshandawrani;I looked into the patch and it fails to handle MissingProperyException / MissingMethodException, as shown in the code below

{code}
class PatchTest extends GroovyTestCase {
    public void testMissingProperty() {
        def foo = new Foo()
        shouldFailWithCause(MissingPropertyException) {
            foo.bar
        }
    }
    
    public void testMissingMethod() {
        def foo = new Foo()
        shouldFailWithCause(MissingMethodException) {
            foo.roshan()
        }
    }
}

class Foo {}
{code};;;","06/Mar/10 22:23;achuggardlee;Re: the Missing*Exceptions... 

I thought those cases are supposed covered under shouldFail(Class,Closure) instead of shouldFailWithCause(Class,Closure) since those are the exceptions that are directly thrown:

E.g. new Foo().roshan() throws an exception without a cause:
{code}
    @Test
    public void testMissingMethodException() {
        try {
            new Foo().roshan()
            throw new Error(""no failure"")
        } catch(MissingMethodException e) {
            assertNull(e.getCause())
        }
    }
{code};;;","06/Mar/10 22:28;roshandawrani;There are unit test cases in groovy code base that explicitly test MissingPropertyException with shouldFailWithCause. I think the current implementation of shouldFailWithCause() has no problem if getCause() is null.;;;","06/Mar/10 22:31;roshandawrani;And since it has not been having any problem handling exception cases with cause = null, making it so will cause another regression.;;;","07/Mar/10 08:10;achuggardlee;I guess the root of this issue then is what is 'shouldFailWithCause' supposed to assert about the passed Class and Closure and how is it different from shouldFail(Class,Closure)?

Unfortunately we're running into having no javadoc on the method, the only other bug am currently finding that mentions shouldFailWithCause is GROOVY-1247 (which seems to be related to return values), and fisheye unfortunately isn't helping find when it was added given that [HEAD of GroovyTestCase currently indexed as r6778|http://fisheye.codehaus.org/browse/groovy/trunk/groovy/groovy-core/src/main/groovy/util/GroovyTestCase.java?r=HEAD] where the method does not exist yet...

Based upon the naming convention, I interpreted shouldFailWithCause(Class,Closure) to mean that I expect a particular closure to throw any Throwable that has a cause of the specified class, thus distinguishing it from shouldFail(Class,Closure) which seems to asserts that the closure throws a Throwable of the specified class.

The issue I have with shouldFailWithCause also handling the case where getCause() == null is that then we have a state where this one method sometimes makes an assertion about the thrown Throwable, and sometimes makes an assertion about the thrown Throwable's cause, making our tests unclear as to which is the case.

If my interpretation of purpose behind shouldFailWithCause is true, then the tests were written incorrectly in the first place, and we should deliberately break them. If I'm wrong, then we need to make sure to change shouldFailWithCause so that it only asserts one state since philosophically having a method that asserts multiple different states makes any test utilizing it ambiguous to begin with. (Since no matter what we'll wind up breaking someone with any change, we probably should slate it for groovy 1.8).

And of course this is a separate discussion from whether or not the change to let RuntimeExceptions fall through as is was indeed correct. ;;;","07/Mar/10 09:00;achuggardlee;My Last argument in code... currently these two tests both succeed, and I assert that only one of them should since they are different states:

{code}
    public static class HomerSimpson { 
    }
    
    @Test
    public void testMissingMethodManual() {
        Closure code = {
            throw new MissingMethodException(""eatDonut"", HomerSimpson, new Object[0] )
        }
        shouldFailWithCause(MissingMethodException.class, code)
    }
    
    @Test
    public void testMissingMethodSecond() {
        Closure code = {
            throw new Exception(new MissingMethodException(""preventMeltdown"", HomerSimpson, new Object[0] ))
        }
        shouldFailWithCause(MissingMethodException.class, code)
    }
{code};;;","07/Mar/10 10:07;achuggardlee;Wait... I'm an idiot... shouldFailWithCause tests that the last cause is of the specified type... (is this correct?)

{code}
    @Test
    public void testIOExceptionFirst() {
        Closure code = { throw new IOException() }
        shouldFailWithCause(IOException.class, code)
    }
    
    @Test
    public void testIOExceptionSecond() {
        Closure code = {throw new Exception(new IOException()) }
        shouldFailWithCause(IOException.class, code)
    }
    
    @Test
    public void testIOExceptionThird() {
        Closure code = { throw new Exception(new Exception(new IOException())) }
        shouldFailWithCause(IOException.class, code)
    }
    
    @Test
    public void testIOExceptionFourth() {
        Closure code = { throw new Exception(new Exception(new Exception(new IOException()))) }
        shouldFailWithCause(IOException.class, code)
    }
{code};;;","07/Mar/10 10:18;achuggardlee;Considering [my last comment|#action_212964] how about this then:

{code}
    protected String shouldFailWithCause(Class clazz, Closure code) {
        Throwable th = null;
        try {
            code.call();
        } catch (Throwable e) {
            th = e;
            while(th.getCause()!=null) {
                th = th.getCause();
            }
        }
        
        if (th==null) {
            fail(""Closure "" + code + "" should have failed with an exception caused by type "" + clazz.getName());
        } else if (! clazz.isInstance(th)) {
            fail(""Closure "" + code + "" should have failed with an exception caused by type "" + clazz.getName() + "", instead got Exception "" + th);
        }
        return th.getMessage();
    }
{code};;;","08/Mar/10 00:21;roshandawrani;The last patch looked ok to me and I have applied it. Thanks.;;;","09/Mar/10 02:31;paulk;I am not sure the logic is correct here as patched. Pondering ...;;;","09/Mar/10 03:32;paulk;The following test used to work but now fails with the latest patch:
{code}
class MyTest extends GroovyTestCase {
  def throwWrappedException() {
    throw new GroovyRuntimeException(
      new IllegalArgumentException(
        new NullPointerException()
      )
    )
  }
  void testBefore() {
    shouldFailWithCause(IllegalArgumentException) {
      throwWrappedException()
    }
  }
}
{code}
I think the original intention of this method was to strip away any layers of Groovy wrapping and proceed from there but changes in the way we do things make shouldFail have that characteristic now. I think the best semantics would now be to detect the cause anywhere in the hierarchy.;;;","09/Mar/10 05:17;paulk;My suggested additional fix is attached (though needs javadoc!). All tests pass. But I think PropertyTest should just be shouldFail anyway (which also passes). I suspect PropertyTest was only the other way because of legacy problems with shouldFail which no longer exist.;;;","09/Mar/10 05:22;paulk;One aspect that I wasn't sure which way to go was whether to check the top-level exception against the cause we are looking for. I ended up going that way because the first exception we see might be further wrapped as the cause for some GroovyRuntimeException and hence might be the cause without us knowing it.;;;","09/Mar/10 05:45;roshandawrani;Another option would be to revert back all changes to shouldFailWithCause() that we have made here and solve it by reverting part of the ""faster exception handling"" change, as earlier discussed here.

Or, we can stick to the new patch and define the behavior at this point with a proper javadoc so that the intended behavior does not need to be guessed in future and stick with it.;;;","09/Mar/10 05:52;paulk;I am +1 for the second of these:

bq. We can stick to the new patch and define the behavior at this point with a proper javadoc so that the intended behavior does not need to be guessed in future and stick with it.

I don't think the original version was offering any significant value given the other changes that have taken place.;;;","09/Mar/10 06:16;roshandawrani;Ok, let's do it - with a few lines of javadoc this time ;-);;;","09/Mar/10 21:16;paulk;Wasn't sure whether you wanted me to do it or not - so I went ahead and did it.;;;","09/Mar/10 21:31;roshandawrani;I was looking for some help there due to the javadoc involved. I thought you were in a better position to explain it there due to the last issue you found there and the changes that you made.

Thanks.;;;","10/Mar/10 00:31;paulk;No worries at all. Now just to work out why tests pass locally and on Bamboo JDK1.6 but fail on Bamboo JDK1.5?;;;","10/Mar/10 02:02;roshandawrani;Paul, the JDK 1.5 builds are failing because in the tests you have used the following 2 constructors of IOException and the JDK 1.5 version of IOException does not have both of these.

{noformat}
IOException(Throwable)

IOException(String, Throwable)
{noformat}

The tests need to use some other exception that has such suitable constructors in both JDK 1.5 and 1.6.;;;","10/Mar/10 02:39;roshandawrani;Here is a suggestion for IOException replacement in tests : java.util.concurrent.ExecutionException - has both the needed constructors.;;;","10/Mar/10 02:42;paulk;Yes, I ran the tests locally on 1.5 and spotted that too. Just fixing now ...;;;","10/Mar/10 06:01;paulk;I ended up going with IllegalArgumentException. The other lesson learned from the CI logs was that we weren't seeing the full error message. It made sense to unwrap GroovyRuntimeExceptions and print out all of the exception messages in the error message. It also no longer made sense to compare against the top level exception as that is now the same as shouldFail. So I updated the logic and the javadoc.;;;","11/Mar/10 06:56;paulk;Just chatting with Jochen. Apparently there is a use case that we have encountered in the past where an exception has itself as its own cause. Sounds bad style but we should handle this case gracefully in any case. I'll add in a check for this case too to avoid the possibility of an infinite loop.;;;",,,,,,,,,,,,,,,,
finally block not called if exception rethrown in catch block,GROOVY-4072,12815064,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,mstudman,mstudman,21/Feb/10 21:19,06/Apr/10 12:08,14/Jul/23 06:00,06/Apr/10 12:08,1.6.8,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,,,,,,,1,,,,,,"Blah.groovy:
{code}
try {
  throw new Exception()
} catch (Exception e) {
  println ""e: ${e}""
  throw e
} finally {
  println ""finally""
}
{code}

~/Downloads/groovy-1.6.8/bin/groovy Blah =>

{code}
e: java.lang.Exception
Caught: java.lang.Exception
	at Blah.run(Blah.groovy:2)
{code}

~/Downloads/groovy-1.6.7/bin/groovy Blah =>

{code}
e: java.lang.Exception
finally
Caught: java.lang.Exception
	at Blah.run(Blah.groovy:2)
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 06 12:08:13 UTC 2010,,,,,,,,,,"0|i2c4on:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Feb/10 23:38;mstudman;Possibly related to http://jira.codehaus.org/browse/GROOVY-3922 ?;;;","05/Apr/10 07:41;paulk;Just checking status. The fix for GROOVY-3922 seems to fix this. Can we close or is a merge to 1_6_X pending?;;;","06/Apr/10 12:08;blackdrag;as commented on GROOVY-3922 the fix is for 1.7.2 only since the file versions of ACG differ too much;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
IndexOutOfBoundsException for labeled assertion statement,GROOVY-4071,12815094,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pniederw,pniederw,pniederw,21/Feb/10 14:23,09/Mar/10 21:48,14/Jul/23 06:00,09/Mar/10 18:29,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-1,,,Compiler,,,,0,,,,,,"Try to compile the following code (or run it in GroovyConsole):
{code}
mylabel:
assert true == true
{code}

Result:
{noformat}
java.lang.IndexOutOfBoundsException: Index: 1, Size: 1
	at java.util.ArrayList.RangeCheck(ArrayList.java:547)
	at java.util.ArrayList.get(ArrayList.java:322)
	at org.codehaus.groovy.transform.powerassert.SourceText.getNormalizedColumn(SourceText.java:103)
	at org.codehaus.groovy.classgen.AsmClassGenerator.record(AsmClassGenerator.java:1661)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:1625)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBooleanExpression(AsmClassGenerator.java:1901)
	at org.codehaus.groovy.ast.expr.BooleanExpression.visit(BooleanExpression.java:40)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitAssertStatement(AsmClassGenerator.java:978)
	at org.codehaus.groovy.ast.stmt.AssertStatement.visit(AssertStatement.java:47)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:161)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:707)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:51)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:161)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:707)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:51)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:97)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:108)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:586)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:562)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:119)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:664)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1044)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:50)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:275)
	at org.codehaus.groovy.control.CompilationUnit$11.call(CompilationUnit.java:758)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:973)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:520)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:498)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:475)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:292)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:727)
	at groovy.lang.GroovyShell.run(GroovyShell.java:512)
	at groovy.lang.GroovyShell.run(GroovyShell.java:170)
	at groovy.lang.GroovyShell$run$1.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:848)
	at sun.reflect.GeneratedMethodAccessor423.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:151)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor422.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:276)
	at groovy.lang.Closure.call(Closure.java:271)
	at groovy.lang.Closure.run(Closure.java:354)
	at java.lang.Thread.run(Thread.java:637)
{noformat}",Mac OS 10.6.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4095,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 09 21:48:11 UTC 2010,,,,,,,,,,"0|i2cf1z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Mar/10 09:01;roshandawrani;Peter, wanted to check if you have given it a look? I was just seeing where the error was coming from and it looks like a AST formation issue to me, because of which the AssertStatement has the wrong line number set on it.

I was wondering if you were planning to deal with it in the power assert code somehow (by offsetting the line number, etc);;;","09/Mar/10 09:14;pniederw;Thanks for reminding me. Will have a look at it.;;;","09/Mar/10 10:43;roshandawrani;If instead of AssertStatement, we had AssertExpression wrapped in an ExpressionStatement, then probably this line number issue wouldn't have been there. But that change seems quite widespread.

Eager to see what solution comes up for this.;;;","09/Mar/10 18:29;pniederw;Fixed in rev. 19521 by adding another check for invalid source position (rationale: better output nothing than to throw an IIOBE). Of course the real solution is to fix GROOVY-4095 .;;;","09/Mar/10 21:11;roshandawrani;When the assertion fails, the big/almost-blank message looks a bit weird now:

{noformat}
Caught: Assertion failed: 

:


	at Try.run(Try.groovy:2)
{noformat}
;;;","09/Mar/10 21:13;pniederw;It's now up to GROOVY-4095 to fix this.;;;","09/Mar/10 21:20;pniederw;Actually I'm not sure if GROOVY-4095 is sufficient for correct rendering of labeled asserts, but it's necessary.;;;","09/Mar/10 21:27;roshandawrani;Wherever it gets fixed - I just wanted to record the bit that still does not look correct. 

I think wrong rendering of labeled asserts and wrong line number on AssertStatementare 2 different things. 

I will make a note of wrong rendering under GROOVY-4095 as well - for information.;;;","09/Mar/10 21:35;pniederw;>I think wrong rendering of labeled asserts and wrong line number on AssertStatementare 2 different things.
These two things are strongly correlated. The source code for the assertion is not captured (and thus displayed) correctly because the source position is wrong. The values aren't displayed because AssertionRenderer detects that source position is wrong, in which case it doesn't render the value(s).
>wrong line number on AssertStatementare
Just to be clear, it's not wrong source position of assert statements, but wrong source position of (any) labeled statement.;;;","09/Mar/10 21:48;roshandawrani;>> wrong line number on AssertStatementare
> Just to be clear, it's not wrong source position of assert statements, but wrong source position of (any) labeled statement.

I know that the source position is not specific to AssertStatement but to others as well but the issue here is specific to AssertStatement. I had tried a few more labeled statements but for them it didn't seem to matter much because expressions inside the statements were still carrying the correct source information. I didn't test extensively though.

That's the reason that as an initial experiment I was exploring having ExpressionStatement (AssertExpression) instead of AssertStatement so that AssertExpression continued to carry the correct source information for power assert and "":"" source location was set on wrapping ExpressionStatement, which mattered less.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Wrong value returned for ""Attribute.name()"" when iterating over GPath Attributes",GROOVY-4070,12816348,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,frayerm,frayerm,21/Feb/10 13:18,07/Apr/15 19:12,14/Jul/23 06:00,23/Feb/10 06:10,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.9,1.7.2,1.8-beta-1,,,,,0,,,,,,"When iterating over a collection of GPath Attributes I'm seeing the wrong value being returned for the ""Attribute.name()"" method.  The issue seems to be in the implementation of the ""groovy.util.slurpersupport.Attributes.iterator()"" method when constructing a new Attribute.  It uses the ""attributeName"" field which holds the name of the attribute minus the '@' character.  The ""Attribute.name()"" method is expecting the first character in the name to be '@' as well and throws it away.  This leads to the first character in the attribute name going missing.

I've attached a patch which shows one possible fix to the issue in Attributes.java.  It also modifies GpathSyntaxTestSupport.groovy to add some Unit Tests for this issue.

The following code demonstrates the problem I'm seeing.

{code}
def xml = '''
<people>
  <person age=""20"">John</person>
  <person age=""25"">Jane</person>
</people>
'''

def p = new XmlSlurper().parseText(xml)
p.person.each {
  println it.@age.name()
}
p.person.@age.each {
  println it.name()
}
{code}

Running the above gives the following output:
age
age
ge
ge
",Mac OS X 10.6.2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"21/Feb/10 13:18;frayerm;patch.txt;https://issues.apache.org/jira/secure/attachment/12722258/patch.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Tue Feb 23 06:10:23 UTC 2010,,,,,,,,,,"0|i2chvb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"23/Feb/10 06:00;paulk;patch looks good;;;","23/Feb/10 06:10;paulk;Thanks for the patch. Applied.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Custom constructors added via metaclass are sometimes not cleaned up,GROOVY-4069,12815060,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,ldaley,ldaley,20/Feb/10 18:49,07/Apr/10 23:45,14/Jul/23 06:00,02/Mar/10 20:36,1.7.1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"There seems to be an issue with constructors added via metaclass and cleanup:

{code}
class MetaClassMagicTests extends GroovyTestCase {
    void testIt() {
        ExpandoMetaClass.enableGlobally()
        
        // Child.metaClass // uncomment and everything works
        
        // Save the old meta class
        def oldMetaClass = Parent.metaClass
        
        // Install a new one
        def emc = new ExpandoMetaClass(Parent, true, true)
        emc.initialize()
        GroovySystem.metaClassRegistry.setMetaClass(Parent, emc)
        
        // Install a map based constructor
        emc.constructor = { Map m -> Parent.newInstance() }
        
        // Parent constructor is used, all good
        assert new Child([:]) instanceof Parent
        
        // Reinstate the old meta class
        GroovySystem.metaClassRegistry.removeMetaClass(Parent) 
        GroovySystem.metaClassRegistry.setMetaClass(Parent, oldMetaClass)

        // This fails, this calls the custom constructor from above and returns an instance of Parent
        assert new Child([:]) instanceof Child
    }
    
}

class Parent { def a }
class Child extends Parent { def b }
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"28/Feb/10 09:00;roshandawrani;4069_v18x_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722502/4069_v18x_Patch.txt","02/Mar/10 10:46;roshandawrani;V2_4069_v18x_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722617/V2_4069_v18x_Patch.txt",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 02 20:36:58 UTC 2010,,,,,,,,,,"0|i2ctjb:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"23/Feb/10 09:39;roshandawrani;Isn't it the Child metaClass that you should be manipulating instead of Parent's? 

The following code goes through:

{code}
class MetaClassMagicTests extends GroovyTestCase {
    void testIt() {
        ExpandoMetaClass.enableGlobally()
        
        def oldMetaClass = Child.metaClass
        
        def emc = new ExpandoMetaClass(Child, true, true)
        emc.initialize()
        GroovySystem.metaClassRegistry.setMetaClass(Child, emc)
        
        emc.constructor = { Map m -> Child.newInstance() }
        
        assert new Child([:]) instanceof Parent
        
        GroovySystem.metaClassRegistry.removeMetaClass(Child) 
        GroovySystem.metaClassRegistry.setMetaClass(Child, oldMetaClass)

        assert new Child([:]) instanceof Child
    }
    
}

class Parent { def a }
class Child extends Parent { def b }
{code};;;","23/Feb/10 17:00;ldaley;No, the point is that after I have removed the constructor from the parent's metaclass, it is still called when constructing the child. This is definitely unexpected.

Note the...

{code}
// Child.metaClass // uncomment and everything works
{code}

line. If that get's executed then everything works, which _seems_ like that if the Child metaClass is initialised before diddling with the Parent's metaClass you get the right behaviour.;;;","28/Feb/10 07:50;roshandawrani;While your point about inconsistency is right, I think your asserts convey the wrong expectations (as far as I understand metaClass thing). I think when you add a constructor through Parent EMC, ""new Child()"" should not get that constructor.

So, the following should be the behavior:
{code}
ExpandoMetaClass.enableGlobally()

def oldMetaClass = Parent.metaClass

def emc = new ExpandoMetaClass(Parent, true, true)
emc.initialize()
GroovySystem.metaClassRegistry.setMetaClass(Parent, emc)

emc.constructor = { Map m -> Parent.newInstance() }

/* here also you should get a new Child because you have manipulated Parent MC */
assert new Child([:]) instanceof Child

GroovySystem.metaClassRegistry.removeMetaClass(Parent) 
GroovySystem.metaClassRegistry.setMetaClass(Parent, oldMetaClass)

assert new Child([:]) instanceof Child

class Parent { def a }
class Child extends Parent { def b }
{code}

For the behavior that you are trying, you should manipulate Child MC.

Can someone please verify the behavior - one way or another? Thanks.;;;","28/Feb/10 09:00;roshandawrani;Attaching a patch for review based on my understanding of the behavior in this scenario.

Basically the change made in the patch is that EMC should not create a constructor site if the type <init> has been invoked on does not match the type it finds <init> on at runtime. That way when ""Parent"" defines a new constructor through EMC, ""new Child()"" will not match it.

Tests are added to verify the behavior when you manipulate the MC of Parent and of Child and variations ""ChildX.metaClass"" commented/uncommented that lead to the inconsistent behavior.;;;","02/Mar/10 10:01;blackdrag;hmm... is the type parameter really needed? I assume the declaring class of a method for a method added by closure will always not be the same as the current class. So I wonder if it wouldn't be enough to change{code:Java}
(type == null) || (method.getDeclaringClass().getTheClass().equals(type)
{code}
to
{code:Java}
method.getDeclaringClass().getTheClass().equals(getTheClass())
{code}
As I understand it, this will always false if the method is added through a closure... or is getTheType() returning something else than what ""type"" would get?;;;","02/Mar/10 10:46;roshandawrani;Thanks for the feedback, Jochen. I didn't notice that I could get the type from MC#getTheClass() as well. 

I have made that change and I am attaching V2 of the patch here.

Please let me know if you see any other issue.;;;","02/Mar/10 20:36;roshandawrani;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Groovy clibuilder doesn't take the parameter when the longOpt name ends with character ""s""",GROOVY-4066,12815747,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,miwang,miwang,18/Feb/10 17:10,07/Apr/10 23:45,14/Jul/23 06:00,20/Feb/10 03:10,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"When the clibuilder creates a command line option whose longOpt ends with character ""s"", such as ""seconds"", the parser can't get the parameter, it is null. 

Here's a simple groovy script that demonstrates the problem.  Note that the long option ending with an 's' gets enabled when the non-s option is given.



$> ./cli.groovy -s
options.s evaluates to true
options.seconds evaluates to false
options.e evaluates to false
options.second evaluates to false


$> ./cli.groovy -e
options.s evaluates to false
options.seconds evaluates to true
options.e evaluates to true
options.second evaluates to true



def cli = new CliBuilder()
cli.s longOpt:'seconds', 'a long arg that ends with an ""s""'
cli.e longOpt:'second', 'a long arg that does not end with an ""s""'

def options = cli.parse( args )
if( null == options ) 
{ 
    return
}

if( args.length == 0 || options.h ) 
{
    cli.usage()
}

println ""options.s evaluates to "" + (options.s as boolean)
println ""options.seconds evaluates to "" + (options.seconds as boolean)
println ""options.e evaluates to "" + (options.e as boolean)
println ""options.second evaluates to "" + (options.second as boolean)
 ","Linux, Mac",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Feb 20 03:10:11 UTC 2010,,,,,,,,,,"0|i2bn8v:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"19/Feb/10 10:05;roshandawrani;I don't think that is a bug (may be a documentation issue, but I haven't checked it out yet). 

The longOpt(s) is there to support getting multiple option values.

Say, if you have an option (short name = D, long name = define) that lets you pass multiple values with it, you can retrieve them as getOptionValues('D') or options.defines (plural form, that internally maps to getOptionValues('D')) - so it removes last 's', takes the option long name as 'define' and then invokes the getOptionValues() to get all associated values.;;;","19/Feb/10 17:33;paulk;A while back when commons cli looked stalled, I wrote a version of CliBuilder for a different underlying engine. In that, I looked for non-plural forms and only took the 's' off for those cases. It seemed to work well. Perhaps it could be backed ported for our commons cli version.;;;","19/Feb/10 20:22;roshandawrani;I think that will be an improvement - that options.seconds will become plural of options.second only if option ""second"" is defined, otherwise, it will try to use it as ""seconds"" itself. 

It won't help where both singular and plural options (""second"" and ""seconds"") are defined, as in this JIRA's case, but is an improvement over current behavior nonetheless.;;;","19/Feb/10 22:37;miwang;Roshan, thanks for the reply. If I use the short option name: ""options.s"", I still don't get anything. Effectively, it stops people from adding ""s"" to the end of any long option name, plus, there is no clear documentation on this.

For instance, I was trying to use a parameter like ""number_of_seconds"", if I can't add ""s"" to the longOpt, I have to change the name to ""number_of_second"" which sounds weird. Also, I took me quite some time to find the trick of trailing ""s"", since there was no warning or error in runtime. I searched documentation and couldn't find any thing about this trick.

So from a user point of view, this does make people's life more difficult, especially if they are unaware of this trick. ;;;","19/Feb/10 22:46;roshandawrani;We'll improve the behavior now (as Paul has suggested) as well as update the documentation to talk about this plural trick.

After the change, it will allow you to have an option like ""number_of_seconds"" (unless you also have happen to have ""number_of_second"" because then it will have a conflict with the plural feature again);;;","20/Feb/10 03:10;roshandawrani;Fixed, as discussed here. Here is the test that code goes through after the fix:

{code}
def cli = new CliBuilder ()
cli.s ( longOpt : 'number_of_seconds', 'a long arg that ends with an ""s""' )

def options = cli.parse (['-s'])

assert options.hasOption ( 's' )
assert options.hasOption ( 'number_of_seconds' )
assert options.s
assert options.number_of_seconds
{code}

Thanks for the hint, Paul.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovyc not compiling correctly when Grape.grab is used,GROOVY-4065,12814896,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,mattmcq,mattmcq,17/Feb/10 17:18,14/Oct/13 16:53,14/Jul/23 06:00,11/Oct/13 14:56,1.7.0,2.2.0-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.2.0-rc-1,,,Compiler,Grape,,,3,,,,,,"This is my first Jira on codehaus. Please let me know if I'm filing this the right way. Thank You!

Example class Foo:
{code}
import groovy.grape.*
class Foo {
  public static void main(String[] args){
    Grape.grab(group:'org.apache.ant', module:'ant', version:'1.8.0');
    System.out.println(""Grape.grab seems to work"");
  }
}
{code}
Compilation:
{noformat}
> groovy Foo.groovy 
Grape.grab seems to work

> groovyc Foo.groovy 

> java -cp $PATH:/opt/groovy/embeddable/groovy-all-1.7.0.jar:ivy-2.1.0.jar:. Foo 
Exception in thread ""main"" java.lang.NullPointerException: Cannot invoke method removeAll() on null object
	at org.codehaus.groovy.runtime.NullObject.invokeMethod(NullObject.java:77)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:45)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.NullCallSite.call(NullCallSite.java:17)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:241)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:225)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:51)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:44)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:143)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:155)
	at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:216)
	at groovy.grape.Grape.grab(Grape.java:131)
	at groovy.grape.Grape$grab.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at Foo.main(Foo.groovy:4)
{noformat}","osx 10.6 / JVM: 1.6.0_17
",codex22,louspringer,mattmcq,pschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 11 14:56:05 UTC 2013,,,,,,,,,,"0|i2cdbr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Feb/10 17:41;paulk;add code tags;;;","17/Feb/10 19:08;paulk;Put in place a guard to stop NPE and now I believe the real error is being shown:
{noformat}
Exception in thread ""main"" java.lang.RuntimeException: No suitable ClassLoader found for grab
...
at groovy.grape.GrapeIvy.chooseClassLoader(GrapeIvy.groovy:163)
...
at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:227)
{noformat}
;;;","17/Feb/10 20:15;mattmcq;Hey Paul, I added a check for the NPE as well and got the same 'real' error you just mentioned. Glad to hear it's not just on my machine (it was my first time changing the source for a big lib; wasn't sure if I did the compiling/re-jaring correctly.)  Thanks for looking into this so quickly!;;;","30/Dec/12 09:18;pschumacher;Still not working with 2.0.6.;;;","11/Oct/13 14:56;pschumacher;This works now. Maybe this was fixed by the change to make grapes/grab work with jdk8.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error trying to configure GroovyServlet to point to single groovy file for all URLs,GROOVY-4061,12815076,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,tcomer,tcomer,15/Feb/10 15:09,07/Apr/10 23:47,14/Jul/23 06:00,17/Feb/10 01:17,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,Groovlet / GSP,,,,0,,,,,,"When trying to configure the GroovyServlet to direct all request to a single groovy script to be able to have dynamic RESTful URLs, a java.lang.StackOverflowError is thrown. What seems to be happening is something is recursively calling the getResource() method on the AbstractHttpServlet over and over always appending BeanInfo onto the name of the file. I've attached a simple war file that demonstrates this. I've also included the log file as well.",Tomcat 6 / JDK 6,tcomer,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Feb/10 12:13;tcomer;AbstractHttpServlet.java;https://issues.apache.org/jira/secure/attachment/12722311/AbstractHttpServlet.java","15/Feb/10 15:09;tcomer;localhost.2010-02-15.log;https://issues.apache.org/jira/secure/attachment/12722500/localhost.2010-02-15.log","15/Feb/10 15:12;tcomer;test.war;https://issues.apache.org/jira/secure/attachment/12722501/test.war","15/Feb/10 15:12;tcomer;web.xml;https://issues.apache.org/jira/secure/attachment/12722616/web.xml",,,,,4.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 17 02:50:20 UTC 2010,,,,,,,,,,"0|i2cbtr:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"15/Feb/10 23:28;roshandawrani;What is happening here is that for the first access GroovyServlet/AbstractHttpServlet map ""/"" to ""rest.groovy"" and compiles rest.groovy fine. After that it tries to create a MetaClass object for the new class and in the MC init(), it tries to lookup its bean-info class (restBeanInfo.groovy) through the call to Introspector.getBeanInfo(Class<rest>). This look-up again goes through GroovyScriptEngine$ScriptClassLoader(), which again applies the resource-name-matching and now maps it ""/restBeanInfo.groovy"" to ""/rest.groovy"", and this keeps happening recursively.

Any suggestions on how to handle this special case?;;;","16/Feb/10 02:34;blackdrag;I think it is impossible to support this directly with GSE. The URLs GSE looksup are not page requests in the first place, they are lookups for groovy sources and classes. The compiler will always ask for classes that may not exist, but giving an error page here is wrong, since that is not what GSE needs. I think it would be better to make a gateway servlet, that redirects the requests to GroovyServlet by changing the name into the script name or by directly extending AbstractServlet and do a service method that calls the method correctly;;;","16/Feb/10 10:45;tcomer;I think I may have fixed the issue by modifying where the regex gets applied. Instead of doing it in the getResourceConnection() method, I moved the logic to the getScriptUri() method. When doing this, it makes 2 test cases fail, testGetResourceConnection_Replace1stFooWithBar() and testGetResourceConnection_ReplaceAllFooWithBar(), but that would be expected since the getResourceConnection() is no longer responsible for the regex replacement. I've attached the new AbstractHttpServlet for review.;;;","16/Feb/10 11:05;roshandawrani;I like the approach of the patch.

In getScriptUri(), shouldn't it also cover the pattern matching when the request is coming from RequestDispatcher.include() case (first ""return uri;"" case in getScriptUri())?;;;","16/Feb/10 12:12;tcomer;Good call. I've updated the AbstractHttpServlet to account for this.;;;","16/Feb/10 12:33;roshandawrani;Anyone sees any other issue with the patch? If not, I can apply it.;;;","16/Feb/10 13:58;guillaume;I haven't tried the patch with Gaelyk (the issue was coming from there initially), but I bet Tom has tried it and it solves his issue.
So no objection for applying the patch, on the contrary!;;;","16/Feb/10 19:11;tcomer;Yup, I tried it tonight with Gaelyk and it works just fine for me now.;;;","17/Feb/10 01:17;roshandawrani;Applied the patch. Thanks for providing it.

Pls let me know if the fix needs to be backported to 1.6.8 as well.;;;","17/Feb/10 02:50;guillaume;Excellent, Tom, thanks a lot for your contribution, this is very much appreciated!;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Unexpected compilation error with MapEntryExpression usage - groovy grammar issue?,GROOVY-4058,12814851,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,ait,roshandawrani,roshandawrani,14/Feb/10 21:19,07/Apr/10 23:45,14/Jul/23 06:00,30/Mar/10 02:22,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,Compiler,,,,0,,,,,,"The following code compiles fine:
{code}
import java.util.concurrent.*
class Test {
    def bar () {
        ExecutorService pool = null
        pool.submit(( Runnable ) [ run : { ""some statement""; 
            //println ""fishy print""
        }])
    }
}
{code}

But if I uncomment the print statement from inside the closure, like
{code}
import java.util.concurrent.*
class Test {
    def bar () {
        ExecutorService pool = null
        pool.submit(( Runnable ) [ run : { ""some statement""; 
            println ""fishy print""
        }])
    }
}
{code}
I get the following compilation error:
{noformat}
...\Try.groovy: 5: You tried to use a map entry for an index operation, this is not allowed. Maybe something should be set in parentheses or a comma is missing?
 @ line 5, column 36.
           pool.submit(( Runnable ) [ run : { ""some statement""; 
{noformat}

Here is the AST formed in 2 cases (2nd case has the wrong AST)

Case 1: (Successful compilation)
{noformat}
ArgumentListExpression[
    CastExpression[
        (java.lang.Runnable) 
            MapExpression[
                MapEntryExpression(key: ConstantExpression[run], value: ClosureExpression[]{...}
                )
            ]
    ]
]
{noformat}

Case 2: (Failing compilation)
{noformat}
ArgumentListExpression[
    BinaryExpression[
        left = ClassExpression[type: java.lang.Runnable]
        operation = ""[""
        right = MapEntryExpression(key: ConstantExpression[run], value: ClosureExpression[]{...})]]
{noformat}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 30 08:59:57 UTC 2010,,,,,,,,,,"0|i2cnhj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Feb/10 22:34;roshandawrani;I am wondering whether in indexPropertyArgs() rule, [key : value] should not be matched.

Does it make sense in any case to have a [x : ...] in the subscript operation?;;;","30/Mar/10 08:59;paulk;It would be nicer if we had a solution to this problem at the grammar level but that's a much harder fix. So, I have added a test in the meantime - if we can refactor at some point at least we shouldn't have this particular regression.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Power assert doesn't pretty-print groovy.lang.Reference content inside a closure inside an anonymous class,GROOVY-4051,12815045,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,gromopetr,gromopetr,11/Feb/10 13:29,17/Feb/10 12:04,14/Jul/23 06:00,17/Feb/10 12:04,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,,,,,,,0,,,,,,"{code}def y = [null]
def o = new Object() {
  def foo() {
    def c = {
      assert y[0]
    }
    c()
  }
}
o.foo(){code}

gives

{code}Caught: Assertion failed: 

assert y[0]
       ||
       |null
       groovy.lang.Reference@99d12cc
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 17 12:04:14 UTC 2010,,,,,,,,,,"0|i2bznb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Feb/10 14:13;roshandawrani;I think it has nothing to do with power assert feature's implementation as such. The issue is there because of the way closure classes are rendered when they are defined inside inner classes, as in the reported case.

Unlike regular closures, in such closure classes, Reference fields are not being defined. In a normal closure, ""y"" would be a reference field and loading that field at runtime ensures that if it is a holder (Reference ) field, it calls get() on it to return the value it is holding.

In the erroneous closure classes, since ""y"" is not defined as a holder field, the call at run time goes through CallSite.callGroovyObjectGetProperty(), and here it is not checked whether the value returned is a holder or not, so it simply returns the Reference object, resulting in the error reported.;;;","12/Feb/10 14:50;roshandawrani;Put another way, the provided code becomes equivalent to:
{code}
class Script {
    List y
    class AIC {
        Reference y
        class Closure$n {
            def doCall() {
                assert y[0] // getProperty(y) = owner.y == AIC.y (Reference)
            }
        }
    }
}
{code}
where getProperty() logic does not do the holder/Reference check, so simply returns the Reference field from AIC class.;;;","12/Feb/10 15:20;pniederw;Are you saying that this is a bug in the Groovy compiler? Otherwise, Reference will need special handling when rendering power assertions (provided we want to fix this issue). It's just one line of code.;;;","12/Feb/10 15:34;roshandawrani;Yes, I think it is a bug in the groovy compiler - in handling getProperty() in cases such as the one reported here

{code}
def y = [null]
def o = new Object() {
  def foo() {
    def c = {
      println y /* prints groovy.lang.Reference@.... */
    }
    c()
  }
}
o.foo()
{code}

The use of Reference is supposed to be behind-the-scenes in closures, but the output above shows that it is spilling out unhandled.

When the above is corrected, power-assert-pretty-print issue will go away too.;;;","12/Feb/10 15:38;pniederw;OK, so I won't make any changes to power assert code. Where are we going to track the compiler bug?;;;","12/Feb/10 15:39;roshandawrani;And I don't think 1-line forced-handling of Reference values(in ValueRecorder?) will be correct.

What if I then explicitly wrote
{code}
Reference ref = new Reference(""xx"")
assert ref == null
{code}

Instead of correctly getting
{noformat}
Caught: Assertion failed: 

assert ref == null
       |   |
       |   false
       groovy.lang.Reference@19bfb30
{noformat}
I will start getting
{noformat}
Caught: Assertion failed: 

assert ref == null
       |   |
       |   false
       ""xx""
{noformat}

Right?;;;","12/Feb/10 15:42;roshandawrani;I think tracing through that bug in compiler code will need some guidance from Jochen. I will need, at least. :-)

I am waiting for his comments to get some hint on where to start looking.;;;","12/Feb/10 15:46;pniederw;> in ValueRecorder?
I had planned to add that line to AssertionRenderer.valueToString().

> Right?
Yeah but I think this would have been acceptable because such a test is very unlikely to exist outside the Groovy code base.;;;","12/Feb/10 15:49;roshandawrani;>> Right?
  > Yeah but I think this would have been acceptable because such a test is very unlikely to exist outside the Groovy code base.

It's your choice. Because there is bigger issue involved there (property access in such scenarios), I didn't want to shortcut the fix into power assert code.;;;","12/Feb/10 15:52;pniederw;I'm all for fixing the real cause, so I won't make a change to the power assert code for now. Are you going to create a separate issue for the compiler bug?;;;","12/Feb/10 16:00;roshandawrani;Since there is only 1 underlying issue here anyway, I had not planned to create another issue. 

You think it is better to get the pretty-print issue out of the way now with that 1-line fix and then handle the compiler bug separately?

I am in pause mode actually till I hear from Jochen about this. May be he can clearly see where the issue is and then we can rightaway go away for the real fix instead of assert code workaround in the meantime :-);;;","12/Feb/10 16:03;pniederw;We should wait until Jochen weighs in. I don't consider the assert issue high priority.;;;","12/Feb/10 18:28;blackdrag;The implementation idea in ACG for power asserts was that when ever we get a value and we are in an assert, we save that value in the value recorder. 

Now I thought I did handle the Reference stuff there already, but it seems I am wrong. Of course we need to save the referenced value, not the reference itself... 

Now in case of a VariableExpression the code I have should work alright. The y in the y[0] should be one... I modified the code to
{code:Java}
def y = 1
def o = new Object() {
  def foo() {
    def c = {
      assert y == 1
      1
    }
    c()
  }
}
o.foo()
{code}
This assert should not fail, but it does! A ""println y"" shows that it prints a Reference. So I think the problem is actually not in ValueRecorder, or the power assert integration. I think it is a general compiler bug with annonymous inner classes. Probably the VariableExpression should have been marked for using a Reference but does not get marked. I am sure if we fix that, then the power assert will give the right message text automatically. What makes me wonder is that y[0] still seems to print null in the original example. This implies the marking is there... but somehow lost or ignored.

Does this help you a little Roshan?;;;","12/Feb/10 18:29;blackdrag;Ah yes... since this internal Reference usage should not be visible we should maybe consider this being a blocker for 1.7.1;;;","13/Feb/10 00:16;roshandawrani;Raising the priority to Blocker for 1.7.1.;;;","17/Feb/10 12:04;blackdrag;fixed now;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1.7.x's faster DGM loading system causes issues on Google App Engine,GROOVY-4049,12815029,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,guillaume,guillaume,11/Feb/10 10:15,16/Aug/12 10:07,14/Jul/23 06:00,12/Feb/10 01:23,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,,,,,0,,,,,,"The new system for improving faster startup of Groovy which loads DGM methods actually causes issue on Google App Engine, as it tries to load classes (referenced in DefaultGroovyMethods) which are not white listed on GAE.",Google App Engine,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 11 10:21:23 UTC 2010,,,,,,,,,,"0|i2bn13:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Feb/10 10:21;guillaume;Juriy provided a patch for this problem on the mailing-list:
http://markmail.org/thread/wtlfk3i6hz4ni3bn;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
waitForProcessOutput should also waitFor internally,GROOVY-4048,12812191,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jimjag,jimjag,11/Feb/10 08:32,07/Apr/15 19:13,14/Jul/23 06:00,19/Feb/10 06:38,1.6.7,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,groovy-jdk,,,,0,,,,,,"Related to GROOVY-3796, there is a race condition where someone could use waitForProcessOutput() and then call exitValue and get an 'java.lang.IllegalThreadStateException: process hasn't exited' error, since the actual process itself hasn't terminated. This can be worked around with a process.waitForProcessOutput(); process.waitFor(), but this is confusing since waitForProcessOutput also implies that we wait for *everything*.

This patch adds a specific waitFor() to waitForProcessOutput()","OS X, Ubuntu",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Feb/10 08:32;jimjag;wf.patch;https://issues.apache.org/jira/secure/attachment/12722612/wf.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Feb 19 06:38:42 UTC 2010,,,,,,,,,,"0|i2cc7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Feb/10 06:38;paulk;Added to trunk and 1_7_X. Thanks for the patch.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
1 == new Object() throws ClassCastException,GROOVY-4046,12815075,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,roshandawrani,cptnuss,cptnuss,10/Feb/10 08:05,19/Jul/16 11:34,14/Jul/23 06:00,10/Feb/10 13:23,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,1.7.1,1.8-beta-1,,,,,1,,,,,,"
Example 1:

assertFalse(new Object() == 1) // this is ok
assertFalse(1 == new Object()) // this throws a ClassCastException, because Groovy redirects the call to java.lang.Integer.compareTo(Integer i)



Example 2:

enum MyEnum { A, B, C }

assertFalse(new Object() == MyEnum.A) // this is ok
assertFalse(MyEnum.A == new Object()) // this throws a ClassCastException, because Groovy redirects the call to java.lang.Enum.compareTo(E e) where E extends java.lang.Enum<E>

",tested for 1.7.0 and 1.6.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7876,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Feb 06 15:36:07 UTC 2011,,,,,,,,,,"0|i2c8d3:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"10/Feb/10 13:23;roshandawrani;In the corner case of a Comparable instance being comparedTo an Object instance, the comparison made by DefaultTypeTransformation#compareToWithEqualityCheck() was becoming Object.isAssignableFrom(SomeComparableClass), which was not really serving any purpose, because all classes are assignable to Object. This meaningless condition was causing the issue in both the reported scenarios and has been fixed now.
;;;","06/Jul/10 16:55;pniederw;There seems to be a broader issue here: DefaultTypeTransformation.compareToWithEqualityCheck() assumes that instances of assignment-compatible classes are comparable. I don't think this assumption is safe, even for classes that obey the Comparable contract. For example:

{code}
class Foo implements Comparable<Foo> {
  int compareTo(Object other) {
    if (other.getClass() != Foo.class) throw new ClassCastException()
    0
  }
  
  boolean equals(Object other) {
      other.getClass() == Foo.class  
  }
}

class Bar extends Foo implements Comparable<Bar> {
  int compareTo(Object other) {
    if (other.getClass() != Bar.class) throw new ClassCastException()
    0
  }
  
  boolean equals(Object other) {
    other.getClass() == Bar.class  
  }
}

new Foo() == new Bar() // ClassCastException!
{code};;;","06/Feb/11 15:36;esumerfd;A potential ramification of this change is this failing test when the equals and Comparable interface exist in the same class.

// Groovy 1.8 b4
class EqualsCompareTest extends GroovyTestCase {

    void test_equals_along() {

        assert new EqualsOnly() == 1
    }

    void test_equals_and_compare() {

        assert new EqualsAndCompare() == 1
    }
}

class EqualsOnly {
    boolean equals(value) {
        1 == value
    }
}

class EqualsAndCompare implements Comparable {
    boolean equals(value) {
        1 == value
    }
    int compareTo(value) {
        1.compareTo(value)
    }
}
;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error in resolving inner class,GROOVY-4043,12815028,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,08/Feb/10 20:01,16/Aug/12 10:07,14/Jul/23 06:00,09/Feb/10 05:15,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,,,,,0,,,,,,"Originally reported by Alex on the groovy dev mailing list.

The following code fails to compile (Error: unable to resolve class B):

{code}
class A {
	static class B {}
}

class C extends A {
	B b
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 09 05:15:26 UTC 2010,,,,,,,,,,"0|i2bszr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Feb/10 05:15;roshandawrani;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"DGM#flatten(Collection, Closure) isn't using closure properly",GROOVY-4040,12811586,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,,06/Feb/10 17:36,07/Apr/15 19:13,14/Jul/23 06:00,06/Feb/10 19:02,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,1.7.1,1.8-beta-1,groovy-jdk,,,,0,,,,,,"DGM#flatten(Collection items, Closure flattenUsing) calls the flattenUsing closure but then adds the original item back into the result rather than the flattened item",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Feb 06 19:02:43 UTC 2010,,,,,,,,,,"0|i2cqg7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Feb/10 19:02;paulk;The existing tests were only working by fluke because all the closure examples returned a collection of items. There is now an additional example.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Closure meta class respondsTo(closure, ""doCall"") does not work",GROOVY-4038,12815065,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,misterd,misterd,04/Feb/10 06:42,07/Apr/10 23:45,14/Jul/23 06:00,03/Mar/10 10:48,1.5.7,1.5.8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"When running the following code:

Closure test = {String x -> println x};
println test.metaClass.respondsTo(test, ""doCall"");

The resulting output is: []

Which is incorrect, since the MOP for respondsTo(Object, String) states:
[...] if the implementing MetaClass responds to a method with the given name *regardless* of arguments.
But the Closure does respond to doCall(String), which can easily be verified using this code:

println test.metaClass.respondsTo(test, ""doCall"", ""Hello"");

which will output something similar to: [public MyClass$_myMethod_closure1.doCall(java.lang.String)]
which tells us, that the closure does respond to doCall(String).

Hence, this meta method, and all other meta methods named doCall - *regardless* of their parameters - aswell, should also be included in the list returned by respondsTo(Object,String).
",Only tested for Groovy 1.5.7 and 1.5.8 since i am unable to compile the project with groovy 1.8.0,misterd,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/Mar/10 04:35;roshandawrani;4038_v18x_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722266/4038_v18x_Patch.txt",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 03 10:48:28 UTC 2010,,,,,,,,,,"0|i2ck4v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Mar/10 02:21;roshandawrani;In fact, ClosureMetaClass does not handle ""respondTo"" call for any method name. For ex, even the following does not go through

{code}
closureObj.metaClass.respondsTo(closureObj, ""setResolveStrategy"")
{code}

This is happening because ClosureMetaClass does not do super.initialize() and hence its metaMethodIndex is always empty for any closure. So, all ""respondTo"" calls fail to find the matching method.

Anyone sees any issues if we start initializing with closure class info popoulated? Will it hit the performance significantly?

If it is not to be supported, may be, MetaObjectProtocol#respondsTo() documentation can be updated to tell that ClosureMetaClass do not support this call.;;;","03/Mar/10 02:36;guillaume;As a first step, I would say it'd be good to check if it has a significant (negative) impact on performance.;;;","03/Mar/10 03:21;blackdrag;The initialize call is what makes a MetaClass expensive in memory and in computing time. So given a test with low memory, were the MetaClass of the Closure is recreated constantly would show that. I think it might be more wise to do the initialization on demand instead. That means if respondsTo is called, it should call initialize, if that has not be done yet.;;;","03/Mar/10 03:26;roshandawrani;I like Jochen's idea. Filling it in advance may not be worth it, as respondsTo() is not something that will be frequently done.;;;","03/Mar/10 03:36;guillaume;Yup, very good point, better do it lazily if really needed, but not in advance as this is costly.;;;","03/Mar/10 04:35;roshandawrani;Attaching a patch for review.;;;","03/Mar/10 06:21;blackdrag;Why did you make the applyPropertyDescriptors method protected (from private)? As for the loadMetaInfo() method... why not remove that method and isntead call initiliaze()?;;;","03/Mar/10 06:28;roshandawrani;loadMetaInfo() had to be introduced because by the time respondsTo() is called, ClosureMetaClass initialized flag is set to true. So, if I simply call super.initialize(), it won't do anything because ClosureMetaClass#isInitialized() will return true. loadMetaInfo() temporarily sets initialized to false and then calls super.initialize() so that it does the meta-filling.

applyPropertyDescriptors() had to be made protected, because MetaClassImpl#applyPropertyDescriptors() calls addMetaBeanProperty(), for which ClosureMetaClass throws UnsupportedOperationException.;;;","03/Mar/10 08:07;blackdrag;ok then;;;","03/Mar/10 10:48;roshandawrani;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyClassLoader leaves file handles open,GROOVY-4037,12815034,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,blackdrag,veita,veita,04/Feb/10 06:21,17/Feb/10 13:01,14/Jul/23 06:00,17/Feb/10 10:03,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,,,class generator,,,,0,,,,,,"GroovyClassLoader leaves file handles open.

We use Groovy scripts within an application server. On systems that protect open files with locks (e.g. Windows) this bug prevents Groovy scripts from being redeployed.

The following code shows the problem:

{code}
public void test() throws Exception
{
  final File              l_fileScript;
  final GroovyClassLoader l_ldr;
  final GroovyCodeSource  l_cs;
  final Class<?>          l_classScript;

  l_fileScript = new File(""path/to/script1944A6CADCE5EBA2BE66D50EA1D8AE36562C645E.groovy"");

  l_ldr = new GroovyClassLoader();

  l_cs = new GroovyCodeSource(l_fileScript);

  l_cs.setCachable(false);

  l_classScript = l_ldr.parseClass(l_cs);

  return; // set breakpoint here
}
{code}

At the breakpoint the handle of the script file is still open.
",any,veita,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 17 13:01:18 UTC 2010,,,,,,,,,,"0|i2bsrz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"17/Feb/10 09:09;blackdrag;I tried your example on my Ubuntu system, but instead with debugging I used a extremely long sleep. I ensured before that I can use lsof to see the open file in an example that simply opens the file using a FileOutputStream. This worked. Next I treid to find the open file handle from your example, but this failed.

So far it seemed that the file handle will be closed again.

Then I changed the file to include an asset and suddenly the file is open. Now I know the file is reopened to make the power assert text and I guess the code to close them is missing. This means 1.6.8 is not affected by this problem too.;;;","17/Feb/10 10:03;blackdrag;should be fixed now;;;","17/Feb/10 10:14;roshandawrani;Jochen, know of any ""lsof"" equivalent for Windows as well?

When this issue got raised, I gave it a shot, but soon got stuck due to not knowing how to check if a file handle is open or not (on my Windows box).;;;","17/Feb/10 13:01;blackdrag;http://stackoverflow.com/questions/15708/lsof-equivalent-for-windows gives various ways to get that;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
null pointer exception from createissue() function,GROOVY-4036,12815046,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,siddh89,siddh89,04/Feb/10 02:30,07/Apr/10 23:52,14/Jul/23 06:00,04/Feb/10 02:33,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-02-04 02:30:54.0,,,,,,,,,,"0|i2byz3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Super method calls from anonymous classes sometimes fail,GROOVY-4035,12815052,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,gromopetr,gromopetr,03/Feb/10 13:53,07/Apr/10 23:47,14/Jul/23 06:00,04/Feb/10 06:26,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,,,,,0,,,,,,"{code}
class Foo {
  def foo(msg) {
  }
}

def z = new Foo() {

  def foo(Object msg) {
    return super.foo(msg);
  }

}

z.foo(""42"")
{code}

Caught: groovy.lang.MissingMethodException: No signature of method: test.foo() is applicable for argument types: (java.lang.String) values: [42]
Possible solutions: run(), run(), any(), any(groovy.lang.Closure), is(java.lang.Object), find(groovy.lang.Closure)
	at test.this$dist$invoke$4(test.groovy)
	at test$1.methodMissing(test.groovy)
	at test$1.foo(test.groovy:9)
	at test.run(test.groovy:14)
",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 04 06:26:13 UTC 2010,,,,,,,,,,"0|i2conr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Feb/10 06:26;roshandawrani;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Mixin's getClass() method replaces original getClass() implementation,GROOVY-4034,12815069,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,ldaley,ldaley,03/Feb/10 05:56,16/Jun/10 03:50,14/Jul/23 06:00,03/Mar/10 12:40,1.6.7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.9,,,,,,,0,,,,,,"{code}
class M {
    def doIt() {
        assert metaClass.owner.class == M // passes but shouldn't, should be T
    }
}

class T {}
T.mixin(M)
new T().doIt()
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 03 12:40:37 UTC 2010,,,,,,,,,,"0|i2buun:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Mar/10 00:38;roshandawrani;This issue is not there on 1.7 onwards (http://groovyconsole.appspot.com/script/76002). 

How about upgrading to 1.7.x instead of getting it fixed on 1.6.9 and upgrading to that (assuming that you need the fix and can upgrade for that :-) )?;;;","03/Mar/10 06:17;roshandawrani;Guillaume / Jochen, does this issue look worth porting to 1.6.9? 

The issue is not there on 1.7.x and trunk.;;;","03/Mar/10 06:42;guillaume;Yes, you can port it to 1.6 too.
I'm not yet 100% sure we'll do another 1.6.x, but till we don't do an 1.8, we should still port critical bug fixes to 1.6 at least.;;;","03/Mar/10 12:40;roshandawrani;Back-ported the fix.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
putAt and  put behave different on Maps,GROOVY-4029,12815072,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,kmuntau,kmuntau,02/Feb/10 02:00,07/Apr/10 23:46,14/Jul/23 06:00,09/Feb/10 11:40,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,1.7.1,1.8-beta-1,,,,,0,,,,,,"
Map m = [:]
//this is ok as LinkedHashMap supports null as key and value
m.put(null, null)

//this will throw an exception
m[null] = null
",,kmuntau,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"02/Feb/10 05:00;roshandawrani;v17x_DGM_New_Map_Method_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722255/v17x_DGM_New_Map_Method_Patch.txt","02/Feb/10 05:00;roshandawrani;v17x_MC_setProperty_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722496/v17x_MC_setProperty_Patch.txt","02/Feb/10 08:43;roshandawrani;v17x_Method_Selection_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722257/v17x_Method_Selection_Patch.txt",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 09 11:40:09 UTC 2010,,,,,,,,,,"0|i2cljb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Feb/10 02:07;kmuntau;this was found while porting an application from groovy version 1.6.3 to 1.7.0
;;;","02/Feb/10 03:46;roshandawrani;I looked a bit into it. 

m[null] = null selects DGM#putAt(Object, String, Object) over DGM#putAt(Map, Object, Object) because key in the subscript operator is supposed to be String. Because of that DGM selection, it goes to MetaClassImpl#setProperty(), which tries to use the key's hashcode in meta-property look-up in MethodIndex maps. Since the key is null, it results in NPE.

So,
Option 1) Specially handle key = null and MC.isMap = true in the beginning of MetaClassImpl#setProperty() and delegate it to Map.put(key, value)

Option 2) Introduce DGM#putAt(Map, String, Object) so that it gets selected over DGM#putAt(Object, String, Object).

Which way looks better?;;;","02/Feb/10 05:00;roshandawrani;Attaching both the potential patches for review.;;;","02/Feb/10 05:12;blackdrag;for null the most general class should be selected, and that is Object, not String. So if String is used, it is wrong here. That sounds like a method selection bug;;;","02/Feb/10 05:16;blackdrag;And indeed.... while
{code:Java}
def foo(Map x, Object o, Object p) {1}
def foo(Map x, String s, Object p) {2}
assert foo([:],null,null)==1
{code}
works, this fails
{code:Java}
def foo(Object o, Object p) {1}
def foo(String s, Object p) {2}
assert foo(null,null)==1
{code}
The later case is what is used to select the DGM method. So we have definitely a method selection bug here;;;","02/Feb/10 05:35;roshandawrani;Yes, method selection is the problem overall. I had first looked at the method selection area itself.

When MetaClassImpl#calculateParameterDistance() looks at both 
DGM(Map, Object, Object) and 
DGM(Object, String, Object), it first calculates the distance for DGM(Object, String, Object), finds the distance 0, and simply selects that method. 

It doesn't even calculate the distance for DGM(Map, Object, Object). That's where the error is coming from.;;;","02/Feb/10 08:43;roshandawrani;Jochen, here is another proposed patch, which fixes the method selection.

It now looks at parameter distances of all candidate methods and chooses the most specific one - instead of jumping out pre-maturely on seeing a distance of 0.;;;","03/Feb/10 09:17;roshandawrani;Jochen, do you see any issue with the parameter distance patch? Or shall I go ahead with it?;;;","04/Feb/10 07:05;blackdrag;Does it really fix the issue? Because distance 0 means a direct match, meaning there should be no other method which does fit it better. But I wonder why the distance is 0. It is just wrong that null causes a zero distance. Well, ok, if we say that null causes a zero distance, then of course there oculd be multiple methods with distance 0... but then the method selection would result in a method selection error. So for me the error here is not jumping out prematurely, it is that this should not give the distance 0 for mathching String agains null. Probably the method selection process needs a refinement here in using the distance to Object as distance element for this. not of the argument class as usal, but of the parameter class. Then String is less fitting than Object and the Object version should be selected;;;","04/Feb/10 07:22;roshandawrani;It seems to fix the issue. Didn't break any existing test and fixes the issue here. :-)

But you know better about the parameter distance calculations.

I can tell you where the distance 0 is coming from. Let's see if it helps.

When it calculates the distance for (null, null) against (String, Object), 

* it starts with objectDistance-- (dist = -1) and then adds 1 * 2 (dist = 1) (because String is 1 level away from Object). Dist offset for first parameter 1 << 23

* it then looks at next parameter (Object) - does objectDistance-- (dist = -1), nothing else gets added because parameter type Object is 0 level away from Object. Distance offset for this parameter -1 << 23.

Now overall for both the parameters, distance becomes 1 << 23 + -1 << 23 = 0, making it the perfect match, because of which it prematurely exits not even looking at other candidates.;;;","04/Feb/10 07:29;roshandawrani;It is already using the distance to Object as a distance element for this. And it is not looking at the argument as usual, but of the parameter class - because arguments are null.

I don't know why it first does that (objectDistance -- ) in the beginning when the argument is null. If it doesn't do that, then we won't have this (+x) + (-x) situation choosing wrong perfect matches. But I don't have the background of that objectDistance --.;;;","04/Feb/10 08:07;blackdrag;if any partial distance lower than 0 is returned, then this is absolutely wrong. So the distance calculation for null is wrong. 1 is right for String, but for object it should return 0, not -1. 

As of why there is objectDistance -.... no idea, maybe a relict from a refactoring... and it made sense back then.;;;","04/Feb/10 08:33;roshandawrani;The partial distance of -1 << 23 is coming due that objectDistance --, which makes it -1 to being with when it deals with nulls.

If you also suspect that it may not make sense now, may be I will try removing that to attempt the 4th patch. :-);;;","04/Feb/10 09:45;blackdrag;yes, please ;);;;","04/Feb/10 11:40;roshandawrani;I removed objectDistance--. Now there is no partial < 0 distance and it fixes the issue.

Below is the patch - 4th time lucky?

{code}
Index: src/main/org/codehaus/groovy/runtime/MetaClassHelper.java
===================================================================
--- src/main/org/codehaus/groovy/runtime/MetaClassHelper.java	(revision 19174)
+++ src/main/org/codehaus/groovy/runtime/MetaClassHelper.java	(working copy)
@@ -303,8 +303,6 @@
             // choose the distance to Object if a parameter is null
             // this will mean that Object is preferred over a more
             // specific type
-            // remove one to dist to be sure Object is preferred
-            objectDistance--;
             Class clazz = parameter.getTheClass();
             if (clazz.isPrimitive()) {
                 objectDistance += 2;
Index: src/test/groovy/bugs/Groovy4029Bug.groovy
===================================================================
--- src/test/groovy/bugs/Groovy4029Bug.groovy	(revision 0)
+++ src/test/groovy/bugs/Groovy4029Bug.groovy	(revision 0)
@@ -0,0 +1,9 @@
+package groovy.bugs
+
+class Groovy4029Bug extends GroovyTestCase {
+    void testAddNullKeyEntryInMapUsingSubscriptNotation() {
+        Map m = [:]
+        m[null] = null
+        assert m.size() == 1
+    }
+}
\ No newline at end of file
{code}
;;;","05/Feb/10 14:42;roshandawrani;Hi Jochen. 

Shall I apply this last patch (not doing objectDistance-- to not have any -ive partial distances)?;;;","09/Feb/10 05:01;roshandawrani;4 patches and more than that requests for final review. 

This JIRA should really be closed by now :-);;;","09/Feb/10 05:07;blackdrag;sorry, yes, zhe patch is fine;;;","09/Feb/10 11:40;roshandawrani;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,
Inner classes - Constructor calls with named arguments don't get implicit this reference passed as 1st argument,GROOVY-4028,12813640,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,01/Feb/10 07:06,14/Aug/13 03:57,14/Jul/23 06:00,01/Feb/10 09:52,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,,,,,0,,,,,,"Groovy doesn't yet support setting properties on (non-static) inner classes using named arguments, as in code below
{code}
class MyOuterClass {
    def foo() {
        def ic = new MyInnerClass(fName: 'Roshan', lName: 'Dawrani')
    }
    class MyInnerClass {
        def fName
        def lName
    }
}
def oc = new MyOuterClass()
oc.foo()
{code}
The code above fails with the message
{noformat}
failed to invoke constructor: public MyOuterClass$MyInnerClass(MyOuterClass) with arguments: [] reason: java.lang.IllegalArgumentException: wrong number of arguments
{noformat}
indicating that the implicit ""this"" reference is not being passed as the first argument.

Supporting above usage may require significant changes possibly. 

The bit related to ""this"" not being passed implicitly can be corrected in the meantime - so that at least the following works fine
{code}
class MyOuterClass {
    def foo() {
        def ic = new MyInnerClass(fName: 'Roshan', lName: 'Dawrani')
    }
    class MyInnerClass {
        Map propMap
        def MyInnerClass(Map propMap) {
            this.propMap = propMap
        }
    }
}
def oc = new MyOuterClass()
oc.foo()
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 01 09:52:47 UTC 2010,,,,,,,,,,"0|i2brgn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Feb/10 09:52;roshandawrani;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy interfaces allow methods with full body?,GROOVY-4025,12815059,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,31/Jan/10 11:45,14/Aug/13 03:57,14/Jul/23 06:00,01/Mar/10 00:24,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.2,1.8-beta-1,,,,,,0,,,,,,"The compilation of the following code goes through
{code}
interface ITest {
    def foo(a, b) {
        return a + b
    }
}
{code}

The bytecode of the interface, however, has the correct abstract method
{code}
public abstract Object foo(Object paramObject1, Object paramObject2);
{code}

It should not allow the full methods only to reject their bodies later.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 01 00:24:14 UTC 2010,,,,,,,,,,"0|i2cpyf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Feb/10 22:21;roshandawrani;The following compiles too:
{code}
abstract class Test {
    abstract foo(a, b) {
        return a + b
    }
}
{code};;;","01/Mar/10 00:24;roshandawrani;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"ClassFormatError when using the name including ""-"" sign",GROOVY-4020,12813602,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,trongtt,trongtt,29/Jan/10 06:36,22/May/22 19:43,14/Jul/23 06:00,22/May/22 19:43,1.6.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,5.0.0-alpha-1,,,Compiler,,,,4,ClassFormatError,,,,,"I'm not sure if there any constraint with the name parameter before passing to GroovyCodeSource but it is raising an exception if the name includes ""-"" sign :

GroovyCodeSource gcs = new GroovyCodeSource(inputStream, ""file-name.gtmpl"", ""/groovy/shell"");

Here is the exception :

Caused by: java.lang.ClassFormatError: Illegal class name ""File-name"" in class file File-name
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:616)
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124)
        at groovy.lang.GroovyClassLoader.access$200(GroovyClassLoader.java:54)
        at groovy.lang.GroovyClassLoader$ClassCollector.createClass(GroovyClassLoader.java:482)
        at groovy.lang.GroovyClassLoader$ClassCollector.onClassNode(GroovyClassLoader.java:499)
        at groovy.lang.GroovyClassLoader$ClassCollector.call(GroovyClassLoader.java:503)
        at org.codehaus.groovy.control.CompilationUnit$10.call(CompilationUnit.java:728)
        at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:925)
        at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:462)
        at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:278)

It seems that the name parameter is used for createing Class in Java, so it must be a binary name as defined by the Java Language Specification. If so, the name would be validated and converted to good one ? Or I must to take care of that myself before using GroovyCodeSource ?",,aaron.j.garcia,emilles,paulk,sflanigan,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7670,,,,GROOVY-5760,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 22 19:43:15 UTC 2022,,,,,,,,,,"0|i2bnc7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jan/10 07:39;roshandawrani;Yes, the name that you pass to GroovyCodeSource is used to come up with the class name of the script class that you parse using that GroovyCodeSource.

The behavior reported (class loader rejecting such classes with invalid names with ClassFormatError) seems to be JVM specific.

I am on Windows XP with following Java 1.5.0_04 and for me the class loading does not fail.

Should we validate the class names and reject the invalid ones?;;;","29/Jan/10 10:07;trongtt;a validation is needed i think.

if the class name is wrong, is there any reason to keep you to automatically convert it to good one ?;;;","30/Jan/10 05:21;roshandawrani;Jochen, what do you think? Can we reject the invalid class names or convert them into good ones? 

I think I have seen at least one place in groovy where invalid class names are converted.;;;","30/Jan/10 16:46;blackdrag;if we convert the question is to what.;;;","31/Jan/10 20:21;trongtt;does the GROOVY-3054 relate to this problem ?;;;","31/Jan/10 22:38;roshandawrani;Not really. 

GROOVY-3054 seems more about extracting just the file name part from the whole path of the script file. So, if you have c:/groovy/MyScript.groovy, it removes ""c:/groovy/"" from the front and "".groovy"" from the end and comes up with MyScript as the class name. It, kind-of, assumes that file name portion itself will be a valid one, and not like ""file-name.gtmpl"" - that is the portion that needs to be fixed now.;;;","17/Apr/12 02:33;nicolas raoul;I can confirm this on Ubuntu 2011.04 with bash and Groovy 1.7.4 JVM: 1.6.0_22:

$ groovy xmlslurper-url-bug.groovy
Caught: java.lang.ClassFormatError: Illegal class name ""xmlslurper-url-bug"" in class file xmlslurper-url-bug
$ mv xmlslurper-url-bug.groovy xmlslurperurlbug.groovy
$ groovy xmlslurperurlbug.groovy
Hello World;;;","18/Apr/12 16:26;aaron.j.garcia;I'm having this exact same issue.  I'm trying to make a Groovy CGI Script, and I want to call it ""test-groovy.cgi"".  I have to do one of two things:

1) Make a class definition inside of test-groovy.cgi with a good name like TestGroovy, and a main method.  
2) Rename my file to testGroovy.cgi.

I think a good solution would be to just remove the ""-"" from the file name when creating the generated class name.  ;;;","18/Apr/12 19:15;paulk;I think Roshan's suggestion of reusing {{org.codehaus.groovy.bsf.GroovyEngine#convertToValidJavaClassname()}} is the way to go. This would not remove characters like '-' but instead replace them with '_'. Which would be a potential problem for scripts which somehow already had such a class with an underscore - but such systems would already break under BSF anyway. Any objections?

I also think the method should be moved into some util class outside of BSF and then called from BSF and wherever else it is needed.;;;","19/Apr/12 00:17;blackdrag;If we change the name it is not bijective any more. Well, being bijective is nice, but maybe not needed. Though having 2 possible source names for a given class name is one thing, having many more possibilities another. As soon as you have one script depending on another, that kind of name mangling will cause a problem. In https://blogs.oracle.com/jrose/entry/symbolic_freedom_in_the_vmsuggests to use an escaping mechanism instead. But the problem is that '-' is not part of that. Still we could take the idea and for example use \\ + UTF16 hexadecimal number. That would then allow a 1:1 encoding and supports any UTF16 character;;;","22/May/22 19:43;emilles;https://github.com/apache/groovy/commit/2691fb0d2b745a7cc6647edd09a71a3831ffa460;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Single super constructor argument is casted to array if super constructor has vararg parameter,GROOVY-4016,12815048,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,gromopetr,gromopetr,27/Jan/10 12:18,08/Jul/12 04:51,14/Jul/23 06:00,25/Jun/12 10:52,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8.7,2.0.0,,Compiler,,,,0,,,,,,"{code:Java}
class Foo {
  def Foo(String... s) { }
}
class ImplOneParameter extends Foo {
  def ImplOneParameter(String s) {
    super(s)
  }
}
class ImplArray extends Foo {
  def ImplArray(String[] s) {
    super(s)
  }
}


new ImplArray(""String"")
new ImplOneParameter(""String"") //fails with CCE
{code}
The same dispatch as for usual method calls should apply.",,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4122,GROOVY-4015,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 25 10:52:17 UTC 2012,,,,,,,,,,"0|i2c1uf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Jan/10 09:46;roshandawrani;The ClassCastException part of this issue has been fixed under GROOVY-4015.

What is remaining now is that super(""String"") call to Foo(String...s) is becoming equivalent to ""String"" as String[] and reaching the vararg String[] of Foo#<init>() as [S, t, r, i, n, g].
;;;","28/Jan/10 09:59;roshandawrani;Why is it that this()/super() calls are handled specially and don't go through the callsites as normal method calls and constructor invocations do?

Because of special handling done there for this()/super() calls, the ParameterTypes#correctArguments() logic, which takes care of varargs in case of usual method calls, will need to be replicated there, is it?;;;","28/Jan/10 11:09;blackdrag;They cannot go through normal callsites, because an invokespecial is needed for that. And that invokespecial needs to be comming from the subclass. What the groovy compiler does is generating a table of super(..) calls if super is used, one for each constructure of the super class. Then the arguments are used to select the right contructor and the final call is then done using normal java bytecode with invokespecial. So not only do you need to coerce the arguments, you also need to but them on the stack according to what java needs.

About your comment before... do you tell em that foo(""String"") reaches foo(String[]) with an String[], that consists of the strings ""S"",""T"",""R"",""I"",""N"",""G""? Because that certainly is wrong. It should be exactly an String[] of length one, containing ""String"" as sole element.;;;","28/Jan/10 11:17;roshandawrani;Yes Jochen, that is what I meant - that ""String"" is reaching foo(String...s) as an array of six 1-character strings {""S"",""t"",""r"",""i"",""n"",""g""}.

We will need to put ParameterTypes#correctArguments() kind of logic (that deals with varargs for callsite based calls) in ASM#visitSpecialConstructorCall() as well (where it generates the bytecode instructions for the invokespecial based invocations that you explained), right?

""String"" is reaching as {""S"",""t"",""r"",""i"",""n"",""g""} because to get rid of ClassCastException, the ""asType"" coercion is happening now and it is effectively (""String"" as String[]) that gets passed.;;;","28/Jan/10 11:46;blackdrag;it is reaching that as such array now, right? Because that is something we absolutely need ot fix. 

I think the asType coercion is maybe not the right thing. I am sorry that I gave my ok now. Because as I realize now, asType coercion is used for the as operator while the maximum we want to have would be a groovy cast. Neither a cast nor asType are there to handle vargs. Usually the way of doing things here is the following:

pack all arguments in an array, use that to decide what constructor to call, return a new coerced array, that is then unpacked und used for the method call. What happens currently is that we probably only change the arguments of the array. But since we need to handle vargs, we need the ability to return a new array. 

So some method in ScriptBytecodeAdapter is needed that does the coercion. Along with that you should probably undo the a change for 4015, because this extended logic here will do what is needed in a much better way and does not falsify the cast with strang asType method calls. In the end the coercion logic for MetaMethods will be dulpicated this way yes. Before Alex this kind of code was in MetaClasselper as static method, but this is no longer available and doing so now is maybe not the best idea too. ;;;","28/Jan/10 11:56;roshandawrani;It's not a problem - I will undo the 4015 fix. Good that 4015 and 4016 are reported at the same time. Better to catch this issue sooner than later.

So, just to recapture what you have suggested:

1) Undo the 4015 fix and from ""doConvertAndCast"" go back to ""doCast"" logic.

2) Introduce a new doCoerceAndCast method in SBA that does MetaMethod like handling of varargs.

3) Switch from ""doCast"" to this new ""doCoerceAndCast"" in ASM#visitSpecialConstructorCall();;;","28/Jan/10 12:10;blackdrag;Atm we have selectConstructorAndTransformArguments in ScriptBytecodeAdapter. Looking further into the code, the returned int indicates also if the method was vargs (MetaClassImpl). I think in that case the array is supposed to store the new array as first argument and unrolling of the internal array has to happen. This part exists in the design, it is just not implemented yet.. Using the original or a new array to store the coerced arguments is also no big deal.

So I think no new method is needed, just filling the gaps is. ;;;","28/Jan/10 12:16;roshandawrani;I will need to see how the returned int tells that a var args method was found, new array, unrolling, etc. Most of the last comment just bounced off me :-)

I will go through SBA#selectConstructorAndTransformArguments() and ASM#visitSpecialConstructorCall() again a bit later to try to understand your last comment better.

If no new method is required, I won't add one - I promise ;-);;;","28/Jan/10 13:00;blackdrag;The important method is in MetaClassImpl:
{code:Java}
    public int selectConstructorAndTransformArguments(int numberOfConstructors, Object[] arguments) {
        //TODO: that is just a quick prototype, not the real thing!
        if (numberOfConstructors != constructors.size()) {
            throw new IncompatibleClassChangeError(""the number of constructors during runtime and compile time for "" +
                    this.theClass.getName() + "" do not match. Expected "" + numberOfConstructors + "" but got "" + constructors.size());
        }

        if (arguments == null) arguments = EMPTY_ARGUMENTS;
        Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
        MetaClassHelper.unwrap(arguments);
        CachedConstructor constructor = (CachedConstructor) chooseMethod(""<init>"", constructors, argClasses);
        if (constructor == null) {
            constructor = (CachedConstructor) chooseMethod(""<init>"", constructors, argClasses);
        }
        if (constructor == null) {
            throw new GroovyRuntimeException(
                    ""Could not find matching constructor for: ""
                            + theClass.getName()
                            + ""("" + InvokerHelper.toTypeString(arguments) + "")"");
        }
        List l = new ArrayList(constructors.toList());
        Comparator comp = new Comparator() {
            public int compare(Object arg0, Object arg1) {
                CachedConstructor c0 = (CachedConstructor) arg0;
                CachedConstructor c1 = (CachedConstructor) arg1;
                String descriptor0 = BytecodeHelper.getMethodDescriptor(Void.TYPE, c0.getNativeParameterTypes());
                String descriptor1 = BytecodeHelper.getMethodDescriptor(Void.TYPE, c1.getNativeParameterTypes());
                return descriptor0.compareTo(descriptor1);
            }
        };
        Collections.sort(l, comp);
        int found = -1;
        for (int i = 0; i < l.size(); i++) {
            if (l.get(i) != constructor) continue;
            found = i;
            break;
        }
        // NOTE: must be changed to ""1 |"" if constructor was vargs
        return 0 | (found << 8);
    }
{code}

If you take the last line, then you see that found is shifted by 8 and if you look into the bytecode then you will see that there is a backshift. So if the first bit is set, then varargs transformation had been applied. So in bytecode you need to first do x&1!=0 to see if the vargs transform had been used (xbeing the return value of the method). If it is 0 then the current logic applies, if not, then we can for example (not yet implemented!) store a new array in element 0, which contain all arguments transformed for the vargs. I would suggest that in general, but for backwarts compatibility it is better to use these two ways. Also it is not very complicated, since the unroling logic can be reused, just the used array is different. ;;;","28/Jan/10 13:32;roshandawrani;I will spend more time on that, but that is one difficult method to understand.

* What purpose do 2 consecutive calls to chooseMethod(""<init>"", constructors, argClasses) serve?

* If there were multiple constructors defined, how does the index of the constructor (that is then used in ""0 | (found << 8)"") indicate whether the constructor uses varargs or not.
    * Or, is ""// NOTE: must be changed to ""1 |"" if constructor was vargs"" really saying that varargs handling in the constructor selection is un-implemented in MC#selectConstructorAndTransformArguments() as well, and when implemented, the return value should be changed to ""1 | (found << 8)""? If that is the case, then varargs handling will have to be implemented both in MC#selectConstructorAndTransformArguments() as well as in ASM#visitSpecialConstructorCall();;;","28/Jan/10 14:51;blackdrag;Oh.... that is avery good question... I have absolutely not idea. Doesn't look right to me.The return value does not yet indicate if a varargs transform happened. This needs implementation. And yes, in that case 1 | (found << 8) should be done... of course the argument array needs to bechanged before. 

ASM#visitSpecialConstructorCall() needs to provide code to recognize that bit being set and unroll a different array then. But that varargs handling is different from what is to be done in MC#selectConstructorAndTransformArguments(). Because this code needs to preapre the array only.;;;","28/Jan/10 15:03;roshandawrani;Jochen, I am a bit skeptical about making changes without clearly understanding exactly what is happening in MC#selectConstructorAndTransformArguments() and why. I don't want to break more than I make there. There are too many small-small bits I don't understand in that method - like the sorting based on type descriptors, role of index of constructor chosen, etc. If I don't clearly get the current picture of it, I will give this issue a pass most probably.

In that case, do you think it will be better to undo 4015 and go back to ClassCastExceptions? Or, can that fix be kept so that at least we are half-way there in supporting this()/super() with non-matching argument/parameter types? It's only in corner cases like var arg usage here that behavior may be buggy until 4016 gets solved properly.

If you think it will be better to go pre-4015 state, I can just undo that for now.;;;","29/Jan/10 03:28;blackdrag;I think it is probably best to undo 4015 and make it a duplicate of this one;;;","29/Jan/10 03:30;roshandawrani;Sounds good. I will do that.;;;","29/Jan/10 04:05;roshandawrani;Jochen, I have undone the fix of 4015 and marked that as duplicate of this one.

When this issue is fixed, it must be ensured that GROOVY-4015 scenario is handled as well. Probable the testcase can be reused later from MethodSelectionTest.groovy's history.

Sorry about a little mess that I have created here, but I had no idea about 4016 when I was working on 4015 :-(;;;","25/Jun/12 10:52;blackdrag;this issues seems to be fixed since 1.8.0;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyScriptEngine.loadScriptByName returns anonymous inner classes on second invocation/reload,GROOVY-4013,12815047,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,mpriatel,mpriatel,26/Jan/10 22:18,07/Apr/10 23:46,14/Jul/23 06:00,27/Jan/10 06:51,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,class generator,Compiler,,,0,,,,,,"When using GroovyScriptEngine to create classes, invoking loadScriptByName twice on the same source file will return an anonymous inner classes on the second invocation (eg, reloading classes).


class MySwingPanel extends FrameworkPanel
{
   def initPanel()
   {
      def b = new Button('click me')
      b.addActionListener( new ActionListener(){
         // implementation code...
      })
   }
}


GroovyScriptEngine gse ...
gse.loadScriptByName('myswingpanel.groovy') // returns MySwingPanel

// now reload everything

gse.getGroovyClassLoader().clearCache();
gse.loadScriptByName('myswingpanel.groovy') // returns MySwingPanel$1


For now the workaround in my project is to just create a new instance of GroovyScriptEngine.


http://old.nabble.com/loading-multiple-classes-with-loadScriptByName----bug-or-feature--td27252081.html",,mpriatel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 27 06:51:34 UTC 2010,,,,,,,,,,"0|i2bsjb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jan/10 06:51;roshandawrani;Fixed. GSE doesn't cache the dependencies of the inner classes anymore.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
java.lang.ArrayStoreException thrown on trying to execute a list,GROOVY-4012,12815071,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,paulk,russel,russel,26/Jan/10 09:26,07/Apr/15 19:12,14/Jul/23 06:00,01/Feb/10 20:09,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,,,,,0,,,,,,"The script:
{code}
directory = new File ( 'tmp' )
println ( directory.path )
[ 'sh' , '-c' , ""${directory.path} && ls"" ].execute ( ).waitFor ( )
{code}
casues the output:
{code}
tmp
Exception thrown
26-Jan-2010 15:23:41 org.codehaus.groovy.runtime.StackTraceUtils sanitize
WARNING: Sanitizing stacktrace:
java.lang.ArrayStoreException
	at java.lang.System.arraycopy(Native Method)
	at java.util.ArrayList.toArray(ArrayList.java:328)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.execute(DefaultGroovyMethods.java:7511)
	at org.codehaus.groovy.runtime.dgm$163.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:270)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:52)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:121)
	at ConsoleScript1.run(ConsoleScript1:3)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:264)
	at groovy.lang.GroovyShell.run(GroovyShell.java:513)
	at groovy.lang.GroovyShell.run(GroovyShell.java:170)
	at groovy.lang.GroovyShell$run.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:857)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:616)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:66)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:151)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:616)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:88)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:272)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:886)
	at groovy.lang.Closure.call(Closure.java:276)
	at groovy.lang.Closure.call(Closure.java:271)
	at groovy.lang.Closure.run(Closure.java:354)
	at java.lang.Thread.run(Thread.java:636)

java.lang.ArrayStoreException
	at ConsoleScript1.run(ConsoleScript1:3)
{code}
which seems a bit mean.",Groovy Trunk as at 2010-01-25,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3273,,,,,,"01/Feb/10 18:59;GROOVY-4012__java_lang_ArrayStoreException_thrown_on_trying_to_execute_a_list.patch;https://issues.apache.org/jira/secure/attachment/12722498/GROOVY-4012__java_lang_ArrayStoreException_thrown_on_trying_to_execute_a_list.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 01 20:09:17 UTC 2010,,,,,,,,,,"0|i2c827:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jan/10 10:56;roshandawrani;Should be solved, I guess. In the meanwhile, will the following workaround be acceptable?
{code}
directory = new File ( 'tmp' )
println ( directory.path )
[ 'sh' , '-c' , ""${directory.path} && ls"" as String].execute ( ).waitFor ( )
{code};;;","26/Jan/10 11:03;roshandawrani;Looking a bit more into it, the javadoc of the execute() method says
{noformat}
 * Executes the command specified by the <code>String</code> list that is the parameter.
 * The first item in the list is the command the others are the parameters. All entries
 * must be Strings.
{noformat}

That way the method call being made is invalid as one list member is a GString.

Do we want to give special handling to GString and allow String/GStrings in the list that process accepts?;;;","26/Jan/10 11:47;russel;Roshan,  Thanks for sussing what the actual source of the problem is.  A few disconnected but related thoughts:

The workaround works for me in the short term but I think should be treated as unacceptable in the medium to long term.

Another workaround is to do:
{code}
[ 'sh' , '-c' , directory.path + ' && ls' ].execute ( ).waitFor ( )
{code}

Users are generally a bit blasé about String and GString so if a function/method is going to be particular then there needs to be good feedback to the user so they don't get confused.

The error message here is, as far as the user is concerned, totally disconnected from anything to do with their code -- even though their code is the progenitor of the problem.  This failure really does need fixing sooner rather than later.

If execute requires Strings, should it force interpretation of GStrings?

When does the GString need to be interpreted?  Is it actually necessary for the execute method to enforce the parameters being Strings?

Overall I have no problem with a function/method insiusting on String and disallowing GStrings, but in such a situation, the function/method really must implement type checking and feedback to the user regarding API usage failures.
;;;","26/Jan/10 11:55;roshandawrani;Let's wait for others views - on whether it is better to allow GStrings in addition to Strings in execute parameters or to reject the parameters with a more informative message. The fix itself should be the easier part.

I personally favor - GStrings/Strings to be allowed and also add some type checking of parameters to throw out a more informative error message when any other type is encountered.;;;","28/Jan/10 06:38;roshandawrani;Jochen, any comments on this one?

Thanks.;;;","28/Jan/10 07:19;blackdrag;If I am right, then the method used was until recently this:
{code:Java}
    public static Process execute(List commandList) throws IOException {
        final String[] commandArray = new String[commandList.size()];
        Iterator it = commandList.iterator();
        for (int i = 0; it.hasNext(); ++i) {
            commandArray[i] = it.next().toString();
        }
        return execute(commandArray);
    }
{code}

Now I am seeing this:
{code:Java}
    public static Process execute(final List<String> commands) throws IOException {
        return execute((String[]) commands.toArray(new String[commands.size()]));
    }
{code}
This change is not equal, because the old code made a String conversion, the new code expects Strings. 

To be exact it is even wrong calling this method using a List<Object>. Normally Java would prevent that, but Groovy does not.;;;","28/Jan/10 07:35;roshandawrani;Yes, seems like a recently introduced change.

And all overloads of DGM#execute(List, ....) are affected by it.

Although earlier javadoc and implementation were not equivalent. Javadoc said all list items must be strings and then it forced the string conversion. Had it been in sync with the documentation, the problem would have surfaced earlier.

Do we wait for Paul's feedback? Or, can we make it same as before by forcing a toString() conversion?;;;","28/Jan/10 07:50;blackdrag;The change was 19006. According to the docu this change was not wrong, because the docu said it needs a String. I suggest to undo the change, to change the documentation and to leave a comment in the code as of why this is done - to avoid regression;;;","28/Jan/10 07:58;roshandawrani;It was wrong (not in sync with the doco) in the sense that it said it needed list of string, but even if list was made up of other types, it happily converted them. It wasn't enforced that all list members were strings - say be rejecting calls that passed list having members of other types.

If the calls were made ideally with lists of strings, we will not have any issue even now.

I think it may be better to hear back Paul's views on this to avoid to-and-fro changes on this piece of code.;;;","30/Jan/10 20:38;paulk;Hi guys, been on holidays - sorry for delay in replying.

We can go back to Object but that feels less intuitive and then what about String[] and String variations?

A middle ground would be to go with CharSequence which would happily cater for GString. We would still need to (hopefully in one spot) apply the toString() before calling exec(). Relevant signatures would be:

{code}
execute(CharSequence command)
execute(CharSequence command, CharSequence[] envp, File dir)
execute(CharSequence command, List<CharSequence> envp, File dir)

execute(CharSequence[] commands)
execute(CharSequence[] commands, CharSequence[] envp, File dir)
execute(CharSequence[] commands, List<CharSequence> envp, File dir)

execute(List<CharSequence> commands)
execute(List<CharSequence> commands, CharSequence[] envp, File dir)
execute(List<CharSequence> commands, List<CharSequence> envp, File dir)
{code}

I think this is a nicer API. Removes inconsistency between {{String[]}} vs {{List<Object>}} but still covers the GString case.
To combat calls from Groovy using the old style we would need some pre-checking of the params with a nice error message.

It would still be a regression though if anyone is currently relying on the toString() from Object behavior. Ugly if they are but not impossible. 

;;;","01/Feb/10 18:59;paulk;potential patch - causing build problems on my machine though - not sure if it is something local or not - would welcome any feedback;;;","01/Feb/10 20:06;paulk;problem with last patch was due to primitiveTypes needing CharSequence[] during dgminfo loading but now considering reverting to previous solution as CharSequence doesn't really give us anything over String with normal Groovy coercion.;;;","01/Feb/10 20:09;paulk;Reverted to previous approach of having List instead of List<String> and using toString() to convert. Also, did some minor tidying up and doco fixes.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
XmlParser wraps nested elements in extra ArrayList,GROOVY-4010,12815014,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,james.cookie,james.cookie,05/Jan/10 04:34,19/Feb/10 07:12,14/Jul/23 06:00,19/Feb/10 07:12,1.6.7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,1.7.1,,,,,,6,,,,,,"When using XmlParser we are experienceing different behaviour within Grails 1.2 than directly using Groovy 1.6.7. The issue manifests itself when accessing nested elements in a document.

example, this works fine from within GroovyConsole 1.6.7:

{code}
def XML = '''<channel>
  <item id=""1""/>
  <item id=""2""/>
  <item id=""3""/>
</channel>'''
assert 3 == new XmlParser().parseText(XML).item.size()
assert 3 == new XmlParser().parseText(""<rss>$XML</rss>"").channel.item.size()
{code}

Here is a test case that passed under Grails 1.1.1 but fails under 1.2:
{code}
class XMLUnitTests extends GroovyTestCase {
    def XML = '''
        <channel>
          <item id=""1""/>
          <item id=""2""/>
          <item id=""3""/>
        </channel>
    '''

    void testOneLevel() {
        def records = new XmlParser().parseText(XML)
        assertEquals 3, records.item.size()
    }

    void testTwoLevels() {
        def records = new XmlParser().parseText(""<rss>$XML</rss>"")
        assertEquals 3, records.channel.item.size()
    }
}
{code}

","Grails 1.2, Groovy 1.6.7",biehl,brownj,cazacugmihai,fikus,hartsock,kaaloo,msmolyak,ttop,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Jan/10 08:11;guillaume;xmlparserissue-bug-report-27012010.zip;https://issues.apache.org/jira/secure/attachment/12722550/xmlparserissue-bug-report-27012010.zip",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 19 07:12:05 UTC 2010,,,,,,,,,,"0|i2ci07:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"05/Jan/10 04:38;james.cookie;Note:
The test case above works in Intellij, it only fails when using 'grails test-app'

Workaround:
Flatten the list to make the test pass i.e.: assertEquals 3, records.channel.item.flatten().size()



;;;","05/Jan/10 06:06;kaaloo;Oh I'm glad you posted this, I ran into this one last night.;;;","06/Jan/10 19:01;ttop;I'm also seeing some XmlParser weirdness, see GRAILS-5670.;;;","25/Jan/10 08:03;graemerocher;I have stepped debugged into Grails code and Grails is doing nothing special with Groovy's XmlParser. It seems to me to be a callsite caching bug, which would explain why the examples pass for trivial cases but not for Grails (because callsite caching hasn't kicked in yet for the trivial case, but has when running inside of Grails).

In the meantime, simply replacing ""new XmlParser()"" with ""new XmlSlurper()"" makes the example test case pass and I recommend folks use XmlSlurper until this bug is fixed in Groovy;;;","25/Jan/10 09:56;msmolyak;Graeme,

We cannot use XmlSlurper, since we are taking an existing DOM, parsing it and modifying it at the same time. As far as I know, XmlSlurper is read-only.

Could you provide a reference explaining what callsite caching is?

Thank you,

Michael ;;;","25/Jan/10 10:22;graemerocher;XmlSlurper allows modifications. Grails' doWithWebDescriptor plugin hook uses XmlSlurper to allow users to modify web.xml

Callsite caching is a Groovy language feature that increases performance by caching ""call sites"", which are basically dynamic paths to a method call. This allows these call sites to be inlined by the JIT. Unfortunately from my investigations there appears to be a bug somewhere at the language level.;;;","27/Jan/10 08:11;guillaume;Attaching a simple sample Grails app exhibiting the issue with Grails 1.2.0.
Running grails test-app will launch the failing test case.
Although that test case works in GroovyConsole as is.;;;","27/Jan/10 10:51;blackdrag;testTwoLevels fails even without testOneLevel being available. This is for me a sign, that it is probably no call site caching bug.;;;","27/Jan/10 11:38;blackdrag;NodeList sets its own MetaClass, which defines a getAttribute(Object, String) method, wich returns an ArrayList. It defines also an getProperty(Object, String) method. NodeList itself defines also a getAt(String).

Now this getAt method is the only one, that returns the desired NodeList. If the ExpandoMetaClass is active, this is no longer the case;;;","27/Jan/10 11:39;blackdrag;Meaning that in pure Groovy the test fails too if ExpandoMetaClass.enableGlobally() is executed first;;;","27/Jan/10 12:03;blackdrag;From what I can see he problem originates from ClassInfo#getMetaClassUnderLock. This is supposed to return a MetaClass, if ExpandoMetaClass is enabled globally, then this checks if the returned metaclass is a ExpandoMetaClass and if that is the case, it returns this meta class. If that is not the case, then this method will return a new meta class. This is obivously wrong here, since we need that NodeList meta class or else it won't work.;;;","27/Jan/10 15:30;blackdrag;Looks like I have a fix for the part related to EMC, but in a testcase this still fails. And there it fails with and without EMC even;;;","28/Jan/10 09:19;blackdrag;I committed a patch to the 1_6_X branch. It would be good if someone could verify that this patch does not do anyting bad and if it fixes the problem at hand. ;;;","01/Feb/10 02:36;graemerocher;thanks Jochen I will verify that it works against Grails 1.2.x branch.;;;","19/Feb/10 07:12;blackdrag;until further notice I will close this issue as fixed. The patch has been applied to 1.7 and 1.8 as well.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Avoiding repeated resolve() calls in case of failure to resolve the type.,GROOVY-4009,12815040,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,roshandawrani,roshandawrani,23/Jan/10 13:13,07/Apr/10 23:46,14/Jul/23 06:00,23/Jan/10 15:40,1.8-beta-1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,1.7.1,1.8-beta-1,,,,,0,,,,,,"When I run the code
{code}
class Test {
    static main(args) {
        Int x = 1
        def y = x + x
    }
}
{code}
I get the errors
{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Try.groovy: 3: unable to resolve class Int 
 @ line 3, column 13.
           Int x = 1
               ^

Try.groovy: 4: unable to resolve class Int 
 @ line 4, column 17.
           def y = x + x
                   ^

Try.groovy: 4: unable to resolve class Int 
 @ line 4, column 21.
           def y = x + x
                       ^

3 errors
{noformat}

If the declaration statement has determined that the type couldn't be resolved, I am not sure that calling resolve() again for each use of that variable is of any use. It results in the same error coming multiple times (as many times as that variable is used) and also makes the compilation slower due to these unnecessary resolve() calls (even though the performance is hit only in case of errors, when resolve was unsuccessful.)",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 25 23:43:40 UTC 2010,,,,,,,,,,"0|i2c8x3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jan/10 15:40;roshandawrani;For now, it is not done on 1.6.8. Let me know if should be done there too.;;;","25/Jan/10 06:44;blackdrag;I think backporting it would be good, since it reduces the error output, without changing any logic. The resolve calls may cause errors, but they won't go beyond the CompilationUnit, so there should be no change in logic even if something in the ClassLoader would count requeested classes or such.

;;;","25/Jan/10 23:43;roshandawrani;Backported the fix to 1.6.8 now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Stub generator creates invalid Java code for anonymous inner classes,GROOVY-4005,12815037,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,roshandawrani,pniederw,pniederw,20/Jan/10 12:30,07/Apr/10 23:46,14/Jul/23 06:00,22/Jan/10 00:14,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,Compiler,,,,0,,,,,,"Stub generator should generate no code at all for anonymous inner classes. Instead it generates code that produces numerous Java compile errors. Therefore, if a project contains just a single AIC, joint compilation breaks.",,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 22 00:14:20 UTC 2010,,,,,,,,,,"0|i2cnmv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jan/10 11:10;roshandawrani;Since stub generation happens in Conversion phase, how can normal inner classes be differentiated from anonymous inner classes? On InnerClassNodes, the scope is not set until resolve phase, so just checking if classNode is a InnerClassNode with variable scope = null is not sufficient to identify the anonymous inner classes.

I wonder if on InnerClassNode of an AIC, we should set a flag in APP itself - this information seems very commonly needed and once it goes beyond APP, currently AIC nodes get mixed up with other InnerClassNodes.;;;","22/Jan/10 00:14;roshandawrani;Done. Stub generator skips code generation for anonymous inner classes now.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
stub generator creates wrong code for inner and nested classes,GROOVY-4004,12815036,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,roshandawrani,pniederw,pniederw,20/Jan/10 12:25,07/Apr/10 23:46,14/Jul/23 06:00,22/Jan/10 01:48,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,Compiler,,,,0,,,,,,"class Foo {
  def foo

  class Bar { // could also be static
  }
}

Look at the generated Java source code. All property accessors in Foo are replicated in Bar. An easy way to show this is to define a property with the same name in both classes. Javac will fail with a duplicate declaration error.",,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 22 01:48:43 UTC 2010,,,,,,,,,,"0|i2bmmf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jan/10 01:48;roshandawrani;Done. The property methods from the outer class are not replicated into the inner classes anymore.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
deadlock in GroovyClassLoader,GROOVY-4002,12815005,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,guillaume,vakopian,vakopian,19/Jan/10 18:24,02/Jun/10 08:03,14/Jul/23 06:00,01/Jun/10 09:50,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,,,,,,,2,,,,,,"GroovyClassLoader may deadlock when AbstractScriptEngine.eval() is called from different threads. The problem seems to be the locks on the sourceCache Map that both GroovyClassLoader.parseClass() and GroovyClassLoader.loadClass() acquire.
There is a discussion about a similar situation (most likely the same bug) in here: http://markmail.org/message/pfnv546io5yvsqan

Here is a stack dump from my application:

""Thread-1"":
  waiting to lock monitor 0x09f8be04 (object 0x9c7c4a00, a java.util.HashMap),
  which is held by ""Thread-2""
""Thread-2"":
  waiting to lock monitor 0x09f8bd3c (object 0x8562eed8, a java.lang.Class),
  which is held by ""Thread-1""


Thread-1:
----------------------------
at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:711)
 - waiting to lock <0x9c7c4a00> (a java.util.HashMap)
 at groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:425)
 at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:772)
 at java.lang.ClassLoader.loadClass(ClassLoader.java:251)
 at java.beans.Introspector.instantiate(Introspector.java:1438)
 at java.beans.Introspector.findExplicitBeanInfo(Introspector.java:410)
 - locked <0x8562eed8> (a java.lang.Class for java.beans.Introspector)
 at java.beans.Introspector.<init>(Introspector.java:359)
 at java.beans.Introspector.getBeanInfo(Introspector.java:159)
 at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:2924)
 at java.security.AccessController.doPrivileged(Native Method)
 at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:2922)
 at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:2905)
 - locked <0x9cb7ceb8> (a groovy.lang.MetaClassImpl)
 at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:164)
 at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:180)
 at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:195)
 at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:701)
 at groovy.lang.GroovyObjectSupport.<init>(GroovyObjectSupport.java:32)
 at groovy.lang.Script.<init>(Script.java:40)
 at groovy.lang.Script.<init>(Script.java:37)
 at Script4.<init>(Script4.groovy)
 at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
 at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
 at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
 at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
 at java.lang.Class.newInstance0(Class.java:355)
 at java.lang.Class.newInstance(Class.java:308)
 at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:259)
 at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:112)
 at javax.script.AbstractScriptEngine.eval(AbstractScriptEngine.java:216)


Thread-2:
----------------------------
""http-8210-1"":

 at java.beans.Introspector.findExplicitBeanInfo(Introspector.java:408)
 - waiting to lock <0x8562eed8> (a java.lang.Class for java.beans.Introspector)
 at java.beans.Introspector.<init>(Introspector.java:359)
 at java.beans.Introspector.getBeanInfo(Introspector.java:159)
 at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:2924)
 at java.security.AccessController.doPrivileged(Native Method)
 at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:2922)
 at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:2905)
 - locked <0x9cb96308> (a groovy.lang.MetaClassImpl)
 at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:164)
 at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:193)
 at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:199)
 at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:697)
 at org.codehaus.groovy.runtime.callsite.CallSiteArray.createPojoSite(CallSiteArray.java:107)
 at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:148)
 at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
 at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:54)
 at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
 at org.codehaus.groovy.ast.builder.AstBuilderInvocationTrap.visitMethodCallExpression(AstBuilderTransformation.groovy:177)
 at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:63)
 at org.codehaus.groovy.ast.CodeVisitorSupport.visitBinaryExpression(CodeVisitorSupport.java:144)
 at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
 at org.codehaus.groovy.ast.CodeVisitorSupport.visitBinaryExpression(CodeVisitorSupport.java:144)
 at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:49)
 at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:69)
 at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:40)
 at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:35)
 at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:51)
 at sun.reflect.GeneratedMethodAccessor918.invoke(Unknown Source)
 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
 at java.lang.reflect.Method.invoke(Method.java:597)
 at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoCachedMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:229)
 at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:52)
 at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
 at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callSafe(AbstractCallSite.java:90)
 at org.codehaus.groovy.ast.builder.AstBuilderTransformation.visit(AstBuilderTransformation.groovy:57)
 at org.codehaus.groovy.transform.ASTTransformationVisitor$3.call(ASTTransformationVisitor.java:303)
 at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:831)
 at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:519)
 at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:495)
 at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:472)
 at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:291)
 - locked <0x9c7c4a00> (a java.util.HashMap)
 at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:262)
 at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:206)
 at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.getScriptClass(GroovyScriptEngineImpl.java:337)
 at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:110)
 at javax.script.AbstractScriptEngine.eval(AbstractScriptEngine.java:216)
 at com.sustain.util.script.ScriptUtils.executeScript(ScriptUtils.java:73)
 ","java -version
java version ""1.6.0_03""
Java(TM) SE Runtime Environment (build 1.6.0_03-b05)
Java HotSpot(TM) Client VM (build 1.6.0_03-b05, mixed mode, sharing)
",anttip,fraenkel,skuklewicz,vakopian,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4050,,GROOVY-4127,,,,,,"14/May/10 17:28;vakopian;groovy-4002.patch;https://issues.apache.org/jira/secure/attachment/12722558/groovy-4002.patch","05/Apr/10 13:02;anttip;groovy_issue_4002.zip;https://issues.apache.org/jira/secure/attachment/12722437/groovy_issue_4002.zip",,,,,,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 02 08:03:47 UTC 2010,,,,,,,,,,"0|i2caqf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jan/10 08:55;blackdrag;With all these problems for synchronization here Iam thinking that maybe we need to change the internal architecture a bit for this. I am thinking about making CompilationUnit being able to get sources addded from multiple threads. Then the compile() calling thread has to wait. The contra argument for this one is, that we then don't know what class to return anymore.

Another idea would be to support parallel compilation units. They could share information about other classes to ensure that no classes will be duplicated.;;;","05/Apr/10 13:02;anttip;I encountered a similar deadlock on a server using groovlets. I've attached a zip file containing a 'test case' that tries to reproduce the issue and a patch. 

The test case is not 100% successful, most of the time it leads to a deadlock on my machine (>9 times out of 10). Behavior might vary on different platforms. The test case should be straightforward to execute, zip file contains a README.txt, but basically you just compile and run the single Java class.

The patch is small change in GroovyClassLoader, in parseClass() it now releases the sourceCache lock during compilation and locks only for reads and writes to the sourceCache. The patch might lead to compiling a same class 2 times (not harmful?), but should avoid the deadlock. I noticed that classCache has separate methods for reading and writing to the cache, maybe the sourceCache should too?

I'm not 100% sure the patch is fully ""correct"". It passes the test cases, but with threading issues, that's just scratching the surface. I know enough about threading to not to trust myself and I'm not familiar with the groovy project's source, so hopefully others could take a look. Meanwhile, I'll deploy the patch on to the server I saw this issue with and will report if I encounter some problems with it.;;;","07/Apr/10 22:35;anttip;I did have some more problems with the server I deployed the patch to, it ran out of PermGen. I was worried because this patch might cause the same classes to be loaded 2 times. However, it turned out to be a different issue that was related to SimpleTemplateEngine (GROOVY-4154).;;;","14/May/10 17:27;vakopian;Does anyone know why the {{GroovyClassLoader.loadClass()}} synchronizes the code in lines 707-727? The comment there says ??""synchronize on sourceCache, as we want only one compilation at the same time""??. Fair enough. However, I don't think {{synchronized (sourceCache)}} is needed to achieve that goal. Here is why. In that block the code accesses the {{classCache}}, with methods that are already synchronized. Then, if needed it calls {{recompile()}}. So {{recompile()}} is where the actual ??compilation?? happens. So why not synchronize the block inside {{recompile()}} that touches the {{sourceCache}}. That is the lines 756-757. I've tried this modification with groovy 1.7.2, and it passes the tests that Antti attached here (where as with stock 1.7.2 it deadlocks pretty much 100%).
I actually doubt this is a full fix, as I think there is probably a more fundamental problem in the order locks are acquired during the compilation and load. However this seems to alleviate the problem a lot, so perhaps it can be applied until a full solution is found or a redesign attempted. Patch is attached.;;;","14/May/10 17:28;vakopian;Attaching a patch to move {{synchronize(sourceCahce)}} from {{loadClass()}} to {{recompile()}};;;","19/May/10 15:32;fraenkel;The patch is not right.
Anywhere sourceCache is touched there needs to be a synchronized block around it.
More sync blocks need to be created, not moved.

We are hitting this problem regularly now.

Our paths are slightly different but end up in the same deadlock.
One thread is initializing a new Groovy object that is causing the MetaClass.initialize() that drives the Introspector to use loadClass for the BeanInfo, and another is performing a parseClass.
;;;","19/May/10 16:49;vakopian;Michael,
Are you talking about my patch (named groovy-4002.patch added on May 14), or Antti's? My patch satisfies your criteria of keeping all access to sourceCache synchronized.I've also been running that patch for a week now, and have not seen any problems so far.;;;","19/May/10 22:14;fraenkel;Sorry.  You are correct.  Your patch looks good.  I am testing it as well and will let you know if we hit any issues as well.;;;","01/Jun/10 14:22;vakopian;I was wandering about the reason why the patch which clearly allows for multiple concurrent parsing of the same source was chosen to fix this bug. Was the second patch wrong or did it not fix the problem? I'd really appreciate a comment on this, as I'm currently running 1.7.2 with the second patch and I'd like to know if you think there are problems with it.;;;","01/Jun/10 21:14;paulk;Possibly the wrong patch was inadvertently applied. Will adjust as required shortly if so.;;;","02/Jun/10 02:50;guillaume;Indeed, my mistake, I'll make sure to fix that this morning. The other patch is better than the first one -- although it fixed the usual path people seem to go through.;;;","02/Jun/10 08:03;guillaume;Committed the better patch, and also transformed the sample into a test case.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Grapes/Grab spending time checking remote repositories every 3rd run?,GROOVY-4001,12815049,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mbjarland,mbjarland,16/Jan/10 10:12,26/Jul/12 16:49,14/Jul/23 06:00,13/Jul/12 08:04,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.0-rc-1,,,Grape,,,,0,,,,,,"This is a performance issue with grapes. I have two groovy files: 

* A httpServer.groovy (attached) which runs an embedded jetty server and responds to http post requests
* A httpClient.groovy (attached) which runs HttpBuilder and does a http post to the server in the other script

both groovy files download dependencies using @Grab annotations and they both work. 

Weirdness ensues in the following scenario:

# I have network connectivity enabled
# I delete my grapes cache
# I start the server script and wait of it to come up
# I run an infinite bash while loop which executes the client script and collects timings: 'while true ; do time groovy -d httpClient.groovy ; done'

\\
Console logs of both client and server runs attached. It turns out that the client script takes about 4 seconds to run two times and then every third time it takes 25-30 seconds to run. I've verified this over hundreds of runs and it does not seem like a random occurrence of say network congestion or cpu load. In the attached console logs we can see that the server takes 1-5ms to handle requests, but the client script trundles along in a sequence of 4s, 4s, 25s, 4s, 4s, 25s etc. 

If I turn off my nic the timings become deterministic: 4s, 4s, 4s

I have also tried running against the RC2 release of the http-builder package with identical results. As I believe the snapshot and RC2 versions are served by different remote repos, this would lower the probability that this is a remote repo issue. I also removed my ~/.groovy/grapeConfig.xml before the test. 

So a couple of questions: 

# what is going on here 
# is there any way to force debug logging for grapes during script execution to find out what it is actually doing

\\
I suspect this issue might be caused by the check-for-new-version-every-time snapshot jar handling logic. If so, maybe it would be a good idea to have an extra parameter to the grab annotation: 
{noformat} 
  @Grab(..., checkmodified=false)

{noformat} 
just as we do for repositories in the grapeConfig.xml file. This would basically instruct the resolver to _not_ check the remote repos for a new version of this particular jar once one matching the version is in the local cache...even if the version has 'SNAPSHOT' or 'RC2' at the end. As we don't always have control over 3rd party versioning (http-builder latest stable is for example RC2 which I suspect is treated the same way as a snapshot release), it would be nice to be able to force your script to run in 4 seconds insted of 30. Grapes gurus, you'll probably have a better solution, but figured I'd throw it out there. 

In summary, the above behavior makes calling the http-builder from groovy using grapes useless for me as the 30s delay is not acceptable in my current context. Any ideas or suggestions would be most welcome.   
","Groovy Version: 1.7.0, Java HotSpot(TM) 64-Bit Server VM (build 14.3-b01-101, mixed mode), OSX 10.6.2, 2.8GHz Core2Duo mac book pro, 4G memory, SSD disk, 100Mbit internet",curious.attempt.bunny@gmail.com,mbjarland,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Jan/10 10:12;mbjarland;GrabHttpClientServerTest.zip;https://issues.apache.org/jira/secure/attachment/12722429/GrabHttpClientServerTest.zip","16/Jan/10 10:12;mbjarland;GrabHttpClientServerTest.zip;https://issues.apache.org/jira/secure/attachment/12722493/GrabHttpClientServerTest.zip","16/Jan/10 10:12;mbjarland;GrabHttpClientServerTest.zip;https://issues.apache.org/jira/secure/attachment/12722143/GrabHttpClientServerTest.zip",,,,,,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 04 04:49:35 UTC 2012,,,,,,,,,,"0|i2bmk7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jan/10 10:14;mbjarland;Apologies for attaching the same file three times.;;;","16/Jan/10 10:54;malbery;Looks to be a reasonable solution to me.;;;","16/Jan/10 11:41;malbery;I get the pattern you outlined. I switched to the RC2 version to remove the GrabResolver from the mix:

{code}
//@GrabResolver(name='',  root='http://repository.codehaus.org')
@Grab('org.codehaus.groovy.modules.http-builder:http-builder:0.5.0-RC2')
{code}

With:
{code}
      <ibiblio name=""codehaus"" root=""http://repository.codehaus.org/"" m2compatible=""true""/>
      <ibiblio name=""ibiblio"" m2compatible=""true""/>
      <ibiblio name=""java.net2"" root=""http://download.java.net/maven/2/"" m2compatible=""true""/>
{code}

I get:
19s, 4s, 4s, 19s, 4s, 4s, 19s, etc.

With:
{code}
      <ibiblio name=""codehaus"" root=""http://repository.codehaus.org/"" m2compatible=""true"" checkmodified=""false""/>
      <ibiblio name=""ibiblio"" m2compatible=""true"" checkmodified=""false""/>
      <ibiblio name=""java.net2"" root=""http://download.java.net/maven/2/"" m2compatible=""true"" checkmodified=""false""/>
{code}

I get pretty much the same numbers:
19s, 4s, 4s, 19s, 4s, 4s, 19s, etc.

So I doubt that this is a checkmodified configuration issue.
;;;","18/Jan/10 21:02;malbery;I tried building a distribution of groovy using the latest snapshot of ivy. No change in the behaviour.;;;","01/Dec/10 17:43;malbery;This setting may be the answer:

<chain name=""downloadGrapes"" returnFirst=""true"">

in ~/.groovy/grapeConfig.xml:

<ivysettings>
  <settings defaultResolver=""downloadGrapes""/>
  <resolvers>
    <chain name=""downloadGrapes"" returnFirst=""true"">
      <filesystem name=""cachedGrapes"">
        <ivy pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/ivy-[revision].xml""/>
        <artifact pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/[type]s/[artifact]-[revision](-[classifier]).[ext]""/>
      </filesystem>
      <!-- todo add 'endorsed groovy extensions' resolver here -->
      <ibiblio name=""codehaus"" root=""http://repository.codehaus.org/"" m2compatible=""true""/>
      <ibiblio name=""ibiblio"" m2compatible=""true""/>
      <ibiblio name=""java.net2"" root=""http://download.java.net/maven/2/"" m2compatible=""true""/>
    </chain>
  </resolvers>
</ivysettings>


http://ant.apache.org/ivy/history/2.0.0-alpha2/resolver/chain.html

;;;","24/Mar/11 07:15;mbjarland;A year later...

Figured as some time and a few groovy versions have passed by it might be worth commenting on this issue again. 

Given the following groovy script:

{code:title=test.groovy} 
#!/usr/bin/env groovy

@Grab('org.fusesource.jansi:jansi:1.5')
@Grab('net.sf.jopt-simple:jopt-simple:3.2')
@Grab('com.amazonaws:aws-java-sdk:1.1.8')
@Grab('org.codehaus.gpars:gpars:0.11')

import org.fusesource.jansi.*

println ""Initializing...""
{code}

we get a run time of 30 seconds on a late model mac book pro with an SSD (i.e. not a problem with hardware) and a 100/10Mbit internet connection (i.e. not a problem with network connectivity). Note also that all the referenced resources have specific versions on them (not ranges etc) and that they are not snapshots. I am left a bit confused as to why ivy would even want to go out and check repositories if it has already found an exact match for the artifact in the local repo.

Adding the returnFirst=""true"" flag in the grapeConfig.xml as per previous comment on this issue drops the execution time down to 2.4 seconds which is more or less acceptable. 30 seconds for a println is in my book a catastrophe and disqualifies the @Grab annotation from being used in a lot of scenarios.

Now I agree that it is nice to have an actual fix with the grapeConfig.xml file. This however removes the portability of a script. I can now not send this file to my colleague or deploy it to a hundred servers without going through some secret ivy voodoo (grapeConfig.xml) on each machine where the script is deployed. 

I would therefore still advocate an addition to the @Grab annotation where we could have something like:

{code:title=Possible @Grab Annotation Syntax}
  @Grab(..., returnFirst=true)
{code} 

where I think that the default should be returnFirst=true. Also I still think it would be really useful if there was a:

{code}
  @Grab(..., debug=true)
{code}

or a system property we could set, or any other way to get grapes to actually log what it is doing and spending those 30 seconds of my life on. 



;;;","14/Apr/12 06:27;mbjarland;Another year passes by...

I can add a small addendum to this issue. To enable logging for the ivy resolution in a specific groovy execution you can use the ""ivy.message.logger.level"" system property:

{code}
$ groovy -Divy.message.logger.level=4 test.groovy
{code}
;;;","04/May/12 04:49;blackdrag;I looked into this a bit and I decided for now to use a modified default configuration given to grape. It can be overridden by a local config any time, so I guess this should be ok. At least it solves your problem. Groovy 2.0 beta 4 will contain that change.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Enum static field initialization inconsistency,GROOVY-3996,12815013,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,13/Jan/10 04:15,07/Apr/10 23:47,14/Jul/23 06:00,13/Jan/10 08:55,1.6.7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,1.7.1,1.8-beta-1,,,,,0,,,,,,"Output of the code
{code}
enum Color {
	R, G, B
	static Color[] ALL_COLORS = [R, G, B];
}

println Color.ALL_COLORS
{code}
is correct - [R, G, B]

But if I just make the static field public then the code fails with output as [null, null, null]
{code}
enum Color {
	R, G, B
	public static Color[] ALL_COLORS = [R, G, B];
}

println Color.ALL_COLORS
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3993,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 13 08:55:28 UTC 2010,,,,,,,,,,"0|i2ck3z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jan/10 08:55;roshandawrani;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
An inner enum class cannot resolve itself in its own body,GROOVY-3995,12815004,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,13/Jan/10 03:53,07/Apr/10 23:50,14/Jul/23 06:00,19/Jan/10 10:09,1.6.7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,,,,,,,0,,,,,,"The compilation of 
{code}
class Test {
	enum Color {
		  R, G, B
		  public static Color[] ALL_COLORS = [R, G, B];
	}
}
{code}
fails with
{noformat}
unable to resolve class Color[] 
 @ line 4, column 5.
   		  public static Color[] ALL_COLORS = [R, G, B];
       ^

1 error
{noformat}

However the compilation of following code goes through (top-level enum):
{code}
enum Color {
	  R, G, B
	  public static Color[] ALL_COLORS = [R, G, B];
}
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3993,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2010-01-13 03:53:47.0,,,,,,,,,,"0|i2cgb3:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
ClassCastException when trying to instantiat an EnumSet from an inner enum,GROOVY-3994,12811728,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,xsautejeau,xsautejeau,12/Jan/10 08:57,07/Apr/10 23:47,14/Jul/23 06:00,13/Jan/10 04:33,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,,,,,0,,,,,,"When trying to run the attached test case, which does noting much more than trying to instantiate an EnumSet from an inner enum, I get the following exception :

java.lang.ClassCastException: class TestInnerEnum$MyEnum not an enum
	at java.util.EnumSet.noneOf(EnumSet.java:93)
	at java.util.EnumSet.allOf(EnumSet.java:110)
	at java_util_EnumSet$allOf.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at TestInnerEnum.testPrint(TestInnerEnum.groovy:20)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at org.junit.internal.runners.TestMethod.invoke(TestMethod.java:59)
	at org.junit.internal.runners.MethodRoadie.runTestMethod(MethodRoadie.java:98)
	at org.junit.internal.runners.MethodRoadie$2.run(MethodRoadie.java:79)
	at org.junit.internal.runners.MethodRoadie.runBeforesThenTestThenAfters(MethodRoadie.java:87)
	at org.junit.internal.runners.MethodRoadie.runTest(MethodRoadie.java:77)
	at org.junit.internal.runners.MethodRoadie.run(MethodRoadie.java:42)
	at org.junit.internal.runners.JUnit4ClassRunner.invokeTestMethod(JUnit4ClassRunner.java:88)
	at org.junit.internal.runners.JUnit4ClassRunner.runMethods(JUnit4ClassRunner.java:51)
	at org.junit.internal.runners.JUnit4ClassRunner$1.run(JUnit4ClassRunner.java:44)
	at org.junit.internal.runners.ClassRoadie.runUnprotected(ClassRoadie.java:27)
	at org.junit.internal.runners.ClassRoadie.runProtected(ClassRoadie.java:37)
	at org.junit.internal.runners.JUnit4ClassRunner.run(JUnit4ClassRunner.java:42)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:130)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:94)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:165)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:60)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:110)","Ubuntu 8.04
JDK 1.6.0_14
IntelliJ IDEA 9.0",xsautejeau,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3979,,"12/Jan/10 08:57;xsautejeau;TestInnerEnum.groovy;https://issues.apache.org/jira/secure/attachment/12722428/TestInnerEnum.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 13 04:33:47 UTC 2010,,,,,,,,,,"0|i2csnj:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"13/Jan/10 03:33;roshandawrani;Although the usage of enum is different here, the underlying cause is same as that of GROOVY-3979.;;;","13/Jan/10 04:33;roshandawrani;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
NPE when trying to access member of a static array from an inner static enum,GROOVY-3993,12818047,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,xsautejeau,xsautejeau,12/Jan/10 07:48,07/Apr/10 23:47,14/Jul/23 06:00,19/Jan/10 12:26,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,1.7.1,1.8-beta-1,,,,,0,,,,,,"In the attached test case, I can read the size of the static array (3) but whenever I try to access a property of one of the array elements, I get the following result :

hello
a
3

java.lang.NullPointerException: Cannot invoke method name() on null object
	at org.codehaus.groovy.runtime.NullObject.invokeMethod(NullObject.java:77)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:45)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.NullCallSite.call(NullCallSite.java:17)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:40)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:121)
	at TestInnerEnum.testPrint(TestInnerEnum.groovy:19)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at org.junit.internal.runners.TestMethod.invoke(TestMethod.java:59)
	at org.junit.internal.runners.MethodRoadie.runTestMethod(MethodRoadie.java:98)
	at org.junit.internal.runners.MethodRoadie$2.run(MethodRoadie.java:79)
	at org.junit.internal.runners.MethodRoadie.runBeforesThenTestThenAfters(MethodRoadie.java:87)
	at org.junit.internal.runners.MethodRoadie.runTest(MethodRoadie.java:77)
	at org.junit.internal.runners.MethodRoadie.run(MethodRoadie.java:42)
	at org.junit.internal.runners.JUnit4ClassRunner.invokeTestMethod(JUnit4ClassRunner.java:88)
	at org.junit.internal.runners.JUnit4ClassRunner.runMethods(JUnit4ClassRunner.java:51)
	at org.junit.internal.runners.JUnit4ClassRunner$1.run(JUnit4ClassRunner.java:44)
	at org.junit.internal.runners.ClassRoadie.runUnprotected(ClassRoadie.java:27)
	at org.junit.internal.runners.ClassRoadie.runProtected(ClassRoadie.java:37)
	at org.junit.internal.runners.JUnit4ClassRunner.run(JUnit4ClassRunner.java:42)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:130)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:94)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:165)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:60)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:110)


Process finished with exit code 255","Ubuntu 8.0.4
InteliJ IDEA 9.0
JDK 1.6..0_14",xsautejeau,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3995,GROOVY-3996,,,,,,,"12/Jan/10 07:48;xsautejeau;TestInnerEnum.groovy;https://issues.apache.org/jira/secure/attachment/12722253/TestInnerEnum.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 19 12:26:22 UTC 2010,,,,,,,,,,"0|i2c0fz:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"13/Jan/10 09:09;roshandawrani;This issue is fixed on 1.7.x and trunk through GROOVY-3996.

On 1.6.x, 2 issues are coming in its way:

1) Within the inner enum MyEnum, it cannot resolve MyEnum itself. For this issue, I have opened GROOVY-3995.

2) If I change ""public static MyEnum[] myenums = [a,b,c];"" to ""public static myenums = [a,b,c];"" to avoid the resolve issue, then there is class ordering issue because of which instead of running the test class TestInnerEnum, GroovyShell tries to run the class TestInnerEnum$MyEnum.;;;","13/Jan/10 09:25;roshandawrani;Jochen, the resolve error is not there in 1.7.x because of the ResolveVisitor changes made in revision 17933 (that introduced resolveNestedClass()).

Do you see any issue if these changes (the ResolveVisitor part of the 17933 cgangeset) are ported to 1.6.x as well to get rid of the resolve error?;;;","14/Jan/10 21:10;roshandawrani;Shall I port back the ResolveVisitor part of the 17933 changeset(resolveNestedClass()) to make GROOVY-3995 example work?;;;","19/Jan/10 12:26;roshandawrani;Fixed. 

On 1.7.x/trunk, only the changes done against GROOVY-3996 were needed to fix the issue. 1.6.x needed additional changes that were done against this JIRA as well as GROOVY-3995.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Exponantiation,GROOVY-3991,12815025,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,berndschiffer,berndschiffer,11/Jan/10 13:26,09/Nov/11 05:30,14/Jul/23 06:00,09/Nov/11 05:30,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.5,1.8-beta-2,,groovy-jdk,,,,0,,,,,,"On command line:

$ groovy -e 'println 2**63' #=> 9223372036854775807
$ ruby -e 'puts 2**63' #=> 9223372036854775808

Ruby is right, Groovy is wrong.

Special thanks to @datenreisender: http://twitter.com/datenreisender/status/6996674701

Ruined my kata: http://berndschiffer.blogspot.com/2009/12/prime-factors-kata-first-try.html :(",,ataylor284,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Apr/10 13:55;ataylor284;exponantiation.patch;https://issues.apache.org/jira/secure/attachment/12722556/exponantiation.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 16 08:33:06 UTC 2010,,,,,,,,,,"0|i2bzl3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jan/10 14:45;blackdrag;The Java System.out.println (Math.pow(2, 63)); says 9.223372036854776E18. Part of the problem is that the resulting double does not have enough precession to hold the value. Since Groovy internally uses the pow method of course the value of the result will not be exact enough. So if you say Groovy is wrong and Ruby is right, then the same goes for Java. 

Where is the bug report for Java on this? There would be none, because in Java you wouldn't use Math.pow(double,double) if you wanted to have exact results. Math.pow uses an approximation method that might not return the ""correct"" result, especiall if the result would not fit in a double. instead you have to use BigInteger#pow in Java to get the exact results.

So is this a bug for Groovy? Not sure. Groovy could certainly do better here. If both participants are integer, then maybe we should use BigInteger#pow instead. Of course the result type would then have to be BigInteger on this here. I mean you used int as a base, but the result does no fit in an int. An higher exponent would mean the result won't fit into an Long as well.

Another version would be to stay in the base type. That means you would have to do 2G**63 to get the BigInteger version. For speed reasons I think this is a much better choice here.;;;","27/Apr/10 13:55;ataylor284;A patch to improve exponantiation.;;;","27/Apr/10 14:02;ataylor284;I've attached a patch which changes exponentiation to use the BigInteger.pow(int) and BigDecimal.pow(int) methods where possible.  Those methods only handle the cases where the exponent is a positive integer, but they provide exact results.  I've tried to keep the typing sane.  In particular, the result is provided in the same type as the left operand if possible, otherwise it is expanded to a BigInteger.  BigDecimals result in BigDecimals.  In the cases where the exponent is not a positive integer or the base is a double, the old Math.pow() implementation is used.

With this patch, 2**63 gives the correct result as a BigInteger.;;;","16/Sep/10 08:33;roshandawrani;Applied the patch. Thanks for providing it.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Groovy compiler allows overriding final methods but class loading fails with java.lang.VerifyError,GROOVY-3989,12814845,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,roshandawrani,roshandawrani,roshandawrani,11/Jan/10 02:48,07/Apr/10 23:47,14/Jul/23 06:00,11/Jan/10 08:14,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,1.7.1,1.8-beta-1,Compiler,,,,0,,,,,,"The following script compiles but when run, class loading fails saying ""java.lang.VerifyError: class B overrides final method""

{code}
class A {
    def foo() {}
    final def bar() {}
}
class B extends A {
    def foo() {}
    def bar() {}
}
B
{code}

If I swap the order of method definitions in class B as:
{code}
class A {
    def foo() {}
    final def bar() {}
}
class B extends A {
    def bar() {}
    def foo() {}
}
B
{code}
then it correctly gives the error message ""You are not allowed to overwrite the final method bar() from class 'A'.""",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 11 08:14:45 UTC 2010,,,,,,,,,,"0|i2chbb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jan/10 08:14;roshandawrani;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cannot copy the text selected in output pane of GroovyConsole,GROOVY-3987,12815006,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,roshandawrani,roshandawrani,10/Jan/10 23:02,07/Apr/10 23:47,14/Jul/23 06:00,11/Jan/10 02:17,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,1.7.1,1.8-beta-1,,,,,0,,,,,,"While the text can be selected in the output pane of GroovyConsole, it cannot be copied using Ctrl-C or menu option Edit -> Copy.

It will be useful if it can work.",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 11 02:17:43 UTC 2010,,,,,,,,,,"0|i2cqbj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jan/10 02:17;roshandawrani;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
can't omit toplevel parentheses in enum element method,GROOVY-3986,12811794,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,uehaj,uehaj,10/Jan/10 20:27,23/Jun/10 15:45,14/Jul/23 06:00,09/Apr/10 10:12,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.3,1.8-beta-1,,,,,,0,,,,,,"{code}
enum Color {
    RED {
      String toString() { println ""foo"" }
    },GREEN,BLUE
}
{code}
produces an error:
{code}
$ groovy enumtest2.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/Users/uehaj/src/groovy/enumtest2.groovy: 2: unexpected token: RED @ line 2, column 5.
       RED {
       ^

1 error
{code}

following is OK:
{code}
enum Color {
    RED {
      String toString() { println(""foo"") }
    },GREEN,BLUE
}
{code}
",Mac OS X 10.5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"11/Jan/10 14:26;roshandawrani;3986_v17x_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722140/3986_v17x_Patch.txt","12/Jan/10 10:17;roshandawrani;TEST-UberTestCaseJavaSourceCodehausPackages.txt;https://issues.apache.org/jira/secure/attachment/12722548/TEST-UberTestCaseJavaSourceCodehausPackages.txt","12/Jan/10 10:17;roshandawrani;TEST-UberTestCaseTCK.txt;https://issues.apache.org/jira/secure/attachment/12722252/TEST-UberTestCaseTCK.txt","10/Jan/10 20:27;uehaj;enumtest2.groovy;https://issues.apache.org/jira/secure/attachment/12722546/enumtest2.groovy",,,,,4.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 09 10:12:34 UTC 2010,,,,,,,,,,"0|i2ccvr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jan/10 14:26;roshandawrani;Attaching a patch for review.

Does it really have to be fixed on 1.6.x? 

The support for anonymous classes for enum instances is not ported on 1.6.x, right?;;;","11/Jan/10 15:32;blackdrag;no need to fix it on 1.6.x, true. But I am a bit puzzled about the fix:
{code}
enumBlock  {Token first = LT(1);}
    :   LCURLY! nls!
        (
            // Need a syntactic predicate, since enumConstants
            // can start with foo() as well as classField.
            // (It's a true ambiguity, visible in the specification.
            // To resolve in practice, use ""def"" before a real method.)
            (enumConstantsStart)=> enumConstants
        |   (classField)?
        )
        ( sep! (classField)? )*
        RCURLY!
        {#enumBlock = #(create(OBJBLOCK, ""OBJBLOCK"",first,LT(1)), #enumBlock);}
    ;
{code}
We start out with either a method/field (classField) or enumConstant or the enum is empty. ()? means it is there once or not at all. So how does this construction support an empty enum? enumConstantsStart does not apply and (classField)? is in fact classField|epsilon, where I use epsilon here as the empty word. Since that first choice can be empty, we also seem to allow {code:Java}enum{
  ;
  def foo(){}
}{code}
which is a bit strange, but won't hurt.

The problem I have is more that enumConstantsStart (enumConstant (COMMA | SEMI | NLS | RCURLY)) should match ""RED {"" in the enumConstant rule already. Why doesn't do it that? also with your fix we get another ()? in there for the enumConstants part, which makes it optional, while it should have been that aleady. Also we do want to match it, so why use ()? here?

;;;","11/Jan/10 15:35;blackdrag;I am wondering if{code}
enumBlock  {Token first = LT(1);}
    :   LCURLY! nls!
        (
            (enumConstantsStart)=> enumConstants
        |   classField
        )?
        ( sep! (classField)? )*
        RCURLY!
        {#enumBlock = #(create(OBJBLOCK, ""OBJBLOCK"",first,LT(1)), #enumBlock);}
    ;
{code}
wouldn't be a better rule... maybe even{code}
enumBlock  {Token first = LT(1);}
    :   LCURLY! nls!
        (
            (enumConstantsStart)=> enumConstants
        |   classField
        )?
        ( sep! classField )*
        RCURLY!
        {#enumBlock = #(create(OBJBLOCK, ""OBJBLOCK"",first,LT(1)), #enumBlock);}
    ;
{code}
;;;","11/Jan/10 22:06;roshandawrani;Hi Jochen,
I tried both the code examples from your comment - 2nd one makes AstBrowser.groovy throw a compilation error, and the 1st does one does not fix the issue reported here (it still fails with option 1).

The grammar change in my patch has the disadvantage that following gets compiled:
{code}
enum{
  ;
  def foo(){}
}
{code}
Is it something that we can live with or more research needs to be done to find another solution?;;;","11/Jan/10 22:14;roshandawrani;May be it was a typo on your part (and I copied :-) )

But this does not work
{code}
enum { // it would have been bad if this also worked - without enum IDENT
  ;
  def foo(){}
}
{code}

while this does

{code}
enum Color{
  ; // this can be considered harmless, as you suggested earlier
  def foo(){}
}
{code}
;;;","12/Jan/10 03:40;blackdrag;yeah, my error in forgetting the identifier for the enum itself. I wrote too fast.

Basically the problem I have with the patch is: Why does it work? I simply fail to understand why the grammar before does not catch that case and the new one does. I don't feel too good about adding something to the grammar I don't understand. I hoped you could maybe shed some light on this.;;;","12/Jan/10 04:04;roshandawrani;I am afraid I won't be able to explain to you in terms of ANTLR theory why my patch works. The best tool I have in my kit is debugging.

So how and why I tried that change - what I did was to trace in GroovyRecognizer the following 2 cases and saw why in the class that expression was creating no issues but in the enum it did.

{code}
class Color {
    String toString() { println ""foo"" }
}
{code}
{code}
enum Color {
    RED {
      String toString() { println ""foo"" }
    }
}
{code}

The 2 scenarios were going different ways in primaryExpression() match and the reason was the inputState.guessing value. For the class inputState.guessing was 0 whereas for the enum, it was 1. I traced back to see that guessing++ value that primaryExpression() was seeing was coming from (enumConstantsStart =>) guard. So I tried changes around that and found the solution in the patch to be working. (My guess is that it is happening because ""enumConstantsStart"" guard uses ""enumConstant"" in it. If we can define the guard in an alternate way, it may help. But it is a guess at this point.)

I hoped that although I had gone by plain debugging, another grammar expert would understand my change better theoretically and would be able to let me also know why my patch works :-)

I understand your concern though, and I don't want to press for it. I can try to look more into it and come up with a better patch/explanation.;;;","12/Jan/10 05:21;blackdrag;We have to try to understand why it works, otherwise we will have the trouble again when we move to antlr v3.

I will try to record a debugging session here with the offending code and the original groovy.g...

So I make a breakpoint in enumBlock in GroovyRecognizer to see which alternative now is taken... first we match LCURLY and the NLS, no problem. RED is an IDENT, so I get into the branch that will try matching to EnumConstantsStart. This leads to enumConstant, where the first token is set to IDENT ""RED"". annotationsOpt won't match, because there is no annotation, but it is optional anyway. There we successfully match the IDENT ""RED"". Next we match the NLS... which makes me wonder if that is right, because before the NLS we should match the LCURLY instead. Well it comes after the NLS. So we start reading enumConstantBlock. In enumconstantField we can successfully read the method signature, and then descend into compoundStatement, which goes directly into compoundStatement. There we match the LCURLY and then go down in blockBody, to statement, to expressionStatement, to expression, assignmentExpression, conditionalExpression, logicalOrExpression, logicalAndExpression, inclusiveOrExpression, exclusiveOrExpression, andExpression, regexExpression, equalityExpression, relationalExpression, shiftExpression, additiveExpression, multiplicativeExpression, powerExpressionNotPlusMinus, unaryExpressionNotPlusMinus, postfixExpression, pathExpression, primaryExpression, where we finally match the IDENT ""println"". We go all the way up again, to expressionStatement where it throws an NoViableAltException. To me that says it failed to recognize the command expression. 

And indeed, if I change the command expression into a println(""foo"") then we get no parse error at all. 

It fails in expressionStatement, because there commandArgs is not tried to match, which is prefixed by {code:Java}
if (((_tokenSet_69.member(LA(1))) && (_tokenSet_70.member(LA(2))))&&(isPathExpr)) 
{code}
And that is because of the input state guessing as you said... why exactly that is I fail to see, I can only assume that the match to IDENT was assumed to be enough by antlr.. whatever... If I change the enumConstantsStart rule to {code}
enumConstantsStart
    :   IDENT nls! (COMMA | SEMI | RCURLY | LCURLY | LPARENT)+
    ;
{code}
then the enum is successfully recognized. Roshan, what do you think of this solution? If I am right, then the parser won't have to descend all the expression types.

;;;","12/Jan/10 06:13;roshandawrani;Thanks for documenting the debugging details - it covers all till the failure point in rule ""primaryExpression"" .

It seems quite clear now that the inputState.guessing difference is coming for enum case because the call is reaching expression rules from a guard (enumConstantsStart, which first increment the guessing and decrement it when it is done and in between (as in the expression rules here), you see the incremented guessing value). It should reach the expression() matching rules only after all guessing is over and guards have done their work (So the enumConstant rule matching from enumConstants should not have any issue, once we get the guard right).

So, I agree fully that enumConstantsStart definition has to change so that it does not go all the way deep.

However your current suggested definition of enumConstantsStart is not working. It is clashing elsewhere. 

We need to come up with the correct enumConstantsStart definition and it should be fine, I think.;;;","12/Jan/10 09:28;blackdrag;Where is it clashing? The problematic case here worked well.;;;","12/Jan/10 09:39;roshandawrani;Did you do a clean build?

For me the compilation of the main sources itself is failing (not able to reach the tests because of which) with the error below:

{code}
[groovyc] org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
[groovyc] D:\Roshan\GroovyDevSetup\Workspace17x\groovy\src\main\groovy\inspect\swingui\AstBrowser.groovy: 252: unexpected token: INITIALIZATION @ line 252, column 5.
[groovyc]        INITIALIZATION(Phases.INITIALIZATION, ""Initialization""),
[groovyc]        ^
{code};;;","12/Jan/10 09:41;roshandawrani;enumConstantsStart re-definition in your comment above was the only change, right?

I have not applied any other change to groovy.g as I didn't see it anywhere in the comment.;;;","12/Jan/10 09:49;blackdrag;I did no build, I tested only the example. Ah, there is a spelling error LPARENT should have been LPAREN. The usage of LPARENT created a new token, that of course is never matched.;;;","12/Jan/10 10:17;roshandawrani;After removing the spelling error, the compilation went fine but 2 tests are broken

gls.enums.EnumTest.testSingleListDoesNoInfluenceMaps()

org.codehaus.groovy.antlr.EnumSourceParsingTest.testParseEnumWithValues()

Attaching the test reports with full stack traces.;;;","05/Apr/10 07:12;paulk;The following seemed to work for me:
{noformat}
enumConstantsStart
    :   annotationsOpt IDENT (COMMA | SEMI | LCURLY | LPAREN | nls! (modifiersOpt | RCURLY))
    ;
{noformat}
I am not sure we would want NLS before LCURLY or LPAREN but I guess it might be fine (wanted?) for COMMA and SEMI.;;;","08/Apr/10 02:57;paulk;It would be nice if we could fix GROOVY-3047 at the same time - which the above doesn't.;;;","09/Apr/10 10:12;paulk;Fixed. Thanks for reporting the issue and also to Roshan for trailblazing the solution.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,
"error in instance initializer for Enum element, without special method",GROOVY-3985,12815016,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,uehaj,uehaj,10/Jan/10 20:20,07/Apr/10 23:46,14/Jul/23 06:00,11/Jan/10 06:42,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,,,,,0,,,,,,"{code}
enum Color {
    RED {
      { println(""foo""); } // Instance initalizer
    },GREEN,BLUE
}
{code}

makes an error like:
{code}
$ groovy  enumtest.groovy
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/Users/uehaj/src/groovy/enumtest.groovy: -1: You are not allowed to overwrite the final method $INIT([Ljava.lang.Object;) from class 'Color'.
 @ line -1, column -1.
1 error
{code}
following is OK.
{code}
num Color {
    RED {
      String toString() {}
      { println(""foo""); } // Instance initalizer
    },GREEN,BLUE
}
{code}

",Mac OS X,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"10/Jan/10 20:20;uehaj;enumtest.groovy;https://issues.apache.org/jira/secure/attachment/12722308/enumtest.groovy",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 11 06:42:49 UTC 2010,,,,,,,,,,"0|i2c0jj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jan/10 06:42;roshandawrani;Fixed. ""without special method"" part of it is being fixed under GROOVY-3989.

Explanation: Enum instances use anonymous inner classes to override the behavior defined at enum level. 
Such inner classes for instances have enum class as their super class. The $INIT method for the enum was 
not being made non-final and hence instance initializers($INIT) of the inner classes were 
erroring out with ""You are not allowed to overwrite the final method $INIT([Ljava.lang.Object; ) from class '...'""

;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
GroovyScriptingEngine doesn't recognize changes in the source of checked class only when dependencies got changed,GROOVY-3980,12811995,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,novoj,novoj,07/Jan/10 14:25,05/Apr/15 14:43,14/Jul/23 06:00,08/Jan/10 13:18,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,class generator,,,,0,,,,,,"Expected behaviour from my point of view it that GroovyScriptEngine should refresh class everytime its source code or source code of any of classes this class references changes. Such behaviour was implemented in 1.6.5. When upgrading to 1.7.0 our test began to fail - class is refreshed only in case of referenced classes source code gets changed, but when I directly change the source of the class I am directly loading, I receive old version -  no refresh occurs.

I can prove this by the set of tests that pass on 1.6.5 but fails on 1.7.0. Precisely the proving test is: 
com.fg.scripting.groovy.GroovyScriptingEngineReloadSupportTest#testReloadGroovyClass

Before running tests, please inspect com.fg.scripting.groovy.AbstractGroovyTest#setUp and modify the path.","Groovy 1.7.0-all, JDK 1.5, Win",,,,,,,,,,,,,,,,,,,,,,,,,,,,,3600,3600,,0%,3600,3600,,,,,,,,,,,,,,,,,,,,,,,,"08/Jan/10 09:13;roshandawrani;3980_v17x_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722427/3980_v17x_Patch.txt","08/Jan/10 05:43;novoj;lib_groovy-1.7.0.zip;https://issues.apache.org/jira/secure/attachment/12722492/lib_groovy-1.7.0.zip","07/Jan/10 14:25;novoj;patch-GroovyScriptEngine.patch;https://issues.apache.org/jira/secure/attachment/12722304/patch-GroovyScriptEngine.patch","08/Jan/10 11:29;roshandawrani;v2_3980_v17x_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722307/v2_3980_v17x_Patch.txt",,,,,4.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Fri Jan 08 23:00:12 UTC 2010,,,,,,,,,,"0|i2cji7:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"08/Jan/10 04:18;roshandawrani;I wanted to run the given tests to see what was happening in the reloading, but am unable to do it as it fails with 

{noformat}
[INFO] Failed to resolve artifact.

GroupId: com.fg
ArtifactId: fg-default-jdk15-library
Version: 1.12

Reason: Unable to download the artifact from any repository

  com.fg:fg-default-jdk15-library:pom:1.12
{noformat}

What do I need to do to run the tests?;;;","08/Jan/10 04:27;novoj;Sorry, I forget to remove our company parent pom. I will replace Zip with correct version. Give me some time please.;;;","08/Jan/10 04:36;novoj;Can you please try this one?;;;","08/Jan/10 05:16;roshandawrani;Still no luck - first compilation of java files was failing with the message that ""annotation/generics not supported. Try -source 1.5"". I configured the maven-compiler-plugin to use 1.5 source version.

After that downloads of javax/mail, javax/jms artifacts is not going through for me. :-(;;;","08/Jan/10 05:37;novoj;Javax libraries are not on public repositories due to licensing issues. They are not necessary for the test, but are probably in Log4J transitive dependencies. I will try to configure it better.;;;","08/Jan/10 05:43;novoj;I excluded problematic libraries and configured compiler plugin. Try it please and sorry not making it on the first strike. Nice example of environment differences.;;;","08/Jan/10 05:54;roshandawrani;I am now able to run the tests. Following are found to be failing - 

testReloadGroovyClass(com.fg.scripting.groovy.GroovyScriptingEngineReloadSupportTest)
testReloadLoadGroovyClass(com.fg.scripting.groovy.SpringGroovyReloadSupportTest)

Thanks for quickly assisting me in trying to reproduce the issue locally.;;;","08/Jan/10 06:01;novoj;It's for my own good :)
For this issue only test: testReloadGroovyClass(com.fg.scripting.groovy.GroovyScriptingEngineReloadSupportTest) is interesting. The second test is reported in another issue (GROOVY-3981), documenting incompatibility with Spring Framework.;;;","08/Jan/10 06:41;roshandawrani;One confusion. You pom shows that you are using spring 2.5.6 and spring/2.5.6/spring-2.5.6.pom shows that it depends on groovy 1.5.6.

I think, after 1.5.6 (especially in 1.7.0), GroovyScriptEngine has undergone a lot of changes in the (reloading) logic it uses to determine if sources/their dependencies have changed.

Will it be possible for you to try it with a version of spring that uses a newer groovy version and see if you still face this issue?

Changes to groovy 1.5.x line are not happening now anyway.;;;","08/Jan/10 06:49;roshandawrani;Or will the groovy version be taken from pom of your test code, which is 1.7.0?

Sorry I don't know maven much - just wanted to make sure that it is 1.7.0 that is getting used by test, as there is not much point in debugging it if it is using 1.5.6.

Can I make maven output the runtime classpath it is using?;;;","08/Jan/10 06:53;roshandawrani;Please ignore my last couple of comments. I forgot about your patch - you must have tested it on 1.7.0, so it must be 1.7.0 on the mvn classpath. Sorry.;;;","08/Jan/10 06:59;novoj;Yes, I am sure 1.7.0 is used - it's the explicit dependency set in pom.xml - try this:

mvn dependency:tree

This should print the dependent JARS.

Moreover, I've tested my patch on latest sources checked out from Subversion and test passes. Spring shouldn't be involved in this test as I use directly GroovyScriptEngine.;;;","08/Jan/10 08:07;roshandawrani;I have looked into the issue a bit and also the patch, and I think the patch is wrong. It is wrong because it is comparing a ScriptCacheEntry's modified time with current system time, which will always be true and hence the script will always get re-compiled, even when there are no changes to the script.

So, say, a script was first loaded by GSE at time T1 and next calls are made at T1 + t1(System.currentTimeMillis), T1 + t2, T1 + t3, and there is no change in the script file at all, but because T1 < T1 + t1(or t2 or t3) will always give true, it will keep getting re-compiled.

The idea is correct though - that in addition to looking at an entries dependencies, it should also look at the entry itself.

I will get back after looking a bit more.;;;","08/Jan/10 09:13;roshandawrani;Attaching the patch I propose.

It's getting rid of the failure ""testReloadGroovyClass(com.fg.scripting.groovy.GroovyScriptingEngineReloadSupportTest)"";;;","08/Jan/10 09:56;blackdrag;I thought the problem is that something is not recompiled... When it is always recompiled, then this makes no sense at all for me.

Checking the entry itself was not needed before, becaue the script has itself as dependency - at least I thought so. I guess that this might not always be the case;;;","08/Jan/10 10:02;roshandawrani;No, the script did not have itself as a dependency.

It's not that something is always getting recompiled - then the issue would not have been there, as you say. 

The main script was always getting recompiled if I tried the patch originally provided. On original 1.7.0, you are right that main entry was not getting recompiled and that was the problem in the issue reported here.;;;","08/Jan/10 11:18;novoj;Thank you for solving the issue Roshan - I clearly missed the point. It was a way harder that I initially thought.;;;","08/Jan/10 11:29;roshandawrani;Jochen, here is another patch that adds the script itself also to its dependencies.

The counts in the DepenendencyTest had to be incremented by 1 due to this extra dependency that is now there.;;;","08/Jan/10 12:10;blackdrag;seems I had the right intention and then forgot about it later in the implementation. Thanks Roshan, that patch looks good to me;;;","08/Jan/10 12:12;roshandawrani;Patch v2, right? I will go ahead and apply then?;;;","08/Jan/10 13:18;roshandawrani;Fixed.

You are welcome, Jan.;;;","08/Jan/10 22:54;paulk;Nice work!;;;","08/Jan/10 23:00;roshandawrani;Thanks, Paul :-);;;",,,,,,,,,,,,,,,,,,,,,,
Enum inside a class,GROOVY-3979,12815015,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,roshandawrani,xjia,xjia,07/Jan/10 11:42,07/Apr/10 23:46,14/Jul/23 06:00,13/Jan/10 04:33,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,,,,,1,,,,,,"Iteration of enum defined inside a class fails with the following exception:

Caught: groovy.lang.MissingMethodException: No signature of method:
static EnumTest2$Direction.values() is applicable for argument types: ()
values: []

The following example demonstrates the problem   

class EnumTest2 {  

  enum Direction { North, East, South, West } 

  static void main(args) { 
    for (d in Direction) { 
      println d
    }

  }

}",All,aalmiray,keeganwitt,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-4064,,,,,,,,,,,,,,,,GROOVY-3994,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 13 04:33:28 UTC 2010,,,,,,,,,,"0|i2ciyv:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"11/Jan/10 13:19;keegan;I've experienced the same issue, but when trying to use the valueOf method. Appears to be looking to the containing class instead of the enum.;;;","11/Jan/10 13:24;roshandawrani;Yes - valueOf(), next(), previous(), values() - all 4 methods are affected by it. Compiler is not adding these 4 methods to the enum when it is an enum defined inside a class due to some issue currently.;;;","13/Jan/10 04:33;roshandawrani;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Error in as Int[] conversion,GROOVY-3978,12814969,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,edcruz,edcruz,07/Jan/10 08:58,03/Feb/11 10:51,14/Jul/23 06:00,05/Oct/10 06:02,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.6,1.8-beta-3,,,,,,1,,,,,,"Running the next scritp will fail on second line when it should parse the numbers correctly.

def numbers = ['100','200','123']
def integers = numbers as Integer[]

Exception thrown: org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object '100' with class 'java.lang.String' to class 'java.lang.Integer'

org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object '100' with class 'java.lang.String' to class 'java.lang.Integer'
	at Script1.run(Script1:2)",Windows XP,davide.cavestro,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"04/Oct/10 17:13;paulk;groovy3978_asType_arrays.patch;https://issues.apache.org/jira/secure/attachment/12722458/groovy3978_asType_arrays.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 03 10:51:02 UTC 2011,,,,,,,,,,"0|i2cbqf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Jan/10 09:40;roshandawrani;Looks odd that

{code}
println ('100' as Integer) // gives 100
println (['1','2','3'] as Integer[]) // [49, 50, 51]
println (['100','200','123'] as Integer[]) // fails with the reported exception
{code}

Why are the rules different for a single element's String to Integer conversion and when the same happens in List to Array conversion? In List to Array conversion, String to Integer is allowed only for single-character strings (equivalent of retrieving the ascii value of that character);;;","04/Oct/10 17:13;paulk;Proposed patch attached. Test cases to come. It is a breaking change (albeit a corner case - bug in my view) so we should confirm the new behavior is what we are expecting. Behavior is now:
{code}
println ('1' as Integer) // gives 1
println ('100' as Integer) // gives 100
println (['1','2','3'] as Integer[]) // [1, 2 ,3]
println (['100','200','123'] as Integer[]) // [100, 200, 123]
{code}
;;;","03/Feb/11 10:51;blackdrag;fixing this issue caused a regression as seen in GROOVY-4657;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Auto-conversion inconsistency in BigDecimal treatment in method calls - Double vs Float,GROOVY-3977,12814995,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,06/Jan/10 22:57,07/Apr/10 23:47,14/Jul/23 06:00,07/Jan/10 02:19,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,1.7.1,1.8-beta-1,,,,,0,,,,,,"As reported by Peter on groovy user mailing list - :

{code}
class Foo {
 double myDouble
 float myFloat
}

def foo = new Foo()

// OK
foo.setMyDouble 0.1

/* groovy.lang.MissingMethodException: No signature of method: Foo.setMyFloat() 
is applicable for argument types: (java.math.BigDecimal) values: 0.1] */
foo.setMyFloat 0.1  
{code}",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 07 02:19:08 UTC 2010,,,,,,,,,,"0|i2cprz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Jan/10 02:19;roshandawrani;Fixed - as discussed on the groovy user list.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
No generic type information for closure parameters in generated closure class,GROOVY-3975,12815022,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,pniederw,pniederw,06/Jan/10 11:55,07/Apr/10 23:46,14/Jul/23 06:00,07/Jan/10 00:00,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.6.8,1.7.1,1.8-beta-1,Compiler,,,,0,,,,,,"cl = { List<String> s -> }

println cl.getClass().getMethod(""call"", List).genericParameterTypes[0]   // interface java.util.List (would have expected List<String>) 
println cl.getClass().getMethod(""doCall"", List).genericParameterTypes[0] // interface java.util.List (would have expected List<String>)

According to Jochen, this is a (probably easy to fix) bug.
",,pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 07 00:00:19 UTC 2010,,,,,,,,,,"0|i2c8tb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jan/10 13:42;roshandawrani;Tried for some time but couldn't really see any difference between a normal method that has generic using parameters and the ""call""/""doCall"".

""call""/""doCall"" are both getting the correct signature as 
<(Ljava/util/List<Ljava/lang/String;>;)Ljava/lang/Object;> - verified with jclasslib

Don't know why in parsing of method data, generic signature is coming as null.;;;","06/Jan/10 13:52;pniederw;Class file version is wrong for closure classes. Major version is 47 instead of 49.;;;","06/Jan/10 13:55;roshandawrani;Oh! Thanks a lot for saving me some time. 

I had started looking into how ASM's MethodWriter was dealing with signatures/parameters passed to it!;;;","06/Jan/10 14:03;pniederw;""couldn't really see any difference"" rang a bell :-);;;","06/Jan/10 14:13;roshandawrani;Normally whether a class is using generics or not(a flag that is used for determining what bytecode version to use) is set by ResolveVisitor, but closure inner classes are not run through all the phases - they don't undergo ""resolve"" phase.

So, the question is how this flag should be set on InnerClassNode of closure classes - should it inspect its fields/methods/parameters/return types, etc to derive whether any member is using generics. Or is it safe to set it as ""true"" always.

Don't want to affect closure classes generated for Java 1.4.;;;","07/Jan/10 00:00;roshandawrani;Simpler things come to mind after sleeping. :-)

Fixed.;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
adding method to class in ASTBuilder not working,GROOVY-3971,12815032,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,gavingrover,gavingrover,03/Jan/10 21:22,11/Jun/14 14:25,14/Jul/23 06:00,09/Jun/14 02:09,1.7-rc-2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,2.4.0-beta-1,,,ast builder,,,,1,,,,,,"The following code produces class MyClass OK, but running the class produces error:
*Exception in thread ""main"" java.lang.NoSuchMethodError: main*

Here's the ASTBuilder code I used:
{noformat}
import static org.objectweb.asm.Opcodes.ACC_PUBLIC
import static org.objectweb.asm.Opcodes.ACC_STATIC
import org.codehaus.groovy.ast.builder.AstBuilder
import org.codehaus.groovy.control.CompilerConfiguration
import org.codehaus.groovy.control.CompilationUnit

def classes= new AstBuilder().buildFromSpec{
  classNode 'MyClass', ACC_PUBLIC, {
    classNode Object //superclass
    interfaces{
      classNode GroovyObject
    }
    mixins{}
    genericsTypes{}
    method('main', ACC_PUBLIC & ACC_STATIC, Void.class) {
      parameters{
        parameter 'args': String[].class
      }
      exceptions{}
      block{
        methodCall {
          variable ""this""
          constant ""println""
          argumentList {
            constant ""Hello, world!""
          }
        }
      }
    }
  }
}

def gcl= new GroovyClassLoader()
def sec= null
def ccfg= CompilerConfiguration.DEFAULT
def cu= new CompilationUnit(ccfg, sec, gcl)
cu.addClassNode(classes[0])
cu.compile() 
{noformat}

Also tried this but same result:
{noformat}
import static org.objectweb.asm.Opcodes.ACC_PUBLIC
import static org.objectweb.asm.Opcodes.ACC_STATIC
import org.codehaus.groovy.ast.*
import java.security.CodeSource
import org.codehaus.groovy.ast.builder.AstBuilder
import org.codehaus.groovy.control.CompilerConfiguration
import org.codehaus.groovy.control.CompilationUnit
import org.codehaus.groovy.control.CompilePhase

def classes= new AstBuilder().buildFromString(CompilePhase.CONVERSION, """"""\
public class MyClass{
  public static void main(String[] args){
    println ""Hello, world!""
  }
}
"""""")

def gcl= new GroovyClassLoader()
def sec= null //new CodeSource()
def ccfg= CompilerConfiguration.DEFAULT
def cu= new CompilationUnit(ccfg, sec, gcl)
cu.addClassNode(classes[1])
cu.compile()
{noformat}
",Groovy 1.7-RC-2 on jre1.6.0_04 on Windows Vista SP2,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"06/Jan/10 01:33;hamletdrc;astbuilder_example.patch;https://issues.apache.org/jira/secure/attachment/12722303/astbuilder_example.patch",,,,,,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 09 05:46:20 UTC 2014,,,,,,,,,,"0|i2bra7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jan/10 21:44;gavingrover;javap output of class:

{noformat}
public class MyClass extends java.lang.Object implements groovy.lang.GroovyObject{
    public static java.lang.Long __timeStamp;
    public static java.lang.Long __timeStamp__239_neverHappen1262576568013;
    public MyClass();
    public java.lang.Object this$dist$invoke$2(java.lang.String, java.lang.Object);
    public void this$dist$set$2(java.lang.String, java.lang.Object);
    public java.lang.Object this$dist$get$2(java.lang.String);
    protected groovy.lang.MetaClass $getStaticMetaClass();
    public groovy.lang.MetaClass getMetaClass();
    public void setMetaClass(groovy.lang.MetaClass);
    public java.lang.Object invokeMethod(java.lang.String, java.lang.Object);
    public java.lang.Object getProperty(java.lang.String);
    public void setProperty(java.lang.String, java.lang.Object);
    static {};
    public void super$1$wait();
    public java.lang.String super$1$toString();
    public void super$1$wait(long);
    public void super$1$wait(long, int);
    public void super$1$notify();
    public void super$1$notifyAll();
    public java.lang.Class super$1$getClass();
    public boolean super$1$equals(java.lang.Object);
    public java.lang.Object super$1$clone();
    public int super$1$hashCode();
    public void super$1$finalize();
    static java.lang.Class class$(java.lang.String);
}
{noformat}
;;;","05/Jan/10 13:30;roshandawrani;For the 2nd example (AstBuilder#buildFromString()), here is the working code:

{code}
import static org.objectweb.asm.Opcodes.ACC_PUBLIC
import static org.objectweb.asm.Opcodes.ACC_STATIC
import org.codehaus.groovy.ast.*
import java.security.CodeSource
import org.codehaus.groovy.ast.builder.AstBuilder
import org.codehaus.groovy.control.CompilerConfiguration
import org.codehaus.groovy.control.CompilationUnit
import org.codehaus.groovy.control.CompilePhase

def classes = new AstBuilder().buildFromString(CompilePhase.CONVERSION, """"""\
public class MyClass{
  public static void main(String[] args){
    println ""Roshan here!""
  }
}
"""""")
def su = classes[1].module.context
def gcl = new GroovyClassLoader()
def sec = null //new CodeSource()
def ccfg = CompilerConfiguration.DEFAULT
def cu = new CompilationUnit(ccfg, sec, gcl)
cu.addClassNode(classes[1])
cu.addSource(su)
cu.compile()
{code};;;","05/Jan/10 14:19;roshandawrani;Regarding 1st example, the MethodNode (main) is not even getting added to ClassNode (MyClass)'s methods, so no wonder it is not coming in compiled class and then not able to run.;;;","05/Jan/10 16:59;paulk;Slightly tweaked version of Roshan's example:
{code}
import org.codehaus.groovy.ast.*
import org.codehaus.groovy.ast.builder.AstBuilder
import org.codehaus.groovy.control.CompilationUnit
import static org.codehaus.groovy.control.CompilerConfiguration.*
import static org.codehaus.groovy.control.CompilePhase.*

def classes = new AstBuilder().buildFromString(CONVERSION, """"""\
class MyClass {
  static main(String[] args){
    println ""Roshan here!""
  }
}
"""""")
def su = classes[1].module.context
def gcl = new GroovyClassLoader()
def cu = new CompilationUnit(DEFAULT, null, gcl)
cu.addClassNode(classes[1])
cu.addSource(su)
cu.compile()
MyClass.main()
{code};;;","06/Jan/10 00:11;roshandawrani;I should have mentioned here for documentation sake what was the change introduced for the 2nd example.

The issue was that because there was no SourceUnit attached to the CompilationUnit, it was skipping all SourceUnitOperation(s) in the compilation phases - ""resolve"" being one such skipped operation.

Because ""resolve"" was not happening, main method was remaining as ""main(LString;)V"" instead of ""main(Ljava.lang.String;)V"" and that's why it was not being recognized as the standard main method.;;;","06/Jan/10 01:33;hamletdrc;I don't think there is any issue with the AST Builder. I wrote a Transformation called ""Main"" that adds main methods to classes and it works fine. There are two errors in the posted script: 
  1: You must use ACC_PUBLIC | ACC_STATIC for the correct modifiers. The & is not correct. 
  2: You must use Void.TYPE for the return type, Void.class is not the same. 

I would commit this patch to the Groovy Example directory... what do you think? ;;;","06/Jan/10 01:45;roshandawrani;Hamlet, isn't the transformation solution different from what is asked for in the example 1 - where classNode and method both are defined in AstBuilder?

It was noticed that methods defined under AstBuilder (in buildFromSpec) don't get added to the defining ClassNode. Since that has not been addressed, wanted to check if AstBuilder is not supposed to support that.;;;","06/Jan/10 01:55;hamletdrc;Yes, this solution is slightly different because I wanted to make something a little more useful. However, it did work in my testing. The problems were in the pipe character, the return type, and all that CompilationUnit/SourceUnit stuff, not in the AST builder. Maybe I should retest it after work though. ;;;","06/Jan/10 02:02;roshandawrani;No, no, you missed my point. All other things you say are fine (modifier, return type, CompilationUnit/SourceUnit association, etc), except one.

This example is different from the issue #1 raised here because it is also doing the work of adding the MethodNode to the ClassNode - isn't that something that AstBuilder should also be able to do in its buildFromSpec()? 

Does AstBuilder not support the following (because right now, methods from the builder don't get associated with ClassNode)?
{code}
def classes= new AstBuilder().buildFromSpec{
  classNode 'MyClass', ACC_PUBLIC, {
    ....
    method('main', ACC_PUBLIC & ACC_STATIC, Void.class) {
        ....
    }
  }
}
{code};;;","06/Jan/10 02:41;paulk;Following on from Roshan's comments, currently, I can only solve the original problem using something like:
{code}
import static org.objectweb.asm.Opcodes.ACC_PUBLIC
import static org.objectweb.asm.Opcodes.ACC_STATIC
import static org.codehaus.groovy.control.CompilerConfiguration.*
import org.codehaus.groovy.ast.builder.AstBuilder
import org.codehaus.groovy.control.CompilationUnit

def classes = new AstBuilder().buildFromSpec {
  classNode 'HelloClass', ACC_PUBLIC, {
    classNode Object //superclass
    interfaces {
      classNode GroovyObject
    }
    mixins {}
  }
}

def methods = new AstBuilder().buildFromSpec {
  method('main', ACC_PUBLIC | ACC_STATIC, Void.TYPE) {
    parameters {
      parameter 'args': String[].class
    }
    exceptions{}
    block{
      expression {
        methodCall {
          variable ""this""
          constant ""println""
          argumentList {
            constant ""Hello, world!""
          }
        }
      }
    }
  }
}
def helloClass = classes[0]
def mainMethod = methods[0]
helloClass.addMethod(mainMethod)
def gcl = new GroovyClassLoader()
def cu = new CompilationUnit(DEFAULT, null, gcl)
cu.addClassNode(helloClass)
cu.compile()
{code}
It would be nice to have something like a {{methods{...}}} node which allowed the two to be combined.;;;","06/Jan/10 02:58;roshandawrani;And even on this, without a SourceUnit, all SourceUnitOperation(s) of the compilation are not happening - so no ""resolve"" is happening - all types have to be explicitly resolved, as in ""parameter 'args': String[].class""

Not sure whether such compile scenarios are supported by AstBuilder or not - once it goes beyond vanilla examples, differences from what compiler does normally may start coming in the way very fast - like ClassNodes not wrapped in a ModuleNode, no association with a SourceUnit, all SourceUnitOperation(s) getting skipped, etc.;;;","06/Jan/10 04:19;hamletdrc;In my opinion, using the ""buildFromSpecification"" requires the user to know the details of the ASTNode subtypes to use effectively. Similarly, using the SwingBuilder requires the user to know about the concrete Swing types as well. The builders are a nice convenience syntactically, but are not an abstraction hiding the details. Since this is the case, I would recommend _not_ adding convenience methods to the builder. Instead, add the convenience methods to the ASTNode subtypes directly and then add the support for these to the builder. I think the builder should remain a syntatic shortcut over the ASTNodes and not start adding too much Api to it. ;;;","06/Jan/10 04:25;hamletdrc;@Roshan

Your example should work fine with the AstBuilder. I guess I will have to look into it more. However, I'm still not convinced there is a bug in the AstBuilder. I think the error will come down to not using the API correctly. 

For instance, use the same example and replace all the AstBuilder with direct ASTNode constructors... I will bet that it doesn't work that way either. 

The test case for this needs to be an expected result created from ASTNode subclasses and an actual result created from AstBuilder... then compare the expected ASTNode to the actual ASTNode... all this wiring together and writing a class file is immaterial to the proper functioning of the builder. ;;;","06/Jan/10 04:50;roshandawrani;Well, if I replace all AstBuilder with direct ASTNode constructors, then apart from creating ClassNode and MethodNode using their constructors, I will also have to do ClassNode.addMethod(MethodNode) manually - for the ClassNode to compile into a class that has that method.

That's the question - is AstBuilder supposed to do that internally or is that the responsibility of the AstBuilder user (as in Paul's example).

If it is supposed to be AstBuilder's responsibility, then it is a bug in AstBuilder curently. If it is not, then that means the following is not supported:
{code}
new AstBuilder().buildFromSpec{
  classNode 'MyClass', ACC_PUBLIC, {
    ....
    method('main', ACC_PUBLIC & ACC_STATIC, Void.class) {
        ....
    }
  }
}
{code}

Just trying to understand how much AstBuilder supports out-of-the-box.;;;","06/Jan/10 05:08;hamletdrc;@Roshan

OK, I understand now. 

My reaction is that AstBuilder should not do this. But I could be convinced either way. How many edge cases like this are there, I wonder? How far in this direction do we go? ;;;","06/Jan/10 05:23;roshandawrani;I am not really sure that these are edge cases. To start with, there are FieldNode (which need the owner ClassNode in their constructor and also need to be added to ClassNode with addField()). Similarly for PropertyNodes (owner ClassNode + addProperty).

First question to ask is about the purpose of AstSpecificationCompiler - whether it even wants to support the compile scenario as in this JIRA.

If AstSpecificationCompiler wants to give out ClassNodes that are compilable, then I don't think it can avoid the API - it will have to setup of hierarchy of ASTNodes as the compiler expects.;;;","06/Jan/10 05:35;hamletdrc;Yes, I see the point. Perhaps that would be a good improvement. ;;;","06/Jan/10 06:40;guillaume;I agree here that the various edge case nodes have to be ""added"" to their respective parents, like method nodes, field nodes, property nodes to their class node parent.
(are we missing other nodes that need to be attached to their parent?);;;","06/Jan/10 10:59;hamletdrc;so, to summarize: 
we do want to auto-add these types to the parent. And this should be a minor improvement/enhancement that is part of a point release (7.1 most likely);;;","06/Jan/10 11:10;roshandawrani;Auto-wrapping expressions into statements may also be considered (like wrapping a MethodCallExpression into an ExpressionStatement).

Currently, it has to be done manually as below
{code}
block{
      expression { // we should see if this can be avoided at user level.
        methodCall {
         ....
        }
      }
    }
{code};;;","06/Jan/10 12:05;guillaume;@Hamlet, yes, a must-have minor improvement/enhancement, good for a point release in a month or so :-)
@Roshan, we not necessarily mandatory, but if there are some places / cases like these ones we can help further simplify, why not!;;;","07/Jan/10 06:40;hamletdrc;@Guillaume 

>> If there are some places / cases like these ones we can help further simplify, why not!

I am a little worried about where this leads. Currently, the best documentation for the buildFromSpec is the ASTNode javadoc. This is good, as it is backed by something thoroughly unit tested and is executable in some sense. If we diverge from a a simple wrapper then we need to add some sort of documentation or risk leaving users confused. But re-document the buildFromSpec then it is a big task and duplicates much of what is there. For me, I would not make these simplifications. ;;;","07/Jan/10 16:02;guillaume;@Hamlet, yes, you're certainly right, I guess it may be a bit confusing if the builder doesn't closely follow the AST Groovy generates. So let's not do such shortcuts, and keep the structure the same in the builder and in the ASTNodes.;;;","07/Jan/10 20:49;roshandawrani;Lost the thread a bit in the last couple of comments.

We are talking about avoiding convenience short-cuts like auto-wrapping methodCall{} in expression {} and sticking 1:1 between build and AST API as far as possible, but we are still good to go on the improvement suggested to add methods/fields/properties, etc and setup the hierarchy of ASTNodes appropriately to make the ClassNode coming out of ""buildFromSpec"" compilable, right?;;;","08/Jan/10 01:35;hamletdrc;@Roshan

That is correct. 

""We are talking about avoiding convenience short-cuts like auto-wrapping methodCall{} in expression {} and sticking 1:1 between build and AST API as far as possible, but we are still good to go on the improvement suggested to add methods/fields/properties, etc and setup the hierarchy of ASTNodes appropriately to make the ClassNode coming out of ""buildFromSpec"" compilable."";;;","08/Jun/14 05:27;paulk;See possible solution: https://github.com/groovy/groovy-core/pull/439

Current status: Allows method, constructor, property and field nodes to be embedded directly within a classNode spec currently without a wrapper helper method, e.g. ""methods {...}"". This makes creating classes much easier but violates the consistency of the spec in that creating every other node type involves just filling in the information from the constructor arguments. This deviates from that pattern. So, we should consider whether we want that before proceeding.;;;","08/Jun/14 14:51;paulk;I note that annotations aren't in the constructor and are checked for and added using addAnnotations (though for methods only). So, I'll adapt the proposed solution to work like that for other cases.

I also note that annotations can't be processed without a SourceUnit (leads to NPEs), so the above fragments don't support adding annotations in any case.;;;","09/Jun/14 02:09;paulk;I'll mark as resolved since the example below now runs:
{code}
// groovyjarjarasm import reflects using the embedded Groovy packaged asm jar
import static groovyjarjarasm.asm.Opcodes.*
import org.codehaus.groovy.ast.builder.AstBuilder
import org.codehaus.groovy.control.CompilerConfiguration
import org.codehaus.groovy.control.CompilationUnit

def classes = new AstBuilder().buildFromSpec{
  classNode 'MyClass', ACC_PUBLIC, {
    classNode Object //superclass
    interfaces {
      classNode GroovyObject
    }
    mixins{}
    genericsTypes{}
    methods {
      method('main', ACC_PUBLIC | ACC_STATIC, Void.TYPE) {
        parameters {
          parameter 'args': String[].class
        }
        exceptions{}
        block {
          expression {
            methodCall {
              variable ""this""
              constant ""println""
              argumentList {
                constant ""Hello, world!""
              }
            }
          }
        }
      }
    }
  }
}

def gcl = new GroovyClassLoader()
def sec = null
def ccfg = CompilerConfiguration.DEFAULT
def cu = new CompilationUnit(ccfg, sec, gcl)
cu.addClassNode(classes[0])
cu.compile()
{code}
Please reopen if you disagree.

I'll also note that if you add annotations into the example that it will no longer compile due to a missing source unit. I'm unsure how to get that working. I'll create another issue unless another developer can enlighten me as to how that would work.

I'll also note that I haven't used Hamlet's patch which has an integration test. Someone wanting to add such a test is welcome to harvest the relevant section of that patch.;;;","09/Jun/14 05:46;paulk;Just a followup to the previous comment. Setting a source unit seems to do the trick:
{code}
import static groovyjarjarasm.asm.Opcodes.*
import org.codehaus.groovy.ast.builder.AstBuilder
import org.codehaus.groovy.ast.*
import static org.codehaus.groovy.control.CompilerConfiguration.DEFAULT
import org.codehaus.groovy.control.*

def classes = new AstBuilder().buildFromSpec{
  classNode 'MyClass', ACC_PUBLIC, {
    classNode Object
    interfaces{ classNode GroovyObject }
    mixins{}
    annotations{ annotation Deprecated }
  }
}

def gcl = new GroovyClassLoader()
def cu = new CompilationUnit(DEFAULT, null, gcl)
def su = new SourceUnit(""dummyName"", ""dummySource"", DEFAULT, gcl, null)
ModuleNode module = new ModuleNode(su)
module.addClass(classes[0])
cu.AST.addModule(module)
cu.compile()
new GroovyShell().evaluate '''
  assert Class.forName(""MyClass"").annotations[0].toString() == '@java.lang.Deprecated()'
'''
{code};;;",,,,,,,,,,,,,,,,
GroovyConsole window loses focus when script is run,GROOVY-3966,12814997,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,pniederw,pniederw,02/Jan/10 07:50,07/Apr/10 23:46,14/Jul/23 06:00,19/Jan/10 21:34,1.7.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.7.1,1.8-beta-1,,Groovy Console,,,,0,,,,,,"When I run a script in Groovy Console, the window often (not always) loses focus. One effect is that I cannot run the same script again with Cmd+R without first clicking the window.","Mac OS 10.6.2
Java 1.6.0_17",pniederw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3854,,,,,,,,"08/Jan/10 03:27;roshandawrani;3854_v18x_CtrlQ_InterruptConfirmation.JPG;https://issues.apache.org/jira/secure/attachment/12722545/3854_v18x_CtrlQ_InterruptConfirmation.JPG","08/Jan/10 03:27;roshandawrani;3854_v18x_ExecutingMsgInStatusBar.JPG;https://issues.apache.org/jira/secure/attachment/12722306/3854_v18x_ExecutingMsgInStatusBar.JPG","08/Jan/10 03:28;roshandawrani;3854_v18x_Patch.txt;https://issues.apache.org/jira/secure/attachment/12722138/3854_v18x_Patch.txt","08/Jan/10 03:27;roshandawrani;3854_v18x_SimultaneousRunDisallowMsg.JPG;https://issues.apache.org/jira/secure/attachment/12722426/3854_v18x_SimultaneousRunDisallowMsg.JPG","07/Jan/10 09:07;roshandawrani;Executing_Msg_In_StatusBar.JPG;https://issues.apache.org/jira/secure/attachment/12722491/Executing_Msg_In_StatusBar.JPG","07/Jan/10 09:07;roshandawrani;Executing_Msg_In_StatusBar.txt;https://issues.apache.org/jira/secure/attachment/12722249/Executing_Msg_In_StatusBar.txt",,,6.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 19 21:34:18 UTC 2010,,,,,,,,,,"0|i2bnvj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jan/10 20:18;malbery;Possibly related: whenever I run a script in Groovy Console I get a tiny Awt/Swing window appear. That for me explains losing focus.;;;","02/Jan/10 20:29;pniederw;Right. So it's more correct to say that when the ""Groovy executing"" window closes, the main window doesn't always get the focus back. I only seem to have this problem for scripts that execute in a very short time.;;;","03/Jan/10 02:21;guillaume;Which reminds me there's the issue of the ""Groovy executing"" window itself. I think there's no JIRA issue yet about it, but the idea would be to get rid of it, and just have a message in the status window, for instance. And that could solve the problem itself as mentioned in this issue.;;;","04/Jan/10 09:36;malbery;I do see a window pop up righr when I execute my script. That goes away and another mini window pops up and stays there (see attached image). Perhaps this is no longer relevant to this issue however.;;;","04/Jan/10 09:38;guillaume;This may still be related.;;;","04/Jan/10 09:39;malbery;Ignore me. I just made a build from the head of trunk and it no longer happens.;;;","07/Jan/10 09:07;roshandawrani;Here is a patch that shows the ""Groovy is now executing"" message in the status bar instead of a modal dialog box.

If it seems ok to go ahead with this, then may be GROOVY-3854 can be used to apply it, as it is related.

One difference now will be that user can run the same script multiple times at the same time. Earlier the modal dialog box prevented that. Is that ok?;;;","07/Jan/10 09:17;pniederw;Isn't it important to have a way to abort a script execution? Also, if multiple scripts are run concurrently, I guess there would need to be separate output areas.;;;","07/Jan/10 09:27;roshandawrani;An alternative could be to remain functionally equivalent but just be less intrusive - by replacing Dialog Box + Interrupt with the following:

* Associate a key combination like Ctrl-C/Ctrl-Z to abort the script execution. (Status bar msg: ""Groovy is now executing. Please wait or press Ctrl-C to abort"")

* Disable UI options to run a script until current execution finishes - normally or abruptly.;;;","07/Jan/10 15:59;guillaume;The patch looks good to me -- but I haven't had the time to try it.
However, I would create a flag somewhere to say there's a script running, so that we can prevent launching twice the same script.
The idea of a Ctrl-C/Z is a good idea, working the same as the interrupt button from the old dialog box (ie. interrupting usually never works anyway).;;;","07/Jan/10 22:43;roshandawrani;GroovyConsole window losing focus may possibly be related to ""Groovy executing"" dialog box, so linking it with GROOVY-3854.

If we go ahead with removing the dialog box and replace it with a status bar message, both these issues may get fixed together.;;;","08/Jan/10 03:28;roshandawrani;Attaching a patch for review (3854* files).

The changes are:

1)  The modal dialog box that used to appear when script was executed has been replaced by a message in status bar, which reads ""Script executing now. Please wait or press Ctrl-Q to interrupt it."".

2)  An attempt to run a script when the previous one has not finished is rejected and status bar is updated with the message ""Cannot run script now as a script is already running. Please wait or press Ctrl-Q to interrupt it.""

3)  If the user presses Ctrl-Q when the script is running, a confirmation box is thrown and if the user chooses ""Yes"", the thread running the script is interrupted.

The corresponding screenshots are attached for reference.

Please let me know if I can go ahead now with these changes in GroovyConsole.;;;","14/Jan/10 10:51;roshandawrani;Peter, GROOVY-3854 fix has removed the dialog box and replaced it with messages in status bar as discussed here. Because of that change the focus shift from main console window to dialog box and back won't happen now.

Can you please check if you are still seeing the issue reported here?;;;","15/Jan/10 07:45;guillaume;Assigning it to Roshan as he's already implemented the solution.
I think the issue can be resolved now, as others have tested the patch.;;;","15/Jan/10 08:48;roshandawrani;Need to wait for 2 things before we mark this one as resolved:

1) It'll be good to know if Peter is not seeing the issue anymore.

2) Paul is having some issues with Ctrl-Q working on his Windows 7 machine. The shortcut is not bringing up the ""interrupt"" confirmation dialog box, so looks like Windows is gobbling up the ctrl-Q signal. He is looking more into it. Let's wait to hear from him on the same.;;;","15/Jan/10 11:18;pniederw;Old problems are solved, but CTRL+Q shortcut is problematic. Shortcut won't work on Mac because on this platform, CRTL is mapped to CMD, and CMD+Q always means ""quit application"".
Although I can't get to it on my Mac, I think the confirmation box is unnecessary. I don't press a shortcut like CTRL+Q unintentionally. Also, there is not even a confirmation box when I completely exit GroovyConsole (which I can do with CMD+Q).
An ""Interrupt"" button (e.g. next to the ""Run"" button and only enabled when a script is running) would be more helpful, and would give additional feedback that a script is running. The message in the status bar is easy to miss, and casual users are usually uncomfortable with using shortcuts.;;;","15/Jan/10 11:30;roshandawrani;Ctrl-Q is giving issues on Windows 7 also. So I don't mind removing it and making invocation of ""interrupt"" explicit by an Interrupt button + menu item (as for Run)

Let's see what others think of this UI change + an interrupt confirmation when the user tries to exit from groovyconsole.
;;;","18/Jan/10 07:51;roshandawrani;Hi Peter,
    I have changed the implementation of ""interrupt script"" now. It can now be invoked by the toolbar/menu item ""Interrupt Script"" that get enabled only while the script is running. Also if the script is running, the user is asked if he wants to interrupt the script before exiting, which allows the user to interrupt or wait for it to finish before existing.

Can you check if this implementation works out any better for you?

Thanks,
Roshan
;;;","18/Jan/10 07:54;roshandawrani;I should have added that the changes have been done only on the trunk as of now.;;;","19/Jan/10 07:43;roshandawrani;Peter, if you can check out the new implementation (on trunk) and provide feedback, it will be good.

Paul has confirmed that he is fine with the changes on his Win 7 and Ubuntu environments where he was facing issues.;;;","19/Jan/10 21:34;roshandawrani;This should no longer be an issue after the changes done under GROOVY-3854.;;;",,,,,,,,,,,,,,,,,,,,,,,,
Inconsistent numbering - deploying groovy artifacts to Maven repositories,GROOVY-3965,12814994,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,roshandawrani,roshandawrani,roshandawrani,01/Jan/10 08:23,22/Jul/10 17:33,14/Jul/23 06:00,01/Jan/10 09:29,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,1.8-beta-1,,,,,,,0,,,,,,"Raised by Russel on the groovy dev mailing list (reproducing here)

---------------------------------------------------
It appears that the trunk Groovy build system creates groovy jars with
the number 1.8.0-beta-1-SNAPSHOT but installs to the Maven repository
using the artifactId 1.8-beta-1-SNAPSHOT.  This inconsistency is
seriously irritating for doing certain scripting hacks.
---------------------------------------------------",,russel,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 01 09:29:52 UTC 2010,,,,,,,,,,"0|i2cq3z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Jan/10 09:29;roshandawrani;Fixed;;;",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
