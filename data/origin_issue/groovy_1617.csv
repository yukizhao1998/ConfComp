Summary,Issue key,Issue id,Issue Type,Status,Project key,Project name,Project type,Project lead,Project description,Project url,Priority,Resolution,Assignee,Reporter,Creator,Created,Updated,Last Viewed,Resolved,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Affects Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Fix Version/s,Component/s,Component/s,Component/s,Due Date,Votes,Labels,Labels,Labels,Labels,Labels,Labels,Description,Environment,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Watchers,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Log Work,Original Estimate,Remaining Estimate,Time Spent,Work Ratio,Σ Original Estimate,Σ Remaining Estimate,Σ Time Spent,Security Level,Outward issue link (Blocker),Inward issue link (Cloners),Outward issue link (Cloners),Inward issue link (Container),Inward issue link (Duplicate),Inward issue link (Duplicate),Outward issue link (Duplicate),Outward issue link (Problem/Incident),Outward issue link (Problem/Incident),Inward issue link (Reference),Inward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Outward issue link (Reference),Inward issue link (Regression),Outward issue link (Regression),Outward issue link (Regression),Attachment,Attachment,Attachment,Custom field (Affects version (Component)),Custom field (Attachment count),Custom field (Blog - New Blog Administrators),Custom field (Blog - New Blog PMC),Custom field (Blog - Write access),Custom field (Blog Administrator?),Custom field (Blogs - Admin for blog),Custom field (Blogs - Email Address),Custom field (Blogs - Existing Blog Access Level),Custom field (Blogs - Existing Blog Name),Custom field (Blogs - New Blog Write Access),Custom field (Blogs - Username),Custom field (Bug Category),Custom field (Bugzilla - Email Notification Address),Custom field (Bugzilla - List of usernames),Custom field (Bugzilla - PMC Name),Custom field (Bugzilla - Project Name),Custom field (Bugzilla Id),Custom field (Bugzilla Id),Custom field (Change Category),Custom field (Complexity),Custom field (Discovered By),Custom field (Docs Text),Custom field (Enable Automatic Patch Review),Custom field (Epic Link),Custom field (Estimated Complexity),Custom field (Evidence Of Open Source Adoption),Custom field (Evidence Of Registration),Custom field (Evidence Of Use On World Wide Web),Custom field (Existing GitBox Approval),Custom field (External issue URL),Custom field (Fix version (Component)),Custom field (Flags),Custom field (Git Notification Mailing List),Custom field (Git Repository Import Path),Custom field (Git Repository Name),Custom field (Git Repository Type),Custom field (GitHub Options),Custom field (Github Integration),Custom field (Github Integrations - Other),Custom field (Global Rank),Custom field (INFRA - Subversion Repository Path),Custom field (Initial Confluence Contributors),Custom field (Last public comment date),Custom field (Level of effort),Custom field (Machine Readable Info),Custom field (Mentor),Custom field (New-TLP-TLPName),Custom field (Original story points),Custom field (Parent Link),Custom field (Priority),Custom field (Project),Custom field (Protected Branch),Custom field (Rank),Custom field (Rank (Obsolete)),Custom field (Review Date),Custom field (Reviewer),Custom field (Severity),Custom field (Severity),Custom field (Skill Level),Custom field (Source Control Link),Custom field (Space Description),Custom field (Space Key),Custom field (Space Name),Custom field (Start Date),Custom field (Tags),Custom field (Target end),Custom field (Target start),Custom field (Team),Custom field (Test and Documentation Plan),Custom field (Testcase included),Custom field (Tester),Custom field (Workaround),Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment,Comment
Issue With Static Compiler And Generics,GROOVY-8427,13127712,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,jeffscottbrown,jeffscottbrown,29/Dec/17 21:11,03/Feb/22 22:34,14/Jul/23 06:02,09/May/21 13:55,2.4.13,,,,,,,,2.5.15,3.0.8,4.0.0-beta-1,,Compiler,,,,0,,,,,,,"This code will compile:

{code:title=src/main/groovy/demo/Bar.groovy|borderStyle=solid}
package demo
import java.util.function.Consumer
import groovy.transform.CompileStatic

@CompileStatic
class Bar {

    static <T> void foo(T a, Consumer<T> c) {  }

    static void main(args) {
        def c = {
            foo('') {
                println 'hello'
            }
        }
    }
}
{code}

This code will not compile:

{code:title=src/main/groovy/demo/Bar.groovy|borderStyle=solid}
package demo
import java.util.function.Consumer
import groovy.transform.CompileStatic

@CompileStatic
class Bar {

    static <T> void foo(T a, Consumer<T> c) {  }

    static void main(args) {
        def c = {
            // this following line is the only difference
            int x = 0
            foo('') {
                println 'hello'
            }
        }
    }
}
{code}

{noformat}
/Users/jeffbrown/projects/project/src/main/groovy/demo/Bar.groovy: 14: [Static type checking] - Cannot call <T> demo.Bar#foo(T, java.util.function.Consumer <T>) with arguments [java.lang.String, groovy.lang.Closure <java.lang.Void>] 
 @ line 14, column 13.
               foo('') {
               ^

1 error
{noformat}

I have only tested with Groovy 2.4.13.",,jeffscottbrown,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 31 01:39:10 UTC 2017,,,,,,,,,,"0|i3odj3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Dec/17 01:39;paulk;Looks weird to me. You can also get the compiler to behave by returning String from your Closure, e.g.:
{code}
 def c = {
    int x = 0 // with or without is fine
    foo('') {
        println 'hello'
        ''
    }
}
{code};;;",,,,,,,,,,,,,,,,,,,,,
Private and protected inner classes have incorrect access modifier values,GROOVY-8423,13127004,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,24/Dec/17 06:04,09/Dec/19 21:36,14/Jul/23 06:02,14/Nov/19 23:25,2.4.13,,,,,,,,3.0.0-rc-2,,,,Compiler,,,,0,,,,,,,"{code}
import java.lang.reflect.Modifier           
class Foo {                                 
    private class Private {}
    protected class Protected {}

    static void test() {
        assert Modifier.isPrivate(Private.class.getModifiers()) \\ 0
        assert Modifier.isProtected(Protected.class.getModifiers()) \\ 1
    }            
}                                           
Foo.test()
{code}

The test above fails (on both assertions). This appears to be due to the ACC_PRIVATE and ACC_PROTECTED modifiers being removed/replaced for inner classes, as well as from their inner class table entries (see GROOVY-6357). Though those modifiers aren't valid for the classes themselves, they are allowed in the inner classes table (https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.6).",,githubbot,shils,,,,,,,"asfgit commented on pull request #648: GROOVY-8423: Do not adjust access modifiers for inner class table ent…
URL: https://github.com/apache/groovy/pull/648
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;14/Nov/19 23:24;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,600,,,0,600,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 24 18:33:56 UTC 2017,,,,,,,,,,"0|i3o95z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Dec/17 17:58;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/648

    GROOVY-8423: Do not adjust access modifiers for inner class table ent…

    …ries

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-8423

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/648.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #648
    
----
commit 9353cbf62713a63f43cb22dafd6e4c99885ea9a1
Author: Shil Sinha <shils@...>
Date:   2017-12-24T17:54:22Z

    GROOVY-8423: Do not adjust access modifiers for inner class table entries

----
;;;","24/Dec/17 18:33;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/648#discussion_r158607705
  
    --- Diff: src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java ---
    @@ -305,11 +305,6 @@ private void makeInnerClassEntry(ClassNode cn) {
             }
             int mods = adjustedClassModifiersForInnerClassTable(cn);
     
    -
    -        if (Modifier.isPrivate(mods)) {
    --- End diff --
    
    I'm unsure about removing this block as the commit message suggests it was necessary for android support. Does anyone know the history behind this? @melix 
;;;",,,,,,,,,,,,,,,,,,,,
Incorrect properties copy in Sql.newInstance ,GROOVY-8422,13126901,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,thw,thw,22/Dec/17 21:55,26/Jul/18 04:44,14/Jul/23 06:02,06/Mar/18 03:30,2.4.13,,,,,,,,2.4.15,,,,SQL processing,,,,0,,,,,,,"The constructor `Properties(Properties defaults)` does not create a copy, but a new object with the argument as defaults. That breaks JDBC drivers that expect the properties to be present in the object directly (enumerating of keys, containsKey etc.).

",,githubbot,jwagenleitner,thw,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 06 03:30:09 UTC 2018,,,,,,,,,,"0|i3o8jb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Dec/17 21:58;thw;https://github.com/apache/groovy/blob/4139798c5715403bcba0de2bf64d80a5aa1cb613/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java#L585

{code}
        if (props != null) {
            Properties propsCopy = new Properties(props);
            connection = DriverManager.getConnection(url.toString(), propsCopy);
{code};;;","05/Mar/18 16:39;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/671

    GROOVY-8422: Incorrect properties copy in Sql.newInstance

    The provided Properties should be passed to the DriverManager as-is.
    A copy is only needed when changes are made to the provided Properties
    in order to mask sensitive information for logging purposes.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8422-sql-props

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/671.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #671
    
----
commit 1f833b4af4e5e5ac667967b55f279e9534d5ec58
Author: John Wagenleitner <jwagenleitner@...>
Date:   2018-03-05T16:35:33Z

    GROOVY-8422: Incorrect properties copy in Sql.newInstance
    
    The provided Properties should be passed to the DriverManager as-is.
    A copy is only needed when changes are made to the provided Properties
    in order to mask sensitive information for logging purposes.

----
;;;","06/Mar/18 03:03;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/671
;;;","06/Mar/18 03:30;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,
getSet* property name => Cannot read write-only property exception,GROOVY-8418,13125064,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,emge,emge,15/Dec/17 00:11,24/Nov/19 02:44,14/Jul/23 06:02,30/Oct/19 18:58,2.4.7,,,,,,,,2.5.8,3.0.0-rc-1,,,Compiler,,,,0,,,,,,,"* When accessing a property whose name starts with ""getSet"", Groovy throws
{code}
GroovyRuntimeException: Cannot read write-only property: getSet...
{code} 
* Example:
{code}
// Returns the SQL update statement representation of the DB object
GString getSetSql() { ... }
{code}
",,emge,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 30 18:58:48 UTC 2019,,,,,,,,,,"0|i3nx9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Oct/19 18:58;emilles;Tested with this code:
{code:groovy}
class Groovy8418 {
  static main(args) {
    def obj = this.newInstance()
    println obj.getSetOfValues()
    println obj.setOfValues
  }
  def getSetOfValues() {
    'stuff'
  }
}
{code}

Prints ""stuff\nstuff\n"", with or without {{@CompileStatic}}.;;;",,,,,,,,,,,,,,,,,,,,,
Map-based constructor generated by @Immutable works only with HashMap,GROOVY-8416,13124997,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,anma,anma,14/Dec/17 16:30,25/May/21 15:59,14/Jul/23 06:02,06/Mar/18 23:38,2.4.13,,,,,,,,2.5.0-beta-3,,,,,,,,0,,,,,,,"If you call the map-based constructor of an {{@Immutable}} class with a non-{{HashMap}}, it will try to set the properties via setters, which causes a {{ReadOnlyPropertyException}}. Somehow it works with {{HashMap}} or subclasses like {{LinkedHashMap}}. Why?

{code}
import groovy.transform.Immutable

@Immutable
class Point {
	int x
	int y
}

def coordinates = [x: 1, y: 2]
assert coordinates instanceof LinkedHashMap

def p1 = new Point(coordinates)
assert p1.x == 1

def p2 = new Point(new HashMap(coordinates))
assert p2.x == 1

try {
	new Point(new TreeMap(coordinates))
} catch (e) {
	assert e instanceof ReadOnlyPropertyException
}

try {
	new Point(coordinates.asImmutable())
} catch (e) {
	assert e instanceof ReadOnlyPropertyException
}
{code}",,anma,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10108,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 06 23:38:22 UTC 2018,,,,,,,,,,"0|i3nwun:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Dec/17 00:35;paulk;I'll have to look at the code and tests to remember for sure but I think there is some provision made for Map-based properties, i.e. this is allowed:
{code}
@Immutable
class Point {
  TreeMap props
}

TreeMap map = [color: 'red', x: 2, y: -3]
println new Point(map)
println new Point(props: map)
{code}
So both an ordered tuple constructor (with TreeMap arg) and map-based constructor (with HashMap arg) are provided.
There are issues if props above is made a Map or HashMap for example and I think only one Map-based constructor is provided. Perhaps the assumptions behind that code can be improved though.;;;","06/Mar/18 23:38;paulk;This was fixed as part of recent changes for 2.5.0-beta-3 but I forgot to close this issue before release. Commit: e5e8fe1af3

It means in your example you can now do:
{code}
def p3 = new Point(new TreeMap(coordinates))
assert p3.x == 1
{code}
;;;",,,,,,,,,,,,,,,,,,,,
Static compilation with generic function wrapping BiFunction causes GroovyCastException,GROOVY-8409,13123925,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,emilles,svella,svella,09/Dec/17 16:55,02/Sep/22 23:54,14/Jul/23 06:02,07/May/21 15:18,2.4.13,2.4.8,,,,,,,2.5.17,3.0.11,4.0.0-beta-1,,Static compilation,,,,1,,,,,,,"I have a statically compiled class with a method that declares Generic type T as it's return type and accepts a parameter of type java.util.function.BiFunction also with return type T. It makes a call to the passed in BiFunction and assigns the the result to a variable of type T.
{code:java}
static <T> T actionWrapperT(BiFunction<Date, URL, T> action) {
        T result = action.apply(new Date(), new URL('http://www.example.com'))
        // do something else here
        return result
    }
{code}
When actionWrapperT is called with runtime type T as something other than Date (e.g. XXX), it causes a GroovyCastException.
{panel}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'XXX@71b1176b' with class 'XXX' to class 'java.util.Date'
{panel}
because it incorrectly tries to cast result type to Date rather than to XXX.

It appears to me that the compiler is conflating generic type T as declared for the generic method with generic type T as declared by BiFunction<T,U,R> because if I change the name of the generic type of the generic method to R (to match the return type name of BiFunction) or to some other name not used by BiFunction, then it works correctly, but if I change it to U to match the second parameter of the BiFunction then it fails trying to cast to the BiFunction generic type U instead of the method generic type U.

Problem does not happen under normal compilation or with only type checking enabled.

Attached file Bug.groovy reproduces the problem.",MacOS Sierra 10.12.6,daniel_sun,kenzierocks,paulk,svella,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-9267,,,,,,,GROOVY-10745,,,,,,"09/Dec/17 16:54;svella;Bug.groovy;https://issues.apache.org/jira/secure/attachment/12901363/Bug.groovy",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Oct 07 02:08:56 UTC 2018,,,,,,,,,,"0|i3nq9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Dec/17 21:53;svella;Since reporting this issue 10 days ago I have run into this same general problem several times, which is probably best described as the generic type names from the call site scope getting conflated with the generic type names from declaration when CompileStatic is enabled. I've seen it both manifest itself at run time as described in the original bug because of an erroneous call to castTo() and at compile time where it either erroneously flags a type mismatch or can't resolve a property or method because it's trying to do so with the wrong type.;;;","18/Aug/18 10:01;daniel_sun;The content of resolvedPlaceholders is shown as follows:
{code:java}
{R=T, T=java.util.Date, U=java.net.URL}
{code}
Note: the `T` of `R=T` is defined by user, but the `T` of `T=java.util.Date` is defined in `BiFunction`. As a result, R -> T -> Date

We should not just use generics name whose type is `String`.

 

The relevant code is:
{code:java}
//https://github.com/apache/groovy/blob/master/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java#L4954-L4957

        Map<String, GenericsType> resolvedPlaceholders = resolvePlaceHoldersFromDeclaration(receiver, getDeclaringClass(method, arguments), method, method.isStatic());
        if (!receiver.isGenericsPlaceHolder()) {
            GenericsUtils.extractPlaceholders(receiver, resolvedPlaceholders);
        }
{code};;;","19/Aug/18 12:30;daniel_sun;Since `GenericsType` does not have declaring class, so it will cost more time to fix the issue... 
You can workaround the issue as follows(rename the generics parameter to other name, e.g. `X`)


{code:java}
        import groovy.transform.CompileStatic
        import java.util.function.BiFunction
        @CompileStatic
        class Groovy8409Bug {
        
            static <X> X actionWrapperT(BiFunction<Date, URL, X> action) {
                X result = action.apply(new Date(), new URL('http://www.example.com'))
                // do something else here
                return result
            }
        
            static void main(String[] args) {
                Groovy8409Bug t = actionWrapperT { Date date, URL url -> new Groovy8409Bug() }
            }
        
        }
{code};;;","19/Aug/18 14:02;daniel_sun;See `GenericsTypeName` https://github.com/apache/groovy/blob/master/src/main/java/org/codehaus/groovy/ast/GenericsType.java#L502-L514
;;;","26/Aug/18 01:44;paulk;Standalone example for testing showing two failing cases and two working cases (R workaround since that matches the third generic type in BiFunction and V since that avoids all existing types):
{code}
import java.util.function.BiFunction
import groovy.transform.CompileStatic

//@CompileStatic (if uncommented: GroovyCastException: Cannot cast object 'foo' with class 'java.lang.String' to class 'java.util.Date')
static <T> T actionWrapperT(BiFunction<Date, URL, T> action) {
    T result = action.apply(new Date(), new URL('http://www.example.com'))
    // do something else here
    return result
}

//@CompileStatic (if uncommented: GroovyCastException: Cannot cast object 'foo' with class 'java.lang.String' to class 'java.net.URL')
static <U> U actionWrapperU(BiFunction<Date, URL, U> action) {
    U result = action.apply(new Date(), new URL('http://www.example.com'))
    // do something else here
    return result
}

@CompileStatic
static <R> R actionWrapperR(BiFunction<Date, URL, R> action) {
    R result = action.apply(new Date(), new URL('http://www.example.com'))
    // do something else here
    return result
}

@CompileStatic
static <V> V actionWrapperV(BiFunction<Date, URL, V> action) {
    V result = action.apply(new Date(), new URL('http://www.example.com'))
    // do something else here
    return result
}

actionWrapperT{ Date d, URL u -> ""foo"" }
actionWrapperU{ Date d, URL u -> ""foo"" }
actionWrapperR{ Date d, URL u -> ""foo"" }
actionWrapperV{ Date d, URL u -> ""foo"" }
{code}
I will raise the priority of this too.;;;","07/Oct/18 00:53;kenzierocks;This is a pretty big blocker for {{@CompileStatic}} usage in Gradle, as with 5.0 {{PluginContainer#getPlugin(Class)}} can no longer return the type of the passed class according to the type checker. I'm willing to take a look into adding the required scoping information to {{GenericsTypeName}} if no one else is already doing so.

 

See also: (1) from https://github.com/gradle/gradle/issues/7048.;;;","07/Oct/18 02:08;daniel_sun;Hi [~kenzierocks],

I tried to fix the issue, but time was not allowed(completed some refactoring to extract GenericsTypeName), so I'm very glad to know you are willing to investigate the issue. As you found, the core problem is how to add scope information(e.g. declaring class, enclosing generics type, etc.) to GenericsTypeName.

 As a note side, the following two {{L}}(1st -> String, 2nd -> GString) and two {{R}} (1st -> Integer, 2nd -> Long) should be distinguished too, so only declaring class is not enough, maybe we need enclosing generics type too.
{code:java}
class Pair<L, R> {}

           L       R              L        R
Pair<Pair<String, Integer>, Pair<GString, Long>>
{code}

Cheers,
Daniel.Sun
;;;",,,,,,,,,,,,,,,
invokeMethod cannot be set  through category,GROOVY-8408,13123658,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,ecerulm,ecerulm,08/Dec/17 09:19,26/Jul/18 04:38,14/Jul/23 06:02,04/May/18 00:12,2.4.13,2.5.x,2.6.0-alpha-2,3.x,,,,,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,,,,,,0,,,,,,,"In the Groovy in Action book, chapter 8.4.5 says 

{quote}Category method names can well take the form of property accessors (pretending property access), operator methods, and GroovyObject methods. MOP hook methods cannot be added through a category class. This is a restriction as of Groovy 2.4. The feature may become available in later versions.{quote}

It interpreted this as meaning that I can add GroovyMethods (getProperty,
getMetaClass, invokeMethod , setMetaClass and setProperty)  to a class using categories but not
methodMissing or propertyMissing (which I think they call MOP hook methods in the GINA book).

But when I tried to add invokeMethod using a category the change has no effect, adding missingMethod does not work either see attachement. 

I see that methodsMissing/ propertyMissing via category was probably never supported noted in GROOVY-3867. But the Groovy in Action paragraph makes me think that invokeMethod et al were supported at some point. 



Mailing list thread with [~blackdrag] on the [mailing list|http://markmail.org/message/xlj74kawyayspnzv?q=list:org%2Eapache%2Egroovy%2Eusers+category+category]


",,daniel_sun,ecerulm,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-3867,,,,,,"08/Dec/17 09:16;ecerulm;categoryMissingMethod.groovy;https://issues.apache.org/jira/secure/attachment/12901215/categoryMissingMethod.groovy",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 04 00:12:32 UTC 2018,,,,,,,,,,"0|i3nom7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/May/18 00:12;daniel_sun;The proposed PR is merged. Thanks!

https://github.com/apache/groovy/commit/ad664b181249c4b8e8821003d7e750632943ce36;;;",,,,,,,,,,,,,,,,,,,,,
antlr4 jar file has not been repackaged into groovy-all-2.6.0-XXX-indy.jar,GROOVY-8407,13123595,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,daniel_sun,daniel_sun,08/Dec/17 00:05,08/Dec/17 01:08,14/Jul/23 06:02,08/Dec/17 01:08,2.6.0-alpha-1,2.6.0-alpha-2,,,,,,,2.6.0-alpha-3,,,,,,,,0,,,,,,,"antlr4 jar file has not been repackaged into groovy-all-2.6.0-XXX-indy.jar, but groovy-all-3.0.0-XXX-indy.jar contains antlr4 jar file.",,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 08 01:08:48 UTC 2017,,,,,,,,,,"0|i3no87:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Dec/17 01:08;daniel_sun;Fixed by https://github.com/apache/groovy/commit/6546b0b346b62cdf4545c09b640d96f88812f9e4;;;",,,,,,,,,,,,,,,,,,,,,
Inherited methods with default parameters cause cause static compilation to fail,GROOVY-8405,13123547,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,nathanwharvey,nathanwharvey,07/Dec/17 20:35,13/Dec/18 10:05,14/Jul/23 06:02,18/Aug/18 08:49,2.5.0-beta-1,,,,,,,,2.5.3,3.0.0-alpha-4,,,Static compilation,,,,0,,,,,,,"Given a super type with a method that has a default argument:

{code}
@CompileStatic
class SuperType {
	void sample(String string, Integer arg=0) {}
}
{code}

And a subclass that extends the method, but omits the optional parameters:
{code}
@CompileStatic
class SubType extends SuperType {
	@Override
	void sample(String string) {}
}
{code}

Static type checking fails to pick which method to call in the following code:
{code}
@CompileStatic
class BrokenMethods {
	public static void main(String[] args) {
		new SubType().sample('hi')
	}
}
{code}

The error message is:
{code}
Reference to method is ambiguous. Cannot choose between [void codes.nom.broken.SubType#sample(java.lang.String), void codes.nom.broken.SubType#sample(java.lang.String)]
{code}",,daniel_sun,daniilo,nathanwharvey,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 18 08:49:02 UTC 2018,,,,,,,,,,"0|i3nnxj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Aug/18 08:49;daniel_sun;The issue is fixed. Here is the test: 

https://github.com/apache/groovy/commit/680317fc2c4e9cdf2707b386e5cc5f49f670bab9;;;",,,,,,,,,,,,,,,,,,,,,
Trait FieldHelper is not marked synthetic,GROOVY-8403,13122854,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,daniilo,daniilo,05/Dec/17 11:55,14/Aug/18 08:05,14/Jul/23 06:02,06/Aug/18 15:20,,,,,,,,,2.5.2,,,,Compiler,,,,0,,,,,,,,,daniilo,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 06 15:20:54 UTC 2018,,,,,,,,,,"0|i3njon:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Dec/17 22:53;daniilo;Obvious question: is it intentional?;;;","06/Aug/18 15:20;paulk;It seems to me like it should match the normal Helper class.;;;",,,,,,,,,,,,,,,,,,,,
GroovyScriptEngine.ScriptClassLoader applies compilation customizers twice,GROOVY-8402,13122468,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,03/Dec/17 23:09,06/Mar/18 23:14,14/Jul/23 06:02,12/Dec/17 06:26,2.4.13,,,,,,,,2.4.14,,,,GroovyScriptEngine,,,,0,,,,,,,"ScriptClassLoader.createCompilationUnit calls super.createCompilationUnit, which initializes a new CompilationUnit. As phase operations for compilation customizers are already added in the constructor for CompilationUnit, they should not be added again at the end of ScriptClassLoader.createCompilationUnit.",,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 12 05:58:19 UTC 2017,,,,,,,,,,"0|i3nhc7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Dec/17 23:21;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/641

    GROOVY-8402: GroovyScriptEngine.ScriptClassLoader applies compilation…

    … customizers twice

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-8402

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/641.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #641
    
----
commit 1b660cfae31b56aa2a33739f078513ac8d78c19b
Author: Shil Sinha <shils@apache.org>
Date:   2017-12-03T23:19:57Z

    GROOVY-8402: GroovyScriptEngine.ScriptClassLoader applies compilation customizers twice

----
;;;","12/Dec/17 05:58;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/641
;;;",,,,,,,,,,,,,,,,,,,,
ImportCustomizer is applied once per class (should be once per module),GROOVY-8399,13122379,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,emilles,emilles,02/Dec/17 21:24,21/Feb/20 02:17,14/Jul/23 06:02,22/Nov/19 01:19,,,,,,,,,3.0.0-rc-2,,,,Compiler,,,,0,breaking,,,,,,CompilerConfiguration with ImportCustomizer gets applied once per class in a source unit.  If unit has a lot of classes this can cause a lot of extra imports processing.{{CompilationUnit.applyToPrimaryClassNodes(PrimaryClassNodeOperation)}} is the loop that drives the CompilationCustomizers.  {{org.codehaus.groovy.control.customizers.ImportCustomizer.call}} is where imports are added.  Could check if ClassNode param is the primary class in the module before applying.  Or {{ModuleNode}} could allow {{addImport}} and just dedup internally.,,emilles,paulk,,,,,,,"eric-milles commented on pull request #1097: GROOVY-8399: apply import customizations only once per module
URL: https://github.com/apache/groovy/pull/1097
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;21/Nov/19 18:12;githubbot;600","danielsun1106 commented on pull request #1097: GROOVY-8399: apply import customizations only once per module
URL: https://github.com/apache/groovy/pull/1097
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;22/Nov/19 01:18;githubbot;600","danielsun1106 commented on issue #1097: GROOVY-8399: apply import customizations only once per module
URL: https://github.com/apache/groovy/pull/1097#issuecomment-557344694
 
 
   Merged. Thanks.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;22/Nov/19 01:18;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 21 02:17:01 UTC 2020,,,,,,,,,,"0|i3ngsv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Feb/20 02:17;paulk;Added breaking label: For anyone using import customizers and relying on the previous sub-optimal behavior, consider the workaround discussed in GROOVY-9407.;;;",,,,,,,,,,,,,,,,,,,,,
@CompileStatic doesn't respect resolve strategy on closures,GROOVY-8394,13120880,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,daniilo,daniilo,27/Nov/17 10:30,11/Nov/20 02:01,14/Jul/23 06:02,29/Oct/19 18:40,2.4.13,,,,,,,,2.5.8,,,,Static compilation,Static Type Checker,,,0,,,,,,,"{code}

class Root {
  Parent parent = new Parent()

  def parent(@DelegatesTo(Parent) Closure cl) {
    cl.delegate = parent
    cl()
  }
}

class Parent {
  Child child = new Child()

  def child(@DelegatesTo(Child) Closure cl) {
    cl.delegate = child
    cl()
  }

  def foo() { ""parent"" }
}

class Child {
  def foo() { ""child"" }
}

@groovy.transform.CompileStatic
def usage() {
  new Root().parent {
    child {
      foo()
    }
  }
}

println usage()
{code}

Expected result: {{parent}}
Actual result: {{child}}

Closure inside {{child &#123;&#125;}} call has default resolve strategy, i.e. owner first. Its owner is a closure passed to {{parent &#123;&#125;}}, which is delegated to {{Parent}}, which in turn has the method {{foo}}.

Works properly without {{@CompileStatic}}.",,blackdrag,daniilo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 27 12:44:58 UTC 2017,,,,,,,,,,"0|i3n7kv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Nov/17 12:44;blackdrag;additional information: Setting no strategy in @DelegatesTo means OWNER_FIRST. As described, the owner of the child Closure is the parent Closure, which means the call should be resolved as if done from the owner Closure. This seems not to be the case;;;",,,,,,,,,,,,,,,,,,,,,
Static import of a property messes with instance method,GROOVY-8389,13120673,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,daniilo,daniilo,24/Nov/17 18:58,16/May/23 13:29,14/Jul/23 06:02,29/Jun/18 19:47,2.4.13,2.5.0-beta-2,,,,,,,2.5.1,2.6.0-alpha-5,3.0.0-alpha-4,,Static compilation,Static Type Checker,,,0,,,,,,,"{code:title=bugs.groovy}
import static A.bar

class A {
  static bar = ""A""
}

def bar() {
  ""bar""
}

@groovy.transform.CompileStatic
def usage() {
  bar()
}

println usage() 
{code}

{noformat}
13: [Static type checking] - Cannot find matching method A#bar(). Please check if the declared type is right and if the method exists.
 @ line 13, column 3.
     bar()
     ^
{noformat}",,daniel_sun,daniilo,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7490,GROOVY-11056,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 29 19:47:31 UTC 2018,,,,,,,,,,"0|i3n6av:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Nov/17 22:51;paulk;Another example:
{code}
import static A.baz
import static A.bar

class A {
  static bar = { ""Abar"" }
  static baz = { ""Abaz"" }
}

def bar() {
  ""bar""
}

@groovy.transform.CompileStatic
def usage() {
  bar() + baz()
}

assert usage() == 'barAbaz'
{code}
Works with {{@CS}} commented out (and indicates in dynamic Groovy that local explicit methods with the same name as static imports are allowed and take precedence - worth checking other cases to make sure this is by design) but otherwise fails with:
{noformat}
2 compilation errors:
[Static type checking] - Cannot find matching method A#bar(). Please check if the declared type is right and if the method exists...
[Static type checking] - Cannot find matching method A#baz(). Please check if the declared type is right and if the method exists...
{noformat};;;","29/Jun/18 19:47;daniel_sun;Fixed by https://github.com/apache/groovy/commit/c91f3e4543d56959e6ca5084cd463a9b82e8666c;;;",,,,,,,,,,,,,,,,,,,,
Invalid module-info.class in jar artifacts,GROOVY-8387,13119666,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,20/Nov/17 13:58,06/Mar/18 23:25,14/Jul/23 06:02,21/Nov/17 07:32,2.6.0-alpha-2,3.x,,,,,,,2.5.0-beta-3,2.6.0-alpha-3,,,,,,,0,,,,,,,"Due to jarjar of ASM 6, we get a bogus module-info.class file in our artifacts on master and GROOVY_2_6_X. We need to prune this out in the gradle build file.

We want to ultimately have our own such file but we haven't worked out what its contents would be yet and that will have its own issue.",,daniel_sun,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8489,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Mar 03 01:49:25 UTC 2018,,,,,,,,,,"0|i3n047:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Nov/17 15:16;emilles;Even Groovy 2.5's groovy-all jar contains a module-info.class;;;","20/Nov/17 15:40;uschindler;I think when packaging JARs that use something like Maven Shade Plugin / Jarjar (or similar), you should explicitely exclude module-info.class when building the zipfileset to call JARJAR using an exclude. Other packaged libs (not only ASM) may suddenly include this file. This hurts especially uber-jars.

IMHO, we should also file bugs at Maven and Gradle to take care that their shading/packagerewrite/uber-jar plugins take care of that exclusion automatically.

FYI, when using ANT with Jarjar Bings I had a similar issue and this was fixed for me like that: https://github.com/policeman-tools/forbidden-apis/commit/1654d5d38e40ee500ca7ae82b146ed6fcfba0827;;;","21/Nov/17 07:32;paulk;Yes, I had forgotten we had moved 2_5_X to ASM 6 also. Should be fixed now.;;;","02/Mar/18 19:52;emilles;Groovy 2.4.14 has module-info.class in groovy-all.jar.  Was it supposed to be removed?;;;","02/Mar/18 20:00;emilles;This bug appears in Groovy 2.4.14 as well.

;;;","03/Mar/18 01:49;paulk;[~emilles] we bumped the ASM version in 2.4 for some reason. I'll clone the issue to cover getting it fixed.;;;",,,,,,,,,,,,,,,,
Final variable analysis broken with try/catch/finally,GROOVY-8386,13119482,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,19/Nov/17 12:25,27/Feb/20 11:04,14/Jul/23 06:02,24/Dec/17 06:37,2.5.x,,,,,,,,2.5.0-beta-3,,,,Compiler,,,,0,,,,,,,"In this code:
{code}
final begin
try {
  begin = new Date()
} finally {
  println 'done'
}
{code}
The current error is:
{noformat}
The variable [begin] may be uninitialized
{noformat}
But this should only happen if begin is used in the catch or finally blocks or prior to the first assignment.

This impacts Spock usage since it converts the following into something similar to above:
{code}
@Grab('org.spockframework:spock-core:1.1-groovy-2.4-SNAPSHOT')
@GrabExclude('org.codehaus.groovy:groovy-all')
import spock.lang.Specification

class DummySpec extends Specification {
    def 'FVA when using Spock'() {
        given:
        final begin = new Date()

        cleanup:
        println 'done'
    }
}
{code}
",,githubbot,paulk,zman0900,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"27/Feb/20 11:03;paulk;screenshot-1.png;https://issues.apache.org/jira/secure/attachment/12994761/screenshot-1.png",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 27 11:04:43 UTC 2020,,,,,,,,,,"0|i3myzb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Dec/17 07:14;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/646

    GROOVY-8386/GROOVY-8094: Final variable analysis broken with try/catc…

    …h/finally and if/then/else

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy fva

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/646.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #646
    
----
commit be854b73091a1b284efb7682a19df843f09e6df5
Author: paulk <paulk@...>
Date:   2017-12-22T07:11:51Z

    GROOVY-8386/GROOVY-8094: Final variable analysis broken with try/catch/finally and if/then/else

----
;;;","24/Dec/17 06:32;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/646
;;;","24/Dec/17 06:37;paulk;Proposed PR #464 applied.;;;","27/Feb/20 09:05;zman0900;This is still broken with 2.5.9:
{code:groovy}
import groovy.transform.CompileStatic
import java.nio.file.Files
import java.nio.file.Path

@CompileStatic
class Test {
    static void main(String... args) {
        new Test().run()
    }

    void run() {
        // Removing 'final' prevents error
        final Path x
        try {
            x = Files.createTempDirectory('delete-me')
            println ""Created temp dir: $x""
            // Some stuff with x that might throw
            throw new IOException('poo')
        } finally {
            println 'in finally'
            if (x) {
                // This works without println below. Maybe because it's a groovy-added method?
                x.deleteDir()
                // Error on this println
                // When removed, no error and code runs to completion
                println ""Deleted temp dir: $x""
            }
            println 'done'
        }
    }
}
{code}

Error message:

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/tmp/Test.groovy: 26: The variable [x] may be uninitialized
. At [26:45]  @ line 26, column 45.
     println ""Deleted temp dir: $x""
                                 ^

1 error
{noformat}


;;;","27/Feb/20 11:04;paulk;This was debated quite a bit and we eventually went with Java semantics here as per screenshot:
 !screenshot-1.png! ;;;",,,,,,,,,,,,,,,,,
Regression in 2.4.13 (snapshot) with STC and intdiv,GROOVY-8384,13119227,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,patric42,patric42,17/Nov/17 13:34,06/Mar/18 23:12,14/Jul/23 06:02,19/Nov/17 11:20,2.4.13,,,,,,,,2.4.13,,,,Static compilation,,,,0,,,,,,,"Even with the fix of 8380, the following still fails:
{code}
@groovy.transform.CompileStatic
class GanzBla {
   static void main(String[] args) {
      def a = 5.intdiv(2)
      assert a.class == java.lang.Integer
      def b = new Long( 5.intdiv(2) )
   }
}
{code}

Without CS, this just works, the type of 5.intdiv(2) is an Integer. With STC, it's a number suddenly. In 2.4.12, this still works flawlessly.
",any,githubbot,patric42,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 19 22:47:01 UTC 2017,,,,,,,,,,"0|i3mxen:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Nov/17 14:32;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/639

    GROOVY-8384 - Regression in 2.4.13 snapshot with STC and intdiv plus …

    …some cleanup

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8384

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/639.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #639
    
----
commit 6387ed88c22d5b74ec731aba37afec67dd229120
Author: paulk <paulk@asert.com.au>
Date:   2017-11-18T14:29:08Z

    GROOVY-8384 - Regression in 2.4.13 snapshot with STC and intdiv plus some cleanup

----
;;;","19/Nov/17 05:04;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/639
;;;","19/Nov/17 11:20;paulk;Proposed PR applied.;;;","19/Nov/17 22:47;patric42;Thank you :D;;;",,,,,,,,,,,,,,,,,,
OptimizerVisitor#setConstField not @CS friendly,GROOVY-8383,13119144,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,17/Nov/17 08:13,06/Mar/18 23:12,14/Jul/23 06:02,19/Nov/17 11:21,,,,,,,,,2.4.13,,,,,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
def method() {
    Long wrapper = 2L
    long prim = 2L
}
method()
{code}
gives:
{noformat}
java.lang.NoSuchFieldError: $const$0
{noformat}
swapping the second {{2L}} with {{3L}} or {{wrapper}} side steps the problem.
The primitive and wrapper constants are being deemed the same but the types won't match ({{J}} vs {{Ljava/lang/Long;}}). Other types are also affected but seemingly not int or double. Swapping the order has no affect. I assume the code in OptimizerVisitor#setConstField is not @CS friendly. That code has an early return for Integer and Double.

In addition, the current implementation has a limitation if the user uses field names similar to what the visitor generates, e.g. {{$const$0}}. A similar error will occur if such a field exists but has the wrong type:
{code}
class Bar {
  private String $const$0 = 'bar'
  def method2() {
    Long wrapper3 = 20L
  }
}
new Bar().method2() // => NoSuchFieldError
{code}
And if it happens to be the ""correct"" type it can lead to weird errors:
{code}
class Bar {
  private static long $const$0 = 42
  def method2() {
    long prim4 = 21L
  }
}
assert new Bar().method2() == 42 // expected 21!
{code}
",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 19 11:21:23 UTC 2017,,,,,,,,,,"0|i3mwwf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Nov/17 04:52;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/640

    GROOVY-8383: OptimizerVisitor#setConstField not @CS friendly

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8383

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/640.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #640
    
----
commit 3ec550a50803f10ba343db7b0a9c1b38c543d9f3
Author: paulk <paulk@asert.com.au>
Date:   2017-11-19T04:49:31Z

    GROOVY-8383: OptimizerVisitor#setConstField not @CS friendly

----
;;;","19/Nov/17 05:04;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/640
;;;","19/Nov/17 11:21;paulk;Proposed PR applied.;;;",,,,,,,,,,,,,,,,,,,
Target Typing for empty collections should work for field/property initialisers,GROOVY-8382,13118902,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,16/Nov/17 13:09,06/Mar/18 23:12,14/Jul/23 06:02,17/Nov/17 12:45,,,,,,,,,2.4.13,,,,,,,,0,,,,,,,"{code}
import groovy.transform.*
@CompileStatic
@ToString(includeFields=true)
class Foo {
    List<String> propWithGen = ['propWithGen'] ?: []
    List propNoGen = ['propNoGen'] ?: []
    private List<String> fieldGen = ['fieldGen'] ?: []
    def bar() {
        this.propNoGen = ['notDecl'] ?: [] // not applicable here
        List<String> localVar = ['localVar'] ?: []
        localVar
    }
}

def foo = new Foo()
assert foo.bar() == ['localVar']
assert foo.toString() == 'Foo([propWithGen], [notDecl], [fieldGen])'
{code}",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 17 12:46:52 UTC 2017,,,,,,,,,,"0|i3mvev:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Nov/17 13:43;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/637

    GROOVY-8382: Target Typing for empty collections should work for fiel…

    …d/property initialisers

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8382

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/637.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #637
    
----
commit 40f1b2953472fdb20bd1fc35ec26b3d435d6a72b
Author: paulk <paulk@asert.com.au>
Date:   2017-11-16T13:40:14Z

    GROOVY-8382: Target Typing for empty collections should work for field/property initialisers

----
;;;","16/Nov/17 21:12;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/637
;;;","17/Nov/17 12:45;paulk;Proposed PR merged.;;;","17/Nov/17 12:46;paulk;As well as the field/property examples above, this fixes the issues reported by the nextflow project.;;;",,,,,,,,,,,,,,,,,,
"Regression in 2.4.13-SNAPSHOT: x & y, x | y, x ^ y lose typing information",GROOVY-8380,13118261,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,patric42,patric42,14/Nov/17 14:31,06/Mar/18 23:12,14/Jul/23 06:02,17/Nov/17 13:08,2.4.13,,,,,,,,2.4.13,,,,Static compilation,,,,0,,,,,,,"This used to work up to 2.4.12:
{code}
@groovy.transform.CompileStatic
class bla {
   static void main(String[] args) {
      println new Long( 5 / 3 )
   }
}
{code}

starting with 2.4.13, it gives this error message:
{noformat}
bla.groovy: 4: [Static type checking] - Cannot find matching method java.lang.Long#<init>(java.math.BigDecimal). Please check if the declared type is right and if the method exists.
 @ line 4, column 15.
         println new Long( 5 / 3 )
{noformat}

",any,blackdrag,patric42,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Important,,,,,,,,9223372036854775807,,,Fri Nov 17 13:08:48 UTC 2017,,,,,,,,,,"0|i3mrgf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Nov/17 14:56;patric42;The reason seems to be the fix for GROOVY-8325.;;;","14/Nov/17 22:02;paulk;It's not clear to me if this is a bug though perhaps the fix in GROOVY-8325 could have been done in 2.5+. From looking at the changed code, it was always the intention to fail the match due to loss of precision but a missing {{redirect()}} meant that it was incorrectly passed for quite some time.

Dynamic Groovy does not match that constructor in 2.4.12 due to possible loss of precision (and I tried numerous versions back to 1.8.9 with the same result):
{noformat}
groovy.lang.GroovyRuntimeException:
Could not find matching constructor for: java.lang.Long(java.math.BigDecimal)
{noformat}
Perhaps we need an error message indicating possible loss of precision as the cause.

Static Groovy also rejects: {{Long foo = 5 / 3}} but dynamic Groovy accepts this.

Anyway, let's see what others think.;;;","14/Nov/17 22:46;patric42;How about {code}new Integer( 3 & (-1 ^ 3) ){code}?

;;;","14/Nov/17 23:32;paulk;That does look wrong but unrelated. It matches what this gives:
{code}
Integer x = -1 & 3
{code}
but these are okay:
{code}
Integer x = 1 & 3
new Long(6 & 3)
{code}
and this is okay:
{code}
int a = -1
int b = 3
int c = a & b
{code}
It seems that we match on {{NumberMathModificationInfo#or}} for primitives but fall back to the {{Number}} variant for wrapper types. And for whatever reason, constant 3 is given type {{int}} but constant -1 is given type {{Integer}}. We don't do that for other operators like + and *, so there is room for improvement there.;;;","15/Nov/17 02:47;blackdrag;Please bear in mind, that an assignment in dynamic Groovy is no substitute for a method parameter. In Groovy the assignment involves an implicit cast, that is not the case for a method call. So it is always legal to assign a number typed value to a variable with another number type, even if that means a loss of precision. As for what types are compatible with a Long/long typed parameter you should take a look at LongCachedClass#isAssignableFrom.You will see there, that Double, Float and BigDecimal are no candidates. And if you then look at DoubleCachedClass and FloatCachedClass, you will that loss of precision is really no factor here. In fact if you look at IntegerCachedClass you will see that it is perfectly legal to pass an BigInteger or Long for an int parameter.

What we did not do in dynamic Groovy is allow floating points typed arguments for integer types parameters. Why that is... frankly I have no idea.That goes back to March 2008 at least. But I don´t think that was a change, since even groovy-beta-9 fails to call a method with a long parameter using a BigDecimal argument.

Static Groovy has the ""no loss of precision"" rule, thus here it should be even more clear what is required.;;;","15/Nov/17 06:13;paulk;Right, that's correct. Please ignore the assignment example difference between static/dynamic above as dynamic Groovy has extra coercion going on of course. So, to summarise, here is what used to happen:
{code}
Long wl = 1L
long pl = 1L
assert new Integer(wl & wl) > 0  // GRE when dynamic, STC incorrectly passes
assert new Long(wl & wl) > 0     //
assert new Integer(pl & pl) > 0  // GRE when dynamic, STC detects
assert new Long(pl & pl) > 0     //
assert new Long(6 & 3) == 2L     //
assert new Long(-2 & 3) == 2L    //
{code}
Here is what happens now:
{code}
Long wl = 1L
long pl = 1L
assert new Integer(wl & wl) > 0  // GRE, STC detects
assert new Long(wl & wl) > 0     // STC incorrectly fails
assert new Integer(pl & pl) > 0  // GRE, STC detects
assert new Long(pl & pl) > 0     //
assert new Long(6 & 3) == 2L     //
assert new Long(-2 & 3) == 2L    // STC incorrectly fails
{code}
Fixing the GROOVY-8325 bug has revealed another.

The type for x & y is being correctly determined for primitives ({{WideningCategories.isIntCategory}}) but fails for wrappers. 6 is given type int, -2 is given type Integer, so it also fails.
;;;","15/Nov/17 14:30;blackdrag;The GRE for new Integer(wl & wl) is a bit strange to be frank. Looking at https://github.com/codehaus/groovy-git/blob/master/src/main/org/codehaus/groovy/reflection/stdclasses/IntegerCachedClass.java#L51 I see BigInteger but not Long and long.... so while this explains the GRE I feel like something is wrong here. How can a BigInteger be ok, but a Long not? This means I can do {code:Java}
​def foo(int i) {1}
assert foo(Long.MAX_VALUE as BigInteger)​ == 1​
{code} But I cannot do {code:Java}
​def foo(int i) {1}
assert foo(1L)​ == 1​
{code}
Anyway... this is probably another issue and not subject of this here. Here it is all about the remaining STC failure ;;;","17/Nov/17 12:53;paulk;Yes, that was unclear for me too. My guess is that the BigInteger in IntegerCachedClass is a mistake since it isn't included in LongCachedClass.;;;","17/Nov/17 13:08;paulk;I have fixed the issue with &, | and ^ and I'll close this issue as fixing those. If you wish to comment further about {{new Long(5 / 3)}}, then please create another issue but that isn't meant to be supported.;;;",,,,,,,,,,,,,
hashCode() generated by @EqualsAndHashCode is inefficient for instances with null fields or properties,GROOVY-8377,13117779,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,erdi,erdi,12/Nov/17 10:44,25/Nov/17 13:31,14/Jul/23 06:02,25/Nov/17 12:45,2.4.12,2.5.0-beta-2,2.6.0-alpha-2,,,,,,2.6.0-alpha-3,3.0.0-alpha-1,,,,,,,0,performance,,,,,,"In a project I work on there is a relatively large hash map for which the key type has a {{@EqualsAndHashCode}} generated {{hashCode()}}. After introducing an additional property to the key type, for which the value is {{null}} on most instances, I noticed a massive degradation in efficiency of adds to the aforementioned map.

After some digging around it turns out that the AST generated by that transform performs an identity check using {{is()}} between the property/field value and {{this}}. In cases where the property/field value is {{null}} this leads to a {{NullObject.is()}} call, for which, as far as I understand, no call site caching occurs.

A PR with a jmh benchmark and a very simple fix to follow.",,daniel_sun,erdi,githubbot,melix,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8391,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Nov 25 13:31:18 UTC 2017,,,,,,,,,,"0|i3mohj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Nov/17 10:56;githubbot;GitHub user erdi opened a pull request:

    https://github.com/apache/groovy/pull/633

    GROOVY-8377 Equals and hash code ast performance

    See [GROOVY-8377](https://issues.apache.org/jira/browse/GROOVY-8377) for the rationale behind this PR.
    
    Given how simple the fix is and its impact (from 3k ops/ms to 30k ops/ms on my machine) I'd suggest considering backporting of it to 2.4.x, 2.5.x and 2.6.x lines.
    
    <rant>
    Working on this was harder then it should be down to:
    - the build takes a minute(!) to configure, I believe it is down to [this code](https://github.com/apache/groovy/blob/1c42f421edd91f31aa35a3e7b7113910718b35d5/build.gradle#L93)
    - the jmh benchmarks for Groovy code are broken and [needed fixing as part of my PR](https://github.com/erdi/groovy/commit/fc1d085a120bd7a542edeb7c1ff4b06816b776b2)
    
    I understand that I worked against master, but the experience was highly unwelcoming.
    </rant>

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/erdi/groovy equals-and-hash-code-ast-performance

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/633.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #633
    
----
commit fc1d085a120bd7a542edeb7c1ff4b06816b776b2
Author: Marcin Erdmann <erdi84@gmail.com>
Date:   2017-11-12T10:23:26Z

    Fix Groovy dependency in performance tests to be the same as the one used by Gradle so that jmh benchmarks using Groovy don't fail

commit 3c6d1d462569259aad6ef95b73af4c17837595b0
Author: Marcin Erdmann <erdi84@gmail.com>
Date:   2017-11-12T10:25:03Z

    Add a benchmark for hashCode() generated using @EqualsAndHashCode when instance on which hashCode() is called has null fields and properties

commit 2ce280083e30d912829d010592384c72b5b406cf
Author: Marcin Erdmann <erdi84@gmail.com>
Date:   2017-11-12T10:26:39Z

    Add a test to verify that changes to generating hashCode() for instances with null fields and properties and EqualsAndHashCodeASTTransformation have no impact on the value returned

commit bd2b79c2cf67b99020265dca2465e18b2a40b2c8
Author: Marcin Erdmann <erdi84@gmail.com>
Date:   2017-11-12T10:29:41Z

    Improve performance of generated hashCode() methods for instances with null fields and properties by avoiding calling NullObject.is() method for which no call site caching occurs.

----
;;;","12/Nov/17 10:57;erdi;PR: https://github.com/apache/groovy/pull/633;;;","17/Nov/17 10:50;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/633
;;;","17/Nov/17 13:06;paulk;See my comment on the PR. I won't close just yet to give us time to ponder whether further backporting is needed.;;;","25/Nov/17 12:45;daniel_sun;It is fixed in 3.0.0, so I will close it to release 3.0.0-alpha-1. Feel free to reopen when further backporting is needed.;;;","25/Nov/17 12:47;melix;Can we backport to 2.5? It's kind of weird to have it in 3.0, when 2.5 is not even out.;;;","25/Nov/17 13:31;paulk;It gets hard keeping track if we re-open issues, so I cloned the issue instead.;;;",,,,,,,,,,,,,,,
GrapeIvy downloads wrong artifact for non-default conf when artifact name is not the same as the module,GROOVY-8372,13115543,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,emilles,erwaman,erwaman,02/Nov/17 05:03,09/Dec/19 21:35,14/Jul/23 06:02,09/Nov/19 15:18,2.2.2,,,,,,,,2.5.9,3.0.0-rc-2,,,Grape,,,,0,,,,,,,"In my Ivy repo, there exists the following directory with the following contents:

{noformat}
com/example/foo/bar/1.2.3/
  bar-1.2.3.jar
  bar-1.2.3.ivy
  bar-qux-1.2.3.jar
{noformat}

In bar-1.2.3.ivy, the following conf and publication exist:

{noformat:title=bar-1.2.3.ivy}
...
<configurations>
  <conf name=""qux""/>
  ...
</configurations>
...
<publications>
  <artifact name=""bar"" type=""jar"" ext=""jar"" conf=""apiElements,archives,runtime,runtimeElements""/>
  <artifact name=""bar-qux"" type=""jar"" ext=""jar"" conf=""qux""/>
  ...
</publications>
...
{noformat}

When I try to use Grape to resolve bar-qux-1.2.3.jar by setting

* org = com.example.foo
* module = bar
* version = 1.2.3
* conf = qux

bar-1.2.3.jar gets downloaded instead of bar-qux-1.2.3.jar.

This issue seems to be caused by GROOVY-6470. The correct jar (bar-qux-1.2.3.jar) gets downloaded when using groovy-all-2.2.1, but the wrong jar is downloaded when using groovy-all-2.2.2 and newer.",,erwaman,githubbot,paulk,,,,,,"eric-milles commented on pull request #1071: GROOVY-8372: GrapeIvy: pass remote (not local) conf to addDependencyArtifact
URL: https://github.com/apache/groovy/pull/1071
 
 
   add dependency artifacts only if ext, type or classifier is non-default
   
   closes #626
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;06/Nov/19 21:35;githubbot;600","paulk-asert commented on issue #1071: GROOVY-8372: GrapeIvy: pass remote (not local) conf to addDependencyArtifact
URL: https://github.com/apache/groovy/pull/1071#issuecomment-551042388
 
 
   +1. This looks like it is doing the right thing and appears to solve the manual test case in the jar attached to this issue.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Nov/19 11:36;githubbot;600","danielsun1106 commented on pull request #1071: GROOVY-8372: GrapeIvy: pass remote (not local) conf to addDependencyArtifact
URL: https://github.com/apache/groovy/pull/1071
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Nov/19 04:08;githubbot;600","danielsun1106 commented on pull request #626: GROOVY-8372: GrapeIvy downloads wrong artifact for non-default conf when artifact name is not the same as the module
URL: https://github.com/apache/groovy/pull/626
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Nov/19 04:08;githubbot;600","danielsun1106 commented on issue #1071: GROOVY-8372: GrapeIvy: pass remote (not local) conf to addDependencyArtifact
URL: https://github.com/apache/groovy/pull/1071#issuecomment-552064082
 
 
   Merged. Thanks.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Nov/19 04:09;githubbot;600","erwa commented on issue #1071: GROOVY-8372: GrapeIvy: pass remote (not local) conf to addDependencyArtifact
URL: https://github.com/apache/groovy/pull/1071#issuecomment-552114666
 
 
   Thanks for fixing this issue!
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Nov/19 16:21;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3600,,,0,3600,,,,,,,,,,,GROOVY-6470,,,,,,,,"26/Nov/17 19:48;erwaman;grapesTest.zip;https://issues.apache.org/jira/secure/attachment/12899310/grapesTest.zip",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 14 00:13:49 UTC 2018,,,,,,,,,,"0|i3maqn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Nov/17 05:07;githubbot;GitHub user erwa opened a pull request:

    https://github.com/apache/groovy/pull/626

    GROOVY-8372: GrapeIvy downloads wrong artifact for non-default conf when artifact name is not the same as the module

    Ref: https://issues.apache.org/jira/browse/GROOVY-8372

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/erwa/groovy remove-conf-optional-check

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/626.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #626
    
----
commit 679d924169d9d14f11050666e445ec9105187f66
Author: Anthony Hsu <ahsu@linkedin.com>
Date:   2017-11-02T05:04:14Z

    GROOVY-8372: GrapeIvy downloads wrong artifact for non-default conf when artifact name is not the same as the module

----
;;;","05/Nov/17 10:50;paulk;Any chance you can zip up some minimal repo so that we can replicate your issue?
Also, we'll need to think about whether we can add some test coverage for this case and possibly also the GROOVY-6470 issue which this undoes to make sure that case doesn't re-surface.;;;","08/Nov/17 04:30;erwaman;Thanks, [~paulk], for taking a look. Let me see if I can create a minimal setup that reproduces the issue. I'll hopefully have some time later this week or this weekend.;;;","26/Nov/17 19:51;erwaman;Attached a self-contained zip that illustrates the issue. With Groovy 2.2.1, the correct y-foo-1.2.3.jar gets resolved:

{code}
$ javac -cp .:lib/groovy-all-2.2.1.jar:lib/ivy-2.4.0.jar GrapesTest.java && java -cp .:lib/groovy-all-2.2.1.jar:lib/ivy-2.4.0.jar GrapesTest
...
[SUCCESSFUL ] x#y;1.2.3!y-foo.jar (3ms)
{code}

whereas with Groovy 2.2.2, y-1.2.3.jar gets resolved (incorrect):

{code}
$ javac -cp .:lib/groovy-all-2.2.2.jar:lib/ivy-2.4.0.jar GrapesTest.java && java -cp .:lib/groovy-all-2.2.2.jar:lib/ivy-2.4.0.jar GrapesTest
...
[SUCCESSFUL ] x#y;1.2.3!y.jar (2ms)
{code};;;","14/Feb/18 00:13;erwaman;[~paulk], could you take another look – I've attached a zip that reproduces the issue.;;;",,,,,,,,,,,,,,,,,
Enum property access not working with @CompileStatic,GROOVY-8369,13113293,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,paulk,paulk,31/Oct/17 12:30,06/Mar/18 23:12,14/Jul/23 06:02,01/Nov/17 09:20,2.4.12,,,,,,,,2.4.13,,,,Static compilation,,,,0,,,,,,,"{code}
import groovy.transform.CompileStatic

enum Foo { }

@CompileStatic
def test() {
  println Foo.getModifiers() // => 16401 // ENUM | FINAL | PUBLIC (see GROOVY_8360 wrt STATIC)
  println Foo.modifiers      // java.lang.NoSuchFieldError: modifiers
}

test()
{code}",,githubbot,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 01 16:15:52 UTC 2017,,,,,,,,,,"0|i3lwun:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Oct/17 22:43;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/625

    GROOVY-8369: Statically compiled property access on enum class throws…

    … NoSuchFieldError

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-8369

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/625.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #625
    
----
commit 03fd268d814c491f1424f9fe8d8a0d30c5c333a5
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2017-10-31T17:29:19Z

    GROOVY-8369: Statically compiled property access on enum class throws NoSuchFieldError

----
;;;","01/Nov/17 03:31;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/625
;;;","01/Nov/17 07:14;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/625#discussion_r148194617
  
    --- Diff: src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy ---
    @@ -696,4 +696,21 @@ import org.codehaus.groovy.transform.sc.ListOfExpressionsExpression
                 assert astTrees['A$_closure1'][1].contains('INVOKESTATIC A.pfaccess$02 (LA;Ljava/lang/String;)Ljava/lang/String;')
             }
         }
    +
    +    //GROOVY-8369
    +    void testPropertyAccessOnEnumClass() {
    +        try {
    +            assertScript '''
    +                enum Foo {}
    +
    +                def test() {
    +                    println Foo.getModifiers() // => 16401 // ENUM | FINAL | PUBLIC (see GROOVY_8360 wrt STATIC)
    +                    println Foo.modifiers      // java.lang.NoSuchFieldError: modifiers
    +                }    
    +                test()
    +            '''
    +        } finally {
    +            //println astTrees
    +        }
    +    }
    --- End diff --
    
    Perhaps a slight improvement to my original test would be comparing property access to the getter result and also confirming that enum constants take preference over property access (which worked before but I couldn't see covered in existing tests).
    ```
    @Deprecated
    enum Foo {
      annotations
    }
    
    @groovy.transform.CompileStatic
    def test() {
      assert 'annotations' == Foo.annotations.toString()
      assert Foo.getAnnotations().size() == 1
      assert Foo.getModifiers() == Foo.modifiers
    }
    
    test()
    ```
;;;","01/Nov/17 07:19;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/625#discussion_r148195160
  
    --- Diff: src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy ---
    @@ -696,4 +696,21 @@ import org.codehaus.groovy.transform.sc.ListOfExpressionsExpression
                 assert astTrees['A$_closure1'][1].contains('INVOKESTATIC A.pfaccess$02 (LA;Ljava/lang/String;)Ljava/lang/String;')
             }
         }
    +
    +    //GROOVY-8369
    +    void testPropertyAccessOnEnumClass() {
    +        try {
    +            assertScript '''
    +                enum Foo {}
    +
    +                def test() {
    +                    println Foo.getModifiers() // => 16401 // ENUM | FINAL | PUBLIC (see GROOVY_8360 wrt STATIC)
    +                    println Foo.modifiers      // java.lang.NoSuchFieldError: modifiers
    +                }    
    +                test()
    +            '''
    +        } finally {
    +            //println astTrees
    +        }
    +    }
    --- End diff --
    
    Actually, I'll merge now and tweak the test as per above.
;;;","01/Nov/17 07:38;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/625#discussion_r148197190
  
    --- Diff: src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy ---
    @@ -696,4 +696,21 @@ import org.codehaus.groovy.transform.sc.ListOfExpressionsExpression
                 assert astTrees['A$_closure1'][1].contains('INVOKESTATIC A.pfaccess$02 (LA;Ljava/lang/String;)Ljava/lang/String;')
             }
         }
    +
    +    //GROOVY-8369
    +    void testPropertyAccessOnEnumClass() {
    +        try {
    +            assertScript '''
    +                enum Foo {}
    +
    +                def test() {
    +                    println Foo.getModifiers() // => 16401 // ENUM | FINAL | PUBLIC (see GROOVY_8360 wrt STATIC)
    +                    println Foo.modifiers      // java.lang.NoSuchFieldError: modifiers
    +                }    
    +                test()
    +            '''
    +        } finally {
    +            //println astTrees
    +        }
    +    }
    --- End diff --
    
    Oops, I just noticed you beat me to it. I'll just make the tweak.
;;;","01/Nov/17 09:20;paulk;Thanks [~shils];;;","01/Nov/17 16:15;shils;Thanks for reviewing and handling the rest of the backports [~paulk];;;",,,,,,,,,,,,,,,
date arithmetic bug using TimeCategory intervals,GROOVY-8368,13113141,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,blackdrag,bkoehm,bkoehm,30/Oct/17 20:35,31/Oct/17 00:24,14/Jul/23 06:02,31/Oct/17 00:24,2.6.0-alpha-1,,,,,,,,,,,,,,,,0,,,,,,,"There's what I think to be a date arithmetic bug using TimeCategory intervals and it appears to show itself only the 30th of any given month.  I noticed this because our automatic builds fail towards the end of the month due to failing tests and this has been going on for a long time.  I decided to hunt this down today (Oct 30) as the build failed today and I had time to track it down.  I was able to produce a small script to reproduce it, as shown below.  I tested with latest 2.6.0 alpha1 as well as 2.4.10 (what we're actually using).  Both show the bug.

I don't have an opinion on how ""1.month"" is interpreted in Groovy.  That's not what this submission is about.  The bug I am reporting here is that the following two expressions should always evaluate to the same value and it appears they don't on the 30th of the month:
{code}
Date now = new Date().clearTime()
// fails on the 30th of the month (at least, for Oct 30 2017)
assert now + 1.month + 1.day == now + 1.day + 1.month
{code}

{code}
// START of intervalBug.groovy
import groovy.time.TimeCategory

Date now = new Date().clearTime()
println ""current date = $now""
use(TimeCategory) {
  println ""now+1day+1month = ${now + 1.day + 1.month}""
  println ""now+1month+1day = ${now + 1.month + 1.day}""
}
// END of intervalBug.groovy
{code}

{noformat}
# also tested with groovy-2.4.10 with same buggy result
$ groovy -v
Groovy Version: 2.6.0-alpha-1 JVM: 1.8.0_131 Vendor: Oracle Corporation OS: Linux

# 29th of month is OK: same result produced
$ sudo date -s ""29 OCT 2017 13:00:00""; groovy intervalBug.groovy
Sun Oct 29 13:00:00 PDT 2017
current date = Sun Oct 29 00:00:00 PDT 2017
now+1day+1month = Thu Nov 30 00:00:00 PST 2017
now+1month+1day = Thu Nov 30 00:00:00 PST 2017

# 30th of month is BUGGY: different result produced
$ sudo date -s ""30 OCT 2017 13:00:00""; groovy intervalBug.groovy
Mon Oct 30 13:00:00 PDT 2017
current date = Mon Oct 30 00:00:00 PDT 2017
now+1day+1month = Thu Nov 30 00:00:00 PST 2017
now+1month+1day = Fri Dec 01 00:00:00 PST 2017

# 31st of month is OK
$ sudo date -s ""31 OCT 2017 13:00:00""; groovy intervalBug.groovy
[sudo] password for bkoehmstedt: 
Tue Oct 31 13:00:00 PDT 2017
current date = Tue Oct 31 00:00:00 PDT 2017
now+1day+1month = Fri Dec 01 00:00:00 PST 2017
now+1month+1day = Fri Dec 01 00:00:00 PST 2017

# 1st of month is OK
$ sudo date -s ""01 NOV 2017 13:00:00""; groovy intervalBug.groovy
[sudo] password for bkoehmstedt: 
Wed Nov  1 13:00:00 PDT 2017
current date = Wed Nov 01 00:00:00 PDT 2017
now+1day+1month = Sat Dec 02 00:00:00 PST 2017
now+1month+1day = Sat Dec 02 00:00:00 PST 2017
{noformat}
","Ubuntu 16.04, Groovy 2.6.0-alpha-1, OpenJDK 1.8.0_131
",bkoehm,blackdrag,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"30/Oct/17 20:35;bkoehm;intervalBug.groovy;https://issues.apache.org/jira/secure/attachment/12894840/intervalBug.groovy",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 31 00:23:56 UTC 2017,,,,,,,,,,"0|i3lvx3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Oct/17 20:48;bkoehm;I should add I just showed this issue to a colleague and he is already trying to explain to me why he doesn't think this is an actual bug, but I'm not quite following the explanation.  From my very-programmer-centric mindset, ""assert a + b + c == a + c + b"" should always succeed no matter what data type b and c are.  But at any rate, if someone else other than my colleague can explain why ""this isn't a bug"" for my ""programmer-centric"" mindset, I'll be happy to close it as not-a-bug.
;;;","31/Oct/17 00:23;blackdrag;I suggest you read on https://en.wikipedia.org/wiki/Commutative_property

Yes, we use the operator + here, but this plus is not the plus operator as it is defined for real numbers. I higher algebra you always have to define the operator and + is just a symbol. And for a DSL as here we can redefine plus of course to fit the domain. The plus operator here is then defined for dates, following the semantics of a date, which is basically rooted in the way use dates in our language. If you project a date to a real number like a long and any duration as well you would end up with a commutative operation, but you also imply that 1.month means a fixed number of days, and that is not true for for example Oct 1 plus one month and Nov 1 plus one months. One time you add 31, one time 30 days. This means our use in this mini DSL is more near the way we use dates in the common language, but we loose the easy projection on a real number. In other words: it is not comparable and the operation may have very different properties

I personally like matrix multiplication as an example. Here we have A*B != B*A in the general case. There are A and B for which we can have an equal here, but in general we can not say this. For real numbers a*b is always b*a. We just lost commutativity here.

Let´s do something crazy that mathematicians like to do... define our own binary operator *, where x*y=x+y+y. then 1*2 is suddenly 5, but 2*1 is 4. And we lost commutativity. Or let's define an binary operator +, where x+y=x/y. Then 1+2 is 0.5 and 2+1 is 2. Here we lost commutativity again.;;;",,,,,,,,,,,,,,,,,,,,
@Memoized not working for inner classes,GROOVY-8367,13112984,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,30/Oct/17 09:44,06/Mar/18 23:25,14/Jul/23 06:02,01/Nov/17 09:38,2.5.0-beta-2,,,,,,,,2.5.0-beta-3,,,,xforms,,,,0,,,,,,,"{code}
import groovy.transform.Memoized

class Outer {
  private static class Inner {
    @Memoized
    static calc(int arg1, int arg2) { arg1 + arg2}
  }
}

println Outer.Inner.calc(3, 4)
{code}
Works with 2.4.12 but for 2.5+, results in:
{noformat}
groovy.lang.GroovyRuntimeException: NPE while processing ConsoleScript12
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:286)
...
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.classgen.asm.ClosureWriter.getClosureSharedVariables(ClosureWriter.java:360)
	at org.codehaus.groovy.classgen.asm.ClosureWriter.createClosureClass(ClosureWriter.java:194)
	at org.codehaus.groovy.classgen.asm.ClosureWriter.getOrAddClosureClass(ClosureWriter.java:156)
...
{noformat}
",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 01 09:38:36 UTC 2017,,,,,,,,,,"0|i3luyf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Oct/17 11:44;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/624

    GROOVY-8367: @Memoized not working for inner classes

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8367

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/624.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #624
    
----
commit a4af4465cbeafc16411a240c8c4dd2720699a78f
Author: paulk <paulk@asert.com.au>
Date:   2017-10-30T11:42:53Z

    GROOVY-8367: @Memoized not working for inner classes

----
;;;","01/Nov/17 09:28;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/624
;;;","01/Nov/17 09:38;paulk;Proposed PR applied. 2_4_X was unaffected.;;;",,,,,,,,,,,,,,,,,,,
Nested class of parent Java class is not resolved,GROOVY-8364,13111463,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,daniilo,daniilo,23/Oct/17 15:59,11/Nov/20 02:00,14/Jul/23 06:02,13/Jul/20 18:45,,,,,,,,,,,,,,,,,0,,,,,,,"{code:title=bugs/A.java}
package bugs;

public class A {
    public interface Inner {}
}
{code}

{code:title=bugs/B.java}
package bugs;

public class B {
    public interface Inner {}
}
{code}

{code:title=bugs/test/test.groovy}
package bugs.test

import bugs.A
//import static bugs.B.Inner

class Current extends A {
  static usage() {
    return Inner // here
  }
}

println Current.usage()
{code}

{noformat}
Apparent variable 'Inner' was found in a static scope but doesn't refer to a local variable, static field or class. Possible causes:
You attempted to reference a variable in the binding or an instance variable from a static context.
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method 'Inner' but left out brackets in a place not allowed by the grammar.
 @ line 8, column 12.
       return Inner
              ^
{noformat}

Note the class could be resolved only via import.

Now try to uncomment a static import.
While usually the nested class takes precedence over an import, in this case the failure to resolve a nested class results in a silent resolution to {{bugs.B.Inner}}, i.e. no error is reported.

In both cases the reference is expected to be resolved to {{bugs.A.Inner}}",,daniilo,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8359,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 13 18:45:18 UTC 2020,,,,,,,,,,"0|i3llm7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jul/20 18:45;emilles;Fixed as part of or before Groovy 2.4;;;",,,,,,,,,,,,,,,,,,,,,
Nested class is resolved via another nested class with package name,GROOVY-8362,13111023,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,blackdrag,daniilo,daniilo,20/Oct/17 15:50,06/Mar/18 23:14,14/Jul/23 06:02,04/Jan/18 04:04,,,,,,,,,2.4.14,,,,,,,,0,,,,,,,"{code:title=bugs/bugs.groovy}
package bugs

class Current {

  static class bugs {
    static class Target {}
  }

  static usage() {
    new Target() // error expected
  }
}

println Current.usage() // bugs.Current$bugs$Target@20d28811
{code}",,blackdrag,daniilo,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 04 04:11:47 UTC 2018,,,,,,,,,,"0|i3liwn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Oct/17 20:35;daniilo;I can provide pull requests for issues opened by me if somebody could explain if this is really a bug or an undocumented feature.;;;","24/Oct/17 06:09;blackdrag;I can tell you that this is not an undocumented feature. I can tell you also that I think this issue exposes a structural problem to the class resolving mechanism we are using. So feel free to create a fix for it. I am curious on how you are going to solve the problem ;);;;","22/Dec/17 16:08;githubbot;GitHub user dovchinnikov opened a pull request:

    https://github.com/apache/groovy/pull/647

    GROOVY-8362: don't resolve class via class with package name

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/dovchinnikov/groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/647.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #647
    
----
commit 42d4c22ae55f4369c1d83dee5eedc4b0631540bb
Author: Daniil Ovchinnikov <daniil.ovchinnikov@...>
Date:   2017-12-22T16:01:10Z

    GROOVY-8362: don't resolve class via class with package name

----
;;;","04/Jan/18 02:18;paulk;[~blackdrag] This looks okay to me. What do you think?;;;","04/Jan/18 02:24;blackdrag;looks good to me;;;","04/Jan/18 04:05;paulk;Proposed PR merged, thanks!;;;","04/Jan/18 04:11;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/647
;;;",,,,,,,,,,,,,,,
Nested class is resolved via aliased static import,GROOVY-8361,13111013,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,daniilo,daniilo,20/Oct/17 15:19,11/Nov/20 02:01,14/Jul/23 06:02,27/Nov/19 15:24,,,,,,,,,2.5.0,,,,,,,,0,,,,,,,"{code:title=unrelatedPackage/Container.groovy}
package unrelatedPackage
class Container {
  static class Target {}
}
{code}

{code:title=bugs/bugs.groovy}
package bugs
import static unrelatedPackage.Container.Target as Unrelated
println new Target() // reference is expected to be unresolved
{code}",,daniilo,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 27 15:24:58 UTC 2019,,,,,,,,,,"0|i3liuf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Nov/19 15:24;emilles;Not sure when this got fixed, but it works in current 2.5 and 3.0 branches.;;;",,,,,,,,,,,,,,,,,,,,,
Enums that are nested classes do not have the static modifier set,GROOVY-8360,13110841,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,20/Oct/17 00:11,06/Mar/18 23:25,14/Jul/23 06:02,13/Nov/17 03:47,2.4.12,2.5.0-beta-2,2.6.0-alpha-1,3.x,,,,,2.5.0-beta-3,,,,Compiler,,,,0,,,,,,,"In java, enums that are nested classes have the static modifier set i.e. if Bar is an enum defined within a class Foo, {{assert Modifier.isStatic(Foo.Bar.modifiers)}} passes. The assertion does not hold if Foo and Bar are defined in groovy:

{code}
class Foo {
    enum Bar {
        X
    }
}
            
assert java.lang.reflect.Modifier.isStatic(Foo.Bar.modifiers)
{code}

This can be problematic in cases like https://mongodb.github.io/morphia/, where the type of a mapped field cannot be a non-static inner class. Of course that library could also be more enum-aware when validating mapped fields, but that's a separate issue. 

A simple workaround for this issue is to explicitly declare the enum as static, so it's not critical that a patch for this be in 2.4.X if it's considered a breaking change (though no tests fail with the change.)",,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Nov 04 17:13:02 UTC 2017,,,,,,,,,,"0|i3lhs7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Oct/17 00:20;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/619

    GROOVY-8360: Enums that are inner classes should have the static clas…

    …s modifier

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-8360

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/619.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #619
    
----
commit 8a0d193ba392d5a5e3ec417d1e708d4cee856627
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2017-10-19T22:37:23Z

    GROOVY-8360: Enums that are inner classes should have the static class modifier

----
;;;","24/Oct/17 01:18;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/619#discussion_r146433436
  
    --- Diff: src/test/gls/enums/EnumTest.groovy ---
    @@ -592,6 +592,80 @@ class EnumTest extends CompilableTestSupport {
                 assert UsState.ID.toString() == 'Idaho'
             '''
         }
    +
    +    void testNestedEnumHasStaticModifier_GROOVY_8360() {
    +        assertScript '''
    +            class Foo {
    +                enum Bar {
    +                    X('x'), Y
    +                    String s
    +                    Bar(String s) { this.s = s }
    +                    Bar() {}
    +                }
    +            }            
    +            assert java.lang.reflect.Modifier.isStatic(Foo.Bar.modifiers)
    +            assert Foo.Bar.X.s == 'x'
    +        '''
    +    }
    +
    +    void testEnumWithinInnerClassHasStaticModifier_GROOVY_8360() {
    +        assertScript '''
    +            class Foo {
    +                class Baz {
    +                    enum Bar {
    +                        X('x'), Y                                                                        
    +                        String s                                                                                                
    +                        Bar(String s) { this.s = s }
    +                        Bar() {}                                                
    +                    }                
    +                }
    +            }            
    +            assert java.lang.reflect.Modifier.isStatic(Foo.Baz.Bar.modifiers)
    +            assert Foo.Baz.Bar.X.s == 'x'
    +        '''
    +    }
    +
    +    void testNestedEnumHasStaticModifierSC_GROOVY_8360() {
    +        assertScript '''
    +            @groovy.transform.CompileStatic
    +            class Foo {
    +                enum Bar {
    +                    X('x'), Y
    +                    String s
    +                    Bar(String s) { this.s = s }
    +                    Bar() {}
    +                }
    +            }          
    +            @groovy.transform.CompileStatic
    +            void test() {
    +                assert java.lang.reflect.Modifier.isStatic(Foo.Bar.getModifiers())
    --- End diff --
    
    Unrelated to this issue - property style getter calls on Enum classes throw NoSuchFieldErrors at runtime when statically compiled.
;;;","31/Oct/17 12:46;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/619#discussion_r147980977
  
    --- Diff: src/test/gls/enums/EnumTest.groovy ---
    @@ -592,6 +592,80 @@ class EnumTest extends CompilableTestSupport {
                 assert UsState.ID.toString() == 'Idaho'
             '''
         }
    +
    +    void testNestedEnumHasStaticModifier_GROOVY_8360() {
    +        assertScript '''
    +            class Foo {
    +                enum Bar {
    +                    X('x'), Y
    +                    String s
    +                    Bar(String s) { this.s = s }
    +                    Bar() {}
    +                }
    +            }            
    +            assert java.lang.reflect.Modifier.isStatic(Foo.Bar.modifiers)
    +            assert Foo.Bar.X.s == 'x'
    +        '''
    +    }
    +
    +    void testEnumWithinInnerClassHasStaticModifier_GROOVY_8360() {
    +        assertScript '''
    +            class Foo {
    +                class Baz {
    +                    enum Bar {
    +                        X('x'), Y                                                                        
    +                        String s                                                                                                
    +                        Bar(String s) { this.s = s }
    +                        Bar() {}                                                
    +                    }                
    +                }
    +            }            
    +            assert java.lang.reflect.Modifier.isStatic(Foo.Baz.Bar.modifiers)
    +            assert Foo.Baz.Bar.X.s == 'x'
    +        '''
    +    }
    +
    +    void testNestedEnumHasStaticModifierSC_GROOVY_8360() {
    +        assertScript '''
    +            @groovy.transform.CompileStatic
    +            class Foo {
    +                enum Bar {
    +                    X('x'), Y
    +                    String s
    +                    Bar(String s) { this.s = s }
    +                    Bar() {}
    +                }
    +            }          
    +            @groovy.transform.CompileStatic
    +            void test() {
    +                assert java.lang.reflect.Modifier.isStatic(Foo.Bar.getModifiers())
    --- End diff --
    
    I created GROOVY-8369 for this. I can't at first glance see a reason why we'd not support this with @CS.
;;;","04/Nov/17 17:13;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/619
;;;",,,,,,,,,,,,,,,,,,
Nested class is not resolved if compiled separately,GROOVY-8359,13110792,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,daniilo,daniilo,19/Oct/17 20:40,11/Nov/20 02:00,14/Jul/23 06:02,13/Jul/20 18:46,,,,,,,,,,,,,,,,,0,,,,,,,"{code:title=classes.groovy}
package bugs

class CurrentParent {
  static class Target {}
}
{code}

{code:title=bug.groovy}
package bugs

class Current extends CurrentParent {
  static usage() {
    new Target()
  }
}
{code}

This works if files are compiled together, but fails if files are compiled one by one with {{Error:(5, 5) Groovyc: unable to resolve class Target}}",,daniilo,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8358,,GROOVY-8364,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 13 18:46:10 UTC 2020,,,,,,,,,,"0|i3lhhb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jul/20 18:46;emilles;Works in Groovy 3 -- test case added;;;",,,,,,,,,,,,,,,,,,,,,
Nested class resolution behaves differently depending on class order,GROOVY-8358,13110757,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,,daniilo,daniilo,19/Oct/17 18:50,11/Nov/20 02:00,14/Jul/23 06:02,13/Jul/20 18:48,,,,,,,,,,,,,,,,,0,,,,,,,"{code}
package bugs

class Outer implements OuterI {

  static class Current extends CurrentParent  {
    static usage() {
      new Target()
    }
  }
}

class CurrentParent implements CurrentParentI {}

interface CurrentParentI {
  static class Target {}
}

interface OuterI {
  static class Target {}
}

println Outer.Current.usage() // bugs.OuterI$Target@3eb7fc54
{code}

If {{CurrentParent}} definition is moved before {{Outer}}, then {{new Target}} will be resolved to {{bugs.CurrentParentI$Target}}:
{code}
package bugs

class CurrentParent implements CurrentParentI {}

class Outer implements OuterI {

  class Current extends CurrentParent  {
    static usage() {
      new Target()
    }
  }
}

interface CurrentParentI {
  static class Target {}
}

interface OuterI {
  static class Target {}
}

println Outer.Current.usage() // bugs.CurrentParentI$Target@3eb7fc54
{code}

Moving classes must not affect results of compilation.",,daniilo,emilles,paulk,richardHu,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8359,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 13 18:48:06 UTC 2020,,,,,,,,,,"0|i3lh9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jun/20 16:02;richardHu;this issue is not clearly described;;;","07/Jun/20 09:37;daniilo;[~richardHu] Tell me what is unclear, please. ;;;","13/Jul/20 18:48;emilles;Works in Groovy 3 -- test cases added.  Both cases are looking to outer types of super class before outer types of outer class(es).;;;",,,,,,,,,,,,,,,,,,,
"EncodingGroovyMethods.decodeBase64() throws ""bad character in base64 value"" when meets \t \r",GROOVY-8357,13110250,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,xingplus,xingplus,18/Oct/17 09:51,06/Mar/18 23:12,14/Jul/23 06:02,01/Nov/17 09:23,2.4.12,,,,,,,,2.4.13,,,,groovy-runtime,,,,0,,,,,,,"EncodingGroovyMethods.decodeBase64() throws ""bad character in base64 value"" RuntimeException when the method meets \t \r character.
I found in org.codehaus.groovy.runtime.EncodingGroovyMethodsSupport.TRANSLATE_TABLE has a mistake:
    static final byte[] TRANSLATE_TABLE = (
            ""\u0042\u0042\u0042\u0042\u0042\u0042\u0042\u0042""
                    //                    {color:red}\t{color}    {color:yellow}\n{color}                {color:blue}\r{color}
                    + ""\u0042{color:red}\u0042{color}{color:yellow}\u0041{color}\u0041\u0042{color:blue}\u0042{color}\u0041\u0042""
...
I mark them in color.
I believe it's an offset mistake.",,githubbot,jwagenleitner,paulk,xingplus,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 01 09:23:01 UTC 2017,,,,,,,,,,"0|i3lej3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Oct/17 19:38;paulk;Do you have a failing test to illustrate the problem?;;;","29/Oct/17 15:30;xingplus;yes:
{color:#f79232}'\r'.decodeBase64(){color} will throw a RuntimeException(bad character in base64 value)
{color:#f79232}'\n'.decodeBase64(){color} won't;;;","30/Oct/17 02:33;paulk;Okay, gotcha. While the RFC spec gives some latitude in deciding which characters can be ignored vs deemed legal, it does indeed look like some kind of cut-n-paste glitch.;;;","30/Oct/17 02:38;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/623

    GROOVY-8357: EncodingGroovyMethods.decodeBase64() throws ""bad charact…

    …er in base64 value"" when meets \t \r

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8357

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/623.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #623
    
----
commit 37792e912934e0317a1b908ed205a753cdaedf19
Author: paulk <paulk@asert.com.au>
Date:   2017-10-30T02:37:05Z

    GROOVY-8357: EncodingGroovyMethods.decodeBase64() throws ""bad character in base64 value"" when meets \t \r

----
;;;","01/Nov/17 09:04;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/623
;;;","01/Nov/17 09:23;paulk;Should be fixed. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,
Use javax.validation 2.0 API results in GroovyBugError,GROOVY-8356,13110012,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,graemerocher1,graemerocher1,17/Oct/17 15:09,18/Oct/17 16:03,14/Jul/23 06:02,18/Oct/17 16:03,2.4.12,2.5.0-beta-2,,,,,,,2.5.0-beta-2,,,,,,,,0,,,,,,,"If you use the javax.validation 2.0 API using certain annotations results in:

{code}
BUG! exception in phase 'class generation' in source unit '.../validation/ValidatedSpec.groovy' unsupported Target TYPE_USE
{code}

Example code:

{code}
class Foo {
    String testMe(@Pattern(regexp = ""\\d+"") String number) {
        return number
    }
}
{code}

Seems https://github.com/apache/groovy/blob/GROOVY_2_5_X/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java#L327 needs updating for Java 8 `TYPE_USE`",,graemerocher1,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 18 16:03:46 UTC 2017,,,,,,,,,,"0|i3ld2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Oct/17 15:20;graemerocher1;I would say this issue is pretty serious, as it makes `javax.validation` 2.0 and above unusable in Groovy as every annotation in `javax.validation` has an inner annotation defined as:

{code}
	/**
	 * Defines several {@link Digits} annotations on the same element.
	 *
	 * @see Digits
	 */
	@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
	@Retention(RUNTIME)
	@Documented
	@interface List {

		Digits[] value();
	}
{code}

The `TYPE_USE` definition here is causing the error;;;","17/Oct/17 23:24;paulk;I haven't looked into the error yet but TYPE_USE is defined in this file:
https://github.com/apache/groovy/blob/GROOVY_2_5_X/src/main/org/codehaus/groovy/vmplugin/v8/Java8.java;;;","18/Oct/17 16:03;graemerocher1;Actually this is fixed in beta 2, sorry for the hassle;;;",,,,,,,,,,,,,,,,,,,
Extend AutoFinal to closures and inner class within a class,GROOVY-8347,13107839,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,08/Oct/17 11:03,06/Mar/18 23:25,14/Jul/23 06:02,12/Oct/17 00:13,,,,,,,,,2.5.0-beta-3,,,,,,,,0,,,,,,,"When a class is annotated with @AutoFinal, now closures and inner classes within the annotated class are processed. An {{enabled}} flag is available for disabling processing on say one inner class or one method. Individual closures can be annotated by defining them as a field or local variable.",,emge,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 11 14:34:36 UTC 2017,,,,,,,,,,"0|i3l07z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Oct/17 14:34;paulk;Added;;;",,,,,,,,,,,,,,,,,,,,,
Issue implementing Java interface,GROOVY-8343,13107528,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,Schlogen,Schlogen,06/Oct/17 15:04,06/Mar/18 23:25,14/Jul/23 06:02,19/Oct/17 22:12,2.5.0-beta-2,,,,,,,,2.5.0-beta-3,,,,Compiler,,,,0,,,,,,,"Groovy compiler fails with a message saying a method is not implemented in the Groovy class that exists in the Java interface.

The error can be seen here: https://travis-ci.org/grails/grails-core/builds/284244075

The file in question does in fact implement the method. https://github.com/grails/grails-core/blob/spring_5/grails-bootstrap/src/main/groovy/org/grails/io/support/ByteArrayResource.groovy#L64",,paulk,Schlogen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 19 22:12:26 UTC 2017,,,,,,,,,,"0|i3kyt3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Oct/17 13:19;paulk;Workaround is to fully qualify the return type, e.g.:
{code}
org.grails.io.support.Resource
{code}
You obviously shouldn't have to do that. I can think of several ways to fix this but I will have to try some things out first.;;;","19/Oct/17 22:12;paulk;Should be fixed;;;",,,,,,,,,,,,,,,,,,,,
Static compilation error with a method returning an array in a type parameter,GROOVY-8342,13107257,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mjjustin,mjjustin,05/Oct/17 15:09,13/Dec/18 10:05,14/Jul/23 06:02,11/Oct/18 02:17,,,,,,,,,2.5.3,3.0.0-alpha-4,,,Static compilation,,,,0,,,,,,,"A compilation error occurs when using static compilation and attempting to assign the result of a method that returns a parameterized argument that contains an array in the type parameter.  The equivalent Java code has no issues.

Here is a specific example:

{code}@CompileStatic
class ArrayGenericsIssue {
  static void main(String[] args) {
    Optional<Integer[]> value = testArrayMethod(1) //This fails to compile
  }

  static <E> Optional<E[]> testArrayMethod(E ignored) {
    return Optional.empty()
  }
}{code}

The error returned is:

{code}Error:(11, 33) Groovyc: [Static type checking] - Incompatible generic argument types. Cannot assign java.util.Optional <E[]> to: java.util.Optional <Integer[]>{code}

The expected behavior is that this code would compile and run successfully with @CompileStatic enabled.

Note that equivalent code with a non-array generic parameter works just fine:
{code}
  static void main(String[] args) {
    Optional<List<Integer>> value = testListMethod(1)
  }

  static <E> Optional<List<E>> testListMethod(E ignored) {
    return Optional.empty()
  }
{code}

Additionally, there is no compilation issue if the value is cast:

{code}Optional<Integer[]> value = (Optional<Integer[]>) testArrayMethod(1){code}

For some context, I'm running into this issue when working with [jOOQ|https://www.jooq.org/], as some of its API involves working with array type parameters. ",,emilles,mjjustin,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 11 02:17:08 UTC 2018,,,,,,,,,,"0|i3kx5j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Oct/18 16:53;emilles;{{StaticTypeCheckingVisitor}} seems to have a handle on the generics.  When visiting method {{testListMethod}}, it does manage to understand the link between {{E}} and {{Integer}}.
{code:java}
    protected ClassNode inferReturnTypeGenerics(
            ClassNode receiver,
            MethodNode method,
            Expression arguments,
            GenericsType[] explicitTypeHints) {
        ...
        // resolvedPlaceholders: {E=java.lang.Integer}
        // returnType: java.util.Optional <[LE;> -> java.util.Optional <T extends java.lang.Object>
        return applyGenericsContext(resolvedPlaceholders, returnType);
    }
{code};;;","10/Oct/18 17:10;emilles;Down from the above method, in {{StaticTypeCheckingSupport}}:
{code:java}
    private static GenericsType applyGenericsContext(Map<String, GenericsType> spec, GenericsType gt) {
        if (gt.isPlaceholder()) { // returns false for ""LE;"" -- gt.getType() returns ""E -> java.lang.Object[]""; placeholder is set on the component type
{code};;;","10/Oct/18 17:34;emilles;This may fix the issue (edit indicated in the 2nd half):
{code:java}
    private static GenericsType applyGenericsContext(Map<String, GenericsType> spec, GenericsType gt) {
        if (gt.isPlaceholder()) {
            String name = gt.getName();
            GenericsType specType = spec.get(name);
            if (specType!=null) return specType;
            if (hasNonTrivialBounds(gt)) {
                GenericsType newGT = new GenericsType(gt.getType(), applyGenericsContext(spec, gt.getUpperBounds()), applyGenericsContext(spec, gt.getLowerBound()));
                newGT.setPlaceholder(true);
                return newGT;
            }
            return gt;
        } else if (gt.isWildcard()) {
            GenericsType newGT = new GenericsType(gt.getType(), applyGenericsContext(spec, gt.getUpperBounds()), applyGenericsContext(spec, gt.getLowerBound()));
            newGT.setWildcard(true);
            return newGT;
        }
        ClassNode type = gt.getType();
        /* GRECLIPSE edit
        if (type.getGenericsTypes()==null) return gt;
        ClassNode newType = type.getPlainNodeReference();
        newType.setGenericsPlaceHolder(type.isGenericsPlaceHolder());
        newType.setGenericsTypes(applyGenericsContext(spec, type.getGenericsTypes()));
        */
        ClassNode newType;
        if (type.isArray()) {
            newType = applyGenericsContext(spec, type.getComponentType()).makeArray();
        } else {
            if (type.getGenericsTypes()==null) return gt;
            newType = type.getPlainNodeReference();
            newType.setGenericsPlaceHolder(type.isGenericsPlaceHolder());
            newType.setGenericsTypes(applyGenericsContext(spec, type.getGenericsTypes()));
        }
        GenericsType newGT = new GenericsType(newType);
        return newGT;
    }
{code};;;","11/Oct/18 01:31;paulk;Thanks [~emilles]. I haven't thought through whether there is a better way to refactor/fix this but your change certainly fixes this case, so I'll merge and we can think about improvements down the track.;;;","11/Oct/18 02:17;paulk;Incorporated Eric's suggested change.;;;",,,,,,,,,,,,,,,,,
GDK: eachDirRecurse and eachFileRecurse are NOT depth-first,GROOVY-8341,13107159,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,dheinric,dheinric,05/Oct/17 08:23,06/Mar/18 23:25,14/Jul/23 06:02,12/Oct/17 03:26,2.4.11,,,,,,,,2.4.13,,,,groovy-jdk,,,,0,,,,,,,"The documentation for those two methods states: ""Sub-directories are recursively searched in a depth-first fashion."" But the result is NOT depth-first, as the following example shows:

Given a directory tree of {code}/tmp
|-/foo
| |-/bar
|   |-/foo
|   |-/bar
|   |-/baz
|-/baz{code}
the following simple code {code}#!/usr/bin/groovy

File rootDir = new File(new URI('file:/tmp/foo'))
rootDir.eachDirRecurse {
  println(it)
}{code}
gives this result {code}/tmp/foo/bar
/tmp/foo/bar/baz
/tmp/foo/bar/foo
/tmp/foo/bar/bar
/tmp/foo/baz{code}
while {code}% find /tmp/foo -depth -type d{code}
correctly gives {code}/tmp/foo/bar/baz
/tmp/foo/bar/foo
/tmp/foo/bar/bar
/tmp/foo/bar
/tmp/foo/baz
/tmp/foo{code}",Windows Linux,dheinric,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 12 03:26:50 UTC 2017,,,,,,,,,,"0|i3kwjz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Oct/17 10:58;paulk;I think many people see linux find as always doing depth-first traversal (because it's definitely not breadth-first) of directories but -depth can be used to ensure children are processed before their parent (which is what we'd expect from a strict depth-first algorithm). Groovy {{eachDirRecurse}} is the same as linux find without the -depth option (give or take the difference with processing the root). You can get the strict behavior using {{traverse}} and it's {{postDir}} closure:
{code}
import static groovy.io.FileType.*
File rootDir = new File(new URI('file:/tmp/foo'))
rootDir.traverse(type: DIRECTORIES, postRoot: true, postDir: { println it }, {})
{code}
gives:
{noformat}
/tmp/foo/bar/baz
/tmp/foo/bar/foo
/tmp/foo/bar/bar
/tmp/foo/bar
/tmp/foo/baz
/tmp/foo
{noformat}
You could argue that a change in behavior is required but given the {{traverse}} functionality, I suspect we could perhaps just make the documentation clearer. What do you think?;;;","09/Oct/17 06:03;dheinric;I don't care which one is fixed, as long as both match afterwards...;;;","09/Oct/17 11:24;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/614

    GROOVY-8341: GDK: eachDirRecurse and eachFileRecurse are NOT depth-fi…

    …rst (clarify wording in javadoc)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8341

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/614.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #614
    
----
commit 9100c04a8f65b4579ef4aab312190a408be3270d
Author: paulk <paulk@asert.com.au>
Date:   2017-10-09T11:21:52Z

    GROOVY-8341: GDK: eachDirRecurse and eachFileRecurse are NOT depth-first (clarify wording in javadoc)

----
;;;","12/Oct/17 03:16;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/614
;;;","12/Oct/17 03:26;paulk;Documentation now clarified. Thanks for helping us improve Groovy. If you can think of anyway to improve the wording even further, let us know (or create a PR).;;;",,,,,,,,,,,,,,,,,
Calling Stream.of from groovy class in JDK 9 fails,GROOVY-8338,13106389,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,marnyl,marnyl,02/Oct/17 12:31,10/Apr/18 13:02,14/Jul/23 06:02,07/Mar/18 01:21,2.4.12,,,,,,,,2.5.0-rc-1,2.6.0-alpha-3,3.0.0-alpha-2,,groovy-runtime,,,,1,,,,,,,"Trying to call Stream.of from groovy class (groovy version 2.4.12) using JDK 9 (jdk 9 181) fails. 
Example:

{code}
package test

import java.util.stream.Stream

class B {
    static void main(String[] args) {
        Stream.of(""1"").forEach({ println(it) })
    }
}
{code}

The code above fails with:
Exception in thread ""main"" java.lang.IncompatibleClassChangeError: Method java.util.stream.Stream.of(Ljava/lang/Object;)Ljava/util/stream/Stream; must be InterfaceMethodref constant
	at java_util_stream_Stream$of.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at test.B.main(B.groovy:7)


The same occurs for other interface static methods also:
{code}
public interface D {
    static D of(String s) {
        return new D() {
        };
    }
}

class C {
    static void main(String[] args) {
        D.of(""1"")
    }
}
{code}

Also fails with:
Exception in thread ""main"" java.lang.IncompatibleClassChangeError: Method test.D.of(Ljava/lang/String;)Ltest/D; must be InterfaceMethodref constant
	at test.D$of.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at test.C.main(C.groovy:7)

Running with JDK 8 works fine.",,blackdrag,daniel_sun,jwagenleitner,marnyl,paulk,shohou,slnowak,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8494,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 07 01:21:12 UTC 2018,,,,,,,,,,"0|i3krun:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Dec/17 00:42;slnowak;[~blackdrag] is this issue solved on GROOVY_2_4_X branch of https://github.com/apache/groovy ? I'm trying to run spock tests on jdk9, but i'm also having issues with static methods on interfaces. 

I even tried building groovy-all from sources (GROOVY_2_4_X) and use it in my project, but then I get {code}method: call signature: (Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;) Illegal type in constant pool{code}

Same thing happens when I try to run InterfaceStaticMethodCallTest:
{code}java.lang.VerifyError: (class: java_util_stream_Stream$of, method: callStatic signature: (Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object;) Illegal type in constant pool

	at java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2671)
	at java.lang.Class.getConstructor0(Class.java:3075)
	at java.lang.Class.getConstructor(Class.java:1825)
	at org.codehaus.groovy.reflection.ClassLoaderForClassArtifacts.defineClassAndGetConstructor(ClassLoaderForClassArtifacts.java:82)
	at org.codehaus.groovy.runtime.callsite.CallSiteGenerator.compileStaticMethod(CallSiteGenerator.java:262)
	at org.codehaus.groovy.reflection.CachedMethod.createStaticMetaMethodSite(CachedMethod.java:295)
	at org.codehaus.groovy.runtime.callsite.StaticMetaMethodSite.createStaticMetaMethodSite(StaticMetaMethodSite.java:114)
	at groovy.lang.MetaClassImpl.createStaticSite(MetaClassImpl.java:3421)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:76)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:161)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:47)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:116)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:128)
	at TestScript0.run(TestScript0.groovy:4)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:574)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:612)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:593)
	at groovy.test.GroovyAssert.assertScript(GroovyAssert.java:83)
	at groovy.util.GroovyTestCase.assertScript(GroovyTestCase.java:203)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:210)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:51)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:157)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:169)
	at org.codehaus.groovy.vmplugin.v8.InterfaceStaticMethodCallTest.testStreamOf(InterfaceStaticMethodCallTest.groovy:28)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at junit.framework.TestCase.runTest(TestCase.java:176)
	at junit.framework.TestCase.runBare(TestCase.java:141)
	at junit.framework.TestResult$1.protect(TestResult.java:122)
	at junit.framework.TestResult.runProtected(TestResult.java:142)
	at junit.framework.TestResult.run(TestResult.java:125)
	at junit.framework.TestCase.run(TestCase.java:129)
	at junit.framework.TestSuite.runTest(TestSuite.java:252)
	at junit.framework.TestSuite.run(TestSuite.java:247)
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70){code}

Oh and btw I'm not quite sure why do you depend on 'asm-all:6.0'. It seems like it's not available in maven central (couldn't find anything newer than https://mvnrepository.com/artifact/org.ow2.asm/asm-all/6.0_BETA);;;","26/Dec/17 09:51;blackdrag;2.4.14 should have the fix. There is a second part to this fix where we upgrade to 2.4.x to ASM6 (not beta). As for depending on asm-all:6.0 actually we are currently investigating where we depend on that, because groovy-core does not depend on the no longer existing asm-all artifact.;;;","26/Dec/17 09:53;slnowak;So the latest commit from GROOVY_2_4_X should fix that? In my case, unfortunately it haven't. Maybe because I was compiling with asmVersion = 6.0-BETA?;;;","26/Dec/17 10:11;blackdrag;Even though I did backport the change to 2.4.x, it is very possible I will have to change the fix version and say it is 2.5+ only. On the CI server the same fix works well on master and 2.5.x, but the JDK8 snapshot build currently fails there.... because it requests asm-all-6.0, which does not exist. Right now I have no idea what would be different for Groovy 2.4 to not pass verification and still work with for example master or 2.5. Would it possible for you to test Groovy 2.5? I know there are problems with master and spock, because master is set to Groovy 3, but 2.5 should work, should it not?;;;","26/Dec/17 10:14;slnowak;I can try to build 2.5 from sources and test it but I'm not sure if spock is compatible with 2.5. 
When I'm trying to build groovy locally, it also can't find asm-all-6.0, i had to downgrade the dependency.;;;","26/Dec/17 10:54;slnowak;[~blackdrag] Well, I had some compilation issues on 2.5, but after fixing that:
{code}Caused by: java.lang.IncompatibleClassChangeError: Method io.vavr.control.Validation.valid(Ljava/lang/Object;)Lio/vavr/control/Validation; must be InterfaceMethodref constant{code}

Of course, Validation.valid is a static factory method on an interface. So it looks like the issue is still there. 

Let me know if I'm doing anything wrong:
1) i'm trying to compile groovy locally
{code}MacBook-Pro-Slawomir:groovy snowak$ git log -1
commit ad4b5d15e2191349f7ddc588cc208a4014a240d4 (HEAD -> GROOVY_2_5_X, upstream/GROOVY_2_5_X)
Author: sunlan <sunlan@apache.org>
Date:   Tue Dec 26 12:54:01 2017 +0800

    Simplify the arguments of `coerceToSAM` method

    (cherry picked from commit 6e5f47f)

MacBook-Pro-Slawomir:groovy snowak$ ./gradlew clean dist -x test  --parallel{code}
2) then I specify compiled jar as a maven depencency:
{code}        <dependency>
            <groupId>org.codehaus.groovy</groupId>
            <artifactId>groovy</artifactId>
            <version>2.5.0-SNAPSHOT</version>
            <scope>system</scope>
            <systemPath>/Users/snowak/work/projects/groovy/target/libs/groovy-2.5.0-SNAPSHOT.jar</systemPath>
        </dependency>
{code}

This should work, right?;;;","12/Jan/18 04:29;daniel_sun;The following code still fails when running on Java9
{code}
$ java -Xmx32m -version
java version ""9.0.1""
Java(TM) SE Runtime Environment (build 9.0.1+11)
Java HotSpot(TM) 64-Bit Server VM (build 9.0.1+11, mixed mode)
$ javac -J-Xmx32m -version
javac 9.0.1
{code}

{code:java}
assert [2, 3, 4] == Stream.of(1, 2, 3).map(e -> e + 1).collect(Collectors.toList());
{code}

https://travis-ci.org/apache/groovy/jobs/327967597
{code}
groovy.transform.stc.LambdaTest > testMethodCall FAILED
    java.lang.IncompatibleClassChangeError: Method java.util.stream.Stream.of([Ljava/lang/Object;)Ljava/util/stream/Stream; must be InterfaceMethodref constant
        at Test1.p1(TestScript0.groovy:15)
        at Test1.main(TestScript0.groovy:9)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:564)
        at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:103)
        at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1299)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1047)
        at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:835)
        at Test1.invokeMethod(TestScript0.groovy)
        at org.codehaus.groovy.runtime.InvokerHelper$1.run(InvokerHelper.java:456)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:445)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:483)
        at groovy.lang.GroovyShell.evaluate(GroovyShell.java:464)
        at groovy.test.GroovyAssert.assertScript(GroovyAssert.java:83)
        at groovy.util.GroovyTestCase.assertScript(GroovyTestCase.java:203)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:564)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSiteNoUnwrapNoCoerce.invoke(PogoMetaMethodSite.java:210)
        at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.callCurrent(PogoMetaMethodSite.java:59)
        at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:51)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:157)
        at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:169)
        at groovy.transform.stc.LambdaTest.testMethodCall(LambdaTest.groovy:24)
{code}
;;;","12/Jan/18 07:13;paulk;Should we reopen this?;;;","12/Jan/18 21:17;blackdrag;then most likely somebody else has to solve the problem;;;","13/Jan/18 00:03;paulk;Well, I don't care whether it is closed or remains open so long as we know what parts have been fixed so far and what cases are still left to do. I wasn't following as closely as I possibly should have early on and I have kind of lost track. [~blackdrag] what's your understanding of the current status? Some cases fail for master in JDK9 and some issues on 2_4_X?;;;","13/Jan/18 13:02;blackdrag;What I fixed is the  proxy generator callsite caching is using to make the call. So as long as the call is done through the proxy it should work. Or so I thought. the message tells me that the proxy class is loaded but incorrect. It tells me that me fix is not applied for it actually and that this still generates the old proxy version we still require because those people cannot keep java9 and java8 working properly together at times. I think it depends on the VM if it works or not.;;;","14/Jan/18 12:25;slnowak;I've just built groovy-all jar from latest commit on 2.4.X branch, included it in my test project and the following test
{code}class StaticMethodCall extends Specification {

    def 'static method call test'() {
        expect:
        Stream.of(1, 2, 3).map({ it + 1 }).collect(Collectors.toList()) == [2, 3, 4]
    }

}{code}
passed on jdk 9.0.1

However, there's still something broken. I've added a static Vertx.vertx() call 
{code}
class StaticMethodCall extends Specification {
    def 'static method call test'() {
        expect:
        def vertx = Vertx.vertx()
        true
    }
}{code}

and it fails with:
{code}
java.lang.VerifyError: (class: io/vertx/core/Vertx$vertx, method: callStatic signature: (Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object;) Illegal type in constant pool

	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3110)
	at java.base/java.lang.Class.getConstructor0(Class.java:3315)
	at java.base/java.lang.Class.getConstructor(Class.java:2108)
	at com.example.app.StaticMethodCall.static method call test(StaticMethodCall.groovy:9)
{code}

it's not caused by vertx itself as it works on jdk9, it only fails in groovy.

// edit:
I'm trying to recreate the issue without using vertx, will get back to you;;;","14/Jan/18 13:06;paulk;Thanks! Your results with and without @CompileStatic would also potentially be useful information.;;;","14/Jan/18 13:18;slnowak;[~paulk]
Ok, so this is what I've found so far:
If you define an interface:
{code}
public interface InterfaceWithStaticMethod {

    static boolean someStaticMethod() {
        return true;
    }
}{code}

then this works:
{code}class StaticMethodCall extends Specification {
    def 'static method call test'() {
        expect:
        InterfaceWithStaticMethod.someStaticMethod()
    }
}{code}

however this fails:
{code}class StaticMethodCall extends Specification {
    def 'static method call test'() {
        expect:
        def result = InterfaceWithStaticMethod.someStaticMethod()
        result
    }
}{code}
with {code}java.lang.VerifyError: (class: example/app/InterfaceWithStaticMethod$someStaticMethod, method: callStatic signature: (Ljava/lang/Class;[Ljava/lang/Object;)Ljava/lang/Object;) Illegal type in constant pool

	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3110)
	at java.base/java.lang.Class.getConstructor0(Class.java:3315)
	at java.base/java.lang.Class.getConstructor(Class.java:2108)
	at com.example.app.StaticMethodCall.static method call test(StaticMethodCall.groovy:9){code}

Running it with @CompileStatic yields:
{code}[INFO] Running com.example.app.StaticMethodCall
[ERROR] Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 3.161 s <<< FAILURE! - in com.example.app.StaticMethodCall
[ERROR] static method call test(com.example.app.StaticMethodCall)  Time elapsed: 0.068 s  <<< ERROR!
java.lang.IncompatibleClassChangeError: Method example.app.InterfaceWithStaticMethod.someStaticMethod()Z must be InterfaceMethodref constant
        at com.example.app.StaticMethodCall.static method call test(StaticMethodCall.groovy:11)

[INFO] 
[INFO] Results:
[INFO] 
[ERROR] Errors: 
[ERROR]   StaticMethodCall.static method call test:11 IncompatibleClassChange Method exa...
{code}

;;;","15/Jan/18 15:04;daniel_sun;I found javac creates `Integer` array for `Stream.of(1, 2, 3)`, but groovy creates `Object` array. Maybe it is the cause why `Stream.of` fails in Java9, which is more strict to verify.;;;","15/Jan/18 15:49;slnowak;[~daniel_sun] See my comment above - this issue is not related to 'Stream.of' itself.;;;","27/Jan/18 20:28;slnowak;Do you have any idea when this could be fixed?;;;","14/Feb/18 15:06;slnowak;[~paulk] this kind of blocks the usage of groovy (for example for testing) in any jdk9 based project. Are there any plans to fix this issue?;;;","07/Mar/18 01:21;paulk;I believe the fix worked for 2.5+ but doesn't work (or at least isn't sufficient) for 2_4_X. I've cloned the issue to cater for that case.;;;",,,
STC: instanceof in ternary expression not propagating type info to true expression,GROOVY-8337,13106320,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,emilles,emilles,02/Oct/17 01:00,13/Dec/18 10:05,14/Jul/23 06:02,26/Aug/18 02:08,,,,,,,,,2.5.3,3.0.0-alpha-4,,,Static Type Checker,,,,0,,,,,,,"{code}
@CompileStatic
class Static {
  private Number n
  BigDecimal meth() {
    return n == null || n instanceof BigDecimal ? n : new BigDecimal(n.toString())
  }
}
{code}

StaticTypeCheckingVisitor is missing the temporary type of the true expression part of the ternary expression because it pops before accessing the type.  One possible solution:

{code}
    @Override
    public void visitTernaryExpression(final TernaryExpression expression) {
        Map<VariableExpression, List<ClassNode>> oldTracker = pushAssignmentTracking();
        // create a new temporary element in the if-then-else type info
        typeCheckingContext.pushTemporaryTypeInfo();
        expression.getBooleanExpression().visit(this);
        Expression trueExpression = expression.getTrueExpression();
        Expression falseExpression = expression.getFalseExpression();
        trueExpression.visit(this);
        // GRECLIPSE add
        final ClassNode typeOfTrue = findCurrentInstanceOfClass(trueExpression, getType(trueExpression));
        // GRECLIPSE end
        // pop if-then-else temporary type info
        typeCheckingContext.popTemporaryTypeInfo();
        falseExpression.visit(this);
        ClassNode resultType;
        if (isNullConstant(trueExpression) || isNullConstant(falseExpression)) {
            BinaryExpression enclosingBinaryExpression = typeCheckingContext.getEnclosingBinaryExpression();
            if (enclosingBinaryExpression != null && enclosingBinaryExpression.getRightExpression()==expression) {
                resultType = getType(enclosingBinaryExpression.getLeftExpression());
            } else if (isNullConstant(trueExpression) && isNullConstant(falseExpression)) {
                resultType = OBJECT_TYPE;
            } else if (isNullConstant(trueExpression)) {
                resultType = wrapTypeIfNecessary(getType(falseExpression));
            } else {
                resultType = wrapTypeIfNecessary(getType(trueExpression));
            }
        } else {
            // store type information
            // GRECLIPSE edit
            //final ClassNode typeOfTrue = getType(trueExpression);
            // GRECLIPSE end
            final ClassNode typeOfFalse = getType(falseExpression);
            resultType = lowestUpperBound(typeOfTrue, typeOfFalse);
        }
        storeType(expression, resultType);
        popAssignmentTracking(oldTracker);
    }
{code}",,daniel_sun,emilles,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/Oct/17 16:56;emilles;screenshot-1.png;https://issues.apache.org/jira/secure/attachment/12890187/screenshot-1.png",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 26 02:08:35 UTC 2018,,,,,,,,,,"0|i3krfb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Oct/17 02:03;paulk;Eric, what Groovy version are you using? Unless I am missing something, your example seems to run fine on 2.4.12, 2.5.0-beta-1, 2.6.0-alpha-1 and master.;;;","02/Oct/17 15:10;emilles;I am using 2.4.12.  I agree, on command line and in groovy console it executes.  But I can't seem to figure out why when it failes within Groovy-Eclipse, which runs the same visitor to process the source for static compilation.  As you can see from the snippet, I needed to patch on my end.  But it looked like a probable improvement for the platform, so I opened this issue and shared my patch.;;;","02/Oct/17 22:47;paulk;As part of GROOVY-8336 different but similar changes were made. Do they help in your scenario?;;;","03/Oct/17 16:12;emilles;It may be helpful, it was not available in 2.4.13 snapshot at the time I was looking into the issue.  Also, it has a limitation of no enclosing closure.  Could that restriction be lifted?;;;","03/Oct/17 16:55;emilles;Paul,
I can confirm that the changes for Groovy-8336 don't address my issue.

!screenshot-1.png!;;;","26/Aug/18 02:08;daniel_sun;It is fixed now.
https://github.com/apache/groovy/commit/e82bd2654536675c7abcf51f250921f44b5c44f1;;;",,,,,,,,,,,,,,,,
Static compilation requires casting inside instanceof check (additional cases),GROOVY-8336,13106277,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,Schlogen,paulk,01/Oct/17 05:54,06/Mar/18 23:25,14/Jul/23 06:02,02/Oct/17 10:53,2.4.12,,,,,,,,2.4.13,,,,Compiler,,,,0,,,,,,,"Cloned from GROOVY-8260 to handle these additional cases:
{code}
import groovy.transform.CompileStatic

@CompileStatic
Date ternaryParam(Object input) {
    input instanceof Date ? input : null
}

@CompileStatic
Date ternaryLocalVar(Object input) {
    Object copy = input
    copy instanceof Date ? copy : null
}

@CompileStatic
Date ifThenElseParam(Object ifThenElseInput) {
    if (ifThenElseInput instanceof Date) {
        ifThenElseInput
    } else {
        null
    }
}

@CompileStatic
Date ifThenElseLocalVar(Object input) {
    Date result
    if (input instanceof Date) {
        result = input
    } else {
        result = null
    }
    result
}

class FooBase {}
class FooChild extends FooBase{}
@CompileStatic
FooChild ifThenElseLocalVar2(FooBase input) {
    FooChild result
    if (input instanceof FooChild) {
        result = input
    } else {
        result = null
    }
    result
}

def d = new Date()
assert ternaryParam(42) == null
assert ternaryParam('foo') == null
assert ternaryParam(d) == d
assert ternaryLocalVar(42) == null
assert ternaryLocalVar('foo') == null
assert ternaryLocalVar(d) == d
assert ifThenElseParam(42) == null
assert ifThenElseParam('foo') == null
assert ifThenElseParam(d) == d
assert ifThenElseLocalVar(42) == null
assert ifThenElseLocalVar('foo') == null
assert ifThenElseLocalVar(d) == d
def fc = new FooChild()
assert ifThenElseLocalVar2(fc) == fc
assert ifThenElseLocalVar2(new FooBase()) == null
{code}",macOS JDK 1.8,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8260,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 02 10:53:54 UTC 2017,,,,,,,,,,"0|i3kr5r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Oct/17 06:55;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/611

    GROOVY-8336: Static compilation requires casting inside instanceof ch…

    …eck (additional cases)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8336

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/611.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #611
    
----
commit 1b79882184484086220516b182c56a6c78e56ffd
Author: paulk <paulk@asert.com.au>
Date:   2017-10-01T06:53:25Z

    GROOVY-8336: Static compilation requires casting inside instanceof check (additional cases)

----
;;;","01/Oct/17 20:35;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/611
;;;","02/Oct/17 10:53;paulk;Proposed PR applied.;;;",,,,,,,,,,,,,,,,,,,
Packaging issue for Antlr4-related jars,GROOVY-8332,13105707,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,28/Sep/17 09:26,06/Mar/18 23:25,14/Jul/23 06:02,13/Oct/17 11:52,2.6.0-alpha-1,,,,,,,,2.6.0-alpha-2,,,,,,,,0,,,,,,,"The 2.6.0-alpha-1 jars have some incorrect service metadata.

To reproduce, create a gradle project containing the following files:
{code:title=Calc.java}
public class Calc {
    public static int sum(int a, int b) { return a + b; }
}
{code}
{code:title=CalcTest.groovy}
class CalcTest extends GroovyTestCase {
    void testSum() { assert 3 == Calc.sum(1, 2) }
}
{code}
{code:title=build.gradle}
group 'calc'
version '1.0-SNAPSHOT'

apply plugin: 'groovy'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    compile 'org.codehaus.groovy:groovy-all:2.6.0-alpha-1'
    testCompile 'junit:junit:4.12'
}
{code}
When invoking the {{test}} task via gradle, the following error is observed:
{noformat}
:compileJava
error: Bad service configuration file, or exception thrown while constructing Processor object: javax.annotation.processing.Processor: Provider org.antlr.v4.runtime.misc.RuleDependencyProcessor not found
:compileJava FAILED
{noformat}
I believe we need to reference:
{{groovyjarjarantlr4.v4.runtime.misc.RuleDependencyProcessor}}
instead of:
{{org.antlr.v4.runtime.misc.RuleDependencyProcessor}}
in our jarjar'd jar files within this file:
{{META-INF/services/javax.annotation.processing.Processor}}

We might need to roll this by hand since I suspect we won't be able to configure the antlr gradle plugin to do such a change.",,daniel_sun,erdi,jkemnade,keegan,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 13 11:52:52 UTC 2017,,,,,,,,,,"0|i3knnr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Sep/17 03:11;daniel_sun;Is it possible to replace org.antlr.v4.runtime.misc.RuleDependencyProcessor with groovyjarjarantlr4.v4.runtime.misc.RuleDependencyProcessor in the jarjar task?;;;","29/Sep/17 04:28;paulk;jarjar does some reference replacement but obviously doesn't know about the reference in this file. Actually, I am wondering if we even need a reference to that processor at all or is it only needed during grammar generation. I haven't looked into that part of antlr4 yet.;;;","29/Sep/17 04:42;daniel_sun;I guess annotations like @NotNull requires the processor.;;;","29/Sep/17 05:37;paulk;It's still not clear to me if it's required. We'd want @NonNull checking when we compile the grammar but after that?;;;","29/Sep/17 15:08;daniel_sun;https://github.com/tunnelvisionlabs/antlr4/blob/master/runtime/Java/src/org/antlr/v4/runtime/misc/RuleDependencyProcessor.java

As the comment shows, it is ""A compile-time validator for rule dependencies."". In other words, we need the RuleDependencyProcessor at compile time.;;;","08/Oct/17 21:44;erdi;I'm seeing the exact same issue when trying to build Geb using 2.6.0-alpha-1.;;;","13/Oct/17 11:52;paulk;Just removing the META-INF/services file seems to have fixed the problem without causing any issues.;;;",,,,,,,,,,,,,,,
Wrong 'Inconvertible types' error on casting interface ,GROOVY-8330,13105099,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,Alexey Afanasiev,Alexey Afanasiev,26/Sep/17 14:24,27/Sep/17 09:10,14/Jul/23 06:02,27/Sep/17 07:00,2.4.12,,,,,,,,2.4.13,2.5.0-beta-2,2.6.0-alpha-2,3.0.0-alpha-1,Static compilation,Static Type Checker,,,0,,,,,,,"{code}
import groovy.transform.CompileStatic

interface A1{}
interface A2 extends A1{}
        
class C1 implements A1{}
class C2 extends C1 implements A2 {}
        
@CompileStatic
def m(A2 a2) {
       C1 c1 = (C1) a2 // There is error here now: Inconvertible types: cannot cast A2 to C1
}
{code}

JLS handle this situation in 5.1.6.1 :
A narrowing reference conversion exists from reference type S to reference type T
if ......  - S is an interface type, T is a class type, and T does not name a final class.",,Alexey Afanasiev,blackdrag,daniel_sun,githubbot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 27 09:10:42 UTC 2017,,,,,,,,,,"0|i3kjxz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Sep/17 14:57;githubbot;GitHub user avafanasiev opened a pull request:

    https://github.com/apache/groovy/pull/607

    GROOVY-8330: Wrong 'Inconvertible types' error on casting interface

    Make cast error a little bit like java.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/avafanasiev/groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/607.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #607
    
----
commit f30d2e5dd6ce8045eb6656d1993f0dd9b07edfc5
Author: alexey.afanasiev <alexey.afanasiev@jetbrains.com>
Date:   2017-09-26T14:43:15Z

    GROOVY-8330: Wrong 'Inconvertible types' error on casting interface

----
;;;","26/Sep/17 19:27;blackdrag;thanks for the pull request. On first glance this looks really strange, until you realize you have been using a lot already ;)  So +1 here
;;;","27/Sep/17 06:44;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/607
;;;","27/Sep/17 07:00;daniel_sun;Thanks for your patch!;;;","27/Sep/17 09:10;Alexey Afanasiev;Thanks for accepting!;;;",,,,,,,,,,,,,,,,,
Can't access static method from same class within this constructor call,GROOVY-8327,13103682,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,idooley,idooley,20/Sep/17 17:59,13/Dec/18 10:05,14/Jul/23 06:02,22/Sep/18 17:11,2.5.2,2.6.0-alpha-1,3.0.0-alpha-3,,,,,,2.5.3,3.0.0-alpha-4,,,,,,,0,,,,,,,"The parser in 2.5, 2.6, 3.0 gives a MultipleCompilationErrorsException on code that compiled successfully in 2.4
{code:java|title=Code that fails to compile on 2.6.0-alpha-1}
class A {
    static String g() { }
    A() {
        this({g()}) // It is ok to create a closure that calls g() in a constructor, but not if it is being passed into this().
    }
    A(a) { }
}
{code}
{code:java|title=compilation error message}
$ groovyc test.groovy  
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
test.groovy: 4: Can't access instance method 'g' before the class is constructed
 @ line 4, column 15.
           this({g()}) // It is ok to create a closure that calls g() in a constructor, but not if it is being passed into this().
                 ^

1 error
{code}
My opinion is that groovy should allow users to call a static method inside a constructor before the instance has been fully constructed, but I'm not aware of the details of why this is disallowed in 2.6.0-alpha-1.",groovc command line on linux,daniel_sun,githubbot,idooley,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 23 00:11:10 UTC 2018,,,,,,,,,,"0|i3kb7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Sep/18 16:15;githubbot;GitHub user danielsun1106 opened a pull request:

    https://github.com/apache/groovy/pull/801

    GROOVY-8327: Parser regression. Can't access static instance method b…

    …efore class is constructed

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/danielsun1106/groovy GROOVY-8327

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/801.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #801
    
----
commit 4d285954134a45c88257aaa7b24775ea1f3a6a71
Author: danielsun1106 <realbluesun@...>
Date:   2018-09-22T15:49:06Z

    GROOVY-8327: Parser regression. Can't access static instance method before class is constructed

----
;;;","22/Sep/18 16:22;daniel_sun;The issue is fixed now.

P.S. This is not a bug of parser. ;;;","22/Sep/18 17:06;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/801
;;;","22/Sep/18 17:11;daniel_sun;Fixed by https://github.com/apache/groovy/commit/87c6310350de68a56d1721d32671747dc23cf549;;;","22/Sep/18 20:43;idooley;Thanks for the fix, [~daniel_sun]. I appreciate it!;;;","23/Sep/18 00:11;daniel_sun;My pleasure :-)
;;;",,,,,,,,,,,,,,,,
@Override should not copied onto methods generated by applying @Memoize,GROOVY-8326,13103659,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,erdi,erdi,20/Sep/17 16:29,06/Mar/18 23:25,14/Jul/23 06:02,02/Oct/17 00:37,2.4.12,,,,,,,,2.4.13,,,,,,,,0,ast,,,,,,"Applying {{@Memoized}} onto a method already annotated with {{@Override}} will result in a compilation error along the lines of:

{quote}
Method 'memoizedMethodPriv$...' from class '...' does not override method from its superclass or interfaces but is annotated with @Override.
{quote}

This is because all annotations of the method annotated with {{@Memoized}} are copied onto the method generated by the AST [here|https://github.com/apache/groovy/blob/731d4daa78b9cd32bea724d2d651aa1164eef6cc/src/main/org/codehaus/groovy/transform/MemoizedASTTransformation.java#L131]. In my opinion {{java.lang.Override}} should be filtered out.
",,erdi,githubbot,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 02 00:37:00 UTC 2017,,,,,,,,,,"0|i3kb2v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Oct/17 04:09;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/610

    GROOVY-8326: @Override should not copied onto methods generated by ap…

    …plying @Memoize

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8326-Memoized-Override

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/610.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #610
    
----
commit 8bb23c4a5574925a1eecfe57b1a8acbcafbbcb5a
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-10-01T04:06:49Z

    GROOVY-8326: @Override should not copied onto methods generated by applying @Memoize

----
;;;","01/Oct/17 21:04;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/610
;;;","02/Oct/17 00:37;paulk;John's PR applied. Thanks all.;;;",,,,,,,,,,,,,,,,,,,
@CompileStatic calls wrong newInstance method.,GROOVY-8325,13103564,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,chice,chice,20/Sep/17 10:33,06/Mar/18 23:25,14/Jul/23 06:02,16/Oct/17 05:44,2.4.10,,,,,,,,2.4.13,,,,Compiler,Static compilation,,,0,,,,,,,"
{code:java}
import groovy.transform.CompileStatic

class Foo {
    static Foo newInstance(Long v) {
        return new Foo()
    }
}

@CompileStatic   //crash only caused by this CompileStatic
class TestGroovy {
    static void main(String ... args) {
        def a = Foo.newInstance(123)  //when @CompileStatic, this calls DefaultGroovyMethods.newInstance
        println a
    }
}

{code}
",,blackdrag,chice,patric42,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 14 15:05:50 UTC 2017,,,,,,,,,,"0|i3kahr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Sep/17 14:10;paulk;Error message is:
{noformat}
groovy.lang.GroovyRuntimeException: Could not find matching constructor for: Foo(Integer)
{noformat}
Using {{Foo.newInstance(123L)}} works fine.
;;;","20/Sep/17 20:02;blackdrag;but shouldn´t the call with newInstance(int) call newInstance(Long) instead of newInstance(Object[])? In non-static groovy this should be the case. In Java I think not.;;;","21/Sep/17 00:07;paulk;I haven't checked yet what the correct behavior should be, I was just clarifying the error case and messages.;;;","16/Oct/17 00:09;paulk;I noticed that {{StaticTypeCheckingSupport#isAssignableTo}} has some clauses like {{Long_TYPE==toBeAssignedTo}}. I think they would need to be using {{.equals()}} or the {{.redirect()}}.;;;","16/Oct/17 02:01;paulk;Something else looks a little strange. If I just fix up the invalid {{==}} mentioned in the previous comment, then the example in the issue description works, but the results seem strange to me for this example:
{code}
import groovy.transform.*

class CustomNumber extends Number {
    @Delegate Long delegate = 42L
}

@CompileStatic
def method() {
    Groovy8325.newInstance2(new CustomNumber())
}

class Groovy8325 {
    static Groovy8325 newInstance2(Integer v) {
        new Groovy8325()
    }
}

println method()
{code}
With @CS, this passes and the method target is {{newInstance2(Integer)}} and via {{DTT#continueCastOnNumber}}, {{intValue()}} is called on the {{Number}}. This involves possible loss of precision but more importantly, I wouldn't expect us to support this from the type hierarchy point of view.

Without @CS, it gives:
{noformat}
groovy.lang.MissingMethodException: No signature of method: static Groovy8325.newInstance2() is applicable for argument types: (CustomNumber) values: [CustomNumber@114064d7]
Possible solutions: newInstance2(java.lang.Integer)
{noformat}
Note: I am using {{newInstance2}} just to remove the {{DGM#newInstance}} case from the equation - it would involve an extra consideration which isn't important for the case I believe is wrong.;;;","16/Oct/17 05:44;paulk;Okay, I fixed the original problem and also made the code a little stricter so that the case above which fails dynamic Groovy with MME now also fails static type checking. Thanks for reporting the issue.;;;","14/Nov/17 15:05;patric42;Please have a look at GROOVY-8380, as this fix causes a regression for

@groovy.transform.CompileStatic
def bla() {
   new Long( 5 / 2 )
}

That used to work and seems on par with the Java behaviour on that matter.;;;",,,,,,,,,,,,,,,
Enabling groovy.indy.logging can lead to stack overflows,GROOVY-8324,13103352,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,mwhipple,mwhipple,19/Sep/17 20:29,06/Mar/18 23:25,14/Jul/23 06:02,15/Oct/17 04:11,2.4.12,,,,,,,,2.4.13,,,,,,,,0,invokedynamic,,,,,,"Still digging through this a bit more, but while trying to diagnose performance issues I enabled indy logging which led to:
{noformat}
! Caused by: java.lang.StackOverflowError: null
! at java.lang.Class.getEnclosingMethodInfo(Class.java:1072)
! at java.lang.Class.getEnclosingClass(Class.java:1272)
! at java.lang.Class.getSimpleBinaryName(Class.java:1443)
! at java.lang.Class.getSimpleName(Class.java:1309)
! at java.lang.invoke.MethodType.toString(MethodType.java:797)
! at java.lang.String.valueOf(String.java:2982)                        <--- Loops back to here
! at java.lang.StringBuilder.append(StringBuilder.java:131)
! at org.codehaus.groovy.vmplugin.v7.Selector$MethodSelector.<init>(Selector.java:488)
! at org.codehaus.groovy.vmplugin.v7.Selector.getSelector(Selector.java:98)
! at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:227)
! at MyDomainClass.toString(MyDomainClass.groovy)
{noformat}

The domain class itself stringifies without issue, changing the class to use {{@CompileStatic}} seems to have resolved this issue. It might be nice if that specific log message could be toggled independently of the others to try to avoid the possibility of blowing up while attempting to troubleshooting. 

{noformat}
java version ""1.8.0_45""
Java(TM) SE Runtime Environment (build 1.8.0_45-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)
{noformat}",,blackdrag,githubbot,jwagenleitner,mwhipple,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Oct 15 04:11:27 UTC 2017,,,,,,,,,,"0|i3k96v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Sep/17 22:07;blackdrag;Wait.. do I get this right? You are running a program and you have indy logging enabled and this logging then leads to a stack overflow when trying to build a String containing a MethodType and the error goes away if you use @CompileStatic in your program and am I right in that the loop is completely java.lang space? That looks strange. Would it be possible for you to provide an example? Because like this I can only suspect that maybe this is due to a wrongly set inner class information or something alike, but that is just guessing.;;;","19/Sep/17 22:53;mwhipple;I'll work on providing better info in the next day now that I'm not occupied with the main issue. I meant to give an explanation for the abbreviated trace,  but it repeats from the tagged line down, so mostly the vmplugin stuff and the attempted stringifying of MyDomainClass. MyDomainClass in the above is a placeholder for a (non-nested) Bean style class which is @Immutable and it was that class to which adding @CompileStatic resolved the immediate issue. I'll work on getting a real code example together. 

After that issue was passed another came up with a NoClassDef error for a nested class elsewhere which seemed unrelated but that sounds like it may align with your suggestion.;;;","19/Sep/17 22:55;mwhipple;And the answer to all the questions before the final java.lang trace one is yes;;;","20/Sep/17 15:58;mwhipple;Other domain classes are also resulting in similar issues, all of which are relying on the {{@ToString}} AST Transformation.  Here's another trace for another class which seems to be getting stuck while stringifying the enumerated arguments during the same logging block:
{noformat}
! java.lang.StackOverflowError: null
! at org.codehaus.groovy.vmplugin.v7.IndyInterface$CALL_TYPES.values(IndyInterface.java:55)
! at org.codehaus.groovy.vmplugin.v7.Selector.getSelector(Selector.java:95)
! at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:227)
! at foo.PendingChange.toString(PendingChangeDAO.groovy)
! at java.lang.String.valueOf(String.java:2982)
! at java.lang.StringBuilder.append(StringBuilder.java:131)
! at org.codehaus.groovy.vmplugin.v7.Selector$MethodSelector.<init>(Selector.java:499)
! at org.codehaus.groovy.vmplugin.v7.Selector.getSelector(Selector.java:98)
! at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:227)
! at foo.PendingChange.toString(PendingChangeDAO.groovy)
! at java.lang.String.valueOf(String.java:2982)
! at java.lang.StringBuilder.append(StringBuilder.java:131)
! at org.codehaus.groovy.vmplugin.v7.Selector$MethodSelector.<init>(Selector.java:499)
! at org.codehaus.groovy.vmplugin.v7.Selector.getSelector(Selector.java:98)
! at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:227)
! at foo.PendingChange.toString(PendingChangeDAO.groovy)
{noformat}

I'm not done looking at the primary issue yet after all but I'll likely try to circle back to this shortly and see if I can debug it a bit.;;;","20/Sep/17 20:39;blackdrag;first time you mention @ToString. This is a strong indicator for the printing of the arguments in the logging. ""this"" is the first argument, thus if this.toString is done by invokedynamic, it will lead to an stack overflow. Which org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:227) needs a fix for the arguments. If you want to really get to the bottom if this I suggest you remove parts from the logging message in this line and see which is causing it. My bet is now on the arguments;;;","22/Sep/17 14:03;mwhipple;project to reproduce the issue in relative isolation: https://github.com/mwhipple/groovy-8324

Will poke around at it today.;;;","22/Sep/17 18:36;githubbot;GitHub user mwhipple opened a pull request:

    https://github.com/apache/groovy/pull/604

    GROOVY-8324: Skip logging 'this' argument in IndyInterface

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/mwhipple/groovy GROOVY-8324

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/604.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #604
    
----
commit c153a7220c76e814dd562faeb4d41f3975879dec
Author: Matt Whipple <mwhipple@brightcove.com>
Date:   2017-09-22T18:34:10Z

    GROOVY-8324: Skip logging 'this' argument in IndyInterface

----
;;;","22/Sep/17 18:55;mwhipple;Your bet was correct...the logging was cycling on a getter trying to stringify the {{this}} argument where the toString() invoked that getter. I opened a PR for what seems like a reasonable way to avoid this by not logging the {{this}} argument:

Sample output from the git project linked in previous comment:

instance method:
{noformat}
    INFO: ----------------------------------------------------
                invocation of method 'getName'
                invocation type: METHOD
                sender: class gt.MyOtherObject
                targetType: (MyOtherObject)Object
                safe navigation: false
                thisCall: true
                spreadCall: false
                with 1 arguments (including 'this')
{noformat}

non-instance method (unchanged):
{noformat}
    INFO: ----------------------------------------------------
                invocation of method 'append'
                invocation type: METHOD
                sender: class gt.MyOtherObject
                targetType: (Object,Object)Object
                safe navigation: false
                thisCall: false
                spreadCall: false
                with 2 arguments
                        argument[0] = gt.MyOtherObject(
                        argument[1] = test0
{noformat};;;","22/Sep/17 22:27;blackdrag;Hmm... but it does still mean, that if the second argument in that array is a class compiled with Groovy invokedynamic, it will cause further logging in the logging and in the worst case an overflow again. What do you think about printing the argument classes instead of the actual arguments? Maybe with identity hashcode?;;;","22/Sep/17 23:29;mwhipple;Sounds good to me, I'll swap the PR around later tonight or tomorrow. I don't _think_ the current approach would cause a stack overflow (though I could certainly be missing something), but it is definitely very noisy.;;;","23/Sep/17 18:08;mwhipple;Updated sample output:
Method call including {{@ToString}}'ed class (no longer descends):
{noformat}
    INFO: ----------------------------------------------------
                invocation of method 'checkPropNames'
                invocation type: METHOD
                sender: class gt.MyValueObject
                targetType: (Class,MyValueObject,HashMap)Object
                safe navigation: false
                thisCall: false
                spreadCall: false
                with 3 arguments
                        argument[0] = java.lang.Class@702fcf34
                        argument[1] = gt.MyValueObject@248274ae
                        argument[2] = java.util.LinkedHashMap@4ab86851
{noformat}

Call with null arg:
{noformat}
    INFO: ----------------------------------------------------
                invocation of method ''
                invocation type: CAST
                sender: class org.codehaus.groovy.vmplugin.v7.Selector
                targetType: (Object)String
                safe navigation: false
                thisCall: false
                spreadCall: false
                with 1 arguments
                        argument[0] = null
{noformat};;;","15/Oct/17 03:59;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/604
;;;","15/Oct/17 04:11;jwagenleitner;Thanks for reporting the issue and for the fix.;;;",,,,,,,,,
!instanceof treated incorrectly in type checker,GROOVY-8321,13102736,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,paulk,paulk,16/Sep/17 04:02,27/Nov/22 19:39,14/Jul/23 06:02,29/Oct/19 19:07,,,,,,,,,3.0.0-rc-1,,,,Static Type Checker,,,,0,,,,,,,"Currently in:
https://github.com/apache/groovy/blob/183b8fbf0248a2dceffbba684e50c3c2c060e46c/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java#L703

The `instanceof` and `!instanceof` operators are treated the same when in fact the exact opposite is required.

Consider the following code where the `instanceof` has been _accidentally_ replaced with `!instanceof`. 
{code}
[42, 'bar'].each { doit(it) }

@groovy.transform.TypeChecked
doit(arg) {
  if (arg !instanceof String) {
    println arg.toUpperCase() // MME: Integer.toUpperCase()
  } else {
    // println arg.toUpperCase() // [STC] [Static type checking] - Cannot find Object#toUpperCase()
    println 'is a number'
  }
}
{code}
We'd now expect the `toUpperCase` call to fail compilation but it succeeds and then fails at runtime.

Bonus points if the commented line in the else clause can be made to work.",,daniel_sun,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8523,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 26 02:18:29 UTC 2018,,,,,,,,,,"0|i3k5fj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Aug/18 02:18;daniel_sun;We can get compilation error on master:


{code:java}
[Static type checking] - Cannot find matching method java.lang.Object#toUpperCase(). Please check if the declared type is correct and if the method exists.
 at line: 6, column: 13
{code}


{code:java}
[42, 'bar'].each { doit(it) }

@groovy.transform.TypeChecked
doit(arg) {
  if (arg !instanceof String) {
    println arg.toUpperCase() // MME: Integer.toUpperCase()
  } else {
    // println arg.toUpperCase() // [STC] [Static type checking] - Cannot find Object#toUpperCase()
    println 'is a number'
  }
}
{code}
;;;",,,,,,,,,,,,,,,,,,,,,
Improve smart type on list expresions,GROOVY-8319,13102582,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,Alexey Afanasiev,Alexey Afanasiev,15/Sep/17 14:12,15/Sep/17 16:34,14/Jul/23 06:02,15/Sep/17 16:34,2.4.12,,,,,,,,2.4.13,2.5.0-beta-2,2.6.0-alpha-2,3.0.0-alpha-1,Static compilation,Static Type Checker,,,0,,,,,,,"Probably code below should be compiled well in CompileStatic:
{code}
def m() {
    def a  = 1
    Integer[] b = [a] // error: 'a' treats like an Object
}
{code}
and 
{code}
def m() {
     def row = ["""", """", """"]
     def (left, right) = [row[0], row[1]]
     left.toUpperCase() // error: 'left' treats like an Object
}
{code}",,Alexey Afanasiev,daniel_sun,githubbot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 15 16:34:06 UTC 2017,,,,,,,,,,"0|i3k4hr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Sep/17 14:18;githubbot;GitHub user avafanasiev opened a pull request:

    https://github.com/apache/groovy/pull/602

    GROOVY-8319: Improve smart type on list expressions

    I hope it should work like expected.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/avafanasiev/groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/602.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #602
    
----
commit 31792951288d2af1763a16ca81441ca18f5ba141
Author: alexey.afanasiev <alexey.afanasiev@jetbrains.com>
Date:   2017-09-15T14:16:11Z

    GROOVY-8319: Improve smart type on list expressions

----
;;;","15/Sep/17 16:27;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/602
;;;","15/Sep/17 16:34;daniel_sun;Thanks for your patch!;;;",,,,,,,,,,,,,,,,,,,
Smart type inference doesn't work on explicit closure params,GROOVY-8317,13101958,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,Alexey Afanasiev,Alexey Afanasiev,13/Sep/17 13:21,01/Feb/18 06:23,14/Jul/23 06:02,13/Dec/17 04:55,,,,,,,,,2.4.14,2.5.0-beta-3,2.6.0-alpha-3,3.0.0-alpha-2,Static compilation,Static Type Checker,,,0,,,,,,,"Should be compiled well:
{code}
@CompileStatic
class TestType {
    static def bar(Object b) {
        b.with { obj ->
            assert obj instanceof String
            obj.toUpperCase() // error: Cannot find matching method java.lang.Object#toUpperCase(). 
        }
    }
}
{code}

Funny moment - on implicit 'it' parameter works fine:
{code}
@CompileStatic
class TestType {
    static def bar(Object b) {
        b.with {
            assert it instanceof String
            it.toUpperCase()
        }
    }
}
{code}
",,Alexey Afanasiev,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6888,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 13 04:55:11 UTC 2017,,,,,,,,,,"0|i3k0pb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Dec/17 04:55;daniel_sun;Fixed by https://github.com/apache/groovy/commit/bd5191d9a8858945a4d83df58e261eb56bec0ab7

Thanks for the patch!;;;",,,,,,,,,,,,,,,,,,,,,
Project sourceSet for antlr seems wrong,GROOVY-8316,13101586,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,apupier,apupier,12/Sep/17 09:59,06/Mar/18 23:25,14/Jul/23 06:02,13/Sep/17 09:32,2.4.12,,,,,,,,2.5.0-beta-2,,,,,,,,0,,,,,,,as explained here https://github.com/eclipse/buildship/issues/566#issuecomment-328804533 it seems that the project sourceSet is wrongly defined,,apupier,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 13 10:23:06 UTC 2017,,,,,,,,,,"0|i3jyfr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Sep/17 00:33;paulk;Can you try again? The antlr sources are moved. There are still a couple of resources that should also be moved - but they shouldn't impact you and I'll move those too once I get time to test the relevant parts of the build that would be impacted.;;;","13/Sep/17 09:32;apupier;tried again, this error no more occur (but the ended result of the import in Eclipse is not usable, there are a lot of errors, don't even know by what to start);;;","13/Sep/17 10:23;paulk;I haven't really used Eclipse in anything other than an experimental capacity anytime recently. Perhaps others can give you better advice.

The only other suggestion I have is to try the GROOVY_2_5_X branch. It is slightly less complicated and if that works better it will point us to some areas we could focus fixing on.

Also, a long shot, but perhaps consider whether any hints from Cedric's slightly old screencast for Intellij might also apply to Eclipse:
http://melix.github.io/blog/2014/06/contribute-groovy-ide.html;;;",,,,,,,,,,,,,,,,,,,
Looping in GroovyRecognizer.enumConstants during compilation,GROOVY-8315,13101567,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,apupier,apupier,12/Sep/17 08:57,09/Dec/19 21:35,14/Jul/23 06:02,27/Nov/19 15:57,2.4.12,,,,,,,,2.4.18,2.5.9,3.0.0-rc-2,,Compiler,,,,0,,,,,,,"i tried to import the Groovy project in Eclipse using Buildship (so without using gradlew jar eclipse which is not working) and with Groovy-eclipse installed.  It is blocked in ""Compilation"".
This stack is roundtripping from l.6825 to 6835

{noformat}
Name: Worker-3
State: RUNNABLE
Total blocked: 1,686  Total waited: 1,206

Stack trace: 
org.codehaus.groovy.antlr.parser.GroovyRecognizer.enumConstants(GroovyRecognizer.java:6825)
org.codehaus.groovy.antlr.parser.GroovyRecognizer.enumBlock(GroovyRecognizer.java:5878)
org.codehaus.groovy.antlr.parser.GroovyRecognizer.enumDefinition(GroovyRecognizer.java:2422)
org.codehaus.groovy.antlr.parser.GroovyRecognizer.typeDefinitionInternal(GroovyRecognizer.java:2134)
org.codehaus.groovy.antlr.parser.GroovyRecognizer.classField(GroovyRecognizer.java:6368)
org.codehaus.groovy.antlr.parser.GroovyRecognizer.enumConstants(GroovyRecognizer.java:6868)
org.codehaus.groovy.antlr.parser.GroovyRecognizer.enumBlock(GroovyRecognizer.java:5878)
org.codehaus.groovy.antlr.parser.GroovyRecognizer.enumDefinition(GroovyRecognizer.java:2422)
org.codehaus.groovy.antlr.parser.GroovyRecognizer.typeDefinitionInternal(GroovyRecognizer.java:2134)
org.codehaus.groovy.antlr.parser.GroovyRecognizer.statement(GroovyRecognizer.java:1473)
org.codehaus.groovy.antlr.parser.GroovyRecognizer.compilationUnit(GroovyRecognizer.java:772)
org.codehaus.groovy.antlr.ErrorRecoveredCSTParserPlugin.transformCSTIntoAST(ErrorRecoveredCSTParserPlugin.java:64)
org.codehaus.groovy.antlr.AntlrParserPlugin.parseCST(AntlrParserPlugin.java:113)
org.codehaus.groovy.control.SourceUnit.parse(SourceUnit.java:248)
org.codehaus.groovy.control.CompilationUnit$8.call(CompilationUnit.java:182)
org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:966)
org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:622)
org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:598)
org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:575)
org.codehaus.jdt.groovy.internal.compiler.ast.GroovyCompilationUnitDeclaration.processToPhase(GroovyCompilationUnitDeclaration.java:220)
org.codehaus.jdt.groovy.internal.compiler.ast.GroovyParser.dietParse(GroovyParser.java:388)
org.codehaus.jdt.groovy.integration.internal.MultiplexingParser.dietParse(MultiplexingParser.java:53)
org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:827)
org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:395)
org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:441)
org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:427)
org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:392)
org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:192)
org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:329)
org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:63)
org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:256)
org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:175)
org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:735)
org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)
org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)
org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:301)
org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:304)
org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:360)
org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:383)
org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:142)
org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:232)
org.eclipse.core.internal.jobs.Worker.run(Worker.java:56)
{noformat}

it seems to be related to the groovy compiler itself (currently using the 2.4.12 embedded in Groovy-eclipse)",,apupier,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Oct 29 19:09:57 UTC 2019,,,,,,,,,,"0|i3jybj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Sep/17 18:12;emilles;Aurélien, can you supply the enum that is being processed by your stack trace?  When you compile with gradle (aka groovyc), is this looping happening?  I think this is likely going to need to be an issue opened against groovy-eclipse.;;;","25/Sep/17 07:20;apupier;{quote}can you supply the enum that is being processed by your stack trace? {quote}
Unfortunately, I can't provide the enum that is processed, the UI is frozen when i try to import the ""Groovy"" project.

{quote}
When you compile with gradle (aka groovyc), is this looping happening? I think this is likely going to need to be an issue opened against groovy-eclipse.{quote}

I have not tried with this specific version, I was blocked during my investigation.
I don't have the project anymore and moved on another thing right now. not sure when i will have time to get back to that.


;;;","29/Oct/19 19:09;emilles;See also GROOVY-8507;;;",,,,,,,,,,,,,,,,,,,
groovy Eclipse task is generating classpath with duplicated src/main entry,GROOVY-8314,13101559,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,apupier,apupier,12/Sep/17 08:27,24/Nov/19 02:44,14/Jul/23 06:02,29/Oct/19 19:10,2.4.12,,,,,,,,3.0.0-rc-1,,,,,,,,0,,,,,,,"- launch gradlew jar eclipse
- import inside Eclipse
--> notice the ""build path contains duplicate entry: 'src/main' for project 'groovy'

you can see it in the Java Build Path dialog too:
!screenshot-1.png!
",,apupier,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"12/Sep/17 08:27;apupier;screenshot-1.png;https://issues.apache.org/jira/secure/attachment/12886592/screenshot-1.png",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 25 07:22:19 UTC 2017,,,,,,,,,,"0|i3jy9r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Sep/17 18:14;emilles;Aurélien, can you move this issue over to https://github.com/groovy/groovy-eclipse/issues?  Also, did Buildship/Gradle generate the .classpath for your project or did you create the .classpath manually?;;;","25/Sep/17 07:22;apupier;I think that it is an issue with the Groovy project configuration itself. I used the eclipse task provided by the Groovy project to generate the .classpath;;;",,,,,,,,,,,,,,,,,,,,
NullPointerException in TypeResolver when using generic array return type,GROOVY-8313,13101038,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,emilles,emilles,09/Sep/17 14:16,06/Mar/18 23:25,14/Jul/23 06:02,16/Oct/17 23:59,,,,,,,,,2.4.13,,,,,,,,0,,,,,,,"I think this is related to GROOVY-6899.  I've been trying to isolate this for some time now: https://github.com/groovy/groovy-eclipse/issues/174.  When using a generic array type as a return value, the bridge method is written improperly.

{code}
public interface MultiIndexed<PK, SK> {
  PK getPrimaryKey();
  SK[] getSecondaryKeys();
}

class MIData implements MultiIndexed<Integer, String> {
  final String value
  final Integer primaryKey
  final String[] secondaryKeys

  MIData(String val, Integer pk, String... sk) {
    this.value = val
    this.primaryKey = pk
    this.secondaryKeys = sk
  }
}
{code}

javap on MiData.class shows {{public final SK[] getSecondaryKeys();}}.  The equivalent Java class shows a different signature for the bridge method: {{public java.lang.Object[] getSecondaryKeys();}}.

This causes an NPE under Introspector when bean info is trying to be resolved.
{code}
java.lang.NullPointerException
    at com.sun.beans.TypeResolver.resolve(TypeResolver.java:203)
    at com.sun.beans.TypeResolver.resolve(TypeResolver.java:162)
    at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:81)
    at java.beans.FeatureDescriptor.getReturnType(FeatureDescriptor.java:370)
    at java.beans.Introspector.getTargetEventInfo(Introspector.java:1052)
    at java.beans.Introspector.getBeanInfo(Introspector.java:427)
    at java.beans.Introspector.getBeanInfo(Introspector.java:173)
    at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:3289)
    at java.security.AccessController.doPrivileged(Native Method)
    at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:3287)
    at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:3263)
    at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:254)
    at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:285)
    at MiData.$getStaticMetaClass(MiData.groovy)
    at MiData.<init>(MiData.groovy)

class Main {
  static void main(String[] args) {
    def data = new MIData('V', 1, 'B')
    print 'no error'
  }
}
{code}


I think this can be fixed in {{Verifier.getCovariantImplementation}}, like this:
{code}
        // if we reach this point we have at least one parameter or return type, that
        // is different in its specified form. That means we have to create a bridge method!
        MethodNode newMethod = new MethodNode(
                oldMethod.getName(),
                overridingMethod.getModifiers() | ACC_SYNTHETIC | ACC_BRIDGE,
                // GRECLIPSE edit
                //oldMethod.getReturnType().getPlainNodeReference(),
                GenericsUtils.nonGeneric(oldMethod.getReturnType()),
                // GRECLIPSE end
                cleanParameters(oldMethod.getParameters()),
                oldMethod.getExceptions(),
                null
        );
{code}
",,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 16 23:59:17 UTC 2017,,,,,,,,,,"0|i3jv2v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Oct/17 23:59;paulk;Fixed. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,,,
[Parrot]Failed to check duplicated parameters properly,GROOVY-8311,13100855,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,daniel_sun,daniel_sun,08/Sep/17 16:24,06/Mar/18 23:25,14/Jul/23 06:02,08/Sep/17 16:49,2.6.0-alpha-1,,,,,,,,2.6.0-alpha-2,,,,parser,,,,0,,,,,,,"The following code yields {{Duplicated named parameter 'name' found at line: 5, column: 27}}

{code:java}
def greet(args) {  
    [args.name, args.age] 
} 
def name = 'age' 
assert greet(name: 'Doe', (name): 8) == ['Doe', 8]
{code}
",,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 08 16:48:59 UTC 2017,,,,,,,,,,"0|i3jtwn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Sep/17 16:48;daniel_sun;Fixed by https://github.com/apache/groovy/commit/302a78e3df5de2a1bc34d478214358f3b32d4714;;;",,,,,,,,,,,,,,,,,,,,,
Strange @CompileStatic check in Closure ,GROOVY-8310,13100510,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,Alexey Afanasiev,Alexey Afanasiev,07/Sep/17 16:14,09/Dec/19 21:36,14/Jul/23 06:02,15/Nov/19 03:08,,,,,,,,,3.0.0-rc-2,,,,Static compilation,Static Type Checker,,,0,,,,,,,"This code compiles normal:
{code}
@CompileStatic
class B {
    public <T> T bar(Closure<Collection<Integer>> a) {
        return null
    }

    def use() {
       bar {
            [1]
        }
    }
}
{code}

Switching return type cause error in code:
{code}
import groovy.transform.CompileStatic

@CompileStatic
class B {
    public def bar(Closure<Collection<Integer>> a) {
        return null
    }

    def use() {
        bar { // Error:(21, 9) Groovyc: [Static type checking] - Cannot find matching method pack.B#bar(groovy.lang.Closure <java.util.List>). 
            [1]
        }
    }
}
{code}

I believe first example should have error too.  But probably after fixing in that way following code will be broken:
{code}
def foo() {
        def nums = [1]
        def res = nums.collectMany { [it] }
    }
{code}",,Alexey Afanasiev,daniel_sun,daniilo,emilles,,,,,"eric-milles commented on pull request #1078: GROOVY-8310: STC: check closure return type when method type has generic
URL: https://github.com/apache/groovy/pull/1078
 
 
   Signature for DGM.collectMany needed to be fixed.  Once STC checks closure return type compatibility (against method with return type generics), a list returned from the body of a `collectMany` will not match `Closure<Collection<? extedns T>>` but does satisfy `Closure<? extends Collection<? extedns T>>`.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Nov/19 11:27;githubbot;600","danielsun1106 commented on issue #1078: GROOVY-8310: STC: check closure return type when method type has generic
URL: https://github.com/apache/groovy/pull/1078#issuecomment-552249370
 
 
   LGTM
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;11/Nov/19 00:01;githubbot;600","danielsun1106 commented on pull request #1078: GROOVY-8310: STC: check closure return type when method type has generic
URL: https://github.com/apache/groovy/pull/1078
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;15/Nov/19 03:07;githubbot;600","danielsun1106 commented on issue #1078: GROOVY-8310: STC: check closure return type when method type has generic
URL: https://github.com/apache/groovy/pull/1078#issuecomment-554190779
 
 
   Merged. Thanks.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;15/Nov/19 03:07;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 10 10:20:28 UTC 2019,,,,,,,,,,"0|i3jrs7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Nov/19 21:46;emilles;If the matched method (bar in this case) has generics in its return type, {{org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor#visitMethodCallExpression}} goes into this block (circa line 3500):
{code:java}
                        if (isUsingGenericsOrIsArrayUsingGenerics(returnType)) {
                            visitMethodCallArguments(chosenReceiver.getType(), argumentList, true, directMethodCallCandidate);
                            ClassNode irtg = inferReturnTypeGenerics(chosenReceiver.getType(), directMethodCallCandidate, callArguments, call.getGenericsTypes());
                            returnType = irtg != null && implementsInterfaceOrIsSubclassOf(irtg, returnType) ? irtg : returnType;
                            callArgsVisited = true;
                        }
{code}

This marks {{callArgsVisited}} and so it does not go into this block where the error is generated for the other test case (circa 3550):
{code:java}
            if (!callArgsVisited) {
                MethodNode mn = (MethodNode) call.getNodeMetaData(DIRECT_METHOD_CALL_TARGET);
                visitMethodCallArguments(receiver, argumentList, true, mn);
                // GROOVY-6219
                if (mn != null) {
                    List<Expression> argExpressions = argumentList.getExpressions();
                    Parameter[] parameters = mn.getParameters();
                    for (int i = 0; i < argExpressions.size() && i < parameters.length; i += 1) {
                        Expression arg = argExpressions.get(i);
                        ClassNode pType = parameters[i].getType();
                        ClassNode aType = getType(arg);
                        if (CLOSURE_TYPE.equals(pType) && CLOSURE_TYPE.equals(aType)) {
                            if (!isAssignableTo(aType, pType)) {
                                addNoMatchingMethodError(receiver, name, getArgumentTypes(argumentList), call);
                                call.removeNodeMetaData(DIRECT_METHOD_CALL_TARGET);
                            }
                        }
                    }
                }
            }
{code}
;;;","10/Nov/19 10:20;emilles;Because covariance does not extend to the generics, {{Closure<Collection>}} and {{Closure<List>}} are not the same types.  If you change the signature of bar to {{Closure<? extends Collection<Integer>}} or cast the list expression to {{Collection<Integer>}}, there are no errors.

So if the difference between the return types is fixed, there will be an error for ""def bar(...)"" and ""public <T> T bar(...)"".;;;",,,,,,,,,,,,,,,,,,,,
Error trying to grab a dependency available in local m2 repo when using the default Ivy settings file provided by Groovy,GROOVY-8305,13098591,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,apupier,apupier,30/Aug/17 15:32,09/Dec/19 21:36,14/Jul/23 06:02,09/Nov/19 15:17,2.4.12,,,,,,,,2.5.9,3.0.0-rc-2,,,Grape,,,,0,,,,,,,"the default Ivy settings file used is:
https://github.com/apache/groovy/blob/183b8fbf0248a2dceffbba684e50c3c2c060e46c/src/resources/groovy/grape/defaultGrapeConfig.xml#L29

it contains:

{quote}<ibiblio name=""localm2"" root=""file:$\{user.home\}/.m2/repository/""{quote}

which leads to this kind of error on windows when the file is available in the local m2 repo:

{quote}:: downloading artifacts ::
Preparing to download artifact org.apache.camel#camel-catalog-provider-karaf;2.19.2!camel-catalog-provider-karaf.jar
	 trying file:C:\Users\Aurelien Pupier/.m2/repository/org/apache/camel/camel-catalog-provider-karaf/2.19.2/camel-catalog-provider-karaf-2.19.2.jar
		tried file:C:\Users\Aurelien Pupier/.m2/repository/org/apache/camel/camel-catalog-provider-karaf/2.19.2/camel-catalog-provider-karaf-2.19.2.jar
downloading file:C:/Users/Aurelien Pupier/.m2/repository/org/apache/camel/camel-catalog-provider-karaf/2.19.2/camel-catalog-provider-karaf-2.19.2.jar ...
	localm2: downloading file:C:/Users/Aurelien Pupier/.m2/repository/org/apache/camel/camel-catalog-provider-karaf/2.19.2/camel-catalog-provider-karaf-2.19.2.jar
		to C:\Users\Aurelien Pupier\.groovy\grapes\org.apache.camel\camel-catalog-provider-karaf\jars\camel-catalog-provider-karaf-2.19.2.jar.part
java.lang.IllegalArgumentException: Invalid uri 'file:C:/Users/Aurelien Pupier/.m2/repository/org/apache/camel/camel-catalog-provider-karaf/2.19.2/camel-catalog-provider-karaf-2.19.2.jar': incorrect path{quote}
",,apupier,githubbot,jaikiran,paulk,,,,,"eric-milles commented on issue #597: GROOVY-8305: Fix default Ivy settings file for local m2 path
URL: https://github.com/apache/groovy/pull/597#issuecomment-551054369
 
 
   When I have used a filesystem-based ibiblio in the past on Windows, the format looked like
   ```
   <ibiblio name=""Local"" m2compatible=""true"" root=""file:///C:/Users/...""
   ```
   As stated above, `${user.home}` is going to resolve to ""C:\..."" on Windows and ""/home/..."" on Linux.  So, I don't think you can unconditionally set a file url prefix that will work for both.  Is there a variable that can be used to get a file: url for the user's directory?
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Nov/19 12:12;githubbot;600","eric-milles commented on issue #597: GROOVY-8305: Fix default Ivy settings file for local m2 path
URL: https://github.com/apache/groovy/pull/597#issuecomment-551057610
 
 
   Another approach would be to set the ""ivy.ibiblio.default.artifact.root"" property from the code and remove the root attribute from the settings file.  I thinnk this defaults to Maven Central's URL.  So you would need to add a root attribute to the ibiblio below jcenter, which is intended to point to maven central.
   
   https://ant.apache.org/ivy/history/master/resolver/ibiblio.html
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Nov/19 12:22;githubbot;600","eric-milles commented on issue #597: GROOVY-8305: Fix default Ivy settings file for local m2 path
URL: https://github.com/apache/groovy/pull/597#issuecomment-551057610
 
 
   Another approach would be to set the ""ivy.ibiblio.default.artifact.root"" property from the code and remove the root attribute from the settings file.  I thinnk this defaults to Maven Central's URL.  So you would need to add a root attribute to the ibiblio below jcenter, which is intended to point to maven central.
   
   https://ant.apache.org/ivy/history/master/resolver/ibiblio.html
   
   Or you may be able to encode ""user.home"" to a url and set as a system property that is referenced from the default settings file.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Nov/19 12:27;githubbot;600","eric-milles commented on issue #597: GROOVY-8305: Fix default Ivy settings file for local m2 path
URL: https://github.com/apache/groovy/pull/597#issuecomment-551057610
 
 
   Another approach would be to set the ""ivy.ibiblio.default.artifact.root"" property from the code and remove the root attribute from the settings file.  I think this defaults to Maven Central's URL.  So you would need to add a root attribute to the ibiblio below jcenter, which is intended to point to maven central.
   
   https://ant.apache.org/ivy/history/master/resolver/ibiblio.html
   
   Or you may be able to encode ""user.home"" to a url and set as a system property that is referenced from the default settings file.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Nov/19 12:31;githubbot;600","eric-milles commented on issue #597: GROOVY-8305: Fix default Ivy settings file for local m2 path
URL: https://github.com/apache/groovy/pull/597#issuecomment-551057610
 
 
   Another approach would be to set the ""ivy.ibiblio.default.artifact.root"" property from the code and remove the root attribute from the settings file.  I think this defaults to Maven Central's URL.  So you would need to add a root attribute to the ibiblio below jcenter, which is intended to point to maven central.
   
   https://ant.apache.org/ivy/history/master/resolver/ibiblio.html
   
   Or you may be able to encode ""user.home"" to a url and set as a system property that is referenced from the default settings file.
   
   Update: Looks like you can set variables for the settings file like this ""ivyInstance.settings.setVariable('ivy.checksums', '')"" instead of System properties.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Nov/19 12:38;githubbot;600","eric-milles commented on issue #597: GROOVY-8305: Fix default Ivy settings file for local m2 path
URL: https://github.com/apache/groovy/pull/597#issuecomment-551064285
 
 
   Last line below is proposed addition to `GrapeIvy.groovy` that would allow you to use ""${user.home.url}"" in the default settings xml.
   ```groovy
       GrapeIvy() {
           // if we are already initialized, quit
           if (enableGrapes) return
   
           // start ivy
           Message.defaultLogger = new DefaultMessageLogger(System.getProperty('ivy.message.logger.level', '-1') as int)
           settings = new IvySettings()
           settings.setVariable('user.home.url', new File(System.getProperty('user.home')).toURI().toURL() as String)
   ```
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Nov/19 12:45;githubbot;600","eric-milles commented on issue #597: GROOVY-8305: Fix default Ivy settings file for local m2 path
URL: https://github.com/apache/groovy/pull/597#issuecomment-551064285
 
 
   Last line below is proposed addition to `GrapeIvy.groovy` that would allow you to use ""${user.home.url}"" in the default settings xml.
   ```groovy
       GrapeIvy() {
           // if we are already initialized, quit
           if (enableGrapes) return
   
           // start ivy
           Message.defaultLogger = new DefaultMessageLogger(System.getProperty('ivy.message.logger.level', '-1') as int)
           settings = new IvySettings()
           settings.setVariable('user.home.url', new File(System.getProperty('user.home')).toURI().toURL() as String)
   ```
   
   _Note_: This property value ends with a slash.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Nov/19 13:09;githubbot;600","eric-milles commented on pull request #1073: GROOVY-8305: build ""file:"" URL for ""user.home"" and set as Ivy variable
URL: https://github.com/apache/groovy/pull/1073
 
 
   closes #597
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;07/Nov/19 14:45;githubbot;600","danielsun1106 commented on issue #1073: GROOVY-8305: build ""file:"" URL for ""user.home"" and set as Ivy variable
URL: https://github.com/apache/groovy/pull/1073#issuecomment-551371777
 
 
   +1
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Nov/19 03:43;githubbot;600","paulk-asert commented on issue #1073: GROOVY-8305: build ""file:"" URL for ""user.home"" and set as Ivy variable
URL: https://github.com/apache/groovy/pull/1073#issuecomment-551563321
 
 
   +1
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Nov/19 10:47;githubbot;600","danielsun1106 commented on pull request #597: GROOVY-8305: Fix default Ivy settings file for local m2 path
URL: https://github.com/apache/groovy/pull/597
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Nov/19 04:07;githubbot;600","danielsun1106 commented on pull request #1073: GROOVY-8305: build ""file:"" URL for ""user.home"" and set as Ivy variable
URL: https://github.com/apache/groovy/pull/1073
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Nov/19 04:07;githubbot;600","danielsun1106 commented on issue #1073: GROOVY-8305: build ""file:"" URL for ""user.home"" and set as Ivy variable
URL: https://github.com/apache/groovy/pull/1073#issuecomment-552064025
 
 
   Merged. Thanks.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Nov/19 04:08;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,0,7800,,,0,7800,,CAMEL-11727,,,,,,,,,,,IVY-1567,,,,,,"15/Sep/17 12:10;apupier;screenshot-1.png;https://issues.apache.org/jira/secure/attachment/12887332/screenshot-1.png","15/Sep/17 12:11;apupier;screenshot-2.png;https://issues.apache.org/jira/secure/attachment/12887333/screenshot-2.png",,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 21 05:19:17 UTC 2019,,,,,,,,,,"0|i3jghb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Aug/17 15:42;githubbot;GitHub user apupier opened a pull request:

    https://github.com/apache/groovy/pull/597

    GROOVY-8305: Fix default Ivy settings file for local m2 path

    - worth being tested on Linux
    - not sure how to write a test for that

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/apupier/groovy GROOVY-8305-FixIvySettingsFile

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/597.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #597
    
----
commit 9740919cee991a573a45e288f8aa7d4490dfcc4f
Author: Aurélien Pupier <apupier@redhat.com>
Date:   2017-08-30T15:39:44Z

    GROOVY-8305: Fix default Ivy settings file for local m2 path
    
    Signed-off-by: Aurélien Pupier <apupier@redhat.com>

----
;;;","30/Aug/17 16:32;githubbot;Github user jaikiran commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/597#discussion_r136121797
  
    --- Diff: src/resources/groovy/grape/defaultGrapeConfig.xml ---
    @@ -26,7 +26,7 @@
             <ivy pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/ivy-[revision].xml""/>
             <artifact pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/[type]s/[artifact]-[revision](-[classifier]).[ext]""/>
           </filesystem>
    -      <ibiblio name=""localm2"" root=""file:${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    +      <ibiblio name=""localm2"" root=""file:/${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    --- End diff --
    
    Actually, as noted in the RFC[1] and the simplified version[2], this should be:
    
    ```
    file:///${user.home}/.m2/repository/
    ```
    That should work fine both on Windows and *nix
    
    [1] https://tools.ietf.org/html/rfc8089
    [2] https://en.wikipedia.org/wiki/File_URI_scheme
;;;","30/Aug/17 17:13;githubbot;Github user apupier commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/597#discussion_r136132695
  
    --- Diff: src/resources/groovy/grape/defaultGrapeConfig.xml ---
    @@ -26,7 +26,7 @@
             <ivy pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/ivy-[revision].xml""/>
             <artifact pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/[type]s/[artifact]-[revision](-[classifier]).[ext]""/>
           </filesystem>
    -      <ibiblio name=""localm2"" root=""file:${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    +      <ibiblio name=""localm2"" root=""file:/${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    --- End diff --
    
    I tried with file:/// and it is not working:
    
    cachedGrapes: resource not reachable for org.apache.camel#camel-catalog-provider-karaf;2.19.2: res=C:\Users\Aurelien Pupier\.groovy\grapes\org.apache.camel\camel-catalog-provider-karaf\jars\camel-catalog-provider-karaf-2.19.2.jar
    	 trying file:///C:\Users\Aurelien Pupier/.m2/repository/org/apache/camel/camel-catalog-provider-karaf/2.19.2/camel-catalog-provider-karaf-2.19.2.jar
    		tried file:///C:\Users\Aurelien Pupier/.m2/repository/org/apache/camel/camel-catalog-provider-karaf/2.19.2/camel-catalog-provider-karaf-2.19.2.jar
;;;","30/Aug/17 17:17;githubbot;Github user apupier commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/597#discussion_r136134093
  
    --- Diff: src/resources/groovy/grape/defaultGrapeConfig.xml ---
    @@ -26,7 +26,7 @@
             <ivy pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/ivy-[revision].xml""/>
             <artifact pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/[type]s/[artifact]-[revision](-[classifier]).[ext]""/>
           </filesystem>
    -      <ibiblio name=""localm2"" root=""file:${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    +      <ibiblio name=""localm2"" root=""file:/${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    --- End diff --
    
    it is working with file://
;;;","06/Sep/17 14:05;githubbot;Github user lhein commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/597#discussion_r137277087
  
    --- Diff: src/resources/groovy/grape/defaultGrapeConfig.xml ---
    @@ -26,7 +26,7 @@
             <ivy pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/ivy-[revision].xml""/>
             <artifact pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/[type]s/[artifact]-[revision](-[classifier]).[ext]""/>
           </filesystem>
    -      <ibiblio name=""localm2"" root=""file:${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    +      <ibiblio name=""localm2"" root=""file:/${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    --- End diff --
    
     file:///${user.home}/.m2/repository/ 
    
    is most likely not correct. You will end up with 4 slashes on Linux/Unix.
    
    It should be file:// afaik
;;;","06/Sep/17 14:13;githubbot;Github user lhein commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/597#discussion_r137279308
  
    --- Diff: src/resources/groovy/grape/defaultGrapeConfig.xml ---
    @@ -26,7 +26,7 @@
             <ivy pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/ivy-[revision].xml""/>
             <artifact pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/[type]s/[artifact]-[revision](-[classifier]).[ext]""/>
           </filesystem>
    -      <ibiblio name=""localm2"" root=""file:${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    +      <ibiblio name=""localm2"" root=""file:/${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    --- End diff --
    
    besides that the change works on my fedora machine.
;;;","06/Sep/17 14:19;githubbot;Github user lhein commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/597#discussion_r137280911
  
    --- Diff: src/resources/groovy/grape/defaultGrapeConfig.xml ---
    @@ -26,7 +26,7 @@
             <ivy pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/ivy-[revision].xml""/>
             <artifact pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/[type]s/[artifact]-[revision](-[classifier]).[ext]""/>
           </filesystem>
    -      <ibiblio name=""localm2"" root=""file:${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    +      <ibiblio name=""localm2"" root=""file:/${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    --- End diff --
    
    just tested with file:// and it fails for me.
;;;","06/Sep/17 14:23;githubbot;Github user apupier commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/597#discussion_r137282315
  
    --- Diff: src/resources/groovy/grape/defaultGrapeConfig.xml ---
    @@ -26,7 +26,7 @@
             <ivy pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/ivy-[revision].xml""/>
             <artifact pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/[type]s/[artifact]-[revision](-[classifier]).[ext]""/>
           </filesystem>
    -      <ibiblio name=""localm2"" root=""file:${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    +      <ibiblio name=""localm2"" root=""file:/${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    --- End diff --
    
    to sum up:
    - ""file:/""
    -- Windows OK
    -- Linux OK
    - ""file://""
    -- Windows OK
    -- Linux KO
    - ""file:///""
    -- Windows KO
    -- Linux KO
    
    and the winner is: ""file:/""
;;;","15/Sep/17 12:29;apupier;steps to reproduce (sorry not found easier ones):
- ensure you have .m2/repository/org/apache/camel/camel-catalog-provider-karaf/2.19.2/camel-catalog-provider-karaf-2.19.2.jar
- ensure you have no camel-catalog-provider-karaf-2.19.2.jar in .groovy/grapes cache
- Install [Fuse Tooling | https://tools.jboss.org/features/fusetools.html] that you can download from https://tools.jboss.org/downloads/
- Click File -> New -> Fuse Integration project
!screenshot-1.png!
- click next
- put version to 2.19.2
!screenshot-2.png!
- click Finish

- open Error log
-- Window -> Show view -> other...
-- Choose ""Error log""
--> if you hit the issue you will see a message ""Unable to load Camel Catalog for version 2.19.2. Please check your connection and your local .m2 repository.""
Please note that there is a button ""Open log"" if you want to see more traces
Please note that i can't see the Ivy log (in case groovy.grape.report.downloads=true and ivy.message.logger.level=4 has been set, not sure why for now, i can see them only in osgi console)

;;;","29/Sep/17 13:07;githubbot;Github user nickboldt commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/597#discussion_r141862977
  
    --- Diff: src/resources/groovy/grape/defaultGrapeConfig.xml ---
    @@ -26,7 +26,7 @@
             <ivy pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/ivy-[revision].xml""/>
             <artifact pattern=""${user.home}/.groovy/grapes/[organisation]/[module]/[type]s/[artifact]-[revision](-[classifier]).[ext]""/>
           </filesystem>
    -      <ibiblio name=""localm2"" root=""file:${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    +      <ibiblio name=""localm2"" root=""file:/${user.home}/.m2/repository/"" checkmodified=""true"" changingPattern="".*"" changingMatcher=""regexp"" m2compatible=""true""/>
    --- End diff --
    
    This seems logical/obvious since ${user.home} includes a prefix slash, and for a valid URI you need two slashes. Thus when in doubt, file:/${user.home}/path/to/things. This is true for p2 repo URIs too.
;;;","21/Nov/19 05:19;paulk;This change is possibly the cause for GROOVY-9312;;;",,,,,,,,,,,
VerifyError for nested class this call to static method,GROOVY-8303,13097847,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,jwagenleitner,jwagenleitner,27/Aug/17 21:21,06/Mar/18 23:25,14/Jul/23 06:02,28/Aug/17 04:24,2.5.0-beta-1,,,,,,,,2.5.0-beta-2,,,,,,,,0,,,,,,,"{code}
class Base {
    static class Nested {
        private String b
        static String getData() { return ""ABCD"" }
        Nested() { this(getData()) }
        Nested(String b) { this.b = b }
        String toString() { b }
    }
}
assert new Base.Nested().toString() == 'ABCD'
{code}

Results in 

{code}
java.lang.VerifyError: (class: Base$Nested, method: <init> signature: ()V) Expecting to find object/array on stack.
{code}

The same code works if a top-level class.",,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7014,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 28 04:19:39 UTC 2017,,,,,,,,,,"0|i3jbxr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Aug/17 22:01;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/593

    GROOVY-8303: VerifyError for nested class this call to static method

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8303-VerifyError-Nested

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/593.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #593
    
----
commit 29614bfa2ef1a3c57412b8148125d43b1911dc43
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-08-27T21:23:29Z

    GROOVY-8303: VerifyError for nested class this call to static method

----
;;;","28/Aug/17 04:19;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/593
;;;",,,,,,,,,,,,,,,,,,,,
Slow Performance Caused by Invoke Dynamic,GROOVY-8298,13097661,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,daniel_sun,jjathman,jjathman,25/Aug/17 17:51,03/May/22 17:26,14/Jul/23 06:02,11/Jan/20 18:12,2.4.12,,,,,,,,3.0.0-rc-3,,,,,,,,0,,,,,,,"I have been researching a problem my application is having where performance seems to be much slower than I would expect. After a lot of research I found GROOVY-6583 which seems to have the same symptoms (though not caused by the same method calls). After more research I found someone who reported a similar issue and created a [sample application|https://github.com/dwclark/deopt-storm] which reproduces the issue. I am seeing the same behavior he discusses which is that using the JIT probe I'm able to see that our production application is constantly uses a large amount of CPU on JIT activities for days on end, it never gets better. 

When doing a thread dump of our application we often see 20-50 threads all stuck on this same stack trace:


{code:none}
""qtp2078714399-360525"": running, holding [771bcf60]
	at java.lang.invoke.MethodHandleNatives.setCallSiteTargetNormal(Native Method)
	at java.lang.invoke.CallSite.setTargetNormal(CallSite.java:258)
	at java.lang.invoke.MutableCallSite.setTarget(MutableCallSite.java:154)
	at org.codehaus.groovy.vmplugin.v7.Selector$MethodSelector.doCallSiteTargetSet(Selector.java:909)
	at org.codehaus.groovy.vmplugin.v7.Selector$MethodSelector.setCallSiteTarget(Selector.java:969)
	at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:228)
	at java.lang.invoke.LambdaForm$DMH/1665404403.invokeStatic_L3IL5_L(LambdaForm$DMH)
	at java.lang.invoke.LambdaForm$BMH/1828868503.reinvoke(LambdaForm$BMH)
	at java.lang.invoke.LambdaForm$reinvoker/1917025677.dontInline(LambdaForm$reinvoker)
	at java.lang.invoke.LambdaForm$MH/462773420.guard(LambdaForm$MH)
	at java.lang.invoke.LambdaForm$MH/1947020920.linkToCallSite(LambdaForm$MH)
{code}


No matter how long the application runs it will continue to show this behavior. From what I've read I think our code causes this problem because we run code that looks like this:

{code:java}
// List of objects will consistent of 2-20 instances of classes 
// which all implement the same interface which defines the runMethod. 
// Each concrete implementation will have it's own unique behavior
def resultList = listOfObjects*.runMethod()
{code}

Turning off invoke dynamic compilation and using the regular groovy-all jar seems to eliminate the issue and result it overall better performance.

It would be nice if Groovy could at least identify this situation and prevent itself from getting in to the de-opt storm.
",,daniel_sun,jjathman,jwagenleitner,lexek,traskstalnaker,,,,"danielsun1106 commented on pull request #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;03/Jan/20 19:52;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570689193
 
 
   @blackdrag 
   Jochen, it would be great if you could review the PR :-)
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;03/Jan/20 20:29;githubbot;600","blackdrag commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570808378
 
 
   Just to be sure I understand the code correctly... We install a CachedCallableCallsite, which will have similar logic to before, meaning we do the normal method selection, then install a method as primary target and if all the guards fail (or all callsites get reset by meta class logic) we fallback to now not a new select, but to another guard that first checks with cacheHits if the cache contains the method and sets the new target in a ThreadLocal. If it exists we use fromCache, which basically gets the handle from the ThreadLocal and in case of a cache miss we do select again, but select will always add the new selections to the cache. To determine if it is a cache hit we use the class name of the receiver. Oh, and select will also (as before) set a new target for the callsite.
   
   Assuming this is correct I do have a few problems with this:
   - you should always have a micro benchmark for this sort of thing. Yes, micro benchmarks are evil, but in this case you are trying to optimize something very small, so it is going to be micro, if not nano. 
   - unless changed ThreadLocal is a performance killer. It introduces a barrier which is preventing method inlining.
   - a call x.foo(y) may add a handle X#foo(Y1) in the cache, but if y changes to Y2 your cache will still return X#foo(Y1), even though y may not be an instance of Y1. You will have to check the argument types. In java and static Groovy the receiver check would be enough, in Groovy (because of double dispatch) not. And of course if X changes to a class of same name but different loader, then the handle for X#foo(Y1) would be invalid as well. 
   
   Let me suggest an alternative approach... if the end up to select the method again, then use old callsite target as fallback for the new handle. That way you create a giant method handle that is the cache, forcing the JVM to optimize the whole thing. Of course there are x more steps to improve that, but it would be a simple start. (we may want to limit the length, reorder according to the number of calls, maybe have some weakly referenced to avoid class unloading issues, and maybe other things, but all that needs a benchmark to go by and prove it is an improvement really) 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/20 18:34;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570811643
 
 
   Jochen, the main idea can be described as the following code:
   
   ```
   if (cacheHits(receiverCassName)) { // Try to find the cached MethodHandle
         // the main logic of `fromCache`
         MethodHandle mh = lruCache.get(receiverCassName); // find the cached MethodHandle again...
         return mh.invokeExact(...);
   } else { // fallback, and put the fallback methodhandle to the inline cache(LRU) for reuse
         // the main logic of `selectMethod`
         Selector selector = Selector.getSelector(...);
         selector.setCallSiteTarget();
         MethodHandle mh = selector.handle.asSpreader(...).asType(...);
         lruCache.put(receiverCassName, mh); // cache the methodhandle 
         return mh.invokeExact(...);
   }
   ```
   
   As the inline cache is implemented as LRU cache, and `cacheHits` and `fromCache` are executed in two steps(not atomic), so if `cacheHits` returns `true`(means cached methodhandle found), `fromCache` find the same cached methodhandle from LRU cache, the result probably is `null` as cached methodhandle may be cleared according to the rule of LRU... I use `ThreadLocal` to avoid the above concurrent issue.
   
   Also, we have inline cache for callsite, so `setTarget` can be avoided, which causes the poor performance as the GROOVY-8298 shown.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/20 19:14;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570811643
 
 
   Jochen, the main idea can be described as the following code:
   
   ```java
   if (cacheHits(receiverCassName)) { // Try to find the cached MethodHandle
         // the main logic of `fromCache`
         MethodHandle mh = lruCache.get(receiverCassName); // find the cached MethodHandle again...
         return mh.invokeExact(...);
   } else { // fallback, and put the fallback methodhandle to the inline cache(LRU) for reuse
         // the main logic of `selectMethod`
         Selector selector = Selector.getSelector(...);
         selector.setCallSiteTarget();
         MethodHandle mh = selector.handle.asSpreader(...).asType(...);
         lruCache.put(receiverCassName, mh); // cache the methodhandle 
         return mh.invokeExact(...);
   }
   ```
   
   As the inline cache is implemented as LRU cache, and `cacheHits` and `fromCache` are executed in two steps(not atomic), so if `cacheHits` returns `true`(means cached methodhandle found), `fromCache` find the same cached methodhandle from LRU cache, the result probably is `null` as cached methodhandle may be cleared according to the rule of LRU... I use `ThreadLocal` to avoid the above concurrent issue.
   
   Also, we have inline cache for callsite, so `setTarget` can be avoided, which causes the poor performance as the GROOVY-8298 shown.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/20 19:15;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570811643
 
 
   Jochen, the main idea can be described as the following code:
   
   ```java
   if (cacheHits(receiverCassName)) { // Try to find the cached MethodHandle
         // the main logic of `fromCache`
         MethodHandle mh = lruCache.get(receiverCassName); // find the cached MethodHandle again...
         return mh.invokeExact(...);
   } else { // fallback, and put the fallback methodhandle to the inline cache(LRU) for reuse
         // the main logic of `selectMethod`
         Selector selector = Selector.getSelector(...);
         selector.setCallSiteTarget();
         MethodHandle mh = selector.handle.asSpreader(...).asType(...);
         lruCache.put(receiverCassName, mh); // cache the methodhandle 
         return mh.invokeExact(...);
   }
   ```
   
   As the inline cache is implemented as LRU cache, and `cacheHits` and `fromCache` are executed in two steps(not atomic), so if `cacheHits` returns `true`(means cached methodhandle found), `fromCache` find the same cached methodhandle from LRU cache again, the result probably is `null` as cached methodhandle may be cleared according to the rule of LRU... I use `ThreadLocal` to avoid the above concurrent issue.
   
   Also, we have inline cache for callsite, so `setTarget` can be avoided, which causes the poor performance as the GROOVY-8298 shown.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/20 19:16;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570811643
 
 
   Jochen, the main idea can be described as the following code:
   
   ```java
   if (cacheHits(receiverCassName)) { // Try to find the cached MethodHandle
         // the main logic of `fromCache`
         MethodHandle mh = lruCache.get(receiverCassName); // find the cached MethodHandle again...
         return mh.invokeExact(...);
   } else { // fallback, and put the fallback methodhandle to the inline cache(LRU) for reuse
         // the main logic of `selectMethod`
         Selector selector = Selector.getSelector(...);
         selector.setCallSiteTarget();
         MethodHandle mh = selector.handle.asSpreader(...).asType(MethodType.methodType(Object.class, Object[].class));
         lruCache.put(receiverCassName, mh); // cache the methodhandle 
         return mh.invokeExact(...);
   }
   ```
   
   As the inline cache is implemented as LRU cache, and `cacheHits` and `fromCache` are executed in two steps(not atomic), so if `cacheHits` returns `true`(means cached methodhandle found), `fromCache` find the same cached methodhandle from LRU cache again, the result probably is `null` as cached methodhandle may be cleared according to the rule of LRU... I use `ThreadLocal` to avoid the above concurrent issue.
   
   >a call x.foo(y) may add a handle X#foo(Y1) in the cache, but if y changes to Y2 your cache will still return X#foo(Y1), even though y may not be an instance of Y1. You will have to check the argument types. 
   
   We cache the methodhandle with method type `MethodType.methodType(Object.class, Object[].class)`, so we will not encounter the issue(the following code runs well) ;-)
   ```groovy
   def same(obj) { return obj }
   [1, 1.0f, '1.0'].each { same(it) }
   ```
   
   Also, we have inline cache for callsite, so `setTarget` can be avoided, which causes the poor performance as the GROOVY-8298 shown.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/20 19:38;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570811643
 
 
   Jochen, the main idea can be described as the following code:
   
   ```java
   if (cacheHits(receiverCassName)) { // Try to find the cached MethodHandle
         // the main logic of `fromCache`
         MethodHandle mh = lruCache.get(receiverCassName); // find the cached MethodHandle again...
         return mh.invokeExact(...);
   } else { // fallback, and put the fallback methodhandle to the inline cache(LRU) for reuse
         // the main logic of `selectMethod`
         Selector selector = Selector.getSelector(...);
         selector.setCallSiteTarget();
         MethodHandle mh = selector.handle.asSpreader(...).asType(MethodType.methodType(Object.class, Object[].class));
         lruCache.put(receiverCassName, mh); // cache the methodhandle 
         return mh.invokeExact(...);
   }
   ```
   
   As the inline cache is implemented as LRU cache, and `cacheHits` and `fromCache` are executed in two steps(not atomic), so if `cacheHits` returns `true`(means cached methodhandle found), `fromCache` find the same cached methodhandle from LRU cache again, the result probably is `null` as cached methodhandle may be cleared according to the rule of LRU... I use `ThreadLocal` to avoid the above concurrent issue.
   
   >a call x.foo(y) may add a handle X#foo(Y1) in the cache, but if y changes to Y2 your cache will still return X#foo(Y1), even though y may not be an instance of Y1. You will have to check the argument types. 
   
   We cache the methodhandle with method type `MethodType.methodType(Object.class, Object[].class)`, so we will not encounter the issue, the following code runs well  ;-)
   ```groovy
   def same(obj) { return obj }
   for (int i = 0; i < 100000; i++) {
       [1, 1.0f, '1.0'].each { same(it) }
   }
   ```
   (before tuning: 9s, after tuning: 6s, on my machine)
   
   ```groovy
   for (int i = 0; i < 100000; i++) {
       [1, 1.0f, '1.0'].each { it.toString() }
   }
   ```
   (before tuning: 6s, after tuning: 2s, on my machine)
   
   More strict performance will be done with JMH, I have no idea how to enable indy for performance tests for now...
   
   Also, we have inline cache for callsite, so `setTarget` can be avoided, which causes the poor performance as the GROOVY-8298 shown.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/20 19:46;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570811643
 
 
   Jochen, the main idea can be described as the following code:
   
   ```java
   if (cacheHits(receiverCassName)) { // Try to find the cached MethodHandle
         // the main logic of `fromCache`
         MethodHandle mh = lruCache.get(receiverCassName); // find the cached MethodHandle again...
         return mh.invokeExact(...);
   } else { // fallback, and put the fallback methodhandle to the inline cache(LRU) for reuse
         // the main logic of `selectMethod`
         Selector selector = Selector.getSelector(...);
         selector.setCallSiteTarget();
         MethodHandle mh = selector.handle.asSpreader(...).asType(MethodType.methodType(Object.class, Object[].class));
         lruCache.put(receiverCassName, mh); // cache the methodhandle 
         return mh.invokeExact(...);
   }
   ```
   
   As the inline cache is implemented as LRU cache, and `cacheHits` and `fromCache` are executed in two steps(not atomic), so if `cacheHits` returns `true`(means cached methodhandle found), `fromCache` find the same cached methodhandle from LRU cache again, the result probably is `null` as cached methodhandle may be cleared according to the rule of LRU... I use `ThreadLocal` to avoid the above concurrent issue.
   
   >a call x.foo(y) may add a handle X#foo(Y1) in the cache, but if y changes to Y2 your cache will still return X#foo(Y1), even though y may not be an instance of Y1. You will have to check the argument types. 
   
   We cache the methodhandle with method type `MethodType.methodType(Object.class, Object[].class)`, so we will not encounter the issue, the following code runs well  ;-)
   ```groovy
   def same(String obj) { return obj }
   def same(int obj) { return obj }
   def same(float obj) { return obj }
   for (int i = 0; i < 100000; i++) {
       [1, 1.0f, '1.0'].each { same(it) }
   }
   ```
   (before tuning: 9s, after tuning: 6s, on my machine)
   
   ```groovy
   for (int i = 0; i < 100000; i++) {
       [1, 1.0f, '1.0'].each { it.toString() }
   }
   ```
   (before tuning: 6s, after tuning: 2s, on my machine)
   
   More strict performance will be done with JMH, I have no idea how to enable indy for performance tests for now...
   
   Also, we have inline cache for callsite, so `setTarget` can be avoided, which causes the poor performance as the GROOVY-8298 shown.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/20 19:50;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570811643
 
 
   Jochen, the main idea can be described as the following code:
   
   ```java
   if (cacheHits(receiverCassName)) { // Try to find the cached MethodHandle
         // the main logic of `fromCache`
         MethodHandle mh = lruCache.get(receiverCassName); // find the cached MethodHandle again...
         return mh.invokeExact(...);
   } else { // fallback, and put the fallback methodhandle to the inline cache(LRU) for reuse
         // the main logic of `selectMethod`
         Selector selector = Selector.getSelector(...);
         selector.setCallSiteTarget();
         MethodHandle mh = selector.handle.asSpreader(...).asType(MethodType.methodType(Object.class, Object[].class));
         lruCache.put(receiverCassName, mh); // cache the methodhandle 
         return mh.invokeExact(...);
   }
   ```
   
   As the inline cache is implemented as LRU cache, and `cacheHits` and `fromCache` are executed in two steps(not atomic), so if `cacheHits` returns `true`(means cached methodhandle found), `fromCache` find the same cached methodhandle from LRU cache again, the result probably is `null` as cached methodhandle may be cleared according to the rule of LRU... I use `ThreadLocal` to avoid the above concurrent issue.
   
   Also, we have the inline cache for callsite, so `setTarget` can be avoided, which causes the poor performance as the GROOVY-8298 shown.
   
   >a call x.foo(y) may add a handle X#foo(Y1) in the cache, but if y changes to Y2 your cache will still return X#foo(Y1), even though y may not be an instance of Y1. You will have to check the argument types. 
   
   We cache the methodhandle with method type `MethodType.methodType(Object.class, Object[].class)`, so we will not encounter the issue, the following code runs well  ;-)
   ```groovy
   def same(String obj) { return obj }
   def same(int obj) { return obj }
   def same(float obj) { return obj }
   for (int i = 0; i < 100000; i++) {
       [1, 1.0f, '1.0'].each { same(it) }
   }
   ```
   (before tuning: 9s, after tuning: 6s, on my machine)
   
   ```groovy
   for (int i = 0; i < 100000; i++) {
       [1, 1.0f, '1.0'].each { it.toString() }
   }
   ```
   (before tuning: 6s, after tuning: 2s, on my machine)
   
   More strict performance will be done with JMH, I have no idea how to enable indy for performance tests for now...
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/20 20:04;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570811643
 
 
   Jochen, the main idea can be described as the following code:
   
   ```java
   if (cacheHits(receiverCassName)) { // Try to find the cached MethodHandle
         // the main logic of `fromCache`
         MethodHandle mh = lruCache.get(receiverCassName); // find the cached MethodHandle again...
         return mh.invokeExact(...);
   } else { // fallback, and put the fallback methodhandle to the inline cache(LRU) for reuse
         // the main logic of `selectMethod`
         Selector selector = Selector.getSelector(...);
         selector.setCallSiteTarget();
         MethodHandle mh = selector.handle.asSpreader(...).asType(MethodType.methodType(Object.class, Object[].class));
         lruCache.put(receiverCassName, mh); // cache the methodhandle 
         return mh.invokeExact(...);
   }
   ```
   
   As the inline cache is implemented as LRU cache, and `cacheHits` and `fromCache` are executed in two steps(not atomic), so if `cacheHits` returns `true`(means cached methodhandle found), `fromCache` find the same cached methodhandle from LRU cache again, the result probably is `null` as cached methodhandle may be cleared according to the rule of LRU... I use `ThreadLocal` to avoid the above concurrent issue.
   
   Also, we have the inline cache for callsite, so `setTarget` can be avoided, which causes the poor performance as the GROOVY-8298 shown.
   
   >a call x.foo(y) may add a handle X#foo(Y1) in the cache, but if y changes to Y2 your cache will still return X#foo(Y1), even though y may not be an instance of Y1. You will have to check the argument types. 
   
   We cache the methodhandle with method type `MethodType.methodType(Object.class, Object[].class)`, so we will not encounter the issue, the following code runs well  ;-)
   ```groovy
   def same(String obj) { return obj }
   def same(int obj) { return obj }
   def same(float obj) { return obj }
   for (int i = 0; i < 100000; i++) {
       [1, 1.0f, '1.0'].each { same(it) }
   }
   ```
   (before tuning: 9s, after tuning: 6s, on my machine)
   
   ```groovy
   for (int i = 0; i < 100000; i++) {
       [1, 1.0f, '1.0'].each { it.toString() }
   }
   ```
   (before tuning: 6s, after tuning: 2s, on my machine)
   
   More strict performance tests will be done with JMH, I have no idea how to enable indy for performance tests for now...
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/20 20:15;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570811643
 
 
   Jochen, the main idea can be described as the following simplified code:
   
   ```java
   if (cacheHits(receiverCassName)) { // Try to find the cached MethodHandle
         // the main logic of `fromCache`
         MethodHandle mh = lruCache.get(receiverCassName); // find the cached MethodHandle again...
         return mh.invokeExact(...);
   } else { // fallback, and put the fallback methodhandle to the inline cache(LRU) for reuse
         // the main logic of `selectMethod`
         Selector selector = Selector.getSelector(...);
         selector.setCallSiteTarget();
         MethodHandle mh = selector.handle.asSpreader(...).asType(MethodType.methodType(Object.class, Object[].class));
         lruCache.put(receiverCassName, mh); // cache the methodhandle 
         return mh.invokeExact(...);
   }
   ```
   
   As the inline cache is implemented as LRU cache, and `cacheHits` and `fromCache` are executed in two steps(not atomic), so if `cacheHits` returns `true`(means cached methodhandle found), `fromCache` find the same cached methodhandle from LRU cache again, the result probably is `null` as cached methodhandle may be cleared according to the rule of LRU... I use `ThreadLocal` to avoid the above concurrent issue.
   
   Also, we have the inline cache for callsite, so `setTarget` can be avoided, which causes the poor performance as the GROOVY-8298 shown.
   
   >a call x.foo(y) may add a handle X#foo(Y1) in the cache, but if y changes to Y2 your cache will still return X#foo(Y1), even though y may not be an instance of Y1. You will have to check the argument types. 
   
   We cache the methodhandle with method type `MethodType.methodType(Object.class, Object[].class)`, so we will not encounter the issue, the following code runs well  ;-)
   ```groovy
   def same(String obj) { return obj }
   def same(int obj) { return obj }
   def same(float obj) { return obj }
   for (int i = 0; i < 100000; i++) {
       [1, 1.0f, '1.0'].each { same(it) }
   }
   ```
   (before tuning: 9s, after tuning: 6s, on my machine)
   
   ```groovy
   for (int i = 0; i < 100000; i++) {
       [1, 1.0f, '1.0'].each { it.toString() }
   }
   ```
   (before tuning: 6s, after tuning: 2s, on my machine)
   
   More strict performance tests will be done with JMH, I have no idea how to enable indy for performance tests for now...
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/20 20:54;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570811643
 
 
   Jochen, you got the point ;-) The main idea can be described as the following simplified code:
   
   ```java
   if (cacheHits(receiverCassName)) { // Try to find the cached MethodHandle
         // the main logic of `fromCache`
         MethodHandle mh = lruCache.get(receiverCassName); // find the cached MethodHandle again...
         return mh.invokeExact(...);
   } else { // fallback, and put the fallback methodhandle to the inline cache(LRU) for reuse
         // the main logic of `selectMethod`
         Selector selector = Selector.getSelector(...);
         selector.setCallSiteTarget();
         MethodHandle mh = selector.handle.asSpreader(...).asType(MethodType.methodType(Object.class, Object[].class));
         lruCache.put(receiverCassName, mh); // cache the methodhandle 
         return mh.invokeExact(...);
   }
   ```
   
   As the inline cache is implemented as LRU cache, and `cacheHits` and `fromCache` are executed in two steps(not atomic), so if `cacheHits` returns `true`(means cached methodhandle found), `fromCache` find the same cached methodhandle from LRU cache again, the result probably is `null` as cached methodhandle may be cleared according to the rule of LRU... I use `ThreadLocal` to avoid the above concurrent issue.
   
   Also, we have the inline cache for callsite, so `setTarget` can be avoided, which causes the poor performance as the GROOVY-8298 shown.
   
   >a call x.foo(y) may add a handle X#foo(Y1) in the cache, but if y changes to Y2 your cache will still return X#foo(Y1), even though y may not be an instance of Y1. You will have to check the argument types. 
   
   We cache the methodhandle with method type `MethodType.methodType(Object.class, Object[].class)`, so we will not encounter the issue, the following code runs well  ;-)
   ```groovy
   def same(String obj) { return obj }
   def same(int obj) { return obj }
   def same(float obj) { return obj }
   for (int i = 0; i < 100000; i++) {
       [1, 1.0f, '1.0'].each { same(it) }
   }
   ```
   (before tuning: 9s, after tuning: 6s, on my machine)
   
   ```groovy
   for (int i = 0; i < 100000; i++) {
       [1, 1.0f, '1.0'].each { it.toString() }
   }
   ```
   (before tuning: 6s, after tuning: 2s, on my machine)
   
   More strict performance tests will be done with JMH, I have no idea how to enable indy for performance tests for now...
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/20 20:58;githubbot;600","blackdrag commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570829416
 
 
   frankly I think I am missing something completely right now. You say setTarget is causing the bad performance... there is a hit involved with that yes, but in my experience creating all those MethodTypes is just as bad. Maybe that part got improved. In my opinion your implementation should be much slower now for the regular case... Especially you hitting the cache every time should cause some bad effects... I guess there is only testing.. then let us call cs the normal groovy callsite caching as we have, indy1 the current indy on master, indy2 master with your changes including the removal of the ThreadLocal. Also better would be to run multiple times and only get the best ones (using java11u28)
   
   ```Java
   def m(i){1}
   for (int i = 0; i < 100_000_000; i++) {
    if (m(i)!=1) throw new Error(""??"")
   }
   ```
   I run this up to 20 times to get the best stable time
   CS: ~510ms
   indy1: ~256ms
   indy2: ~12680ms
   
   which more or less shows what I expected. The effect of indy1 being faster than CS, is because the JVM actually has more options to optimize in indy and the guards here are very simple. With more parameters in the call indy would loose performance compared to CS. For indy2 I did expect it to be worse than indy1, but actually not that much. On the other hand I was already expecting form the code, that going to the cache every time is going to hurt.
   
   ```Java
   def same(String obj) { return obj }
   def same(int obj) { return obj }
   def same(float obj) { return obj }
   for (int i = 0; i < 100_000; i++) {
       [1, 1.0f, '1.0'].each { same(it) }
   }
   ```
   CS: ~64ms
   indy1: ~2250ms
   indy2: ~2000ms
   
   This was the case I was really curious about. There is an improvement, but too small yet. So I did an experiment... 
   ```diff
   @@ -883,7 +884,7 @@ public abstract class Selector {
                if (handle == null) return;
                if (!cache) return;
    
   -            MethodHandle fallback = makeFallBack(callSite, sender, name, callType.ordinal(), targetType, safeNavigationOrig, thisCall, spread);
   +            MethodHandle fallback = callSite.getTarget();
    
                // special guards for receiver
                if (receiver instanceof GroovyObject) {
   ```
   which means instead of always falling back to the select method I instead reuse the existing handle in the callsite as fallback. That means, that each select call will cause a bigger handle, the newest on top, having the older as fallback. If I then have a callsite [1, 1.0f, '1.0'].each { same(it) } I will get a one handle for the string, which falls back to the float, which falls back to the int, which falls back to the select method. I did not test this for being correct or anything, and even if correct it is still having overhead it does not need, but well... let's compare...
   
   In the first test the performance of my version and the old indy version are about the same, because the handle, that is produced is the same. Anything else would have been strange. In the second test I get 65ms, so roughly the same as CS. Sure, there may be a deopt because of setTarget, which happens in the inner loop 3 times. But after that the callsite is stable and has still 99999 iterations to run and optimize.
   
   I was wondering why your versions is so extremely slow and I think it is because of the receiver based cache you use. Sure you cache the handle, but the key is the receiver.
   ```Java
   for (int i = 0; i < 1_000_000; i++) {
       [1, 1.0f, '1.0'].each { it.toString() }
   }
   ```
   In this variant the receiver will change, giving your caching a chance to actually do its work and not fail with cache misses all the time
   
   CS: ~770ms
   indy1: ~14600ms (I stopped after 4 iterations)
   indy2:  ~639ms
   indy3:  ~215ms
   (static compiled Groovy: ~110ms)
   
   Here I can see your factor 3 you talked about earlier. And the indy3 version shows that there is even more to gain.
   
   One last case I´d like to showcase
   ```Java
   class Cat {
     static m(Script s){println ""x""}
   }
   def m(){}
   
   for (int i = 0; i < 100_000; i++) {
     use(Cat) {
        m()
     }
   }
   ```
   In this version we have an category active. This category is not even going to be used, but the effect is really bad:
   
   CS: starts with ~180ms, ends with ~2000ms
   indy1: starts with ~2500ms, ends with ~7000ms
   indy2: starts with ~2300ms, ends with ~6650ms
   indy3: StackOverflowError
   
   I consider indy1 and indy2 being about equal here, but you may ask why there is a StackOverflowError for indy3. That is because at least one of the guards (I think it is the exception guard, which also degrades performance a lot) causes additional stack usage. That is already the case for the handle we produce in the selector. Older versions of Java did still show this, it seems in Java11 this is now hidden... well.. considering https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8016334 this is the case for a much longer time, but with -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames you can make them visible again:
   ```
   	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1027)
   	at java.base/java.lang.invoke.LambdaForm$DMH/0x00000008002a4440.invokeInterface(LambdaForm$DMH:1000029)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bf040.invoke(LambdaForm$MH:1000027)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002be840.invoke(LambdaForm$MH:1000059)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002be040.guardWithCatch(LambdaForm$MH:1000040)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bc840.invoke(LambdaForm$MH:1000113)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002b4840.invokeExact_MT(LambdaForm$MH:1000019)
   	at org.codehaus.groovy.vmplugin.v7.IndyInterface.selectMethod(IndyInterface.java:232)
   	at java.base/java.lang.invoke.LambdaForm$DMH/0x0000000800294840.invokeStatic(LambdaForm$DMH:1000026)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bfc40.invoke(LambdaForm$MH:1000094)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000094)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000094)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000094)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000094)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000094)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000094)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000094)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000094)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000094)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000094)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bd840.reinvoke(LambdaForm$MH:1000020)
   	at java.base/java.lang.invoke.LambdaForm$MH/0x00000008002bdc40.guard(LambdaForm$MH:1000074)
   	at java.base/java.lang.invoke.Invokers$Holder.linkToCallSite(Invokers$Holder:1000014)
   	at simple5$_run_closure1.doCall(simple5.groovy:11)
   ```
   This part of the tracer is from indy in master -  the indy3 version is really really big. What is most likely happening though is that the handle is grown for each method call. So I think it is an actual bug in the indy3 version, but I did not claim it is production ready code either ;)
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;04/Jan/20 23:35;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570900509
 
 
   Jochen, as you found, the regular case the most inefficient one. So in the latest commit I introduce a threshold to control whether to set target.
   ```groovy
   def m(i){1}
   for (int i = 0; i < 100_000_000; i++) {
    if (m(i)!=1) throw new Error(""??"")
   }
   ```
   (indy2: before commit 6092c76: **15s**, after commit 6092c76(threshold: 100_000): **3s**, indy1: **3s**. indy2 costs almost same time to indy1 on my machine)
   
   Please review the PR again, thanks :-)
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;05/Jan/20 11:03;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570900509
 
 
   Jochen, as you found, the regular case is the most inefficient one. So in the latest commit I introduce a threshold to control whether to set target.
   ```groovy
   def m(i){1}
   for (int i = 0; i < 100_000_000; i++) {
    if (m(i)!=1) throw new Error(""??"")
   }
   ```
   (indy2: before commit 6092c76: **15s**, after commit 6092c76(threshold: 100_000): **3s**, indy1: **3s**. indy2 costs almost same time to indy1 on my machine)
   
   Please review the PR again, thanks :-)
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;05/Jan/20 11:10;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570900509
 
 
   Jochen, as you found, the regular case is the most inefficient one. So in the latest commit I introduce a threshold to control whether to set target.
   ```groovy
   def m(i){1}
   for (int i = 0; i < 100_000_000; i++) {
    if (m(i)!=1) throw new Error(""??"")
   }
   ```
   (indy2: before commit 6092c76: **15s**, after commit 6092c76(threshold: 100_000): **3s**, indy1: **3s**, CS: **3s**. indy2 costs almost same time to indy1 on my machine)
   
   ```groovy
   class Cat {
     static m(Script s){println ""x""}
   }
   def m(){}
   
   for (int i = 0; i < 100_000; i++) {
     use(Cat) {
        m()
     }
   }
   ```
   (indy2: **7s**, indy1: **8s**, CS: **4s**)
   
   Please review the PR again, thanks :-)
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;05/Jan/20 11:18;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570900509
 
 
   Jochen, as you found, the regular case is the most inefficient one. So in the latest commit I introduce a threshold to control whether to set target.
   ```groovy
   def m(i){1}
   for (int i = 0; i < 100_000_000; i++) {
    if (m(i)!=1) throw new Error(""??"")
   }
   ```
   (indy2: before commit 6092c76: **15s**, after commit 6092c76(threshold: 100_000): **3s**; indy1: **3s**; CS: **3s**. indy2 costs almost same time to indy1 on my machine)
   
   ```groovy
   class Cat {
     static m(Script s){println ""x""}
   }
   def m(){}
   
   for (int i = 0; i < 100_000; i++) {
     use(Cat) {
        m()
     }
   }
   ```
   (indy2: **7s**; indy1: **8s**; CS: **4s**)
   
   Please review the PR again, thanks :-)
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;05/Jan/20 11:22;githubbot;600","blackdrag commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570908249
 
 
   @danielsun1106 which version of Java are you using for your tests? In my test CS was slower for the first case than indy1, in your comment they have equal speed. 
   
   As for the category case I think this should be kept outside for now. they require special treatment, as I think even the times in CS are not acceptable.. I mean compare with case one... that is 100 million calls in 500ms and the category is 100k calls in 4000ms, interpolated than 4 million ms - that is a factor of 8000.
   
   Measuring.... Case 1 now like indy1, as you have. Case2, with the different arguments, is now at 1290ms compared to before 2000ms. Case3, with the different receivers, is now at 540ms, so like 50% improvement. But if you check how often setTarget is called on the callsite even with a threshold of 0 you will see that there must be something wrong in the implementation.
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;05/Jan/20 12:34;githubbot;600","blackdrag commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570908249
 
 
   @danielsun1106 which version of Java are you using for your tests? In my test CS was slower for the first case than indy1, in your comment they have equal speed. 
   
   As for the category case I think this should be kept outside for now. they require special treatment, as I think even the times in CS are not acceptable.. I mean compare with case one... that is 100 million calls in 500ms and the category is 100k calls in 4000ms, interpolated then 4 million ms for 100 million calls - that is a factor of 8000.
   
   Measuring.... Case 1 now like indy1, as you have. Case2, with the different arguments, is now at 1290ms compared to before 2000ms. Case3, with the different receivers, is now at 540ms, so like 50% improvement. But if you check how often setTarget is called on the callsite even with a threshold of 0 you will see that there must be something wrong in the implementation.
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;05/Jan/20 12:35;githubbot;600","blackdrag commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570908249
 
 
   @danielsun1106 which version of Java are you using for your tests? In my test CS was slower for the first case than indy1, in your comment they have equal speed. 
   
   As for the category case I think this should be kept outside for now. they require special treatment, as I think even the times in CS are not acceptable.. I mean compare with case one... that is 100 million calls in 500ms and the category is 100k calls in 4000ms, interpolated then 4 million ms for 100 million calls - that is a factor of 8000.
   
   Measuring.... Case 1 is now like indy1, as you have. Case2, with the different arguments, is now at 1290ms compared to before 2000ms. Case3, with the different receivers, is now at 540ms, so like 50% improvement. But if you check how often setTarget is called on the callsite even with a threshold of 0 you will see that there must be something wrong in the implementation.
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;05/Jan/20 12:36;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570908778
 
 
   Jochen, I'm using the JDK 11:
   ```
   C:\Users\Daniel.LAPTOP-H7RKNSIS>java -version
   openjdk version ""11.0.5"" 2019-10-15 LTS
   OpenJDK Runtime Environment Corretto-11.0.5.10.1 (build 11.0.5+10-LTS)
   OpenJDK 64-Bit Server VM Corretto-11.0.5.10.1 (build 11.0.5+10-LTS, mixed mode)
   ```
   >But if you check how often setTarget is called on the callsite even with a threshold of 0 you will see that there must be something wrong in the implementation.
   
   OK. I'll look into the issue later. 
   
   Thanks for your reviewing again ;-)
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;05/Jan/20 12:40;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570964021
 
 
   @blackdrag 
   Jochen, `setTarget` is executed twice when `threshold` is `0`: one for `next`(i.e. i++) and another for `m(i)`, so it's correct ;-)
   
   ```groovy
   def m(i){1}
   for (int i = 0; i < 100_000_000; i++) {
       if (m(i)!=1) throw new Error(""??"")
   }
   ```
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;06/Jan/20 00:21;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570983832
 
 
   Here is an edge case: we set `groovy.indy.optimize.threshold` to `0`, and the target of callsite `toString` will be set because the threshold(`0`) reaches. The newly set target is not good for polymorfic calls(the subsequent calls when `i >= 10`), so when fallback count reaches threshold, we will reset to the `fromCache` target, i.e. the default target.
   ```groovy
   for (int i = 0; i < 1_000_000; i++) {
       [1, 2.0f, '3.0'].each {
           if (1 != it && i < 10) return
           
           it.toString() 
       }
   }
   ```
   (indy2(after d799d22, `groovy.indy.optimize.threshold`: `0`): **3s**; indy2(before d799d22, `groovy.indy.optimize.threshold`: `0`): **12s**; indy1: **27s**; CS: **4s** on my another machine)
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;06/Jan/20 02:51;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570983832
 
 
   Here is an edge case: we set `groovy.indy.optimize.threshold` to `0`, and the target of callsite `toString` will be set because the threshold(`0`) reaches. The newly set target is not good for polymorfic calls(the subsequent calls when `i >= 10`), so when fallback count reaches threshold, we will reset to the `fromCache` target, i.e. the default target.
   ```groovy
   for (int i = 0; i < 1_000_000; i++) {
       [1, 2.0f, '3.0'].each {
           if (1 != it && i < 10) return
           
           it.toString() 
       }
   }
   ```
   (indy2(after d799d22, `groovy.indy.optimize.threshold`: `0`): **3s**; indy2(before d799d22, `groovy.indy.optimize.threshold`: `0`): **12s**; indy1: **27s**; CS: **4s**; on my another machine)
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;06/Jan/20 02:53;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-570983832
 
 
   Here is an edge case: we set `groovy.indy.optimize.threshold` to `0` at first, so the target of callsite `toString` will be set because the threshold(`0`) reaches. The newly set target is not good for polymorfic calls(the subsequent calls when `i >= 10`), so when fallback count reaches threshold, we will reset to the `fromCache` target, i.e. the default target.
   ```groovy
   for (int i = 0; i < 1_000_000; i++) {
       [1, 2.0f, '3.0'].each {
           if (1 != it && i < 10) return
           
           it.toString() 
       }
   }
   ```
   (indy2(after d799d22, `groovy.indy.optimize.threshold`: `0`): **3s**; indy2(before d799d22, `groovy.indy.optimize.threshold`: `0`): **12s**; indy1: **27s**; CS: **4s**; on my another machine)
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;06/Jan/20 10:42;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-571961230
 
 
   @blackdrag 
   Jochen, I measured the performance of cs, indy1 and indy2 with JMH ( https://github.com/danielsun1106/benchmark-labs ), the result is shown as follows.
   As we can see, the performance of indy2 is improved a lot:
   
   Benchmark |indy2 VS indy1 | indy2 VS cs
   ---- | ---- | ----
   CallsiteBench.dispatch_megamorphic | 3675% | 25.83%
   CallsiteBench.dispatch_monomorphic | 5.72% | 188.62%
   CallsiteBench.dispatch_polymorphic | 3000% | _-17.11%_
   
   **indy2:**
   ```
   Benchmark                            Mode  Cnt     Score    Error   Units
   CallsiteBench.dispatch_megamorphic  thrpt   15   151.552 ±  2.157  ops/ms
   CallsiteBench.dispatch_monomorphic  thrpt   15  4768.491 ± 41.386  ops/ms
   CallsiteBench.dispatch_polymorphic  thrpt   15   155.040 ±  7.380  ops/ms
   ```
   
   **indy1:**
   ```
   Benchmark                            Mode  Cnt     Score    Error   Units
   CallsiteBench.dispatch_megamorphic  thrpt   15     3.914 ±  0.462  ops/ms
   CallsiteBench.dispatch_monomorphic  thrpt   15  4510.525 ± 46.702  ops/ms
   CallsiteBench.dispatch_polymorphic  thrpt   15     5.283 ±  0.325  ops/ms
   ```
   
   **cs:**
   ```
   Benchmark                            Mode  Cnt     Score    Error   Units
   CallsiteBench.dispatch_megamorphic  thrpt   15   119.447 ± 45.829  ops/ms
   CallsiteBench.dispatch_monomorphic  thrpt   15  1651.584 ± 39.724  ops/ms
   CallsiteBench.dispatch_polymorphic  thrpt   15   186.763 ± 14.549  ops/ms
   ```
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jan/20 09:20;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-571961230
 
 
   @blackdrag 
   Jochen, I measured the performance of cs, indy1 and indy2 with JMH ( https://github.com/danielsun1106/benchmark-labs ), the result is shown as follows.
   As we can see, the performance of indy2 is improved a lot:
   
   Benchmark |indy2 VS indy1 | indy2 VS cs
   ---- | ---- | ----
   CallsiteBench.dispatch_megamorphic | 3675% | 25.83%
   CallsiteBench.dispatch_monomorphic | 5.72% | 188.62%
   CallsiteBench.dispatch_polymorphic | 3000% | _-17.11%_
   
   (Note: the benchmark mode is throughput, so the higher the score is, the better performance will be)
   
   **indy2:**
   ```
   Benchmark                            Mode  Cnt     Score    Error   Units
   CallsiteBench.dispatch_megamorphic  thrpt   15   151.552 ±  2.157  ops/ms
   CallsiteBench.dispatch_monomorphic  thrpt   15  4768.491 ± 41.386  ops/ms
   CallsiteBench.dispatch_polymorphic  thrpt   15   155.040 ±  7.380  ops/ms
   ```
   
   **indy1:**
   ```
   Benchmark                            Mode  Cnt     Score    Error   Units
   CallsiteBench.dispatch_megamorphic  thrpt   15     3.914 ±  0.462  ops/ms
   CallsiteBench.dispatch_monomorphic  thrpt   15  4510.525 ± 46.702  ops/ms
   CallsiteBench.dispatch_polymorphic  thrpt   15     5.283 ±  0.325  ops/ms
   ```
   
   **cs:**
   ```
   Benchmark                            Mode  Cnt     Score    Error   Units
   CallsiteBench.dispatch_megamorphic  thrpt   15   119.447 ± 45.829  ops/ms
   CallsiteBench.dispatch_monomorphic  thrpt   15  1651.584 ± 39.724  ops/ms
   CallsiteBench.dispatch_polymorphic  thrpt   15   186.763 ± 14.549  ops/ms
   ```
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jan/20 10:00;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-571961230
 
 
   @blackdrag 
   Jochen, I measured the performance of cs, indy1 and indy2 with JMH ( https://github.com/danielsun1106/benchmark-labs ), the result is shown as follows.
   As we can see, the performance of indy2 is improved a lot:
   
   Benchmark |indy2 VS indy1 | indy2 VS cs
   ---- | ---- | ----
   CallsiteBench.dispatch_megamorphic | 3675% | 25.83%
   CallsiteBench.dispatch_monomorphic | 5.72% | 188.62%
   CallsiteBench.dispatch_polymorphic | 3000% | _-17.11%_
   
   The following tables show the detailed result(Note: the benchmark mode is throughput, so the higher the `Score` is, the better performance will be):
   
   **indy2:**
   ```
   Benchmark                            Mode  Cnt     Score    Error   Units
   CallsiteBench.dispatch_megamorphic  thrpt   15   151.552 ±  2.157  ops/ms
   CallsiteBench.dispatch_monomorphic  thrpt   15  4768.491 ± 41.386  ops/ms
   CallsiteBench.dispatch_polymorphic  thrpt   15   155.040 ±  7.380  ops/ms
   ```
   
   **indy1:**
   ```
   Benchmark                            Mode  Cnt     Score    Error   Units
   CallsiteBench.dispatch_megamorphic  thrpt   15     3.914 ±  0.462  ops/ms
   CallsiteBench.dispatch_monomorphic  thrpt   15  4510.525 ± 46.702  ops/ms
   CallsiteBench.dispatch_polymorphic  thrpt   15     5.283 ±  0.325  ops/ms
   ```
   
   **cs:**
   ```
   Benchmark                            Mode  Cnt     Score    Error   Units
   CallsiteBench.dispatch_megamorphic  thrpt   15   119.447 ± 45.829  ops/ms
   CallsiteBench.dispatch_monomorphic  thrpt   15  1651.584 ± 39.724  ops/ms
   CallsiteBench.dispatch_polymorphic  thrpt   15   186.763 ± 14.549  ops/ms
   ```
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jan/20 10:02;githubbot;600","blackdrag commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-572151846
 
 
   It is simple: your approach is faster than the old one without adding a lot of complicated code. Go for it.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jan/20 16:36;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-572156808
 
 
   @blackdrag
   Jochen, the benchmark test code is borrowed from groovy project, I will add more test cases ;-)
   As for the complicated code, if you could give me  some suggestion, it would be great.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jan/20 16:48;githubbot;600","paulk-asert commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-572418425
 
 
   +1
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Jan/20 06:53;githubbot;600","asfgit commented on pull request #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;11/Jan/20 01:59;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-574100086
 
 
   I picked the fastest result of the different version of Groovy
   indy2: 4693ms; indy1: 5268ms; cs: 6007ms
   
   **indy2 vs indy1:** 10.91% time reduced
   **indy2 vs cs:** 21.87% time reduced
   
   ```groovy
           final Random random = new Random()
           final int limit = 1_000_000
           
           def factorial
           factorial = { n, acc = 1G -> 1 >= n ? acc : factorial(n - 1, acc * n ) }
   
           for (int i = 0; i < limit; i++) {
               factorial(30 + random.nextInt(5))
           }
   ```
   (Copied from https://e.printstacktrace.blog/groovy-trampoline-closure-a-step-into-recursive-closures/)
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;14/Jan/20 10:10;githubbot;600","danielsun1106 commented on issue #1135: GROOVY-8298: Slow Performance Caused by Invoke Dynamic
URL: https://github.com/apache/groovy/pull/1135#issuecomment-574100086
 
 
   I picked the fastest results of the different versions of Groovy
   indy2: 4693ms; indy1: 5268ms; cs: 6007ms
   
   **indy2 vs indy1:** 10.91% time reduced
   **indy2 vs cs:** 21.87% time reduced
   
   ```groovy
           final Random random = new Random()
           final int limit = 1_000_000
           
           def factorial
           factorial = { n, acc = 1G -> 1 >= n ? acc : factorial(n - 1, acc * n ) }
   
           for (int i = 0; i < limit; i++) {
               factorial(30 + random.nextInt(5))
           }
   ```
   (Copied from https://e.printstacktrace.blog/groovy-trampoline-closure-a-step-into-recursive-closures/)
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;14/Jan/20 10:10;githubbot;600",,0,21000,,,0,21000,,,,,,,,,GROOVY-10535,GROOVY-10596,,,GROOVY-8057,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 03 20:01:39 UTC 2020,,,,,,,,,,"0|i3jasf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Aug/17 19:53;jwagenleitner;I have seen the problem and have recently added a [callsite benchmark test|https://github.com/apache/groovy/blob/482e8d3699e5593a60cc8db5523895fbf7235367/subprojects/performance/src/jmh/java/org/apache/groovy/bench/dispatch/CallsiteBench.java] that shows indy's performance issue with poly and mega morphic calls.  Currently each time a new receiver is found at a callsite it is relinked.

{quote}It would be nice if Groovy could at least identify this situation and prevent itself from getting in to the de-opt storm.{quote}

I think a PIC is needed in order to improve performance in this situation.  [~blackdrag] might be able to correct me if I'm wrong about Groovy currently having a single inline cache.;;;","21/Mar/18 20:04;jjathman;Any thoughts on this one? It makes me nervous that just turning on invoke dynamic causes this severe of a problem, especially since it is so difficult to troubleshoot.;;;","13/Feb/19 19:38;jjathman;I was just reading how Groovy 3 will default to use invoke dynamic support. I think this issue is still a problem. I’m concerned many more people will run in to this issue after the conversion. ;;;","17/Feb/19 07:59;daniel_sun;FYI. 
Jochen discussed the performance issue of indy in the JVM Language group, but no one gave the final solution...

https://groups.google.com/forum/m/#!topic/jvm-languages/aXH7RwoLIqQ;;;","17/Feb/19 08:04;daniel_sun;Here is a bug report related to the performance issue:
https://bugs.openjdk.java.net/browse/JDK-8151981

Maybe we have to find a solution to workaround the bug, e.g. avoid invoking {{MethodHandleNatives.setCallSiteTargetNormal}} as possible as we can(even if intermediate invoking)...
;;;","04/May/19 15:33;daniel_sun;[https://stackoverflow.com/questions/29812958/execution-of-bubble-sort-is-5-times-slower-with-indy]

[~blackdrag] said:
{quote}The answer is easy actually quite easy, Groovy does not have a PIC yet.

... or you can say that we usually have an inline cache of size 1. This means every time you change the list array type, it will invalidate all caches that did exist before and the cached version is thrown away. That is for normal Groovy almost the same as for indy, only that normal Groovy uses runtime generated classes and indy uses invokedynamic/lambda forms. But lambda forms are initially slower, while peak performance is better. Basically what you do is let hotspot start from scratch for most of the method calls, preventing it to apply the optimizations all the time. Of course that is not your fault, but the fault of Groovy for not having a PIC yet. and just to make this very clear... this is no problem of the language, it is simply something I did not yet get to implement.

JRuby on the other hand has a PIC and thus has not to suffer from the overhead of creating new method handles all the time.
{quote};;;","03/Jan/20 20:01;daniel_sun;Here is the PR to implement inline cache for Indy callsite: https://github.com/apache/groovy/pull/1135

I tested the performance against the PR by simply running the following code, and got the time consumed:

Legacy callsite cache: 2s
Indy callsite: 6s
Indy callsite with inline cache: 2s

{code:java}
            for (int i = 0; i < 100000; i++) {
                [1, 1.0f, '1.0'].each { it.toString() }
            }
{code}

P.S. I will try to run the performance tests created by [~jwagenleitner] later.
;;;",,,,,,,,,,,,,,,
Groovydoc Recognition exception with Java 8 class,GROOVY-8296,13097424,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,Schlogen,Schlogen,24/Aug/17 20:34,27/Jan/20 00:44,14/Jul/23 06:02,11/Jan/20 18:17,2.4.12,,,,,,,,3.0.0-rc-3,,,,GroovyDoc,,,,0,,,,,,,"The following class results in an error with groovy doc:

https://github.com/grails/gorm-graphql/blob/12e38e83042a1804b1fa55291841cd510cccab9d/core/src/main/groovy/org/grails/gorm/graphql/entity/EntityFetchOptions.java

{{ERROR [org.codehaus.groovy.tools.groovydoc.GroovyRootDocBuilder] ignored due to RecognitionException: org/grails/gorm/graphql/entity/EntityFetchOptions.java [expecting EOF, found 'joinProperties']}}
",,daniel_sun,Schlogen,,,,,,,"paulk-asert commented on pull request #1137: GROOVY-8296: Groovydoc Recognition exception with Java 8 class
URL: https://github.com/apache/groovy/pull/1137
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jan/20 14:00;githubbot;600","danielsun1106 commented on issue #1137: GROOVY-8296: Groovydoc Recognition exception with Java 8 class
URL: https://github.com/apache/groovy/pull/1137#issuecomment-573067881
 
 
   +1
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jan/20 14:57;githubbot;600","PascalSchumacher commented on pull request #1137: GROOVY-8296: Groovydoc Recognition exception with Java 8 class
URL: https://github.com/apache/groovy/pull/1137#discussion_r365282720
 
 

 ##########
 File path: subprojects/groovy-templates/src/main/groovy/groovy/text/GStringTemplateEngine.java
 ##########
 @@ -199,6 +199,7 @@ public Object run() {
             try {
                 groovyClass = loader.parseClass(new GroovyCodeSource(templateExpressions.toString(), ""GStringTemplateScript"" + counter.incrementAndGet() + "".groovy"", ""x""));
             } catch (Exception e) {
+                System.err.println(""templateExpressions = "" + templateExpressions);
 
 Review comment:
   I guess this line should be reverted?
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jan/20 15:17;githubbot;600","danielsun1106 commented on pull request #1137: GROOVY-8296: Groovydoc Recognition exception with Java 8 class
URL: https://github.com/apache/groovy/pull/1137#discussion_r365317148
 
 

 ##########
 File path: subprojects/groovy-groovydoc/src/main/java/org/apache/groovy/antlr/GroovydocVisitor.java
 ##########
 @@ -78,7 +86,15 @@ protected SourceUnit getSourceUnit() {
 
     @Override
     public void visitClass(ClassNode node) {
-        List<String> imports = node.getModule().getImports().stream().map(ImportNode::getClassName).collect(Collectors.toList());
+        final Map<String, String> aliases = new HashMap<>();
+        final List<String> imports = new ArrayList<>();
+        for (ImportNode iNode : node.getModule().getImports()) {
+            String name = iNode.getClassName();
+            imports.add(name);
+            if (iNode.getAlias() != null && !iNode.getAlias().isEmpty()) {
+                aliases.put(iNode.getAlias(), name.replaceAll(""\\."", ""/""));
 
 Review comment:
   `name.replaceAll(""\\."", ""/""))` can be replaced with `name.replace('.', '/'))` to avoid regex compilation
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jan/20 16:24;githubbot;600","asfgit commented on pull request #1137: GROOVY-8296: Groovydoc Recognition exception with Java 8 class
URL: https://github.com/apache/groovy/pull/1137
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jan/20 22:57;githubbot;600","paulk-asert commented on pull request #1137: GROOVY-8296: Groovydoc Recognition exception with Java 8 class
URL: https://github.com/apache/groovy/pull/1137#discussion_r365463693
 
 

 ##########
 File path: subprojects/groovy-templates/src/main/groovy/groovy/text/GStringTemplateEngine.java
 ##########
 @@ -199,6 +199,7 @@ public Object run() {
             try {
                 groovyClass = loader.parseClass(new GroovyCodeSource(templateExpressions.toString(), ""GStringTemplateScript"" + counter.incrementAndGet() + "".groovy"", ""x""));
             } catch (Exception e) {
+                System.err.println(""templateExpressions = "" + templateExpressions);
 
 Review comment:
   Thanks for spotting that, yes I'll revert.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jan/20 22:59;githubbot;600","paulk-asert commented on pull request #1137: GROOVY-8296: Groovydoc Recognition exception with Java 8 class
URL: https://github.com/apache/groovy/pull/1137#discussion_r365463740
 
 

 ##########
 File path: subprojects/groovy-groovydoc/src/main/java/org/apache/groovy/antlr/GroovydocVisitor.java
 ##########
 @@ -78,7 +86,15 @@ protected SourceUnit getSourceUnit() {
 
     @Override
     public void visitClass(ClassNode node) {
-        List<String> imports = node.getModule().getImports().stream().map(ImportNode::getClassName).collect(Collectors.toList());
+        final Map<String, String> aliases = new HashMap<>();
+        final List<String> imports = new ArrayList<>();
+        for (ImportNode iNode : node.getModule().getImports()) {
+            String name = iNode.getClassName();
+            imports.add(name);
+            if (iNode.getAlias() != null && !iNode.getAlias().isEmpty()) {
+                aliases.put(iNode.getAlias(), name.replaceAll(""\\."", ""/""));
 
 Review comment:
   Nice suggestion.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jan/20 22:59;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,4200,,,0,4200,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 08 16:58:41 UTC 2017,,,,,,,,,,"0|i3j9c7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Sep/17 16:58;daniel_sun;How about parsing Java source files with [javaparser|https://github.com/javaparser/javaparser]?;;;",,,,,,,,,,,,,,,,,,,,,
Groovyc ant task can overflow Windows command line if classpath is large,GROOVY-8295,13097341,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,emilles,emilles,24/Aug/17 15:36,06/Mar/18 23:14,14/Jul/23 06:02,24/Feb/18 01:52,,,,,,,,,2.4.14,,,,Ant integration,,,,1,,,,,,,"The groovyc ant adapter tries to account for the 32K command line length limit on windows in its addSourceFiles method.  However, if the command line gets long for other reasons -- we include a number of libraries in our compiled projects -- the command line can still be overflown.

This results in:
{code}
CompileAntScript.xml:129: Error running forked groovyc.
	at org.codehaus.groovy.ant.Groovyc.runForked(Groovyc.java:1121)
	at org.codehaus.groovy.ant.Groovyc.compile(Groovyc.java:1214)
	at org.codehaus.groovy.ant.Groovyc.execute(Groovyc.java:831)

Caused by: java.io.IOException: Cannot run program ""C:\Program Files\Java\jdk1.8.0_60\jre\bin\java"": CreateProcess error=206, The filename or extension is too long
	at java.lang.ProcessBuilder.start(ProcessBuilder.java:1048)
	at java.lang.Runtime.exec(Runtime.java:620)
	at org.apache.tools.ant.taskdefs.Execute$Java13CommandLauncher.exec(Execute.java:862)
	at org.apache.tools.ant.taskdefs.Execute.launch(Execute.java:481)
	at org.apache.tools.ant.taskdefs.Execute.execute(Execute.java:495)
	at org.codehaus.groovy.ant.Groovyc.runForked(Groovyc.java:1119)
	... 31 more
Caused by: java.io.IOException: CreateProcess error=206, The filename or extension is too long
	at java.lang.ProcessImpl.create(Native Method)
	at java.lang.ProcessImpl.<init>(ProcessImpl.java:386)
	at java.lang.ProcessImpl.start(ProcessImpl.java:137)
	at java.lang.ProcessBuilder.start(ProcessBuilder.java:1029)
	... 36 more
{code}

Would it be possible to add command line length checking to {{runForked}} instead of {{addSourceFiles}} and use a command file for groovyc to prevent command line overflow?  Without this, we are having to use a lot of verbose workarounds in Ant.

https://github.com/apache/groovy/blob/master/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java
",Windows,artsiom.matronkin,emilles,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"29/Aug/17 23:01;emilles;Groovyc.patch;https://issues.apache.org/jira/secure/attachment/12884364/Groovyc.patch",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Feb 23 15:52:15 UTC 2018,,,,,,,,,,"0|i3j8tz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Aug/17 22:41;emilles;I did a little digging on this one.  It appears that the {{@file.txt}} command line option of Groovyc (aka {{org.codehaus.groovy.tools.FileSystemCompiler}}) is for the list of source files only.  So I took another approach to the problem.  Since the classpath is the bit that is so very long (and is listed 2 times when running in forked mode), I tried replacing the absolute path of the executable's working directory.  

The change is actually quite small.  Replace the 2 occurrences of {{commandLineList.add(classpath.toString());}} with {{commandLineList.add(classpath.toString().replace(getProject().getBaseDir().getAbsolutePath(), "".""));}}.


This can reduce a classpath like:
{code}
C:\Users\user.home\project.directory\build\JavaClasses;C:\Users\user.home\project.directory\build\IvyLibraries\master\commons-codec-1.10.jar;C:\Users\user.home\project.directory\build\IvyLibraries\master\commons-collections4-4.1.jar;C:\Users\user.home\project.directory\build\IvyLibraries\master\commons-lang3-3.6.jar;C:\Users\user.home\project.directory\build\IvyLibraries\master\db-5.1.19.jar;C:\Users\user.home\project.directory\build\IvyLibraries\master\groovy-all-2.4.12.jar;C:\Users\user.home\project.directory\build\IvyLibraries\master\guava-22.0.jar;C:\Users\user.home\project.directory\build\IvyLibraries\master\infra-berkeleyloader-28.5.0.jar;C:\Users\user.home\project.directory\build\IvyLibraries\master\infra-logging-31.1.0.jar;C:\Users\user.home\project.directory\build\IvyLibraries\master\joda-time-2.9.9.jar;C:\Users\user.home\project.directory\build\IvyLibraries\master\json-20080701.jar;C:\Users\user.home\project.directory\build\IvyLibraries\master\log4j-1.2.17.jar
{code}
to
{code}
.\build\JavaClasses;;.\build\IvyLibraries\master\commons-codec-1.10.jar;.\build\IvyLibraries\master\commons-collections4-4.1.jar;.\build\IvyLibraries\master\commons-lang3-3.6.jar;.\build\IvyLibraries\master\db-5.1.19.jar;.\build\IvyLibraries\master\groovy-all-2.4.12.jar;.\build\IvyLibraries\master\guava-22.0.jar;.\build\IvyLibraries\master\infra-berkeleyloader-28.5.0.jar;.\build\IvyLibraries\master\infra-logging-31.1.0.jar;.\build\IvyLibraries\master\joda-time-2.9.9.jar;.\build\IvyLibraries\master\json-20080701.jar;.\build\IvyLibraries\master\log4j-1.2.17.jar
{code}

The effect is quite significant for a project with dozens of dependencies that is built in a deeply nested directory on the file system.;;;","29/Aug/17 23:01;emilles;Here is a patch file (based on Groovyc.java in 2.4.12) for the proposed solution I commented on.;;;","07/Nov/17 02:31;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/629

    GROOVY-8295: Groovyc ant task can overflow Windows command line if cl…

    …asspath is large. PR based on Eric's patch in the related issue.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8295

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/629.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #629
    
----
commit b34e1b00101470659fbadf0f23952207d4bfb63b
Author: paulk <paulk@asert.com.au>
Date:   2017-11-07T02:30:10Z

    GROOVY-8295: Groovyc ant task can overflow Windows command line if classpath is large

----
;;;","12/Nov/17 22:30;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/629
;;;","13/Nov/17 02:55;paulk;Proposed PR merged.;;;","04/Dec/17 18:59;emilles;Paul,
The merge request that went in for this only replaces the first occurrence of the project basedir.
{code}
    private String getClasspathRelative(Path classpath) {
        String raw = classpath.toString();
        String baseDir = getProject().getBaseDir().getAbsolutePath();
        if (!raw.startsWith(baseDir)) {
            return raw;
        }
        return ""."" + raw.substring(baseDir.length());
    }
{code}

My original change was {{classpath.toString().replace(getProject().getBaseDir().getAbsolutePath(), ""."")}}, which replaces every occurrence of the baseDir with ""."".;;;","04/Dec/17 19:38;emilles;Here is a possible new version of {{getClasspathRelative}}:
{code}
    private String getClasspathRelative(Path classpath) {
        String baseDir = getProject().getBaseDir().getAbsolutePath();
        String pattern = ""(\\A|"" + File.pathSeparator + "")"" + Pattern.quote(baseDir) + ""\\b"";
        return classpath.toString().replaceAll(pattern, ""$1."");
}
{code};;;","07/Dec/17 00:58;paulk;My bad. I had played around with using split on pathSeparator but obviously didn't put that in my PR. Must have been too many things in parallel at the time! :-);;;","10/Dec/17 03:30;paulk;I ended up not mucking around with split/regexs and instead asking a path for its list of components which seems fairly clean. Output from my test project on Windows:
{noformat}
  [groovyc] C:\Projects\groovy\target\install\embeddable\groovy-all-3.0.0-SNAPSHOT.jar;.\lang\commons-lang-2.6.jar;.\guava\guava-20.0.jar
{noformat}
It would be great if you can try out a snapshot release.;;;","12/Dec/17 17:16;emilles;Paul, thanks for the extra effort.  I'm going to take a look at the current fix.  Also, we are running into a build issue with the fix as deployed in 2.4.13.  We have a chained build and I think the project basedir and the working dir of the compiler are different.  I'll let you know when I have a bit more info.;;;","12/Dec/17 18:24;emilles;So here's what I am running into.  We use the {{<ant antfile=""ant/CompileAntScript.xml"" ...}} from one build script to drive another. This results in a process working directory of {{ant/}}.  This can be confirmed by executing {{java.nio.file.Paths.get("""").toAbsolutePath()}} within Groovyc.  When Groovyc is run in-process (no forking), it inherits this working directory.  However, when Groovyc is forked, {{executor.setWorkingDirectory(getProject().getBaseDir());}} is called, which changes the working directory.

If I replace {{executor.setWorkingDirectory(getProject().getBaseDir());}} with {{executor.setWorkingDirectory(Paths.get("""").toAbsolutePath().toFile());}} in {{runForked}} and I replace {{String baseDir = getProject().getBaseDir().getAbsolutePath();}} with {{String baseDir = Paths.get("""").toAbsolutePath().toString());}} in {{getClasspathRelative}} I get the same behavior for forked and in-process compilation (WRT working directory and relative paths).;;;","12/Dec/17 19:37;emilles;Quick summary: current fix for this issue in Groovy 2.4 branch works perfectly in forked compilation mode.  In-process compilation is failing due to difference between project basedir and working directory (as mentioned in previous comment).

Changing {{getClasspathRelative}} as described above works in forked compilation mode.  Although it alters the working directory from what existing builds have been using.  This same change is not helping in-process compilation.  Ant appears to be validating the classpath resources against the project basedir and the FileSystemCompiler loads relative to the working directory.

If {{getClasspathRelative}} did not alter the classpath for in-process compilation, there would be no other conflict with the fix.  That is, check {{fork}} flag.;;;","12/Dec/17 19:48;emilles;{code}
    private String getClasspathRelative(Path classpath) {
        if (!fork) return classpath.toString();

        String baseDir = getProject().getBaseDir().getAbsolutePath();
        StringBuilder sb = new StringBuilder();
        for (String next : classpath.list()) {
            if (sb.length() > 0) {
                sb.append(File.pathSeparatorChar);
            }
            if (next.startsWith(baseDir)) {
                sb.append(""."").append(next.substring(baseDir.length()));
            } else {
                sb.append(next);
            }
        }
        return sb.toString();
    }
{code}
  or
{code}
    private void doForkCommandLineList(List<String> commandLineList, Path classpath, String separator) {
        ...
        commandLineList.add(""-classpath"");
        commandLineList.add(getClasspathRelative(classpath));
        ...
}
    private void doNormalCommandLineList(List<String> commandLineList, List<String> jointOptions, Path classpath) {
        commandLineList.add(""--classpath"");
        commandLineList.add(!fork ? classpath.toString() : getClasspathRelative(classpath));
        ...
}
{code}



Follow up: Any reason the classpath is passed using both {noformat}-classpath{noformat} and {noformat}--classpath{noformat} options to the compiler?  This duplication is a lot of the reason for command-line overflow.;;;","14/Dec/17 16:00;emilles;Paul, one extra check is required (see my last comment) to handle in-process compilation.  Forked compilation is working properly.;;;","17/Feb/18 06:24;paulk;I had previously changed {{doNormalCommandLineList}} to have:
{code:java}
if (!fork) {
    commandLineList.add(""--classpath"");
    commandLineList.add(classpath.toString());
}
{code}
Is that what you were testing against? It was meant to get rid of the duplication also.;;;","22/Feb/18 15:28;emilles;Looking at the current 2.4 branch, I see doNormalCommandLineList still using getClasspathRelative unconditionally.

[https://github.com/apache/groovy/blob/GROOVY_2_4_X/subprojects/groovy-ant/src/main/java/org/codehaus/groovy/ant/Groovyc.java#L1063]

I am seeing this:
{code:java}
    private void doNormalCommandLineList(List<String> commandLineList, List<String> jointOptions, Path classpath) {
        commandLineList.add(""--classpath"");
        commandLineList.add(getClasspathRelative(classpath));
{code}
 and I'm lobbying for this:
{code:java}
    private void doNormalCommandLineList(List<String> commandLineList, List<String> jointOptions, Path classpath) {
        commandLineList.add(""--classpath"");
        commandLineList.add(!fork ? classpath.toString() : getClasspathRelative(classpath));
{code}

I have not tested with the exclusion of these two lines in the case of in-process compilation.  I had not seen that change anywhere previously.;;;","23/Feb/18 04:46;paulk;Looks like I only did that change in master. It's now propagated to the other branches. Let me know if that works, otherwise we can look at your suggestion.;;;","23/Feb/18 15:52;emilles;Paul, the change looks good for both forked and in-process compilation.  Thanks again for the extra effort on this issue.;;;",,,,
Return 404 for non-existing paths in `TemplateServlet` when running from .war,GROOVY-8294,13097105,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,tom-mi,tom-mi,23/Aug/17 18:31,06/Mar/18 23:25,14/Jul/23 06:02,25/Aug/17 02:16,,,,,,,,,2.4.13,,,,,,,,0,breaking,,,,,,"When TemplateServlet is used in application servers that don't unpack a war (i.e. when the real path of resources could not be retrieved), an internal server error is returned upon trying to retrieve a non-existing template file.

The expected behavior would be to get a 404, just as it is already the case when running from a extracted war.

I had this behavior when running on a [payara micro|https://www.payara.fish/payara_micro] application server using the following {{web.xml}} snippet:
{code}
<web-app xmlns=""http://java.sun.com/xml/ns/javaee"" version=""2.5"">
    <servlet>
        <servlet-name>GroovyTemplate</servlet-name>
        <servlet-class>groovy.servlet.TemplateServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>GroovyTemplate</servlet-name>
        <url-pattern>*.gsp</url-pattern>
    </servlet-mapping>
</web-app>
{code}
and requesting an url ending in {{*.gsp}}, but without a template with that name present.

Please see the attached minimal example (docker required):
Run it with:
{code}
./gradlew runDockerContainer
{code}
and test the URLs
http://localhost:8080/test.gsp  (works)
http://localhost:8080/unknown.gsp  (500, but I would actually expect a 404)

The corresponding stacktrace is
{code}
java.lang.NullPointerException
        at groovy.servlet.TemplateServlet.getTemplate(TemplateServlet.java:331)
        at groovy.servlet.TemplateServlet.service(TemplateServlet.java:445)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)
        at org.apache.catalina.core.StandardWrapper.service(StandardWrapper.java:1606)
        at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:258)
        at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:160)
        at org.apache.catalina.core.StandardPipeline.doInvoke(StandardPipeline.java:654)
        at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:593)
        at com.sun.enterprise.web.WebPipeline.invoke(WebPipeline.java:99)
        at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:155)
        at org.apache.catalina.connector.CoyoteAdapter.doService(CoyoteAdapter.java:371)
        at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:238)
        at com.sun.enterprise.v3.services.impl.ContainerMapper$HttpHandlerCallable.call(ContainerMapper.java:466)
        at com.sun.enterprise.v3.services.impl.ContainerMapper.service(ContainerMapper.java:169)
        at org.glassfish.grizzly.http.server.HttpHandler.runService(HttpHandler.java:206)
        at org.glassfish.grizzly.http.server.HttpHandler.doHandle(HttpHandler.java:180)
        at org.glassfish.grizzly.http.server.HttpServerFilter.handleRead(HttpServerFilter.java:235)
        at org.glassfish.grizzly.filterchain.ExecutorResolver$9.execute(ExecutorResolver.java:119)
        at org.glassfish.grizzly.filterchain.DefaultFilterChain.executeFilter(DefaultFilterChain.java:284)
        at org.glassfish.grizzly.filterchain.DefaultFilterChain.executeChainPart(DefaultFilterChain.java:201)
        at org.glassfish.grizzly.filterchain.DefaultFilterChain.execute(DefaultFilterChain.java:133)
        at org.glassfish.grizzly.filterchain.DefaultFilterChain.process(DefaultFilterChain.java:112)
        at org.glassfish.grizzly.ProcessorExecutor.execute(ProcessorExecutor.java:77)
        at org.glassfish.grizzly.nio.transport.TCPNIOTransport.fireIOEvent(TCPNIOTransport.java:539)
        at org.glassfish.grizzly.strategies.AbstractIOStrategy.fireIOEvent(AbstractIOStrategy.java:112)
        at org.glassfish.grizzly.strategies.WorkerThreadIOStrategy.run0(WorkerThreadIOStrategy.java:117)
        at org.glassfish.grizzly.strategies.WorkerThreadIOStrategy.access$100(WorkerThreadIOStrategy.java:56)
        at org.glassfish.grizzly.strategies.WorkerThreadIOStrategy$WorkerThreadRunnable.run(WorkerThreadIOStrategy.java:137)
        at org.glassfish.grizzly.threadpool.AbstractThreadPool$Worker.doWork(AbstractThreadPool.java:593)
        at org.glassfish.grizzly.threadpool.AbstractThreadPool$Worker.run(AbstractThreadPool.java:573)
        at java.lang.Thread.run(Thread.java:745)
{code}",Payara Micro,jwagenleitner,tom-mi,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/Aug/17 18:31;tom-mi;broken-template-servlet.tar.gz;https://issues.apache.org/jira/secure/attachment/12883381/broken-template-servlet.tar.gz",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 25 02:16:10 UTC 2017,,,,,,,,,,"0|i3j7dz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Aug/17 01:42;jwagenleitner;I labelled as {{breaking}} just to call out the change in behavior, but think it does fix a bug and should go in the next 2.4.x release.;;;","25/Aug/17 02:16;jwagenleitner;Thanks for reporting the issue and the PR.;;;",,,,,,,,,,,,,,,,,,,,
Improve the performance of build for master branch,GROOVY-8292,13094966,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,daniel_sun,daniel_sun,16/Aug/17 09:29,06/Apr/18 11:27,14/Jul/23 06:02,06/Apr/18 11:27,3.x,,,,,,,,,,,,,,,,0,,,,,,,"*master@teamcity(cost 43m:06s):*
http://ci.groovy-lang.org/viewLog.html?buildTypeId=Groovy_Jdk8Build_PlusSnapshotDeploy&buildId=41473

* generateGrammarSource task for antlr4 costs about 30s

*2_6_0@teamcity(cost 32m:13s):*
http://ci.groovy-lang.org/viewLog.html?buildTypeId=Groovy_Jdk8Build_PlusSnapshotDeploy&buildId=41471

*master@travis-ci(cost 27 min 8 sec):*
https://travis-ci.org/apache/groovy/builds/265185360

*2_6_0@travis-ci(cost 24 min 25 sec):*
https://travis-ci.org/apache/groovy/builds/265214423
",,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Aug/17 09:31;daniel_sun;compare.png;https://issues.apache.org/jira/secure/attachment/12882103/compare.png",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 06 11:27:09 UTC 2018,,,,,,,,,,"0|i3iubj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Apr/18 11:27;daniel_sun;The build has been improved, so build costs much less time now;;;",,,,,,,,,,,,,,,,,,,,,
STC and default value in ctor is causing debugging error,GROOVY-8289,13094783,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,emilles,emilles,15/Aug/17 15:13,06/Mar/18 23:12,14/Jul/23 06:02,13/Nov/17 02:53,2.4.12,,,,,,,,2.4.13,,,,bytecode,,,,0,,,,,,,"When debugging in the IDE, there is a curious behavior where it looks like step requests are not being respected.  One thing I have found is that JDWP requests to the JVM process are failing to resolve the variable ""this"" in certain cases.  I need some help from someone who knows the bytecode better than myself to figure out where the problem lies.

Original issue: https://github.com/groovy/groovy-eclipse/issues/312

I have narrowed it down to a small bit of code with static compilation enabled.
{code}
@groovy.transform.CompileStatic
class C {
  String string
  C(String s = null) { string = s }

  static void main(args) {
    def c = new C('') // put breakpoint on this line, run as Java app, and step
    println c
  }
}
{code}
Debug stepping fails when executing the constructor for C.  If I use {{new C(string:'')}}, the generated default constructor is used instead and debugging works fine.  So I think it has something to do with the one-arg constructor's bytecode.

I dumped the class file using javap and have attached them.  {{C1.txt}} is for the code above.  {{C2.txt}} is the above with the named args constructor used instead.  I'm not sure if the local args table for the single-argument constructor is bad and that is why ""this"" cannot be resolved.

There are several similar bugs reported for other tools and whatnots when looking for ""JDWP error code 35"".  Hopefully, these help point to something in the bytecode that can be corrected.

http://bugs.java.com/bugdatabase/view_bug.do?bug_id=5005668
https://bugs.openjdk.java.net/browse/JDK-4992932",,blackdrag,emilles,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"15/Aug/17 15:04;emilles;C1.txt;https://issues.apache.org/jira/secure/attachment/12881946/C1.txt","15/Aug/17 15:04;emilles;C2.txt;https://issues.apache.org/jira/secure/attachment/12881945/C2.txt","17/Aug/17 21:31;emilles;C3.txt;https://issues.apache.org/jira/secure/attachment/12882447/C3.txt",,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 13 02:53:52 UTC 2017,,,,,,,,,,"0|i3it6v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Aug/17 18:46;blackdrag;Maybe I can be of some help here

if you do {code:Java}
         0: aload_0
         1: invokespecial #20                 // Method java/lang/Object.""<init>"":()V
         4: aload_0
{code}
In the constructor, then the first aload 0 will load the uninitialized class. Only after we have done the invokespecial, we have a full object on which we can actually call methods on. In the example code here offset 4 is the first place with a valid this in the java sense. In this normal constructor the LocalVariableTable shows the variable ""this"" starting at 4.

In{code:Java}
      stack=2, locals=1, args_size=1
         0: aload_0
         1: aconst_null
         2: invokespecial #33                 // Method ""<init>"":(Ljava/lang/String;)V
         5: return
{code}
we again load the unitialized class in 0 to then make the only valid method call with it, which is a invokespecial to delegate object creation. so starting with 5 we have a valid ""this"" in the Java sense here. LocalVariableTable though shows ""this"" starting at 0. So I guess it really should start at 5. That would mean, if you step through with a debugger we may see before 5 no local variables then. 

I guess that is what is requested to avoid the debugging error.

Do you share that view?
;;;","17/Aug/17 15:45;emilles;Is the code that controls this in the Static Compilation packages?  That is, how can I experiment with changing the start index of ""this"" for the single-argument constructor in an @CompileStatic class?  I think setting the ""this"" start index to 0 will appease the debugger.;;;","17/Aug/17 16:38;emilles;I'm a little out on a limb here, but when I rewrite the class with explicit {{super()}} constructor invocations, things work fine in the debugger.  That is I now have this:
{code}
@groovy.transform.CompileStatic
class C {
  String string
  C(String s = null) {
    super()
    string = s
  }
  static void main(args) {
    def c = new C('') // put breakpoint on this line, run as Java app, and step
    println c
  }
}
{code}

From what I can gather, AsmClassGenerator.visitStdMethod is where this matters.  If I leave out the call to super, the upper part kicks in.  If I explicitly call super, those instructons are inserted as part of super.visitConstructorOrMethod, which happens on the other side of scope and param init.  I'm going to experiment by moving {{init}} and {{makeSiteEntry}} to the start of the method.

{code}
    private void visitStdMethod(MethodNode node, boolean isConstructor, Parameter[] parameters, Statement code) {
        MethodVisitor mv = controller.getMethodVisitor();
        final ClassNode superClass = controller.getClassNode().getSuperClass();
        if (isConstructor && (code == null || !((ConstructorNode) node).firstStatementIsSpecialConstructorCall())) {
            boolean hasCallToSuper = false;
            if (code!=null && controller.getClassNode() instanceof InnerClassNode) {
                // if the class not is an inner class node, there are chances that the call to super is already added
                // so we must ensure not to add it twice (see GROOVY-4471)
                if (code instanceof BlockStatement) {
                    for (Statement statement : ((BlockStatement) code).getStatements()) {
                        if (statement instanceof ExpressionStatement) {
                            final Expression expression = ((ExpressionStatement) statement).getExpression();
                            if (expression instanceof ConstructorCallExpression) {
                                ConstructorCallExpression call = (ConstructorCallExpression) expression;
                                if (call.isSuperCall()) {
                                    hasCallToSuper = true;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            if (!hasCallToSuper) {
                // invokes the super class constructor
                mv.visitVarInsn(ALOAD, 0);
                mv.visitMethodInsn(INVOKESPECIAL, BytecodeHelper.getClassInternalName(superClass), ""<init>"", ""()V"", false);
            }
        }

        controller.getCompileStack().init(node.getVariableScope(), parameters);
        controller.getCallSiteWriter().makeSiteEntry();

        // handle body
        super.visitConstructorOrMethod(node, isConstructor);
{code};;;","17/Aug/17 20:23;blackdrag;actually I think setting this to have the index 0 as starting index is exactly what is a problem for the debugger ;) the places you mentioned do sound about right, but the actualy entry into the variable table is done with mv.visitLocalVariable(""this"", className, null, thisStartLabel, thisEndLabel, 0); in CompileStack.clear(), which is actually called after the part you are mentioning. thisStartLabel is the label that later defines the bytecode offset where ""this"" starts. The label is set with the init call to CompileStack. For a constructor this can be wrong if firstStatementIsSpecialConstructorCall() is true.;;;","17/Aug/17 21:32;emilles;Attachment C3 is the result of moving `controller.getCompileStack().init` and `controller.getCallSiteWriter().makeSiteEntry` to the top of `AsmClassGenerator.visitStdMethod`.

The start and length of 'this' and other locals has been corrected to 0.  This matches the output if I had added the `super()` constructor call to the code explicitly.;;;","18/Aug/17 07:29;blackdrag;If that is satisfying the debugger then job well done. pullrequest?;;;","18/Aug/17 15:08;emilles;I would like this included in the next release, yes.  I am unable to produce a pull request because I do not have the groovy-core project in my workspace.  I ran my experiment through my groovy patch for groovy-eclipse.  I also don't have a sense for what kind of unit test would be required for a change to the compiler.;;;","07/Nov/17 07:39;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/630

    GROOVY-8289: STC and default value in ctor is causing debugging error

    PR based on Eric's suggested fix in the issue. Still needs a test.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8289

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/630.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #630
    
----
commit febbf61f2701bed0e2b03f28031ac0741fba087b
Author: paulk <paulk@asert.com.au>
Date:   2017-11-07T07:37:16Z

    GROOVY-8289: STC and default value in ctor is causing debugging error

----
;;;","12/Nov/17 22:30;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/630
;;;","13/Nov/17 02:53;paulk;Proposed PR merged.;;;",,,,,,,,,,,,
[Sql] withBatch fails when batchSize == number of addBatch call,GROOVY-8288,13094538,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,akapps,akapps,14/Aug/17 17:19,15/Sep/17 16:45,14/Jul/23 06:02,15/Sep/17 16:45,2.4.12,2.5.0-beta-1,,,,,,,2.4.13,2.5.0-beta-2,2.6.0-alpha-2,3.0.0-alpha-1,SQL processing,,,,0,,,,,,,"{{Sql.withBatch(batchSize, ..)}} calls {{delegate.executeBatch()}} both when batchCount reaches batchSize, and at the end of the method (after the call to the ""batch statement"" closure).

Thus, if the number of {{addBatch()}} calls in the closure is exactly the same as, or a multiple of {{batchSize}}, one too much call to {{executeBatch()}} is made : nothing has been added to the batch.
Which, at least with HSQLDB 2.4.0, leads to a SQLException on that very last call.

Test to reproduce (compliant with SqlBatchTest)
{code:java}
void testWithBatchSizeHavingSizeSameSizeAsStatements() {
    def numRows = sql.rows(""SELECT * FROM PERSON"").size()
    assert numRows == 3
    def myOthers = ['f4':'l4','f5':'l5','f6':'l6','f7':'l7']
    def result = sql.withBatch(myOthers.size(), ""insert into PERSON (id, firstname, lastname) values (?, ?, ?)"") { ps ->
        myOthers.eachWithIndex { k, v, index ->
            def id = index + numRows + 1
            ps.addBatch(id, k, v)
        }
    }
    assert result == [1] * myOthers.size()
    assert sql.rows(""SELECT * FROM PERSON"").size() == numRows + myOthers.size()
    // end result the same as if no batching was in place but logging should show:
    // FINE: Successfully executed batch with 4 command(s)
}
{code}

",,akapps,daniel_sun,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 15 16:45:58 UTC 2017,,,,,,,,,,"0|i3irpb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Aug/17 07:51;githubbot;GitHub user akapps opened a pull request:

    https://github.com/apache/groovy/pull/586

    GROOVY-8288 executeBatch() should not be called with batchCount == 0

    This is a first proposition of resolution for [GROOVY-8288](https://issues.apache.org/jira/browse/GROOVY-8288).
    There still are open questions (see my comments on changes).
    
    Thank you for your feedback.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/akapps/groovy GROOVY-8288-execute-batch

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/586.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #586
    
----
commit 7af055833f82606b12db5d66834ff1a4beaace2a
Author: Antoine Kapps <antoine.kapps@orange.fr>
Date:   2017-08-15T07:42:26Z

    GROOVY-8288 executeBatch() should not be called with batchCount == 0

----
;;;","15/Aug/17 07:54;githubbot;Github user akapps commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/586#discussion_r133134481
  
    --- Diff: subprojects/groovy-sql/src/main/java/groovy/sql/BatchingStatementWrapper.java ---
    @@ -83,8 +83,15 @@ public void clearBatch() throws SQLException {
         }
     
         public int[] executeBatch() throws SQLException {
    -        int[] lastResult = delegate.executeBatch();
    -        processResult(lastResult);
    +        if (batchCount > 0) {
    +            int[] lastResult = delegate.executeBatch();
    +            processResult(lastResult);
    +        }
    +        else if (results.isEmpty()) {
    +            log.warning(""Nothing has been added to batch"");
    +            // we let the JDBC provider decide how to handle an empty batch execution
    +            return delegate.executeBatch();
    +        }
    --- End diff --
    
    This ""else if"" is not really elegant for such a particular case...
    I could have done `if (batchCount > 0 || results.isEmpty())` in the first condition, but I thought it made the intention unreadable.
;;;","15/Aug/17 07:59;githubbot;Github user akapps commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/586#discussion_r133135254
  
    --- Diff: subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlBatchTest.groovy ---
    @@ -119,6 +121,44 @@ class SqlBatchTest extends GroovyTestCase {
             // FINE: Successfully executed batch with 1 command(s)
         }
     
    +    void testWithBatchHavingSizeSameSizeAsStatements() {
    +        def numRows = sql.rows(""SELECT * FROM PERSON"").size()
    +        assert numRows == 3
    +        def myOthers = ['f4':'l4','f5':'l5','f6':'l6','f7':'l7']
    +        def result = sql.withBatch(myOthers.size(), ""insert into PERSON (id, firstname, lastname) values (?, ?, ?)"") { ps ->
    +            myOthers.eachWithIndex { k, v, index ->
    +                def id = index + numRows + 1
    +                ps.addBatch(id, k, v)
    +            }
    +        }
    +        assert result == [1] * myOthers.size()
    +        assert sql.rows(""SELECT * FROM PERSON"").size() == numRows + myOthers.size()
    +        // end result the same as if no batching was in place but logging should show:
    +        // FINE: Successfully executed batch with 4 command(s)
    +    }
    +
    +    void testWithBatchNothingSpecified() {
    +        def numRows = sql.rows(""SELECT * FROM PERSON"").size()
    +        assert numRows == 3
    +
    +        def msg = GroovyAssert.shouldFail {
    +            sql.withBatch(3, ""insert into PERSON (id, firstname, lastname) values (?, ?, ?)"") { ps ->
    +                // Do nothing - not a good practice at all...
    +            }
    +        }
    +        System.err.println(msg)
    +    }
    +
    +    void testWithBatchNoPreparedStatementNothingSpecified() {
    +        def numRows = sql.rows(""SELECT * FROM PERSON"").size()
    +        assert numRows == 3
    +
    +        def result = sql.withBatch { ps ->
    +            // Do nothing - not a good practice at all...
    +        }
    +        assert result == [] as int[]
    --- End diff --
    
    It is quite surprising at first sight that HSQL driver behaves differently if `executeBatch()` is called with nothing added to the batch, whether a preparedStatement is used or not.
    
    I felt like it's not Groovy responsibility to ""suppress"" the exception for the preparedStatement case, and I wanted to test-specify those 2 behaviours as they are the current ones.
;;;","15/Sep/17 16:41;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/586
;;;","15/Sep/17 16:45;daniel_sun;Thanks for your patch!;;;",,,,,,,,,,,,,,,,,
getMetaClass should be annotated as (JavaBeans) transient,GROOVY-8284,13093756,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,drmlipp,drmlipp,10/Aug/17 11:35,11/Nov/20 02:01,14/Jul/23 06:02,19/Sep/20 23:59,2.4.12,,,,,,,,3.0.6,4.0.0-alpha-1,,,Compiler,,,,0,,,,,,,"All groovy classes have the ""getMetaClass()"" method. This breaks the (e.g. XML) serialization of groovy classes that are supposed to represent JavaBeans.

While the serialization provided with Serializable or Externalizable examines the attributes of a class, the special JavaBeans serialization provided by serializers based on [Encoders](https://docs.oracle.com/javase/8/docs/api/java/beans/Encoder.html) relies on the information provided by the [Introspector](https://docs.oracle.com/javase/8/docs/api/java/beans/Introspector.html). 

With respect to persistence, the PropertyDescriptor for ""getMetaClass"" should have the attribute value ""transient"" set. The Introspector generates this value if the method has been annotated as [Transient](https://docs.oracle.com/javase/8/docs/api/java/beans/Transient.html)). Because this value is currently missing, the Encoder tries to serialize the MetaClass information, which fails.

The groovy compiler should therefore annotate the ""getMetaClass"" method with the runtime annotation ""java.beans.Transient"".",,drmlipp,paulk,,,,,,,"paulk-asert opened a new pull request #1365:
URL: https://github.com/apache/groovy/pull/1365


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;11/Sep/20 10:58;githubbot;600","paulk-asert opened a new pull request #1365:
URL: https://github.com/apache/groovy/pull/1365






----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;12/Sep/20 20:29;githubbot;600","paulk-asert opened a new pull request #1365:
URL: https://github.com/apache/groovy/pull/1365






----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;12/Sep/20 21:44;githubbot;600","asfgit closed pull request #1365:
URL: https://github.com/apache/groovy/pull/1365


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Sep/20 04:49;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,2400,,,0,2400,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Sep 19 23:59:13 UTC 2020,,,,,,,,,,"0|i3in33:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Sep/20 23:59;paulk;Proposed PR merged.;;;",,,,,,,,,,,,,,,,,,,,,
Error while popping argument from operand stack tracker in class ...$Trait$Helper,GROOVY-8282,13093541,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,LucasC,LucasC,09/Aug/17 16:53,14/Aug/18 08:05,14/Jul/23 06:02,25/Jul/18 04:09,2.4.15,2.4.8,2.5.1,,,,,,2.5.2,,,,,,,,0,,,,,,,"Hello.

I'm facing a compilation error with this simple {{trait}} definition, with a public method invoking a private one with an implicit {{Map}}:
{code}
trait BugReproduction {
    def foo() {
        bar(a: 1)
    }
    private bar(Map args) {
    }
}
{code}
The error message:
{code}
Caught: BUG! exception in phase 'class generation' in source unit 'file:/.../BugReproduction.groovy' Error while popping argument from operand stack tracker in class BugReproduction$Trait$Helper method java.lang.Object foo(BugReproduction).
BUG! exception in phase 'class generation' in source unit 'file:/.../BugReproduction.groovy' Error while popping argument from operand stack tracker in class BugReproduction$Trait$Helper method java.lang.Object foo(BugReproduction).
{code}

I use Groovy v2.4.8",,githubbot,LucasC,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 25 04:09:07 UTC 2018,,,,,,,,,,"0|i3ilrj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Jul/18 05:53;paulk;Workaround is to use explicit Map as the argument:
{code}
bar([a: 1])
{code};;;","12/Jul/18 11:32;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/774

    GROOVY-8282: Error while popping argument from operand stack tracker …

    …in class ...$Trait$Helper
    
    Bare named argument parameters are captured in a TupleExpression rather than an ArgumentListExpression.
    While it would be nice to retrofit APP to have the correct type, that would impact many more places.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8282

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/774.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #774
    
----
commit f4baa9c82720bcf2ceda57f5c793b81ac6b8b5f4
Author: Paul King <paulk@...>
Date:   2018-07-12T11:30:54Z

    GROOVY-8282: Error while popping argument from operand stack tracker in class ...$Trait$Helper
    
    Bare named argument parameters are captured in a TupleExpression rather than an ArgumentListExpression.
    While it would be nice to retrofit APP to have the correct type, that would impact many more places.

----
;;;","25/Jul/18 03:52;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/774
;;;","25/Jul/18 04:09;paulk;Should be fixed in the next release. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,
"Final field is null in trait, but it has assigned value",GROOVY-8281,13093109,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,alien11689,alien11689,08/Aug/17 09:55,26/Jul/18 04:38,14/Jul/23 06:02,10/Jul/18 12:56,2.4.10,2.4.11,2.4.12,2.4.8,2.4.9,,,,2.5.1,,,,,,,,0,,,,,,,"I have a code like this:

{code}
trait MyTrait {
	final String myValue = ""test""
	final Wrapper wrapper = new Wrapper(myValue)
}

class Wrapper {
	Wrapper(String value){
		if(value == null) {
			throw new Exception(""Value is null!!!"")	
		}
		println ""OK: $value""
	}
}

class Main implements MyTrait {}

new Main()
{code}

Everything works as expected with groovy 2.4.7:

{code}
$ sdk u groovy 2.4.7

Using groovy version 2.4.7 in this shell.
$ groovy bug.groovy 
OK: test
{code}

but newer versions of groovy do not compile this code (2.4.8, 2.4.9, 2.4.10) or have null to value (2.4.11, 2.4.12):

{code}
$ sdk u groovy 2.4.8

Using groovy version 2.4.8 in this shell.
$ groovy bug.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
~/bug.groovy: 3: Apparent variable 'myValue' was found in a static scope but doesn't refer to a local variable, static field or class. Possible causes:
You attempted to reference a variable in the binding or an instance variable from a static context.
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method 'myValue' but left out brackets in a place not allowed by the grammar.
 @ line 3, column 38.
   	final Wrapper wrapper = new Wrapper(myValue)
                                        ^

1 error

$ sdk u groovy 2.4.9

Using groovy version 2.4.9 in this shell.
$ groovy bug.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
~/bug.groovy: 3: Apparent variable 'myValue' was found in a static scope but doesn't refer to a local variable, static field or class. Possible causes:
You attempted to reference a variable in the binding or an instance variable from a static context.
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method 'myValue' but left out brackets in a place not allowed by the grammar.
 @ line 3, column 38.
   	final Wrapper wrapper = new Wrapper(myValue)
                                        ^

~/bug.groovy: 3: Apparent variable 'myValue' was found in a static scope but doesn't refer to a local variable, static field or class. Possible causes:
You attempted to reference a variable in the binding or an instance variable from a static context.
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method 'myValue' but left out brackets in a place not allowed by the grammar.
 @ line 3, column 38.
   	final Wrapper wrapper = new Wrapper(myValue)
                                        ^

2 errors

$ sdk u groovy 2.4.10

Using groovy version 2.4.10 in this shell.
$ groovy bug.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
~/bug.groovy: 3: Apparent variable 'myValue' was found in a static scope but doesn't refer to a local variable, static field or class. Possible causes:
You attempted to reference a variable in the binding or an instance variable from a static context.
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method 'myValue' but left out brackets in a place not allowed by the grammar.
 @ line 3, column 38.
   	final Wrapper wrapper = new Wrapper(myValue)
                                        ^

~/bug.groovy: 3: Apparent variable 'myValue' was found in a static scope but doesn't refer to a local variable, static field or class. Possible causes:
You attempted to reference a variable in the binding or an instance variable from a static context.
You misspelled a classname or statically imported field. Please check the spelling.
You attempted to use a method 'myValue' but left out brackets in a place not allowed by the grammar.
 @ line 3, column 38.
   	final Wrapper wrapper = new Wrapper(myValue)
                                        ^

2 errors

$ sdk u groovy 2.4.11

Using groovy version 2.4.11 in this shell.
$ groovy bug.groovy 
Caught: java.lang.Exception: Value is null!!!
java.lang.Exception: Value is null!!!
	at Wrapper.<init>(bug.groovy:9)
	at MyTrait$Trait$Helper.$init$(bug.groovy:3)
	at Main.<init>(bug.groovy)
	at bug.run(bug.groovy:17)
$ sdk u groovy 2.4.12

Using groovy version 2.4.12 in this shell.
$ groovy bug.groovy 
Caught: java.lang.Exception: Value is null!!!
java.lang.Exception: Value is null!!!
	at Wrapper.<init>(bug.groovy:9)
	at MyTrait$Trait$Helper.$init$(bug.groovy:3)
	at Main.<init>(bug.groovy)
	at bug.run(bug.groovy:17)
{code}",,alien11689,githubbot,paulk,szpak,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7515,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 10 12:56:16 UTC 2018,,,,,,,,,,"0|i3ij3z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Jul/18 11:53;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/772

    GROOVY-8281: Final field is null in trait, but it has assigned value

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8281

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/772.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #772
    
----
commit be7834c73ff967372f7714bad3ec1c5b662d1456
Author: Paul King <paulk@...>
Date:   2018-07-10T11:51:57Z

    GROOVY-8281: Final field is null in trait, but it has assigned value

----
;;;","10/Jul/18 12:34;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/772
;;;","10/Jul/18 12:56;paulk;Proposed PR merged.;;;",,,,,,,,,,,,,,,,,,,
[Parrot]Fix gls.syntax.MethodCallValidationTest#testDeclarationInMethodCall,GROOVY-8277,13092736,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,daniel_sun,daniel_sun,06/Aug/17 17:12,06/Mar/18 23:25,14/Jul/23 06:02,15/Sep/17 16:19,2.6.0-alpha-1,3.0.0-alpha-1,,,,,,,2.6.0-alpha-2,3.0.0-alpha-1,,,,,,,0,,,,,,,,,daniel_sun,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-08-06 17:12:08.0,,,,,,,,,,"0|i3igtj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
methodMissing not executed when the delegate is an inner class,GROOVY-8274,13091386,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,Schlogen,Schlogen,31/Jul/17 22:32,23/Jul/20 14:16,14/Jul/23 06:02,24/Jun/20 00:21,2.4.12,,,,,,,,3.0.5,4.0.0-alpha-1,,,groovy-runtime,,,,0,,,,,,,"{code}
class Foo {
    
    void executeClosure(Closure c) {
        c.resolveStrategy = Closure.DELEGATE_ONLY
        c.delegate = new Bar()
        c.call()
    }

    class Bar {
        def methodMissing(String name, args) {
            println name
        }
    }
}

Closure c = {
    go()
}

new Foo().executeClosure(c)
{code}

Executing the above results in:
{{groovy.lang.MissingMethodException: No signature of method: Foo.go() is applicable for argument types: () values: []}}

If the Bar class is moved out of Foo, it works as I expect.",,Schlogen,,,,,,,,"eric-milles opened a new pull request #1286:
URL: https://github.com/apache/groovy/pull/1286


   InnerClassCompletionVisitor overwrote user's methodMissing or propertyMissing with synthetic dispatcher.
   
   https://issues.apache.org/jira/browse/GROOVY-8274


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;22/Jun/20 03:37;githubbot;600","danielsun1106 merged pull request #1286:
URL: https://github.com/apache/groovy/pull/1286


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;24/Jun/20 00:21;githubbot;600","danielsun1106 commented on pull request #1286:
URL: https://github.com/apache/groovy/pull/1286#issuecomment-648500629


   Merged. Thanks!


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;24/Jun/20 00:21;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-07-31 22:32:44.0,,,,,,,,,,"0|i3i8kv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Extending trait can't execute static method,GROOVY-8272,13090948,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,Schlogen,Schlogen,29/Jul/17 02:52,21/Feb/19 06:18,14/Jul/23 06:02,31/Jan/19 11:21,2.4.12,,,,,,,,2.5.6,3.0.0-beta-1,,,Static compilation,,,,0,,,,,,,"{code}
import groovy.transform.CompileStatic

@CompileStatic
trait Foo {
    static void go() {
    }
}

@CompileStatic
trait Bar extends Foo {
    void doIt() {
        go()
    }
}
{code}

The above code will produce the following:

{{[Static type checking] - Cannot find matching method Bar#go(). Please check if the declared type is right and if the method exists.}}",,daniilo,emilles,paulk,Schlogen,,,,,"paulk-asert commented on pull request #865: GROOVY-8272: Extending trait can't execute static method
URL: https://github.com/apache/groovy/pull/865
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;29/Jan/19 05:58;githubbot;600","danielsun1106 commented on issue #865: GROOVY-8272: Extending trait can't execute static method
URL: https://github.com/apache/groovy/pull/865#issuecomment-458434766
 
 
   +1
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;29/Jan/19 07:26;githubbot;600","asfgit commented on pull request #865: GROOVY-8272: Extending trait can't execute static method
URL: https://github.com/apache/groovy/pull/865
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;31/Jan/19 10:33;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 31 11:21:39 UTC 2019,,,,,,,,,,"0|i3i5vj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Jan/19 11:21;paulk;Proposed PR merged. Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,,,
Take/TakeRight methods on iterator needlessly calls hasNext for one too many elements,GROOVY-8271,13090495,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,cheeseheadtothe,cheeseheadtothe,27/Jul/17 11:49,06/Mar/18 23:25,14/Jul/23 06:02,01/Aug/17 05:34,2.4.12,,,,,,,,2.4.13,,,,groovy-jdk,,,,0,,,,,,,"I expect the {{TakeIterator}} to only call the {{hasNext()}} method for the delegate a maximum of {{N}} times where {{N}} is the number of elements to take.  If the iterator represents some expensive operations, or an unexhausted infinite stream that has exactly {{N}} elements available, the {{TakeIterator}} will block waiting for the {{Nth+1}} element only to return {{N}} of them.

In short, change the {{TakeIterator}}'s {{hasNext}} function from

            {{return delegate.hasNext() && num > 0;}}
to

            {{return num > 0 && delegate.hasNext();}}
",,cheeseheadtothe,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 01 05:34:26 UTC 2017,,,,,,,,,,"0|i3i33z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jul/17 11:56;githubbot;GitHub user MartyNeal opened a pull request:

    https://github.com/apache/groovy/pull/578

    Call iterators hasNext as last when simpler checks can be done first

    Addresses https://issues.apache.org/jira/browse/GROOVY-8271

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/MartyNeal/groovy GROOVY-8271

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/578.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #578
    
----
commit 16528d3b443d3c8c838c2b862e658285d211cf69
Author: Marty Neal <marty.neal@oracle.com>
Date:   2017-07-27T11:52:25Z

    Call iterators hasNext as late as possible where simpler checks can be done first

----
;;;","01/Aug/17 05:30;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/578
;;;","01/Aug/17 05:34;paulk;Fix applied - thanks!;;;",,,,,,,,,,,,,,,,,,,
Bug in @AutoImplement,GROOVY-8270,13090422,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,paulk,paulk,27/Jul/17 05:34,07/Dec/20 22:09,14/Jul/23 06:02,16/Nov/20 04:55,2.5.0-beta-1,,,,,,,,2.5.14,3.0.7,4.0.0-alpha-2,,,,,,0,,,,,,,"This works:
{code}
@AutoImplement
class MyClass implements Comparator {}
{code}
but this doesn't:
{code}
@AutoImplement
class MyClass implements Comparator<String> {}
{code}
The parameters aren't equal inside {{AutoImplementASTTransformation#getDeclaredMethodCorrected}} after correcting for generics (String vs Object).
",,dejan2609,jwagenleitner,paulk,,,,,,"eric-milles opened a new pull request #1418:
URL: https://github.com/apache/groovy/pull/1418


   https://issues.apache.org/jira/browse/GROOVY-8270


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;15/Nov/20 19:12;githubbot;600","asfgit closed pull request #1418:
URL: https://github.com/apache/groovy/pull/1418


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Nov/20 03:07;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 16 04:55:09 UTC 2020,,,,,,,,,,"0|i3i2nr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Jul/17 07:31;paulk;However {{Iterator<String>}} is fine.;;;","16/Nov/20 04:55;paulk;Proposed PR merged, thanks!;;;",,,,,,,,,,,,,,,,,,,,
ReturnStatement.toString() doesn't include its expression,GROOVY-8268,13090053,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,abayer,abayer,25/Jul/17 21:35,06/Mar/18 23:25,14/Jul/23 06:02,26/Jul/17 17:52,2.4.12,2.5.0-beta-1,,,,,,,2.4.13,,,,,,,,0,,,,,,,"{{ReturnStatement.toString()}} isn't implemented, so we don't get its expression included. This is a hassle when using debug printlns - obviously not a huge deal, but it'd be nice to fix.",,abayer,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 26 17:52:11 UTC 2017,,,,,,,,,,"0|i3i0e7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Jul/17 21:37;githubbot;GitHub user abayer opened a pull request:

    https://github.com/apache/groovy/pull/577

    [GROOVY-8268] Add toString() override to ReturnStatement

    [GROOVY-8268](https://issues.apache.org/jira/browse/GROOVY-8268)
    
    Truly trivial, I know. =)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/abayer/groovy groovy-8268

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/577.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #577
    
----
commit 7727d2ba704ac4068872f1aa4020a08b48d1ad5b
Author: Andrew Bayer <andrew.bayer@gmail.com>
Date:   2017-07-25T21:36:38Z

    [GROOVY-8268] Add toString() override to ReturnStatement

----
;;;","25/Jul/17 21:38;abayer;I've got a PR up at https://github.com/apache/groovy/pull/577;;;","26/Jul/17 17:49;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/577
;;;","26/Jul/17 17:52;paulk;Proposed PR applied. Thanks.;;;",,,,,,,,,,,,,,,,,,
GrabAnnotationTransformation.visit has unreachable code,GROOVY-8262,13087970,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,emilles,emilles,18/Jul/17 15:59,06/Mar/18 23:25,14/Jul/23 06:02,19/Jul/17 01:54,,,,,,,,,2.4.13,,,,,,,,0,,,,,,,"GrabAnnotationTransformation.visit at about line 260 has an else block that is unreachable.  I think the second predicate {{mval == null}} should be removed from the if condition.  This should give a more appropriate error message if an attribute is given with an empty or null value.

{code}
                            if (member == null || mval == null) {
                                addError(""The missing attribute \"""" + s + ""\"" is required in @"" + node.getClassNode().getNameWithoutPackage() + "" annotations"", node);
                                continue grabResolverAnnotationLoop;
                            } else if (mval == null) {
                                addError(""Attribute \"""" + s + ""\"" has value "" + member.getText() + "" but should be an inline constant String in @"" + node.getClassNode().getNameWithoutPackage() + "" annotations"", node);
                                continue grabResolverAnnotationLoop;
                            }
{code}",,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 19 01:54:54 UTC 2017,,,,,,,,,,"0|i3hnxr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jul/17 01:54;paulk;Thanks for spotting the issue. I did a slight variation on your suggestion.;;;",,,,,,,,,,,,,,,,,,,,,
Faulty getText implementations for ExpressionStatement & ThrowStatement,GROOVY-8261,13087709,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,jglick@netbeans.org,jglick@netbeans.org,17/Jul/17 19:38,06/Mar/18 23:25,14/Jul/23 06:02,18/Jul/17 05:59,2.4.12,,,,,,,,2.4.13,,,,,,,,0,,,,,,,"Retroactively filing for [PR 574|https://github.com/apache/groovy/pull/574]. Expression statements printed a {{toString}} representation which did not even vaguely resemble source code; you would expect the same source as the expression itself. {{throw}} statements did not get printed at all, just an unimplemented placeholder.",,githubbot,jglick@netbeans.org,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Tue Jul 18 05:58:54 UTC 2017,,,,,,,,,,"0|i3hmbr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jul/17 05:55;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/574
;;;","18/Jul/17 05:58;paulk;I think merging all the way back to 2_4_X should be fine. Thanks for the PR.;;;",,,,,,,,,,,,,,,,,,,,
Static compilation requires casting inside instanceof check,GROOVY-8260,13087481,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,Schlogen,Schlogen,17/Jul/17 06:00,06/Mar/18 23:25,14/Jul/23 06:02,24/Sep/17 11:49,2.4.12,,,,,,,,2.4.13,,,,Compiler,,,,0,,,,,,,"There are many times I find myself having to cast variables directly inside an {{instanceof Class}} check.

In addition, I have found a specific problem with a generic {{<T extends SomeClass>}} where a method in the class that returns {{T}}, Groovy believes a collection is being returned. This is the line in question: https://github.com/grails/gorm-graphql/blob/ea6887bef0ced75d9cc0d01dc7b94d4fc0520266/core/src/main/groovy/org/grails/gorm/graphql/fetcher/impl/EntityDataFetcher.groovy#L45

The goal of this issue is to have the following codebase compile without changes.

{{git clone -b broken_compilation https://github.com/grails/gorm-graphql}}

Attempt to compile with {{./gradlew clean classes}}",macOS JDK 1.8,githubbot,jwagenleitner,paulk,Schlogen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8336,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 24 11:49:52 UTC 2017,,,,,,,,,,"0|i3hkx3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Sep/17 03:39;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/603

    GROOVY-8260: Static compilation requires casting inside instanceof check

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8260

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/603.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #603
    
----
commit e8fd90ae974fa97817682c1c4f8936feef2d2a66
Author: paulk <paulk@asert.com.au>
Date:   2017-09-18T03:37:59Z

    GROOVY-8260: Static compilation requires casting inside instanceof check

----
;;;","24/Sep/17 09:46;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/603
;;;","24/Sep/17 11:49;paulk;Proposed PR applied. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,
Odd problems with flow typing and generics in Groovy 2.4.12+,GROOVY-8255,13087154,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,graemerocher1,graemerocher1,14/Jul/17 10:35,06/Mar/18 23:12,14/Jul/23 06:02,14/Nov/17 13:44,2.4.12,,,,,,,,2.4.13,,,,Static Type Checker,,,,0,,,,,,,"In order to get the GORM codebase to compile I had to make this change:

https://github.com/grails/grails-data-mapping/commit/1ef850c496d13d8ca915b27e76b6bfdb4e27377e

The code in question is:

{code}
    /**
     * Sets multipart values within the request body
     *
     * @param name The name of the multipart
     * @param value The value of the multipart
     */
    void setProperty(String name, value) {
        if (value instanceof File) {
            value = new FileSystemResource(value)
        }
        else if (value instanceof URL) {
            value = new UrlResource(value)
        }
        else if (value instanceof InputStream) {
            value = new InputStreamResource(value)
        }
        else if (value instanceof GString) {
            value = value.toString()
        }
        if( mvm[name] ) {
            mvm[name].add value    
        }
        else {
            mvm.put(name, [value]) // <--- FAILS COMPILATION HERE
        }        
    }
{code}

No matter what I tried I could not get it into to compile. The method accepts `put(String, List<Object>)` but fails compilation with:

{code}
RequestCustomizer.groovy: 392: [Static type checking] - Cannot call org.springframework.util.MultiValueMap <String, Object>#put(java.lang.String, java.lang.Object) with arguments [java.lang.String, java.util.List <java.lang.String>] 
 @ line 392, column 13.
               mvm.put(name, [value])
               ^
{code}

Altering the code to:

{code}
       List<Object> values = [value]
       mvm.put(name, values)
{code}

Fails with:

{code}
RequestCustomizer.groovy: 392: [Static type checking] - Incompatible generic argument types. Cannot assign java.util.List <java.lang.String> to: java.util.List <Object>
 @ line 392, column 35.
               List<Object> values = [value]
                                     ^

RequestCustomizer.groovy: 393: [Static type checking] - Cannot call org.springframework.util.MultiValueMap <String, Object>#put(java.lang.String, java.lang.Object) with arguments [java.lang.String, java.util.List <java.lang.String>] 
 @ line 393, column 13.
               mvm.put(name, values)
               ^

2 errors
{code}

",,githubbot,graemerocher1,jwagenleitner,paulk,Schlogen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 14 13:44:12 UTC 2017,,,,,,,,,,"0|i3hix3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Jul/17 10:36;graemerocher1;Update. This seems to work, but seems like it should not be necessary:

{code}
            List<Object> values = [(Object)value]
            mvm.put(name, values)
{code};;;","14/Jul/17 14:08;jwagenleitner;This looks like it might be related to GROOVY-8220 which was caused by flow typing parameters in GROOVY-8157.;;;","14/Jul/17 14:10;graemerocher1;Another incarnation of this problem has appeared:

https://travis-ci.org/grails/gorm-mongodb/builds/253607974#L430

Compilation error is:

{code}
EnumType.groovy: 144: [Static type checking] - Inconvertible types: cannot cast int to java.lang.Enum
 @ line 144, column 31.
                   value = getId((Enum)value)
                                 ^
{code}

It thinks that {{value}} is an integer which makes no sense given the logic:

{code}
        if (value instanceof Enum) {
            if (isOrdinalTypeEnum(property)) {
                value = ((Enum) value).ordinal()
            } else if (value.hasProperty(GormProperties.IDENTITY)) {
                value = getId((Enum)value)
            } else {
                value = ((Enum)value).name()
            }
        }
{code}

See https://github.com/grails/gorm-mongodb/blob/master/grails-datastore-gorm-mongodb/src/main/groovy/org/grails/datastore/gorm/mongo/simple/EnumType.groovy#L144

Seems Groovy is not taking into account the conditional logic when associated the type with an untyped value. It is associating the return type of {{original()}} in the previous {{if}} block with the {{value}} which is incorrect.;;;","21/Jul/17 13:07;Schlogen;Another example 

{{[Static type checking] - Cannot loop with element of type graphql.language.Selection with collection of type java.util.List <? extends java.lang.Object>}}

{code}
@Grab(group='com.graphql-java', module='graphql-java', version='2.4.0')

import graphql.language.*
import graphql.schema.*

@groovy.transform.CompileStatic
class Foo {
    
   void getFetchArguments(DataFetchingEnvironment environment) {
        for (Field field: environment.fields) {
            List<Selection> selections = field.selectionSet?.selections ?: []
            for (Selection selection: selections) {
                def x
            }
        }
    }
}
{code};;;","24/Sep/17 13:37;paulk;Standalone example:
{code}
@groovy.transform.CompileStatic
class Foo {
    List<List<String>> items = [['x']]
    def bar() {
        def result = []
        List<String> selections = items.get(0) ?: [] // ['y'] okay
        for (String selection: selections) {
            result << selection
        }
        result
    }
}

assert new Foo().bar() == ['x']
// [Static type checking] - Incompatible generic argument types.
// Cannot assign java.util.List <? extends java.lang.Object>
// to: java.util.List <String>
{code};;;","13/Nov/17 08:44;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/635

    GROOVY-8255: Odd problems with flow typing and generics in Groovy 2.4…

    ….12+ (target typing for empty literals within Ternary/Elvis)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8255

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/635.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #635
    
----
commit 6c35dcff589929cf80b2e79a246b35aae4afec2a
Author: paulk <paulk@asert.com.au>
Date:   2017-11-13T08:43:02Z

    GROOVY-8255: Odd problems with flow typing and generics in Groovy 2.4.12+ (target typing for empty literals within Ternary/Elvis)

----
;;;","13/Nov/17 12:11;paulk;I was planning to close this issue with the proposed PR. The instanceof cases have already been handled in other issues. If there are any remaining ""Odd problems"", they can be raised as separate issues.;;;","14/Nov/17 10:57;githubbot;Github user melix commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/635#discussion_r150800145
  
    --- Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java ---
    @@ -3461,6 +3465,36 @@ public void visitTernaryExpression(final TernaryExpression expression) {
             popAssignmentTracking(oldTracker);
         }
     
    +    // currently just for empty literals, not for e.g. Collections.emptyList() at present
    +    /// it seems attractive to want to do this for more cases but perhaps not all cases
    +    private ClassNode checkForTargetType(final Expression expr, final ClassNode type) {
    +        if (typeCheckingContext.getEnclosingBinaryExpression() != null && isEmptyCollection(expr)) {
    +            int op = typeCheckingContext.getEnclosingBinaryExpression().getOperation().getType();
    +            if (isAssignment(op)) {
    +                VariableExpression target = (VariableExpression) typeCheckingContext.getEnclosingBinaryExpression().getLeftExpression();
    +                return adjustForTargetType(target.getType(), type);
    +            }
    +        }
    +        return type;
    +    }
    +
    +    private ClassNode adjustForTargetType(final ClassNode targetType, final ClassNode resultType) {
    +        if (targetType.isUsingGenerics() && missesGenericsTypes(resultType)) {
    +            // unchecked assignment within ternary/elvis
    +            // examples:
    +            // List<A> list = existingAs ?: []
    +            // in that case, the inferred type of the RHS is the type of the RHS
    +            // ""completed"" with generics type information available in the LHS
    +            return GenericsUtils.parameterizeType(targetType, resultType.getPlainNodeReference());
    +        }
    +        return resultType;
    +    }
    +
    +    private boolean isEmptyCollection(Expression expr) {
    --- End diff --
    
    Could be static.
;;;","14/Nov/17 12:17;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/635
;;;","14/Nov/17 13:44;paulk;Proposed PR applied.;;;",,,,,,,,,,,,
Groovy console fails to launch,GROOVY-8253,13085661,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,daniel_sun,daniel_sun,08/Jul/17 07:52,09/Feb/22 01:16,14/Jul/23 06:02,08/Jul/17 19:34,3.0.0-alpha-1,,,,,,,,2.6.0-alpha-1,,,,Groovy Console,,,,0,,,,,,,"The issue can be reproduced by executing {{me.sunlan.groovyconsole.GroovyConsole#main}} at https://github.com/danielsun1106/groovyconsole

*Fails to launch(groovy 3.0.0 snapshot)*
https://github.com/danielsun1106/groovyconsole/releases/tag/0.0.1

*Launch successfully(groovy 2.4.12)*
https://github.com/danielsun1106/groovyconsole/releases/tag/0.0.2

*Error messages:*
{code:java}
Exception in thread ""main"" groovy.lang.MissingMethodException: No signature of method: javax.swing.JMenu.setMnemonic() is applicable for argument types: (String) values: [F]
Possible solutions: setMnemonic(char), setMnemonic(int), getMnemonic()
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:60)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.unwrap(ScriptBytecodeAdapter.java:66)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:81)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:174)
	at groovy.ui.view.BasicMenuBar$_run_closure1.doCall(BasicMenuBar.groovy:26)
	at groovy.ui.view.BasicMenuBar$_run_closure1.doCall(BasicMenuBar.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:98)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:294)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:989)
	at groovy.lang.Closure.call(Closure.java:415)
	at groovy.lang.Closure.call(Closure.java:409)
	at groovy.util.FactoryBuilderSupport.dispatchNodeCall(FactoryBuilderSupport.java:889)
	at groovy.util.FactoryBuilderSupport.doInvokeMethod(FactoryBuilderSupport.java:781)
	at groovy.util.FactoryBuilderSupport.invokeMethod(FactoryBuilderSupport.java:501)
	at groovy.util.FactoryInterceptorMetaClass.invokeMethod(FactoryBuilderSupport.java:1312)
	at groovy.lang.GroovyObjectSupport.invokeMethod(GroovyObjectSupport.java:46)
	at groovy.lang.Script.invokeMethod(Script.java:80)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:75)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:166)
	at groovy.ui.view.BasicMenuBar.run(BasicMenuBar.groovy:25)
	at groovy.util.FactoryBuilderSupport.build(FactoryBuilderSupport.java:1171)
	at groovy.util.FactoryBuilderSupport.build(FactoryBuilderSupport.java:1154)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:98)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:384)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:69)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:166)
	at groovy.ui.Console$__clinit__closure26.doCall(Console.groovy:337)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:98)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:294)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:989)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.call(PogoMetaClassSite.java:42)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at groovy.ui.ConsoleView$_run_closure1.doCall(ConsoleView.groovy:59)
	at groovy.ui.ConsoleView$_run_closure1.doCall(ConsoleView.groovy)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:98)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:294)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:989)
	at groovy.lang.Closure.call(Closure.java:415)
	at groovy.lang.Closure.call(Closure.java:409)
	at groovy.util.FactoryBuilderSupport.dispatchNodeCall(FactoryBuilderSupport.java:889)
	at groovy.util.FactoryBuilderSupport.doInvokeMethod(FactoryBuilderSupport.java:781)
	at groovy.util.FactoryBuilderSupport.invokeMethod(FactoryBuilderSupport.java:501)
	at groovy.util.FactoryInterceptorMetaClass.invokeMethod(FactoryBuilderSupport.java:1312)
	at groovy.lang.GroovyObjectSupport.invokeMethod(GroovyObjectSupport.java:46)
	at groovy.lang.Script.invokeMethod(Script.java:80)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:75)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:174)
	at groovy.ui.ConsoleView.run(ConsoleView.groovy:56)
	at groovy.util.FactoryBuilderSupport.build(FactoryBuilderSupport.java:1171)
	at groovy.util.FactoryBuilderSupport.build(FactoryBuilderSupport.java:1154)
	at groovy.util.FactoryBuilderSupport$build$4.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at groovy.ui.Console.run(Console.groovy:378)
	at groovy.ui.Console$run$0.callCurrent(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:166)
	at groovy.ui.Console.run(Console.groovy:341)
	at me.sunlan.groovyconsole.GroovyConsole.main(GroovyConsole.java:11)

{code}
",,daniel_sun,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10475,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jul 09 01:11:30 UTC 2017,,,,,,,,,,"0|i3h9qv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Jul/17 18:43;jwagenleitner;Looks like after [commit 23e6093921e06|https://github.com/apache/groovy/commit/23e6093921e06fcd73dabe67ce5be549a6cd63f9] the extension modules are not being written in the groovy-all jar.  The missing method should be added by the {{SwingGroovyMethods}} class.

{code:title=groovy-all-3.0.0-SNAPSHOT.jar:META-INF/services/ExtensionModule}
# This is a generated file, do not edit
moduleName=groovy-all
moduleVersion=3.0.0-SNAPSHOT
extensionClasses=
staticExtensionClasses=
{code};;;","08/Jul/17 19:34;jwagenleitner;Should be fixed by https://github.com/apache/groovy/commit/35aba7c0cf710b1337935f266ac6e6e6bef82c92;;;","09/Jul/17 01:11;daniel_sun;The issue is fixed. Thank you, John :);;;",,,,,,,,,,,,,,,,,,,
AIOOBE in combination of ncurry and rcurry,GROOVY-8252,13085307,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,daniilo,daniilo,06/Jul/17 19:25,06/Mar/18 23:25,14/Jul/23 06:02,09/Oct/17 08:39,2.4.12,,,,,,,,2.4.13,2.5.0-beta-3,,,,,,,0,,,,,,,"{code}
def c = { a, b, c, d -> println a + b + c + d }
c.ncurry(0, ""a"").rcurry(""c"", ""d"")() // note no args passed
{code}

Expected: MissingMethodException or {{null}} passed.
Actual:
{noformat}
java.lang.ArrayIndexOutOfBoundsException
at java_util_concurrent_Callable$call.call(Unknown Source)
{noformat}
",,daniilo,githubbot,jkemnade,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 09 08:39:02 UTC 2017,,,,,,,,,,"0|i3h7l3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Jul/17 12:28;jkemnade;I can reproduce this with 2.5.0-beta-1, and also with a simpler example:
{code}
def c = { a, b, c -> println a + b + c }
c.rcurry(""b"", ""c"")()
{code}
{noformat}
Exception in thread ""main"" java.lang.ArrayIndexOutOfBoundsException
	at java.lang.System.arraycopy(Native Method)
	at org.codehaus.groovy.runtime.CurriedClosure.getUncurriedArguments(CurriedClosure.java:103)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1084)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1022)
	at groovy.lang.Closure.call(Closure.java:414)
	at groovy.lang.Closure.call(Closure.java:408)
	at java_util_concurrent_Callable$call.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at Test.run(Test.groovy:3)
{noformat};;;","02/Oct/17 01:31;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/612

    GROOVY-8252: AIOOBE in combination of ncurry and rcurry

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8252

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/612.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #612
    
----
commit 1fc4449df4a9359275131a341b9a4e9390705cdd
Author: paulk <paulk@asert.com.au>
Date:   2017-10-02T01:29:43Z

    GROOVY-8252: AIOOBE in combination of ncurry and rcurry

----
;;;","09/Oct/17 06:08;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/612
;;;","09/Oct/17 08:39;paulk;Proposed PR applied. So expected behavior is now no AIOOBE but there can be an IllegalArgumentException in the case of ncurry if insufficient arguments are provided to fill up the space before the specified index value. If the documentation still seems unclear, please let me know.;;;",,,,,,,,,,,,,,,,,,
Implement withCloseable on AutoCloseable,GROOVY-8251,13085251,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,henri,henri,06/Jul/17 14:50,06/Mar/18 23:25,14/Jul/23 06:02,18/Jul/17 02:00,2.5.0-beta-1,,,,,,,,2.5.0-beta-2,,,,groovy-jdk,,,,2,,,,,,,"The Groovy implementation of try-with-resource is through {{withCloseable()}}. The problem is that {{withCloseable}} only exists for classes implementing the {{Closeable}} interface.

But a try-with-resource works with the {{AutoCloseable}} interface. So {{withCloseable}} should probably be moved on step below to {{AutoCloseable}} (that {{Closeable}} extends).",,githubbot,jwagenleitner,kha,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7572,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 18 02:00:23 UTC 2017,,,,,,,,,,"0|i3h78v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jul/17 16:24;jwagenleitner;Looks like GROOVY-7572 added a {{withAutoCloseable}} method in the NIO submodule and it's in 2.5.  Since 2.5 is Java 7+ it may make more sense to move the new method into core rather than NIO.;;;","06/Jul/17 16:42;henri;Ok. That's the explanation. I saw {{withAutoCloseable}} but it was not available indeed. I thought. Moving it to core would make sense. But in fact I'm not sure it's really useful to have two methods for the same thing unless there is a technical limitation forcing it.;;;","06/Jul/17 18:19;jwagenleitner;My initial thought was sort of the same, just add a {{withCloseable(AutoCloseable..) throws Exception}} method.  I don't think there is any limitation, other than the old {{withCloseable(Closeable..) throws IOException}} method would probably need to be kept for binary compatibility.  The {{throws}} clause of the old method would probably need to change but don't think that is a problem.

There may be some confusion with the name {{withCloseable}} taking either a {{Closeable}} or {{AutoCloseable}}, given that {{AutoCloseable}} is the more general type.  But I like the concise name {{withCloseable}} more.;;;","06/Jul/17 18:26;henri;Yes. Because let's be fair, the only reason we have {{AutoCloseable}} today is because {{Closeable}} was typed {{IOException}}. Starting from scratch, we would only have {{Closeable}} throwing an exception.;;;","09/Jul/17 01:27;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/572

    GROOVY-8251: Implement withCloseable on AutoCloseable

    `NioGroovyMethods.withAutoCloseable` was added for 2.5.0 as part of [GROOVY-7572](https://issues.apache.org/jira/browse/GROOVY-7572).  It appears it was originally placed here because at the time Java 6 was still used, but now 2.5.0 is 7+.
    
    First commit proposes moving the method (as-is) into the core `IOGroovyMethods` class.  This is where the `withCloseable(java.io.Closeable...)` method is, so also part of this change is moving the tests for it from NIO to core.  Since 2.5.0 is not been officially released I don't think there is a need to deprecate or worry about binary compatibility for the `withAutoCloseable` method.
    
    Second commit proposes to rename the new but unreleased method from `withAutoCloseable` to `withCloseable` to match the existing method on `java.io.Closeable`.  See discussion on [GROOVY-8251](https://issues.apache.org/jira/browse/GROOVY-8251).

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8251-AutoCloseable

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/572.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #572
    
----
commit 912200153193849fc35a09a053898d46c7f1dacd
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-07-09T00:22:36Z

    GROOVY-8251: Implement withCloseable on AutoCloseable
    
    Relocate withAutoCloseable from NIO subproject to core. Since
    AutoCloseable is not an NIO related class and release 2.5.0
    will target Java 7, the method should be available as part
    of core.
    
    Relocated withCloseable tests to core since that method
    is deprecated in the NIO module.

commit 261bc174980da8d6b6f4cdb54b8f0ab98c64c4fd
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-07-09T01:13:48Z

    GROOVY-8251: rename withAutoCloseable to withCloseable

----
;;;","18/Jul/17 01:49;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/572
;;;","18/Jul/17 02:00;jwagenleitner;Thanks for reporting the issue.  The {{withAutoCloseable}} method has been moved from the NIO subproject to core and renamed {{withCloseable}} to be consistent with the existing method for {{java.io.Closeable}}.;;;",,,,,,,,,,,,,,,
VariableScopeVisitor does not set declaring class on property nodes,GROOVY-8250,13084946,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,emilles,emilles,05/Jul/17 19:53,21/Feb/19 06:16,14/Jul/23 06:02,21/Feb/19 06:16,,,,,,,,,2.5.3,3.0.0-alpha-4,,,,,,,0,,,,,,,"VariableScopeVisitor.findClassMember creates PropertyNode instances for methods (ex: foo.bar will have a property node created if getBar() is implemented).  This is done inside the MethodNode for loop circa line 165.

The nodes created by this visitor lack a declaring class setting as well as having an improper type.  Without these values, type inferencing is more difficult for anyone that processes the AST.  These are reasonable simple to remedy:
{code}
    private Variable findClassMember(ClassNode cn, String name) {
        if (cn == null) return null;
        if (cn.isScript()) {
            return new DynamicVariable(name, false);
        }

        for (FieldNode fn : cn.getFields()) {
            if (fn.getName().equals(name)) return fn;
        }

        for (MethodNode mn : cn.getMethods()) {
            String pName = getPropertyName(mn);
            // GRECLIPSE edit
            //if (pName != null && pName.equals(name))
            //    return new PropertyNode(pName, mn.getModifiers(), ClassHelper.OBJECT_TYPE, cn, null, null, null);
            if (pName != null && pName.equals(name)) {
                PropertyNode property = new PropertyNode(pName, mn.getModifiers(), getPropertyType(mn), cn, null, null, null);
                property.getField().setDeclaringClass(cn);
                property.setDeclaringClass(cn);
                return property;
            }
            // GRECLIPSE end
        }
        ...

    // GRECLIPSE add
    private ClassNode getPropertyType(MethodNode m) {
        if (m.getReturnType() != ClassHelper.VOID_TYPE) {
            return m.getReturnType();
        }
        return m.getParameters()[0].getType();
    }
    // GRECLIPSE end
{code}",,daniel_sun,emilles,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 21 06:16:44 UTC 2019,,,,,,,,,,"0|i3h5d3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Aug/17 00:01;jwagenleitner;Setting the type on the property based on the first match will cause a problem if there are multiple setters for the given property.  For reference, [commit 4f28eab3cc|https://github.com/apache/groovy/commit/4f28eab3cca03a15ca146c7c8301f5ecddf6fa89] contains tests that will fail if the first resolved setter parameter type is chosen.

One alternative may be to check all methods and if a single type if found use it else fall back to Object.;;;","20/Feb/19 16:37;emilles;I believe this got included in a recent release.  Could the appropriate release notes be updated and this ticket be closed?;;;","21/Feb/19 05:46;daniel_sun;[~emilles] Do you have any test case to verify the fix?;;;","21/Feb/19 06:16;paulk;Fixed as part of GROOVY-8797, but see the comments wrt limitations on being able to set the type. If you believe the type information needs further work, please open a new issue.;;;",,,,,,,,,,,,,,,,,,
@Newify on local variable declaration fails to resolve class expression,GROOVY-8249,13084584,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,emilles,emilles,04/Jul/17 15:11,06/Mar/18 23:25,14/Jul/23 06:02,27/Sep/17 09:32,,,,,,,,,2.4.13,,,,,,,,0,,,,,,,"If I use {{@Newify}} on a local variable declaration, I am getting an error that the class value is not resolvable.

{code}
@Newify(Date)
def d = Date(1234L)
{code}
results in:
{code}
Script1.groovy: 1: Error during @Newify processing. Annotation parameter must be a class or list of classes but found an unresolvable reference to 'Date'.
 @ line 1, column 9.
   @Newify(Date)
           ^
{code}

It looks like org.codehaus.groovy.classgen.VariableScopeVisitor.visitDeclarationExpression is missing a call to visitAnnotations.  Classes, fields, and methods all have this call.  When I add it, the VariableExpression resolves to a ClassExpression as expected.",,emilles,githubbot,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 27 09:32:29 UTC 2017,,,,,,,,,,"0|i3h35b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Aug/17 01:01;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/584

    GROOVY-8249: Newify local variable declaration fails to resolve class…

    … expression

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8249-Newify-VarDecl-ClassResolve

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/584.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #584
    
----
commit 2c11c1b72ff47e6c5ccb2134a7ea86da8cabc028
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-08-14T00:15:00Z

    GROOVY-8249: Newify local variable declaration fails to resolve class expression

----
;;;","27/Sep/17 08:06;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/584
;;;","27/Sep/17 09:32;paulk;Thanks for the PR John (merged) and thanks for spotting the issue Eric.;;;",,,,,,,,,,,,,,,,,,,
AIOOBE in StaticTypeCheckingVisitor with SAM and explicit closure parameter,GROOVY-8247,13084502,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,daniilo,daniilo,04/Jul/17 10:36,09/Sep/22 00:02,14/Jul/23 06:02,14/Sep/17 10:24,2.4.10,,,,,,,,2.4.13,,,,Static compilation,Static Type Checker,,,0,,,,,,,"{code}
def runnable(Runnable r) {
    r.run()
}
@CompileStatic
def foo() {
    runnable { it -> // note explicit it
        println it
    }
}
foo()
{code}

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during instruction selection: 0

java.lang.ArrayIndexOutOfBoundsException: 0
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferSAMType(StaticTypeCheckingVisitor.java:2424)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferClosureParameterTypes(StaticTypeCheckingVisitor.java:2362)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallArguments(StaticTypeCheckingVisitor.java:2326)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:3030)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:358)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:196)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:42)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:37)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:166)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:104)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:115)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1816)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:126)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2151)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2110)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:185)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:76)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:134)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:178)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1065)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:603)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:581)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:558)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:688)
	at groovy.lang.GroovyShell.run(GroovyShell.java:517)
	at groovy.lang.GroovyShell.run(GroovyShell.java:507)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:653)
	at groovy.ui.GroovyMain.run(GroovyMain.java:384)
	at groovy.ui.GroovyMain.process(GroovyMain.java:370)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:129)
	at groovy.ui.GroovyMain.main(GroovyMain.java:109)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131)
{noformat}",,daniilo,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8246,GROOVY-6939,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 14 10:24:22 UTC 2017,,,,,,,,,,"0|i3h2n3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Jul/17 10:38;daniilo;I've created two separate issues because of different stack traces. Please mark GROOVY-8247 as duplicate if it's actually a duplicate.;;;","14/Sep/17 09:42;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/600

    GROOVY-8247: AIOOBE in StaticTypeCheckingVisitor with SAM and explici…

    …t closure parameter

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8247

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/600.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #600
    
----
commit afb5302b0f447e73adbda62aa22c4d63ff1d4c48
Author: paulk <paulk@asert.com.au>
Date:   2017-09-14T09:38:17Z

    GROOVY-8247: AIOOBE in StaticTypeCheckingVisitor with SAM and explicit closure parameter

----
;;;","14/Sep/17 10:19;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/600
;;;","14/Sep/17 10:24;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,
AIOOBE in StaticTypeCheckingVisitor with SAM ,GROOVY-8246,13084500,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,daniilo,daniilo,04/Jul/17 10:33,06/Mar/18 23:25,14/Jul/23 06:02,14/Sep/17 10:24,2.4.10,,,,,,,,2.4.13,,,,Static compilation,Static Type Checker,,,0,,,,,,,"{code}
def runnable(Runnable r) {
    r.run()
}
@CompileStatic
def foo() {
    runnable {
        println it
    }
}
foo()
{code}

{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during instruction selection: 0

at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.getType(StaticTypeCheckingVisitor.java:3996)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.getArgumentTypes(StaticTypeCheckingVisitor.java:1956)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2829)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:358)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:196)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:42)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:37)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:166)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitClosureExpression(CodeVisitorSupport.java:176)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClosureExpression(StaticTypeCheckingVisitor.java:2021)
	at org.codehaus.groovy.ast.expr.ClosureExpression.visit(ClosureExpression.java:45)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallArguments(StaticTypeCheckingVisitor.java:2329)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:3030)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:358)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:196)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:42)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:37)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:166)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:104)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:115)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1816)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:126)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2151)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2110)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:185)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:76)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:134)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:178)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1065)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:603)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:581)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:558)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:688)
	at groovy.lang.GroovyShell.run(GroovyShell.java:517)
	at groovy.lang.GroovyShell.run(GroovyShell.java:507)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:653)
	at groovy.ui.GroovyMain.run(GroovyMain.java:384)
	at groovy.ui.GroovyMain.process(GroovyMain.java:370)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:129)
	at groovy.ui.GroovyMain.main(GroovyMain.java:109)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131)
{noformat}",,daniilo,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8247,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 14 10:24:42 UTC 2017,,,,,,,,,,"0|i3h2mn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Sep/17 09:42;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/601

    GROOVY-8246: AIOOBE in StaticTypeCheckingVisitor with SAM

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8246

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/601.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #601
    
----
commit 9d084e2980c4379efa2fee6ec5bb929bca9f31a0
Author: paulk <paulk@asert.com.au>
Date:   2017-09-14T09:41:00Z

    GROOVY-8246: AIOOBE in StaticTypeCheckingVisitor with SAM

----
;;;","14/Sep/17 10:19;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/601
;;;","14/Sep/17 10:24;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,
@Newify(auto=false) causing error (in Groovy Web Console),GROOVY-8245,13083899,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,emilles,emilles,30/Jun/17 19:27,06/Mar/18 23:25,14/Jul/23 06:02,06/Aug/17 04:14,,,,,,,,,2.4.13,,,,,,,,0,,,,,,,"When I run this with no {{auto=flase}} attribute or with {{auto=true}}, it runs successfully (in Groovy Web Console).  When I run as below, I get a strange error: {code}
java.lang.ExceptionInInitializerError
	at Script1.run(Script1.groovy:15)
Caused by: groovy.lang.MissingMethodException: No signature of method: static Bar.Foo() is applicable for argument types: () values: []
Possible solutions: any(), is(java.lang.Object), any(groovy.lang.Closure), use([Ljava.lang.Object;), use(java.util.List, groovy.lang.Closure), use(java.lang.Class, groovy.lang.Closure)
	at Bar.<clinit>(Script1.groovy:10)
{code}

{code}
class Foo {
  Foo() {
    println 'new foo'
  }
}

@Newify(auto=false, value=Foo)
class Bar {
  static {
    Foo foo = Foo()
  }
  static void method() {}
}

​Bar.method()
{code}",,emilles,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 06 04:14:41 UTC 2017,,,,,,,,,,"0|i3gyxj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Jul/17 20:37;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/571

    GROOVY-8245: @Newify(auto=false) not transforming declarations

    Also added default for `value` attribute for [GROOVY-8242](https://issues.apache.org/jira/browse/GROOVY-8242).

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8245-Newify

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/571.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #571
    
----
commit f2c80cf2403e40b7c7f22eaa778bec35a8c80bee
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-07-04T16:37:04Z

    GROOVY-8245: @Newify(auto=false) not transforming declarations

----
;;;","06/Aug/17 04:02;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/571
;;;","06/Aug/17 04:14;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,
SAM trait coercion with default parameters,GROOVY-8244,13083839,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,daniilo,daniilo,30/Jun/17 16:18,12/Oct/22 20:17,14/Jul/23 06:02,25/Mar/22 20:02,2.4.10,,,,,,,,2.5.19,3.0.11,4.0.2,,,,,,0,trait,traits,,,,,"{code}
trait T {
    abstract def foo(a, b = 1)
}

T t = { o1, o2 ->
    println o1
    assert o2 == 1
}
t.foo(42) // Caught: groovy.lang.MissingMethodException: No signature of method: abstractMethod$_run_closure1.doCall() is applicable for argument types: (java.lang.Integer) values: [42]
{code}

Expected result: it should just work or throw GroovyCastException in case of traits are not SAM candidates",,daniilo,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10717,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 25 20:02:52 UTC 2022,,,,,,,,,,"0|i3gyk7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Mar/22 20:02;emilles;https://github.com/apache/groovy/commit/aa173c4d5740a3c3e3dcb901a2c30e64c4891fce;;;",,,,,,,,,,,,,,,,,,,,,
SAM trait coercion via middle interface,GROOVY-8243,13083831,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,daniilo,daniilo,30/Jun/17 15:50,12/Oct/22 18:31,14/Jul/23 06:02,21/Mar/22 04:48,2.4.10,,,,,,,,2.5.19,3.0.11,4.0.2,,,,,,0,trait,traits,,,,,"{code}
trait T {
    abstract def foo(int i)

    def bar(double j) {
        println ""bar $j""
    }
}
interface F extends T {}

F t = { println ""closure $it"" }
t.foo(42) // `closure 42`
t.bar(43) // `closure 43.0`; should be `bar 43.0`
{code}

Changing variable type to {{T}} works as expected.",,chessami92,daniilo,emilles,paulk,,,,,"eric-milles opened a new pull request #1704:
URL: https://github.com/apache/groovy/pull/1704


   https://issues.apache.org/jira/browse/GROOVY-8243


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Mar/22 19:46;githubbot;600","paulk-asert merged pull request #1704:
URL: https://github.com/apache/groovy/pull/1704


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;21/Mar/22 04:44;githubbot;600","paulk-asert commented on pull request #1704:
URL: https://github.com/apache/groovy/pull/1704#issuecomment-1073482452


   Merged, thanks!


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;21/Mar/22 04:48;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 04 18:29:22 UTC 2022,,,,,,,,,,"0|i3gyif:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Jun/17 16:11;daniilo;If traits are not SAM candidates, please  throw GroovyCastException on assignment.;;;","19/Mar/22 19:35;emilles;The trait presents as this interface to the JVM:
{code:java}
interface T {
  Object foo(int i);
  Object bar(double j);
}
{code}

So when {{java.lang.reflect.Proxy}} is created for the closure and interface {{F}}, both {{foo(int)}} and {{bar(double)}} are routed to the closure.

If GROOVY-8299 is completed, it is possible that non-abstract, public trait methods could be implemented as native default interface methods.  However, that ticket is about interfaces and may or may not affect traits.  GROOVY-10000 is another ticket that suggests to me that some consistency between interfaces and traits for static finals and non-private, non-static methods is expected.;;;","20/Mar/22 19:52;emilles;https://github.com/apache/groovy/pull/1704

If there is more than one abstract method, then the coerce will still work the way described in the problem since it falls to the Java {{Proxy}} path.  In that case, you can use a map with more than one closure, like:
{code:groovy}
F f = [foo: { ... }, baz: { ... }]
{code};;;","21/Mar/22 04:48;paulk;Proposed PR merged, thanks!;;;","02/Aug/22 21:19;chessami92;Not sure if this is the appropriate ticket, but as of 3.0.11 the below code no longer works; it now prints out {{null}} instead of {{{}string b{}}}. Seems like it is relying on the native object instead of the {{{}$closure$delegate$map{}}}?

{code:java}
abstract class A {
    String b
}

def a = [getB: { 'string b' }] as A
println a.b
{code};;;","02/Aug/22 21:30;emilles;Please create a new ticket.  You can link-to/reference any others you think are relevant.;;;","03/Aug/22 21:32;emilles;Map to type coercion is briefly described here, but there is no mention of what happens if the type supplies some methods. https://groovy-lang.org/semantics.html#_map_to_type_coercion;;;","04/Aug/22 18:29;chessami92;Created GROOVY-10717;;;",,,,,,,,,,,,,,
Javadoc for Newify is missing some attribute values,GROOVY-8242,13083827,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,emilles,emilles,30/Jun/17 15:37,06/Mar/18 23:25,14/Jul/23 06:02,06/Aug/17 04:13,,,,,,,,,2.4.13,,,,,,,,0,,,,,,,"I was looking at thw Newify AST transform.  Some of the Javadoc appears incorrect since the annotation requires a value.

{code}
 * or this (""Ruby-style""):
 * <pre>
 * {@code @Newify} class MyTreeProcessor {  --  Is this supposed to be @Newify([Tree,Leaf])?
 *     def myTree = Tree.new(Tree.new(Leaf.new(""A""), Leaf.new(""B"")), Leaf.new(""C""))
 *     def process() { ... }
 * }
 * </pre>
{code}

{code}
 * An example showing how to use the annotation at different levels:
 * <pre>
 * {@code @Newify(auto=false, value=Foo)}
 * class Main {
 *     {@code @Newify} // turn auto on for field  --  Is this supposed to be @Newify(BigInteger)?
 *     def field1 = java.math.BigInteger.new(42)
 *     def field2, field3, field4
 *
 *     {@code @Newify(Bar)}
 *     def process() {
 *         field2 = Bar(""my bar"")
 *     }
 *
 *     {@code @Newify(Baz)}
 *     Main() {
 *         field3 = Foo(""my foo"")
 *         field4 = Baz(""my baz"")
 *     }
 * }
 * </pre>
{code}",,emilles,githubbot,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 06 10:31:50 UTC 2017,,,,,,,,,,"0|i3gyhj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jul/17 20:47;jwagenleitner;I believe the javadoc code is valid.  You can omit providing a value if using the Ruby style, {{Integer.new(7)}}, unless {{auto=false}} is set.  The value is required when using the Python style, {{Integer(7)}} as noted in this line from the javadoc:

{quote}The ""Python-style"" conversions require you to specify each class on which you want them to apply.{quote};;;","04/Jul/17 15:06;emilles;But the value attribute does not have a default value.  So if none is set, I get warnings that I must set it.;;;","04/Jul/17 16:26;jwagenleitner;Based on the docs and tests, I believe it's clear that the intent of {{Newify}} is to allow the annotation without providing class values.  Assuming that's true then this issue should be about providing a default for that attribute in order to avoid warnings.;;;","04/Jul/17 20:39;jwagenleitner;As part of the PR for GROOVY-8245 I added a default for the {{value}} attribute.;;;","05/Jul/17 00:15;emilles;Thanks for the fix.  I tried the annotation in Groovy Console without class values and the Ruby-style ""new"" static method does indeed work.  Now I just need to figure out how to provide content assist for this in Eclipse since it is a bit wider open than the explicit class value form.  But again, thanks.;;;","05/Aug/17 21:13;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/579

    GROOVY-8242: @Newify default attribute value

    Class values are only required for Python-style conversions so the
    attribute should default to an empty array to indicate it is not
    strictly required.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8242-Newify-value-default

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/579.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #579
    
----
commit e68a7c7ca60e9c6453565bbb91720dfe6479567c
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-08-05T18:05:17Z

    GROOVY-8242: @Newify default attribute value
    
    Class values are only required for Python-style conversions so the
    attribute should default to an empty array to indicate it is not
    strictly required.

----
;;;","06/Aug/17 04:02;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/579
;;;","06/Aug/17 04:13;jwagenleitner;Thanks for reporting the issue, default has been added for the value attribute to denote it's not required (in cases when using the Ruby-style).;;;","06/Aug/17 10:31;paulk;Just for historical reference, I don't believe the Groovy compiler will complain for all cases where an annotation attribute has no default and is not supplied with one when not used. There are several cases:

# If the annotation and usage are both Groovy/same source unit I think you will normally see (for the {{value}} annotation attribute as an example):
{code}
No explicit/default value found for annotation attribute 'value' in @MyAnnotation
{code}
# If the annotation is Java/pre-compiled and it has SOURCE retention, Groovy will keep quiet.
# If the annotation is Java/pre-compiled and it has RUNTIME retention you will see the JVM complain:
{code}
java.lang.annotation.IncompleteAnnotationException: MyAnnotation missing element value
{code}

I suspect that at least the last of these, case (3), is a bug. I presume in earlier versions of the JVM and/or ASM libraries reading an annotation for the Java/pre-compiled case with no default value triggered the same check as for Groovy above, case (1),  but now it yields a {{ReturnStatement}} containing {{null}} as the return value and this avoids detection. Probably the second is also a bug provided annotation processing is finished which I think will be true since the mandatory attribute check is done during classgen.

In any case, it doesn't affect this issue. I.e. the issue is valid and PR good. I'll create an additional issue to track this.;;;",,,,,,,,,,,,,
SAM parameter type inference for explicit parameter,GROOVY-8241,13083778,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,daniilo,daniilo,30/Jun/17 13:14,20/Feb/18 04:18,14/Jul/23 06:02,13/Dec/17 04:56,2.4.10,,,,,,,,2.4.14,2.5.0-beta-3,2.6.0-alpha-3,3.0.0-alpha-2,Static compilation,Static Type Checker,,,0,,,,,,,"{code}
import groovy.transform.CompileStatic
import java.util.function.Predicate

@CompileStatic
static boolean foo(Predicate<? super String> p) {
    p.test(""foo"")
}

@CompileStatic
static def testPredicate() {
    foo { // it ->
        it.toUpperCase()
        true
    }
}
{code}

Uncomment {{it}}, compiler will say: 
{noformat}
Cannot find matching method java.lang.Object#toUpperCase()
{noformat}",,Alexey Afanasiev,daniel_sun,daniilo,githubbot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6888,GROOVY-8476,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Feb 14 18:47:23 UTC 2018,,,,,,,,,,"0|i3gy6n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Dec/17 13:05;githubbot;GitHub user avafanasiev opened a pull request:

    https://github.com/apache/groovy/pull/643

    GROOVY-8241 SAM parameter type inference for explicit parameter

    It should fix GROOVY-8241, GROOVY-7061, GROOVY-8317.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/avafanasiev/groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/643.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #643
    
----
commit dcbc41e591a65895e4a4f47eca78488d8ea0603b
Author: alexey.afanasiev <alexey.afanasiev@jetbrains.com>
Date:   2017-12-11T13:01:02Z

    GROOVY-8241 SAM parameter type inference for explicit parameter

----
;;;","13/Dec/17 03:27;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/643
;;;","13/Dec/17 04:56;daniel_sun;Fixed by https://github.com/apache/groovy/commit/bd5191d9a8858945a4d83df58e261eb56bec0ab7
;;;","17/Dec/17 01:32;githubbot;Github user daniel-huss commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/643#discussion_r157355618
  
    --- Diff: src/test/groovy/transform/stc/MethodCallsSTCTest.groovy ---
    @@ -383,6 +406,94 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
                 ''', 'Reference to method is ambiguous'
         }
     
    +    void testShouldFailWithMultiplePossibleMethods2() {
    +        shouldFailWithMessages '''
    +                static String foo(String s) {
    +                    'String'
    +                }
    +                static String foo(Integer s) {
    +                    'Integer'
    +                }
    +                static String foo(Boolean s) {
    +                    'Boolean'
    +                }
    +                ['foo',123,true].each { argument ->
    +                    if (argument instanceof String || argument instanceof Boolean || argument instanceof Integer) {
    +                        foo(argument)
    +                    }
    +                }
    +            ''', 'Reference to method is ambiguous'
    +    }
    +
    +    void testInstanceOfOnExplicitParameter() {
    +        assertScript '''
    +                1.with { obj ->
    +                    if (obj instanceof String) {
    +                        obj.toUpperCase() 
    +                    }
    +                }
    +            '''
    +    }
    +
    +    void testSAMWithExplicitParameter() {
    +        assertScript '''
    +            public interface SAM {
    +                boolean run(String var1, Thread th);
    +            }
    +            
    +            static boolean foo(SAM sam) {
    +               sam.run(""foo"",  new Thread())
    +            }
    +            
    +            static def callSAM() {
    +                foo { str, th ->
    +                    str.toUpperCase().equals(th.getName())
    +                }
    +            }
    +            '''
    +    }
    +
    +    void testGroovy8241() {
    +        assertScript '''
    +            import java.util.function.Predicate
    +            
    +            static boolean foo(Predicate<? super String> p) {
    +                p.test(""foo"")
    +            }
    +            
    +            static def testPredicate() {
    +                foo { it ->
    +                    it.toUpperCase()
    --- End diff --
    
    I'm confused :) This works because `foo` happens to always pass a String to `p::test`, but what if it passed `new Object()` instead? If testPredicate were  `@CompileStatic` I would expect a compile error here. Is this disparity intentional?
;;;","18/Dec/17 10:19;githubbot;Github user avafanasiev commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/643#discussion_r157445258
  
    --- Diff: src/test/groovy/transform/stc/MethodCallsSTCTest.groovy ---
    @@ -383,6 +406,94 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
                 ''', 'Reference to method is ambiguous'
         }
     
    +    void testShouldFailWithMultiplePossibleMethods2() {
    +        shouldFailWithMessages '''
    +                static String foo(String s) {
    +                    'String'
    +                }
    +                static String foo(Integer s) {
    +                    'Integer'
    +                }
    +                static String foo(Boolean s) {
    +                    'Boolean'
    +                }
    +                ['foo',123,true].each { argument ->
    +                    if (argument instanceof String || argument instanceof Boolean || argument instanceof Integer) {
    +                        foo(argument)
    +                    }
    +                }
    +            ''', 'Reference to method is ambiguous'
    +    }
    +
    +    void testInstanceOfOnExplicitParameter() {
    +        assertScript '''
    +                1.with { obj ->
    +                    if (obj instanceof String) {
    +                        obj.toUpperCase() 
    +                    }
    +                }
    +            '''
    +    }
    +
    +    void testSAMWithExplicitParameter() {
    +        assertScript '''
    +            public interface SAM {
    +                boolean run(String var1, Thread th);
    +            }
    +            
    +            static boolean foo(SAM sam) {
    +               sam.run(""foo"",  new Thread())
    +            }
    +            
    +            static def callSAM() {
    +                foo { str, th ->
    +                    str.toUpperCase().equals(th.getName())
    +                }
    +            }
    +            '''
    +    }
    +
    +    void testGroovy8241() {
    +        assertScript '''
    +            import java.util.function.Predicate
    +            
    +            static boolean foo(Predicate<? super String> p) {
    +                p.test(""foo"")
    +            }
    +            
    +            static def testPredicate() {
    +                foo { it ->
    +                    it.toUpperCase()
    --- End diff --
    
    Actually you can't pass anything  except String to Predicate<? super String> p . Cause it should be able to be assigned to captured type '? super String' . This behavior matches java's lambda behavior.
;;;","14/Feb/18 18:47;githubbot;Github user daniel-huss commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/643#discussion_r168272512
  
    --- Diff: src/test/groovy/transform/stc/MethodCallsSTCTest.groovy ---
    @@ -383,6 +406,94 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
                 ''', 'Reference to method is ambiguous'
         }
     
    +    void testShouldFailWithMultiplePossibleMethods2() {
    +        shouldFailWithMessages '''
    +                static String foo(String s) {
    +                    'String'
    +                }
    +                static String foo(Integer s) {
    +                    'Integer'
    +                }
    +                static String foo(Boolean s) {
    +                    'Boolean'
    +                }
    +                ['foo',123,true].each { argument ->
    +                    if (argument instanceof String || argument instanceof Boolean || argument instanceof Integer) {
    +                        foo(argument)
    +                    }
    +                }
    +            ''', 'Reference to method is ambiguous'
    +    }
    +
    +    void testInstanceOfOnExplicitParameter() {
    +        assertScript '''
    +                1.with { obj ->
    +                    if (obj instanceof String) {
    +                        obj.toUpperCase() 
    +                    }
    +                }
    +            '''
    +    }
    +
    +    void testSAMWithExplicitParameter() {
    +        assertScript '''
    +            public interface SAM {
    +                boolean run(String var1, Thread th);
    +            }
    +            
    +            static boolean foo(SAM sam) {
    +               sam.run(""foo"",  new Thread())
    +            }
    +            
    +            static def callSAM() {
    +                foo { str, th ->
    +                    str.toUpperCase().equals(th.getName())
    +                }
    +            }
    +            '''
    +    }
    +
    +    void testGroovy8241() {
    +        assertScript '''
    +            import java.util.function.Predicate
    +            
    +            static boolean foo(Predicate<? super String> p) {
    +                p.test(""foo"")
    +            }
    +            
    +            static def testPredicate() {
    +                foo { it ->
    +                    it.toUpperCase()
    --- End diff --
    
    Oh, you're right. I forgot Groovy's interpretation of <? super X> is simply <X> :)
;;;",,,,,,,,,,,,,,,,
Compilation error in @CompileStatic,GROOVY-8240,13083429,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,Alexey Afanasiev,Alexey Afanasiev,29/Jun/17 10:57,06/Mar/18 23:25,14/Jul/23 06:02,05/Jul/17 01:55,2.4.12,2.5.0-alpha-1,,,,,,,2.4.13,,,,Static compilation,,,,0,,,,,,,"This should be compiled and executed normally
{code:java}
import groovy.transform.CompileStatic

class Bar {
  void vararg(boolean flag = true, Class<?>... classes) {}
}

@CompileStatic            
class Foo extends Bar{
  def test() {
    vararg(false, Foo)
  }
}

new Foo().test()
{code}

But the result of compilation is  
*[Static type checking] - Cannot call Foo#vararg(java.lang.Class <java.lang.Object>[]) with arguments [boolean, java.lang.Class <Foo>]*
",,Alexey Afanasiev,daniilo,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jul 05 01:55:39 UTC 2017,,,,,,,,,,"0|i3gw1j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jun/17 13:37;githubbot;GitHub user avafanasiev opened a pull request:

    https://github.com/apache/groovy/pull/570

    GROOVY-8240: Compilation error in @CompileStatic

    I have no idea why should generated methods should have receiver as declared class. It causes bug https://issues.apache.org/jira/browse/GROOVY-8240

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/avafanasiev/groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/570.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #570
    
----
commit 9a6a1f67c56d4c6541caae8908ba7b970e1ff6f8
Author: alexey.afanasiev <alexey.afanasiev@jetbrains.com>
Date:   2017-06-29T13:27:38Z

    GROOVY-8240: Compilation error in @CompileStatic

----
;;;","05/Jul/17 00:33;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/570
;;;","05/Jul/17 01:55;jwagenleitner;Thanks for reporting the issue and for the PR.;;;",,,,,,,,,,,,,,,,,,,
multiple-catch statement behaves strangely,GROOVY-8238,13082781,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,GertG,GertG,27/Jun/17 11:04,21/Feb/19 06:18,14/Jul/23 06:02,28/Jan/19 01:46,2.4.6,,,,,,,,2.5.6,3.0.0-beta-1,,,groovy-runtime,,,,0,,,,,,,"{code:java}
try {
    throw new AnyJavaException()
} catch ( AnyJavaException1 | AnyJavaException2 e ) {
    println e.message
}
{code}
This works as expected. But following does not:
{code:java}
try {
    throw new AnyJavaException()
} catch ( AnyJavaException | AnyGroovyException e ) {
    println e.message
}
{code}
You get:
{noformat}
java.lang.ClassCastException: AnyJavaException cannot be cast to groovy.lang.GroovyObject
{noformat}",Windows 10,GertG,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 28 01:46:28 UTC 2019,,,,,,,,,,"0|i3gs1r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Jan/19 09:26;paulk;The following example fails in Groovy 2.5.5 but passes in 3.0.0-alpha-4:
{code:java}
import groovy.cli.CliBuilderException
try {
    throw new RuntimeException('not working')
} catch ( RuntimeException | CliBuilderException e ) {
    println e.message
}
{code}
I get the same result on the heads of the two respective branches and with and without {{@CompileStatic}}.

I don't know yet whether the new parser is causing a different path to be traversed during compilation or whether there is a commit/fix we haven't back-ported to the 2_5_X branch as of yet. I'll keep looking.;;;","28/Jan/19 01:46;paulk;Turns out the old parser used the same code statements in both blocks when splitting a multi-catch into multi catch blocks.;;;",,,,,,,,,,,,,,,,,,,,
Java stub generation incorrect for static properties of traits,GROOVY-8233,13080343,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,graemerocher1,graemerocher1,16/Jun/17 07:34,26/Jul/18 04:38,14/Jul/23 06:02,10/Jul/18 11:57,2.4.11,,,,,,,,2.5.1,,,,Stub generator / Joint compiler,,,,0,,,,,,,"Groovy generates incorrect stubs for static properties of traits resulting in compilation errors such as:

{code}
/Users/graemerocher/grails/apps/domain-plugins/app/build/tmp/compileGroovy/groovy-java-stubs/bug/DomainA.java:10: error: org_grails_datastore_mapping_dirty_checking_DirtyCheckable__DIRTY_CLASS_MARKER$get() in DomainParent cannot implement org_grails_datastore_mapping_dirty_checking_DirtyCheckable__DIRTY_CLASS_MARKER$get() in DirtyCheckable$Trait$FieldHelper
public class DomainA
       ^
  overriding method is static
1 error
startup failed:
Compilation failed; see the compiler error output for details.

1 error
{code}

Attached is an example. Simply run `./gradlew compileGroovy`",,githubbot,graemerocher1,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"16/Jun/17 07:34;graemerocher1;domain-plugins.zip;https://issues.apache.org/jira/secure/attachment/12873236/domain-plugins.zip",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 10 11:57:01 UTC 2018,,,,,,,,,,"0|i3gd1b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jul/18 13:28;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/767

    GROOVY-8233: Java stub generation incorrect for static properties of …

    …traits

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8233

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/767.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #767
    
----
commit 2048d680490a2bc8710a59b907a50770593e97e0
Author: Paul King <paulk@...>
Date:   2018-07-05T13:26:23Z

    GROOVY-8233: Java stub generation incorrect for static properties of traits

----
;;;","10/Jul/18 11:56;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/groovy/pull/767
;;;","10/Jul/18 11:57;paulk;Proposed PR merged.;;;",,,,,,,,,,,,,,,,,,,
Deadlock in GroovyClassLoader,GROOVY-8230,13079827,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,jbredeson,jbredeson,14/Jun/17 17:35,06/Mar/18 23:25,14/Jul/23 06:02,24/Jun/17 19:28,2.5.0-beta-1,,,,,,,,2.5.0-beta-2,,,,,,,,0,,,,,,,"The GroovyClassLoader.clearCache() method can deadlock when another thread is creating a new instance of a class. The clearCache() method locks the classCache, then when removing the class, through the InvokerHelper, locks the ClassInfo object. When a new instance is created that instance can lock the ClassInfo object first, then later request the lock for the classCache (This happens when requesting the entry getClassCacheEntry). If the timing between the two threads is unlucky a deadlock can occur. 

Relevant stack trace attached.

Groovy: 2.4.10 groovy-all-2.4.10-indy.jar
Java: JRE 8u73_64
",,githubbot,jbredeson,jkemnade,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"14/Jun/17 17:34;jbredeson;GroovyClassLoaderDeadlock.txt;https://issues.apache.org/jira/secure/attachment/12873001/GroovyClassLoaderDeadlock.txt",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jun 24 19:28:34 UTC 2017,,,,,,,,,,"0|i3g9uv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Jun/17 17:49;jwagenleitner;Are you seeing this issue with 2.4.x?  I think the [commit 4ea1207f|https://github.com/apache/groovy/commit/4ea1207f21b93a15dbcca17538c379721d9217de] that introduced the call to {{InvokerHelper}} was only added to 2.5+ and I don't see the code in the [2.4 branch|https://github.com/apache/groovy/blob/GROOVY_2_4_X/src/main/groovy/lang/GroovyClassLoader.java#L970].  Just want to make sure on what version is affected.;;;","14/Jun/17 17:57;jbredeson;Sorry you are correct we are running a modified code base. We are running 2.4.10 with the addition of pull request https://github.com/apache/groovy/pull/445 to fix a memory leak we were having. That would make this a 2.5+ issue or an invalid issue depending on if the MetaClassRegistryImpl still works the same in 2.5+.;;;","19/Jun/17 00:55;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/561

    GROOVY-8230: Deadlock in GroovyClassLoader

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8230-gcl-deadlock

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/561.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #561
    
----
commit cc2ab1a5fe09d56de905d0b0a3b3a87fcf0d6a60
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-06-19T00:16:07Z

    GROOVY-8230: Deadlock in GroovyClassLoader

----
;;;","24/Jun/17 18:47;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/561
;;;","24/Jun/17 19:28;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,
nested try-catch-finally handling inside Closures generates wrong bytecode,GROOVY-8229,13079532,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,daniel_sun,leonard84,leonard84,13/Jun/17 16:35,11/Jul/17 00:23,14/Jul/23 06:02,15/Jun/17 15:06,2.4.10,2.4.11,,,,,,,2.4.12,,,,bytecode,,,,0,,,,,,,"Since version 2.4.10 groovy generates the wrong bytecode instructions for try-catch-finally inside closures. This is most likely caused by one of these two changes: GROOVY-8085, GROOVY-7248.

This was discovered with the generated code for Spocks {{verifyAll}} feature, here is the corresponding issue https://github.com/spockframework/spock/issues/709

The problem can be observed without Spock in this scenario ({{@CompileStatic}} is only used to generate better readable decompiled code, the problem is the same with dynamic code).
{code:java}
import groovy.transform.CompileStatic
import org.junit.Assert
import org.junit.Test
import org.junit.runners.model.MultipleFailureException

@CompileStatic
class TryCatchProblem {

  @Test
  void ""test""() {
    def cl = {
      ErrorCollector collector = new ErrorCollector()
      try {
        try {
          Assert.fail(""a"")
        } catch (Throwable e) {
          collector.collect(e)
        }
        try {
          Assert.fail(""b"")
        } catch (Throwable e) {
          collector.collect(e)
        }
        try {
          Assert.assertTrue(""c"", true)
        } catch (Throwable e) {
          collector.collect(e)
        }
      } finally {
        collector.check()
      }
    }
    cl()
  }
}

class ErrorCollector {
  List<Throwable> errors = []
  int ctr = 0

  void collect(Throwable t) {
    errors.add(t)
  }

  void check() {
    if (!errors.empty) {
      List<Throwable> x = new ArrayList<>(errors)
      x << new RuntimeException(""ctr ${++ctr}"")
      throw new MultipleFailureException(x)
    }
  }
}
{code}

The different results can be seen here: https://gist.github.com/leonard84/23f072b2c434b27e851a3e513570acf1

{panel:title=Result-2.4.9}
java.lang.AssertionError: a
java.lang.AssertionError: b
java.lang.RuntimeException: ctr 1
{panel}


{panel:title=Result-2.4.10}
java.lang.AssertionError: a
java.lang.AssertionError: b
java.lang.AssertionError: a
java.lang.AssertionError: b
java.lang.RuntimeException: ctr 1
java.lang.RuntimeException: ctr 3
{panel}

And the decompiled code can be seen here: https://gist.github.com/leonard84/1c91f8aebd0b8af599a6925404e5a11c

The relevant part is here:
{code:java|title=2.4.9}
            try {
                Assert.assertTrue(""c"", true);
                final Object o = null;
                collector.check();
                return o;
            }
            catch (Throwable e3) {
                collector.collect(e3);
                final Object o2 = null;
                collector.check();
                return o2;
            }
            collector.check();
        }
        finally {
            collector.check();
        }
        return null;
}
{code}

vs.

{code:java|title=2.4.10}
            Object o = null;
            try {
                Assert.assertTrue(""c"", true);
                o = null;
                try {
                    final ErrorCollector errorCollector = collector;
                    errorCollector.check();
                    return o;
                }
                catch (Throwable e3) {
                    collector.collect(e3);
                    final Object o3 = null;
                    collector.check();
                    return o3;
                }
            }
            catch (Throwable t) {}
            try {
                final ErrorCollector errorCollector = collector;
                errorCollector.check();
                return o;
            }
            finally {}
            collector.check();
        }
        finally {
            collector.check();
        }
        return null;
}
{code}

In both cases too many calls to {{collector.check()}} are generated, however since the finally block was not executed in <groovy-2.4.10 it was not really an issue. In the 2.4.10 code the generated code is definitely wrong. Somehow a call to {{collector.check()}} was put in its own try-catch, which throws the first exception which is then catched, appended and thrown inside a new exception with the call to {{collector.check()}} inside the catch. This Exception is then overridden by the call to {{collector.check()}} in the finally block, as you can see by the {{ctr 3}} instead of {{ctr 2}} inside the second RuntimeException.",,daniel_sun,jwagenleitner,leonard84,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8085,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 15 15:59:10 UTC 2017,,,,,,,,,,"0|i3g81b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Jun/17 04:57;daniel_sun;Hi  Leonard,

     I verified the similiar code with 2.5.0-beta-1, failed to reproduce the try-catch-finally issue. 

{code:java}
try {
    try {
        println 1
    } catch (e) {
        println 2
    }
    
    try {
        println 3
    } catch (e) {
        println 4
    }
    
    try {
        println 5
    } catch (e) {
        println 6
    }
} finally {
    println 7
}

/* yield
1
3
5
7

*/
{code}


{code:java}
def c = {
    try {
        try {
            println 1
        } catch (e) {
            println 2
        }
        
        try {
            println 3
        } catch (e) {
            println 4
        }
        
        try {
            println 5
        } catch (e) {
            println 6
        }
    } finally {
        println 7
    }
}

c()

/* yield
1
3
5
7

*/
{code}

;;;","14/Jun/17 05:22;daniel_sun;I guess it may be related to GROOVY-7248 after I completed another experiment:

{code:java}
  void collect(Throwable t) {
    errors.add(t)    // if the code is modified as the following, the issue is gone:      [].add(t)
  }
{code}

Complete code:
{code:java}
import groovy.transform.CompileStatic
import org.junit.Assert
import org.junit.Test
import org.junit.runners.model.MultipleFailureException

@CompileStatic
class TryCatchProblem {

  @Test
  void ""test""() {
    def cl = {
      ErrorCollector collector = new ErrorCollector()
      try {
        try {
          Assert.fail(""a"")
        } catch (Throwable e) {
          collector.collect(e)
        }
        try {
          Assert.fail(""b"")
        } catch (Throwable e) {
          collector.collect(e)
        }
        try {
          Assert.assertTrue(""c"", true)
        } catch (Throwable e) {
          collector.collect(e)
        }
      } finally {
        collector.check()
      }
    }
    cl()
  }
}

class ErrorCollector {
  List<Throwable> errors = []
  int ctr = 0

  void collect(Throwable t) {
    errors.add(t)    // if the code is modified as the following, the issue is gone:      [].add(t)
  }

  void check() {
    println '########################################################################'
    if (!errors.empty) {
      List<Throwable> x = new ArrayList<>(errors)
      x << new RuntimeException(""ctr ${++ctr}"")
      throw new MultipleFailureException(x)
    }
  }
}
{code}
;;;","14/Jun/17 14:33;jwagenleitner;When running the test case provided in the description I first see the change in output (duplicate errors and incorrect count) starting at [commit b549062485c|https://github.com/apache/groovy/commit/b549062485cbd82dfde5537a16ddee126cc7fcfc] for GROOVY-8085.

;;;","14/Jun/17 20:47;leonard84;Hi [~daniel_sun],

regarding your statement:
{quote}
{code:java}
  void collect(Throwable t) {
    errors.add(t)    // if the code is modified as the following, the issue is gone:      [].add(t)
  }
{code}
{quote}



Just so that I understand you correctly do you mean this?
{code:java}
class ErrorCollector {
  List<Throwable> errors = []
  int ctr = 0

  void collect(Throwable t) {
    [].add(t)
  }

  void check() {
    if (!errors.empty) {
      List<Throwable> x = new ArrayList<>(errors)
      x << new RuntimeException(""ctr ${++ctr}"")
      throw new MultipleFailureException(x)
    }
  }
}
{code};;;","15/Jun/17 01:14;daniel_sun;Leonard, I've reproduce the issue via the simplifed code. If code throws exception in the finally block, the code will execute multi times...

{code:java}
try {
    try {
        println 1
    } catch (e) {
    }
} finally {
    check()
}

def check() {
    println 7
    throw new RuntimeException(""check failed..."");
}
{code}
;;;","15/Jun/17 13:53;leonard84;[~danielsun1106] I could reproduce the behavior if either a closure or a non-void method is used. 

{code:java}
  void tooManyChecks() {
    def cl = {
      try {
        try {
          println 1
        } catch (e) {
        }
      } finally {
        check()
      }
    }
    cl()
  }

  def tooManyChecks2() {
    try {
      try {
        println 1
      } catch (e) {
      }
    } finally {
      check()
    }
  }

  void thisWorksAsIntended() {
      try {
        try {
          println 1
        } catch (e) {
        }
      } finally {
        check()
      }    
  }

  def check() {
    println 7
    throw new RuntimeException(""check failed..."");
  }
{code}

{panel}
tooManyChecks:
1
7
7
7

tooManyChecks2:
1
7
7
7

thisWorksAsIntended:
1
7
{panel}

I think that the return handling in conjunction to the finally changes produces this weird behavior. ;;;","15/Jun/17 14:22;jwagenleitner;Here's a test case I used, note that if you add a return after the {{check()}} call it succeeds.  The finally blocks are being replayed by the recorder twice, even though GROOVY-8085 may have triggered the issue it may be due to some implicit return handling/closures somewhere else.

{code}
class Groovy8229Bug extends GroovyTestCase {

    void testFinallyBlockInClosureCalledOnce() {
        assert shouldFail(
            '''
                class TryCatchProblem {
                    static int count = 0
                    static void main(args) {
                        def cl = {
                            try {
                                try {
                                    assert count == 0
                                } catch (Throwable e) { }
                            } finally {
                                check()
                            }
                        }
                        cl()
                    }
                    static void check() {
                        throw new UnsupportedOperationException(""check call count: ${++count}"")
                    }
                }
            '''
        ) == 'check call count: 1'
    }

}
{code}

Since GROOVY-7248 doesn't seem to be a cause or related, I'm removing it from the breaks link.  If any disagrees please add it back.;;;","15/Jun/17 14:26;daniel_sun;John, I agree with you that the issue is not related with GROOVY-7249. I'm trying to fix it.;;;","15/Jun/17 15:06;daniel_sun;Fixed by https://github.com/apache/groovy/commit/0406787a5c29704800132dfde79f9a9018b3e27f;;;","15/Jun/17 15:15;leonard84;Thanks for the quick fix, will there be a fix in 2.4.x for this as well?;;;","15/Jun/17 15:59;daniel_sun;My pleasure :-)
Sure, the fix will be merged into 2.x.x.;;;",,,,,,,,,,,
Stubs for classes implementing traits with fields don't include getters/setters,GROOVY-8224,13078888,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,keegan,keegan,10/Jun/17 18:42,26/Jul/18 04:38,14/Jul/23 06:02,21/Jun/18 06:31,,,,,,,,,2.4.16,2.5.1,,,Stub generator / Joint compiler,,,,1,,,,,,,"As an example, the stubs generated for _GroovyXImpl_ for the Groovy below doesn't include {{int getFoo()}} or {{void setFoo(int value)}}.

{code:java}
trait GroovyXTrait {
    int foo
}
class GroovyXImpl implements GroovyXTrait { }
{code}",,githubbot,keegan,lewisdavidcole,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7536,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Thu Jun 21 06:31:48 UTC 2018,,,,,,,,,,"0|i3g4x3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/May/18 15:48;lewisdavidcole;We recently experienced the exact same issue. Has anyone looked into this issue yet?;;;","19/Jun/18 09:24;paulk;We should be able to modify JavaStubGenerator to cope with this.;;;","19/Jun/18 11:16;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/760

    GROOVY-8224: Stubs for classes implementing traits with fields don't …

    …include getters/setters

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8224

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/760.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #760
    
----
commit 4f3e6a6282f9ba777faa4dd4c9a29a63412b4493
Author: Paul King <paulk@...>
Date:   2018-06-19T11:15:24Z

    GROOVY-8224: Stubs for classes implementing traits with fields don't include getters/setters

----
;;;","21/Jun/18 06:26;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/760
;;;","21/Jun/18 06:31;paulk;Proposed PR merged. Thanks to all involved.;;;",,,,,,,,,,,,,,,,,
AsmClassGenerator does not set source positions on property expressions,GROOVY-8222,13078641,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,emilles,emilles,09/Jun/17 15:15,06/Mar/18 23:25,14/Jul/23 06:02,08/Jul/17 19:48,,,,,,,,,2.4.13,,,,,,,,0,,,,,,,"AsmClassGenerator.visitVariableExpression and AsmClassGenerator.processClassVariable can create a new PropertyExpression from a VariableExpression and the source position of the original is not transferred.

Solution is pretty minimal:
{code} // mid way through visitVariableExpression:
        if (variable == null) {
            // GRECLIPSE edit
            //processClassVariable(variableName);
            processClassVariable(expression);
            // GRECLIPSE end
        } else {
{code}

{code}
    // GRECLIPSE edit
    //private void processClassVariable(String name) {
    private void processClassVariable(VariableExpression expression) {
        String name = expression.getName();
    // GRECLIPSE end
{code}

{code} // end of processClassVariable:
        } else {
            // GRECLIPSE edit
            //PropertyExpression pexp = new PropertyExpression(VariableExpression.THIS_EXPRESSION, name);
            PropertyExpression pexp = new PropertyExpression(new VariableExpression(""this"", ClassHelper.DYNAMIC_TYPE), name);
            pexp.getObjectExpression().setSourcePosition(expression);
            pexp.getProperty().setSourcePosition(expression);
            // GRECLIPSE end
            pexp.setImplicitThis(true);
            visitPropertyExpression(pexp);
        }
{code}


I found this because I had a {{with}} expression that produced an error that was attributed to line -1.
{code}
import com.fasterxml.jackson.annotation.JsonInclude
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.datatype.jsonorg.JsonOrgModule
import org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean
@groovy.transform.CompileStatic
final class CustomObjectMapper extends ObjectMapper
{
    CustomObjectMapper()
    {
        super(mimicSpring())
    }

    private static ObjectMapper mimicSpring()
    {
        /* Formerly in SpringDispatcherContext.xml:
         *  <bean class=""org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean""
         *    p:modulesToInstall=""com.fasterxml.jackson.datatype.jsonorg.JsonOrgModule""
         *    p:serializationInclusion=""NON_NULL"" p:failOnUnknownProperties=""false""
         *    p:autoDetectFields=""false"" p:autoDetectGettersSetters=""true"">
         *  </bean>
         */

        new Jackson2ObjectMapperFactoryBean().with {
            modulesToInstall = JsonOrgModule // Joda module is auto-discovered
            serializationInclusion = JsonInclude.Include.NON_NULL
            defaultViewInclusion = true // include w/o view tag
            failOnUnknownProperties = false
            autoDetectGettersSetters = true
            autoDetectFields = false
            afterPropertiesSet()
            return object // error on this line; this.object is the PropertyExpression that is created by AsmClassGenerator
        }
    }
}
{code}",,arsen.babakhanyan,emilles,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 08 19:48:04 UTC 2017,,,,,,,,,,"0|i3g3e7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jun/17 14:08;githubbot;GitHub user ArsenBabakhanyan opened a pull request:

    https://github.com/apache/groovy/pull/559

    GROOVY-8222: Setting Source Position in newly created PropertyExpression

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/ArsenBabakhanyan/groovy GROOVY-8222

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/559.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #559
    
----
commit 5dcd3aea6710469042b6c7bada86dac28e6d67f8
Author: Arsen Babakhanyan <arsen.ba@gmail.com>
Date:   2017-06-11T14:06:29Z

    GROOVY-8222: Setting Source Position in newly created PropertyExpression

----
;;;","08/Jul/17 17:39;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/559#discussion_r126286728
  
    --- Diff: src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java ---
    @@ -1251,11 +1251,13 @@ private void processClassVariable(String name) {
                 mv.visitInsn(DUP);
     
                 loadThisOrOwner();
    -            mv.visitLdcInsn(name);
    +            mv.visitLdcInsn(expression.getName());
     
                 mv.visitMethodInsn(INVOKESPECIAL, ""org/codehaus/groovy/runtime/ScriptReference"", ""<init>"", ""(Lgroovy/lang/Script;Ljava/lang/String;)V"", false);
             } else {
    -            PropertyExpression pexp = new PropertyExpression(new VariableExpression(""this""), name);
    +            PropertyExpression pexp = new PropertyExpression(new VariableExpression(""this""), expression.getName());
    --- End diff --
    
    The patch provided in the JIRA creates a new `VariableExpression` (see below), I think that needs to be done so the source position is not set on the constant `VariableExpress.THIS_EXPRESSION` via the `getObjectExpression().setSourcePosition(..)` call.
    
    ```java
    PropertyExpression pexp = new PropertyExpression(new VariableExpression(""this"", ClassHelper.DYNAMIC_TYPE), name);
    ```
;;;","08/Jul/17 17:42;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/559#discussion_r126286817
  
    --- Diff: src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java ---
    @@ -1251,11 +1251,13 @@ private void processClassVariable(String name) {
                 mv.visitInsn(DUP);
     
                 loadThisOrOwner();
    -            mv.visitLdcInsn(name);
    +            mv.visitLdcInsn(expression.getName());
     
                 mv.visitMethodInsn(INVOKESPECIAL, ""org/codehaus/groovy/runtime/ScriptReference"", ""<init>"", ""(Lgroovy/lang/Script;Ljava/lang/String;)V"", false);
             } else {
    -            PropertyExpression pexp = new PropertyExpression(new VariableExpression(""this""), name);
    +            PropertyExpression pexp = new PropertyExpression(new VariableExpression(""this""), expression.getName());
    --- End diff --
    
    Scratch that comment, I was looking at the wrong source.
;;;","08/Jul/17 17:50;githubbot;Github user ArsenBabakhanyan commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/559#discussion_r126286972
  
    --- Diff: src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java ---
    @@ -1251,11 +1251,13 @@ private void processClassVariable(String name) {
                 mv.visitInsn(DUP);
     
                 loadThisOrOwner();
    -            mv.visitLdcInsn(name);
    +            mv.visitLdcInsn(expression.getName());
     
                 mv.visitMethodInsn(INVOKESPECIAL, ""org/codehaus/groovy/runtime/ScriptReference"", ""<init>"", ""(Lgroovy/lang/Script;Ljava/lang/String;)V"", false);
             } else {
    -            PropertyExpression pexp = new PropertyExpression(new VariableExpression(""this""), name);
    +            PropertyExpression pexp = new PropertyExpression(new VariableExpression(""this""), expression.getName());
    --- End diff --
    
    ok
;;;","08/Jul/17 19:19;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/559#discussion_r126288338
  
    --- Diff: src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java ---
    @@ -1218,7 +1218,7 @@ public void visitVariableExpression(VariableExpression expression) {
     
             BytecodeVariable variable = controller.getCompileStack().getVariable(variableName, false);
             if (variable == null) {
    -            processClassVariable(variableName);
    +            processClassVariable(expression);
    --- End diff --
    
    I am feeling a bit partial about the change from variableName to expression. I know you need it to set the source position later on. But should we start doing some funky stuff where variableName or expression are changed, the this will cause a problem we may not even notice correctly. So I would suggest something I really really do not often... make the two final
;;;","08/Jul/17 19:24;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/559
;;;","08/Jul/17 19:32;githubbot;Github user ArsenBabakhanyan commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/559#discussion_r126288571
  
    --- Diff: src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java ---
    @@ -1218,7 +1218,7 @@ public void visitVariableExpression(VariableExpression expression) {
     
             BytecodeVariable variable = controller.getCompileStack().getVariable(variableName, false);
             if (variable == null) {
    -            processClassVariable(variableName);
    +            processClassVariable(expression);
    --- End diff --
    
    this PR is closed, as I have mentioned before i am planning to do some refactoring and creating a new PR, I will make expression final there 
;;;","08/Jul/17 19:45;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/559#discussion_r126288792
  
    --- Diff: src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java ---
    @@ -1218,7 +1218,7 @@ public void visitVariableExpression(VariableExpression expression) {
     
             BytecodeVariable variable = controller.getCompileStack().getVariable(variableName, false);
             if (variable == null) {
    -            processClassVariable(variableName);
    +            processClassVariable(expression);
    --- End diff --
    
    Thanks for the PR.  I merged before seeing the comment from @blackdrag, so another refactor PR would be good.
;;;","08/Jul/17 19:48;jwagenleitner;Thanks for reporting the issue and providing a patch.;;;",,,,,,,,,,,,,
GroovyCastException with CompileStatic,GROOVY-8220,13077804,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,pablo72,pablo72,06/Jun/17 21:26,06/Mar/18 23:25,14/Jul/23 06:02,27/Sep/17 09:36,2.4.12,2.5.0-beta-1,,,,,,,2.4.13,,,,,,,,0,,,,,,,"{code}
@groovy.transform.CompileStatic
class Foo {
    CharSequence makeEnv( env, StringBuilder result = new StringBuilder() ) {
        if( env instanceof File ) {
            env = env.toPath()
        }
        if( env instanceof String && env.contains('=') ) {
            result << 'export ' << env << ';'
        }

        return result.toString()
    }
}

assert new Foo().makeEnv('X=1') == 'export X=1;'

Exception thrown

org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'X=1' with class 'java.lang.String' to class 'java.lang.Iterable'
	at Foo.makeEnv(ConsoleScript5:10)
	at Foo.makeEnv(ConsoleScript5:4)
	at Foo$makeEnv.call(Unknown Source)
	at ConsoleScript5.run(ConsoleScript5:20)
{code}

Without CompileStatic it works as expected. ",,arsen.babakhanyan,githubbot,jwagenleitner,monti,pablo72,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8237,,,,,,,,,,GROOVY-8157,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 28 06:08:57 UTC 2017,,,,,,,,,,"0|i3fy87:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Jun/17 18:13;jwagenleitner;Fix for GROOVY-8157 seems to be the cause.;;;","23/Sep/17 17:38;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/605

    GROOVY-8220: SC GroovyCastException on parameter flow typing

    GROOVY-8157 introduced flow typing for parameters and this fix is
    required in order to track their assignments in `if` branches for
    temporary type assignments.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8220-ParameterFlowTyping

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/605.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #605
    
----
commit ad5074b4db073ebefd1af21676675671a62f6064
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-09-08T00:27:06Z

    GROOVY-8220: SC GroovyCastException on parameter flow typing
    
    GROOVY-8157 introduced flow typing for parameters and this fix is
    required in order to track their assignments in `if` branches for
    temporary type assignments.

----
;;;","24/Sep/17 03:00;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/606

    GROOVY-8220: GroovyCastException with CompileStatic

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8220b

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/606.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #606
    
----
commit 9c39935ad5005dddf11816eaf0106227545fdb54
Author: paulk <paulk@asert.com.au>
Date:   2017-09-24T02:58:52Z

    GROOVY-8220: GroovyCastException with CompileStatic

----
;;;","27/Sep/17 07:54;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/605
;;;","27/Sep/17 07:58;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/groovy/pull/606
;;;","27/Sep/17 09:36;paulk;Thanks for the PR John (merged). I applied yours instead of mine since it was simpler and I haven't found any issues yet. Thanks for spotting the issue Paolo.;;;","28/Sep/17 06:08;pablo72;Yes, now the CI build is [green|http://ci.groovy-lang.org/viewLog.html?buildTypeId=JointBuilds_Nextflow_Groovy24xJointBuild&buildId=42830]! Thanks you all.  ;;;",,,,,,,,,,,,,,,
Add @TupleConstructor(includeFields = true) to a class implements a trait which contains properties will cause NPE,GROOVY-8219,13077641,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,digitarts,digitarts,06/Jun/17 11:28,22/Nov/22 21:15,14/Jul/23 06:02,22/Nov/22 21:14,2.4.11,,,,,,,,5.0.0-alpha-1,,,,xforms,,,,0,breaking,trait,traits,,,,"Hi, guys:

I got NPE when I wrote the following codes:
{code:java|title=Groovy Script|borderStyle=solid}
trait T {

    def x = 'abc'

}


import groovy.transform.TupleConstructor

@TupleConstructor(includeFields = true)
class A implements T {
    def a
    private b
}


assert 'ABC' == new A().x.toUpperCase()

{code}

I found that it will works well if I remove {{(includefields = true)}}.",,digitarts,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 22 21:14:03 UTC 2022,,,,,,,,,,"0|i3fx7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Jun/17 23:09;paulk;Lowering priority just a little since this is a known limitation:

http://docs.groovy-lang.org/latest/html/documentation/#_limitations

Having said that, it would obviously be good to remove this limitation.;;;","23/Dec/21 09:06;paulk;I had a look at what would be involved to make your example behave more as you expect. In reality, it is behaving ""kind of"" as designed. By including ""includeFields"" you are also including the trait backing field. That field is only set in the constructor since you could be inheriting from additional traits that also have an ""x"" property and so isn't going to pick up the default value.

I had a look at what would be involved with marking the backing fields as ""Trait$Implemented"" or ""Generated"" and excluding them from the constructor field processing. It works but if applied in a general way possibly breaks other transforms. For example, we rely on {{@ToString}} processing the trait backing fields in {{Groovy7584Bug#testTraitFieldModifiersAreRetained()}} for example. I don't know if other folks are also relying on such behavior.

For your example, I would instead use one of the following:
{code}
@TupleConstructor(includeFields=true, excludes='T__x')
{code}
or
{code}
@TupleConstructor(includeFields=true, includes='a,b')
{code}
;;;","22/Nov/22 21:14;emilles;https://github.com/apache/groovy/commit/0d6eb1b70b3341ea0c19313b988699dc8d1e5e7d;;;",,,,,,,,,,,,,,,,,,,
invalid octal split into two arguments,GROOVY-8216,13076608,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,blackdrag,blackdrag,01/Jun/17 18:30,06/Mar/18 23:25,14/Jul/23 06:02,02/Jun/17 16:00,,,,,,,,,2.6.0-alpha-1,,,,parser-antlr2,,,,1,,,,,,,"{code}​println 09​{code}
This code will cause a NPE, because it will be evaluated as println 0 9, which is evaluated as println(0).9. This happens because the leading zero introduces an octal, but 09 is no octal. The parser no falsely accepts 0 as valid number and does not recognize that 09 is supposed to be a single number anymore.

The expected behaviour is a compile time failure.

Daniel, can we fix that in parrot?",,blackdrag,daniel_sun,daniilo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 02 16:00:37 UTC 2017,,,,,,,,,,"0|i3frmv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jun/17 07:14;daniel_sun;Jochen, I think it can be fixed in Parrot ;);;;","02/Jun/17 08:24;blackdrag;+1;;;","02/Jun/17 16:00;daniel_sun;Fixed by https://github.com/apache/groovy/commit/90be9e50df449bc20d827ec7758bcd444713d40c;;;",,,,,,,,,,,,,,,,,,,
Closures are maybe not Threadsafe,GROOVY-8213,13076497,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,vampire,vampire,01/Jun/17 11:47,13/Feb/20 01:17,14/Jul/23 06:02,13/Feb/20 01:17,2.4.10,,,,,,,,2.4.13,,,,,,,,0,,,,,,,"I just upgraded our Gradle build from 1.12 (including Groovy 1.8.6) to 3.5 (including Groovy 2.4.10).
Now I get a very strange behavior for stuff that is there for years already and it looks to me as if this is a Groovy bug, maybe a non-threadsafeness of Closures.

I have a custom task that contains the following code:

{code}
      def sourceFilesSize = getSourceFiles().files.size()
      def poolSize = Runtime.runtime.availableProcessors()
      def executor = new ThreadPoolExecutor(poolSize, poolSize, 0, SECONDS, new ArrayBlockingQueue<Runnable>([sourceFilesSize, 1].max()))
      def tasks = []
      inputs.outOfDate { toTransform ->
         tasks.add executor.submit {
            project.exec {
               if (gscPath) { // here starts com.empic.build.tasks.Ghostscript$_exec_closure8$_closure11
                  environment 'GSC', gscPath
                  def tempDir = ""$temporaryDir/${Thread.currentThread().name}""
                  project.file(tempDir).mkdirs()
                  environment 'TEMP', tempDir
               }
               executable executablePath

               def arguments = [toTransform.file.absolutePath]
               if ((sourceFilesSize == 1) && getDestinationFile()) {
                  arguments << getDestinationFile().absolutePath
               } else if (destinationDirectory) {
                  arguments << new File(destinationDirectory, fileNameMapping(toTransform.file.name)).absolutePath
               } else {
                  arguments << new File(toTransform.file.parentFile, fileNameMapping(toTransform.file.name)).absolutePath
               }
               args arguments // here ends com.empic.build.tasks.Ghostscript$_exec_closure8$_closure11
            }
         }
      }
      executor.shutdown()
      executor.awaitTermination 1, HOURS
      tasks*.get() // here is line 137
{code}

When this task is executed e. g. with five source files, sometimes all works fine, sometime the build fails with

{noformat}
...
Caused by: java.util.concurrent.ExecutionException: java.lang.IllegalStateException: initialize must be called for meta class of class com.empic.build.tasks.Ghostscript$_exec_closure8$_closure11(class org.codehaus.groovy.runtime.metaclass.ClosureMetaClass) to complete initialisation process before any invocation or field/property access can be done
        at com.empic.build.tasks.Ghostscript.exec(Ghostscript.groovy:137)
        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)
        ... 80 more
Caused by: java.lang.IllegalStateException: initialize must be called for meta class of class com.empic.build.tasks.Ghostscript$_exec_closure8$_closure11(class org.codehaus.groovy.runtime.metaclass.ClosureMetaClass) to complete initialisation process before any invocation or field/property access can be done
{noformat}

Actually I was not able to reproduce the problem locally, but if I run the build on our CI server and attach a debugger, I indeed was able to reproduce the problem with a relatively high reproduction rate. (as in every second to third build approximately, opposed to once every 100 builds)

I logged the current thread when the {{initialized}} property is set to {{true}} and when it is requested with non-suspending breakpoints, but this seems to have caused the timing to change enough already that I was not able to reproduce the error within approximately the first two dozens of tries.

I was able to successfully break at the throwing of the {{IllegalStateException}} though. This happens in {{groovy.lang.MetaClassImpl.checkInitalised}}.
The stacktrace at this point is:

{noformat}
""pool-2-thread-3@10709"" prio=5 tid=0x47 nid=NA runnable
  java.lang.Thread.State: RUNNABLE
	  at groovy.lang.MetaClassImpl.checkInitalised(MetaClassImpl.java:1647)
	  at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:257)
	  at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1027)
	  at groovy.lang.Closure.call(Closure.java:414)
	  at groovy.lang.Closure.call(Closure.java:408)
	  at groovy.lang.Closure.run(Closure.java:495)
	  at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	  at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	  at java.lang.Thread.run(Thread.java:745)
{noformat}

with the closure for which we are at the {{ClosureMetaClass}} in the topmost frame being the mentioned {{com.empic.build.tasks.Ghostscript$_exec_closure8$_closure11}}.",Gradle 3.5,blackdrag,githubbot,jwagenleitner,paulk,vampire,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-9397,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 13 01:17:07 UTC 2020,,,,,,,,,,"0|i3fqy7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Aug/17 00:23;jwagenleitner;I have not been able to reproduce the issue.  My suspicion would be the {{initialized}} variable.  It is updated in synchronized blocks but has a non-synchronized accessor method.  Looking at the history of it (and its counterpart in {{MetaClassImpl}}) it does appear that one time it was synchronized.  Since it's not {{volatile}} it may be possible that the {{ClosureMetaClass#isInitialized}} method may return a stale value.  Having a standalone reproducible test would be helpful.;;;","14/Aug/17 20:48;blackdrag;I agree. If Thread T1 creates and initializes the meta class and Thread T2 then tries to call a method using this meta class, then it is possible that T2 will not see the initialized=true. 

We could think of just making it volatile, which is a performance penalty for every invokeMethod, setProperty and getProperty, that goes through a meta class, especially bad for Closure. So maybe we should invest more effort and recheck if initialized is false using a synchronized block.

Now the question is what will happen when we change from initialized=true to false (for example in EMC) and the other Thread is not notified? If that means that T2 may or may not see the modification, then this is fine with me. Such causes are supposed to require user-side synchronization. ;;;","01/Oct/17 01:37;jwagenleitner;I created a JMH benchmark to test a volatile read vs a recheck and sync, https://github.com/jwagenleitner/testing-groovy/tree/master/issues/groovy8213.

Based on my runs the volatile read is very close to a normal read. Doing a branched check (without needing to sync) was actually worse in terms of performance. Based on those benchmarks I'd suggest making {{initialized}} volatile in both {{ClosureMetaClass}} and also in {{MetaClassImpl}}.;;;","01/Oct/17 03:01;jwagenleitner;A related Gradle issue is https://github.com/gradle/gradle/issues/1420.

While I do believe the publication of the {{initialized}} variable could be an issue and should be addressed, another possible cause of this could be related to the way the {{respondTo}} methods are implemented by unsetting the {{initialized}} variable during a call to {{super.initialize()}} in the {{loadMetaInfo()}} method.

https://github.com/apache/groovy/blob/7b101dd98ffc04b1bfd2447bbe277340d8954add/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java#L724-L740

But in this case and the Gradle issue I'm not sure the {{respondTo}} methods are in play.;;;","01/Oct/17 03:06;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/609

    GROOVY-8213: Closures are maybe not Threadsafe

    To address @blackdrag 's comment in the JIRA I created a JMH benchmark to test a volatile read vs a recheck and sync, https://github.com/jwagenleitner/testing-groovy/tree/master/issues/groovy8213.
     Based on my runs the volatile read is very close to a normal read. Doing a branched check (without needing to sync) was actually worse in terms of performance.
    
    It seems with the `--parallel` feature in Gradle and builds being run on large many core servers this problem seems to be coming up more frequently. See https://github.com/gradle/gradle/issues/1420.
    
    While I do believe the publication of the `initialized` variable is an issue and should be addressed, another possible cause of this sort of problem could be related to the way the [`respondTo` methods are implemented by unsetting the `initialized` variable during a call to `super.initialize()` in the `loadMetaInfo() ` method](https://github.com/apache/groovy/blob/7b101dd98ffc04b1bfd2447bbe277340d8954add/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java#L724-L740). But in this case and the referenced Gradle issue I'm not sure the `respondTo` methods are in play.
    


You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8213-Closure-Init-Threadsafe

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/609.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #609
    
----
commit 01946dbf2bdd11bb1fa402131ba50fef26f889eb
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-10-01T02:31:16Z

    GROOVY-8213: Closures are maybe not Threadsafe

----
;;;","01/Oct/17 03:56;paulk;I haven't thought through whether there are any scenarios not covered by your tests John, but it seems from the results that in many cases there will be negligible performance degradation and improved stability, seems like a no-brainer to include this.;;;","01/Oct/17 04:48;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/609
;;;","01/Oct/17 05:04;jwagenleitner;I went ahead and merged the {{volatile}} change. Thanks for reporting the issue. Not sure how easy this will be to test with 2.4 snapshots, but if possible would like to get feedback on whether this fixes the issue you were seeing on the CI server.
;;;","01/Oct/17 10:36;blackdrag;when  I spoke of a performance penalty, then I did not mean the pure field read, I did mean method inlining. If the method you are calling is guarded by a volatile check, then inlining will not happen.... unless hotspot changed here in the meantime. The expected effect of this change is for me that no inlining is going to happen anymore in purely dynamic Groovy without primopts, indy or compilestatic. So you may not notice immediately. But I would wish for a benchmark in this direction. And just to make the point more understandable.. I actually made such a test back before Groovy 1.8 and later for primitive optimizations. And got exactly that result.;;;","01/Oct/17 23:13;jwagenleitner;I am not sure how to craft a benchmark that you wish for.  I can revert the change or maybe the following would be acceptable logic after removing the {{volatile}} modifier?

{code}
protected boolean isInitialized() {
    if (initialized) {
        return true;
    }
    synchronized (this) {
        return initialized;
    }
}
{code}

Since the normal state is to be initialized this only rechecks if false.;;;","06/Aug/19 13:52;vampire;[~jwagenleitner] are you sure this is fixed?
 According to [the last comment in the Gradle issue you mentioned|https://github.com/gradle/gradle/issues/1420#issuecomment-431588379],
 this also happened with Gradle 4.10.2 which includes Groovy 2.4.15.

I cannot say whether behavior changed for me as I outsourced the problematic code into a Java file to work-around this issue.
  
 ;;;","06/Aug/19 16:13;vampire;Actually I now tried to revert my work-around with Gradle 4.10.3 and now it even failed locally, not only on CI with two out of two tries so far,
so this issue needs to be reopened, it is not fixed.;;;","06/Aug/19 16:13;vampire;{noformat}
org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':doc:en:db-model:transformDbModelDocuImagesToPs2'.
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:110)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:77)
        at org.gradle.api.internal.tasks.execution.OutputDirectoryCreatingTaskExecuter.execute(OutputDirectoryCreatingTaskExecuter.java:51)
        at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:59)
        at org.gradle.api.internal.tasks.execution.ResolveTaskOutputCachingStateExecuter.execute(ResolveTaskOutputCachingStateExecuter.java:54)
        at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:59)
        at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:101)
        at org.gradle.api.internal.tasks.execution.FinalizeInputFilePropertiesTaskExecuter.execute(FinalizeInputFilePropertiesTaskExecuter.java:44)
        at org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:91)
        at org.gradle.api.internal.tasks.execution.ResolveTaskArtifactStateTaskExecuter.execute(ResolveTaskArtifactStateTaskExecuter.java:62)
        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:59)
        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:54)
        at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
        at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:34)
        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.run(EventFiringTaskExecuter.java:51)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:301)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:293)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:175)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:91)
        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.run(DelegatingBuildOperationExecutor.java:31)
        at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:46)
        at org.gradle.execution.taskgraph.LocalTaskInfoExecutor.execute(LocalTaskInfoExecutor.java:42)
        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareWorkItemExecutor.execute(DefaultTaskExecutionGraph.java:277)
        at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareWorkItemExecutor.execute(DefaultTaskExecutionGraph.java:262)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$ExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:135)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$ExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:130)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$ExecutorWorker.execute(DefaultTaskPlanExecutor.java:200)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$ExecutorWorker.executeWithWork(DefaultTaskPlanExecutor.java:191)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$ExecutorWorker.run(DefaultTaskPlanExecutor.java:130)
        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
        at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
Caused by: org.gradle.internal.UncheckedException: java.util.concurrent.ExecutionException: java.lang.IllegalStateException: initialize must be called for meta class of class com.empic.build.tasks.Graphviz$_exec_closure6$_closure9(class org.codehaus.groovy.runtime.metaclass.ClosureMetaClass) to complete initialisation process before any invocation or field/property access can be done
        at org.gradle.internal.UncheckedException.throwAsUncheckedException(UncheckedException.java:63)
        at org.gradle.internal.UncheckedException.throwAsUncheckedException(UncheckedException.java:40)
        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:76)
        at org.gradle.api.internal.project.taskfactory.IncrementalTaskAction.doExecute(IncrementalTaskAction.java:50)
        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:39)
        at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:26)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$1.run(ExecuteActionsTaskExecuter.java:131)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:301)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:293)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:175)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:91)
        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.run(DelegatingBuildOperationExecutor.java:31)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:120)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:99)
        ... 31 more
Caused by: java.util.concurrent.ExecutionException: java.lang.IllegalStateException: initialize must be called for meta class of class com.empic.build.tasks.Graphviz$_exec_closure6$_closure9(class org.codehaus.groovy.runtime.metaclass.ClosureMetaClass) to complete initialisation process before any invocation or field/property access can be done
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at com.empic.build.tasks.Graphviz.exec(Graphviz.groovy:131)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)
        ... 42 more
Caused by: java.lang.IllegalStateException: initialize must be called for meta class of class com.empic.build.tasks.Graphviz$_exec_closure6$_closure9(class org.codehaus.groovy.runtime.metaclass.ClosureMetaClass) to complete initialisation process before any invocation or field/property access can be done
{noformat};;;","13/Feb/20 01:17;paulk;Closing to indicate partially fixed. Further investigations should happen in the cloned issue.;;;",,,,,,,,
coerce GString to String when used as Map key,GROOVY-8212,13076365,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,chrylis,chrylis,01/Jun/17 01:06,17/Sep/22 16:35,14/Jul/23 06:02,17/Sep/22 16:35,2.4.10,,,,,,,,5.0.0-alpha-1,,,,Static compilation,Static Type Checker,,,1,,,,,,,"When a GString is used as the key for a bracket-style map get (in this case, from an overly verbose CSV file):

{code}
row[""$param URL""]
{code}

the {{GStringImpl}} object is passed directly to {{Map#get(Object)}}. Since GStrings are never equal to Strings, this means that the get will always return null.

If {{row}} is explicitly declared as a {{Map<String,?>}}, however, Groovy ought to identify the intended behavior (using a templated string as a map key) and use the string value instead.

The current behavior is a problem because even in static compilation mode, where the generic key bound is known, Groovy does not complain about the use of a GString here (because it normally treats GStrings as valid for {{String}} targets?), but the lookup will fail at runtime.",,bgshacklett,chrylis,daniel_sun,emilles,mauromol,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6668,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 18 17:16:39 UTC 2022,,,,,,,,,,"0|i3fq4v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/May/18 14:45;daniel_sun;It is fixed: https://github.com/apache/groovy/commit/5f6689638160c44dccbf2b7155d35edff2389979;;;","26/Jul/18 04:53;paulk;Hey [~daniel_sun], looks like above commit is just the test. Do you now whether there was another commit? I'll set fix version to my best guess but please correct if you think that is wrong. Thnx.;;;","27/Jul/18 22:01;daniel_sun;https://github.com/apache/groovy/pull/708
As you see, the PR is rejected to merge... so the issue still exists...;;;","27/Jul/18 22:27;paulk;Okay. It was marked resolved but with no fix version. Thanks for reopening.;;;","29/Jul/18 08:16;daniel_sun;I find many users expect coercing GString to String when used as Map key, so it's better to take into account how to deal with the issue properly.;;;","23/Apr/19 12:29;bgshacklett;Has anyone found any good workarounds for this issue? I'm currently wrapping my map literal in `(collectEntries\{ k,v -> [(k.toString()):v]})`, because I haven't found any way to get Groovy to use a proper string as the key if the value is dynamic. Unfortunately, this doesn't work unless only the top level key is being set dynamically.;;;","23/Apr/19 17:28;emilles;One issue caused by Java in this space is that, for legacy reasons, Map's {{get}}, {{containsKey}} and other methods don't use the type parameter {{K}} but instead {{Object}}.  Thus, Java and Groovy have a hard time reasoning about the situation.  Eclipse recently introduced a check for suspicious type passed to {{equals}} because it has the same problem, but the check defaults to an info level message because warning or error was considered too strong.

I think if {{get}} accepted a {{String}}, Groovy would perform the coercion automatically or issue an error in STC mode.;;;","23/Apr/19 19:16;emilles;[~bgshacklett] When you mention map literals, do you mean something like this?
{code:groovy}
def a = 1, b = 2
Map<String, String> map = [
  ""$a"": ""one"",
  ""$b"": ""two""
]
{code}

I ask because flow-typing currently ignores the declaration generics, so Groovy assumes you meant GString as the key type.  You can add a typecase before or coercion after the GString literal to get to String so that you don't need to create a new map using {{collectEntries}}.  And it may not be too hard to create an AST xform that adds the casts or coercions to a map expression automatically.;;;","25/Feb/20 08:36;mauromol;Is this the same as, or at least related to, GROOVY-6668?;;;","18/Aug/22 17:16;emilles;https://github.com/apache/groovy/pull/1770;;;",,,,,,,,,,,,
ArrayIndexOutOfBoundsException at compilation when accessing a generic type with the wrong number of type parameters,GROOVY-8211,13076311,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,mjjustin,mjjustin,31/May/17 21:08,26/Jul/18 04:38,14/Jul/23 06:02,12/Apr/18 17:26,,,,,,,,,2.5.0-rc-2,,,,Static compilation,,,,0,,,,,,,"When using @CompileStatic, accessing a method on a type that is specified using too few type parameters causes an ArrayIndexOutOfBoundsException to be thrown by the Groovy compiler.  Furthermore, there is no indication where in the code the error occurs, so it can be very difficult to debug the issue.

{code}@CompileStatic
class GenericsCompilation {
  def method() {
    Map<String> map

    map.toString() //This line causes the issue
  }
}{code}

The output is:

{code}$ groovyc GenericsCompilation.groovy 
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during instruction selection: 1

java.lang.ArrayIndexOutOfBoundsException: 1
	at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:164)
	at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:136)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1338)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.typeCheckMethodsWithGenerics(StaticTypeCheckingSupport.java:1319)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.typeCheckMethodsWithGenericsOrFail(StaticTypeCheckingVisitor.java:4529)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2966)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:317)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:196)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:42)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:37)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:166)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:104)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:115)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1784)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:126)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2119)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2078)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:164)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1078)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:53)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:249)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:123)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:63)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:134)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:178)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1053)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:525)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:61)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:217)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:150)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:180)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:164)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131)
{code}

I discovered this issue when doing a refactoring that changed the number of type parameters on a type, but missed updating a spot in the code to use the correct number of parameters.  It was completely unclear to me where or what the issue was, other than the fact that it likely had something to do with generics.",,jwagenleitner,mjjustin,paulk,romanstumm,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7865,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 12 17:26:52 UTC 2018,,,,,,,,,,"0|i3fpsv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Apr/18 11:16;romanstumm;I had the a similar error with Groovy 2.4.15 during groovyc of a complex class annotated with CompileStatic:

Error:Groovyc: While compiling adm-core_main: java.lang.ArrayIndexOutOfBoundsException: 1
    at org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(GenericsUtils.java:167)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.extractPlaceHolders(StaticTypeCheckingVisitor.java:4801)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.resolvePlaceHoldersFromDeclaration(StaticTypeCheckingVisitor.java:4762)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnTypeGenerics(StaticTypeCheckingVisitor.java:4553)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:3165)
    at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:397)
    at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:70)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitBinaryExpression(StaticTypeCheckingVisitor.java:705)
    at org.codehaus.groovy.ast.CodeVisitorSupport.visitDeclarationExpression(CodeVisitorSupport.java:298)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitDeclarationExpression(ClassCodeVisitorSupport.java:110)
    at org.codehaus.groovy.ast.expr.DeclarationExpression.visit(DeclarationExpression.java:89)
    at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:122)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:196)
    at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:42)
    at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:88)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:166)
    at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
    at org.codehaus.groovy.ast.CodeVisitorSupport.visitForLoop(CodeVisitorSupport.java:94)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitForLoop(ClassCodeVisitorSupport.java:201)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitForLoop(StaticTypeCheckingVisitor.java:1768)
    at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitForLoop(StaticCompilationVisitor.java:439)
    at org.codehaus.groovy.ast.stmt.ForStatement.visit(ForStatement.java:49)
    at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:88)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:166)
    at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:104)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:115)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1963)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:126)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2318)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2277)
    at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:224)
    at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1081)
    at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:53)
    at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:375)
    at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:182)
    at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:67)
    at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:152)
    at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:196)
    at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1087)
    at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:624)
    at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:602)
    at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:579)
    at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:62)
    at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:115)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.jetbrains.groovy.compiler.rt.GroovycRunner.intMain2(GroovycRunner.java:136)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.jetbrains.jps.incremental.groovy.InProcessGroovyc.runGroovycInThisProcess(InProcessGroovyc.java:156)
    at org.jetbrains.jps.incremental.groovy.InProcessGroovyc.access$000(InProcessGroovyc.java:51)
    at org.jetbrains.jps.incremental.groovy.InProcessGroovyc$1.call(InProcessGroovyc.java:85)
    at org.jetbrains.jps.incremental.groovy.InProcessGroovyc$1.call(InProcessGroovyc.java:82)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
    at java.lang.Thread.run(Thread.java:748);;;","12/Apr/18 08:48;paulk;I have guarded against the AIOOBE and now in that case throw a GroovyBugError, e.g.:
{code}
BUG! exception in phase 'instruction selection' in source unit 'ConsoleScript16' Expected earlier checking to detect generics parameter arity mismatch
Expected: java.util.Map<K,V>
Supplied: java.util.Map<java.lang.String>
{code}
The real fix requires improving {{GenericsVisitor}} as can be seen in this example here:
{code}
@groovy.transform.CompileStatic
class GenericsCompilation {
  //Map<String> map               // (1)
  //Map<String, Map<String>> map  // (2)
  Map<String, String> map
  def method0() {
    map.toString()
  }

//  def method1(Map<String> map) {               // (3)
//  def method1(Map<String, Map<String>> map) {  // (4)
  def method1(Map<String, String> map) {
    map.toString()
  }

  def method2() {
    Map<String> map                 // (5)
//    Map<String, Map<String>> map  // (6)
//    Map<String, String> map
    map.toString()
  }
}

println GenericsCompilation
{code}
The visitor successfully detects top-level arity mismatches for fields and parameter; cases (1) and (3). At the moment, the code contents of a method aren't visited; case (5), and deeper levels of arity mismatch aren't handled; cases: (2), (4) and (6).;;;","12/Apr/18 17:26;paulk;Fixed in 2_5_X and above. On 2_4_X the AIOOBE is avoided but the type parameter arity mismatch is ignored.;;;",,,,,,,,,,,,,,,,,,,
VariableExpressionTransformer does not set source position on property expressions,GROOVY-8208,13075192,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,emilles,emilles,26/May/17 15:09,06/Mar/18 23:25,14/Jul/23 06:02,13/Aug/17 05:43,,,,,,,,,2.4.13,,,,xforms,,,,0,,,,,,,"Two paths in VariableExpressionTransformer create PropertyExpression nodes to stand in for unresolved variable references. Neither case sets the exp source position onto the new node. Other paths through this method transfer position info.
The fix is simple:
{code}
private static Expression tryTransformDelegateToProperty(VariableExpression expr) {
        // we need to transform variable expressions that go to a delegate
        // to a property expression, as ACG would loose the information
        // in processClassVariable before it reaches any makeCall, that could
        // handle it
        Object val = expr.getNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER);
        if (val == null) return null;
        VariableExpression implicitThis = new VariableExpression(""this"");
        PropertyExpression pexp = new PropertyExpression(implicitThis, expr.getName());
        pexp.copyNodeMetaData(expr);
        pexp.setImplicitThis(true);
        // GRECLIPSE add
        pexp.getProperty().setSourcePosition(expr);
        // GRECLIPSE end
        ClassNode owner = expr.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER);
        if (owner != null) {
            implicitThis.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, owner);
            implicitThis.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, val);
        }
        return pexp;
    }

    private static Expression tryTransformPrivateFieldAccess(VariableExpression expr) {
        FieldNode field = expr.getNodeMetaData(StaticTypesMarker.PV_FIELDS_ACCESS);
        if (field == null) {
            field = expr.getNodeMetaData(StaticTypesMarker.PV_FIELDS_MUTATION);
        }
        if (field != null) {
            // access to a private field from a section of code that normally doesn't have access to it, like a
            // closure or an inner class
            VariableExpression receiver = new VariableExpression(""this"");
            PropertyExpression pexp = new PropertyExpression(
                    receiver,
                    expr.getName()
            );
            pexp.setImplicitThis(true);
            // GRECLIPSE add
            pexp.getProperty().setSourcePosition(expr);
            // GRECLIPSE end
            // put the receiver inferred type so that the class writer knows that it will have to call a bridge method
            receiver.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, field.getDeclaringClass());
            // add inferred type information
            pexp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, field.getOriginType());
            return pexp;
        }
        return null;
    }
{code}

The first method affects code like
{code}
@groovy.transform.CompileStatic
class E {
    D d = new D()
    void doSomething() {
        d.with { // 'foo' and 'bar' VariableExpressions are xformed to PropertyExpressions
            foo = 'foo'
            bar = new D()
            bar.foo = 'bar'
        }
    }
}
{code}

The second method affects code like
{code}
@groovy.transform.CompileStatic
class X {
  String id
  @Lazy Object thing = { ->
    Directory.lookup(id) // 'id' is transformed from a VariableExpression to a PropertyExpression
  }()
}
{code}",,emilles,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 13 05:43:46 UTC 2017,,,,,,,,,,"0|i3fiw7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Aug/17 04:44;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/581

    GROOVY-8208: VariableExpressionTransformer does not set source positi…

    …on on property expressions

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8208-varxform

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/581.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #581
    
----
commit 48ce82bce883ee8bcba777a831ad1ee98b70bf45
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-08-13T04:43:06Z

    GROOVY-8208: VariableExpressionTransformer does not set source position on property expressions

----
;;;","13/Aug/17 05:31;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/581
;;;","13/Aug/17 05:43;jwagenleitner;Thanks for reporting the issue and providing the patch.;;;",,,,,,,,,,,,,,,,,,,
Using defaults=false and includeFields=true w/ @TupleConstructor errors over metaClass,GROOVY-8207,13075141,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,ultraq,ultraq,26/May/17 10:38,22/Nov/22 20:30,14/Jul/23 06:02,22/Nov/22 20:30,2.5.0-alpha-1,,,,,,,,,,,,groovy-jdk,,,,0,,,,,,,"When trying out the new defaults = false feature of @TupleConstructor in conjunction with includeFields = true, I get a compiler error of:

{{Groovyc: Error during @TupleConstructor processing, default value processing disabled but default value found for 'metaClass'}}

Seems that includeFields = true ropes in the metaClass field, and so to work around it I have to add excludes = \['metaClass'\] to the annotation.

Is this intended behaviour?  The example in the JavaDocs doesn't make mention of any metaClass or other Groovy internals, just declared fields.
http://docs.groovy-lang.org/docs/groovy-2.5.0-alpha-1/html/api/groovy/transform/TupleConstructor.html
",,ultraq,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-05-26 10:38:11.0,,,,,,,,,,"0|i3fikv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Static type checking failure for enums,GROOVY-8205,13074799,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,ichulovskyi,ichulovskyi,25/May/17 10:04,06/Mar/18 23:25,14/Jul/23 06:02,26/Aug/17 19:36,2.4.10,,,,,,,,2.5.0-beta-2,,,,Static Type Checker,,,,0,,,,,,,"Declare enum:
{code}
public enum Functions {
    A, B, C
}
{code}

Create test class, add the following test and try to compile:
{code}
    @Test
    @CompileStatic
    void testEachForEnum() {
        Functions.values().each { println it.name() }
    }
{code}

Result: Groovyc: [Static type checking] - Cannot find matching method java.lang.Object#name(). Please check if the declared type is right and if the method exists.

Expected: code should compile without errors","Windows 7, JDK 1.8.0_66",githubbot,ichulovskyi,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 26 19:32:03 UTC 2017,,,,,,,,,,"0|i3fggv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Aug/17 18:24;jwagenleitner;This particular issue was fixed by [commit 8c218dec34|https://github.com/apache/groovy/commit/8c218dec34730e92eb020cbb1b0888dcc89bd35b] for GROOVY-7283 which is part of the 2.5 release.;;;","26/Aug/17 18:58;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/592

    GROOVY-8205: Regression test for STC Enum values DGM methods

    Issue fixed by commit 8c218dec34 (GROOVY-7283)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8205-EachEnumValuesTest

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/592.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #592
    
----
commit 95674471a8070b812966f3d50315d7e4f4e19358
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-08-26T18:55:25Z

    GROOVY-8205: Regression test for STC Enum values DGM methods
    
    Issue fixed by commit 8c218dec34 (GROOVY-7283)

----
;;;","26/Aug/17 19:32;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/592
;;;",,,,,,,,,,,,,,,,,,,
@Delegate on arrays causes NPE during compilation,GROOVY-8204,13074796,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,kszafran,kszafran,25/May/17 09:47,06/Mar/18 23:14,14/Jul/23 06:02,26/May/17 02:37,2.4.11,,,,,,,,2.4.12,,,,,,,,0,,,,,,,"I have stumbled upon this bug partly by accident, and I'm not convinced it's a valid use case, but either way it should not crash the compiler with a NPE.

Trying to compile the following simple class:
{code}
import groovy.lang.Delegate

class BugsMe {

	@Delegate
	byte[] file
}
{code}

Results in the following exception:
{code}
>>> a serious error occurred: BUG! exception in phase 'canonicalization' in source unit 'BugsMe.groovy' unexpected NullpointerException
>>> stacktrace:
BUG! exception in phase 'canonicalization' in source unit 'BugsMe.groovy' unexpected NullpointerException
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1070)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:603)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:581)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:558)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:537)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:61)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:217)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:150)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:180)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:164)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131)
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.ast.ClassHelper.getNextSuperClass(ClassHelper.java:454)
	at org.codehaus.groovy.ast.ClassHelper.getNextSuperClass(ClassHelper.java:449)
	at org.codehaus.groovy.ast.tools.GenericsUtils.extractSuperClassGenerics(GenericsUtils.java:444)
	at org.codehaus.groovy.transform.DelegateASTTransformation.addDelegateMethod(DelegateASTTransformation.java:233)
	at org.codehaus.groovy.transform.DelegateASTTransformation.visit(DelegateASTTransformation.java:129)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:134)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:178)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1065)
	... 15 more
{code}",,githubbot,kszafran,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 26 02:37:34 UTC 2017,,,,,,,,,,"0|i3fgg7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/May/17 12:42;paulk;Is it a valid use case? Well, it certainly is an edge case! :-) And correct, it shouldn't crash the compiler.

Interestingly, a type of {{byte}} by itself is allowed though doesn't do anything useful since no methods are found. Also {{String[]}} causes a similar error, so it's not just primitive arrays causing grief. I'd be inclined to treat it just like the non-array primitive case. Allow it but not add any methods. Possibly you might expect a {{length}} property.;;;","25/May/17 13:38;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/551

    GROOVY-8204: @Delegate on arrays causes NPE during compilation

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8204

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/551.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #551
    
----
commit 8af2cf43dcf41d1614e75c1bb17046351c048472
Author: paulk <paulk@asert.com.au>
Date:   2017-05-25T13:37:14Z

    GROOVY-8204: @Delegate on arrays causes NPE during compilation

----
;;;","25/May/17 15:07;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/551#discussion_r118507014
  
    --- Diff: src/main/org/codehaus/groovy/ast/ClassHelper.java ---
    @@ -440,12 +440,15 @@ private static boolean hasUsableImplementation(ClassNode c, MethodNode m) {
         /**
          * Returns a super class or interface for a given class depending on a given target.
          * If the target is no super class or interface, then null will be returned.
    +     * For a non=primitive array type, returns an array of the componentType's superclass.
    --- End diff --
    
    non-primitive
;;;","26/May/17 02:04;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/551
;;;","26/May/17 02:08;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/551#discussion_r118622384
  
    --- Diff: src/main/org/codehaus/groovy/ast/ClassHelper.java ---
    @@ -440,12 +440,15 @@ private static boolean hasUsableImplementation(ClassNode c, MethodNode m) {
         /**
          * Returns a super class or interface for a given class depending on a given target.
          * If the target is no super class or interface, then null will be returned.
    +     * For a non=primitive array type, returns an array of the componentType's superclass.
    --- End diff --
    
    fixed the typo, thanks
;;;","26/May/17 02:37;paulk;Proposed PR merged. Arrays are now allowed though it isn't a very useful/interesting delegate. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,
Add @Newify will cause ?. operator NPE,GROOVY-8203,13074755,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,digitarts,digitarts,25/May/17 05:52,06/Mar/18 23:14,14/Jul/23 06:02,26/May/17 02:39,2.4.11,,,,,,,,2.4.12,,,,xforms,,,,0,features,,,,,,"Hi, guys:

    When I add {{@Newify}} annotation to a class and then use {{?.}} operator, I'll get a NPE, please see the sample code as below:

{code:java|title=Z.groovy|borderStyle=solid}
@Newify(A)
class Z {

    static void main(String... args) {
        def a
        a?.get('b')
    }

    class A {
    }

}
{code}","Win 8.1, Oracle JDK 8u121, Groovy 2.4.11",digitarts,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Important,,,,,,,,9223372036854775807,,,Fri May 26 02:39:59 UTC 2017,,,,,,,,,,"0|i3fg73:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/May/17 07:27;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/550

    GROOVY-8203: Add @Newify will cause ?. operator NPE

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8203

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/550.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #550
    
----
commit 8b4316c8f5ee70cbac2c71d465ecaf3048182676
Author: paulk <paulk@asert.com.au>
Date:   2017-05-25T07:26:54Z

    GROOVY-8203: Add @Newify will cause ?. operator NPE

----
;;;","26/May/17 01:54;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/550
;;;","26/May/17 02:39;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,
void tail calls in closures break @CompileStatic type inference,GROOVY-8202,13074301,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,joan.karadimov,joan.karadimov,23/May/17 19:08,03/Feb/22 22:34,14/Jul/23 06:02,09/May/21 15:23,2.4.10,,,,,,,,2.5.15,3.0.9,4.0.0-beta-1,,Static compilation,,,,0,,,,,,,"Consider this piece of code:
{code:groovy}
void f() {
}

@CompileStatic
String test1() {
	Closure<String> x = {
		if (true) {
			""asd""
		} else {
			f()
			null
		}
	}
	x.call()
}

@CompileStatic
String test2() {
	Closure<String> x = { // Cannot assign Closure<Object> to Closure<String>
		if (true) {
			""asd""
		} else {
			f()
		}
	}
	x.call()
}

@CompileStatic
String test3() {
	if (true) {
		""asd""
	} else {
		f()
	}
}
{code}

The code in _*test1*_ compiles correctly. The type of the closure in _*test2*_ is inferred as _*Closure<Object>*_ and that results in a static type checking error. There is an inconsistency here - in _*test3*_ the type inference yields _*String*_.

Basically - _*null*_ s are not considered when the type is inferred. Calls to void methods should not be either.",,emilles,joan.karadimov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-05-23 19:08:04.0,,,,,,,,,,"0|i3fde7:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Shorthand |= results in NPE",GROOVY-8200,13074190,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,dleh,dleh,23/May/17 12:54,06/Mar/18 23:25,14/Jul/23 06:02,24/Sep/17 10:55,2.3.11,,,,,,,,2.5.0-beta-2,,,,,,,,0,,,,,,,"I've stumbled across some curious behaviour for the shorthand assignment operator in Groovy v2.3.11 (symptom also present in Groovy v2.4.9).

The following [boolean or logic|^shorthand_or_symptom.groovy], unexpectedly throws {{NullPointerException}}.

{code}boolean x = null

// short hand unrolled:  x = null || x

x |= null // -> unexpected NullPointerException

assert !x{code}

The same approach for [boolean and logic|^shorthand_and.groovy], performs as expected.

{code}boolean x = null

// short hand unrolled:  x = null && x

x &= null

assert !x{code}

It's possible to work around the issue with explicit cast.

{code}x |= null as boolean{code}","Groovy Version: 2.3.11 JVM: 1.7.0_80 Vendor: Oracle Corporation OS: Linux

java version ""1.7.0_80""
Java(TM) SE Runtime Environment (build 1.7.0_80-b15)
Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)",blackdrag,dleh,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/May/17 12:54;dleh;shorthand_and.groovy;https://issues.apache.org/jira/secure/attachment/12869453/shorthand_and.groovy","23/May/17 12:54;dleh;shorthand_or_symptom.groovy;https://issues.apache.org/jira/secure/attachment/12869454/shorthand_or_symptom.groovy","24/May/17 08:18;dleh;shorthand_xor_symptom.groovy;https://issues.apache.org/jira/secure/attachment/12869598/shorthand_xor_symptom.groovy",,3.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 24 10:55:24 UTC 2017,,,,,,,,,,"0|i3fcpj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/May/17 18:46;blackdrag;x|=null is x=x|null, which results in x.or(null). You will see here that the expanded version and shorthand work the same. x=x||null will first convert x to boolean and depending on true or false we will also convert the null. Similar for the logic and binary and.
;;;","24/May/17 07:51;dleh;@[~blackdrag], I'm sorry but it seems my explanation wasn't clear enough. 

{quote}... Similar for the logic and binary and.{quote}

By executing the attached examples you'll be able to confirm that {{x |= null}} throws NPE and {{x &= null}} adheres to Groovy truth.
That's an inconsistency regarding null-handling in the |= shorthand notation and violates the [principle of least astonishment|https://en.wikipedia.org/wiki/Principle_of_least_astonishment].;;;","24/May/17 08:18;dleh;[Exclusive or|^shorthand_xor_symptom.groovy] {{x ^= null}} also throws NPE, same as {{x |= null}}.;;;","24/May/17 12:33;blackdrag;ah, ok, there is indeed a misunderstanding.  For {code:Java}
boolean x = true  
x & null
{code}
will NPE, but if you set x to false (the boolean sight on null) It does not NPE. That is imho because not both sides are evaluated. This is wrong and should be fixed. The inconsistency though is in the handling of & and &= not in the others. ;;;","24/May/17 16:31;dleh;[~blackdrag], thank you for revisiting this issue, it's much appreciated.

{quote}...
This is wrong and should be fixed.
...{quote}
I agree, consistency above all.

{quote}...
The inconsistency though is in the handling of & and &= not in the others.{quote}

But from a usability view, I think that having {{null}} adhere to Groovy truth is the convention I would expect Groovy to follow.
Ie. it would be preferable to avoid explicit cast ex.

{code}boolean success = method1(...)
success |= methodMightReturnNull(...) as boolean // this cast is disturbing the groove
success |= x == y
...{code}

My point is; having the NPE thrown is unexpected as Groovy usually handles the conversion from {{null}} to Groovy truth transparently and consistently.
Deviating from that convention introduces risk when using the shorthand notation, because then an extra manual step is required by the developer in-order to avoid a hidden NPE.;;;","24/May/17 18:21;blackdrag;I think you are let astray a bit by the fact, that we are talking about booleans. But those binary operators are not specific to booleans at all. I can do for example {code:Java}
class X {
  def foo
  def or(X x) {new X(foo:foo+"" or ""+x.foo)}
  String toString(){foo}
}

def a = new X(foo:""to be"")
def b = new X(foo:""not to be ..."")
println a|b
{code}and I would get ""to be or not to be"".

Now, what would you expect as result in this if a is null, or b is null or if both are null? And why is it different for boolean?

Also please do not forget, that Groovy truth is applied automatically only in very certain well known cases. null||x works, because the compiler enforces a boolean case for the operands. Then does x||null and even null||null. It does not matter what type x is here, because of this enforcement. But this also means not having a method behind this operator. This is completely extended by the compiler in exactly one way and only this way. The same goes for example for ""if (x)..."". Here we do know again we require a boolean and the compiler will cause a boolean cast to ensure this.;;;","29/May/17 14:22;dleh;@[~blackdrag]; ahh, I see, I had forgotten Groovys support for operator-overload, this complicates matters a bit.
On one hand I see the use-case for meta-programming support, and on the other hand I appreciate the simplicity of Groovys truth convention and boolean operators as-is.

I know which approach I would prefer, but I'm unable to fully comprehend the consequences of either.

Quite the conundrum :);;;","31/May/17 19:01;githubbot;GitHub user noamt opened a pull request:

    https://github.com/apache/groovy/pull/555

    GROOVY-8200 - Shorthand |= results in NPE

    Fixing the NPE with an explicit test and assignment of the right-hand boolean operator.
    Assigning a primitive boolean variable with null, like `boolean x = null`, will end up as `false`.
    I think it only makes sense to apply the same behavior to the right hand operator.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/noamt/groovy GroovyGROOVY-8200

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/555.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #555
    
----
commit 11a0b159d8d04f3c1e518613566a1b459ecda44d
Author: noamt <noam@10ne.org>
Date:   2017-05-31T18:57:04Z

    GROOVY-8200 - Shorthand |= results in NPE:
    Fixing the NPE with an explicit test and assignment of the right-hand boolean operator.
    Assigning a primitive boolean variable with null, like `boolean x = null`, will end up as `false`.
    I think it only makes sense to apply the same behavior to the right hand operator.

----
;;;","24/Sep/17 10:10;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/555
;;;","24/Sep/17 10:55;paulk;I agree with Jochen's comment that we don't want any special treatment of the expansion into the {{or}} method in this case for the {{|=}} shorthand. I also agree with John's assessment in the PR that the implementation of {{or}} could handle this case for {{Boolean}} only. Proposed PR merged but only from 2.5.0-beta-2 onwards which allows us some time to re-consider before 2.5.0 final comes out.;;;",,,,,,,,,,,,
CompileStatic fails to infer correct type when using elvis operator,GROOVY-8195,13073691,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,pootow,pootow,21/May/17 09:02,26/Jul/18 04:44,14/Jul/23 06:02,17/Jun/18 03:08,2.4.9,,,,,,,,2.4.13,,,,Static Type Checker,,,,0,,,,,,,"see the following example:

{code}
import groovy.transform.CompileStatic


@CompileStatic
def foo() {
    Map<String, String> strongMap
    Map<String, String> elvisMap = strongMap ?: [:] // won't compile
    Map<String, String> initStrongMap = [:] // compiles ok
}

{code}",,jwagenleitner,pootow,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 17 03:08:37 UTC 2018,,,,,,,,,,"0|i3f9mn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jun/18 03:08;jwagenleitner;Thanks for reporting the issue, looks like this was fixed in 2.4.13.;;;",,,,,,,,,,,,,,,,,,,,,
TraitReceiverTransformer does not set source position on property expressions,GROOVY-8193,13072876,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,emilles,emilles,17/May/17 17:08,06/Mar/18 23:14,14/Jul/23 06:02,20/May/17 16:43,,,,,,,,,2.4.12,,,,xforms,,,,0,,,,,,,"Two paths in TraitReceiverTransformer.transform create PropertyExpression nodes to stand in for unresolved variable references.  Neither case sets the exp source position onto the new node.  Other paths through this method transfer position info.

The fix is simple: {code}
            } else if (accessedVariable instanceof PropertyNode) {
                String propName = accessedVariable.getName();
                if (knownFields.contains(propName)) {
                    return createFieldHelperCall(exp, weavedType, propName);
                } else {
                    // GRECLIPSE edit
                    PropertyExpression pe =
                    /*return*/ new PropertyExpression(
                            new VariableExpression(weaved),
                            accessedVariable.getName()
                    );
                    pe.getProperty().setSourcePosition(exp);
                    return pe;
                    // GRECLIPSE end
                }
            } else if (accessedVariable instanceof DynamicVariable) {
                // GRECLIPSE edit
                PropertyExpression pe =
                /*return*/ new PropertyExpression(
                        new VariableExpression(weaved),
                        accessedVariable.getName()
                );
                pe.getProperty().setSourcePosition(exp);
                return pe;
                // GRECLIPSE end
            }
{code}",,arsen.babakhanyan,emilles,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 20 20:42:36 UTC 2017,,,,,,,,,,"0|i3f4lj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/May/17 18:51;githubbot;GitHub user ArsenBabakhanyan opened a pull request:

    https://github.com/apache/groovy/pull/542

    GROOVY-8193: setting sourcePosition on Property Expression

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/ArsenBabakhanyan/groovy GROOVY-8193

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/542.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #542
    
----
commit cc750bf27917f04ae5f3de872fa0d42c8050d10e
Author: Arsen Babakhanyan <arsen.ba@gmail.com>
Date:   2017-05-19T18:46:39Z

    GROOVY-8193: setting sourcePosition on Property Expression

----
;;;","20/May/17 15:20;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/542
;;;","20/May/17 16:43;jwagenleitner;PR  from Arsen Babakhanyan merged, thanks for reporting the issue.;;;","20/May/17 20:42;arsen.babakhanyan;thanks [~jwagenleitner] for help;;;",,,,,,,,,,,,,,,,,,
CompileStatic cant infer type when using map as map key,GROOVY-8190,13072008,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,pootow,pootow,15/May/17 13:32,08/Mar/22 12:16,14/Jul/23 06:02,11/Oct/21 17:45,2.4.6,,,,,,,,,,,,Static Type Checker,,,,0,,,,,,,"open groovy console, paste code below
{code}
import groovy.transform.*

@CompileStatic
void foo(Map<Map<String, String>, List<Map<String, Object>>> map){
    for(Map<String, String> key : map.keySet()) {
        def x = map[key]
        def y = x[0][""""]
    }
}
{code}

and you will see it fails to compile

{noformat}
Result: org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
ideaGroovyConsole.groovy: 7: [Static type checking] - Cannot find matching method java.lang.Object#getAt(int). Please check if the declared type is right and if the method exists.
 @ line 7, column 17.
           def y = x[0][""""]
                   ^
1 error
	at org.codehaus.groovy.control.ErrorCollector.failIfErrors(ErrorCollector.java:310)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1075)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:688)
	at groovy.lang.GroovyShell.run(GroovyShell.java:517)
	at groovy.lang.GroovyShell.run(GroovyShell.java:497)
	at sun.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:169)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:71)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
	at console.run(console.txt:25)
	at groovy.ui.GroovyMain.processReader(GroovyMain.java:631)
	at groovy.ui.GroovyMain.processFiles(GroovyMain.java:539)
	at groovy.ui.GroovyMain.run(GroovyMain.java:382)
	at groovy.ui.GroovyMain.process(GroovyMain.java:370)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:129)
	at groovy.ui.GroovyMain.main(GroovyMain.java:109)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:65)
{noformat}

and if you change map key to other type (e.g a {{List<>}}), it will compile just fine.",,emilles,jwagenleitner,pootow,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Oct 11 17:45:38 UTC 2021,,,,,,,,,,"0|i3eza7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Oct/21 17:45;emilles;Fixed in Groovy 2.5+;;;",,,,,,,,,,,,,,,,,,,,,
Builder ExternalStrategy constructors have trouble with private fields,GROOVY-8186,13071298,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,jktw,jktw,11/May/17 18:51,06/Mar/18 23:25,14/Jul/23 06:02,29/Aug/17 06:22,2.4.x,2.5.x,,,,,,,2.5.0-beta-2,,,,,,,,0,,,,,,,"An undocumented feature of @Builder is that the builder's constructor can set default values for the fields. See http://stackoverflow.com/questions/35066664/default-values-in-groovy-builder-ast

I tried creating an ExternalStrategy @Builder annotation for [BaseClientDetails|http://docs.spring.io/spring-security/oauth/apidocs/org/springframework/security/oauth2/provider/client/BaseClientDetails.html] with a constructor that set a default scope. I received a MissingMethodException exception, which I thought was odd.

I added some tests to BuilderTransformTest that demonstrate apparent problems using the external builder in two situations:
1) A groovy class with private fields and manually defined setters.
2) A java class with a private Set field and a setter that takes a Collection

The tests are here: https://github.com/jterhune/groovy/commit/5b2eb74cc8184235b5235b7fd4c80b241799bbc5

I noticed this in 2.4.x. My tests fail in the 2.5.x branch also.
",,githubbot,jktw,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 29 06:22:04 UTC 2017,,,,,,,,,,"0|i3euwf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/May/17 01:19;paulk;For case (1), which is when the builder class and buildee class are in the same compilation unit, you are correct that JavaBean properties aren't considered, just standard Groovy properties. We probably should change this. I suspect what we do for {{@ToString}}, where the underlying transform calls {{BeanUtils.getAllProperties}} to get the complete set of properties, is the way to go.

For case (2), it isn't really Groovy vs Java but whether the class is pre-compiled or not. When pre-compiled, {{@Builder}} uses standard JavaBean introspection to find the properties. If the parameter type of the setter doesn't match with the return type of the getter, the property is deemed read-only from a JavaBean perspective (and there just happens to be a setter-like named method also existing with a different parameter type):
{code}
def personClass = new GroovyShell().evaluate '''
class GroovyPerson {
    private Set<String> pets
    //Collection<String> getPets() { pets }
    Set<String> getPets() { pets }
    //void setPets(Set<String> pets) {
    void setPets(Collection<String> pets) {
        this.pets = pets == null ? Collections.emptySet() : new LinkedHashSet<String>(pets)
    }
}
GroovyPerson
'''
java.beans.Introspector.getBeanInfo(personClass).propertyDescriptors.each { pd ->
    if (!['class', 'metaClass'].contains(pd.name))
        println ""$pd.name $pd.propertyType.name $pd.writeMethod""
}
{code}
The null {{writeMethod}} indicates a read-only property. Uncomment either of the commented out lines (and remove the appropriate existing line) to see the property reappear.
I suspect we don't want to change that but I haven't checked what case (1) does in that situation yet - if we were to fix it as per above.;;;","23/May/17 04:18;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/547

    GROOVY-8186: Builder ExternalStrategy constructors have trouble with …

    …private fields

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8186

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/547.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #547
    
----
commit fa56fca09203e1e70963a79d309a55a058d439f6
Author: paulk <paulk@asert.com.au>
Date:   2017-05-23T04:17:45Z

    GROOVY-8186: Builder ExternalStrategy constructors have trouble with private fields

----
;;;","29/Aug/17 06:17;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/547
;;;","29/Aug/17 06:22;paulk;I extended the proposed PR to handle both ExternalStrategy and DefaultStrategy and merged it. Thanks for the suggestion.;;;",,,,,,,,,,,,,,,,,,
Class constant withouts .class in annotation value resolves as VariableExpression,GROOVY-8184,13070383,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,DameNoSupaplex,DameNoSupaplex,09/May/17 11:38,20/Apr/23 17:12,14/Jul/23 06:02,20/Apr/23 17:12,,,,,,,,,5.0.0-alpha-1,,,,Stub generator / Joint compiler,,,,0,annotations,,,,,,"If I write class name of java class in same package without .class inside annotation definition, expresson not resolves as ClassExpresson, but VariableExpression. In stub generation VariableExpression represents as only name of class whithout .class and leading to incorrect java file.
Example:
groovy:
{code}
@SomeAnnotation(SomeJavaClass)
class Foo {}
{code}
generated stub:
{code}
@SomeAnnotation(SomeJavaClass) //should be @SomeAnnotation(SomeJavaClass.class)
public class Foo {}
{code}",,DameNoSupaplex,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10571,,,,,,,GROOVY-10996,GROOVY-10607,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 20 17:12:39 UTC 2023,,,,,,,,,,"0|i3ep9z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Apr/22 20:14;emilles;See comment(s) in GROOVY-10571 for details on type reference resolution.;;;","19/Apr/23 22:39;emilles;You can add ""import some.pack.SomeJavaClass"" or write ""@SomeAnnotation(SomeJavaClass.class)"" to work around the chicken-egg problem that exists with the bi-directional dependencies.  The [JavaAwareCompilationUnit|https://github.com/apache/groovy/blob/master/src/main/java/org/codehaus/groovy/tools/javac/JavaAwareCompilationUnit.java] does know about the java sources being compiled but does not know what classes are declared within.

Here is an example that relies on an import: https://github.com/apache/groovy/blob/master/subprojects/groovy-macro/src/main/groovy/org/codehaus/groovy/macro/matcher/internal/MatchingConstraintsBuilder.groovy#L71;;;","20/Apr/23 17:12;emilles;https://github.com/apache/groovy/commit/0d11c032af048375dc7ee7ac7dcce5d2e3400f4b;;;",,,,,,,,,,,,,,,,,,,
"Map-style constructor call, inner class and static compilation",GROOVY-8179,13069930,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mauromol,mauromol,08/May/17 09:35,03/Feb/22 22:34,14/Jul/23 06:02,25/Oct/21 15:01,2.4.11,,,,,,,,2.5.15,3.0.9,4.0.0-beta-1,,Static compilation,,,,0,,,,,,,"Consider the following:

{code}
package c 

import groovy.transform.CompileStatic

@CompileStatic
class C { 
	class MyBean { 
		String foo 
		int bar 
	} 
	class AnotherClass { 
		int createInt() { 
			return 1 
		} 
		String createString() { 
			return 'foo' 
		} 
	} 
	
	void doSomething() { 
		def a = new AnotherClass() 
		def b = new MyBean(foo: a.createString()) 
	} 
}
{code}

The compiler complains on {{new MyBean(...)}}:

{noformat}
\src\main\groovy\c\C.groovy: 22: [Static type checking] - Cannot find matching method c.C$MyBean#<init>(c.C, java.util.LinkedHashMap <java.lang.String, java.lang.String>). Please check if the declared type is right and if the method exists.
 @ line 22, column 11.
{noformat}

Changing it to {{new C.MyBean(...)}} works though.",,emilles,mauromol,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-05-08 09:35:13.0,,,,,,,,,,"0|i3emhb:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Codenarc broken in quality build,GROOVY-8178,13069844,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,08/May/17 00:35,06/Mar/18 23:14,14/Jul/23 06:02,09/May/17 01:51,,,,,,,,,2.4.12,,,,,,,,0,,,,,,,"Codenarc checking is currently broken in the quality build. The various codenarc tasks run but show 0 files processed and the following error:
{noformat}
Error from [org.codenarc.rule.imports.UnusedImportRule]
processing source file [[...path to source file...].groovy]
{noformat}
Perhaps a rule named has changed. Haven't checked just yet.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 09 01:51:29 UTC 2017,,,,,,,,,,"0|i3ely7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/May/17 01:51;paulk;Solved for now by temporarily disabling the UnusedImport rule. We should consider adding that rule back in it we can find out why it was failing.;;;",,,,,,,,,,,,,,,,,,,,,
tap - exception in phase 'instruction selection',GROOVY-8176,13069063,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,cazacugmihai,cazacugmihai,04/May/17 08:50,12/Jun/17 00:12,14/Jul/23 06:02,07/May/17 06:36,2.5.0-alpha-1,,,,,,,,2.5.0-beta-1,,,,Compiler,,,,0,,,,,,,"{code}
import groovy.transform.CompileStatic

@CompileStatic
abstract class Person {
	String firstName
	String lastName
}

@CompileStatic
class Student extends Person {
	Set<String> courses
}

@CompileStatic
final class Converter {
	static <P extends Person> P toUser1(P person, Map map) { // ok
		if (!map) {
			return person
		}

		person.firstName = map['firstName']
		person.lastName = map['lastName']
		return person
	}

	static <P extends Person> P toUser2(P person, Map map) { // ok
		if (!map) {
			return person
		}

		person.tap {
			firstName = map['firstName']
			lastName = map['lastName']
		}
	}

	static <P extends Person> P toUser3(P person, Map map) { // ok
		person.tap {
			firstName = map['firstName']
			lastName = map['lastName']
		}
	}

	// Caught: BUG! exception in phase 'instruction selection' in source unit '/reproducer.groovy' unexpected NullpointerException
	static <P extends Person> P toUser4(P person, Map map) {
		!map ? person : person.tap {
			firstName = map['firstName']
			lastName = map['lastName']
		}
	}

	// static Student toStudent(Map map) {
	// 	!map ? null : toUser4(new Student(), map)
	// }
}

@CompileStatic
class Reproducer {
	static void reproduce() {
		Map map = [firstName: 'John', lastName: 'Doe']

		println Converter.toUser1(new Student(), map).dump()
		println Converter.toUser2(new Student(), map).dump()
		println Converter.toUser3(new Student(), map).dump()
		//println Converter.toUser4(new Student(), map).dump()
		//println Converter.toStudent(map).dump()
	}	
}

Reproducer.reproduce()
{code}",,cazacugmihai,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 07 06:36:12 UTC 2017,,,,,,,,,,"0|i3eh4v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/May/17 03:41;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/535

    GROOVY-8176: tap - exception in phase 'instruction selection'

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8176

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/535.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #535
    
----
commit 77a428ee8e4dd941ae94aab0ade2161b559b04f9
Author: paulk <paulk@asert.com.au>
Date:   2017-05-05T03:36:41Z

    GROOVY-8176: tap - exception in phase 'instruction selection'

----
;;;","07/May/17 06:34;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/535
;;;","07/May/17 06:36;paulk;Proposed PR merged. Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,
Groovy.Sql+Oracle parameter substitution problem,GROOVY-8174,13068891,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,pixelpshr,pixelpshr,03/May/17 19:29,06/Mar/18 23:14,14/Jul/23 06:02,05/May/17 03:55,2.4.11,,,,,,,,2.4.12,,,,SQL processing,,,,0,,,,,,,"I'm using the groovy.sql libraries inside of a Java program and having trouble with parameter substitution. My code looks like this:

{code}
                def mdds = Sql.newInstance(...)

		Map<String, Object>params = new HashMap<String, Object>();
		params.clear();
		params.put(""source_system_id"", Integer.valueOf(6));
		params.put(""rec_loc_txt"", ""Test"" + randomNum.toString());
		params.put(""created_dt_tm"", new Timestamp(System.currentTimeMillis()));
		
		String mdSqlString = ""INSERT INTO MD_CATALOG "" +
		                  ""      (SOURCE_SYSTEM_ID, REC_LOC_TXT, CREATED_DT_TM)"" + 
		                  ""      VALUES"" + 
		                  ""      (:source_system_id, :rec_loc_txt, :created_dt_tm)"";

		try {
			List<List<Object>> keys = mdds.executeInsert(params, mdSqlString);
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
{code}

But, when it runs, I get an exception thrown that says:

{code}
Exception in thread ""main"" java.lang.IllegalArgumentException: Found 4 parameter placeholders but supplied with 3 parameters
	at groovy.sql.Sql.setParameters(Sql.java:4116)
	at groovy.sql.Sql.getPreparedStatement(Sql.java:4394)
	at groovy.sql.Sql.executeInsert(Sql.java:2610)
	at groovy.sql.Sql.executeInsert(Sql.java:2674)
	at org.mitre.mac.Main.main(Main.java:70)
{code}

But, I only see 3 placeholders for my 3 parameters. 

Via email, John Wagenleitner replied:

I did a quick test with Groovy 2.4.11 and Oracle 11.2.0.4 (ojdbc6.jar 11.2.0.4 and ojdbc7.jar 12.1.0.2.0) and get the same error.  From what I am seeing Oracle changes the sql to:

{code}INSERT INTO MD_CATALOG (SOURCE_SYSTEM_ID, REC_LOC_TXT, CREATED_DT_TM) VALUES (?, ?, ?) RETURNING ROWID INTO ?{code}

adding the extra bind parameter for ROWID and this is reflected in the call to [metaData.getParameterCount()|https://github.com/apache/groovy/blob/GROOVY_2_4_11/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java#L4115]","Java 1.8.0_131, Groovy 2.4.11, Oracle ojdbc7 12.1.0.2.0",githubbot,jwagenleitner,paulk,pixelpshr,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 15 23:49:00 UTC 2017,,,,,,,,,,"0|i3eg2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/May/17 19:43;pixelpshr;The same error is produced when using the

public List<GroovyRowResult> executeInsert(Map params,
                                           String sql,
                                           List<String> keyColumnNames)
                                    throws SQLException

version and explicitly providing the autoincrementing key column name.

;;;","03/May/17 23:19;paulk;Looks like we can't win using parameter count metadata. I think we'll just have to give a warning in the log if the counts don't match.;;;","04/May/17 00:55;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/534

    GROOVY-8174: Groovy.Sql+Oracle parameter substitution problem

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8174

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/534.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #534
    
----
commit 0efbd83cf46678cc7dacc365634af24db0affb96
Author: paulk <paulk@asert.com.au>
Date:   2017-05-04T00:53:41Z

    GROOVY-8174: Groovy.Sql+Oracle parameter substitution problem

----
;;;","05/May/17 03:51;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/534
;;;","05/May/17 03:55;paulk;Proposed PR merged. Thanks for spotting the issue and thanks for checking John.;;;","15/Jun/17 23:49;paulk;The fix was changed to remove throwing the exception in the one remaining case that we thought worked with all drivers - since some commonly used drivers are buggy for the functionality we were using. We now just give a log warning message if the number of declared and supplied parameters don't match. Since we haven't yet released 2.4.12, the fix version remains the same.;;;",,,,,,,,,,,,,,,,
Escaped dollar slashy difference between old and parrot parsers,GROOVY-8171,13068158,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,jwagenleitner,jwagenleitner,01/May/17 16:26,26/Jul/18 04:46,14/Jul/23 06:02,20/May/18 02:32,2.6.0-alpha-3,3.0.0-alpha-2,,,,,,,2.6.0-alpha-4,3.0.0-alpha-3,,,parser-antlr4,,,,0,,,,,,,"The following test passes with the legacy parser but fails with Parrot

{code}
// legacy parser
def s1 = $/this $$/ is an escaped dollar forward slash/$
assert s1 == 'this $/ is an escaped dollar forward slash'
{code}

{code}
// antlr4 enabled (parrot)
assert s1 == 'this $/ is an escaped dollar forward slash'
       |  |
       |  false
       this / is an escaped dollar forward slash
{code}

Noticed this when I inadvertently changed a spec test in commit [0fb89906aa|https://github.com/apache/groovy/commit/0fb89906aa587920d11fae063bba1d1f8fe26254].  When testing for an escaped dollar slash the test had to be changed ([commit 942cf4eb3e|https://github.com/apache/groovy/commit/942cf4eb3e87f2718df490b9e3547f2042720781]) to pass using the Antlr4 parser.

Based on the [dollar slashy docs|http://www.groovy-lang.org/syntax.html#_dollar_slashy_string] I am not sure if the old behavior is correct or not.",,githubbot,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 20 01:52:44 UTC 2018,,,,,,,,,,"0|i3ebjr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/May/17 16:28;githubbot;Github user jwagenleitner commented on the pull request:

    https://github.com/apache/groovy/commit/0fb89906aa587920d11fae063bba1d1f8fe26254#commitcomment-21969276
  
    I created [GROOVY-8171](https://issues.apache.org/jira/browse/GROOVY-8171) because there is a slight difference in behavior between the parsers when escaping the opening dollar slashy.  Not sure if it's really a problem or not.
;;;","02/May/17 00:32;paulk;It looks like a bug in the parrot parser to me.;;;","19/May/18 15:48;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/712

    GROOVY-8171: Escaped dollar slashy difference between old and parrot …

    …parsers

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8171-dollar-slash-parrot

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/712.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #712
    
----
commit ae89f1b96d6fcf60837b995d871e3489312adb87
Author: John Wagenleitner <jwagenleitner@...>
Date:   2018-05-19T15:45:25Z

    GROOVY-8171: Escaped dollar slashy difference between old and parrot parsers

----
;;;","20/May/18 01:52;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/712
;;;",,,,,,,,,,,,,,,,,,
"StaticCompilationVisitor.visitForLoop sets Parameter origin type, which prevents access to original source type and location",GROOVY-8169,13067498,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,emilles,emilles,27/Apr/17 20:21,12/Aug/19 12:55,14/Jul/23 06:02,30/Jul/19 09:13,,,,,,,,,2.5.8,3.0.0-beta-3,,,Static compilation,,,,0,,,,,,,"{{StaticCompilationVisitor.visitForLoop}} has call to {{forLoop.getVariable().setOriginType(componentType)}}.  I think this call is unnecessary as the inferred type is set on the previous line.  By replacing the origin type, it is no longer possible to determine the uninferred type of the parameter or the source location of the ClassNode.  Additionally, I think the semantics of origin type is not being preserved by overwriting the value.

Example:
{code}
@CompileStatic
def m() {
  List<String> strings = ...
  for (String s in strings) {
  }
}
{code}

In this example, the second occurrence of String is replaced in the AST by the first and so the source position of the ClassNode after ""for"" and before ""s"" is lost.",,daniel_sun,emilles,jwagenleitner,shils,,,,,"eric-milles commented on pull request #975: GROOVY-8169: preserve origin type of for loop variable
URL: https://github.com/apache/groovy/pull/975
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Jul/19 19:22;githubbot;600","danielsun1106 commented on pull request #975: GROOVY-8169: preserve origin type of for loop variable
URL: https://github.com/apache/groovy/pull/975
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;30/Jul/19 09:12;githubbot;600","danielsun1106 commented on issue #975: GROOVY-8169: preserve origin type of for loop variable
URL: https://github.com/apache/groovy/pull/975#issuecomment-516336058
 
 
   Merged. Thanks!
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;30/Jul/19 09:12;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 30 09:13:30 UTC 2019,,,,,,,,,,"0|i3e7h3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/May/17 03:32;shils;That line was added as part of the fix for GROOVY-5641, but all tests currently pass without it everywhere from 2_4_X to master. That way, it certainly does look unnecessary. Do you happen to have an example of something that fails due to the loss of uninferred type information?;;;","08/May/17 14:15;emilles;For one, code editors get the wrong picture of the source.  In the Eclipse IDE, this extra bit prevents code hover and select on the type in the for statement.;;;","30/Jul/19 09:13;daniel_sun;The proposed PR was merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,
When using Interface: BigDecimal cannot be cast to Double,GROOVY-8168,13066807,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,artemik,artemik,25/Apr/17 20:15,30/May/23 17:48,14/Jul/23 06:02,30/May/23 17:20,2.4.10,,,,,,,,5.0.0-alpha-1,,,,,,,,0,,,,,,,"Execute the following code. 

{code}
interface SomeOperation {
    double calculate(int i)
}
SomeOperation operation = { return 1.0 }
operation.calculate(2)
{code}

Results in exception:
{code}
 java.lang.ClassCastException: java.math.BigDecimal cannot be cast to java.lang.Double
	at com.sun.proxy.$Proxy21.calculate(Unknown Source)
	at SomeOperation$calculate.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at ideaGroovyConsole.run(ideaGroovyConsole.groovy:5)
	at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:263)
	at groovy.lang.GroovyShell.run(GroovyShell.java:518)
	at groovy.lang.GroovyShell.run(GroovyShell.java:497)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite$PogoCachedMethodSite.invoke(PogoMetaMethodSite.java:169)
	at org.codehaus.groovy.runtime.callsite.PogoMetaMethodSite.call(PogoMetaMethodSite.java:71)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
	at console.run(console.txt:25)
	at groovy.ui.GroovyMain.processReader(GroovyMain.java:632)
	at groovy.ui.GroovyMain.processFiles(GroovyMain.java:540)
	at groovy.ui.GroovyMain.run(GroovyMain.java:382)
	at groovy.ui.GroovyMain.process(GroovyMain.java:370)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:129)
	at groovy.ui.GroovyMain.main(GroovyMain.java:109)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:65)
{code}",,artemik,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10277,,GROOVY-10792,GROOVY-11051,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 30 17:20:14 UTC 2023,,,,,,,,,,"0|i3e37j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Apr/17 20:44;emilles;Use ""1.0d"" and you should be fine.;;;","30/May/23 17:20;emilles;https://github.com/apache/groovy/blob/f1aef96fed3d8911afba1d160ce07ff085e14dc2/src/test/groovy/transform/stc/TypeCheckingExtensionsTest.groovy#L500;;;",,,,,,,,,,,,,,,,,,,,
Repeated operations in AnnotationCollectorTransform and Traits,GROOVY-8166,13066736,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,emilles,emilles,25/Apr/17 16:19,06/Mar/18 23:14,14/Jul/23 06:02,20/May/17 15:03,,,,,,,,,2.4.12,,,,,,,,0,,,,,,,"I think there are a couple bits of redundant code that I have run into looking at some stuff related to traits and type checking.

1) In {{org.codehaus.groovy.transform.trait.Traits.isTrait(ClassNode)}}, the check for the Trait annotation appears redundant to the call to {{isAnnotatedWithTrait}}.

2) In {{org.codehaus.groovy.transform.AnnotationCollectorTransform.makeListOfAnnotations(Object[][])}}, the recent addition of {{copyMembers}} appears to have missed removing the following line {{toAdd.getMembers().putAll(generated);}}.  Thus I think the map {{generated}} is being asked to put the same entries twice.",,emilles,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 20 15:03:32 UTC 2017,,,,,,,,,,"0|i3e2rr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/May/17 00:19;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/543

    GROOVY-8166: Repeated operations in AnnotationCollectorTransform and …

    …Traits

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8166

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/543.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #543
    
----
commit 72c01601d4cdd00622e6215b2a8d8dcac2ca4a89
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-05-19T19:48:53Z

    GROOVY-8166: Repeated operations in AnnotationCollectorTransform and Traits

----
;;;","20/May/17 13:57;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/543
;;;","20/May/17 15:03;jwagenleitner;Thanks for pointing out the duplicate ops.;;;",,,,,,,,,,,,,,,,,,,
Groovy allows a Java class to inherit static methods from its interface,GROOVY-8164,13066476,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,DmitryKh,DmitryKh,24/Apr/17 20:34,21/Jun/23 15:51,14/Jul/23 06:02,13/Dec/21 20:59,2.4.7,,,,,,,,3.0.18,4.0.0-rc-2,,,Compiler,Static compilation,,,0,breaking,,,,,,"In the following situation Java doesn't compile (as per JLS8 - 8.4.8 Inheritance, Overriding, and Hiding):
{code:java}
interface Foo {
  static void foo() {
    System.out.println(""static void foo() called"");
  }
}

class Bar implements Foo { }

public class FooBarTest {
    public static void main(String[] args) {
        Bar.foo();
    }
}
{code}
{code}
$ javac FooBarTest.java
FooBarTest.java:3: error: cannot find symbol
        Bar.foo();
           ^
  symbol:   method foo()
  location: class Bar
1 error
{code}
But Groovy does compile, both dynamic and @CompileStatic and we get {{static void foo() called}} in the output

Just in case, here is a snippet from _JLS8_:
*8.4.8 Inheritance, Overriding, and Hiding*
A class C inherits from its direct superclass all concrete methods m (both static and instance) of the superclass for which all of the following are true:
...
A class does not inherit static methods from its superinterfaces.",,blackdrag,DmitryKh,dongjoon,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10504,,GROOVY-10605,GROOVY-11107,GROOVY-10590,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Dec 13 20:59:57 UTC 2021,,,,,,,,,,"0|i3e15z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Apr/17 20:37;DmitryKh;Meanwhile, I'm trying to figure out how it can be fixed. I'll create a PR or post here if any questions;;;","25/Apr/17 06:16;blackdrag;Do we really have to follow the JLS here? hat is the disadvantage of not doing so?;;;","25/Apr/17 07:07;DmitryKh;This behaviour was found while fixing another issue GROOVY-7879. There was a quick discussion about this in https://github.com/apache/groovy/pull/521. Maybe it's worth more thorough discussion. I was a bit confused, to be honest, when I discovered this on Java side. But shouldn't \@CompileStatic behave like Java in this scenario?;;;","25/Apr/17 08:35;blackdrag;The discussion in PR 521 does not really help me, since I need to understand the reasoning behind why this is not done in Java like we do it in Groovy right now. Only after I understand why they do it like they do I can tell if it makes sense to do it the same way in Groovy.

I mean I can imagine a case... assume class Foo implements I1, I2; and those interface provide a static method of equal signature. Will we then call through Foo the I1 or the I2 version? But while Java does not depend on the ordering, we do depend on the ordering in several situations  - Traits for example... which actually opens the question... What if your Foo is a trait? Implementation wise I know the result will be vastly different from the pure interface case, but still it may look strange if we allow it for traits (which you still add to the implements clause for your class), but then not for interfaces.;;;","25/Apr/17 08:53;paulk;Actually I was going to suggest we discuss this on the mailing list too. It's not a given that we want to follow Java but we want to have well-specified behavior for all cases. I know we don't have test coverage for all cases and I imagine that what is currently implemented hasn't changed in some places even with changes to Java etc. If someone doesn't beat me to it, I'll try to formulate an email over the next few days while I am waiting for the 2.4.11 VOTE to timeout! :-);;;","13/Dec/21 20:09;emilles;{code:java}
public interface I {
  static void m() {
    System.out.print(""I"");
  }
}
public interface J {
  static void m() {
    System.out.print(""J"");
  }
}
{code}

{code:groovy}
class C implements I, J { }
C.m()
{code}

I am seeing this sometimes print ""I"" and sometimes print ""J"".  So there are no clear rules.  I'm guessing it comes down to meta method index population.;;;","13/Dec/21 20:59;emilles;https://github.com/apache/groovy/commit/feb9987cc334751896c0edd6eb1bc53b32e3f397;;;",,,,,,,,,,,,,,,
Groovy scripts can disable java security manager and escape sandbox,GROOVY-8163,13066149,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,dpolivaev,dpolivaev,23/Apr/17 09:54,06/Mar/18 23:25,14/Jul/23 06:02,06/Jun/17 15:12,2.4.10,2.4.9,2.5.0-alpha-1,,,,,,2.5.0-beta-2,,,,,,,,3,,,,,,,"Consider following test

{code}
package groovytest;

import groovy.util.Eval;
import org.junit.*;

import java.net.URL;
import java.security.AccessController;
import java.security.PrivilegedAction;

public class GroovySecurityTest {

	public static final String RESTRICTED_PERMISSIONS_FOR_SCRIPT_ONLY_POLICY = ""/restrictedPermissionsForScriptOnlyPolicy.txt"";

	public static final String POLICY = RESTRICTED_PERMISSIONS_FOR_SCRIPT_ONLY_POLICY;

	@BeforeClass
	public static void setPolicy() throws Exception {
		final String dirTest = GroovySecurityTest.class.getProtectionDomain().getCodeSource().getLocation().toString();
		final String dirGroovy = Eval.class.getProtectionDomain().getCodeSource().getLocation().toString();
		System.setProperty(""dir.test"",dirTest + ""-"");
		System.setProperty(""dir.groovy"",dirGroovy);
		final URL policy = GroovySecurityTest.class.getResource(POLICY);
		System.setProperty(""java.security.policy"", policy.toString());
	}
	
	
	@Before
	public void setSecurityManager() throws Exception {
			System.setSecurityManager(new SecurityManager());
	}

	@After
	public void removeSecurityManager() throws Exception {
		AccessController.doPrivileged(new PrivilegedAction<Void>() {
			@Override
			public Void run() {
				System.setSecurityManager(null);
				return null;
			}
		});
	}

	@Test
	public void doesNotChangeScriptPermissionsUsungPrivateFieldAccess() throws Exception {
		try {
			AccessController.doPrivileged(new PrivilegedAction<Void>() {

                @Override
                public Void run() {
                    Eval.me(""getClass().protectionDomain0.hasAllPerm = true;""
                                    + ""System.setSecurityManager(null);""
                                    + ""1"");
                    return null;
                }
            });
		} catch (Exception e) {
		}

		Assert.assertNotNull(System.getSecurityManager());
	}

}
{code}

with following policy file restrictedPermissionsForScriptOnlyPolicy.txt

{code}
grant codeBase ""${dir.test}"" {
	permission java.security.AllPermission;
};

grant codeBase ""${dir.groovy}"" {
	permission java.security.AllPermission;
};

grant {
};

{code}

It fails: security manager is not set any more when the test assertion is checked.
It happens because CachedField from org.codehaus.groovy.reflection is created withing trusted code base (groovy jar) and gives access to the field to untrusted scripts without any security checks. The same problem relates to CachedMethod which would allow any script to access protected method java.lang.ClassLoader#defineClass(java.lang.String, byte[], int, int, java.security.ProtectionDomain) that can be misused to manipulate code sources of classes loaded from script to give them all permissions.

It also appears that if I remove permissions from groovy.jar using more restrictive policy using following policy file restrictedPermissionsPolicy.txt
{code}
grant  codeBase ""${dir.test}"" {
    permission java.lang.RuntimePermission ""*"";
    permission java.security.SecurityPermission ""*"";
     permission java.io.FilePermission ""<<ALL FILES>>"", ""read"";
    permission java.util.PropertyPermission ""*"", ""read"";
    permission groovy.security.GroovyCodeSourcePermission ""*"";
};

grant  codeBase ""${dir.groovy}"" {
    permission java.lang.RuntimePermission ""*"";
    permission java.security.SecurityPermission ""*"";
    permission java.io.FilePermission ""<<ALL FILES>>"", ""read"";
    permission java.util.PropertyPermission ""*"", ""read"";
    permission groovy.security.GroovyCodeSourcePermission ""*"";
};

grant {
    permission java.lang.RuntimePermission ""accessDeclaredMembers"";
};

{code}

it has a consequence that groovy can not access even some public methods on bean properties as shown in the following test

{code}
package groovytest;

import groovy.util.Eval;
import org.junit.*;

import java.net.URL;
import java.security.AccessController;
import java.security.PrivilegedAction;

public class GroovyBeanTest {

	public static final String RESTRICTED_PERMISSIONS_POLICY = ""/restrictedPermissionsPolicy.txt"";

	public static final String POLICY = RESTRICTED_PERMISSIONS_POLICY;

	@BeforeClass
	public static void setPolicy() throws Exception {
		final String dirTest = GroovyBeanTest.class.getProtectionDomain().getCodeSource().getLocation().toString();
		final String dirGroovy = Eval.class.getProtectionDomain().getCodeSource().getLocation().toString();
		System.setProperty(""dir.test"",dirTest + ""-"");
		System.setProperty(""dir.groovy"",dirGroovy);
		final URL policy = GroovyBeanTest.class.getResource(POLICY);
		System.setProperty(""java.security.policy"", policy.toString());
	}
	
	
	@Before
	public void setSecurityManager() throws Exception {
			System.setSecurityManager(new SecurityManager());
	}

	@After
	public void removeSecurityManager() throws Exception {
		AccessController.doPrivileged(new PrivilegedAction<Void>() {
			@Override
			public Void run() {
				System.setSecurityManager(null);
				return null;
			}
		});
	}
	
	public interface BeanInterface{
		public String getName();
	}

	private class Bean implements BeanInterface{
		private String _name = ""bean"";
		public String getName(){
			return _name;
		}

	}

	@Test
	public void returnsBeanPropertyValue() throws Exception {
		AccessController.doPrivileged(new PrivilegedAction<Void>() {

			@Override
			public Void run() {
				Assert.assertEquals(""bean"", Eval.x(new Bean(), ""x.name""));
				return null;
			}
		});
	}


	static class BeanClass {
		private String name = ""bean"";
	}

	@Test
	public void returnsBeanClassName() throws Exception {
		AccessController.doPrivileged(new PrivilegedAction<Void>() {

			@Override
			public Void run() {
				Assert.assertEquals(BeanClass.class.getName(), Eval.x(new BeanClass(), ""x.class.name""));
				return null;
			}
		});
	}
}
{code}

The both tests fail as the bean properties can not be found by groovy.
It turned out that I can not run the both tests in one process, make sure you run them separately.

In order to fix this issue for my open source project Freeplane I have to patch groovy code. It turned out to be possible. 
So I want to share the fix with you and ask you to integrate it.

The fix is based on groovy version 2.4.9 and I think that it can be applied to any Groovy version.

You only need to check for access permissions at the relevant places to make sure that they are not leaked from groovy (which needs them to work properly) to the untrusted script

{code}
package org.codehaus.groovy.reflection;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ReflectPermission;

import groovy.lang.GroovyObject;

class AccessPermissionChecker {

	private static final ReflectPermission REFLECT_PERMISSION = new ReflectPermission(""suppressAccessChecks"");

	static private void checkAccessPermission(Class<?> declaringClass, final int modifiers, boolean isAccessible) {
		final SecurityManager securityManager = System.getSecurityManager();
		if (isAccessible && securityManager != null) {
				if ((modifiers & (Modifier.PUBLIC | Modifier.PROTECTED)) == 0
						&& !GroovyObject.class.isAssignableFrom(declaringClass)) {
                        securityManager.checkPermission(REFLECT_PERMISSION);
                }
                else if ((modifiers & (Modifier.PUBLIC)) == 0
					&& declaringClass.equals(ClassLoader.class)){
					securityManager.checkCreateClassLoader();
				}
		}
	}

	static public void checkAccessPermission(Method method) {
		checkAccessPermission(method.getDeclaringClass(), method.getModifiers(), method.isAccessible()
		);
	}

	public static void checkAccessPermission(Field field) {
		checkAccessPermission(field.getDeclaringClass(), field.getModifiers(), field.isAccessible()
		);
	}
}
{code}

patching your classes as follows:

CachedField.java:

{code}
    /**
     * @return the property of the given object
     * @throws RuntimeException if the property could not be evaluated
     */
    public Object getProperty(final Object object) {
        try {
            AccessPermissionChecker.checkAccessPermission(field);
        }
        catch (AccessControlException ex) {
            throw new IllegalArgumentException(""Illegal access to field"" + "" "" + field.getName());
        }
        try {
            return field.get(object);
        } catch (IllegalAccessException e) {
            throw new GroovyRuntimeException(""Cannot get the property '"" + name + ""'."", e);
        }
    }

    /**
     * Sets the property on the given object to the new value
     *
     * @param object on which to set the property
     * @param newValue the new value of the property
     * @throws RuntimeException if the property could not be set
     */
    public void setProperty(final Object object, Object newValue) {
        try {
            AccessPermissionChecker.checkAccessPermission(field);
        }
        catch (AccessControlException ex) {
            throw new IllegalArgumentException(""Illegal access to field"" + "" "" + field.getName());
        }
        final Object goalValue = DefaultTypeTransformation.castToType(newValue, field.getType());

        if (isFinal()) {
            throw new GroovyRuntimeException(""Cannot set the property '"" + name + ""' because the backing field is final."");
        }
        try {
            field.set(object, goalValue);
        } catch (IllegalAccessException ex) {
            throw new GroovyRuntimeException(""Cannot set the property '"" + name + ""'."", ex);
        }
    }
{code}

CachedMethod.java:
{code}
    public final Object invoke(Object object, Object[] arguments) {
        try {
            AccessPermissionChecker.checkAccessPermission(cachedMethod);
        }
        catch (AccessControlException ex) {
            throw new InvokerInvocationException(new IllegalArgumentException(""Illegal access to method"" + cachedMethod.getName()));
        }
        try {
            return cachedMethod.invoke(object, arguments);
        } catch (IllegalArgumentException e) {
            throw new InvokerInvocationException(e);
        } catch (IllegalAccessException e) {
            throw new InvokerInvocationException(e);
        } catch (InvocationTargetException e) {
            Throwable cause = e.getCause();
            throw (cause instanceof RuntimeException && !(cause instanceof MissingMethodException)) ?
                    (RuntimeException) cause : new InvokerInvocationException(e);
        }
    }

    public final Method setAccessible() {
        try {
            AccessPermissionChecker.checkAccessPermission(cachedMethod);
        }
        catch (AccessControlException ex) {
            throw new IllegalArgumentException(""Illegal access to method"" + cachedMethod.getName());
        }
//        if (queuedToCompile.compareAndSet(false,true)) {
//            if (isCompilable())
//              CompileThread.addMethod(this);
//        }
        return cachedMethod;
    }

    public Method getCachedMethod() {
        try {
            AccessPermissionChecker.checkAccessPermission(cachedMethod);
        }
        catch (AccessControlException ex) {
            throw new IllegalArgumentException(""Illegal access to method"" + cachedMethod.getName());
        }
        return cachedMethod;
    }
}

{code}

In order to apply the patch in Freeplane I created a separate project https://github.com/dpolivaev/securegroovy which generates the patch at runtime using bytebuddy. 

I would appreciate if you could integrate the patch in groovy code.

There is one subtle issue with AccessPermissionChecker: as you see it allows access to all protected methods except for ClassLoader without any further checks.
But for the protected methods from ClassLoader is makes one additional check: Otherwise a script could access a class loader by getClass().getClassLoader() and misuse its defineClass method to let malicious code appear trusted. ",,blackdrag,dpolivaev,githubbot,glaforge,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jun 06 15:12:06 UTC 2017,,,,,,,,,,"0|i3dz5j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Apr/17 10:17;glaforge;Can you give a bit more details? Steps to reproduce?;;;","23/Apr/17 10:34;dpolivaev;I have added full description now.;;;","23/Apr/17 10:52;glaforge;Thanks;;;","01/May/17 09:15;dpolivaev;[~glaforge] Hello Guillaume,

because I have got no response, I want to describe why I consider this issue to be urgent. 

We develop mind map editor Freeplane ( https://en.wikipedia.org/wiki/Freeplane ) which  allows to use of scripts embedded into mind maps.
The scripts are used as formulas. They are evaluated automatically when the map is opened.
 
Because the formulas need to use bounded variables which require use of CachedField and CachedMethod , because of the reported issue malicious maps could disable java security manager and do whatever they wanted. As I showed in the report if I disallow use of ReflectPermission(""suppressAccessChecks"") by groovy itself, groovy can not properly find some public class methods. And if I allow Groovy to use this permission there is no way to put the scripts in a sandbox safely.

Although I do not think that patching other people software is generally a good solution I had to patch groovy so solve this issue. 
Groovy is general use scripting language I think that also any software allowing users to embed groovy scripts must have the same problem.

Could you or somebody else from the Groovy developers respond to this issue?
If you have any questions or tips or can suggest me another approach to solve this issue please let me know.

Kind regards,
Dimitry Polivaev
Freeplane project lead;;;","01/May/17 11:48;blackdrag;I think the idea of the patch is good and we should think about integrating it. Since it won´t do anything without a security manager being set it should be not causing trouble for example for testing code. But I also think the patch will not solve all the attack vectors. For example if a subclass of ClassLoader overwrites defineClass, your patch will not catch that. Your code will also catch a lot less if invokedynamic is enabled.

But anyway, I still think this would be a good start..

btw Dimitry, it would be even better if you provided this as pull request on github;;;","01/May/17 20:59;githubbot;GitHub user dpolivaev opened a pull request:

    https://github.com/apache/groovy/pull/532

    Prevent CachedField and CachedMethod from leaking access permissions …

    …to scripts
    
    https://issues.apache.org/jira/browse/GROOVY-8163

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/dpolivaev/groovy master

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/532.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #532
    
----
commit 20741fe4f61940a2e5ab56c67d0710a17ac5583f
Author: Dimitry Polivaev <dpolivaev@gmx.de>
Date:   2017-05-01T20:58:12Z

    Prevent CachedField and CachedMethod from leaking access permissions to scripts
    
    https://issues.apache.org/jira/browse/GROOVY-8163

----
;;;","01/May/17 21:04;dpolivaev;Protected class loader methods can be accessed by scripts only if scripts have permission to create class loaders. Obviously they shouldn't get it.

I have improved my proposal by better handling of package private methods: I allow access to such methods for all classes with names not starting with ""java."" because adding classes to packages is generally allowed and therefore there is no additional security risk.

I have not considered ""invokedynamic enabled"" case as I do not know which additional risks result from it. 
How can I as a groovy user control if invokedynamic is enabled?
;;;","13/May/17 14:13;dpolivaev;[~blackdrag] I would appreciate any feedback about the patch I submitted.;;;","13/May/17 16:42;blackdrag;+1;;;","13/May/17 21:48;jwagenleitner;By wrapping the {{Eval}} in the {{doPrivileged}} block doesn't that effectively grant the script {{AllPermission}}.  If you remove the {{doPrivileged}} and use the following policy 

{code:title=restrictedPermissionsForScriptOnlyPolicy.txt}
grant codeBase ""${dir.test}"" {
	permission java.security.AllPermission;
};

grant codeBase ""${dir.groovy}"" {
	permission java.security.AllPermission;
};

grant {
    permission groovy.security.GroovyCodeSourcePermission ""/groovy/shell"";
    permission java.lang.RuntimePermission ""accessDeclaredMembers"";

    permission java.util.PropertyPermission ""*"", ""read"";
};
{code}

it should result in 

{code}
java.security.AccessControlException: access denied (""java.lang.RuntimePermission"" ""setSecurityManager"")
{code}

Though this still doesn't enforce the access checks which is what the PR seems to address.  But I think that is because Groovy uses {{doPrivileged}} blocks for the access and the policy grants permission to the Groovy codebase.  The following change (no explicit or implied ""supressAccessChecks"" permission):

{code}
grant codeBase ""${dir.groovy}"" {
        permission java.lang.RuntimePermission ""*"";
        permission java.security.SecurityPermission ""*"";
        permission java.io.FilePermission ""<<ALL FILES>>"", ""read"";
        permission java.util.PropertyPermission ""*"", ""read"";
        permission groovy.security.GroovyCodeSourcePermission ""*"";
};
{code}

results in 

{code}
java.lang.IllegalAccessException: Class org.codehaus.groovy.reflection.CachedMethod can not access a member of class java.lang.Class with modifiers ""private native""
{code}

The second example with {{GroovyBeanTest}} works in 2.4.11 and 2_5_X, believe the problem was related to a bug that was fixed that affected version 2.4.8-10.  It will also pass in 2.4.11 if the {{doPrivileged}} is removed and the following grant for the scripts is changed to:

{code}
grant {
    permission java.lang.RuntimePermission ""accessDeclaredMembers"";
    permission groovy.security.GroovyCodeSourcePermission ""/groovy/shell"";

    permission java.util.PropertyPermission ""*"", ""read"";
};
{code};;;","14/May/17 11:55;dpolivaev;{{doPrivileged}} blocks in the test are needed to ignore any access checks for JUnit Runner which belong to different protection domains and depend on how the test execution is started (by gradle or by IDE) . They do not influence checks for called groovy scripts.

After I updated my test project to Version 2.4.11 the {{GroovyBeanTest}} still fails with MissingPropertyException.;;;","14/May/17 11:55;dpolivaev;Need for patching {{MetaClassImpl}} if {{GroovyRuntimeException}} is thrown instead of {{IllegalArgumentException}} as suggested in the review is demonstrated by the following test added to {{GroovySecurityTest}} : 

{code}
	@Test
	public void returnsLoggerClassName() throws Exception {
		AccessController.doPrivileged(new PrivilegedAction<Void>() {

			@Override
			public Void run() {
				Assert.assertEquals(""java.util.logging.Logger"", Eval.x(Logger.getGlobal(), ""x.class.name""));
				return null;
			}
		});
	}

{code};;;","17/May/17 18:41;jwagenleitner;My hunch is that a {{GroovyRuntimeException}} should probably not be caught at that point.  I would have assumed an {{AccessControlException}} from {{CachedField.getProperty}} would be treated similar to the {{IllegalAccessException}} in the same method (wrapped in GRE and not caught at that point).;;;","17/May/17 19:18;githubbot;Github user dpolivaev commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/532#discussion_r117087531
  
    --- Diff: src/main/groovy/lang/MetaClassImpl.java ---
    @@ -1832,6 +1832,9 @@ public Object getProperty(Class sender, Object object, String name, boolean useS
                 } catch (IllegalArgumentException e) {
                     // can't access the field directly but there may be a getter
                     mp = null;
    +            } catch (GroovyRuntimeException e) {
    +                // can't access the field directly but there may be a getter
    +                mp = null;
    --- End diff --
    
    I do not have unit test to explain this catch block. I do have the integration test https://issues.apache.org/jira/browse/GROOVY-8163?focusedCommentId=16009695&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-16009695. The problem is that for some classes C with private member called ""name"" class property C.class.name which corresponds to java calls C.class.getName() does not work unless this catch block is added. 
;;;","17/May/17 19:19;dpolivaev;The catch is needed to make the above test https://issues.apache.org/jira/browse/GROOVY-8163?focusedCommentId=16009695&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-16009695 pass.;;;","27/May/17 21:07;dpolivaev;Could you please check the changes I implemented after the review?;;;","04/Jun/17 23:16;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/532
;;;","06/Jun/17 15:12;jwagenleitner;Thanks for reporting and the PR.;;;",,,,
Empty statement before semicolon with parrot parser,GROOVY-8161,13066051,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,paulk,paulk,22/Apr/17 03:17,06/Mar/18 23:25,14/Jul/23 06:02,05/May/17 17:02,3.0.0-alpha-1,,,,,,,,2.6.0-alpha-1,,,,parser,,,,0,,,,,,,"The folowing snippet:
{code}
for (foo in []) {;
}
{code}
while a little unusual with the semicolon separating two empty statements (or terminating an empty statement if you look at things that way) should be valid but instead gives:
{noformat}
BUG! exception in phase 'conversion' in source unit 'ConsoleScript12' java.lang.NullPointerException
...
Caused by: java.lang.RuntimeException: java.lang.NullPointerException
	at groovy.grape.GrabAnnotationTransformation.visit(GrabAnnotationTransformation.java:227)
...
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:37)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:106)
...
{noformat}",,blackdrag,daniel_sun,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 05 17:02:39 UTC 2017,,,,,,,,,,"0|i3dyjr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Apr/17 09:42;blackdrag;this is getStatements returning null? That should not happen;;;","23/Apr/17 00:16;paulk;[~blackdrag] Agreed;;;","05/May/17 17:02;daniel_sun;Fixed by https://github.com/apache/groovy/commit/1a1dbd801a09ea56a4d2a80a148fbee8a753d862;;;",,,,,,,,,,,,,,,,,,,
Exception when evaluating two Groovy scripts containing an enum in parallel,GROOVY-8160,13066045,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mwalser,mwalser,22/Apr/17 00:59,20/Jun/17 01:49,14/Jul/23 06:02,26/Apr/17 16:01,2.4.10,,,,,,,,2.4.11,,,,,,,,0,,,,,,,"It appears like a concurrent invocation of GroovyShell.evaluate results in a exception if the evaluated script contains an enum.

The following code reproduces this issue:
{code}import groovy.lang.GroovyShell;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;


public class MyReproducer {
    public static void main(String [] args) throws InterruptedException {

        // Uncomment this and the problem will go away
        //runScript();

        ExecutorService es = Executors.newFixedThreadPool(2);
        es.execute(MyReproducer::runScript);
        es.execute(MyReproducer::runScript);
        es.shutdown();
        es.awaitTermination(10, TimeUnit.SECONDS);
    }

    private static void runScript() {
        GroovyShell shell = new GroovyShell();
        shell.evaluate(""enum MyEnum {FOO, BAR, BAZ}\nprintln MyEnum.values()"");
    }
}{code}

Exception thrown: {noformat}Exception in thread ""pool-1-thread-1"" org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
Script1.groovy: -1: unable to resolve class java$lang$Enum 
 @ line -1, column -1.
1 error

	at org.codehaus.groovy.control.ErrorCollector.failIfErrors(ErrorCollector.java:310)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:958)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:605)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:554)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:688)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:700)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:584)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:623)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:594)
	at MyReproducer.runScript(MyReproducer.java:23)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Exception in thread ""pool-1-thread-2"" java.lang.ExceptionInInitializerError
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:348)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray$1.run(CallSiteArray.java:68)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray$1.run(CallSiteArray.java:65)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:65)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallSite(CallSiteArray.java:162)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at Script1.run(Script1.groovy:2)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:585)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:623)
	at groovy.lang.GroovyShell.evaluate(GroovyShell.java:594)
	at MyReproducer.runScript(MyReproducer.java:23)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.TypeNotPresentException: Type java$lang$Enum not present
	at sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:117)
	at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:125)
	at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)
	at sun.reflect.generics.repository.ClassRepository.getSuperclass(ClassRepository.java:90)
	at java.lang.Class.getGenericSuperclass(Class.java:777)
	at com.sun.beans.TypeResolver.prepare(TypeResolver.java:308)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:185)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:218)
	at com.sun.beans.TypeResolver.resolve(TypeResolver.java:169)
	at com.sun.beans.TypeResolver.resolveInClass(TypeResolver.java:81)
	at java.beans.FeatureDescriptor.getReturnType(FeatureDescriptor.java:370)
	at java.beans.PropertyDescriptor.findPropertyType(PropertyDescriptor.java:648)
	at java.beans.PropertyDescriptor.updateGenericsFor(PropertyDescriptor.java:623)
	at java.beans.Introspector.addPropertyDescriptor(Introspector.java:605)
	at java.beans.Introspector.addPropertyDescriptors(Introspector.java:614)
	at java.beans.Introspector.getTargetPropertyInfo(Introspector.java:467)
	at java.beans.Introspector.getBeanInfo(Introspector.java:428)
	at java.beans.Introspector.getBeanInfo(Introspector.java:173)
	at groovy.lang.MetaClassImpl$15.run(MetaClassImpl.java:3318)
	at java.security.AccessController.doPrivileged(Native Method)
	at groovy.lang.MetaClassImpl.addProperties(MetaClassImpl.java:3316)
	at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:3293)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:260)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:302)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:261)
	at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:883)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallStaticSite(CallSiteArray.java:75)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallStatic(CallSiteArray.java:56)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:194)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callStatic(AbstractCallSite.java:214)
	at MyEnum.<clinit>(Script1.groovy)
	... 18 more
Caused by: java.lang.ClassNotFoundException: java$lang$Enum
	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:677)
	at groovy.lang.GroovyClassLoader$InnerLoader.loadClass(GroovyClassLoader.java:425)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:787)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:775)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:348)
	at sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:114)
	... 48 more{noformat}

The problem doesn't occur if a script containing an enum declaration was evaluated before. Also every once in a while everything works fine and no error occurs.

Please note: I was unable to reproduce this problem with 2.5.0-alpha-1 but since I didn't find a mention of this bug in the changelog I figured that I should report it nevertheless.","openjdk version ""1.8.0_111""
OpenJDK Runtime Environment (build 1.8.0_111-8u111-b14-2~bpo8+1-b14)
OpenJDK 64-Bit Server VM (build 25.111-b14, mixed mode)",blackdrag,mwalser,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8217,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 26 16:01:04 UTC 2017,,,,,,,,,,"0|i3dyif:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Apr/17 13:17;mwalser;After bisecting it seems like this commit fixed the issue for the 2.5.0-alpha-1 release:
https://github.com/apache/groovy/commit/8fa53f52187e10cfa184f4e2ff1556ef5db66765

Unfortunately it is not included in the 2.4.X branch.;;;","23/Apr/17 21:55;blackdrag;If I get this right you are using two parallel compilation units.I guess the intermediate mutations on enum are visible in both... which also explains why the commit fixes the problem, because then the enum node is constant. ;;;","24/Apr/17 21:42;mwalser;{quote}If I get this right you are using two parallel compilation units{quote}I think so. At least if calling GroovyShell.evaluate in parallel causes two compilation units to be used.

Also, after this error occurs running code containing enums always fails. You have to restart the whole process to get rid of this condition.;;;","24/Apr/17 22:33;paulk;It seems worth merging that commit onto the 2_4_X branch. What do others think?;;;","25/Apr/17 06:17;blackdrag;+1;;;","26/Apr/17 16:01;paulk;Okay, I merged the commit onto the 2_4_X branch, so hopefully this should be fixed. But let me know if that doesn't fix the problem. Thanks for reporting the problem.;;;",,,,,,,,,,,,,,,,
Flow typing doesn't work with assignment to a parameter,GROOVY-8157,13063777,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,daniilo,daniilo,13/Apr/17 12:33,06/Mar/18 23:14,14/Jul/23 06:02,11/May/17 15:49,2.4.10,,,,,,,,2.4.12,,,,Static Type Checker,,,,0,,,,,,,"{code}
import groovy.transform.CompileStatic

class A {}
class B extends A { def bbb() {} }

@CompileStatic
def fooLocalAssignment() {
    A a = new B()
    a.bbb()
}

@CompileStatic
def fooParameterAssignment(A a) {
    a = new B() 
    a.bbb() // Cannot find matching method A#bbb()
}
{code}",,daniilo,githubbot,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8237,GROOVY-8220,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 11 06:07:23 UTC 2017,,,,,,,,,,"0|i3dl4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/May/17 08:33;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/537

    GROOVY-8157: Flow typing doesn't work with assignment to a parameter

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-8157

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/537.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #537
    
----
commit f864ead5ca2938d59a08986c5fb02c01dba0f2aa
Author: Shil Sinha <shils@apache.org>
Date:   2017-05-06T08:32:20Z

    GROOVY-8157: Flow typing doesn't work with assignment to a parameter

----
;;;","11/May/17 06:07;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/537
;;;",,,,,,,,,,,,,,,,,,,,
Compile error when ListenerList annotation exists,GROOVY-8156,13063775,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,jwagenleitner,safri,safri,13/Apr/17 12:07,02/May/17 02:03,14/Jul/23 06:02,20/Apr/17 04:40,2.4.10,,,,,,,,2.4.11,,,,,,,,0,,,,,,,"After upgrading groovy from  2.4.7 to 2.4.10 all classes using the `groovy.beans.ListenerList` annotation fail to compile.
The error message is:
{noformat}
Caught: BUG! exception in phase 'canonicalization' in source unit '/tmp/fsck/bug.groovy' ClassNode#getTypeClass for Event is called before the type class is set 
BUG! exception in phase 'canonicalization' in source unit '/tmp/fsck/bug.groovy' ClassNode#getTypeClass for Event is called before the type class is set 
{noformat}
Code to reproduce:
{noformat}
class Event {
}

interface EventListener {
        void doSomething(Event e)
}

class EventHandler {
        @groovy.beans.ListenerList
        List<EventListener> listeners
}

def eh = new EventHandler()
eh.addEventListener({ println it} as EventListener)
eh.fireDoSomething(new Event())
{noformat}

Complete steps:
{noformat}
% sdk u groovy 2.4.7

Using groovy version 2.4.7 in this shell.
% cat bug.groovy 
class Event {
}

interface EventListener {
        void doSomething(Event e)
}

class EventHandler {
        @groovy.beans.ListenerList
        List<EventListener> listeners
}

def eh = new EventHandler()
eh.addEventListener({ println it} as EventListener)
eh.fireDoSomething(new Event())
% groovy -v
Groovy Version: 2.4.7 JVM: 1.8.0_121 Vendor: Oracle Corporation OS: Linux
% groovy bug.groovy # WORKS 
Event@762ef0ea
% sdk u groovy 2.4.10       

Using groovy version 2.4.10 in this shell.
% groovy -v                
Groovy Version: 2.4.10 JVM: 1.8.0_121 Vendor: Oracle Corporation OS: Linux
% groovy bug.groovy # FAILS
Caught: BUG! exception in phase 'canonicalization' in source unit '/tmp/fsck/bug.groovy' ClassNode#getTypeClass for Event is called before the type class is set 
BUG! exception in phase 'canonicalization' in source unit '/tmp/fsck/bug.groovy' ClassNode#getTypeClass for Event is called before the type class is set 
{noformat}
",Linux x64 java8 ,githubbot,jwagenleitner,safri,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Apr 20 04:40:14 UTC 2017,,,,,,,,,,"0|i3dl3z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Apr/17 01:54;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/524

    GROOVY-8156: Compile error when ListenerList annotation exists

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy groovy8156

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/524.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #524
    
----
commit 1d24e37353ef1544a2d5a6fdb7929b1a46c598f3
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-04-14T20:33:59Z

    GROOVY-8156: Compile error when ListenerList annotation exists

----
;;;","20/Apr/17 04:12;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/524
;;;","20/Apr/17 04:40;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,
No types when executing PostgreSQL stored procedure,GROOVY-8155,13063603,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,mkobel,mkobel,12/Apr/17 19:39,02/May/17 02:03,14/Jul/23 06:02,18/Apr/17 02:22,2.4.10,2.4.9,,,,,,,2.4.11,,,,SQL processing,,,,0,,,,,,,"Since 2.4.9 I can no longer execute stored procedures:

The following code causes an exception:
{code}
def sql = Sql.newInstance(jdbcUrl,user,pass)

        def result = false
        sql.call('{? = call myproc(?, ?) }', [
                Sql.BOOLEAN,
                Sql.BIGINT(1),
                Sql.BIGINT(1)
        ], { res ->
            result = res
        })
{code}

The exception:
{code}
Exception in thread ""main"" org.postgresql.util.PSQLException: ERROR: function myproc(unknown, unknown, unknown) does not exist
  Hint: No function matches the given name and argument types. You might need to add explicit type casts.
{code}

The exception occurs using 'postgresql:postgresql:9.0-801.jdbc4' and 'org.postgresql:postgresql:42.0.0.jre7'

I assume the following line causes the execution of the procedure before the parameters are set ({{subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java}} in {{protected void setParameters(List<Object> params, PreparedStatement statement)}} ):
{code}
ParameterMetaData metaData = statement.getParameterMetaData();
{code}

This line is introduced here: https://github.com/apache/groovy/pull/495/commits/93f703f53b01a0b0205d8efa364c3efb97758d31#diff-c1c769ea9cf64ea997ca82e512653990R4111


",,jwagenleitner,mkobel,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 18 18:39:28 UTC 2017,,,,,,,,,,"0|i3dk1r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Apr/17 02:22;jwagenleitner;I was not able to reproduce this on the 2_4_X branch due to [this commit|https://github.com/apache/groovy/commit/1cb68274537ee26d311b4740eb468aac00728977], so this should be fixed in the upcoming 2.4.11 release.  If you find otherwise, please re-open this issue.;;;","18/Apr/17 03:21;paulk;Thanks John, yes it's probably a duplicate of GROOVY-8128 but in any case, should be fixed in 2.4.11 as you note.;;;","18/Apr/17 18:39;mkobel;Thank you, I can confirm the code is now working again with the current 2.4.11-SNAPSHOT.;;;",,,,,,,,,,,,,,,,,,,
Inconsistency in multiple assignment with single variable,GROOVY-8150,13062479,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,daniilo,daniilo,07/Apr/17 16:24,06/Mar/18 23:25,14/Jul/23 06:02,02/May/17 02:12,2.4.10,2.5.0-alpha-1,,,,,,,2.6.0-alpha-1,,,,,,,,0,,,,,,,"{code}
def a
def b = [1]

a = b
println ""${a} : ${a.class}"" // [1] : class java.util.ArrayList
(a) = b
println ""${a} : ${a.class}"" // 1 : class java.lang.Integer
((a)) = b
println ""${a} : ${a.class}"" // [1] : class java.util.ArrayList
{code}

This is confusing. Here are options:
1. {{((a)) = b}} should be failed to parse.
2. {{((a)) = b}} should behave like {{(a) = b}}, i.e. number of parentheses should not matter.
3. {{((a)) = b}} and {{(a) = b}} should behave like {{a = b}}. This will match the following case also:
{code}
class A { def myField }

def a = new A()
def b = [1]

a.myField = b
assert a.myField == [1]

(a.myField) = b
assert a.myField == [1]

((a.myField)) = b
assert a.myField == [1]
{code}",,blackdrag,daniel_sun,daniilo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 17 16:45:36 UTC 2017,,,,,,,,,,"0|i3dd4n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Apr/17 19:28;blackdrag;I think ((a))=b should not parse;;;","10/Apr/17 13:15;daniilo;[~blackdrag] then {{((a.myField)) = b}} should not be parsed too. ;;;","17/Apr/17 16:45;daniel_sun;Fixed by https://github.com/apache/groovy/commit/23c6cdc6902df8ff58a85e28651ffff7b58473d0

Thanks for your reporting the issue :);;;",,,,,,,,,,,,,,,,,,,
Closure-shared variables may produce different closure classes for same sources,GROOVY-8148,13062366,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,melix,melix,07/Apr/17 09:12,02/May/17 02:03,14/Jul/23 06:02,07/Apr/17 20:19,,,,,,,,,2.4.11,,,,,,,,0,,,,,,,"For the following source code:

{code}
def xx = true
                    def moot = ""bar""
                    def kr = [:]
                    def zorg = []
                    def cl = {
                        def (x,y,z,t) = [xx, moot, kr , zorg]
                    }
{code}

The compiler may generate different bytecode depending on iterations. The bytecode produced is always valid, but not reproducible.",,melix,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-04-07 09:12:45.0,,,,,,,,,,"0|i3dcfj:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Cross-project @Log + static import issue,GROOVY-8145,13061460,Bug,Resolved,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mjjustin,mjjustin,04/Apr/17 15:48,11/Jul/23 17:27,14/Jul/23 06:02,11/Jul/23 17:27,2.4.10,,,,,,,,5.0.0-alpha-1,,,,Compiler,Static compilation,,,0,,,,,,,"I have discovered a situation in which doing a static import of all members of a class causes a compilation error as the compiler incorrectly infers that the code is attempting to use a private static member on the imported class.

There appears to be a very specific combination of factors that causes this to occur.  Specifically, the class that's doing the static import must be statically compiled using the {{@CompileStatic}} annotation, and both classes must share a logger variable with the same name from {{@Log}} (or {{@Slf4j}}, etc.).  Furthermore, the classes cannot be compiled at the same time (for instance, the one could be in a jar or a sub-build in Gradle).

The following is a specific Gradle example that produces the issue.

First, the build structure:

{noformat}
import-static-issue
  src/main/groovy/test
    build.gradle
    settings.gradle
    Importer.groovy
    SameProjectImported.groovy
  subproject
    src/main/groovy/test/DifferentProjectImported.groovy
{noformat}

And the relevant files:

{code:title=build.gradle}
group 'test'
version '1.0-SNAPSHOT'

allprojects {
  apply plugin: 'groovy'
  apply plugin: 'java'

  sourceCompatibility = 1.8

  repositories {
    mavenCentral()
  }

  dependencies {
    compile 'org.codehaus.groovy:groovy-all:2.4.10'
  }
}

dependencies {
  compile project(':subproject')
}
{code}

{code:title=settings.gradle}
include 'subproject'
{code}

{code:title=Importer.groovy}
package test

import groovy.transform.CompileStatic
import groovy.util.logging.Log

//import static test.SameProjectImported.* //Using this one instead won't trigger the issue
import static test.DifferentProjectImported.*

@Log
@CompileStatic
class Importer {
  static void main(String[] args) {
    log.info 'This will cause a compilation failure'
  }
}
{code}

{code:title=SameProjectImported.groovy}
package test

import groovy.util.logging.Log

@Log
class SameProjectImported {
}
{code}

{code:title=DifferentProjectImported.groovy}
package test

import groovy.util.logging.Log

@Log
class DifferentProjectImported {
  // private static java.util.logging.Logger log // Using this instead of @Log will also cause the error
}
{code}

Compiling this code via Gradle (e.g. ""gradle compileGroovy"") produces the following error:

{noformat}/[...]/import-static-issue/src/main/groovy/test/Importer.groovy: -1: Access to test.DifferentProjectImported#log is forbidden @ line -1, column -1.{noformat}

I have confirmed the issue in Groovy 2.4.10.  I have also confirmed that this issue appears to have been present for the whole Groovy 2.x series.

It doesn't occur if you manually create the private static field in the importing class instead of using the {{@Log}} AST transformation.  It will occur if you manually create the static ""log"" field in the statically imported class but use {{@Log}} in the importing class.  It doesn't occur if the importing class doesn't use {{@CompileStatic}}.  It doesn't occur if the importing class and the imported class are in the same Gradle project.  The issue also occurs if you statically import just the ""log"" field and not ""*"" (though practically speaking, you should never actually try to do that).

I ran across this issue when I was migrating some code into a shared library and was statically importing a number of fields for a class that was being moved.  Manually declaring the fields to be statically imported would work, but my IDE settings would fold it back into ""*"" if the imports are ever optimized for the class, so this isn't a workable solution for me (if nothing else, it would be supremely confusing for any developers down the road).

Edit: Upon further investigation, there is a different but related issue if the importing class is not annotated with {{@CompileStatic}}.  If it's not statically compiled, rather than throwing a compilation failure, it will instead use the imported private log variable, not its own.",,emilles,mjjustin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jul 11 17:27:52 UTC 2023,,,,,,,,,,"0|i3d6uf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Jul/23 15:14;emilles;{{StaticImportVisitor}} runs before the {{Log}} AST transform (and others).  If it sees ""log"" in your code it replaces the dynamic variable with ""DifferentProjectImported.log"".  This same thing could happen for a field or property of any visibility from the imported class when the local resolution of a name is delayed until after a transform supplies the required element (the ""log"" field in this case).;;;","11/Jul/23 15:27;emilles;You can stop the static import substitution by using ""this.log"" within {{Importer}}.;;;","11/Jul/23 17:27;emilles;https://github.com/apache/groovy/commit/3785147d2f7ae43a994f6949eb4a7fd96b79c66c;;;",,,,,,,,,,,,,,,,,,,
Invoking a public method declared in a non-public class result in a IllegalAccessError,GROOVY-8144,13061252,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,pablo72,pablo72,03/Apr/17 20:39,12/Jun/17 00:12,14/Jul/23 06:02,02/May/17 02:27,2.5.0-alpha-1,,,,,,,,2.5.0-beta-1,,,,Static compilation,,,,0,,,,,,,"For example:

{code}
import groovyx.gpars.agent.Agent
import groovy.transform.CompileStatic

@CompileStatic
class Dummy {

  def void foo() {
     def x = new Agent<List>( [] )
     x.send { List it -> it.add(1) }
     x.await()
  }

}


new Dummy().foo()


java.lang.IllegalAccessError: tried to access class groovyx.gpars.agent.AgentBase from class Dummy
    at Dummy.foo(ConsoleScript15:10)
    at Dummy$foo.call(Unknown Source)
    at ConsoleScript15.run(ConsoleScript15:16)
{code}

I guess the problem is that AgentBase class is not declared public
https://github.com/GPars/GPars/blob/master/src/main/groovy/groovyx/gpars/agent/AgentBase.java#L34

This is a regression, see also this thread https://groups.google.com/d/msg/groovy-user/0Ig9mhRLnKk/LWsx1EQbu_4J",,githubbot,jwagenleitner,pablo72,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Apr 15 15:21:10 UTC 2017,,,,,,,,,,"0|i3d5k7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Apr/17 03:01;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/522

    GROOVY-8144: Invoking a public method declared in a non-public class …

    …result in a IllegalAccessError
    
    Commit 1a4c9918a4f12e64 introduced the DecompiledClassNode as part of
    enabling the ASM class resolver.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy groovy8144

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/522.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #522
    
----
commit 3b6c2a504119e99d86de76019f48e0059b8fcf9e
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-04-10T20:10:25Z

    GROOVY-8144: Invoking a public method declared in a non-public class result in a IllegalAccessError
    
    Commit 1a4c9918a4f12e64 introduced the DecompiledClassNode as part of
    enabling the ASM class resolver.

----
;;;","15/Apr/17 15:07;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/522
;;;","15/Apr/17 15:21;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,
Performance subproject included in release artifacts,GROOVY-8143,13061226,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,jwagenleitner,jwagenleitner,03/Apr/17 19:13,02/May/17 02:03,14/Jul/23 06:02,21/Apr/17 10:42,2.5.0-alpha-1,,,,,,,,2.4.11,,,,release,,,,0,,,,,,,"The {{performance}} subproject artifacts for 2.5.0-alpha-1 {{performance-2.5.0-alpha-1.jar}} are bundled in the release and are in maven central.

https://search.maven.org/#artifactdetails%7Corg.codehaus.groovy%7Cperformance%7C2.5.0-alpha-1%7Cjar",,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 21 10:42:39 UTC 2017,,,,,,,,,,"0|i3d5ef:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Apr/17 10:42;paulk;Should be fixed now. I haven't been able to test all of it yet but with a release sometime in the next few days I'll get all the bits tested one way or the other. :-);;;",,,,,,,,,,,,,,,,,,,,,
Static compiler produces different bytecode for same sources,GROOVY-8142,13061185,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,melix,markvieira,markvieira,03/Apr/17 17:22,02/May/17 02:03,14/Jul/23 06:02,07/Apr/17 20:20,2.4.10,,,,,,,,2.4.11,,,,Compiler,,,,1,,,,,,,"When using {{@CompileStatic}} the Groovy compiler produces different bytecode output for the same set of sources. This seems to be the issue when calling a method on a type with multiple super-interfaces which declare the same method. In this case, the bytecode produced by the compiler will reference one of these interfaces randomly.

I have provided a test project which reproduces this issue:

https://github.com/mark-vieira/groovy-compiler-bug ",,lptr,markvieira,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-04-03 17:22:01.0,,,,,,,,,,"0|i3d55b:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Invoke method not returning MOP super method if isCallToSuper,GROOVY-8140,13060982,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,jwagenleitner,jwagenleitner,jwagenleitner,02/Apr/17 15:27,02/May/17 02:03,14/Jul/23 06:02,05/Apr/17 03:32,2.4.8,,,,,,,,2.4.11,,,,groovy-runtime,,,,0,,,,,,,"Recent commit 0a6789d06c [1] reintroduced behavior that skips methods for super.  See mailing list discussion [2].

[1] https://github.com/apache/groovy/commit/0a6789d06cc6451fcfee174ba638c0494f2827ef

[2] http://mail-archives.apache.org/mod_mbox/groovy-dev/201703.mbox/%3CCAPbPdObHqPg7aFHSwLf0sRMdHqrRa1vuNwRvxuZVQu5VQ840%2Bw%40mail.gmail.com%3E",,abayer,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Apr 05 02:17:12 UTC 2017,,,,,,,,,,"0|i3d3w7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Apr/17 16:36;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/520

    GROOVY-8140: Invoke method not returning MOP super method if isCallTo…

    …Super
    
    See [dev mailing list discussion](http://mail-archives.apache.org/mod_mbox/groovy-dev/201703.mbox/%3CCAPbPdObHqPg7aFHSwLf0sRMdHqrRa1vuNwRvxuZVQu5VQ840%2Bw%40mail.gmail.com%3E)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy groovy8140

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/520.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #520
    
----
commit 433eaf8c62f809d531bb9984b126252172f8287c
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-04-02T15:34:47Z

    GROOVY-8140: Invoke method not returning MOP super method if isCallToSuper

----
;;;","05/Apr/17 02:17;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/520
;;;",,,,,,,,,,,,,,,,,,,,
Code passes static compilation but fails during runtime,GROOVY-8136,13059949,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,ichulovskyi,ichulovskyi,29/Mar/17 07:34,10/Feb/23 21:40,14/Jul/23 06:02,07/Sep/22 20:30,2.4.10,,,,,,,,2.5.22,3.0.15,,,Static Type Checker,,,,0,,,,,,,"Input files:
Test.groovy
{code}
class Test {
    static org.springframework.util.MultiValueMap map = [:] // class from spring-core:4.2.6-RELEASE

    static void main(String[] args) {
        println map
    }
}
{code}
compiler-config.groovy
{code}
import groovy.transform.CompileStatic
withConfig(configuration)
{ ast(CompileStatic) }
{code}

Error: {code}org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object '{}' with class 'java.util.LinkedHashMap' to class 'org.springframework.util.MultiValueMap' due to: groovy.lang.GroovyRuntimeException: Could not find matching constructor for: org.springframework.util.MultiValueMap(java.util.LinkedHashMap)
{code}

Expected behavior: either compile time error or handle it correctly during runtime",,emilles,ichulovskyi,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 07 20:30:28 UTC 2022,,,,,,,,,,"0|i3cxin:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Sep/22 17:44;emilles;[MultiValueMap|https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/MultiValueMap.html] is an interface, so you cannot assign a map literal (aka {{LinkedHashMap}}) to it without some kind of explicit conversion.

Update: Sorry, the request is for an error from the type checker.  I missed that part.;;;","07/Sep/22 20:30;emilles;https://github.com/apache/groovy/commit/099cf5b3f0ca61ea5daa72ebcea66ef09a74fd84;;;",,,,,,,,,,,,,,,,,,,,
SecureASTCustomizer whitelist does not work,GROOVY-8135,13059904,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,jwagenleitner,rivanov,rivanov,29/Mar/17 02:14,06/Mar/18 23:14,14/Jul/23 06:02,07/May/17 05:52,2.4.8,,,,,,,,2.4.12,,,,,,,,0,,,,,,,"The example [1] throws a SecurityException[2]

Details

1. Source code

SecureASTCustomizer customizer = new SecureASTCustomizer();
customizer.setIndirectImportCheckEnabled(true);
    	
List<String> starImportsWhitelist = new ArrayList<String>();
starImportsWhitelist.add(""java.lang"");
customizer.setStarImportsWhitelist(starImportsWhitelist);
    	
CompilerConfiguration cc = new CompilerConfiguration();
cc.addCompilationCustomizers(customizer);
		
ClassLoader parent = getClass().getClassLoader();
GroovyClassLoader loader = new GroovyClassLoader(parent, cc);
		
loader.parseClass(""Object[] array = new Object[0]; array.size()"");	

2. Exception
Caused by: java.lang.SecurityException: Importing [[Ljava.lang.Object;] is not allowed
	at org.codehaus.groovy.control.customizers.SecureASTCustomizer.assertImportIsAllowed(SecureASTCustomizer.java:608)
	at org.codehaus.groovy.control.customizers.SecureASTCustomizer.access$800(SecureASTCustomizer.java:121)
	at org.codehaus.groovy.control.customizers.SecureASTCustomizer$SecuringCodeVisitor.assertExpressionAuthorized(SecureASTCustomizer.java:702)

",,githubbot,jwagenleitner,rivanov,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Important,,,,,,,,9223372036854775807,,,Sun May 07 23:43:59 UTC 2017,,,,,,,,,,"0|i3cx8n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/May/17 19:41;githubbot;GitHub user armsargis opened a pull request:

    https://github.com/apache/groovy/pull/538

    GROOVY-8135: SecureASTCustomizer whitelist does not work

    For arrays we should get componentType instead of type

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/armsargis/groovy GROOVY-8135

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/538.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #538
    
----
commit db11e31730d108510324e09ff02c052f416eaa0d
Author: Sargis Harutyunyan <sargis.harutyunyan@webbfontaine.com>
Date:   2017-05-06T19:34:42Z

    GROOVY-8135: SecureASTCustomizer whitelist does not work
    
    For arrays we should get componentType instead of type

commit e852b9782c6dd5a00b98a590cee63567a6a72a27
Author: Sargis Harutyunyan <sargis.harutyunyan@webbfontaine.com>
Date:   2017-05-06T19:39:42Z

    Merge branch 'master' into GROOVY-8135

----
;;;","07/May/17 04:57;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/538
;;;","07/May/17 05:52;jwagenleitner;Thanks for reporting the issue.;;;","07/May/17 23:43;rivanov;Thanks.;;;",,,,,,,,,,,,,,,,,,
Properties of @Delegate fields are preferred to those in the owning class,GROOVY-8132,13059405,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,27/Mar/17 14:17,02/May/17 02:03,14/Jul/23 06:02,17/Apr/17 15:31,2.4.10,,,,,,,,2.4.11,,,,Compiler,,,,0,,,,,,,"Example:

{code}
class Foo {
    String pls
    @groovy.lang.Delegate
    Bar bar
}

class Bar { 
    String pls        
}
assert new Foo(pls: 'ok').pls == 'ok'
{code}

Running the code above results in the following exception:

{code}
java.lang.NullPointerException: Cannot set property 'pls' on null object
{code}

Delegation of properties should behave the the same way as delegation of methods i.e. properties of delegates should not take precedence over properties declared in the owning class.",,githubbot,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Apr 18 03:18:49 UTC 2017,,,,,,,,,,"0|i3cu67:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Mar/17 14:24;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/518

    GROOVY-8132: Owner properties should be preferred over properties of …

    …@Delegate field
    
    * Add test for method delegation precedence

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-8132

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/518.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #518
    
----
commit aaed13450e688815c376a7b351a50c0f9ba55394
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2017-03-22T17:26:24Z

    GROOVY-8132: Owner properties should be preferred over properties of @Delegate field
    * Add test for method delegation precedence

----
;;;","15/Apr/17 20:57;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/518
;;;","17/Apr/17 12:53;paulk;I tried back-porting this to 2_4_X and have 4 failing tests. I'll investigate but depending on what I find, we might not back port this at all (and leave it as a 2.5.0 fix) or we might need to bring across another bug fix first.;;;","17/Apr/17 15:31;shils;[~paulk] Thanks for looking into it. I had issues backporting it as well, but didn't have time to investigate further.;;;","18/Apr/17 03:18;paulk;I was able to tweak the backport to make it work on 2_4_X, so I adjusted the fix version accordingly.;;;",,,,,,,,,,,,,,,,,
"Statement continued onto next line is flagged when first character is ""=""",GROOVY-8131,13059016,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,texadactyl,texadactyl,24/Mar/17 20:04,06/Mar/18 23:25,14/Jul/23 06:02,02/May/17 02:12,2.4.5,,,,,,,,2.6.0-alpha-1,,,,Compiler,,,,0,,,,,,,"Source code attached (grbug.java).

`javac` v8 compiles variable declarations s1, s2, and s3 successfully.

`groovyc` flags s3:
""unexpected token: = @ line 9, column 3.""
","Ubuntu Linux

`uname -a`:
Linux biostar 4.4.0-69-generic #90-Ubuntu SMP Thu Mar 16 16:52:31 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux",blackdrag,daniel_sun,paulk,texadactyl,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"24/Mar/17 20:04;texadactyl;grbug.java;https://issues.apache.org/jira/secure/attachment/12860434/grbug.java",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Apr 02 10:01:13 UTC 2017,,,,,,,,,,"0|i3crrr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Mar/17 05:29;paulk;Currently, this is by design rather than a bug. Groovy treats the semicolon as a statement separator not statement terminator like in Java.

As another example, inside the collect below, there is an expression returning 4 then an expression returning the result +3 (which is just 3) and for Groovy there is an implicit return of the last expression:
{code}
assert [3] == [1].collect {
  4
  + 3
}
{code}
Having said that, we do look ahead for closure left curly braces inside builders for instance. In theory we could enhance the grammar to handle additional cases like the equals but obviously not for all symbols (e.g. changing the '+' as per the above example would break existing code).;;;","26/Mar/17 16:24;texadactyl;To me, the following two executable statements are semantically identical:

     static final SimpleDateFormat s2 = 
		new SimpleDateFormat( ""yyyy-MM-dd_hh:mm:ss"" );

     static final SimpleDateFormat s3
		= new SimpleDateFormat( ""yyyy-MM-dd_hh:mm:ss"" );

When I was a compiler constructor, newline characters (line continuation) was treated as whitespace (0x20).  It doesn't matter whether the scanner employs a terminator or the scanner simply recognizes the end of a valid statement.

When one escapes the newline character in the 1st line of the s3 declaration, then `groovyc` compiles the 2-line statement successfully.

     static final SimpleDateFormat s3m \
		= new SimpleDateFormat( ""yyyy-MM-dd_hh:mm:ss"" );

If the newline is a statement separator (like semicolon), then why weren't both the s2 and s3m declarations flagged?
     1. They are declared as final yet they have no declared initialization before statement separation.
     2. The 2nd line should be a syntax error as they are assignments with nothing to assign to.

Answer guess: Full statements are recognized semantically (terminate implicitly), regardless of the number of lines the statement occupies.

I still think that the original report is against an undesirable feature of the `groovyc` scanner.  If both lines are recognized as part of a single executable statement, then it should not matter where the '=' character falls on (line 1 or line 2).  Semantically, the s2 and s3 declarations are identical.  

Am I missing some subtle philosophical point of Groovy?

I can catch these types of differences in my Java source code fairly easily, hence, the report was classified as ""minor"".

;;;","26/Mar/17 17:36;blackdrag;When you make newline treated as whitespace, you cannot make it part of the syntax of the language. That is why for example in Java you have to use the semicolon to tell the compiler the statement is done. In Groovy the semicolon is optional, thus the newline character significant and you cannot treat it as whitespace anymore and it becomes a possible terminator. But it is still no terminator like the semicolon. That means 
{code:Java}
static final SimpleDateFormat s3
= new SimpleDateFormat( ""yyyy-MM-dd_hh:mm:ss"" );
{code}
has a valid final  first line. That is why in Groovy we suggested the logic that the code line should end with the operator to be more easily be able to tell the compiler that the next line belongs to the same statement.  Such operators are for the compiler = and of course \ too. Which is why s2 and s3m are no problem. 
So terminate implicitly sounds right to me, even though I would not call that semantic recognition, since it is still only the parser that tells the compiler if a statement ends or not. We are for example not having both lines as possibly valid by their own in the parser and then combine them into a single statement somehow.

Anyway... I think this kind of bug can be fixed in the antlr grammar;;;","26/Mar/17 19:33;texadactyl;Jochen,

How can ""static final SimpleDateFormat s3"" be valid if the variable has been declared final but has no value assigned?  Without the token ""final"", I would agree with you.

Newline (\n) part of the syntax of a language?  Why would you want to make an invisible character (text line terminator) part of a language?  Python did it with tab characters (\t) and drives everyone crazy.

You might be thinking that I am picky or Johnny-come-lately with respect to Groovy.  Both true.  Just started compiling older Java to Groovy as part of self-education.
;;;","26/Mar/17 22:54;paulk;If you compile your static final example with the latest snapshot versions of Groovy you will get:
{noformat}
The variable [s3] may be uninitialized
{noformat}
But in some sense that isn't what your main point is, so I won't dwell on that.

Perhaps if you think of newline as a statement terminator, that will explain the current behavior. We do some but not very much lookahead. You are right that we could do smarter lookahead within the grammar but it isn't trivial.

As an example, Groovy allows this statement:
{code}
multiply 4 by 5
{code}
which is the same as:
{code}
multiply(4).by(5)
{code}
With an implementation like:
{code}
def multiply(multiplicand) { [by: { multiplier -> multiplicand * multiplier }] }
{code}
Where as this:
{code}
multiply 4
by 5
{code}
Are these two valid statements:
{code}
multiply(4)
by(5)
{code}
;;;","26/Mar/17 23:49;blackdrag;""static final SimpleDateFormat s3"" is legal if you have a static initializer block, that sets the variable. But you need to put some semantics into the evaluation to determine that, which is why lexer and parser see that as valid statement.

Why would we make newline part of the language? Well because the semicolon is annoying ;) Seriously, if you did Groovy for a while and then go to Java, the semicolon becomes extremely annoying.
;;;","27/Mar/17 15:23;texadactyl;Jochen,

{quote}""static final SimpleDateFormat s3"" is legal if you have a static initializer block, that sets the variable.{quote}
But, I did not.  See the attachment.  That is why I wondered why it wasn't flagged.

One person's annoyance (;) is another person's point of clarity.;;;","27/Mar/17 15:27;texadactyl;Paul & Jochen,

I am not trying to drag out what you two may feel is being argumentative.  Given that this is currently a feature, perhaps the Groovy documentation could highlight this and include some examples similar to mine.

Richard
;;;","30/Mar/17 08:50;paulk;Yes, improving the documentation is always a good thing. I found a brief reference in Groovy in Action but couldn't see any equivalent in the online documentation. PRs welcome! :-);;;","01/Apr/17 16:49;daniel_sun;bq. Anyway... I think this kind of bug can be fixed in the antlr grammar

Jochen, I think the new parser Parrot can be refined to support some code like 
{code}
def a
= 1 + 2
{code}

but I am not going to make Parrot support
{code}
def a = 1
+ 2
{code}

In other words, the first token in second line should be invalid for the statement.
;;;","01/Apr/17 17:26;daniel_sun;I've tried to fix it in the groovy-parser project: https://github.com/danielsun1106/groovy-parser/commit/68d791de2b88693febdfe15896ed8aea2dee9ed1;;;","01/Apr/17 21:16;blackdrag;nice;;;","02/Apr/17 01:43;daniel_sun;Fixed in the parrot branch.;;;","02/Apr/17 10:01;daniel_sun;Besides {{=}}, I have refined the Parrot parser to support more expressions span rows:
https://github.com/apache/groovy/commit/929bf81114a2f0ea4fa231e283ac3e3b4b2bc5d4

ps: you can find that the first token in the new line is invalid for the statement.;;;",,,,,,,,
Cannot call private constructor error - @CompileStatic & default method argument,GROOVY-8130,13058863,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,szpak,szpak,24/Mar/17 11:10,06/Mar/18 23:12,14/Jul/23 06:02,01/Feb/18 04:21,2.4.10,2.4.7,,,,,,,2.4.13,,,,Static compilation,,,,0,,,,,,,"Groovy compiler reports error on a try of use private constructor with default method argument from a static method:
Error:(15, 16) Groovyc: Cannot call private constructor for com.ofg.test.CannotCallPrivateConstructorIssueReproductor from class com.ofg.test.CannotCallPrivateConstructorIssueReproductor

Sample code to reproduce that issue:
{code}
@CompileStatic
class CannotCallPrivateConstructorIssueReproductor {

    private final String someFiled //final is NOT mandatory to reproduce the issue

    private CannotCallPrivateConstructorIssueReproductor(String someFiled, Integer optionalArgument = null) {   //field with default value is crutial
        this.someFiled = someFiled
    }

    static CannotCallPrivateConstructorIssueReproductor factoryMethod() {
        return new CannotCallPrivateConstructorIssueReproductor('sth')
    }
}
{code}

Tested with Groovy 2.4.7 and 2.4.10",,paulk,szpak,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 01 04:21:54 UTC 2018,,,,,,,,,,"0|i3cqtr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Feb/18 04:21;paulk;This seems to be fixed in 2.4.13.;;;",,,,,,,,,,,,,,,,,,,,,
Breaking change in 2.4.9 with Sql query with GString,GROOVY-8128,13058230,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,msauer53,msauer53,22/Mar/17 13:36,02/May/17 02:03,14/Jul/23 06:02,28/Mar/17 02:48,2.4.9,,,,,,,,2.4.11,,,,groovy-runtime,,,,0,,,,,,,"The following code worked for releases 2.4.8 and below:
{code}
    def query = """"""\
    SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED\r\n\
    select u5f_documenttype from DocVersion dv left outer join ClassDefinition cd on dv.object_class_id = cd.object_id 
    where cd.symbolic_name in ('Retail', 'RetailWeb') and dv.is_current = 1
    and u59_accountnumber = $acctNum and u5f_documenttype = 'Signature Card'
    """"""
    def docFound = 'No Doc'
    consumerSql.eachRow(query) {
{code}
This code now fails in 2.4.9 and 2.4.10 with:
{noformat}
Mar 22, 2017 9:23:43 AM groovy.sql.Sql eachRow
WARNING: Failed to execute:     SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
    select u5f_documenttype from DocVersion dv left outer join ClassDefinition cd on dv.object_class_id = cd.object_id 
    where cd.symbolic_name in ('Retail', 'RetailWeb') and dv.is_current = 1
    and u59_accountnumber = ? and u5f_documenttype = 'Signature Card'
     because: com.microsoft.sqlserver.jdbc.SQLServerException: Unable to identify the table     SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
    select u5f_documenttype from DocVersion dv left outer join ClassDefinition cd on dv.object_class_id = cd.object_id 
    where cd.symbolic_name in ('Retail', 'RetailWeb') and dv.is_current = 1
    and u59_accountnumber = ? and u5f_documenttype = 'Signature Card'
     for the metadata.
{noformat}

I have tried changing to using placeholders and name parameters and I get similar results.",Windows 7,mmm444,msauer53,patachat,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8082,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 28 02:48:56 UTC 2017,,,,,,,,,,"0|i3cmx3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Mar/17 09:56;paulk;Do you have the complete stacktrace? In particular which line in groovy.sql.Sql is being executed when the exception is thrown?;;;","23/Mar/17 10:06;patachat;Hi! I have the same problem.  I think that this problem become since the issue #GROOVY-8082 in the class src/main/java/groovy/sql/Sql.java. The method setParameters(List<Object> params, PreparedStatement statement) has modified,   
I have this error : 
org.codehaus.groovy.runtime.InvokerInvocationException: java.sql.SQLSyntaxErrorException: ORA-01747: spécification utilisateur.table.colonne, table.colonne ou colonne non valide

my database is in Oracle.




;;;","23/Mar/17 10:34;paulk;@achat What does your SQL look like? Do you also have some kind of instruction that isn't a table lookup as part of your query (like the ""SET TRANSACTION ISOLA..."" part above)? I don't think we have that in our test suite.;;;","23/Mar/17 10:45;msauer53;Here is my stack trace:
{noformat}
	at com.microsoft.sqlserver.jdbc.SQLServerException.makeFromDriverError(SQLServerException.java:190)
	at com.microsoft.sqlserver.jdbc.SQLServerParameterMetaData.<init>(SQLServerParameterMetaData.java:426)
	at com.microsoft.sqlserver.jdbc.SQLServerPreparedStatement.getParameterMetaData(SQLServerPreparedStatement.java:1532)
	at groovy.sql.Sql.setParameters(Sql.java:4109)
	at groovy.sql.Sql.getPreparedStatement(Sql.java:4383)
	at groovy.sql.Sql.getPreparedStatement(Sql.java:4471)
	at groovy.sql.Sql.eachRow(Sql.java:1262)
	at groovy.sql.Sql.eachRow(Sql.java:1350)
	at groovy.sql.Sql.eachRow(Sql.java:1530)
	at groovy.sql.Sql.eachRow(Sql.java:1614)
	at groovy.sql.Sql$eachRow.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
	at ConsumerTaxDBExtract.queryRetail(ConsumerTaxDBExtract.groovy:18)
{noformat}
Also, I get the same error if I remove the SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED\r\n\ line.;;;","23/Mar/17 11:19;paulk;Okay, so it seems it may not be possible to get parameter metadata for certain kinds of queries at least for certain drivers. We should be able to fix that for 2.4.11 which should be released in a few weeks.;;;","23/Mar/17 11:30;msauer53;Ok.  Thanks.  In case it helps,  here is the release information for the driver I am using:
Microsoft JDBC Driver 4.0 for SQL Server
March 2012
;;;","23/Mar/17 13:16;patachat;[~paulk] my sql is :
{code:sql}
def cwQuery = '''SELECT a.external_id
                  FROM ACTE a
                  LEFT JOIN type_acte ta on  a.TYA_ID = ta.TYA_ID
                  LEFT JOIN office o on a.OFFICE_ID = o.OFFICE_ID
                  LEFT JOIN registre r on r.REGISTRE_ID = a.REGISTRE_ID
                  where
                  ta.code = ? and 
                  r.year = ? and
                  (o.code=? OR o.code IN ('customParamCode')) and
                  r.REGISTRE_ID is not null and
                  a.external_id is not null''
{code}

My driver is ojdbc7-12.1.0.2.
;;;","23/Mar/17 18:26;mmm444;Hello. Just FYI we also ran into this today on PostgreSQL 9.5 and 9.6 using org.postgresql:postgresql:42.0.0 driver. Our case can be reduced to the following table
{code}CREATE TABLE A(x integer){code}
and this statement
{code}INSERT INTO A SELECT ? UNION SELECT ?{code}
;;;","27/Mar/17 06:24;paulk;I think I know what changes I'd make but I haven't been able to replicate the problem to give myself confidence in the change. I tried hsqldb, mysql  and postgresql but couldn't get the error.

Here is what I tried:
{code}
@GrabConfig(systemClassLoader=true)
//@Grab('org.hsqldb:hsqldb:2.3.2')
//@Grab('mysql:mysql-connector-java:5.1.21')
//@Grab('postgresql:postgresql:9.0-801.jdbc4')
@Grab('org.postgresql:postgresql:42.0.0')
import groovy.sql.Sql
def sql = Sql.newInstance(""jdbc:postgresql://localhost:5432/postgres"", ""username"", ""password"", ""org.postgresql.Driver"")
sql.execute 'DROP TABLE IF EXISTS A'
sql.execute 'CREATE TABLE A(x varchar(30))'
sql.execute ""INSERT INTO A SELECT ? UNION SELECT ?"", ['23', '45']
List rows = sql.rows('select * from A')
println ""There are ${rows.size()} A row(s):""
println rows.collect { ""$it.x"" }.join("", "")
{code}
which produces for Groovy 2.4.10:
{noformat}
There are 2 A row(s):
23, 45
{noformat}
I'd be grateful if someone can supply a failing script otherwise I can make the changes I believe are needed and create a SNAPSHOT version of Groovy for someone to test.;;;","27/Mar/17 11:05;msauer53;I would be happy to test against a SNAPSHOT version.;;;","27/Mar/17 11:32;mmm444;Thanks for looking into this [~paulk]. If you just change the column type to integer it fails on PostgreSQL. This script:
{code}
@GrabConfig(systemClassLoader=true)
@Grab('org.postgresql:postgresql:42.0.0')
import groovy.sql.Sql
def sql = Sql.newInstance(""jdbc:postgresql://localhost:5432/postgres"", ""username"", ""password"", ""org.postgresql.Driver"")
println sql.rows('SELECT * FROM version()')
sql.execute 'DROP TABLE IF EXISTS A'
sql.execute 'CREATE TABLE A(x integer)'
sql.execute ""INSERT INTO A SELECT ? UNION SELECT ?"", [23, 45]
List rows = sql.rows('select * from A')
println ""There are ${rows.size()} A row(s):""
println rows.collect { ""$it.x"" }.join("", "")
{code}

fails when run using Groovy 2.4.10:

{code}
$ ~/java/groovy-2.4.10/bin/groovy a.groovy
[[version:PostgreSQL 9.6.2 on x86_64-pc-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-bit]]
Mar 27, 2017 1:20:38 PM groovy.sql.Sql execute
WARNING: Failed to execute: INSERT INTO A SELECT ? UNION SELECT ? because: ERROR: column ""x"" is of type integer but expression is of type text
  Hint: You will need to rewrite or cast the expression.
  Position: 22
Caught: org.postgresql.util.PSQLException: ERROR: column ""x"" is of type integer but expression is of type text
  Hint: You will need to rewrite or cast the expression.
  Position: 22
org.postgresql.util.PSQLException: ERROR: column ""x"" is of type integer but expression is of type text
  Hint: You will need to rewrite or cast the expression.
  Position: 22
        at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2412)
        at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2125)
        at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:297)
        at org.postgresql.jdbc.PgPreparedStatement.getParameterMetaData(PgPreparedStatement.java:1569)
        at a.run(a.groovy:8)
{code};;;","27/Mar/17 14:29;paulk;Ah, I was getting that error but wasn't sure it was related. It does indeed go away with the fix I had in mind. I have committed the fix and it will be available once the CI servers have published the snapshots in several hours. Once finished, the relevant URLs will be (depending on how bleeding edge you like to be):

https://oss.jfrog.org/oss-snapshot-local/org/codehaus/groovy/groovy-all/2.4.11-SNAPSHOT/
https://oss.jfrog.org/oss-snapshot-local/org/codehaus/groovy/groovy-all/2.5.0-SNAPSHOT/
https://oss.jfrog.org/oss-snapshot-local/org/codehaus/groovy/groovy-all/3.0.0-SNAPSHOT/

Any testing would be greatly appreciated.;;;","27/Mar/17 15:42;msauer53;My code worked with the SNAPSHOT jar.;;;","28/Mar/17 02:48;paulk;Thanks Mike. I'll mark as resolved but if anyone has any issues, let me know. Also, if anyone can replicate the problem with an embedded db, also let me know and I'll add a test into the test suite. Our CI isn't currently set up to have a Postgresql db or docker image thereof at the moment.;;;",,,,,,,,
Access to Trait$Trait$Helper#$self is forbidden,GROOVY-8127,13058223,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,facewindu,facewindu,22/Mar/17 13:27,02/May/17 02:03,14/Jul/23 06:02,24/Apr/17 14:27,2.4.10,,,,,,,,2.4.11,,,,Compiler,,,,0,,,,,,,"I'm switching from Groovy 2.4.7 to 2.4.10 in my project.

I have a compile error with 2.4.10.
Simplified example:
{code}
import groovy.transform.CompileStatic
import org.junit.Rule
import org.junit.rules.TestRule
@CompileStatic
trait FooTrait {
    @Rule
    public final TestRule foo = {} as TestRule
}
{code}
I get ""Error:Groovyc: Access to FooTrait$Trait$Helper#$self is forbidden""

Another variant of this error is ""Error:Groovyc: Apparent variable '$self'
was found in a static scope but doesn't refer to a local variable, static
field or class.""

This second error happens with the following code
{code}
import groovy.transform.CompileStatic
import org.junit.Rule
import org.junit.rules.TestRule
import org.junit.runner.Description
import org.junit.runners.model.Statement

@CompileStatic
trait TestSupport {

    boolean failOnResourceLeak = true

    @Rule
    public final TestRule leakDetectionFlagRule = { Statement base, Description description ->
        return {
            base.evaluate()
            if (failOnResourceLeak) {
                throw new Exception(""A resource has leaked in this test!"")
            }
        } as Statement
    } as TestRule

}
{code}",,facewindu,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 24 14:27:30 UTC 2017,,,,,,,,,,"0|i3cmvj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Mar/17 21:20;paulk;Just mentioning the workarounds: remove final (both cases) or remove @CompileStatic (first case).
Groovy 2.4.7 allowed the {{final}} keyword but ignored it. The later versions now apply that modifier.;;;","18/Apr/17 08:01;paulk;Just some examples without the JUnit dependency.

The Access forbidden to {{$self}} case:
{code}
@groovy.transform.CompileStatic
trait FooTrait {
    public final Runnable foo = { println new Date() } as Runnable
    void doRun() { foo.run() }
}

class Foo implements FooTrait { }

new Foo().doRun()
{code}
The {{$self}} in static context case:
{code}
trait TestTrait {
    boolean flag = true
    public final Runnable foo = { println flag } as Runnable
}
{code};;;","24/Apr/17 08:06;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/529

    GROOVY-8127: Access to Trait$Trait$Helper#$self is forbidden

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8127

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/529.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #529
    
----
commit f2a6cef30081456cb3da6ba27dd689d3210a48bd
Author: paulk <paulk@asert.com.au>
Date:   2017-04-24T08:02:34Z

    GROOVY-8127: Access to Trait$Trait$Helper#$self is forbidden

----
;;;","24/Apr/17 14:09;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/529
;;;","24/Apr/17 14:27;paulk;Proposed PR merged but additional feedback on the fix is welcome. Thanks for raising the issue.;;;",,,,,,,,,,,,,,,,,
Inadvertent source code incompatibility in Groovy 2.4.7 release,GROOVY-8126,13057768,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,21/Mar/17 03:02,21/Mar/17 06:37,14/Jul/23 06:02,21/Mar/17 03:03,2.4.7,,,,,,,,2.4.7,,,,,,,,0,breaking,,,,,,"I just spotted a change in 2.4.7 that inadvertently broke source code/contract compatibility. After 1 year it seems just as dangerous to revert as to leave. So I am creating this Jira to note the change and suggest a workaround. We'll change this issue if a better solution is found.

https://github.com/apache/groovy/commit/78b6cc54af85988829ecd6120b69f65e0d9a8ade
{noformat}
src/main/groovy/lang/GroovyCodeSource.java
-    public GroovyCodeSource(URL url) throws IOException {
+    public GroovyCodeSource(URL url) {
{noformat}
Suggested workarounds.
# If you are upgrading and are going to now only use Groovy 2.4.7 and above, just delete any catch statements catching IOException.
# If you have code that needs to work with old and new versions of Groovy and are checking for the IOException, change it to just Exception (and potentially move after other catch blocks) and check for IOException using instanceof if needed.",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-03-21 03:02:37.0,,,,,,,,,,"0|i3ck2n:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bump commons cli version to 1.4,GROOVY-8120,13055889,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,paulk,14/Mar/17 09:49,02/May/17 02:03,14/Jul/23 06:02,14/Mar/17 13:11,,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-03-14 09:49:19.0,,,,,,,,,,"0|i3c8gv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
groovydoc links to a wrong type,GROOVY-8117,13050289,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,vmj,vmj,12/Mar/17 01:44,02/May/17 02:03,14/Jul/23 06:02,22/Apr/17 23:44,2.1.1,2.4.10,,,,,,,2.4.11,,,,GroovyDoc,,,,0,,,,,,,"When I generate groovydocs for the following class:

{code:title=FooAdapter.groovy}
import api.Foo
import lib.Foo as FooImpl

class FooAdapter implements Foo {
    FooAdapter(FooImpl foo) {}
}
{code}

where some API defines:

{code:title=api/Foo.java}
package api;
public interface Foo {}
{code}

and some library defines:

{code:title=lib/Foo.java}
package lib;
public class Foo {}
{code}

then in the documentation the implemented interface ""Foo"" links to {{lib/Foo.html}} instead of {{api/Foo.html}}.
",,paulk,vmj,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Apr 22 23:44:56 UTC 2017,,,,,,,,,,"0|i3babj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Mar/17 01:53;vmj;This was working in 2.1.0, but at the time the ""FooImpl"" was not linked to anything. At 2.1.1 ""FooImpl"" started to link to the right place but this got broken.

;;;","12/Mar/17 01:54;vmj;I've got a test case and a possible fix at https://github.com/vmj/groovy/tree/bugfix/GROOVY-8117
;;;","12/Mar/17 09:49;paulk;Do you want to create a PR? I haven't checked yet why it ""became broken"" but something like what you have possibly with some minor tweaks seems like what we need.;;;","12/Mar/17 11:30;vmj;Sure, there it is: https://github.com/apache/groovy/pull/512

It's highly likely that the change affects more places that I could understand, so by all means let me know what needs to be changed.
;;;","22/Apr/17 23:44;paulk;PR applied. I did a quick analysis and what you had looked okay. Thanks!;;;",,,,,,,,,,,,,,,,,
NPE in Groovy compiler when referencing @Field in aic,GROOVY-8112,13049331,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,avladykin,avladykin,08/Mar/17 17:41,06/Mar/18 23:12,14/Jul/23 06:02,01/Nov/17 09:23,2.4.9,,,,,,,,2.4.13,,,,xforms,,,,0,,,,,,,"The following Groovy script causes NPE at compile time:

{code:java|title=Bug.groovy}
@Grapes([
    @Grab(""org.slf4j:slf4j-api:1.7.22""),
    @Grab(""org.apache.kafka:kafka-clients:0.10.2.0"")
])

import groovy.transform.Field
import org.apache.kafka.clients.producer.Callback
import org.apache.kafka.clients.producer.KafkaProducer
import org.apache.kafka.clients.producer.ProducerRecord
import org.apache.kafka.clients.producer.RecordMetadata
import org.slf4j.Logger
import org.slf4j.LoggerFactory

@Field static final Logger logger = LoggerFactory.getLogger(Bug.class)

wrapper {

    Properties config = new Properties()
    KafkaProducer kafkaProducer = new KafkaProducer<>(config)

    kafkaProducer.send(new ProducerRecord<>('topic', 'data'), new Callback() {
        @Override
        void onCompletion(RecordMetadata recordMetadata, Exception e) {
            if (e != null) {
                logger.error(""Error sending to Kafka"", e)
            }
        }
    })
}
{code}

Full error message from groovyc:
{code:none}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
General error during class generation: NPE while processing Bug.groovy

groovy.lang.GroovyRuntimeException: NPE while processing Bug.groovy
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:258)
	at org.codehaus.groovy.control.CompilationUnit$16.call(CompilationUnit.java:813)
	at org.codehaus.groovy.control.CompilationUnit$16.call(CompilationUnit.java:830)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1053)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:525)
	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:61)
	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:217)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:150)
	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:180)
	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:164)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131)
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitFieldExpression(AsmClassGenerator.java:1049)
	at org.codehaus.groovy.classgen.asm.ClosureWriter.loadReference(ClosureWriter.java:135)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.loadVariableWithReference(InvocationWriter.java:611)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeAICCall(InvocationWriter.java:596)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeConstructor(InvocationWriter.java:571)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorCallExpression(AsmClassGenerator.java:818)
	at org.codehaus.groovy.ast.expr.ConstructorCallExpression.visit(ConstructorCallExpression.java:46)
	at org.codehaus.groovy.classgen.asm.CallSiteWriter.makeCallSite(CallSiteWriter.java:303)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCachedCall(InvocationWriter.java:307)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:392)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:104)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:88)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:459)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:767)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeReturn(StatementWriter.java:589)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeReturn(OptimizingStatementWriter.java:319)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitReturnStatement(AsmClassGenerator.java:616)
	at org.codehaus.groovy.ast.stmt.ReturnStatement.visit(ReturnStatement.java:49)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:84)
	at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeBlockStatement(OptimizingStatementWriter.java:158)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:566)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:104)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:115)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:430)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:387)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:126)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:507)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1078)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:53)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:233)
	... 18 more

1 error
{code}",Windows 8 x64,avladykin,githubbot,paulk,Schlogen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 01 09:23:48 UTC 2017,,,,,,,,,,"0|i3b4pr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Mar/17 04:18;paulk;A smaller example showing the issue:
{code}
import groovy.transform.Field
import org.slf4j.Logger

@Field Logger logger

[].each {
  new Iterable() {
    Iterator iterator() {
      logger.error(""Error!"")
      [].iterator()
    }
  }
}
{code}
Error message:
{noformat}
groovy.lang.GroovyRuntimeException: NPE while processing Bug.groovy
    at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:258)
    ...
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitFieldExpression(AsmClassGenerator.java:1070)
	at org.codehaus.groovy.classgen.asm.ClosureWriter.loadReference(ClosureWriter.java:135)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.loadVariableWithReference(InvocationWriter.java:616)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeAICCall(InvocationWriter.java:601)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeConstructor(InvocationWriter.java:576)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorCallExpression(AsmClassGenerator.java:834)
{noformat}
The AIC has to be inside a Closure to trigger the error.;;;","19/Oct/17 19:32;Schlogen;[~paulk] Facing this issue with 2.5.0-beta-2 in Grails core;;;","20/Oct/17 02:51;paulk;[~Schlogen] Do you have a travis-ci build showing the error or which gradle task did it get up to?;;;","20/Oct/17 03:02;Schlogen;[~paulk] If you check out the spring_5 branch and change the Groovy version in build.gradle you can reproduce the issue;;;","20/Oct/17 07:28;paulk;I already have that checked out - which task are you using? ""test"" good enough?;;;","20/Oct/17 13:12;Schlogen;[~paulk] Just `./gradlew clean classes`;;;","29/Oct/17 22:06;paulk;Another workaround is to use {{this.logger}}.;;;","29/Oct/17 22:48;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/622

    GROOVY-8112: NPE in Groovy compiler when referencing @Field in aic

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8112

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/622.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #622
    
----
commit 3839297520e325b8520d856bd2d74fc5ee63cced
Author: paulk <paulk@asert.com.au>
Date:   2017-10-29T22:47:28Z

    GROOVY-8112: NPE in Groovy compiler when referencing @Field in aic

----
;;;","01/Nov/17 09:04;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/622
;;;","01/Nov/17 09:23;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,
Stack overflow between WideningCategories lowestUpperBound and parameterizeLowestUpperBound,GROOVY-8111,13049293,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,emilles,emilles,emilles,08/Mar/17 15:43,28/Feb/22 20:46,14/Jul/23 06:02,01/Jun/21 19:16,2.5.14,3.0.8,4.0.0-beta-1,,,,,,2.5.16,3.0.9,4.0.0-beta-1,,,,,,0,,,,,,,"I have run into this stack overflow error a few times when editing a Groovy file.  Consider the following:
{code:groovy}
// excerpt of org.apache.commons.lang3.tuple.Pair
class Pair<L, R> implements Map.Entry<L, R>, Comparable<Pair<L, R>>, Serializable {
  public final L left
  public final R right

  private Pair(final L left, final R right) {
    this.left = left
    this.right = right
  }

  static <L, R> Pair<L, R> of(final L left, final R right) {
    return new Pair<>(left, right)
  }

  L getKey() { left }
  R getValue() { right }
  R setValue(R value) { right }
  int compareTo(Pair<L,R> that) { 0 }
}

@groovy.transform.TypeChecked
def test(thing) {
  thing != null ?: Pair.of('', ['']) // STCV is trying to get LUB of boolean and Pair<String,List<String>>
}

test(null)
{code}

Captured on Groovy 2.4.9:
{code:java}
java.lang.StackOverflowError
	at org.codehaus.groovy.ast.ClassNode.getText(ClassNode.java:1686)
	at org.codehaus.groovy.ast.ClassNode.equals(ClassNode.java:813)
	at org.codehaus.groovy.ast.ClassNode.equals(ClassNode.java:810)
	at org.codehaus.groovy.ast.ClassNode.declaresInterface(ClassNode.java:1082)
	at org.codehaus.groovy.ast.ClassNode.implementsInterface(ClassNode.java:1060)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(StaticTypeCheckingSupport.java:798)
	at org.codehaus.groovy.ast.tools.GenericsUtils.extractSuperClassGenerics(GenericsUtils.java:434)
	at org.codehaus.groovy.ast.tools.GenericsUtils.parameterizeType(GenericsUtils.java:228)
	at org.codehaus.groovy.ast.tools.WideningCategories.findGenericsTypeHolderForClass(WideningCategories.java:269)
	at org.codehaus.groovy.ast.tools.WideningCategories.parameterizeLowestUpperBound(WideningCategories.java:233)
	at org.codehaus.groovy.ast.tools.WideningCategories.lowestUpperBound(WideningCategories.java:203)
	at org.codehaus.groovy.ast.tools.WideningCategories.parameterizeLowestUpperBound(WideningCategories.java:250)
	at org.codehaus.groovy.ast.tools.WideningCategories.lowestUpperBound(WideningCategories.java:203)
	at org.codehaus.groovy.ast.tools.WideningCategories.parameterizeLowestUpperBound(WideningCategories.java:250)
	at org.codehaus.groovy.ast.tools.WideningCategories.lowestUpperBound(WideningCategories.java:203)
	at org.codehaus.groovy.ast.tools.WideningCategories.parameterizeLowestUpperBound(WideningCategories.java:250)
	at org.codehaus.groovy.ast.tools.WideningCategories.lowestUpperBound(WideningCategories.java:203)
{code}",,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 20 15:06:49 UTC 2021,,,,,,,,,,"0|i3b4hb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Mar/17 00:24;paulk;We can probably recreate fairly easily from your description but to save some time, do you have a sample source file that causes that stacktrace?;;;","20/May/21 15:06;emilles;Finally found this again.  And note this error crashed the IDE editor, so it becomes very difficult to try and resolve.;;;",,,,,,,,,,,,,,,,,,,,
@ListenerList generated fireWhatever() method stops working,GROOVY-8110,13049238,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,frigo.work,frigo.work,08/Mar/17 11:31,18/Mar/17 09:56,14/Jul/23 06:02,09/Mar/17 21:15,2.4.7,2.4.8,,,,,,,2.4.10,,,,groovy-runtime,,,,0,,,,,,,"As described in the question on SO
[http://stackoverflow.com/questions/42648766/groovy-listenerlist-generated-firexxx-method-stops-working]
and confirmed by @aalmiray the fireWhatever() method generated when
using @ListenerList annotation stops working after some calls.

[@aalmiray|http://stackoverflow.com/users/120745/aalmiray] s code as posted in his reply reproduces the problem with
Groovy 2.4.7 and I confirmed it with 2.4.8 running it in groovyConsole. The difference between this code and the longer one in the SO question is that in the longer version the call works but if called periodically after some time it produces the same Exception.

{code:title=MessageProducer.groovy|borderStyle=solid}
import groovy.beans.ListenerList

interface MessageListener {
  void messageReceived(byte[] msg)
}

class MessageProducer {
  @ListenerList
  List<MessageListener> listeners

  void produce(String msg) {
    fireMessageReceived(msg.getBytes())
  }
}

producer = new MessageProducer()
producer.addMessageListener({ println it } as MessageListener)
producer.produce('Groovy')
{code}

{code:title=Stacktrace|borderStyle=solid}
Exception thrown

java.lang.NoSuchMethodError: MessageProducer.fireMessageReceived([B)V
        at MessageProducer$fireMessageReceived$0.callCurrent(Unknown
Source) at MessageProducer.produce(ConsoleScript0:12)
        at MessageProducer$produce.call(Unknown Source)
        at ConsoleScript0.run(ConsoleScript0:18
{code}",,frigo.work,githubbot,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 09 21:15:33 UTC 2017,,,,,,,,,,"0|i3b453:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Mar/17 12:17;paulk;Just some additional info/examples. Using String[] as the type instead of byte[] yields:
{noformat}
java.lang.ClassFormatError: Method ""fireMessageReceived"" in class MessageProducer has illegal signature ""(L[Ljava/lang/String;;)V""
{noformat}
With similar results for other object types.

Adding @CompileStatic to the produce method yields:
{noformat}
java.lang.VerifyError: (class: MessageProducer, method: produce signature: (Ljava/lang/String;)V) Incompatible argument to function
{noformat}
;;;","09/Mar/17 08:01;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/510

    GROOVY-8110: @ListenerList generated fireWhatever() method stops working

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8110

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/510.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #510
    
----
commit d98c82000ce2e8e832242eeb5ddac4e63759d3b9
Author: paulk <paulk@asert.com.au>
Date:   2017-03-09T07:59:15Z

    GROOVY-8110: @ListenerList generated fireWhatever() method stops working

----
;;;","09/Mar/17 21:13;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/510
;;;","09/Mar/17 21:15;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,
Unsupported operator with @CompileStatic causes BUG! () during compilation,GROOVY-8109,13048798,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,wviterson,wviterson,07/Mar/17 08:57,18/Mar/17 09:56,14/Jul/23 06:02,08/Mar/17 05:06,2.4.9,,,,,,,,2.4.10,,,,Compiler,,,,0,,,,,,,"When I compile the following code
{code:title=UnsupportedOperator.groovy|borderStyle=solid}
@groovy.transform.CompileStatic  
class UnsupportedOperator { 
  def x = 'a' !== 'b' 
} 
{code}
 
I get the following NullPointerException during compilation:
{noformat}
BUG! exception in phase 'instruction selection' in source unit 'ConsoleScript13' unexpected NullpointerException

Caused by: java.lang.NullPointerException
{noformat}

Without the @CompileStatic, I get the expected error message:
{noformat}
Caused by: org.codehaus.groovy.syntax.SyntaxException: Operator (""!=="" at 3:17:  ""!=="" ) not supported @ line 3, column 17.
{noformat}

This might be similar to https://github.com/groovy/groovy-eclipse/issues/179","GroovyConsole (2.4.8), Maven (2.4.9) and IntelliJ, All in Windows 7",githubbot,paulk,wviterson,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 08 05:47:41 UTC 2017,,,,,,,,,,"0|i3b1kn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Mar/17 21:09;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/509

    GROOVY-8109: Unsupported operator with @CompileStatic causes BUG! () …

    …during compilation

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8109

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/509.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #509
    
----
commit cf3cb17e6af87b1eb4188e496f4b8c9fa2f2820a
Author: paulk <paulk@asert.com.au>
Date:   2017-03-07T21:08:07Z

    GROOVY-8109: Unsupported operator with @CompileStatic causes BUG! () during compilation

----
;;;","08/Mar/17 05:06;paulk;Proposed PR merged.;;;","08/Mar/17 05:47;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/509
;;;",,,,,,,,,,,,,,,,,,,
Binary incompatibility problems between compiled code in Groovy 2.4.7 vs 2.4.9,GROOVY-8107,13047940,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,graemerocher1,graemerocher1,03/Mar/17 08:29,18/Mar/17 09:56,14/Jul/23 06:02,08/Mar/17 05:07,2.4.9,,,,,,,,2.4.10,,,,,,,,0,,,,,,,"There are currently various binary incompatibility problems that are presenting a challenge for us moving forward with upgrading to Groovy 2.4.9 in Grails.

One of them is Groovy traits compiled with Groovy 2.4.9 are not usable in Groovy 2.4.7 due to the following exception:

{code}
Error:Groovyc: While compiling tests of grails-datastore-gorm-hibernate5_test: BUG! exception in phase 'semantic analysis' in source unit '/Users/graemerocher/grails/gorm-hibernate5/grails-datastore-gorm-hibernate5/src/test/groovy/grails/gorm/tests/jpa/SimpleJpaEntitySpec.groovy' null
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:932)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:590)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:566)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:543)
...
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.ast.expr.VariableExpression.<init>(VariableExpression.java:64)
	at org.codehaus.groovy.transform.trait.TraitComposer.applyTrait(TraitComposer.java:247)
	at org.codehaus.groovy.transform.trait.TraitComposer.doExtendTraits(TraitComposer.java:111)
	at org.grails.compiler.gorm.GormEntityTransformation.visit(GormEntityTransformation.groovy:338)
	at org.grails.compiler.gorm.JpaGormEntityTransformation.visit(JpaGormEntityTransformation.groovy:50)
	at org.grails.compiler.gorm.GlobalJpaEntityTransform.visitClass(GlobalJpaEntityTransform.groovy:43)
	at org.grails.compiler.gorm.GlobalJpaEntityTransform.visit(GlobalJpaEntityTransform.groovy:35)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$3.call(ASTTransformationVisitor.java:319)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:928)
	... 22 more
{code}

This is an issue and IMO there should never be binary incompatible breaking changes between different patch releases of Groovy 2.4.x.

The other issue is https://issues.apache.org/jira/browse/GROOVY-8048

Which is marked as fixed, but currently code already compiled in Groovy 2.4.7 is throwing a NPE using 2.4.9 such as:

{code}
Caused by: java.lang.NullPointerException: null
        at org.codehaus.groovy.runtime.DefaultGroovyMethods.leftShift(DefaultGroovyMethods.java:12204)
        at grails.artefact.Interceptor$Trait$Helper.matchAll(Interceptor.groovy:109)
{code}

We can't really ask people to start recompiling existing published libraries for a patch release of Groovy so are looking for a path forward with these problems.

It is my opinion that we should be aim to never break binary compatibility in a major release let alone in a patch release.",,blackdrag,githubbot,graemerocher1,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/Mar/17 09:41;graemerocher1;groovy-npe-test.zip;https://issues.apache.org/jira/secure/attachment/12855810/groovy-npe-test.zip","03/Mar/17 09:47;graemerocher1;interceptor-issue.zip;https://issues.apache.org/jira/secure/attachment/12855812/interceptor-issue.zip",,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 08 05:07:51 UTC 2017,,,,,,,,,,"0|i3awbz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Mar/17 09:41;graemerocher1;Attached a Grails application that reproduces the first issue;;;","03/Mar/17 09:47;graemerocher1;Attached example of second issue. Unzip interceptor-issue.zip, cd into `test-app` and run `./gradlew bootRun`;;;","03/Mar/17 09:50;blackdrag;What exactly is the binary breaking change?;;;","03/Mar/17 09:51;blackdrag;What I would get from your comments would be to undo the change for 8048 and do it instead in  3.0;;;","03/Mar/17 10:12;paulk;Moving the 8048 fix to 2.5 or 3 is one of the options we might have to consider, or provide a switch to allow people to opt-in. I'll do some more investigation to see what other options we might have.;;;","03/Mar/17 10:57;graemerocher1;Well my understanding was the fix for 8048 was done due to a regression in 2.4.8 (final fields in traits broke which broke the interceptor trait in Grails) which was supposed to have been solved in 2.4.9 with this fix? Unless I am misunderstanding. Either way simply rolling back the fix for 8048 will not solve it. 

The original problem in 2.4.8 (which preventing us from upgrading to that release) with final fields and traits will need to be resolved somehow.;;;","03/Mar/17 14:32;blackdrag;The 2.4.8 problem was caused by https://github.com/apache/groovy/commit/c00a75a89a15e46c2afacf6e72256cd4484bd5f1 it seems. 

But frankly I still do not see the binary compatibility problem you are talking about. What I have seen looks a lot like a wrong generation of code. If that is the case, you will not fix the NPEs without recompilation. At this point it is nowhere clear to me if the issue can be fixed without requiring recompilation;;;","03/Mar/17 14:54;graemerocher1;That is a big problem since we have existing libraries and plugins compiled with early version of Groovy 2.4.x that will simply fail with this NPE :( ;;;","05/Mar/17 21:54;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/508

    GROOVY-8107: Binary incompatibility problems between compiled code in…

    … Groovy 2.4.7 vs 2.4.9

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8107

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/508.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #508
    
----
commit dbaabcac0e34341c19796d02bfd8c53a02ff2bbc
Author: paulk <paulk@asert.com.au>
Date:   2017-03-05T21:52:26Z

    GROOVY-8107: Binary incompatibility problems between compiled code in Groovy 2.4.7 vs 2.4.9

----
;;;","05/Mar/17 22:08;paulk;Jochen, the binary incompatibility isn't in any Groovy class itself but the generated trait helper classes were backward compatible only not forward compatible.

The attached PR keeps both the old and new fields in the generated trait class and changes the priority to look for the new ones first. I'd propose merging this and releasing 2.4.10. It should then allow traits compiled under 2.4.10 to be used from 2.4.7 which is what is failing now. Honoring of the final field wouldn't work in that case but the behavior would be equivalent to 2.4.7 behavior.

I built a local 6.1.0.BUILD-SNAPSHOT of grails-data-mapping and the groovy-npe-test example now compiles.;;;","05/Mar/17 22:50;blackdrag;What with code compiled using 2.4.8 or 2.4.9?;;;","06/Mar/17 00:14;paulk;Traits compiled with 2.4.8 or 2.4.9 will work with 2.4.8+ (apart from the GROOVY-8048 bug) but not 2.4.7 and before (without recompiling the trait). We'll need to document that in known issues. It was a short-coming in my fix for GROOVY-7584. In hindsight, both GROOVY-7584 and GROOVY-8048 should probably have been done just in the 2.5 branch and maintaining compatibility both ways should have been factored into the design. But given the current state of play, I'd suggest merging the fix into 2.4.10 and we can decide later whether in 3.0 we'd drop supporting the old style field naming convention.;;;","08/Mar/17 05:05;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/508
;;;","08/Mar/17 05:07;paulk;Proposed PR merged;;;",,,,,,,,
Could not call constructor of inner class from anonimous class inside closure,GROOVY-8104,13047710,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,ks.zealot,ks.zealot,02/Mar/17 15:57,31/Jan/22 18:02,14/Jul/23 06:02,24/Mar/21 14:28,,,,,,,,,2.5.16,3.0.8,4.0.0-alpha-3,,,,,,0,,,,,,,"When I was trying to call constructor from anonymous class, I  catch strange exception
{code}
Could not find matching constructor for: A$B(A$_foo_closure1)
{code}
Here is a reproduction
{code}
interface I {
    void bar(Object o)
}
class A {
    void foo(){
        C c = new C()
        ['1','2','3'].each {
            obj ->
                c.baz(obj, new I() {
                    @Override
                    void bar(Object o) {
                        B b = new B(  )

                    }
                })
        }
    }
    class B {

    }
}
class C {
    void baz(Object o, I i) {
        i.bar(o)
    }
}
A a = new A()
a.foo()
{code}

When my inner class have fields, exception is slightly different

{code}
GroovyRuntimeException: Could not find matching constructor for: A$B(A$_foo_closure1, java.util.LinkedHashMap)
{code}
Enviroment : groovy 2.3.9
",,ks.zealot,,,,,,,,"eric-milles opened a new pull request #1531:
URL: https://github.com/apache/groovy/pull/1531


   https://issues.apache.org/jira/browse/GROOVY-8104
   
   ```groovy
   class Outer {
     class Inner {
       // requires Outer reference
     }
     def x = { ->
       new Inner() { // this.@this$0 returns closure; call getThisObject()
       }
     }
   }
   ```


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;21/Mar/21 18:28;githubbot;600","danielsun1106 merged pull request #1531:
URL: https://github.com/apache/groovy/pull/1531


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;24/Mar/21 14:16;githubbot;600","danielsun1106 commented on pull request #1531:
URL: https://github.com/apache/groovy/pull/1531#issuecomment-805860786


   Merged. Thanks!


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;24/Mar/21 14:19;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-03-02 15:57:10.0,,,,,,,,,,"0|i3auwv:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
STC: matching return type of one static method to parameter type of another,GROOVY-8103,13047380,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,emilles,emilles,01/Mar/17 17:04,11/Nov/20 02:01,14/Jul/23 06:02,17/Sep/20 22:38,,,,,,,,,,,,,Static Type Checker,,,,0,,,,,,,"We are using a fluent API based testing library (FEST assert).  I tried to boil this problem down; I hope this example is not too abstract.  Basically, there is a main fluent method that starts every test assertion and this is a static method with many overloads.  The library offers an extension mechanism where you put in your own type and this is where the checker is failing.
{code}
@groovy.transform.TypeChecked
def method() {
    fluent('string').isEqualTo('x') // fine
    fluent(new Util.Ours()).isSimilarTo('') // fine
    fluent(Util.Ours.factory('{}')).isSimilarTo('{""key"":""val""}') // STC error
}
{code}

Supporting code (library provided):
{code}
class Fluent
{
    static FluentAPI fluent(String s) { return new FluentAPI() }
    static <T extends FluentExtension> T fluent(T t) { return t }
}

class FluentAPI
{
    FluentAPI isEqualTo(String s) { return this }
}

interface FluentExtension
{
}
{code}

Our extension:
{code}
class Util {
    static class Ours implements FluentExtension {
        Ours isSimilarTo(String json) { return this }
    }

    static Ours factory(String json) { new Ours() }
}
{code}",,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 17 22:38:38 UTC 2020,,,,,,,,,,"0|i3asvr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/May/17 12:12;emilles;I have another example of this which is specific to CompileStatic.  {{assertThat}} at the end of the block infers to the {{assertThat(Object): ObjectAssert}} overload.  This is correct.  Then {{isNotNull(Object)}} is defined in the superclass, which should now have generic parameters {{GenericAssert<ObjectAssert, Object>}}.  And so {{isNotNull}} has a return type of the second first generic param {{ObjectAssert}}.  But I am getting {{ThrowableAssert}} as the inferred return type.

When I switch from CompileStatic to TypeChecked, the correct return type is inferenced.  So there must be something in the extra transformations of static compilation that cause this.

{code}
@Grab('org.easytesting:fest-assert:1.4')
import static org.fest.assertions.Assertions.assertThat
import static org.mockito.Matchers.*
import static org.mockito.Mockito.*

import groovy.transform.CompileStatic

import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mock
import org.mockito.runners.MockitoJUnitRunner

@CompileStatic @RunWith(MockitoJUnitRunner)
final class MockTest {

  @Mock
  Sample sample

  @Test
  void testMocks() {
    when(sample.method(any(Object))).thenReturn(~/abc/)

    def pat = sample.pattern

    assertThat(pat).isNotNull()
    verify(sample).getPattern()
  }
}
{code};;;","17/Sep/20 22:38;emilles;Fixed circa 2.5.10.  I wasn't able to create a good enough test case to find out exactly when.;;;",,,,,,,,,,,,,,,,,,,,
MarkupBuilder cant yield before first tag,GROOVY-8100,13046677,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,eddelplus,eddelplus,27/Feb/17 16:26,23/Jul/20 14:16,14/Jul/23 06:02,21/Jun/20 23:43,2.4.8,3.0.0-rc-2,,,,,,,3.0.5,4.0.0-alpha-1,,,XML Processing,,,,0,,,,,,,"Trying to produce an HTML5 compliant !DOCTYPE before starting with the HTML-Elements. Without setting the private field 'state' to 2, the output does not show the yielded output. 

{code}
def html = new groovy.xml.MarkupBuilder(new PrintWriter(System.out))
//html.state = 2
html.mkp.yieldUnescaped(""<!DOCTYPE html>\n"")
html.h1(""Header"")
{code}

I suggest fixing this by changing the yield-Method to not check the state before doing the output, so that we see some output when the initial state is still 0:

{code}
void yield(String value, boolean escaping) {
    if (state == 1) {
        state = 2;
        this.nodeIsEmpty = false;
        out.print("">"");
    }
    // -- remove -- if (state == 2 || state == 3) {
    out.print(escaping ? escapeElementContent(value) : value);
    // -- remove -- }
}
{code}
","Oracle Java 1.8.0_112, Windows 10 x64",daniel_sun,eddelplus,,,,,,,"eddelplus opened a new pull request #1284:
URL: https://github.com/apache/groovy/pull/1284


   This will let MarkupBuilder yield output at initial state (0), before any markup is created, e.g. allowing the creation of ""<!DOCTYPE html>"" via MarkupBuilder.mkp.yieldUnescaped.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Jun/20 12:27;githubbot;600","danielsun1106 merged pull request #1284:
URL: https://github.com/apache/groovy/pull/1284


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;21/Jun/20 23:42;githubbot;600","danielsun1106 commented on pull request #1284:
URL: https://github.com/apache/groovy/pull/1284#issuecomment-647197082


   Merged. Thanks.


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;21/Jun/20 23:42;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 21 23:43:03 UTC 2020,,,,,,,,,,"0|i3aojr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Jun/20 23:43;daniel_sun;The proposed PR has been merged. Thanks for your contribution!;;;",,,,,,,,,,,,,,,,,,,,,
Final variable analysis giving incorrect message within nested if,GROOVY-8094,13044738,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,21/Feb/17 07:50,06/Mar/18 23:25,14/Jul/23 06:02,24/Dec/17 06:37,2.5.x,,,,,,,,2.5.0-beta-3,,,,Compiler,,,,0,,,,,,,"{code}
def method() {
    final z = null
    if (z != null) {
        z = 3
    }
}
{code}
gives error message:
{noformat}
1 compilation error:
The variable [z] may be uninitialized
. At [5:11]  at line: 5, column: 11
{noformat}
it should be a compile error since we are reassigning {{z}}, but the error message should be:
{noformat}
The variable [z] is declared final but is reassigned
{noformat}
",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-02-21 07:50:06.0,,,,,,,,,,"0|i3ad0f:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Final variable analysis broken within closure fields,GROOVY-8093,13044692,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,21/Feb/17 02:44,06/Mar/18 23:25,14/Jul/23 06:02,06/Feb/18 22:46,2.5.x,,,,,,,,2.5.0-beta-3,,,,Compiler,,,,0,,,,,,,"The following code compiles and runs successfully in 2.4.8 but fails in 2.5 snapshots:
{code}
class Foo {
    public Closure bar = {
        final RANKINGS = [""year"": 0, ""month"": 10]
    }
}

new Foo().bar()
{code}
Error message is:
{noformat}
1 compilation error:
The variable [RANKINGS] is declared final but is reassigned
. At [3:9]  at line: 3, column: 9
{noformat}
",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8419,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 06 22:46:23 UTC 2018,,,,,,,,,,"0|i3acq7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Feb/18 08:31;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/659

    GROOVY-8093: Final variable analysis broken within closure fields

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8093

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/659.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #659
    
----

----
;;;","06/Feb/18 22:38;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/659
;;;","06/Feb/18 22:46;paulk;Proposed PR merged.;;;",,,,,,,,,,,,,,,,,,,
Incorrectly processing method-level type generics information,GROOVY-8090,13044425,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,paulk,paulk,20/Feb/17 04:36,11/Apr/23 14:20,14/Jul/23 06:02,26/Aug/18 08:37,2.4.8,,,,,,,,2.5.3,3.0.0-alpha-4,,,Static Type Checker,,,,0,,,,,,,"{code}
import static java.util.Arrays.asList

@groovy.transform.CompileStatic
class Main {
    final <T> Iterable<T> foo(T instance) { asList(instance) }
    // next line fails with: [Static type checking] - Cannot call <T> java.util.Arrays#asList(T[]) with arguments [U]
    final <U> Iterable<U> bar(U instance) { asList(instance) }
    final Iterable<String> baz(String instance) { asList(instance) }
}

new Main().with {
    assert foo('A') + bar('B') + baz('C') == ['A', 'B', 'C']
}
{code}",,daniel_sun,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-11003,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 26 08:37:46 UTC 2018,,,,,,,,,,"0|i3ab2v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Feb/17 04:38;paulk;I thought something similar had been reported already but couldn't find it with a quick search.;;;","26/Aug/18 02:43;daniel_sun;The example code can be simplified as

 
{code:java}
@groovy.transform.CompileStatic
class Main {
    final <U> Iterable<U> bar(U instance) { Arrays.asList(instance) }
}

new Main().with {
    assert bar('B') == ['B']
}

{code};;;","26/Aug/18 04:50;paulk;Yes, the two other lines are to show cases that we currently ""handle"". Obviously the {{T}} case although passing must only be partially ""handling"" since otherwise you'd expect the {{U}} case to also work not just because we happened to use the same generic type name as used to define {{Arrays#asList}}.;;;","26/Aug/18 06:46;githubbot;GitHub user danielsun1106 opened a pull request:

    https://github.com/apache/groovy/pull/789

    GROOVY-8090: Incorrectly processing method-level type generics inform…

    …ation

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/danielsun1106/groovy GROOVY-8090

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/789.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #789
    
----
commit eb559b9bf5766746e24bfadef738273df36dc296
Author: danielsun1106 <realbluesun@...>
Date:   2018-08-26T06:22:25Z

    GROOVY-8090: Incorrectly processing method-level type generics information

----
;;;","26/Aug/18 08:26;daniel_sun;Hi [~paulk]

We look for generics type only by its name, which will cause some potential issues(e.g. GROOVY-8409 ). The generics type name issue helps us here by accident(as you said, {{the two other lines are to show cases that we currently ""handle""}}), but it brings trouble to us at the most time... so I have been trying to fix it, see the comment here ( [https://github.com/apache/groovy/blob/master/src/main/java/org/codehaus/groovy/ast/GenericsType.java#L505-L517] ), fails to fix until now... It would be great if you could set aside some time on the generics type name issue.;;;","26/Aug/18 08:35;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/789
;;;","26/Aug/18 08:37;daniel_sun;Fixed by https://github.com/apache/groovy/commit/0395aff7e9ac00d97f2bc1ff7ee10d6034cf495b;;;",,,,,,,,,,,,,,,
bump log4j2 version,GROOVY-8087,13043089,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,14/Feb/17 21:58,02/May/17 02:03,14/Jul/23 06:02,16/Feb/17 03:32,,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,,,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 16 03:34:57 UTC 2017,,,,,,,,,,"0|i3a31r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Feb/17 06:19;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/497

    GROOVY-8087: bump log4j2 version

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8087

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/497.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #497
    
----
commit 89e2aebc1e2a93544c4dddfae4ebf1b5205872a1
Author: paulk <paulk@asert.com.au>
Date:   2017-02-15T06:17:59Z

    GROOVY-8087: bump log4j2 version

----
;;;","16/Feb/17 03:32;paulk;Proposed PR merged;;;","16/Feb/17 03:34;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/497
;;;",,,,,,,,,,,,,,,,,,,
Bump gradle version to 3.3 on master,GROOVY-8086,13043088,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,14/Feb/17 21:57,02/May/17 02:03,14/Jul/23 06:02,15/Feb/17 06:17,,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-02-14 21:57:10.0,,,,,,,,,,"0|i3a31j:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Exception in ""finally"" not caught by outer ""try""",GROOVY-8085,13041554,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,daniel_sun,csilvers,csilvers,09/Feb/17 01:05,13/Jun/17 19:31,14/Jul/23 06:02,27/Feb/17 01:14,2.4.8,,,,,,,,2.4.10,,,,Compiler,,,,0,,,,,,,"I would expect the following code to print `caughtt`:
```
groovy -e 'try { try { true; } finally { 1 / 0 } } catch (e) { println ""caughtt"" }'
```

But instead, it prints:
```
Caught: java.lang.ArithmeticException: Division by zero
java.lang.ArithmeticException: Division by zero
        at script_from_command_line.run(script_from_command_line:1)
```

Why is the exception, thrown by the `finally`, not being caught by the outer try/catch?",linux,blackdrag,csilvers,d0k1,daniel_sun,githubbot,jwagenleitner,mauromol,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8229,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 27 23:54:32 UTC 2017,,,,,,,,,,"0|i39tl3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Feb/17 04:25;daniel_sun;{code}
// Test.groovy
try { 
    try { 
        true; 
    } finally { 
        1 / 0 
    }
} catch (Exception e) { 
    println ""caughtt"" 
}
{code}

The above code can be compiled by groovyc and decompiled by jd as follows(1 / 0  appears many times...):

{code}
import groovy.lang.Binding;
import groovy.lang.Script;
import org.codehaus.groovy.runtime.BytecodeInterface8;
import org.codehaus.groovy.runtime.InvokerHelper;
import org.codehaus.groovy.runtime.callsite.CallSite;

public class Test
  extends Script
{
  public Test() {}
  
  public Test(Binding context)
  {
    super(context);
  }
  
  public static void main(String... args)
  {
    CallSite[] arrayOfCallSite = $getCallSiteArray();
    arrayOfCallSite[0].call(InvokerHelper.class, Test.class, args);
  }
  
  public Object run()
  {
    CallSite[] arrayOfCallSite = $getCallSiteArray();
    if ((!BytecodeInterface8.isOrigInt()) || (__$stMC) || (BytecodeInterface8.disabledStandardMetaClass())) {
      try
      {
        try
        {
          try
          {
            return Boolean.valueOf(true);
          }
          finally
          {
            arrayOfCallSite[3].call(Integer.valueOf(1), Integer.valueOf(0));   // 1 / 0
          }
          arrayOfCallSite[2].call(Integer.valueOf(1), Integer.valueOf(0));     // 1 / 0
        }
        catch (Exception e)
        {
          return arrayOfCallSite[4].callCurrent(this, ""caughtt"");
        }
      }
      finally {}
    } else {
      try
      {
        try
        {
          try
          {
            return Boolean.valueOf(true);
          }
          finally
          {
            arrayOfCallSite[7].call(Integer.valueOf(1), Integer.valueOf(0));   // 1 / 0
          }
          arrayOfCallSite[6].call(Integer.valueOf(1), Integer.valueOf(0));    // 1 / 0
        }
        catch (Exception e)
        {
          return arrayOfCallSite[8].callCurrent(this, ""caughtt"");
        }
      }
      finally {}
    }
    return null;
  }
}

{code}

;;;","09/Feb/17 18:37;csilvers;Hmm, that looks right to me.

I tried running groovyc and then ran
{code}
java -cp "".:$GROOVY_HOME/lib/*"" bad
{code}
and got the same output, so possibly the problem is with my version of java?  Here is what it says:
{code}
% java -version
java version ""1.8.0_91""
Java(TM) SE Runtime Environment (build 1.8.0_91-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)
{code};;;","09/Feb/17 18:41;csilvers;Hmm, I tried 4 different javas:
{code}
java-1.7.0-openjdk-amd64 1071 /usr/lib/jvm/java-1.7.0-openjdk-amd64
java-1.8.0-openjdk-amd64 1069 /usr/lib/jvm/java-1.8.0-openjdk-amd64
java-8-oracle 1072 /usr/lib/jvm/java-8-oracle
java-gcj-4.8 /usr/lib/jvm/java-gcj-4.8
{code}
and they all gave the same output, so it would seem that this is behaving how java wants it to.  But it doesn't make any sense.  I'm confused.;;;","14/Feb/17 06:39;daniel_sun;SUCCEEDED:
{code}
public class TryCatchFinally {
    public static void main(String[] args) {
        try { 
            try { 
                true; 
            } finally { 
                1 / 0 
            }
        } catch (Exception e) { 
            println ""caughtt"" 
        }
    }
}
{code}

FAILED:
{code}
//public class TryCatchFinally {
    public static void main(String[] args) {
        try { 
            try { 
                true; 
            } finally { 
                1 / 0 
            }
        } catch (Exception e) { 
            println ""caughtt"" 
        }
    }
//}
{code}
;;;","15/Feb/17 08:15;daniel_sun;My test code:
{code}
    public static void main(String[] args) {
        try { 
            try { 
                System.out.println(""try!!!"");
            } finally { 
                99 / 0 
            }
        } catch (Exception e) { 
            System.out.println(""catch!!!""); 
        }
    }
{code}

*L1 has not been covered by any exception table!*

*As Jochen said, no problem with the two exception tables:*
-There are two exception tables to handle 99 / 0, one will print ""catch!!!"" but another will throw the exception:-
{code}
TRYCATCHBLOCK L3 L5 L5 java/lang/Exception
...
TRYCATCHBLOCK L3 L5 L6 null
{code}

The related bytecodes are shown as follows:
{code}
  // access flags 0x1
  public run()Ljava/lang/Object;
    TRYCATCHBLOCK L0 L1 L2 null
    TRYCATCHBLOCK L3 L4 L2 null
    TRYCATCHBLOCK L0 L1 L5 java/lang/Exception            
    TRYCATCHBLOCK L3 L5 L5 java/lang/Exception
    TRYCATCHBLOCK L0 L1 L6 null
    TRYCATCHBLOCK L3 L5 L6 null
    TRYCATCHBLOCK L5 L7 L6 null
    TRYCATCHBLOCK L8 L9 L6 null
    TRYCATCHBLOCK L10 L11 L12 null
    TRYCATCHBLOCK L13 L14 L12 null
    TRYCATCHBLOCK L10 L11 L15 java/lang/Exception      
    TRYCATCHBLOCK L13 L15 L15 java/lang/Exception
    TRYCATCHBLOCK L10 L11 L16 null
    TRYCATCHBLOCK L13 L15 L16 null
    TRYCATCHBLOCK L15 L17 L16 null
    TRYCATCHBLOCK L18 L19 L16 null
   L20
    INVOKESTATIC script1487143002698.$getCallSiteArray ()[Lorg/codehaus/groovy/runtime/callsite/CallSite;
    ASTORE 1
    INVOKESTATIC org/codehaus/groovy/runtime/BytecodeInterface8.isOrigInt ()Z
    IFEQ L0
    GETSTATIC script1487143002698.__$stMC : Z
    IFNE L0
    INVOKESTATIC org/codehaus/groovy/runtime/BytecodeInterface8.disabledStandardMetaClass ()Z
    IFNE L0
    GOTO L10
   L0
    LINENUMBER 4 L0
    ALOAD 1
    LDC 1
    AALOAD
    ALOAD 1
    LDC 2
    AALOAD
    LDC Ljava/lang/System;.class
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty (Ljava/lang/Object;)Ljava/lang/Object;
    LDC ""try!!!""
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    ASTORE 2
    NOP
   L1
    LINENUMBER 6 L1
    ALOAD 1
    LDC 3
    AALOAD
    BIPUSH 99
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    ICONST_0
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    POP
    NOP
   L3
    ALOAD 2
    ARETURN
    GOTO L4
   L4
    ALOAD 1
    LDC 4
    AALOAD
    BIPUSH 99
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    ICONST_0
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    POP
    NOP
    GOTO L21
   L2
    ASTORE 3
    ALOAD 1
    LDC 5
    AALOAD
    BIPUSH 99
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    ICONST_0
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    POP
    ALOAD 3
    ATHROW
   L21
    GOTO L22
   L5
    ASTORE 4
   L23
    LINENUMBER 9 L23
    ALOAD 1
    LDC 6
    AALOAD
    ALOAD 1
    LDC 7
    AALOAD
    LDC Ljava/lang/System;.class
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty (Ljava/lang/Object;)Ljava/lang/Object;
    LDC ""catch!!!""
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    ASTORE 5
    NOP
   L7
    NOP
   L8
    ALOAD 5
    ARETURN
    NOP
   L9
    GOTO L22
   L22
    NOP
    GOTO L24
   L6
    ASTORE 6
    ALOAD 6
    ATHROW
   L24
    GOTO L25
   L10
    LINENUMBER 4 L10
    ALOAD 1
    LDC 8
    AALOAD
    ALOAD 1
    LDC 9
    AALOAD
    LDC Ljava/lang/System;.class
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty (Ljava/lang/Object;)Ljava/lang/Object;
    LDC ""try!!!""
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    ASTORE 7
    NOP
   L11
    LINENUMBER 6 L11
    ALOAD 1
    LDC 10
    AALOAD
    BIPUSH 99
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    ICONST_0
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    POP
    NOP
   L13
    ALOAD 7
    ARETURN
    GOTO L14
   L14
    ALOAD 1
    LDC 11
    AALOAD
    BIPUSH 99
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    ICONST_0
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    POP
    NOP
    GOTO L26
   L12
    ASTORE 8
    ALOAD 1
    LDC 12
    AALOAD
    BIPUSH 99
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    ICONST_0
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    POP
    ALOAD 8
    ATHROW
   L26
    GOTO L27
   L15
    ASTORE 9
   L28
    LINENUMBER 9 L28
    ALOAD 1
    LDC 13
    AALOAD
    ALOAD 1
    LDC 14
    AALOAD
    LDC Ljava/lang/System;.class
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty (Ljava/lang/Object;)Ljava/lang/Object;
    LDC ""catch!!!""
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    ASTORE 10
    NOP
   L17
    NOP
   L18
    ALOAD 10
    ARETURN
    NOP
   L19
    GOTO L27
   L27
    NOP
    GOTO L25
   L16
    ASTORE 11
    ALOAD 11
    ATHROW
   L25
    ACONST_NULL
    ARETURN
    LOCALVARIABLE this Lscript1487143002698; L20 L25 0
    LOCALVARIABLE e Ljava/lang/Exception; L23 L9 4
    LOCALVARIABLE e Ljava/lang/Exception; L28 L19 9
    MAXSTACK = 3
    MAXLOCALS = 12

{code};;;","17/Feb/17 18:43;blackdrag;{code}
TRYCATCHBLOCK L3 L5 L5 java/lang/Exception
...
TRYCATCHBLOCK L3 L5 L6 null
{code}
one block is to catch Exception, the other to catch everything else for a rethrow or finally block. Java should produce the same. There is of course the question of the order, which I don´t remember anymore... so it might be possible the JVM wants the TRAYCATCHBLOCK instructions here in reverse order for example. That´s something to compare with Java;;;","18/Feb/17 02:57;daniel_sun;Jochen, here is the result of java compilation. Only two exception table to handle exceptions:
{code}
    TRYCATCHBLOCK L0 L1 L2 null
    TRYCATCHBLOCK L0 L3 L4 java/lang/Exception
{code}

{code}
    // Java code
    public static void main(String[] args) {
        try {
            try {
                System.out.println(""try!!!"");
            } finally {
                System.out.println(99 / 0);
            }
        } catch (Exception e) {
            System.out.println(""catch!!!"");
        }
    }
{code}

{code}
    TRYCATCHBLOCK L0 L1 L2 null
    TRYCATCHBLOCK L0 L3 L4 java/lang/Exception
   L0
    LINENUMBER 10 L0
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    LDC ""try!!!""
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
   L1
    LINENUMBER 12 L1
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    BIPUSH 99
    ICONST_0
    IDIV
    INVOKEVIRTUAL java/io/PrintStream.println (I)V
   L5
    LINENUMBER 13 L5
    GOTO L3
   L2
    LINENUMBER 12 L2
   FRAME SAME1 java/lang/Throwable
    ASTORE 1
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    BIPUSH 99
    ICONST_0
    IDIV
    INVOKEVIRTUAL java/io/PrintStream.println (I)V
    ALOAD 1
    ATHROW
   L3
    LINENUMBER 16 L3
   FRAME SAME
    GOTO L6
   L4
    LINENUMBER 14 L4
   FRAME SAME1 java/lang/Exception
    ASTORE 1
   L7
    LINENUMBER 15 L7
    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;
    LDC ""catch!!!""
    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V
   L6
    LINENUMBER 17 L6
   FRAME SAME
    RETURN
   L8
    LOCALVARIABLE e Ljava/lang/Exception; L7 L6 1
    LOCALVARIABLE args [Ljava/lang/String; L0 L8 0
    MAXSTACK = 3
    MAXLOCALS = 2
{code};;;","21/Feb/17 02:20;daniel_sun;Since L1 has not been covered by exception table, so exception occurred in the the normal excution flow can not be handled, i.e. no error in the inner try block but failed in the finally block.

I tried to add 99 / 0 to the inner try block to make it fail on purpose, then the exception can be handled properly. I guess some bug exists in StatementWriter(https://github.com/apache/groovy/blob/master/src/main/org/codehaus/groovy/classgen/asm/StatementWriter.java#L308), the range of try block seems not be recorded correctly...

{code}
    public static void main(String[] args) {
        try { 
            try { 
                System.out.println(""try!!!"");
                99 / 0 
            } finally { 
                99 / 0 
            }
        } catch (Exception e) { 
            System.out.println(""catch!!!""); 
        }
    }
{code};;;","22/Feb/17 08:51;daniel_sun;{code}
// test code
            try {
                try {
                    System.out.println(""try!!!"");
                } finally {
                    System.out.println(99 / 0);
                }
            } catch (Exception e) {
                System.out.println(""catch!!!"");
            }
{code}

https://github.com/apache/groovy/blob/master/src/main/org/codehaus/groovy/classgen/asm/StatementWriter.java#L584
Generating bytecodes for ReturnStatement( i.e. return System.out.println(""try!!!"") ) will record ranges of blocks, the range of the outer block is not recorded correctly(not cover the finally block in the normal execution flow).

https://github.com/apache/groovy/blob/master/src/main/org/codehaus/groovy/classgen/asm/CompileStack.java#L770
{code}
    private void applyBlockRecorder(List<BlockRecorder> blocks) {
        if (blocks.isEmpty() || blocks.size()==visitedBlocks.size()) return;

        MethodVisitor mv = controller.getMethodVisitor();

        Label end = new Label();
        mv.visitInsn(NOP);
        mv.visitLabel(end);
        Label newStart = new Label();

        for (BlockRecorder fb : blocks) {
            if (visitedBlocks.contains(fb)) continue;

            fb.closeRange(end);

            // we exclude the finally block from the exception table
            // here to avoid double visiting of finally statements
            fb.excludedStatement.run();

            fb.startRange(newStart);
        }

        mv.visitInsn(NOP);
        mv.visitLabel(newStart);
    }
{code}

The following bytecodes have not been covered by any exception table!
{code}
   L9
    LINENUMBER 6 L9
    ALOAD 1
    LDC 3
    AALOAD
    ALOAD 1
    LDC 4
    AALOAD
    LDC Ljava/lang/System;.class
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty (Ljava/lang/Object;)Ljava/lang/Object;
    ALOAD 1
    LDC 5
    AALOAD
    BIPUSH 99
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    ICONST_0
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    POP
{code}

*logs( https://github.com/apache/groovy/pull/503 ):*
{code}
   L3
    LINENUMBER 2 L3
   L4
   L5
    LINENUMBER 3 L5
   L6
   L7
    LINENUMBER 4 L7
    ALOAD 1
    LDC 1
    AALOAD
    ALOAD 1
    LDC 2
    AALOAD
    LDC Ljava/lang/System;.class
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty (Ljava/lang/Object;)Ljava/lang/Object;
    LDC ""try!!!""
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    ASTORE 2
    NOP
   L8
   L9
    LINENUMBER 6 L9
    ALOAD 1
    LDC 3
    AALOAD
    ALOAD 1
    LDC 4
    AALOAD
    LDC Ljava/lang/System;.class
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty (Ljava/lang/Object;)Ljava/lang/Object;
    ALOAD 1
    LDC 5
    AALOAD
    BIPUSH 99
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    ICONST_0
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    POP
   L10
   L11
    NOP
   L12
    ALOAD 2
    ARETURN
   L13
    GOTO L14
   L15
   L16
    TRYCATCHBLOCK L6 L8 L17 null
    TRYCATCHBLOCK L12 L15 L17 null
   L18
   L14
    ALOAD 1
    LDC 6
    AALOAD
    ALOAD 1
    LDC 7
    AALOAD
    LDC Ljava/lang/System;.class
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty (Ljava/lang/Object;)Ljava/lang/Object;
    ALOAD 1
    LDC 8
    AALOAD
    BIPUSH 99
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    ICONST_0
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    POP
   L19
   L20
    NOP
    GOTO L21
   L17
    ASTORE 3
    ALOAD 1
    LDC 9
    AALOAD
    ALOAD 1
    LDC 10
    AALOAD
    LDC Ljava/lang/System;.class
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty (Ljava/lang/Object;)Ljava/lang/Object;
    ALOAD 1
    LDC 11
    AALOAD
    BIPUSH 99
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    ICONST_0
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    POP
   L22
   L23
    ALOAD 3
    ATHROW
   L21
   L24
    GOTO L25
   L26
   L27
   L28
    ASTORE 4
   L29
   L30
    LINENUMBER 9 L30
    ALOAD 1
    LDC 12
    AALOAD
    ALOAD 1
    LDC 13
    AALOAD
    LDC Ljava/lang/System;.class
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.callGetProperty (Ljava/lang/Object;)Ljava/lang/Object;
    LDC ""catch!!!""
    INVOKEINTERFACE org/codehaus/groovy/runtime/callsite/CallSite.call (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
    ASTORE 5
    NOP
   L31
    NOP
   L32
    ALOAD 5
    ARETURN
   L33
    NOP
   L34
   L35
    GOTO L25
    TRYCATCHBLOCK L4 L8 L28 java/lang/Exception
    TRYCATCHBLOCK L12 L26 L28 java/lang/Exception
    TRYCATCHBLOCK L4 L8 L36 null
    TRYCATCHBLOCK L12 L26 L36 null
    TRYCATCHBLOCK L28 L31 L36 null
    TRYCATCHBLOCK L32 L35 L36 null
   L37
   L25
    NOP
    GOTO L38
   L36
    ASTORE 6
    ALOAD 6
    ATHROW
   L38

{code};;;","22/Feb/17 12:12;daniel_sun;We should avoid double visiting of finally statements *conditionally*!

https://github.com/apache/groovy/blob/master/src/main/org/codehaus/groovy/classgen/asm/CompileStack.java#L787
{code}
            // we exclude the finally block from the exception table
            // here to avoid double visiting of finally statements
            fb.excludedStatement.run();
{code};;;","24/Feb/17 03:08;daniel_sun;We can investigate the related commit and try to find how to fix the issue.
https://github.com/apache/groovy/commit/5a7ee2cbbad373cec928c15810989308fa6b6225;;;","24/Feb/17 08:43;daniel_sun;I am trying to fix it: https://github.com/danielsun1106/groovy/commit/0b64cc2fb1c7605fbadefb3166c75d6f97d5a77f
;;;","24/Feb/17 10:08;githubbot;GitHub user danielsun1106 opened a pull request:

    https://github.com/apache/groovy/pull/504

    GROOVY-8085: Exception in ""finally"" not caught by outer ""try""

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/danielsun1106/groovy GROOVY-8085

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/504.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #504
    
----
commit 0b64cc2fb1c7605fbadefb3166c75d6f97d5a77f
Author: Daniel Sun <realbluesun@hotmail.com>
Date:   2017-02-24T08:39:59Z

    GROOVY-8085: Exception in ""finally"" not caught by outer ""try""

----
;;;","24/Feb/17 16:35;daniel_sun;*The issue can be decribled accurately as follows:*
If the inner try block contains return statement(no matter whether explicit return or not) and the inner finally block throws exceptions, the outer try block can not catch it. e.g.
{code}
try {
   try {
      ...
      return ... // no matter whether explicit return or not
   } finally {
      ... // some exception(e.g. exceptionX) is thrown
   }
} catch (Throwable t) { // the exceptionX can not be caught
      ... 
}
{code}

If developers' test cases have not covered the senario for their system, which may give them a *surprise* in the production environment.;;;","27/Feb/17 01:10;githubbot;Github user danielsun1106 closed the pull request at:

    https://github.com/apache/groovy/pull/504
;;;","27/Feb/17 14:33;paulk;Merged onto the 2_4_X branch.;;;","27/Feb/17 20:58;csilvers;Thanks Daniel for tracking this down so assiduously and fixing it!

Are there any workarounds I could use for environments that don't have the fix in it yet?  Some way to restructure the code so it doesn't trigger this bug?

The one I can think of is make sure that nothing inside the inner try/except tries to return anything.  That should be enough to avoid problems, is that right?  (The problem is I'm not sure how to avoid implicit return's in all contexts.)  Is there any other thing I can do?;;;","27/Feb/17 21:53;jwagenleitner;I think one workaround if you are able to restructure the code would be to avoid nesting {{try}} blocks and extract the inner blocks into a method.  The problem seemed to have stemmed from having to process more than one finally block.

{code}
def divideByZero() {
    try { 
        true; 
    } finally { 
        1 / 0 
    }
}

try { 
    divideByZero()
} catch (Exception e) { 
    println ""caughtt"" 
}
{code};;;","27/Feb/17 21:57;csilvers;Awesome, thank you! -- that shouldn't be that hard.;;;","27/Feb/17 23:54;daniel_sun;Beside John's suggestion, I provide you another(*Notice:* no finally block in the outer try-catch statement. If it contains a finally block and may throw exceptions, we will face same issue...):

{code}
try {
   def returnValue
   try {
      ...
      returnValue = ... 
   } finally {
      ... // some exception(e.g. exceptionX) is thrown
   }

   return returnValue;
} catch (Throwable t) { // the exceptionX can be caught
      ... 
}
{code};;;",,
Captured types doesn't work in @CompileStatic,GROOVY-8084,13041337,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,Alexey Afanasiev,Alexey Afanasiev,08/Feb/17 10:06,13/Dec/18 10:05,14/Jul/23 06:02,24/Aug/18 19:57,2.4.8,,,,,,,,2.5.3,3.0.0-alpha-4,,,Static compilation,Static Type Checker,,,0,,,,,,,"This code could be successfully compiled and executed. 
{code}
@CompileStatic
static def method(List<? extends Serializable> captured) {
    captured.add('some string')
    return captured
}

println method(new ArrayList<Integer>())
{code}

Looks like type check in groovy doesn't work with captured types. Is it a bug?

Is there any documentation about generics in groovy? 

P.S.:
Another kind of strange behaviour:
{code}
@CompileStatic
static def method() {
    List<Integer> list = new ArrayList<>()
    List<? extends Serializable> captured = list
    captured.add('some string') //Error:(7, 5) Groovyc: [Static type checking] - Cannot call java.util.ArrayList <java.lang.Integer>#add(java.lang.Integer) with arguments [java.lang.String]
    return captured
}
{code}
Somehow type checking infered type of 'captured' variable to  java.util.ArrayList <java.lang.Integer> ",,Alexey Afanasiev,daniel_sun,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 27 12:59:13 UTC 2018,,,,,,,,,,"0|i39s8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Aug/18 19:57;daniel_sun;It is fixed now.
https://github.com/apache/groovy/commit/45b62af010453f1e2147c8bbbc519b1856d07fe6

As a side note, adding an element to a producer is not allowed in Java, so we should refine STC further;;;","27/Aug/18 09:24;Alexey Afanasiev;Glad to see that work on type inference and generics is continuing!;;;","27/Aug/18 11:53;daniel_sun;We have fixed quite a few STC issues on 2.5 branch, but the fixes are not merged into 2.4 branch(hard to complete), so upgrading to 2.5 is strongly recommened 😊;;;","27/Aug/18 12:59;paulk;And still quite a few more to tackle - we'll just keep making progress.;;;",,,,,,,,,,,,,,,,,,
Groovy sql.rows returns org.postgresql.util.PSQLException: No hstore extension installed,GROOVY-8082,13041240,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,clessiomendes,clessiomendes,08/Feb/17 02:09,28/Mar/17 02:54,14/Jul/23 06:02,16/Feb/17 03:37,2.4.4,,,,,,,,2.4.9,,,,SQL processing,,,,0,,,,,,,"-> Steps to Reproduce

1) create a simple sql string with no where clause
2) pass an empty Map [:] as params to groovySql.rows(sql, params)

PS: (as workargound, passing an empty List, instead of an empty map, as params behaves like expected)

-> Expected Behaviour

call postgres and run the sql passing no parameters

-> Actual Behaviour

Exception raised: No hstore extension installed.. Stacktrace follows:
org.postgresql.util.PSQLException: No hstore extension installed.
at org.postgresql.jdbc2.AbstractJdbc2Statement.setMap(AbstractJdbc2Statement.java:1707)
at org.postgresql.jdbc2.AbstractJdbc2Statement.setObject(AbstractJdbc2Statement.java:1910)
at org.postgresql.jdbc3g.AbstractJdbc3gStatement.setObject(AbstractJdbc3gStatement.java:36)
at org.postgresql.jdbc4.AbstractJdbc4Statement.setObject(AbstractJdbc4Statement.java:47)

-> Environment Information

    Operating System: Windows
    Grails Version: 2.5.4
    JDK Version: 1.7
    Container Version (If Applicable): N/A
    Database: Postgres 9.3.13

-> Probable fix

Method singletonList(Object item) at groovy.sql.SQL

-> More information

http://stackoverflow.com/q/39245870/1916198",,clessiomendes,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8128,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 28 02:54:14 UTC 2017,,,,,,,,,,"0|i39rnb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Feb/17 13:02;paulk;The Sql api doesn't have a {{rows(String, Map)}} variant. Do any of these work:
{code}
groovySql.rows(sql, *:params)
groovySql.rows(params, sql)
groovySql.rows(sql, [params])
{code}
Actually, I just tried them and there doesn't seem to be a useful workaround apart from the empty list as you suggest or perhaps more intuitively:
{code}
def result = params ? groovySql.rows(sql, params) : groovySql.rows(sql)
{code};;;","10/Feb/17 06:48;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/495

    GROOVY-8082: Groovy sql.rows returns org.postgresql.util.PSQLExceptio…

    …n: No hstore extension installed

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8082

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/495.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #495
    
----
commit b34b47623d18372241f0d5242bb780963c0278ab
Author: paulk <paulk@asert.com.au>
Date:   2017-02-10T06:46:33Z

    GROOVY-8082: Groovy sql.rows returns org.postgresql.util.PSQLException: No hstore extension installed

----
;;;","10/Feb/17 06:51;paulk;You could argue that this isn't a bug but a misuse of the api. However, having said that, the error message when you supply the empty map is quite misleading, so the proposed PR looks for the special case of an empty supplied map when no parameter placeholders are found in the sql. It is then equivalent to calling with the empty list.;;;","16/Feb/17 03:34;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/495
;;;","16/Feb/17 03:37;paulk;Proposed PR merged. From 2.4.9, you can now supply an empty map if you want to - provided you have no placeholders you are trying to fill of course.;;;","28/Mar/17 02:54;paulk;Just an update that from 2.4.11, if you have a complex query (or multiline query in some cases it seems) whereby your driver can't determine parameter metadata, then you might not be able to supply an empty map of params and instead have to use the previously mentioned workaround. This only seems to apply to some drivers, so you'll need to try this yourself. You'll see some Groovy debug output at the FINE level if you are affected.;;;",,,,,,,,,,,,,,,,
@CompileStatic class property accessed instead of map property,GROOVY-8074,13040705,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,daniilo,daniilo,06/Feb/17 18:15,11/Sep/22 14:10,14/Jul/23 06:02,11/May/17 15:49,2.4.8,,,,,,,,2.4.12,,,,Static compilation,,,,0,,,,,,,"{code}
class MyMap extends LinkedHashMap {
  def foo = 1
}

@CompileStatic
class Main {
  static void main(String[] args) {
    def map = new MyMap()
    map.put('foo', 42)
    println map.foo // 1 is printed, should be 42
  }
}
{code}",,daniilo,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5001,,GROOVY-10540,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 12 03:56:50 UTC 2017,,,,,,,,,,"0|i39ocf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/May/17 18:48;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/539

    GROOVY-8074: Statically compiled dot property accesses instance prope…

    …rty instead of Map property

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-8074

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/539.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #539
    
----
commit abff6c7bf8a953f8f41d4f5080004c436757cb7e
Author: Shil Sinha <shils@apache.org>
Date:   2017-05-07T18:47:19Z

    GROOVY-8074: Statically compiled dot property accesses instance property instead of Map property

----
;;;","10/May/17 21:54;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/539#discussion_r115862393
  
    --- Diff: src/test/org/codehaus/groovy/classgen/asm/sc/ArraysAndCollectionsStaticCompileTest.groovy ---
    @@ -128,6 +128,18 @@ class ArraysAndCollectionsStaticCompileTest extends ArraysAndCollectionsSTCTest
             }
         }
     
    +    void testMapSubclassPropertyStyleAccess() {
    --- End diff --
    
    maybe add in:
    `// GROOVY-8074`
;;;","11/May/17 06:07;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/539
;;;","12/May/17 03:56;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/539#discussion_r116149015
  
    --- Diff: src/test/org/codehaus/groovy/classgen/asm/sc/ArraysAndCollectionsStaticCompileTest.groovy ---
    @@ -128,6 +128,18 @@ class ArraysAndCollectionsStaticCompileTest extends ArraysAndCollectionsSTCTest
             }
         }
     
    +    void testMapSubclassPropertyStyleAccess() {
    --- End diff --
    
    Added, thanks for the reminder.
;;;",,,,,,,,,,,,,,,,,,
Map delegate within @CompileStatic,GROOVY-8073,13040702,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,daniilo,daniilo,06/Feb/17 18:07,21/Feb/19 06:18,14/Jul/23 06:02,22/Jan/19 04:45,2.4.8,,,,,,,,2.5.6,3.0.0-beta-1,,,Static compilation,,,,0,,,,,,,"{code}
@CompileStatic
class Main {
  static void main(String[] args) {
    def map = [a: 1, b: 2]
    map.with { // Exception in thread ""main"" java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to groovy.lang.GroovyObject
      println a
    }
  }
}
{code}",,daniilo,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Jan 22 04:45:32 UTC 2019,,,,,,,,,,"0|i39obr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jan/19 04:45;paulk;I believe this was fixed as part of GROOVY-7996.;;;",,,,,,,,,,,,,,,,,,,,,
AstBrowser source view does not generate labels for statements,GROOVY-8072,13040480,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,jwagenleitner,jwagenleitner,jwagenleitner,05/Feb/17 17:35,02/May/17 02:03,14/Jul/23 06:02,12/Feb/17 22:19,2.4.8,,,,,,,,2.5.0-alpha-1,,,,Groovy Console,,,,0,,,,,,,Labels for labeled statements are not displayed in the source view of AstBrowser.,,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Feb 12 22:19:11 UTC 2017,,,,,,,,,,"0|i39myn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Feb/17 17:45;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/490

    GROOVY-8072: AstBrowser source view does not generate labels for stat…

    …ements

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy groovy8072

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/490.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #490
    
----
commit 757db0c9e69c237a6416e6ddff1d81a20818fd23
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-02-05T17:37:06Z

    GROOVY-8072: AstBrowser source view does not generate labels for statements

----
;;;","12/Feb/17 22:19;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/490
;;;",,,,,,,,,,,,,,,,,,,,
Annotation based logging of complex expression in closure throws GroovyCastException when statically compiled,GROOVY-8069,13039755,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,02/Feb/17 06:34,08/Mar/17 08:17,14/Jul/23 06:02,02/Feb/17 14:35,2.4.8,,,,,,,,2.4.9,,,,Static compilation,,,,0,,,,,,,"Example:
{code}
@groovy.util.logging.Log
@groovy.transform.CompileStatic
class Foo {
    void bar() {
        def callable = {
            log.info('a' + 1)
        }
        callable.call()
    }
}
new Foo().bar()
{code}

The log statement in the code above results in the following runtime exception:

{code}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'Foo@14ec4505' with class 'Foo' to class 'java.util.logging.Logger'
{code}

The case where the closure is in a static method is similar; the object being cast to a Logger is a Class instead. 

This appears to be due to the implicitThis field being set incorrectly on the guard method call expression (log.isLoggable(Level) in the default case) created in implementations of LoggingStrategy.wrapLoggingMethodCall.
 
Prior to Groovy 2.4.8, log statements inside closures were not guarded (https://issues.apache.org/jira/browse/GROOVY-6932), so this bug wasn't visible. ",,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 02 14:05:45 UTC 2017,,,,,,,,,,"0|i39ijz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Feb/17 07:05;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/487

    GROOVY-8069: Annotation based logging of complex expression in closur…

    …e throws GroovyCastException with SC.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-8069

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/487.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #487
    
----
commit e0be19e84308100e1a9b60a44c6458d33b071d84
Author: Shil Sinha <shils@apache.org>
Date:   2017-02-02T06:48:01Z

    GROOVY-8069: Annotation based logging of complex expression in closure throws GroovyCastException with SC

----
;;;","02/Feb/17 14:05;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/487
;;;",,,,,,,,,,,,,,,,,,,,
improper logging in groovy.sql.Sql,GROOVY-8068,13039509,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,limpus2,limpus2,01/Feb/17 16:21,08/Mar/17 08:17,14/Jul/23 06:02,07/Feb/17 22:47,2.4.8,,,,,,,,2.4.9,,,,groovy-runtime,,,,0,,,,,,,"In groovy.sql.Sql.newInstance(Map<String, Object>), there are two System.err.println() statements left. One of these prints the password of the connection to be created among other info. Convert these statements to proper log output.",groovy-all-2.4.8-indy.jar,githubbot,jwagenleitner,limpus2,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 07 22:47:16 UTC 2017,,,,,,,,,,"0|i39h1b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Feb/17 08:31;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/491

    GROOVY-8068: improper logging in groovy.sql.Sql

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8068

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/491.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #491
    
----
commit 278e07a9cce53bc031e2ef2a40b96d6a94669bb6
Author: paulk <paulk@asert.com.au>
Date:   2017-02-07T08:31:02Z

    GROOVY-8068: improper logging in groovy.sql.Sql

----
;;;","07/Feb/17 15:18;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/491#discussion_r99844410
  
    --- Diff: subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java ---
    @@ -578,17 +578,26 @@ public static Sql newInstance(Map<String, Object> args) throws SQLException, Cla
     
             Object url = sqlArgs.remove(""url"");
             Connection connection;
    +        LOG.fine(""url = "" + url);
             if (props != null) {
    -            System.err.println(""url = "" + url);
    -            System.err.println(""props = "" + props);
    -            connection = DriverManager.getConnection(url.toString(), new Properties(props));
    +            Properties propsCopy = new Properties(props);
    +            connection = DriverManager.getConnection(url.toString(), propsCopy);
    +            if (propsCopy.containsKey(""password"")) {
    +                // don't log the password
    +                propsCopy = new Properties(propsCopy);
    --- End diff --
    
    I don't think this is needed since it's already been copied?
;;;","07/Feb/17 21:04;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/491#discussion_r99928551
  
    --- Diff: subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java ---
    @@ -578,17 +578,26 @@ public static Sql newInstance(Map<String, Object> args) throws SQLException, Cla
     
             Object url = sqlArgs.remove(""url"");
             Connection connection;
    +        LOG.fine(""url = "" + url);
             if (props != null) {
    -            System.err.println(""url = "" + url);
    -            System.err.println(""props = "" + props);
    -            connection = DriverManager.getConnection(url.toString(), new Properties(props));
    +            Properties propsCopy = new Properties(props);
    +            connection = DriverManager.getConnection(url.toString(), propsCopy);
    +            if (propsCopy.containsKey(""password"")) {
    +                // don't log the password
    +                propsCopy = new Properties(propsCopy);
    --- End diff --
    
    It is certainly conservative code. I didn't want the password appearing in logging and I didn't know whether any drivers out there might hold onto the properties object and re-use it when e.g. growing a connection pool or something.
;;;","07/Feb/17 22:25;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/491#discussion_r99946115
  
    --- Diff: subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java ---
    @@ -578,17 +578,26 @@ public static Sql newInstance(Map<String, Object> args) throws SQLException, Cla
     
             Object url = sqlArgs.remove(""url"");
             Connection connection;
    +        LOG.fine(""url = "" + url);
             if (props != null) {
    -            System.err.println(""url = "" + url);
    -            System.err.println(""props = "" + props);
    -            connection = DriverManager.getConnection(url.toString(), new Properties(props));
    +            Properties propsCopy = new Properties(props);
    +            connection = DriverManager.getConnection(url.toString(), propsCopy);
    +            if (propsCopy.containsKey(""password"")) {
    +                // don't log the password
    +                propsCopy = new Properties(propsCopy);
    --- End diff --
    
    That makes sense, I missed that the copy was passed to the DriverManager.  Sorry for the noise.
;;;","07/Feb/17 22:45;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/491
;;;","07/Feb/17 22:47;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,
Possible deadlock when creating new ClassInfo entries in the cache,GROOVY-8067,13038776,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,jwagenleitner,jwagenleitner,jwagenleitner,29/Jan/17 17:21,15/Jul/17 19:13,14/Jul/23 06:02,12/Feb/17 19:28,2.4.8,,,,,,,,2.4.9,,,,groovy-runtime,,,,1,,,,,,,"When running Groovy without {{-Dgroovy.use.classvalue=true}} the ClassInfo instances are cached in a {{ManagedConcurrentMap}} (MCM).  New values are computed on demand and computation involves both a lock on a segment within the MCM and a lock on the {{GlobalClassSet}} (GCS) which is backed by a {{ManagedLinkedList}}.  The problem is that both the ManagedConcurrentMap and the GlobalClassSet share the same ReferenceQueue.

Assume there is an enqueued {{ClassInfo}} value that is stored in Segment2 of the MCM.  Now assume that Thread1 and Thread2 both request {{ClassInfo.getClassInfo(..)}} for two different classes that do not currently exist in the cache.  Assume that based on hashing Thread1 gets a lock on Segment1 and Thread2 gets a lock on Segment2.  Assume that Thread1 is the first to call computeValue which in turn calls {{GlobalClassSet.add(..)}}.  This call adds a new value to a {{ManagedLinkedList}}, and since it's managed the add operation will process the ReferenceQueue. So Thread1 will attempt to dequeue the ClassInfo and the finalizeReference method on it's entry will attempt to remove it from Segment2. Thread2 holds the lock for Segment2 and Thread2 is blocked and can't progress it's waiting on the the lock Thread1 holds the lock for the GlobalClassSet, so deadlock occurs.

The attached test case includes a thread dump at the bottom.",,githubbot,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8092,,,,,,"29/Jan/17 17:21;jwagenleitner;ClassInfoDeadlockTest.java;https://issues.apache.org/jira/secure/attachment/12849880/ClassInfoDeadlockTest.java",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 15 19:13:25 UTC 2017,,,,,,,,,,"0|i39cjj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jan/17 17:59;jwagenleitner;This should only affect Groovy 2.4.8 and a possible workaround if using Java 7+ would be to run with {{-Dgroovy.use.classvalue=true}}.;;;","29/Jan/17 19:47;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/484

    GROOVY-8067: Possible deadlock when creating new ClassInfo entries in the cache

    While I have been able to replicate the deadlock between `GroovyClassValuePreJava7$Segment` and the `GlobalClassSet#add`, I have not directly observed one between the `modifiedExpandos` and the `GlobalClassSet`, but think that it would be good to isolate their reference processing too since both lock in their operations.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy groovy8067

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/484.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #484
    
----
commit 78f5aa0b5977919ba05dcad9fe8a7ee496abf2e8
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-01-29T18:26:43Z

    GROOVY-8067: test for demo only (DO NOT COMMIT)

commit 58a27e7b1c437d436636658a5de9537fda5560d6
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-01-29T19:34:55Z

    GROOVY-8067: Possible deadlock when creating new ClassInfo entries in the cache

----
;;;","05/Feb/17 07:05;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/489

    GROOVY-8067: Possible deadlock when creating new ClassInfo entries in the cache

    As suggested in PR #484 removed the locking on the `ManagedLinkedList` by creating a new `ManagedConcurrentLinkedQueue`.
    
    Also added a `stress` subproject for tests that employ many threads, need GC, or just in general try to break things and take a long time.  These require a special property to be set in order to run, otherwise they will be skipped.  I tried to work it out in the `performance` subproject, but that seems to be very specialized for the compiler tests.  Open to suggestions on a better way to handle these types of tests.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy groovy8067-mclq

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/489.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #489
    
----
commit bb2464a919a3655f36707fa72fb30080c92a7288
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-02-05T06:13:26Z

    GROOVY-8067: Possible deadlock when creating new ClassInfo entries in the cache

----
;;;","05/Feb/17 07:07;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/489#discussion_r99482851
  
    --- Diff: src/main/org/codehaus/groovy/reflection/ClassInfo.java ---
    @@ -186,30 +185,20 @@ public void setStrongMetaClass(MetaClass answer) {
             MetaClass strongRef = strongMetaClass;
             
             if (strongRef instanceof ExpandoMetaClass) {
    -          ((ExpandoMetaClass)strongRef).inRegistry = false;
    -          synchronized(modifiedExpandos){
    -            for (Iterator<ClassInfo> it = modifiedExpandos.iterator(); it.hasNext(); ) {
    -              ClassInfo info = it.next();
    -              if(info == this){
    -                it.remove();
    -              }
    +            ((ExpandoMetaClass)strongRef).inRegistry = false;
    +            for (Iterator<ClassInfo> itr = modifiedExpandos.iterator(); itr.hasNext(); ) {
    +                ClassInfo info = itr.next();
    +                if(info == this) {
    +                    itr.remove();
    +                }
                 }
    -          }
             }
     
             strongMetaClass = answer;
     
             if (answer instanceof ExpandoMetaClass) {
    -          ((ExpandoMetaClass)answer).inRegistry = true;
    -          synchronized(modifiedExpandos){
    -            for (Iterator<ClassInfo> it = modifiedExpandos.iterator(); it.hasNext(); ) {
    -              ClassInfo info = it.next();
    -                if(info == this){
    -                  it.remove();
    -                }
    -             }
    -             modifiedExpandos.add(this);
    -          }
    --- End diff --
    
    Removed because it appeared to be a duplicate of the logic above.  Only if the previous previous `strongMetaClass` value was an expando would it have been added to the map, so the iteration/removal above should have taken care to remove this `ClassInfo` from the `modifiedExpandos` and there's no reason to iterate again.
;;;","07/Feb/17 20:42;githubbot;Github user jwagenleitner closed the pull request at:

    https://github.com/apache/groovy/pull/484
;;;","08/Feb/17 20:35;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/489#discussion_r100162935
  
    --- Diff: subprojects/stress/src/test/java/org/codehaus/groovy/reflection/ClassInfoDeadlockStressTest.java ---
    @@ -0,0 +1,140 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.codehaus.groovy.reflection;
    +
    +import groovy.lang.GroovyClassLoader;
    +
    +import java.util.concurrent.CountDownLatch;
    +import java.util.concurrent.TimeUnit;
    +import java.util.concurrent.atomic.AtomicInteger;
    +
    +import org.apache.groovy.stress.util.GCUtils;
    +import org.junit.Test;
    +import static org.junit.Assert.*;
    +
    +/**
    + * Tests for deadlocks in the ClassInfo caching.
    + *
    + */
    +public class ClassInfoDeadlockStressTest {
    +
    +    private static final int DEADLOCK_TRIES = 8;
    +    private static final int THREAD_COUNT = 8;
    +
    +    private final CountDownLatch startLatch = new CountDownLatch(1);
    +    private final CountDownLatch completeLatch = new CountDownLatch(THREAD_COUNT);
    +    private final GroovyClassLoader gcl = new GroovyClassLoader();
    +    private final AtomicInteger counter = new AtomicInteger();
    +
    +    /**
    +     * We first generate a large number of ClassInfo instances for classes
    +     * that are no longer reachable.  Then queue up threads to all request
    +     * ClassInfo instances for new classes simultaneously to ensure that
    +     * clearing the old references wont deadlock the creation of new
    +     * instances.
    +     * <p>
    +     * GROOVY-8067
    +     */
    +    @Test
    +    public void testDeadlock() throws Exception {
    +        for (int i = 1; i <= DEADLOCK_TRIES; i++) {
    +            System.out.println(""Test Number: "" + i);
    +            generateGarbage();
    +            GCUtils.gc();
    +            attemptDeadlock(null);
    +        }
    +    }
    +
    +    @Test
    +    public void testRequestsForSameClassInfo() throws Exception {
    +        Class<?> newClass = createRandomClass();
    +        for (int i = 1; i <= DEADLOCK_TRIES; i++) {
    +            System.out.println(""Test Number: "" + i);
    +            generateGarbage();
    +            GCUtils.gc();
    +            attemptDeadlock(newClass);
    +        }
    +        ClassInfo newClassInfo = ClassInfo.getClassInfo(newClass);
    +        for (ClassInfo ci : ClassInfo.getAllClassInfo()) {
    +            if (ci.getTheClass() == newClass && ci != newClassInfo) {
    +                fail(""Found multiple ClassInfo instances for class"");
    +            }
    +        }
    +    }
    +
    +    private void attemptDeadlock(final Class<?> cls) throws Exception {
    +        for (int i = 0; i < THREAD_COUNT; i++) {
    +            Runnable runnable = new Runnable() {
    +                @Override
    +                public void run() {
    +                    Class<?> newClass = (cls == null) ? createRandomClass() : cls;
    +                    try {
    +                        startLatch.await();
    +                    } catch (InterruptedException ie) {
    --- End diff --
    
    can use `ThreadUtils.awaite()`
;;;","08/Feb/17 20:35;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/489#discussion_r100162813
  
    --- Diff: src/main/org/codehaus/groovy/util/ManagedConcurrentLinkedQueue.java ---
    @@ -0,0 +1,187 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.codehaus.groovy.util;
    +
    +import java.util.ArrayList;
    +import java.util.Collections;
    +import java.util.Iterator;
    +import java.util.List;
    +import java.util.NoSuchElementException;
    +import java.util.concurrent.ConcurrentLinkedQueue;
    +
    +/**
    + * A queue that stores the values wrapped in a Reference, the type of which is
    + * determined by the provided {@link ReferenceBundle}.  Values stored in this queue
    + * that are put on the {@code ReferenceQueue} will be removed from the list when
    + * reference processing for the {@code ReferenceQueue} is done.
    + *
    + * This queue is backed by a {@link ConcurrentLinkedQueue} and is thread safe.  The
    + * iterator will only return non-null values (reachable) and is based on the
    + * ""weakly consistent"" iterator of the underlying {@link ConcurrentLinkedQueue}.
    + *
    + * @param <T> the type of values to store
    + */
    +public class ManagedConcurrentLinkedQueue<T> implements Iterable<T> {
    +
    +    private final ReferenceBundle bundle;
    +    private final ConcurrentLinkedQueue<Element<T>> queue;
    +
    +    /**
    +     * Creates an empty ManagedConcurrentLinkedQueue that will use the given
    +     * {@code ReferenceBundle} to store values as the given Reference
    +     * type.
    +     *
    +     * @param bundle used to create the appropriate Reference type
    +     *               for the values stored
    +     */
    +    public ManagedConcurrentLinkedQueue(ReferenceBundle bundle) {
    +        this.bundle = bundle;
    +        this.queue = new ConcurrentLinkedQueue<Element<T>>();
    +    }
    +
    +    /**
    +     * Adds the specified value to the queue.
    +     *
    +     * @param value the value to add
    +     */
    +    public void add(T value) {
    +        Element<T> e = new Element<T>(value);
    +        queue.offer(e);
    +    }
    +
    +    /**
    +     * Returns {@code true} if this queue contains no elements.
    +     * <p>
    +     * This method does not check the elements to verify they contain
    +     * non-null reference values.
    +     */
    +    public boolean isEmpty() {
    +        return queue.isEmpty();
    +    }
    +
    +    /**
    +     * Returns an array containing all values from this queue in the sequence they
    +     * were added.
    +     *
    +     * @param tArray the array to populate if big enough, else a new array with
    +     *               the same runtime type
    +     * @return an array containing all non-null values in this queue
    +     */
    +    public T[] toArray(T[] tArray) {
    +        return values().toArray(tArray);
    +    }
    +
    +    /**
    +     * Returns an unmodifiable list containing all values from this queue in the
    +     * sequence they were added.
    +     */
    +    public List<T> values() {
    +        Iterator<T> itr = iterator();
    +        if (!itr.hasNext()) {
    +            return Collections.emptyList();
    +        }
    +        List<T> result = new ArrayList<T>(100);
    +        result.add(itr.next());
    +        while (itr.hasNext()) {
    +            result.add(itr.next());
    +        }
    +        return Collections.unmodifiableList(result);
    +    }
    +
    +    /**
    +     * Returns an iterator over all non-null values in this queue.  The values should be
    +     * returned in the order they were added.
    +     */
    +    @Override
    +    public Iterator<T> iterator() {
    +        return new Iter(queue.iterator());
    +    }
    +
    +    private final class Element<V> extends ManagedReference<V> {
    +
    +        Element(V value) {
    +            super(bundle, value);
    +        }
    +
    +        @Override
    +        public void finalizeReference() {
    +            queue.remove(this);
    +            super.finalizeReference();
    +        }
    +
    +    }
    +
    +    private final class Iter implements Iterator<T> {
    --- End diff --
    
    think this can be made a static nested class
;;;","11/Feb/17 17:00;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/489
;;;","12/Jul/17 21:55;paulk;Git bisect points to the respective commit for this issue for the below Grails plugin issue:

https://github.com/grails/grails-core/issues/10715

I haven't fully investigated and don't have a standalone reproducer yet. I'll raise a separate issue when I find something conclusive.
;;;","15/Jul/17 17:42;jwagenleitner;It looks like the issue might be related to the {{ManagedLinkedList}} (MLL) iterator vs the {{ManagedConcurrentLinkedQueue}} (MCLQ) iterator.  The MLL {{iterator#remove}} method seems to not correctly relink the list (head, tail).

{code}
import org.codehaus.groovy.util.*

mml = new ManagedLinkedList<String>(ReferenceBundle.getHardBundle())
//mml = new ManagedConcurrentLinkedQueue<String>(ReferenceBundle.getHardBundle())
mml.add('foo')
mml.add('bar')
mml.add('baz')

for (Iterator<String> itr = mml.iterator(); itr.hasNext(); ) {
    String s = itr.next()
    println s
    itr.remove()
}
{code}

Output from MLL:

{code}
foo
{code}

Output from MCLQ:

{code}
foo
bar
baz
{code}

So with the old code using MLL any calls to {{clearModifiedExpandos}} would always only remove the first one.

The [call to ExpandoMetaClass.enableGlobally in the grails-melody-plugin|https://github.com/javamelody/grails-melody-plugin/blob/4da5c1e7092f7841e6133fd790baa0419340a6ad/src/main/groovy/grails/melody/plugin/MelodyInterceptorEnhancer.groovy#L32] triggers a call to {{clearModifiedExpandos}}.  By this time Grails core has already added the {{encode}} methods.  The old code just by luck would not remove the modified expandos (and more importantly is the call to {{setStrongMetaClass(null)}}) but the new MCLQ really does clear all modified expandos.

Assuming that's the problem, not sure what's the appropriate fix.  It seems to me like the old MLL is broken, it doesn't look like this would have been the intended behavior.  So guess the question would be whether the responsibility lies with the caller of {{ExpandoMetaClass#enableGlobally}} to check first to see if already enabled or whether that method should not clear if already enabled.;;;","15/Jul/17 19:13;jwagenleitner;{quote}
So guess the question would be whether the responsibility lies with the caller of {{ExpandoMetaClass#enableGlobally}} to check first to see if already enabled or whether that method should not clear if already enabled.
{quote}

The enableGlobally call does already check and only clears if the {{ExpandoMetaClassCreationHandle}} is not the current handle.  In tracing the calls to clearModifiedExpandos when running the sample project grails-javamelody-issue the plugin triggers 2 calls to clearModifiedExpandos, first call in {{ExpandoMetaClassCreationHandle#create}} (via {{ExpandoMetaClass.enableGlobally}}) and second one in {{MetaClassRegistryImpl#setMetaClassCreationHandle}} (via the before mentioned create call).  So even with the old {{ManagedLinkedList}} (in Groovy 2.4.8) the plugin would have removed 2 modified expandos, those for {{org.grails.plugins.codecs.URLCodec}} and {{org.grails.encoder.impl.JavaScriptCodec}}.
;;;",,,,,,,,,,,
protected fields should be disallowed in traits,GROOVY-8066,13038346,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,27/Jan/17 02:37,08/Mar/17 08:17,14/Jul/23 06:02,27/Jan/17 07:35,,,,,,,,,2.4.9,,,,,,,,0,,,,,,,,"We already don't do anything sensible wrt ""protected"" but should instead give a specific error message just like we do for protected methods.",githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jan 27 07:35:10 UTC 2017,,,,,,,,,,"0|i39a87:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jan/17 02:54;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/482

    GROOVY-8066: protected fields should be disallowed in traits

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8066

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/482.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #482
    
----
commit 5de625aac7e172721030d464ceb5e6efda02ecf5
Author: paulk <paulk@asert.com.au>
Date:   2017-01-27T02:52:47Z

    GROOVY-8066: protected fields should be disallowed in traits

----
;;;","27/Jan/17 07:32;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/482
;;;","27/Jan/17 07:35;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,,,
"Map created as org.springframework.http.HttpHeaders is empty in 2.4.8, works fine in 2.4.7",GROOVY-8065,13037700,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,awilkinson,awilkinson,25/Jan/17 13:47,07/Jan/22 18:07,14/Jul/23 06:02,28/Jan/17 05:17,2.4.8,,,,,,,,2.4.9,,,,,,,,0,,,,,,,"There appears to be a regression in Groovy 2.4.8 that causes it to silently create an empty map when it's asked to create it as an instance of Spring Framework's {{HttpHeaders}}.

Here's a minimal reproduction:

{noformat}
@Grab(""org.springframework:spring-web:4.3.5.RELEASE"")
import org.springframework.http.HttpHeaders

def headers = ['Content-Type'       : 'application.json',
               'Content-Disposition': 'test.zip'] as HttpHeaders

println headers
{noformat}

It works as expected with 2.4.7:

{noformat}
$ sdk use groovy 2.4.7 && groovy asHttpHeaders.groovy

Using groovy version 2.4.7 in this shell.
[Content-Type:[application.json], Content-Disposition:[test.zip]]
{noformat}

With 2.4.8 the map is empty:

{noformat}
$ sdk use groovy 2.4.8 && groovy asHttpHeaders.groovy

Using groovy version 2.4.8 in this shell.
[:]
{noformat}","Java 1.8.0_102
OS X 10.10.5",awilkinson,githubbot,jwagenleitner,paulk,snicoll,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-5985,GROOVY-5001,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jan 28 05:17:58 UTC 2017,,,,,,,,,,"0|i396rj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jan/17 13:13;paulk;It looks like this commit:
https://github.com/apache/groovy/commit/2c226838ed
for GROOVY-5985 caused this change.;;;","26/Jan/17 13:19;paulk;Link possible cause - the idea was to make normal map semantics for put come into play when an attempt is made to ""set"" a read-only property for a map - the priority for the normal semantics path should have been lower than when a custom set method is encountered. I am just testing a fix the re-adjusts the priority.;;;","26/Jan/17 13:52;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/480

    GROOVY-8065: Map created as org.springframework.http.HttpHeaders is e…

    …mpty in 2.4.8, works fine in 2.4.7

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8065

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/480.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #480
    
----
commit 6ff8ae172dc7f67fe23911970115f27f0db42106
Author: paulk <paulk@asert.com.au>
Date:   2017-01-26T13:51:32Z

    GROOVY-8065: Map created as org.springframework.http.HttpHeaders is empty in 2.4.8, works fine in 2.4.7

----
;;;","28/Jan/17 03:23;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/480
;;;","28/Jan/17 05:17;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,
@Log annotation does not check logging enablement inside closures which are arguments to methods,GROOVY-8060,13036969,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,shorn,paulk,23/Jan/17 07:36,08/Mar/17 08:17,14/Jul/23 06:02,26/Jan/17 05:18,2.3.3,2.4.8,,,,,,,2.4.9,,,,groovy-runtime,,,,0,,,,,,,"From cloned issue for an additional case:
{code}

import groovy.util.logging.Slf4j
import spock.lang.Specification

@Slf4j
class LoggingSpec extends Specification {


    def ""makes sure groovy isn't building the string inside inactive log levels""() {
        assert log.isDebugEnabled() == false, ""set the log level for this class to INFO to see the horror""
        assert log.isInfoEnabled() == true, ""set the log level for this class to INFO to see the horror""

        CountingDoIt counter = new CountingDoIt()

        //http://docs.groovy-lang.org/docs/groovy-2.4.5/html/documentation/#_logging_improvements
        when: ""we shouldn't evaluate""
        log.debug(""this shouldn't happen ${counter.call()}"".toString())
        then:
        counter.count == 0

        when: ""we should evaluate""
        counter = new CountingDoIt()
        log.info(""this should happen ${counter.call()}"".toString())
        then:
        counter.count == 1

        when: ""we're inside a closure and groovy is failing..so beware""
        counter = new CountingDoIt()
        1.times({ ignore ->
            log.debug(counter.call())
        })
        then:
        counter.count == 0    //debug isn't enabled so this string should never be evaluated but it is

        when: ""we're inside a closure that calls a method.  it's OK""
        counter = new CountingDoIt()

        1.times({ ignore ->
            log.debug(""this shouldn't happen ${doIt(counter)}"".toString())
        })
        then:
        counter.count == 0

    }


    String doIt(CountingDoIt countingDoIt) {
        log.debug(""this shouldn't happen ${countingDoIt.call()}"".toString())
        ""blah""

    }

    static class CountingDoIt {
        int count = 0

        String call() {
            count = count + 1
            ""doneDidIt""
        }
    }
}
{code}","Windows 7, Groovy 2.3.3, JDK 1.8.0_05",githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6932,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 26 05:18:56 UTC 2017,,,,,,,,,,"0|i3929b:",9223372036854775807,,,,,,,,,,,,,,,,Yes,,,"23/Jan/17 11:45;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/478

    GROOVY-8060: @Log annotation does not check logging enablement inside…

    … closures which are arguments to methods

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8060

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/478.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #478
    
----
commit e96a9619ca3e51d867290056194fe5259c55c084
Author: paulk <paulk@asert.com.au>
Date:   2017-01-23T11:42:52Z

    GROOVY-8060: @Log annotation does not check logging enablement inside closures which are arguments to methods

----
;;;","25/Jan/17 11:59;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/478
;;;","26/Jan/17 05:18;paulk;Proposed PR merged.;;;",,,,,,,,,,,,,,,,,,,
STC overloaded generic method selection not using resolved types,GROOVY-8059,13036854,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,jwagenleitner,jwagenleitner,22/Jan/17 06:39,26/Jul/18 04:38,14/Jul/23 06:02,11/May/18 06:47,2.4.8,,,,,,,,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,,Static Type Checker,,,,1,,,,,,,"The fix for GROOVY-6804 only works for primitive arguments because the [distance calc doesn't wrap and compare against reference param types|https://github.com/apache/groovy/blob/048b6586b741009f5497c6bfdb7fb1aad6c607be/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java#L859].  I believe it should wrap before doing the compare (which would fix GROOVY-8055) and believe the current test is only passing because of this anomaly with primitives.

The following test is the same from GROOVY-6804 but instead uses the wrapper type and fails to compile:

{code}
@groovy.transform.CompileStatic
class Base<K extends Serializable, V> {
    void delete(K key) {}
    void delete(V value) {}
}

@groovy.transform.CompileStatic
class Foo extends Base<String, Integer> {}

@groovy.transform.CompileStatic
public class Class1 {
    Class1() {
        Foo foo = new Foo()        
        foo.delete(Integer.valueOf(1))
    }
}
new Class1()
{code}

{code}
[Static type checking] - Cannot call Foo#delete(K) with arguments [java.lang.Integer] 
{code}

In the case of a primitive both {{K-Serializable}} and {{V-Object}} (as seen by the {{getDistance()}}) method have the same distance so both are promoted as possible choices.  The [generic type information is not evaluated until later|https://github.com/apache/groovy/blob/048b6586b741009f5497c6bfdb7fb1aad6c607be/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java#L3720] and when generics are applied the correct method is chosen.  However, in the case of the reference type {{K-Serializable}} is the only method because it has the lowest distance calc and generics are not evaluated.

It seems that the fix would be to resolve the types prior to making the distance calculation.",,daniel_sun,frantam,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6804,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 11 06:47:20 UTC 2018,,,,,,,,,,"0|i391jr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/May/18 06:47;daniel_sun;it is fixed
https://github.com/apache/groovy/commit/c321ec989b495c2fd9261c23cfacdb2a23b879fe;;;",,,,,,,,,,,,,,,,,,,,,
GroovyCodeSource(URL) can leak a file handler,GROOVY-8056,13035839,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,awilkinson,awilkinson,18/Jan/17 10:21,06/Mar/18 23:14,14/Jul/23 06:02,03/Jun/17 15:53,2.4.8,,,,,,,,2.4.12,,,,,,,,0,,,,,,,"When {{GroovyCodeSource}} is created from a {{URL}} it calls {{url.openConnection.getContentEncoding()}}. When it's a {{file:}} URL, this causes a {{FileInputStream}} to be opened and never closed. The stack trace for it being opened is:

{noformat}
at java.io.FileInputStream.<init>(Unknown Source)
	at java.io.FileInputStream.<init>(Unknown Source)
	at sun.net.www.protocol.file.FileURLConnection.connect(Unknown Source)
	at sun.net.www.protocol.file.FileURLConnection.initializeHeaders(Unknown Source)
	at sun.net.www.protocol.file.FileURLConnection.getHeaderField(Unknown Source)
	at java.net.URLConnection.getContentEncoding(Unknown Source)
	at groovy.lang.GroovyCodeSource.<init>(GroovyCodeSource.java:176)
	at groovy.text.markup.MarkupTemplateEngine$MarkupTemplateMaker.<init>(MarkupTemplateEngine.java:222)
	at groovy.text.markup.MarkupTemplateEngine.createTemplateByPath(MarkupTemplateEngine.java:145)
{noformat}

I believe that keeping a local reference to the {{URLConnection}} and then calling {{getInputStream().close()}} on it will fix the problem.

For reference [this|https://github.com/spring-projects/spring-boot/issues/7892] is the Spring Boot issues where the problem was originally reported.",,awilkinson,blackdrag,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jun 03 15:53:01 UTC 2017,,,,,,,,,,"0|i38v9z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jan/17 13:29;blackdrag;Yes, this should not happen... I hope that this then really solves the problem on the spring-boot side, since Windows tends to not close file handles right away and just because we close may not mean windows closes it at that time too. But anyway, this needs to be fixed;;;","22/Jan/17 20:50;jwagenleitner;I think {{getContentEncoding()}} is not correct since we are looking for a charset but it returns how the content is compressed (i.e., gzip, deflate) that is specified in the [Content-Encoding HTTP Header|https://tools.ietf.org/html/rfc7231#section-3.1.2.2].

To obtain a charset it's the {{getContentType()}} value and it's in the form (when it's present) {{text/html; charset=UTF-8}}.  Futher, I think we could skip this call completely if {{""file"".equals(url.getProtocol())}} since no Content-Type header will be available.;;;","19/Feb/17 00:26;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/500

    GROOVY-8056: GroovyCodeSource(URL) can leak a file handler

    URLConnect.getContentEncoding returns the Content-Encoding
    HTTP Header [1] which is not a charset.  Since this method would
    have either returned null or an invalid charset, the code path
    specifying the encoding would normally not have been executed.
    The charset may be contained in the Content-Type header, but
    rather than attempt to parse that string which would require
    closing the connection, this fix avoids opening the connection
    and relies on the default charset.
    
    [1] https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy groovy8056-content-encoding

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/500.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #500
    
----
commit 29a641ccc212d397bdc11d3a995763b88dfe34b5
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-02-19T00:22:49Z

    GROOVY-8056: GroovyCodeSource(URL) can leak a file handler
    
    URLConnect.getContentEncoding returns the Content-Encoding
    HTTP Header [1] which is not a charset.  Since this method would
    have either returned null or an invalid charset, the code path
    specifying the encoding would normally not have been executed.
    The charset may be contained in the Content-Type header, but
    rather than attempt to parse that string which would require
    closing the connection, this fix avoids opening the connection
    and relies on the default charset.
    
    [1] https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11

----
;;;","03/Jun/17 14:56;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/557

    GROOVY-8056: GroovyCodeSource(URL) can leak a file handler

    A safer fix in terms of compatibility compared to PR #500. 

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8056-urlcon-leak

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/557.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #557
    
----
commit d99ff70a729448d75d3ca5b98c70733ba1ca428a
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-06-03T14:50:41Z

    GROOVY-8056: GroovyCodeSource(URL) can leak a file handler

----
;;;","03/Jun/17 15:12;githubbot;Github user jwagenleitner closed the pull request at:

    https://github.com/apache/groovy/pull/500
;;;","03/Jun/17 15:50;githubbot;Github user jwagenleitner closed the pull request at:

    https://github.com/apache/groovy/pull/557
;;;","03/Jun/17 15:53;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,
@CompileStatic improperly orders parameter types,GROOVY-8055,13035518,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,marcingrzejszczak,marcingrzejszczak,17/Jan/17 12:15,26/Jul/18 04:38,14/Jul/23 06:02,11/May/18 15:47,2.4.7,2.4.8,,,,,,,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,,Static compilation,,,,0,,,,,,,"*Given* the following snippet

{code}
import groovy.transform.CompileStatic

@CompileStatic
class Foo {
void isEqualTo(Number number) { println ""Number"" }
void isEqualTo(Object number) { println ""Object"" }
}

@CompileStatic
class Runner {
void run() {
new Foo().isEqualTo(4)
}
}

new Runner().run()
{code}

*When* you try to run it 
*Then* you get the following exception

{code}
[Static type checking] - Reference to method is ambiguous. Cannot choose between [void Foo#isEqualTo(java.lang.Object), void Foo#isEqualTo(java.lang.Number)]
 at line: 13, column: 1
{code}

*And* you would expect the thing to compile properly",,daniel_sun,jwagenleitner,marcingrzejszczak,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 11 15:47:21 UTC 2018,,,,,,,,,,"0|i38tav:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/May/18 15:47;daniel_sun;Fixed by https://github.com/apache/groovy/commit/fc1b21fb1960191ba269fac7069bc677b14388ca;;;",,,,,,,,,,,,,,,,,,,,,
Static imports inconsistency with @CompileStatic and use(),GROOVY-8054,13035334,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,daniilo,daniilo,16/Jan/17 21:00,08/Mar/22 12:16,14/Jul/23 06:02,25/Oct/21 15:49,2.4.8,,,,,,,,,,,,Compiler,Static compilation,,,0,,,,,,,"{code}
package hello

import groovy.transform.CompileStatic
import static hello.C.*

class C {
  static foo(a) { 'imported foo' }
  static bar(a) { 'imported bar' }
}

class Main {
  static void main(String[] args) {
    def main = new Main()
    println main.foo1() // imported foo
    println main.bar1() // class bar
    use(Main) {
      println main.bar1() // imported bar
    }
  }

  @CompileStatic
  def foo1() {
    foo '2'
  }

  def bar1() {
    bar '2'
  }

  static foo(String s) { 'class foo' }
  static bar(String s) { 'class bar' }
}
{code}",,daniilo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2017-01-16 21:00:56.0,,,,,,,,,,"0|i38s5z:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"Groovyc: anonymous class in static method cannot access its fields without ""this""",GROOVY-8053,13035062,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,hussdl,hussdl,15/Jan/17 23:40,24/Nov/19 02:45,14/Jul/23 06:02,31/Oct/19 18:18,2.4.8,,,,,,,,2.5.8,3.0.0-rc-1,,,,,,,0,,,,,,,"{code}
import groovy.transform.CompileStatic

@CompileStatic // also happens without it
final class TestCase {

    static thisShouldCompile() {

        Object o = new Object() {

            int inaccessible

            @Override
            int hashCode() {
                inaccessible++ // succeeds when qualified with ""this""
                return super.hashCode()
            }
        }
    }

    static void main( String... args ) {
        thisShouldCompile()
        System.out.println( ""Success"" )
    }
}
{code}

Could be related to GROOVY-7020","JAVA_VERSION=""1.8.0_111""
OS_NAME=""Windows""
OS_VERSION=""5.2""
OS_ARCH=""amd64""",daniel_sun,hussdl,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 01 07:49:49 UTC 2019,,,,,,,,,,"0|i38qhz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Nov/19 07:49;daniel_sun;{quote}meta version for 3.x for scheduling work (with new grammar) - don't leave as fix version
{quote}
I will set the fix version to the latest released version;;;",,,,,,,,,,,,,,,,,,,,,
CVE-2016-6814 Security Vulnerability,GROOVY-8052,13034927,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,paulk,paulk,14/Jan/17 12:45,01/Feb/17 23:19,14/Jul/23 06:02,14/Jan/17 12:45,,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"Issue to track the above CVE.
Commits:
https://github.com/apache/groovy/commit/716d3e67e744c7edeed7cbc3f874090d39355764",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jan 14 15:48:02 UTC 2017,,,,,,,,,,"0|i38pnz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Jan/17 15:48;paulk;As per steps here:
https://www.apache.org/security/committers.html

I believe all steps are complete.;;;",,,,,,,,,,,,,,,,,,,,,
Reference outer class property within inner class closure,GROOVY-8051,13034703,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,daniilo,daniilo,13/Jan/17 15:56,08/Mar/22 12:16,14/Jul/23 06:02,18/Nov/21 17:31,2.4.7,2.4.8,,,,,,,,,,,Compiler,Static compilation,Static Type Checker,,0,,,,,,,"{code}
@CompileStatic // works without this @CompileStatic
class Outer {
  def foo = 1
  Inner createInner() { new Inner() }
  class Inner {
    Closure createClosure() {
      return { foo }
    }
  }
}

@CompileStatic
class Main {
  static void main(String[] args) {
    def i = new Outer().createInner()
    def cl = i.createClosure()
    println cl()
  }
}
{code}

Fail in runtime with:
{noformat}
Exception in thread ""main"" org.codehaus.groovy.runtime.typehandling.GroovyCastException: 
Cannot cast object 'Outer$Inner@23e028a9' with class 'Outer$Inner' to class 'Outer'
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnSAM(DefaultTypeTransformation.java:405)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.continueCastOnNumber(DefaultTypeTransformation.java:319)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.castToType(DefaultTypeTransformation.java:232)
	at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.castToType(ScriptBytecodeAdapter.java:603)
	at Outer$Inner$_createClosure_closure1.doCall(innerclassestest.groovy)
	at Outer$Inner$_createClosure_closure1.call(innerclassestest.groovy)
	at Main.main(innerclassestest.groovy:23)
{noformat}",,daniilo,emilles,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8050,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jun 07 17:45:11 UTC 2020,,,,,,,,,,"0|i38oaf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Feb/17 16:44;shils;[~daniilo] have you tried this on 2.4.8? I wasn't able to reproduce the error there.;;;","07/Feb/17 06:43;daniilo;[~shils] Yes. It is reproducible with groovy 2.4.8 and java build 1.8.0_102-b14.
;;;","20/Mar/17 06:41;paulk;I can reproduce on 2.4.10 but it seems fixed in 2.5+ snapshots.;;;","07/Jun/20 17:45;emilles;This was resolved by the rewriting of ""this"" -> ""thisObject"" -> ""thisObject.this$0"" in Groovy 2.5: https://github.com/apache/groovy/blob/GROOVY_2_5_X/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java#L376

GROOVY-7970 seems to be the source of the fix and includes discussion regarding backporting to Groovy 2.4.  GROOVY-8051 specifically can be fixed with only the ""if (target.isPublic() && receiver != null)"" block in StaticInvocationWriter#writeDirectMethodCall.;;;",,,,,,,,,,,,,,,,,,
Reference outer class property via inner class,GROOVY-8050,13034696,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,daniilo,daniilo,13/Jan/17 15:46,25/Aug/22 18:52,14/Jul/23 06:02,14/Dec/21 19:15,2.4.7,,,,,,,,2.5.19,3.0.10,4.0.0-rc-2,,Compiler,Static compilation,Static Type Checker,,0,,,,,,,"{code}
@CompileStatic
class Outer {
  def foo = 1
  Inner createInner() { new Inner() }
  class Inner {}
}

@CompileStatic  // works without @CompileStatic
class Main {
  static void main(String[] args) {
    def i = new Outer().createInner()
    println i.foo // [Static type checking] - No such property: foo for class: Outer$Inner
  }
}
{code}

I think should work in both static and dynamic contexts or fail in both.
Please close this issue if this is by design.",,daniilo,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8051,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 14 19:15:51 UTC 2021,,,,,,,,,,"0|i38o8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Dec/21 03:44;emilles;https://github.com/apache/groovy/commit/e71a44a04eda3a0b27de7f54b2176c1e3fdafad1;;;","14/Dec/21 19:15;emilles;The dynamic case runs through {{Outer$Inner#propertyMissing}} which delegates to {{Outer#this$dist$get$1}}.  It does not appear to distinguish between a call site that is within Outer and one that lies outside.;;;",,,,,,,,,,,,,,,,,,,,
Trait properties with 'with',GROOVY-8049,13034679,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,daniilo,daniilo,13/Jan/17 14:49,11/Nov/20 02:01,14/Jul/23 06:02,10/Aug/20 13:54,2.4.7,,,,,,,,3.0.6,4.0.0-alpha-1,,,,,,,0,,,,,,,"{code}
@CompileStatic
interface I {
  String getFoo()
}

@CompileStatic
trait T {

  abstract I getProp()

  def usage() {
    prop.with {
      foo.toUpperCase() 
// Groovyc: [Static type checking] - Cannot find matching method java.lang.Object#toUpperCase(). Please check if the declared type is right and if the method exists.
// works when changed to getFoo().toUpperCase() 
    }
  }
}

@CompileStatic
class Main implements T {

  I prop = { ""hello"" } as I

  static void main(String[] args) {
    println new Main().usage()
  }
}
{code}",,daniilo,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 08 18:27:44 UTC 2020,,,,,,,,,,"0|i38o53:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Aug/20 18:27;emilles;Fixed by GROOVY-9386;;;",,,,,,,,,,,,,,,,,,,,,
final fields for pre-compiled traits aren't processed correctly,GROOVY-8048,13034659,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,13/Jan/17 14:14,08/Mar/17 08:17,14/Jul/23 06:02,09/Feb/17 02:21,2.4.8,,,,,,,,2.4.9,,,,,,,,1,,,,,,,"From slack:

Testing 2.4.8 by running through the Grails tests (master branch) and seeing NPE's on some tests that exercise Traits.  Can be fairly quickly replicated by running `./gradlew :grails-plugin-interceptors:test`

same tests pass in 2.4.7 up thru commit https://github.com/apache/groovy/commit/c00a75a89a15e46c2afacf6e72256cd4484bd5f1  which causes the tests to fail with NPE's, don't have a lot of time to look into it, just wanted to mention it

the Trait class has a final property in it and when it's used it's null, removing the final modifier gets rid of the problem https://github.com/grails/grails-core/blob/master/grails-plugin-interceptors/src/main/groovy/grails/artefact/Interceptor.groovy#L113",,githubbot,jspiewak,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 09 02:21:18 UTC 2017,,,,,,,,,,"0|i38o0n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Feb/17 22:43;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/492

    GROOVY-8048: final fields for pre-compiled traits aren't processed co…

    …rrectly

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8048

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/492.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #492
    
----
commit 75a7ca85258bafe9833771714b143941121d4762
Author: paulk <paulk@asert.com.au>
Date:   2017-02-07T22:41:11Z

    GROOVY-8048: final fields for pre-compiled traits aren't processed correctly

----
;;;","09/Feb/17 02:19;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/492
;;;","09/Feb/17 02:21;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,,,
ClassFormatError void field ,GROOVY-8046,13034631,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,daniilo,daniilo,13/Jan/17 12:36,22/May/22 16:01,14/Jul/23 06:02,20/Mar/17 06:45,2.4.7,,,,,,,,2.5.0-alpha-1,,,,Compiler,,,,0,ClassFormatError,,,,,,"{code}
class MyClass {
  void field
  static void main(String[] args) {}
}
{code}

When run:
{noformat}
Exception in thread ""main"" java.lang.ClassFormatError: Field ""field"" in class MyClass has illegal signature ""V""
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:73)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:368)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:362)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:361)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.forName0(Native Method)
	at java.lang.Class.forName(Class.java:264)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:119)
{noformat}",jdk1.8.0_102,daniilo,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 20 06:45:24 UTC 2017,,,,,,,,,,"0|i38nuf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Mar/17 23:57;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/513

    GROOVY-8046: ClassFormatError void field

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8046

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/513.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #513
    
----
commit 2ee00c1733bdb7c489cdd4b7651c2cf5ea00b320
Author: paulk <paulk@asert.com.au>
Date:   2017-03-14T23:48:05Z

    GROOVY-8046: ClassFormatError void field

----
;;;","16/Mar/17 04:58;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/513
;;;","20/Mar/17 06:45;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,,,
Implicit closure coercion doesn't work for elements of array of functional objects,GROOVY-8045,13034599,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,ddimitrov,ddimitrov,13/Jan/17 11:06,23/Jul/22 21:05,14/Jul/23 06:02,01/Jun/22 11:58,2.4.7,,,,,,,,4.0.4,,,,Compiler,,,,1,varargs,,,,,,"Implicit closure coercion is described [here|http://groovy-lang.org/releasenotes/groovy-2.2.html] - it assumes that the closures don't need to be casted to functional types and the generic types will be inferred by the compiler.

Here is one contrived case that works from Java (this is not production code and is writen explicitly for illustration purposes):

{code}
public class GroovyAccDemo {
    @SafeVarargs
    public static <T, R> Function<T, R> ensemble(Function<T, R>... hypotheses) {
        return t -> Arrays.stream(hypotheses)
                          .map(v -> v.apply(t))
                          .collect(Collectors.groupingBy(e -> e, Collectors.counting()))
                          .entrySet()
                          .stream()
                          .max(Comparator.comparingLong(Map.Entry::getValue))
                          .map(Map.Entry::getKey).orElseGet(() -> null);
    }

    public static void main(String[] args) {
        Function<Integer, Integer> foo = ensemble(
                i -> i*i,
                i -> i+i,
                i -> i*i - (i+i)
        );
    }
}
{code}

Here the {{ensemble()}} method accepts a number of compatible functions and returns a single function that calls all hypotheses and returns the most popular result.

The main method illustrates that we can use the {{ensemble()}} function with Java Lambdas without any explicit casts.

If we try to do the same in Groovy, we'll get runtime error (or compile error if static compilation is enabled):

{code}
            foo = GroovyAccDemo.<Integer, Integer> ensemble(
                    { i -> i * i },
                    { i -> i + i },
                    { i -> i * i - (i + i) }
            );
{code}

We can make it work by explicitly coercing the closures like this:

{code}
            foo = GroovyAccDemo.ensemble(
                    { i -> i*i } as Function,
                    { i -> i+i } as Function,
                    { i -> i*i - (i+i ) } as Function
            );
{code}

This may seem as contrived use case, but it makes the use of certain API's more tedious from Groovy than from Java, which just feels wrong ;-)

",,daniel_sun,ddimitrov,emilles,githubbot,rkrisztian,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10529,,,,,,,GROOVY-10636,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 01 16:31:43 UTC 2022,,,,,,,,,,"0|i38nnb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Oct/19 18:14;rkrisztian;I have the same problem in a JUnit 5 test:

{code:groovy}
assertAll([
		{ assert 1 == 1 },
		{ assert 2 == 2 }
].collect { it as Executable })
{code}

Right now this is a bit cumbersome.

Yes, I have considered:

* Upgrading to Groovy 2.6, but Gradle has not yet.
* Switching to Spock, which is a valid point, although requires rewriting my tests, and Spock still uses JUnit 4.;;;","25/May/22 19:25;emilles;SC: https://github.com/apache/groovy/commit/496748a118a51b2dad33f9fd03a8039a1cf0127d;;;","25/May/22 20:48;githubbot;eric-milles opened a new pull request, #1722:
URL: https://github.com/apache/groovy/pull/1722

   https://issues.apache.org/jira/browse/GROOVY-8045


;;;","25/May/22 21:50;githubbot;sonatype-lift[bot] commented on code in PR #1722:
URL: https://github.com/apache/groovy/pull/1722#discussion_r882143891


##########
src/main/java/org/codehaus/groovy/reflection/ParameterTypes.java:
##########
@@ -292,77 +290,72 @@ public boolean isValidExactMethod(Class[] args) {
         return true;
     }
 
-    private static boolean testComponentAssignable(Class toTestAgainst, Class toTest) {
-        Class component = toTest.getComponentType();
-        if (component == null) return false;
-        return MetaClassHelper.isAssignableFrom(toTestAgainst, component);
-    }
-
-    private static boolean isValidVarargsMethod(Class[] arguments, int size, CachedClass[] pt, int paramMinus1) {
-        // first check normal number of parameters
-        for (int i = 0; i < paramMinus1; i++) {
-            if (pt[i].isAssignableFrom(arguments[i])) continue;
-            return false;
+    private static boolean isValidVargsMethod(Class[] argumentTypes, CachedClass[] parameterTypes, int nthParameter) {
+        for (int i = 0; i < nthParameter; i += 1) {
+            if (!parameterTypes[i].isAssignableFrom(argumentTypes[i])) {
+                return false;
+            }
         }
 
+        CachedClass arrayType = parameterTypes[nthParameter];
+        CachedClass componentType = ReflectionCache.getCachedClass(arrayType.getTheClass().getComponentType());
+
         // check direct match
-        CachedClass varg = pt[paramMinus1];
-        Class clazz = varg.getTheClass().getComponentType();
-        if (size == pt.length &&
-                (varg.isAssignableFrom(arguments[paramMinus1]) ||
-                        testComponentAssignable(clazz, arguments[paramMinus1]))) {
-            return true;
+        if (argumentTypes.length == parameterTypes.length) {
+            Class argumentType = argumentTypes[nthParameter];
+            if (arrayType.isAssignableFrom(argumentType) || (argumentType.isArray()
+                    && componentType.isAssignableFrom(argumentType.getComponentType()))) {

Review Comment:
   *NULL_DEREFERENCE:*  object `componentType` last assigned on line 301 could be null and is dereferenced at line 307.
   
   (at-me [in a reply](https://help.sonatype.com/lift/talking-to-lift) with `help` or `ignore`)
   
   ---
   
   Was this a good recommendation?
   [ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=243425071&lift_comment_rating=1) ] - [ [😕 Won't fix](https://www.sonatype.com/lift-comment-rating?comment=243425071&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=243425071&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=243425071&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=243425071&lift_comment_rating=5) ]



##########
src/main/java/org/codehaus/groovy/reflection/ParameterTypes.java:
##########
@@ -292,77 +290,72 @@ public boolean isValidExactMethod(Class[] args) {
         return true;
     }
 
-    private static boolean testComponentAssignable(Class toTestAgainst, Class toTest) {
-        Class component = toTest.getComponentType();
-        if (component == null) return false;
-        return MetaClassHelper.isAssignableFrom(toTestAgainst, component);
-    }
-
-    private static boolean isValidVarargsMethod(Class[] arguments, int size, CachedClass[] pt, int paramMinus1) {
-        // first check normal number of parameters
-        for (int i = 0; i < paramMinus1; i++) {
-            if (pt[i].isAssignableFrom(arguments[i])) continue;
-            return false;
+    private static boolean isValidVargsMethod(Class[] argumentTypes, CachedClass[] parameterTypes, int nthParameter) {
+        for (int i = 0; i < nthParameter; i += 1) {
+            if (!parameterTypes[i].isAssignableFrom(argumentTypes[i])) {
+                return false;
+            }
         }
 
+        CachedClass arrayType = parameterTypes[nthParameter];
+        CachedClass componentType = ReflectionCache.getCachedClass(arrayType.getTheClass().getComponentType());
+
         // check direct match
-        CachedClass varg = pt[paramMinus1];
-        Class clazz = varg.getTheClass().getComponentType();
-        if (size == pt.length &&
-                (varg.isAssignableFrom(arguments[paramMinus1]) ||
-                        testComponentAssignable(clazz, arguments[paramMinus1]))) {
-            return true;
+        if (argumentTypes.length == parameterTypes.length) {
+            Class argumentType = argumentTypes[nthParameter];
+            if (arrayType.isAssignableFrom(argumentType) || (argumentType.isArray()
+                    && componentType.isAssignableFrom(argumentType.getComponentType()))) {
+                return true;
+            }
         }
 
-        // check varged
-        for (int i = paramMinus1; i < size; i++) {
-            if (MetaClassHelper.isAssignableFrom(clazz, arguments[i])) continue;
-            return false;
+        // check vararg match
+        for (int i = nthParameter; i < argumentTypes.length; i += 1) {
+            if (!componentType.isAssignableFrom(argumentTypes[i])) {

Review Comment:
   *NULL_DEREFERENCE:*  object `componentType` last assigned on line 301 could be null and is dereferenced at line 314.
   
   (at-me [in a reply](https://help.sonatype.com/lift/talking-to-lift) with `help` or `ignore`)
   
   ---
   
   Was this a good recommendation?
   [ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=243425264&lift_comment_rating=1) ] - [ [😕 Won't fix](https://www.sonatype.com/lift-comment-rating?comment=243425264&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=243425264&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=243425264&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=243425264&lift_comment_rating=5) ]



##########
src/main/java/org/codehaus/groovy/reflection/ParameterTypes.java:
##########
@@ -292,77 +290,72 @@ public boolean isValidExactMethod(Class[] args) {
         return true;
     }
 
-    private static boolean testComponentAssignable(Class toTestAgainst, Class toTest) {
-        Class component = toTest.getComponentType();
-        if (component == null) return false;
-        return MetaClassHelper.isAssignableFrom(toTestAgainst, component);
-    }
-
-    private static boolean isValidVarargsMethod(Class[] arguments, int size, CachedClass[] pt, int paramMinus1) {
-        // first check normal number of parameters
-        for (int i = 0; i < paramMinus1; i++) {
-            if (pt[i].isAssignableFrom(arguments[i])) continue;
-            return false;
+    private static boolean isValidVargsMethod(Class[] argumentTypes, CachedClass[] parameterTypes, int nthParameter) {
+        for (int i = 0; i < nthParameter; i += 1) {
+            if (!parameterTypes[i].isAssignableFrom(argumentTypes[i])) {
+                return false;
+            }
         }
 
+        CachedClass arrayType = parameterTypes[nthParameter];
+        CachedClass componentType = ReflectionCache.getCachedClass(arrayType.getTheClass().getComponentType());
+
         // check direct match
-        CachedClass varg = pt[paramMinus1];
-        Class clazz = varg.getTheClass().getComponentType();
-        if (size == pt.length &&
-                (varg.isAssignableFrom(arguments[paramMinus1]) ||
-                        testComponentAssignable(clazz, arguments[paramMinus1]))) {
-            return true;
+        if (argumentTypes.length == parameterTypes.length) {
+            Class argumentType = argumentTypes[nthParameter];
+            if (arrayType.isAssignableFrom(argumentType) || (argumentType.isArray()
+                    && componentType.isAssignableFrom(argumentType.getComponentType()))) {
+                return true;
+            }
         }
 
-        // check varged
-        for (int i = paramMinus1; i < size; i++) {
-            if (MetaClassHelper.isAssignableFrom(clazz, arguments[i])) continue;
-            return false;
+        // check vararg match
+        for (int i = nthParameter; i < argumentTypes.length; i += 1) {
+            if (!componentType.isAssignableFrom(argumentTypes[i])) {
+                return false;
+            }
         }
+
         return true;
     }
 
     public boolean isValidMethod(Object[] arguments) {
         if (arguments == null) return true;
-
-        final int size = arguments.length;
-        CachedClass[] paramTypes = getParameterTypes();
-        final int paramMinus1 = paramTypes.length - 1;
-
-        if (size >= paramMinus1 && paramTypes.length > 0 &&
-                paramTypes[(paramMinus1)].isArray) {
-            // first check normal number of parameters
-            for (int i = 0; i < paramMinus1; i++) {
-                if (paramTypes[i].isAssignableFrom(getArgClass(arguments[i]))) continue;
-                return false;
+        final CachedClass[] parameterTypes = getParameterTypes();
+        final int nArguments = arguments.length, nParameters = parameterTypes.length, nthParameter = nParameters - 1;

Review Comment:
   *NULL_DEREFERENCE:*  object `parameterTypes` last assigned on line 324 could be null and is dereferenced at line 325.
   
   (at-me [in a reply](https://help.sonatype.com/lift/talking-to-lift) with `help` or `ignore`)
   
   ---
   
   Was this a good recommendation?
   [ [🙁 Not relevant](https://www.sonatype.com/lift-comment-rating?comment=243425289&lift_comment_rating=1) ] - [ [😕 Won't fix](https://www.sonatype.com/lift-comment-rating?comment=243425289&lift_comment_rating=2) ] - [ [😑 Not critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=243425289&lift_comment_rating=3) ] - [ [🙂 Critical, will fix](https://www.sonatype.com/lift-comment-rating?comment=243425289&lift_comment_rating=4) ] - [ [😊 Critical, fixing now](https://www.sonatype.com/lift-comment-rating?comment=243425289&lift_comment_rating=5) ]



;;;","31/May/22 22:48;daniel_sun;[~rkrisztian] Groovy 2.6 is out of maintainence for a long time, so it's strongly recommended to upgrading to the latest version of Groovy 4 directly.;;;","01/Jun/22 11:56;githubbot;eric-milles merged PR #1722:
URL: https://github.com/apache/groovy/pull/1722


;;;","01/Jun/22 16:31;rkrisztian;[~daniel_sun], thanks, I will upgrade. I am aware now that it is indeed possible to compile with any Groovy version in Gradle.;;;",,,,,,,,,,,,,,,
NPE compiling Memoized method,GROOVY-8043,13033443,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,idooley,idooley,10/Jan/17 16:52,02/May/17 02:03,14/Jul/23 06:02,20/Mar/17 11:32,2.4.7,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,"{code:title=Reproducable Example groovy code that fails to compile}
class A {    
}

new A() {
  @groovy.transform.Memoized()
  String a() {
    return ""a""
  }
}
{code}

{code:title=Exception I get when compiling the groovy script}
groovy.lang.GroovyRuntimeException: NPE while processing Script71.groovy
     at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:258)
     at org.codehaus.groovy.control.CompilationUnit$16.call(CompilationUnit.java:813)
     at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1053)
     at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
     at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
     at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
     at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
     at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
     at groovy.lang.GroovyShell.parseClass(GroovyShell.java:688)
     at groovy.lang.GroovyShell.parse(GroovyShell.java:700)
     at groovy.lang.GroovyShell.evaluate(GroovyShell.java:584)
     at groovy.lang.GroovyShell.evaluate(GroovyShell.java:623)
     at groovy.lang.GroovyShell.evaluate(GroovyShell.java:594)
     ...
Caused by: java.lang.NullPointerException
     at org.codehaus.groovy.classgen.asm.ClosureWriter.createClosureClass(ClosureWriter.java:190)
     at org.codehaus.groovy.classgen.asm.ClosureWriter.getOrAddClosureClass(ClosureWriter.java:156)
     at org.codehaus.groovy.classgen.asm.ClosureWriter.writeClosure(ClosureWriter.java:87)
     at org.codehaus.groovy.classgen.AsmClassGenerator.visitClosureExpression(AsmClassGenerator.java:657)
     at org.codehaus.groovy.ast.expr.ClosureExpression.visit(ClosureExpression.java:45)
     at org.codehaus.groovy.classgen.asm.CallSiteWriter.prepareSiteAndReceiver(CallSiteWriter.java:235)
     at org.codehaus.groovy.classgen.asm.CallSiteWriter.prepareSiteAndReceiver(CallSiteWriter.java:224)
     at org.codehaus.groovy.classgen.asm.CallSiteWriter.makeCallSite(CallSiteWriter.java:272)
     at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCachedCall(InvocationWriter.java:307)
     at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:392)
     at org.codehaus.groovy.classgen.asm.InvocationWriter.makeCall(InvocationWriter.java:104)
     at org.codehaus.groovy.classgen.asm.InvocationWriter.makeInvokeMethodCall(InvocationWriter.java:88)
     at org.codehaus.groovy.classgen.asm.InvocationWriter.writeInvokeMethod(InvocationWriter.java:459)
     at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethodCallExpression(AsmClassGenerator.java:767)
     at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
     at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:316)
     at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:84)
     at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:638)
     at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:51)
     at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:612)
     at org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.writeExpressionStatement(OptimizingStatementWriter.java:357)
{code}",,githubbot,idooley,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 20 11:32:48 UTC 2017,,,,,,,,,,"0|i38ian:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Mar/17 07:29;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/511

    GROOVY-8043: NPE compiling Memoized method with AIC

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8043

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/511.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #511
    
----
commit 6a30bb254f63fe949ed60f5b173220e88aad2c62
Author: paulk <paulk@asert.com.au>
Date:   2017-03-10T07:27:55Z

    GROOVY-8043: NPE compiling Memoized method with AIC

----
;;;","20/Mar/17 06:50;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/511
;;;","20/Mar/17 11:32;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,
groovyConsole gets confused with a slashy string with an escaped forward slash,GROOVY-8042,13033223,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,dkarr,dkarr,09/Jan/17 23:27,06/Mar/18 23:25,14/Jul/23 06:02,28/Jun/17 04:03,2.4.7,,,,,,,,2.4.13,,,,Groovy Console,,,,0,,,,,,,"If I paste or enter the following into groovyConsole:
--------------
def escapeSlash = /The character \/ is a forward slash/
--------------

What it displays is a little confusing.  It renders in yellow starting at the first forward slash.  The intention is that this would show the entire expression, including the terminating forward slash, in yellow.

What it actually does is terminate the ""yellow"" at the second forward slash, which is escaped.

Fortunately, the expression does execute successfully, but the display makes it seem to the user that there is a syntax error with the expression.",,dkarr,DmitryKh,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jun 28 04:03:49 UTC 2017,,,,,,,,,,"0|i38gxz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jun/17 22:12;githubbot;GitHub user dkhamitov opened a pull request:

    https://github.com/apache/groovy/pull/568

    GROOVY-8042 groovyConsole gets confused with a slashy string with an escaped forward slash

    Hi, guys! Here is quite a simple fix for the case when a slashy string renders in yellow just up to the escaped slash, not the closing one (https://issues.apache.org/jira/browse/GROOVY-8042). If we can have more tests on this code, please let me know how we can achieve this. The tests which I've added are kind of regression tests.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/dkhamitov/groovy GROOVY-8042-wrong-color-of-slashy-string

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/568.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #568
    
----
commit df1bfad8a5e8e9d5ad95e098b2cd75a4ef4a6dae
Author: dkhamitov <khamitov.dm@gmail.com>
Date:   2017-06-26T22:12:30Z

    GROOVY-8042 groovyConsole gets confused with a slashy string with an escaped forward slash

----
;;;","28/Jun/17 03:55;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/568
;;;","28/Jun/17 04:03;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,
Class unloading (PermGen) memory leak with Groovy Shell,GROOVY-8035,13032206,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,gbauer,gbauer,05/Jan/17 09:35,01/Feb/17 23:18,14/Jul/23 06:02,09/Jan/17 15:55,2.4.7,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"The following code causes a memory leak in perm gen reproducibly on Oracle JDK6 and 7.

{code:java}
import groovy.lang.GroovyShell;

public class Demo {


    public static void main(String[] args) throws Exception {
        for (int i = 0; i < 10000000; i++) {
            GroovyShell gs = new GroovyShell();
            Script script = gs.parse("" 'Hello, World';"");
            Object result = script.run();
            assert result.equals(""Hello, World"");
        }
    }
}
{code}

Tested with the following VM options (with PermGen size 20MB), the execution results in java.lang.OutOfMemoryError: PermGen space after a little more than 2000 iterations.

{noformat}
-verbose:class -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+CMSClassUnloadingEnabled -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses -XX:+TraceClassUnloading -XX:MaxPermSize=16M -XX:+UseConcMarkSweepGC -XX:+ExplicitGCInvokesConcurrent -XX:+PrintGCDetails -XX:-UseParNewGC
{noformat}

As a workaround, calling the following method with script.getClass() from above (as described in http://stackoverflow.com/a/41473210/2156613) seems to avoid this leak and trigger class unloading correctly:
{code:java}
    public static void clearAllClassInfo(Class<?> type) {
        try {
            Field globalClassValue = ClassInfo.class.getDeclaredField(""globalClassValue"");
            globalClassValue.setAccessible(true);
            GroovyClassValue classValueBean = (GroovyClassValue) globalClassValue.get(null);
            classValueBean.remove(type);
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    }
{code}

This should be handled by Groovy itself, or (if this is not possible) there should be at least a possibility to trigger this functionality via a Groovy API call instead of having to create the above method in all applications using Groovy.","Oracle JDK6, Oracle JDK7",gbauer,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 09 15:55:35 UTC 2017,,,,,,,,,,"0|i38anz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Jan/17 06:43;jwagenleitner;I can replicate the error with 2.4.7 but not with 2.4.8-SNAPSHOT.  Possibly fixed by GROOVY-7683.  As a work-around for 2.4.7 you might want to try {{-Dgroovy.use.classvalue=true}}.;;;","09/Jan/17 08:09;gbauer;Hi [~jwagenleitner], I tested with 2.4.8-SNAPSHOT as well and could not replicate the error, so it seems to be fixed and I will upgrade as soon as 2.4.8 is released.

Wih 2.4.7 and {{-Dgroovy.use.classvalue=true}}, the problem does not occur for Java 7, but unfortunately the issue persists with Java 6.;;;","09/Jan/17 15:55;jwagenleitner;Thanks for confirming, I'll go ahead and resolve this.  I should have mentioned that the {{groovy.use.classvalue}} would only apply to jdk7 and above.;;;",,,,,,,,,,,,,,,,,,,
Compile error when using generic type with lower bound,GROOVY-8034,13032118,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,uze@yandex.ru,uze@yandex.ru,04/Jan/17 23:34,11/Sep/22 20:33,14/Jul/23 06:02,26/Mar/21 15:39,2.4.6,2.4.7,,,,,,,2.5.19,3.0.13,4.0.0-alpha-3,,Static Type Checker,,,,0,,,,,,,"I'm trying to implement chained generics. It works as Java code but fails to compile by groovyc:
{code}
Error:(38, 9) Groovyc: [Static type checking] - Cannot call <C extends com.github.ykiselev.ChainTest.A<? super O, ?>> com.github.ykiselev.ChainTest$A <? super O -> java.lang.Object, ?>#andThen(C) with arguments [com.github.ykiselev.ChainTest$A <Double, String>]
{code}
Code (JUnit4 unit test)
{code}
package com.github.ykiselev

import groovy.transform.TypeChecked
import org.junit.Test

@TypeChecked
class ChainTest {

    static class A<I, O> {

        def <C extends A<? super O, ?>> C andThen(C next) {
            return next
        }

    }

    static <I, O, C extends A<? super O, ?>> C chain(A<I, O> self, C next) {
        self.andThen(next)
        return next
    }

    @Test
    void ""should chain""() {
        def a1 = new A<String, Integer>()
        def a2 = new A<Integer, Double>()
        def a3 = new A<Double, String>()
        def a4 = new A<String, Double>()
        def a5 = new A<Number, Object>()

        a1.andThen(a2) // ok
        a2.andThen(a3) // ok
        a3.andThen(a4) // ok
        a4.andThen(a5) // ok (even without ""? super O"")

        chain(a1, a2).andThen(a3) // ok
        chain(chain(chain(chain(a1, a2), a3), a4), a5) // ok

        a1.andThen(a2)
                .andThen(a3) // static type checker error
                .andThen(a4)
                .andThen(a5)
    }
}
{code}

This would compile if I change bounded type parameter like this:
{code}
def <C extends A<O, ?>> C andThen(C next) {
            return next
}
{code}

but I need it bounded.",,DmitryKh,uze@yandex.ru,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 05 10:52:10 UTC 2017,,,,,,,,,,"0|i38a4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jan/17 10:45;uze@yandex.ru;(i) This code is compiled without errors by groovy 2.4.4, 2.4.5
;;;","05/Jan/17 10:52;uze@yandex.ru;Test project available on [github|https://github.com/YKiselev/groovyLowerBoundFail];;;",,,,,,,,,,,,,,,,,,,,
STC: spread property references fails in static method,GROOVY-8033,13031762,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,emilles,emilles,03/Jan/17 21:14,29/Mar/17 01:13,14/Jul/23 06:02,10/Jan/17 00:00,2.4.7,,,,,,,,2.5.0-alpha-1,,,,Static Type Checker,,,,0,,,,,,,"I managed to boil this down to static method versus non-static method.  When I use the spread operator in a Set to access a property (backed by getter), I am getting a type checking error.  If I remove the TypeChecked, all is well.  If I remove static from the method, all is well.

{code}
@groovy.transform.TypeChecked
class Foo {
  static def meth() {
    Set<java.beans.BeanInfo> defs = []
    defs*.additionalBeanInfo
  }
}
{code}

Error during compile (or in the IDE):
Foo.groovy: 11: [Static type checking] - No such property: additionalBeanInfo for class: java.util.Set <java.beans.BeanInfo>",,emilles,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 09 23:58:59 UTC 2017,,,,,,,,,,"0|i387xb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jan/17 21:49;shils;This seems to occur in all cases when the inferred type of the collection variable is not derived from List (e.g. Set, Queue, etc.);;;","04/Jan/17 17:42;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/476

    GROOVY-8033: spread property calls on non-list collections fail STC i…

    …n static methods

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-8033

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/476.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #476
    
----
commit 7821c9b030ac61e30f8ea85fc962c6019b52302a
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2017-01-04T17:26:37Z

    GROOVY-8033: spread property calls on non-list collections fail STC in static methods

----
;;;","09/Jan/17 23:58;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/476
;;;",,,,,,,,,,,,,,,,,,,
An unexpected error has occurred when using 'kkk = kkk + 12',GROOVY-8030,13031196,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,x_MM1229,x_MM1229,30/Dec/16 03:03,08/Mar/17 08:17,14/Jul/23 06:02,05/Feb/17 10:33,2.4.5,,,,,,,,2.4.9,,,,Compiler,,,,0,,,,,,,"Test groovy code:
------------------------------------
{code:Java}
package com.test

def kkk = 123
kkk = ""123""

println kkk.toInteger()

int a = 0;

if (a > 0)
{
  kkk = 789
  kkk = kkk + 12 // This code caused error occur
}
else
{
  kkk = ""456""
  kkk = kkk + ""78""
}

//println kkk.toUpperCase()
println kkk
{code}
Error message:
------------------------------------
{noformat}
Exception in thread ""main"" BUG! exception in phase 'class generation' in source unit 'SimpleDemo' At line 13 column 9
On receiver: kkk with message: plus and arguments: 12
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at https://issues.apache.org/jira/browse/GROOVY
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesCallSiteWriter.makeSingleArgumentCall(StaticTypesCallSiteWriter.java:634)
	at org.codehaus.groovy.classgen.asm.InvocationWriter.makeSingleArgumentCall(InvocationWriter.java:616)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateBinaryExpression(BinaryExpressionHelper.java:529)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionMultiTypeDispatcher.evaluateBinaryExpression(BinaryExpressionMultiTypeDispatcher.java:230)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:148)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:638)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:51)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.evaluateEqual(BinaryExpressionHelper.java:316)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesBinaryExpressionMultiTypeDispatcher.evaluateEqual(StaticTypesBinaryExpressionMultiTypeDispatcher.java:151)
	at org.codehaus.groovy.classgen.asm.BinaryExpressionHelper.eval(BinaryExpressionHelper.java:84)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBinaryExpression(AsmClassGenerator.java:638)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:51)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeExpressionStatement(StatementWriter.java:607)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitExpressionStatement(AsmClassGenerator.java:620)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:42)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:84)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:65)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:566)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeIfElse(StatementWriter.java:288)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitIfElse(AsmClassGenerator.java:582)
	at org.codehaus.groovy.ast.stmt.IfStatement.visit(IfStatement.java:43)
	at org.codehaus.groovy.classgen.asm.StatementWriter.writeBlockStatement(StatementWriter.java:84)
	at org.codehaus.groovy.classgen.asm.sc.StaticTypesStatementWriter.writeBlockStatement(StaticTypesStatementWriter.java:65)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitBlockStatement(AsmClassGenerator.java:566)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:104)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:115)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitStdMethod(AsmClassGenerator.java:430)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitConstructorOrMethod(AsmClassGenerator.java:387)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:126)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitMethod(AsmClassGenerator.java:507)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1086)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:53)
	at org.codehaus.groovy.classgen.AsmClassGenerator.visitClass(AsmClassGenerator.java:233)
	at org.codehaus.groovy.control.CompilationUnit$16.call(CompilationUnit.java:813)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1055)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:694)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:706)
	at groovy.lang.GroovyShell.parse(GroovyShell.java:742)
{noformat}","java.version=1.8.0_45
java.runtime.version=1.8.0_45-b15
os.arch=x86
os.name=Windows 7
sun.jnu.encoding=GBK",blackdrag,githubbot,paulk,x_MM1229,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Feb 05 10:33:47 UTC 2017,,,,,,,,,,"0|i384g7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"30/Dec/16 09:25;blackdrag;the stack trace suggest static compilation, your example code does not show anything about static compilation. Can you please confirm this happens only during static compilation?;;;","30/Dec/16 09:32;x_MM1229;Yes, i'm sure. The error only occur during static compilation.

We using below code add compileStatic feature:
configuration.addCompilationCustomizers(new ASTTransformationCustomizer(CompileStatic.class));;;;","27/Jan/17 10:40;paulk;A smaller example illustrating the issue:
{code}
@groovy.transform.CompileStatic
def main() {
    def kkk = ""abc""
    kkk = 30
    kkk + 12 // BUG! exception in phase 'class generation'
}

assert main() == 42
{code}
It's using the LUB and Serializable doesn't have {{plus}} but it shouldn't be using LUB here.;;;","31/Jan/17 05:32;paulk;The last line succeeds if written as: {{kkk += 12}} or {{kkk.plus(12)}};;;","03/Feb/17 10:19;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/488

    GROOVY-8030: An unexpected error has occurred when using 'kkk = kkk +…

    … 12'

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8030

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/488.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #488
    
----
commit 1338c7c7cacabf316db13a71c0c4bdfa54741ce1
Author: paulk <paulk@asert.com.au>
Date:   2017-02-03T09:59:47Z

    GROOVY-8030: An unexpected error has occurred when using 'kkk = kkk + 12'

----
;;;","05/Feb/17 10:33;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,
"Matcher indexed via IntRange with startIdx..-1 does not return ""intermediate"" range matches",GROOVY-8026,13029239,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,brianeray,brianeray,19/Dec/16 19:44,08/Mar/17 08:17,14/Jul/23 06:02,30/Jan/17 14:09,2.4.7,,,,,,,,2.4.9,,,,groovy-jdk,,,,0,,,,,,,"Maybe this isn't a bug, and I realize that a {{Matcher}} is not exactly a {{List}} or any other {{Collection}}, but the inconsistency is a little mysterious. Here's a simple Groovysh script with several comparative indexes:

{code:java}
txt = 'abcd 1 efgh 2 ijkl 3 mnop'
m = txt =~ /\d/
println m.collect { it }    // as expected: [1, 2, 3]
println m[ 0..2 ]           // as expected: [1, 2, 3]
println m[ 0..m.size()-1 ]  // as expected: [1, 2, 3]
println m[ 0..<m.size() ]   // as expected: [1, 2, 3]
println m[ 0..-1 ]          // bug?: [1, 3]

//for comparison
a = [ 1, 2, 3 ]
println a.collect { it }    // [1, 2, 3]
println a[ 0..2 ]           // [1, 2, 3]
println a[ 0..a.size()-1 ]  // [1, 2, 3]
println a[ 0..<a.size() ]   // [1, 2, 3]
println a[ 0..-1 ]          // [1, 2, 3]
{code}","Zulu OpenJDK 1.8.0_102-b14
Windows 7 Pro",githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jan 30 14:09:16 UTC 2017,,,,,,,,,,"0|i37sdr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Dec/16 05:44;paulk;Possibly similar to GROOVY-5744;;;","20/Dec/16 17:24;brianeray;Interesting. Here are expanded tests, just to see how close the symptoms are to that issue.
{code:java}
//compare to GROOVY-5744 (multiple assignment from an Iterator skips every other element)
otherTxt = '1 2 3 4 5 6 7 8 9'
mm = otherTxt =~ /\d/
println mm.collect { it }                  // [1, 2, 3, 4, 5, 6, 7, 8, 9]
println mm[ 0..8 ]                         // [1, 2, 3, 4, 5, 6, 7, 8, 9]
println mm[ 0..mm.size()-1 ]               // [1, 2, 3, 4, 5, 6, 7, 8, 9]
println mm[ 0..<mm.size() ]                // [1, 2, 3, 4, 5, 6, 7, 8, 9]
println mm[-1]                             // 9
println mm[ 0..-1 ]                        // the current inconsistency: [1, 9]
println mm[ (0..-1).toList() ]             // [1, 9]
println mm[ (0..-1).iterator().toList() ]  // [1, 9]

//for comparison
aa = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
println aa.collect { it }                  // [1, 2, 3, 4, 5, 6, 7, 8, 9]
println aa[ 0..8 ]                         // [1, 2, 3, 4, 5, 6, 7, 8, 9]
println aa[ 0..aa.size()-1 ]               // [1, 2, 3, 4, 5, 6, 7, 8, 9]
println aa[ 0..<aa.size() ]                // [1, 2, 3, 4, 5, 6, 7, 8, 9]
println aa[-1]                             // 9
println aa[ 0..-1 ]                        // [1, 2, 3, 4, 5, 6, 7, 8, 9]
println aa[ (0..-1).toList() ]             // [1, 9]
println aa[ (0..-1).iterator().toList() ]  // [1, 9]
{code}

The only mismatch between {{List#getAt(Range)}} and {{Matcher#getAt(Range)}} (actually [{{Matcher#getAt(Collection)}}|http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/regex/Matcher.html#getAt(java.util.Collection)]?) seems to be this one scenario. Mechanically it is as if the {{Range}} is first evaluated to a {{List}} when indexing a {{Matcher}}.

In contrast {{List#getAt(Range)}} is clever. It appears to convert the {{Range}} end to the implied positive index before evaluating it.;;;","27/Jan/17 07:00;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/483

    GROOVY-8026: Matcher indexed via IntRange with startIdx..-1 does not …

    …return ""intermediate"" range matches

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8026

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/483.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #483
    
----
commit c7ae6ef5a9d8206b9a5051adb99f1e86969cc1d8
Author: paulk <paulk@asert.com.au>
Date:   2017-01-27T06:58:50Z

    GROOVY-8026: Matcher indexed via IntRange with startIdx..-1 does not return ""intermediate"" range matches

----
;;;","30/Jan/17 12:59;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/483
;;;","30/Jan/17 14:09;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,
Compile time increases exponentially when compiling Class implementing a Trait,GROOVY-8023,13028346,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,mklaehn,mklaehn,15/Dec/16 09:50,08/Mar/17 08:17,14/Jul/23 06:02,26/Jan/17 20:27,2.4.4,2.4.7,,,,,,,2.4.9,,,,Compiler,,,,0,,,,,,,"Concidering the following classes
{code:title=ATrait.groovy|borderStyle=solid}
trait ATrait {
}
{code}
and
{code:title=AClass.groovy|borderStyle=solid}
class AClass implements ATrait {
    def String cleanName(String name) {
        return name.
            replaceAll(/alpha01/, '/').
            replaceAll(/alpha02/, '/').
            replaceAll(/alpha03/, '/').
            replaceAll(/alpha04/, '/').
            replaceAll(/alpha05/, '/').
            replaceAll(/alpha06/, '/').
            replaceAll(/alpha07/, '/').
            replaceAll(/alpha08/, '/').
            replaceAll(/alpha09/, '/').
            replaceAll(/alpha10/, '/').
            replaceAll(/alpha11/, '/').
            replaceAll(/alpha12/, '/').
            replaceAll(/alpha13/, '/').
            replaceAll(/alpha14/, '/').
            replaceAll(/alpha15/, '/').
            replaceAll(/alpha16/, '/').
            replaceAll(/alpha17/, '/').
            replaceAll(/alpha18/, '/').
            replaceAll(/alpha19/, '/').
            replaceAll(/alpha20/, '/').
            replaceAll(/alpha21/, '/').
            replaceAll(/alpha22/, '/').
            replaceAll(/alpha23/, '/').
//            replaceAll(/alpha24/, '/').
//            replaceAll(/alpha25/, '/').
            replaceAll(/\//, ""."").
            replaceAll(/\.\.*/, ""."").
            replaceAll(/__+/, ""_"")
    }
}
{code}
 compiles in about 6 seconds. If I remove the import of the Trait 'ATrait' in 'AClass' the compile proces only takes about 1 second.

If you consider the classes as the are shown above then the compile time nearly duplicates for every method call I add to the chained method call.

With the replaceAll with alpha24 being compiled the compilation process takes approximately 11 seconds and with alpha 25 being compiled in conjunction with alpha24 the compilation takes approximately 20 seconds.",,blackdrag,mklaehn,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 26 20:07:06 UTC 2017,,,,,,,,,,"0|i37mvb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Jan/17 20:07;blackdrag;it was quadratic time complexity, now it is linear again: https://github.com/apache/groovy/commit/d3dd694969e85050b2b127280ad5ca7dcdfd2180;;;",,,,,,,,,,,,,,,,,,,,,
Strange performance issue using if(true) versus if(1==1),GROOVY-8019,13027236,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,cwhite102,cwhite102,11/Dec/16 03:14,01/Feb/17 23:18,14/Jul/23 06:02,11/Dec/16 22:21,2.4.4,2.4.7,,,,,,,2.4.8,,,,,,,,0,,,,,,,"While using a Groovy script we came across a strange performance anomaly.  Having the bulk of our script wrapped in an  if( true ){}  statement as opposed to an  if( 1==1 ){}  statement severely degrades performance of the inner part of the script.  Multi-threaded performance is most severely affected.  There appeared to be much more contention running the same script on a 48 core box with the  ""if(true)"".  (took about 100x longer to run 48 copies of these scripts on their own threads). 

The curious aspect of this, is that the 'if' statement is not in the nested loops, but somehow has negatively affected the compilation / optimization / byte-code.

Running a Single copy of this script on a 8 core i7 shows quite a performance hit too...  (5000ms vs. 200ms)

The (effective) code to run the script is as follows...
{code}
	compiledScript = ((Compilable)engine).compile(scriptString);
	result = compiledScript.eval(bindings);
{code}

Here's the script...

{code}
// $script_engine_name=groovy

long sum = 0;
double m = 1;

if( true ) {

	System.err.println( ""START"");
	long t0 = System.currentTimeMillis();

	for( int j=0; j<1000; j++ ) {
	  for( int i=0; i<100000; i++ ) {
  		sum = sum + i;
  		m = m*i;
	  }
	}

	long t1 = System.currentTimeMillis();
	System.err.println( ""END - "" + (t1-t0)+""ms"");
}

System.err.println( ""Done: ""+sum+"" ""+m );
{code}",Groovy Script Engine in a Java app running on Windows 7 and Windows Server 2012,blackdrag,cwhite102,d0k1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8020,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Dec 13 19:37:34 UTC 2016,,,,,,,,,,"0|i37g0v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Dec/16 22:21;blackdrag;the problem was that if an if-block does not contain only optimizable code, it did forbid others (the for-loops here) to be optimized. Now this is no longer the case, thus the performance is much better again and the problem should be solved;;;","13/Dec/16 19:37;cwhite102;Thanks for the quick investigation!
I just added Groovy-8020 as there seems to be a similar issue with While() statements that likely wasn't addressed by the fix here.
;;;",,,,,,,,,,,,,,,,,,,,
@TupleConstructor could use the order of properties listed in 'includes' when that option is used,GROOVY-8016,13025200,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,02/Dec/16 20:52,02/May/17 02:03,14/Jul/23 06:02,07/Dec/16 06:07,,,,,,,,,2.5.0-alpha-1,,,,,,,,0,breaking,,,,,,"Different JVMs return the available fields/properties in slightly different orders, so having this option is in some ways required to achieve consistent behavior across all platforms. This would be a minor breaking change for people using 'includes' but relying on the platform returned order but people in that situation are facing the platform issue in any case.",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Dec 07 06:07:25 UTC 2016,,,,,,,,,,"0|i373gf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Dec/16 00:03;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/469

    GROOVY-8016: @TupleConstructor could use the order of properties list…

    …ed in 'includes' when that option is used

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8016

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/469.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #469
    
----
commit f26225df0461f521bcf2e87cbab9540908a1bf7b
Author: paulk <paulk@asert.com.au>
Date:   2016-12-03T23:57:34Z

    GROOVY-8016: @TupleConstructor could use the order of properties listed in 'includes' when that option is used

----
;;;","07/Dec/16 06:06;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/469
;;;","07/Dec/16 06:07;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,,,
The checking of property names during AST transform attribute processing doesn't take into account includeSuperProperties,GROOVY-8013,13024669,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,01/Dec/16 05:16,02/May/17 02:03,14/Jul/23 06:02,03/Dec/16 23:24,,,,,,,,,2.5.0-alpha-1,,,,xforms,,,,0,,,,,,,"Example shown below is for @ToString but the issue affects numerous xforms:
{code}
import groovy.transform.*

@ToString
class Foo {
  String baz = 'baz'
}

@ToString(includes='baz', includeSuperProperties=true)
class Bar extends Foo {
  int num = 42
}

new Bar().toString()
// 1 compilation error: Error during @ToString processing: 'includes' property 'baz' does not exist.
{code}",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Dec 03 23:24:06 UTC 2016,,,,,,,,,,"0|i3706f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Dec/16 20:29;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/468

    GROOVY-8013: The checking of property names during AST transform attr…

    …ibute processing doesn't take into account includeSuperProperties

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8013

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/468.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #468
    
----
commit 8a56fe6f87f39a7f98e60dab0d3680dd82ae95e5
Author: paulk <paulk@asert.com.au>
Date:   2016-12-02T20:27:23Z

    GROOVY-8013: The checking of property names during AST transform attribute processing doesn't take into account includeSuperProperties

----
;;;","03/Dec/16 23:22;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/468
;;;","03/Dec/16 23:24;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,,,
A class with a @MapConstructor when supplied with no args throws NPE,GROOVY-8012,13024668,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,paulk,01/Dec/16 05:10,02/May/17 02:03,14/Jul/23 06:02,01/Dec/16 18:43,,,,,,,,,,,,,xforms,,,,0,,,,,,,"{code}
@groovy.transform.MapConstructor
class Foo {
    String bar
}

println new Foo(bar: 'baz').bar // OK
println new Foo() // NPE
{code}
",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Dec 01 18:43:25 UTC 2016,,,,,,,,,,"0|i37067:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Dec/16 17:15;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/466

    GROOVY-8012: A class with a @MapConstructor when supplied with no arg…

    …s throws NPE

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy8012

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/466.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #466
    
----
commit 8bb742c75c88423693657c7d8af5e71400ba2568
Author: paulk <paulk@asert.com.au>
Date:   2016-12-01T17:13:41Z

    GROOVY-8012: A class with a @MapConstructor when supplied with no args throws NPE

----
;;;","01/Dec/16 18:33;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/466
;;;","01/Dec/16 18:43;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,,,
@CompileStatic causes failure to compile Groovy class that calls overloaded Java method,GROOVY-8008,13023454,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,renatoathaydes,renatoathaydes,25/Nov/16 22:44,26/Jul/18 04:38,14/Jul/23 06:02,21/Jun/18 05:40,2.4.5,2.4.7,2.4.8,,,,,,2.4.16,2.5.1,,,,,,,0,,,,,,,"This bug is not making sense to me, but I want to report it because it's incredibly frustrating to get an error message that won't even tell me which file the compiler was trying to compile before throwing an Exception.

Here's the stacktrace:

Error:Groovyc: While compiling osgiaas-cli-groovy_main: java.lang.ArrayIndexOutOfBoundsException: 2
	at org.codehaus.groovy.vmplugin.v5.Java5.makeParameters(Java5.java:443)
	at org.codehaus.groovy.vmplugin.v5.Java5.configureClassNode(Java5.java:376)
	at org.codehaus.groovy.ast.ClassNode.lazyClassInit(ClassNode.java:265)
	at org.codehaus.groovy.ast.ClassNode.getAnnotations(ClassNode.java:1431)
	at org.codehaus.groovy.ast.ClassNode.getAnnotations(ClassNode.java:1430)
	at org.codehaus.groovy.transform.trait.Traits.isAnnotatedWithTrait(Traits.java:170)
	at org.codehaus.groovy.transform.trait.Traits.isTrait(Traits.java:149)
	at org.codehaus.groovy.transform.trait.Traits.collectSelfTypes(Traits.java:309)
	at org.codehaus.groovy.transform.trait.Traits.collectSelfTypes(Traits.java:291)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.addSelfTypes(StaticTypeCheckingVisitor.java:3102)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.makeOwnerList(StaticTypeCheckingVisitor.java:3083)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2852)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:297)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2735)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:297)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2735)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:297)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2735)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:297)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitProperty(ClassCodeVisitorSupport.java:144)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitProperty(StaticTypeCheckingVisitor.java:1518)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1074)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:53)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:249)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:122)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:63)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:134)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:178)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1055)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:62)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:115)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.intMain2(GroovycRunner.java:136)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.jetbrains.jps.incremental.groovy.InProcessGroovyc.runGroovycInThisProcess(InProcessGroovyc.java:156)
	at org.jetbrains.jps.incremental.groovy.InProcessGroovyc.access$000(InProcessGroovyc.java:51)
	at org.jetbrains.jps.incremental.groovy.InProcessGroovyc$1.call(InProcessGroovyc.java:85)
	at org.jetbrains.jps.incremental.groovy.InProcessGroovyc$1.call(InProcessGroovyc.java:82)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)


All I can tell you is that [this commit](https://github.com/renatoathaydes/osgiaas/commit/3b04f1d22b3b612d49a5af6fab402b2f4fe316d7) (to a Java class in another module!) started causing this error. Basically, it adds a new overload to a method (`com.athaydes.osgiaas.cli.args.ArgsSpec.ArgsSpecBuilder#accepts(java.lang.String, java.lang.String)`) which no class even calls yet.

The error happens when compiling the [:modules:cli:osgiaas-cli-grab](https://github.com/renatoathaydes/osgiaas/tree/master/modules/cli/osgiaas-cli-grab/src/main/groovy/com/athaydes/osgiaas/cli/grab) module, which only contains 2 groovy classes (so it should be possible to determine why this is happening a little more easily).

Reverting the commit, the code compiles and all tests pass.

Removing `@CompileStatic` from the classes also seems to fix the problem, but then other Groovy classes (which also have `@CompileStatic`) start failing!

Please let me know if there's anything I can do to help figure this out... but for now, that's all the information I can provide!",Mac OS / Java 8_u112,githubbot,jwagenleitner,renatoathaydes,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-8505,,GROOVY-8505,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 21 05:40:13 UTC 2018,,,,,,,,,,"0|i36sof:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jan/17 19:10;renatoathaydes;This file also does not compile with either @CompileStatic or @TypeChecked:

https://github.com/renatoathaydes/osgiaas/blob/master/modules/cli/osgiaas-cli-groovy/src/main/groovy/com/athaydes/osgiaas/cli/groovy/command/GroovyCommand.groovy

I found out that if I comment out the lines creating the ""argsSpec"":

```
    final ArgsSpec argsSpec = ArgsSpec.builder()
            .accepts( RESET_CODE_ARG, RESET_CODE_LONG_ARG )
        ...
```

Then it works. I tried to reproduce this bug with a simpler setup but it just worked... I couldn't figure out what's the difference between my simpler code and this one. Hope this helps, anyway.;;;","16/Jan/17 22:31;jwagenleitner;The [constructor causing the problem|https://github.com/renatoathaydes/osgiaas/blob/c2dde60530b977fc4bf508d702785d44fb3d42ad/modules/cli/osgiaas-cli-api/src/main/java/com/athaydes/osgiaas/cli/args/ArgsSpec.java#L440-L443] is:

{code}
com.athaydes.osgiaas.cli.args.ArgsSpec$ArgsSpecBuilder$ArgBuilder(
    com.athaydes.osgiaas.cli.args.ArgsSpec$ArgsSpecBuilder,
    java.lang.String,
    java.lang.String
)
{code}

Since it's an inner class the first parameter is a synthetic reference to the outer class.

The [{{makeParameters(CompileUnit cu, Type\[\] types, Class\[\] cls, Annotation\[\]\[\] parameterAnnotations)}}|https://github.com/apache/groovy/blob/GROOVY_2_4_8/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java#L441-L450] method loops through the types and reflection methods for the Constructor {{getGenericParameterTypes()}} and {{getParameterTypes()}} return 3 elements {{class com.athaydes.osgiaas.cli.args.ArgsSpec$ArgsSpecBuilder, class java.lang.String, class java.lang.String}}.  However, the {{getParameterAnnotations()}} method only returns 2 {{[\[\], \[@javax.annotation.Nullable()\]\]}} (does not appear to include an empty element for the synthetic parameter).

This only seems to be the case when one of the parameters has an annotation, if the nullable anno is removed from that private constructor it compiles successfully.
;;;","18/Jan/17 19:19;jwagenleitner;I believe this is related to [JDK-8024694|https://bugs.openjdk.java.net/browse/JDK-8024694] (referenced from [JDK-8025806|https://bugs.openjdk.java.net/browse/JDK-8025806]).  When an annotation is present on an inner class constructor parameter the class file generates a {{RuntimeVisibleParameterAnnotations}} section that only includes the formal parameters and not the out this synthetic/mandated parameter.

A work-around in this case may be to check for length mismatch and prepend the {{Annotation[][]}} array with zero-length {{Annotation[]}} elements.

Just for reference here's a program that if compiled with javac shows the mismatch and throws an AIOB error:

{code}
import java.lang.reflect.*;
import java.util.Arrays;

public class CtorAnnoParams {

    public static void main(String... args) throws Exception {
        Constructor<?> ctor1 = Inner1.class.getDeclaredConstructors()[0];
        System.out.println(Arrays.toString(ctor1.getParameterTypes()));
        System.out.println(Arrays.toString(ctor1.getGenericParameterTypes()));
        System.out.println(Arrays.deepToString(ctor1.getParameterAnnotations()));

        Constructor<?> ctor2 = Inner2.class.getDeclaredConstructors()[0];
        System.out.println(Arrays.toString(ctor2.getParameterTypes()));
        System.out.println(Arrays.toString(ctor2.getGenericParameterTypes()));
        System.out.println(Arrays.deepToString(ctor2.getParameterAnnotations()));
        
        System.out.println(""------------------"");
        for (Parameter p : ctor2.getParameters()) {
            System.out.println(p);
            System.out.println(p.getAnnotations());
        }
    }

    private class Inner1 {
        private Inner1(String arg1, Integer arg2) {}
    }

    private class Inner2 {
        private Inner2(String arg1, @Deprecated Integer arg2) {}
    }
}
{code};;;","15/Jun/18 02:42;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/757

    GROOVY-8008: AIOOB inner class ctor params with runtime annotations

    Should also address [GROOVY-8505](https://issues.apache.org/jira/browse/GROOVY-8505) which is the same issue.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy 8008-aioob-inner-class-ctor-param-annos

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/757.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #757
    
----
commit e5e8da40dc3e2d1d141280ee5162247da7ed3083
Author: John Wagenleitner <jwagenleitner@...>
Date:   2018-06-15T02:37:56Z

    GROOVY-8008: AIOOB inner class ctor params with runtime annotations

----
;;;","18/Jun/18 04:24;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/757#discussion_r195962344
  
    --- Diff: src/main/java/org/codehaus/groovy/vmplugin/v5/Java5.java ---
    @@ -405,6 +408,32 @@ public void configureClassNode(CompileUnit compileUnit, ClassNode classNode) {
             }
         }
     
    +    /**
    +     * Synthetic parameters such as those added for inner class constructors may not be
    +     * included in the parameter annotations array.  This is the case when at least one
    +     * parameter of an inner class constructor is annotated with a RUNTIME retention
    +     * policy.  This method will normalize the annotation array so that it contains the
    +     * same number of elements as the array returned from {@link Constructor#getParameterTypes()}.
    +     *
    +     * If adjustment is required, the adjusted array will be pre-pended will zero-length
    --- End diff --
    
    minor typo: second 'will' should be 'with'
;;;","18/Jun/18 18:05;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/757#discussion_r196172656
  
    --- Diff: src/main/java/org/codehaus/groovy/vmplugin/v5/Java5.java ---
    @@ -405,6 +408,32 @@ public void configureClassNode(CompileUnit compileUnit, ClassNode classNode) {
             }
         }
     
    +    /**
    +     * Synthetic parameters such as those added for inner class constructors may not be
    +     * included in the parameter annotations array.  This is the case when at least one
    +     * parameter of an inner class constructor is annotated with a RUNTIME retention
    +     * policy.  This method will normalize the annotation array so that it contains the
    +     * same number of elements as the array returned from {@link Constructor#getParameterTypes()}.
    +     *
    +     * If adjustment is required, the adjusted array will be pre-pended will zero-length
    --- End diff --
    
    Fixed, thanks.
;;;","21/Jun/18 05:08;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/757
;;;","21/Jun/18 05:40;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,
[parrot] Getting the groovydoc comment should work in scripts as well,GROOVY-8007,13023403,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,glaforge,glaforge,25/Nov/16 13:52,25/Nov/16 16:10,14/Jul/23 06:02,25/Nov/16 16:10,,,,,,,,,,,,,,,,,0,,,,,,,"In a script I can't get access to the content of the groovydoc / javadoc comments for methods, although it works if I wrap my script in a class:

{code}
import org.codehaus.groovy.control.*
import static org.apache.groovy.parser.antlr4.AstBuilder.DOC_COMMENT

def code = '''
/**
 * a method
 * @author glaforge
 */
void m(int i) {}
}
'''
def ast = new CompilationUnit().tap {
    addSource 'methodM.groovy', code
    compile Phases.SEMANTIC_ANALYSIS 
}.ast

assert ast.classes[0].methods[0].nodeMetaData[DOC_COMMENT]
{code}

Ideally, it should work as well for scripts as it works for classes.",,daniel_sun,glaforge,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 25 16:09:15 UTC 2016,,,,,,,,,,"0|i36sd3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Nov/16 16:09;daniel_sun;Fixed;;;",,,,,,,,,,,,,,,,,,,,,
[parrot] NPE when using try-with-resources with a missing semi-colon,GROOVY-8005,13023218,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,glaforge,glaforge,24/Nov/16 15:31,26/Nov/16 07:37,14/Jul/23 06:02,26/Nov/16 07:36,,,,,,,,,,,,,,,,,0,,,,,,,"When testing the try-with-resouces construct in the Groovy console, I did a mistake, and forgot the semi-colon in between resources:

{code}
def input = new File('./NOTICE')

try (
    FileInputStream fin = new FileInputStream(input)
    GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(output))
) {
    byte[] buffer = new byte[4096]
    int nread = 0
    while ((nread = fin.read(buffer)) != -1) {
        out.write(buffer, 0, nread)
    }
}
{code}

And I got the following NPE:
{code}
java.lang.NullPointerException
	at org.apache.groovy.parser.antlr4.AstBuilder.configureAST(AstBuilder.java:3775)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitCommandExpression(AstBuilder.java:1484)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitCommandExprAlt(AstBuilder.java:1449)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitCommandExprAlt(AstBuilder.java:67)
	at org.apache.groovy.parser.antlr4.GroovyParser$CommandExprAltContext.accept(GroovyParser.java:7491)
	at org.antlr.v4.runtime.tree.AbstractParseTreeVisitor.visit(AbstractParseTreeVisitor.java:44)
	at org.apache.groovy.parser.antlr4.AstBuilder.visit(AstBuilder.java:3408)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitVariableInitializer(AstBuilder.java:1408)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitVariableDeclarator(AstBuilder.java:1392)
	at org.apache.groovy.parser.antlr4.AstBuilder.lambda$visitVariableDeclarators$17(AstBuilder.java:1365)
	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)
	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1374)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitVariableDeclarators(AstBuilder.java:1368)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitVariableDeclaration(AstBuilder.java:1257)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitLocalVariableDeclaration(AstBuilder.java:1210)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitResource(AstBuilder.java:447)
	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)
	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1374)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitResourceList(AstBuilder.java:442)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitResources(AstBuilder.java:437)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitTryCatchStatement(AstBuilder.java:417)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitTryCatchStmtAlt(AstBuilder.java:407)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitTryCatchStmtAlt(AstBuilder.java:67)
	at org.apache.groovy.parser.antlr4.GroovyParser$TryCatchStmtAltContext.accept(GroovyParser.java:6039)
	at org.antlr.v4.runtime.tree.AbstractParseTreeVisitor.visit(AbstractParseTreeVisitor.java:44)
	at org.apache.groovy.parser.antlr4.AstBuilder.visit(AstBuilder.java:3408)
	at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193)
	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1374)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitCompilationUnit(AstBuilder.java:141)
	at org.apache.groovy.parser.antlr4.AstBuilder.visitCompilationUnit(AstBuilder.java:67)
	at org.apache.groovy.parser.antlr4.GroovyParser$CompilationUnitContext.accept(GroovyParser.java:290)
	at org.antlr.v4.runtime.tree.AbstractParseTreeVisitor.visit(AbstractParseTreeVisitor.java:44)
	at org.apache.groovy.parser.antlr4.AstBuilder.visit(AstBuilder.java:3408)
	at org.apache.groovy.parser.antlr4.AstBuilder.buildAST(AstBuilder.java:116)
	at org.apache.groovy.parser.antlr4.Antlr4ParserPlugin.buildAST(Antlr4ParserPlugin.java:43)
	at org.codehaus.groovy.control.SourceUnit.convert(SourceUnit.java:269)
	at org.codehaus.groovy.control.CompilationUnit$15.call(CompilationUnit.java:690)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:948)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:615)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:591)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:568)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:299)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:269)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:688)
	at groovy.lang.GroovyShell.run(GroovyShell.java:517)
	at groovy.lang.GroovyShell.run(GroovyShell.java:497)
	at groovy.lang.GroovyShell.run(GroovyShell.java:170)
	at groovy.lang.GroovyShell$run$1.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy:1045)
	at groovy.ui.Console$_runScriptImpl_closure17.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor226.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:294)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:994)
	at groovy.lang.Closure.call(Closure.java:415)
	at groovy.lang.Closure.call(Closure.java:409)
	at groovy.lang.Closure.run(Closure.java:496)
	at java.lang.Thread.run(Thread.java:745)
{code}",,daniel_sun,glaforge,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Nov 26 07:36:27 UTC 2016,,,,,,,,,,"0|i36r7z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Nov/16 07:36;daniel_sun;Fixed.;;;",,,,,,,,,,,,,,,,,,,,,
CompileStatic ImmutableList.size() calls DefaultGroovyMethods.size(Iterable),GROOVY-8004,13022150,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,JanKanis,JanKanis,21/Nov/16 10:18,08/Mar/22 12:16,14/Jul/23 06:02,25/Oct/21 15:55,2.4.7,,,,,,,,,,,,Compiler,,,,0,,,,,,,"Calling {{size()}} on a Guava ImmutableList (which implements {{List}}) under {{@CompileStatic}} calls DefaultGroovyMethods.size(Iterable) instead ImmutableList.size(). If the variable is of type {{List}} and the compiler cannot deduce that it actually contains an {{ImmutableList}} the {{List.size()}} method is called as expected.

The same bug exists for general Guava collections. 

Obviously this is bad especially for large collections, where a {{size()}} ends up taking linear time instead of constant time.

Example:
{code}
import com.google.common.collect.ImmutableList
import groovy.transform.CompileStatic

@CompileStatic
class TestClass {
    public static void main(String[] args) {
        ImmutableList<String> l = ImmutableList.copyOf(args)
        List<String> ls = l as List

        println(l.size()) // Calls DefaultGroovyMethods.size(Iterable)
        println(ls.size()) // Calls List.size()
    }
}
{code}

View the generated code with {{javap -p -c TestClass.class}} to see the calls that were emitted.",,JanKanis,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 05 23:16:30 UTC 2017,,,,,,,,,,"0|i36kmn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jan/17 23:16;shils;Didn't have much time to look at this, but it appears to be a result of the distance calculation in StaticTypeCheckingSupport#chooseBestMethod(ClassNode, Collection<MethodNode>, ClassNode...) i.e. the extension methods distance is found to be less than the regular ones. ;;;",,,,,,,,,,,,,,,,,,,,,
Static compilation drops source position for method calls,GROOVY-8002,13021859,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,emilles,emilles,18/Nov/16 21:41,12/Aug/19 12:55,14/Jul/23 06:02,02/Aug/19 14:45,,,,,,,,,2.5.8,3.0.0-beta-3,,,,,,,0,,,,,,,"@CompileStatic is dropping source position for method calls in a couple cases.  There are several circumstances where a MethodCallExpression is created using the 1st constructor of MCE, which creates a ConstantExpression for the method with no position.  And later when org.codehaus.groovy.classgen.asm.sc.StaticPropertyAccessHelper.PoppingMethodCallExpression.transformExpression(ExpressionTransformer) is called, the transformed expression has lost position info.

The latter is pretty easy.  See the one line addition below:
{code}
        public Expression transformExpression(final ExpressionTransformer transformer) {
            PoppingMethodCallExpression trn = new PoppingMethodCallExpression(receiver.transformExpression(transformer), setter, (TemporaryVariableExpression) tmp.transformExpression(transformer));
            trn.copyNodeMetaData(this);
            // GRECLIPSE add
            trn.setSourcePosition(this);
            // GRECLIPSE end
            trn.setImplicitThis(isImplicitThis());
            trn.setSafe(isSafe());
            trn.setSpreadSafe(isSpreadSafe());
            return trn;
        }
{code}

MethodCallExpression could use an override of setSourcePosition to try and propagate some info to method and arguments expressions.  Here is what I came up with:
{code}
    public void setSourcePosition(ASTNode node) {
        super.setSourcePosition(node);
        if (node instanceof MethodCall) {
            if (node instanceof MethodCallExpression) {
                method.setSourcePosition(((MethodCallExpression) node).getMethod());
            } else {
                method.setSourcePosition(node);
                method.setEnd(method.getStart() + getMethodAsString().length());
            }
            if (arguments != null) {
                arguments.setSourcePosition(((MethodCall) node).getArguments());
            }
        } else if (node instanceof PropertyExpression) {
            method.setSourcePosition(((PropertyExpression) node).getProperty());
        }
    }
{code}",,daniel_sun,emilles,jwagenleitner,paulk,,,,,"eric-milles commented on pull request #974: GROOVY-8002: propagate source position to method in chain assignment
URL: https://github.com/apache/groovy/pull/974
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Jul/19 18:21;githubbot;600","danielsun1106 commented on issue #974: GROOVY-8002: propagate source position to method in chain assignment
URL: https://github.com/apache/groovy/pull/974#issuecomment-516348283
 
 
   Is it better to set the position of method nodes in the parsers?
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;30/Jul/19 09:46;githubbot;600","eric-milles commented on issue #974: GROOVY-8002: propagate source position to method in chain assignment
URL: https://github.com/apache/groovy/pull/974#issuecomment-516446279
 
 
   This is a common pattern, the original parsed AST is transformed and the new nodes need to have source ranges transferred.  In this case `PoppingMethodCallExpression trn = new PoppingMethodCallExpression(receiver.transformExpression(transformer), setter, (TemporaryVariableExpression) tmp.transformExpression(transformer));` creates new nodes.  The entire expression does not have source position set.  In addition, the object expression and method expression may be new and lack source position.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;30/Jul/19 14:33;githubbot;600","danielsun1106 commented on pull request #974: GROOVY-8002: propagate source position to method in chain assignment
URL: https://github.com/apache/groovy/pull/974
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;02/Aug/19 14:23;githubbot;600","danielsun1106 commented on issue #974: GROOVY-8002: propagate source position to method in chain assignment
URL: https://github.com/apache/groovy/pull/974#issuecomment-517723930
 
 
   Agreed.
   Merged. Thanks!
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;02/Aug/19 14:34;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 02 14:45:52 UTC 2019,,,,,,,,,,"0|i36itz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Nov/16 23:18;paulk;Thanks for spotting the issue and the suggestions. Do you happen to have some source code which triggers the above path - to save us a bit of time replicating the correct conditions? Thanks.;;;","19/Nov/16 13:32;emilles;Yes indeed.  It is the chain assignment, specifically {{b.zero}} that has no position in the AST.

{code}
            class B {
              private String z
              void setZero(String zero) { z = zero }
            }

            @groovy.transform.CompileStatic
            class C {
              String x
              B b
              C() {
                x = b.zero = 'X'
              }
            }
{code};;;","02/Aug/19 14:45;daniel_sun;The proposed PR was merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,
Static compiling fails type checking with generics,GROOVY-8001,13021834,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,jmsotuyo,jmsotuyo,18/Nov/16 19:52,02/May/21 09:18,14/Jul/23 06:02,02/Apr/21 14:38,2.4.7,,,,,,,,4.0.0-alpha-3,,,,Static Type Checker,,,,0,,,,,,,"Given a property of type {{Map<String, Object>}} and the assignment:

{code}
myObject.property = ['myKey':""${buildDir}/file-cache""]
{code}

I get the following error:

{quote}
[Static type checking] - Cannot assign value of type java.util.LinkedHashMap <java.lang.String, groovy.lang.GString> to variable of type java.util.Map <java.lang.String, java.lang.Object>
{quote}

I have to manually cast the value to {{Object}} for it to work without warnings:

{code}
myObject.property = ['myKey': ""${buildDir}/file-cache"" as Object]
{code}

This should not be needed, since any object is a valid instance of {{Object}}",,emilles,jmsotuyo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 18 22:18:08 UTC 2016,,,,,,,,,,"0|i36iof:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Nov/16 21:59;emilles;I think this mirrors Java's handling of the same.  If you had {{Map<String,? extends Object>}} for property the assignment should succeed.  Or if you do the cast as you have indicated, you help the inferencing engine out to get to String, Object.  We have to do this same thing all the time when using Arrays.asList(), Collection.singletonMap(), and so on.;;;","18/Nov/16 22:09;jmsotuyo;The types for the {{LinkedHashMap}} are inferred by Groovy.

If I wrote:

{code}
['myKey': ""${buildDir}/file-cache"", 'otherKey': 4G]
{code}

It would be treated as a {{LinkedHashMap<String, Object>}}  and would work just as fine. The problem here is how Groovy is inferring the types for the Map.

I believe Groovy should (and can) look not only at the values, but how the variable is used to determine the used types when doing static compilation and either throw an error if a mismatch is found, or sort it out if it's possible.;;;","18/Nov/16 22:18;emilles;Sure, GString and BigDecimal will give you Object as the least upper bound type.  If you had {{[key1: ""GString"", key2: 'String']}} you'd get {{Map<String,CharSequence>}} not Object.  Java would infer this the same way.  Cast either value to Object and that will be the least upper bound.  Java and Groovy can't do much more than they are already doing because you don't always have a nicely typed item on the left hand side of the assignment.;;;",,,,,,,,,,,,,,,,,,,
Problem With Trait Generics,GROOVY-8000,13021167,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,jeffscottbrown,jeffscottbrown,16/Nov/16 15:14,11/Nov/20 02:01,14/Jul/23 06:02,12/Sep/20 22:45,2.4.7,,,,,,,,3.0.6,4.0.0-alpha-1,,,,,,,1,,,,,,,"The project at https://github.com/jeffbrown/generictraits contains the following:

{code:title=src/main/groovy/demo/TopTrait.groovy|borderStyle=solid}
package demo

trait TopTrait<T> {
    T getSomething() {}
}
{code}

{code:title=src/main/groovy/demo/MiddleTrait.groovy|borderStyle=solid}
package demo

trait MiddleTrait<T> implements TopTrait<T> {}
{code}

{code:title=src/main/groovy/demo/BottomTrait.groovy|borderStyle=solid}
package demo

trait BottomTrait<T> implements MiddleTrait<T> {}
{code}

{code:title=src/main/groovy/demo/Demo.groovy|borderStyle=solid}
package demo

// if this class implements MiddleTrait instead
// of BottomTrait, it will compile...
class Demo implements BottomTrait<String> {}
{code}

{noformat}
 $ ./gradlew clean cG
:clean
:compileJava UP-TO-DATE
:compileGroovy
startup failed:
/Users/jeff/t/generictraits/src/main/groovy/demo/Demo.groovy: -1: The return type of java.lang.Object getSomething() in demo.Demo is incompatible with java.lang.String in demo.TopTrait
. At [-1:-1]  @ line -1, column -1.
1 error

:compileGroovy FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileGroovy'.
> Compilation failed; see the compiler error output for details.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 2.123 secs
{noformat}



",,emilles,jeffscottbrown,paulk,,,,,,"eric-milles opened a new pull request #1347:
URL: https://github.com/apache/groovy/pull/1347


   https://issues.apache.org/jira/browse/GROOVY-8000


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Aug/20 19:37;githubbot;600","eric-milles merged pull request #1347:
URL: https://github.com/apache/groovy/pull/1347


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Aug/20 22:26;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1200,,,0,1200,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Sep 12 22:45:42 UTC 2020,,,,,,,,,,"0|i36ek7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Sep/20 22:45;paulk;Proposed PR merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,,,
calling method having a Bigdecimal parameter with a long produces incorrect bigdecimal,GROOVY-7997,13019810,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,aalmiray,detlef_brendle,detlef_brendle,10/Nov/16 12:00,01/Feb/17 23:19,14/Jul/23 06:02,15/Nov/16 19:18,2.4.6,,,,,,,,2.4.8,,,,groovy-jdk,groovy-runtime,,,0,,,,,,,"Assume the following example:
{code}
def x = Random.newInstance().nextLong()

def asBigDecimal(BigDecimal bd){
    println ""bigdecimal value is $bd""
}

println ""long value is $x""
asBigDecimal(x)
{code}
This will produce two different print outs.
My expecation is that the printed numbers are equal.",linux,blackdrag,detlef_brendle,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Nov 15 19:18:41 UTC 2016,,,,,,,,,,"0|i3666n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Nov/16 19:18;blackdrag;fixed in Hackergarten Basel;;;",,,,,,,,,,,,,,,,,,,,,
Using with method with a closure that references a protected property produces ClassCastException,GROOVY-7996,13019806,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,graemerocher1,graemerocher1,10/Nov/16 11:40,10/Aug/20 15:03,14/Jul/23 06:02,21/Nov/19 15:16,2.4.7,,,,,,,,2.5.9,3.0.0-rc-2,,,,,,,0,,,,,,,"The following example:

{code}
class Foo {
    Object propertyMissing(String name) {
         return ""stuff""
    }
    
    void build(Closure callable) {
         this.with(callable)
    }
}

@groovy.transform.CompileStatic
class Bar {
    protected List bar = []
    
    boolean doStuff() {
        Foo foo = new Foo()
        foo.build {
           return bar.isEmpty() 
        }
    }
}

new Bar().doStuff()
{code}

Produces 

{code}
java.lang.ClassCastException: java.lang.String cannot be cast to java.util.List
	at Bar$_doStuff_closure1.doCall(ConsoleScript3:19)
	at Bar$_doStuff_closure1.call(ConsoleScript3)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.with(DefaultGroovyMethods.java:242)
	at Bar.doStuff(ConsoleScript3:18)
	at Ba
{code}

The equivalent code without CompileStatic prints:

{code}
Result: false
{code}

The behaviour of both should be he same IMO",,daniel_sun,emilles,graemerocher1,paulk,,,,,"paulk-asert commented on pull request #857: GROOVY-7996: Using with method with a closure that references a prote…
URL: https://github.com/apache/groovy/pull/857
 
 
   …cted property produces ClassCastException
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;21/Jan/19 03:17;githubbot;600","asfgit commented on pull request #857: GROOVY-7996: Using with method with a closure that references a prote…
URL: https://github.com/apache/groovy/pull/857
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;22/Jan/19 01:17;githubbot;600","eric-milles commented on issue #857: GROOVY-7996: Using with method with a closure that references a prote…
URL: https://github.com/apache/groovy/pull/857#issuecomment-484662202
 
 
   This change breaks down if an additional level of closure is inserted.  The implicit this is transformed into a path expression in `StaticTypeCheckingVisitor.existsProperty`.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Apr/19 19:47;githubbot;600","eric-milles commented on pull request #1051: GROOVY-7996: check for get(String)/set(String,Object) or propertyMissing
URL: https://github.com/apache/groovy/pull/1051
 
 
   Here is another take on 7996.  Closure delegate implements propertyMissing and owner has field.  Submitter expects propertyMissing to be respected since resolve strategy is DELEGATE_FIRST.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;29/Oct/19 20:21;githubbot;600","danielsun1106 commented on pull request #1051: GROOVY-7996: check for get(String)/set(String,Object) or propertyMissing
URL: https://github.com/apache/groovy/pull/1051
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Nov/19 04:59;githubbot;600","danielsun1106 commented on issue #1051: GROOVY-7996: check for get(String)/set(String,Object) or propertyMissing
URL: https://github.com/apache/groovy/pull/1051#issuecomment-552066839
 
 
   Merged. Thanks.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Nov/19 05:00;githubbot;600","eric-milles commented on pull request #1088: GROOVY-7996: check for get(String)/set(String,Object) or propertyMissing
URL: https://github.com/apache/groovy/pull/1088
 
 
   roll back some of the [initial changes](https://github.com/apache/groovy/commit/8ab86fe9c6dd61767d90425d103d33d741b82fe2)
   
   (Groovy 2.5 backport)
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;15/Nov/19 20:08;githubbot;600","paulk-asert commented on issue #1088: GROOVY-7996: check for get(String)/set(String,Object) or propertyMissing (Groovy 2.5 backport)
URL: https://github.com/apache/groovy/pull/1088#issuecomment-554638610
 
 
   Merged. Thanks. Please feel free to close this PR. I have left the Jira issue as is (reopened) since after the rollback, the initial example in the issue is breaking again even after this PR. Is that also your expectation? Perhaps we need to add that testcase in and marked as NotYetImplemented?
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Nov/19 13:42;githubbot;600","eric-milles commented on pull request #1088: GROOVY-7996: check for get(String)/set(String,Object) or propertyMissing (Groovy 2.5 backport)
URL: https://github.com/apache/groovy/pull/1088
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Nov/19 14:55;githubbot;600","eric-milles opened a new pull request #1303:
URL: https://github.com/apache/groovy/pull/1303


   Provide the user some clue that runtime behavior will not match declared
   behavior (in explicit or implicit @DelegatesTo metadata).
   
   ![image](https://user-images.githubusercontent.com/18193802/86957817-ded77d80-c120-11ea-85b3-353691b01079.png)
   
   https://issues.apache.org/jira/browse/GROOVY-7996
   https://issues.apache.org/jira/browse/GROOVY-7597


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;08/Jul/20 18:42;githubbot;600","paulk-asert commented on a change in pull request #1303:
URL: https://github.com/apache/groovy/pull/1303#discussion_r452115482



##########
File path: src/test/org/codehaus/groovy/classgen/asm/sc/DelegatesToStaticCompileTest.groovy
##########
@@ -111,4 +111,29 @@ class DelegatesToStaticCompileTest extends DelegatesToSTCTest implements StaticC
             assert !bytecode.contains('INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType')
         }
     }
-}
\ No newline at end of file
+
+    // GROOVY-7996
+    void testErrorForMismatchedClosureResolveStrategy() {
+        shouldFailWithMessages '''
+            class Foo {
+                def build(Closure x) { // resolve strategy OWNER_FIRST
+                    this.with(x) // resolve strategy DELEGATE_FIRST
+                }
+                def propertyMissing(String name) {
+                    'something'
+                }
+            }
+
+            class Bar {
+                protected List bars = []
+                def baz() {
+                    new Foo().build {
+                        bars.isEmpty() // fails if executed; delegate's propertyMissing takes precedence
+                    }
+                }
+            }
+
+            new Bar().baz()
+        ''', 'Closure parameter with resolve strategy 0 passed to method with resolve strategy 1'

Review comment:
       I'd suggest we need a `getResolveStrategyAsString()` method to make these more meaningful.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Jul/20 10:19;githubbot;600","eric-milles commented on a change in pull request #1303:
URL: https://github.com/apache/groovy/pull/1303#discussion_r452412460



##########
File path: src/test/org/codehaus/groovy/classgen/asm/sc/DelegatesToStaticCompileTest.groovy
##########
@@ -111,4 +111,29 @@ class DelegatesToStaticCompileTest extends DelegatesToSTCTest implements StaticC
             assert !bytecode.contains('INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.castToType')
         }
     }
-}
\ No newline at end of file
+
+    // GROOVY-7996
+    void testErrorForMismatchedClosureResolveStrategy() {
+        shouldFailWithMessages '''
+            class Foo {
+                def build(Closure x) { // resolve strategy OWNER_FIRST
+                    this.with(x) // resolve strategy DELEGATE_FIRST
+                }
+                def propertyMissing(String name) {
+                    'something'
+                }
+            }
+
+            class Bar {
+                protected List bars = []
+                def baz() {
+                    new Foo().build {
+                        bars.isEmpty() // fails if executed; delegate's propertyMissing takes precedence
+                    }
+                }
+            }
+
+            new Bar().baz()
+        ''', 'Closure parameter with resolve strategy 0 passed to method with resolve strategy 1'

Review comment:
       Added method to ClosureUtils and moved the test so it is tried for `@CompileStatic` and `@TypeChecked`.




----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;09/Jul/20 18:32;githubbot;600","asfgit closed pull request #1303:
URL: https://github.com/apache/groovy/pull/1303


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Jul/20 13:22;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,0,7800,,,0,7800,,,,,,,,,,,GROOVY-9063,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 10 15:03:13 UTC 2020,,,,,,,,,,"0|i3665r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Nov/16 11:58;paulk;I haven't looked into why yet but if the bar field is protected or public you get the error. Workarounds are to make it a normal property (no visibility modifier) or private. Obviously, might not be ideal or work for you depending on your scenario.;;;","22/Jan/19 04:44;paulk;Proposed PR merged. Workaround is to use `owner.bar.isEmpty()` or `this.bar.isEmpty()`;;;","18/Apr/19 19:29;emilles;Since {{void build(Closure callable)}} does not have a {{@DelegatesTo}} annotation, it is indicating that the resolve strategy of the closure will be {{OWNER_FIRST}} (the default value).  However, you have called the closure using {{DefaultGroovyMethods.with}}, which has a closure resolve strategy of {{DELEGATE_FIRST}}.

I believe that the compiler expects a {{List}} because that is what the owner provides for ""bar"", however {{with}} is trying to resolve ""bar"" against the delegate which is a {{Foo}}.  As part of this, looks like {{propertyMissing}} is getting invoked.;;;","18/Apr/19 20:03;emilles;If written this way, no error occurs on Groovy 2.4:
{code}
class Foo {
  def propertyMissing(String name) {
    return 'stuff'
  }
  def build(@DelegatesTo(value=Foo, strategy=Closure.OWNER_FIRST) Closure block) {
    block.delegate = this
    return block.call()
  }
}

@groovy.transform.CompileStatic
class Bar {
  protected List bars = []
  boolean doStuff() {
    new Foo().build {
      return bars.isEmpty()
    }
  }
}
{code}
This should return {{true}} for {{new Bar().doStuff()}} since {{build}} now returns the value returned from the closure.;;;","18/Apr/19 21:12;emilles;{{VariableScopeVisitor.checkVariableNameForDeclaration}} thinks ""bars"" refers to a field and that never gets changed.  Any variable expression within a closure that does not resolve to a local variable should be assumed to be dynamic, correct?;;;","27/Oct/19 15:46;emilles;Rolling back initial changes for this issue.  There were a number of other issues created by this and I think the case of a delegate having the same property name as an owner field is a bit less likely of a use case than the others.  Also, there are at east 2 workarounds available for this issue: 1) specify the closure as OWNER_FIRST and 2) use ""owner"" or ""thisObject"" or ""this"" qualifier on field access.

A number of test cases have been added so if a fix is approached for this again, there will be less chance of breaking other closure variable expression access scenarios.;;;","28/Oct/19 19:46;emilles;This is a bit of an experiment.  If the initial issue is re-written this way (cut from unit test) and if I add to {{StaticTypeCheckingVisitor#existsProperty}} checks for dynamic property resolution (see below), then the test case will indeed run through {{Foo#propertyMissing}} and there will be no {{ClassCastException}}.

{code:java}
            ""Foo.groovy"",
            ""class Foo {\n"" +
            ""  def build(@DelegatesTo(value=Foo, strategy=Closure.DELEGATE_FIRST) Closure<?> block) {\n"" +
            ""    return this.with(block)\n"" +
            ""  }\n"" +
            ""  def propertyMissing(String name) {\n"" +
            ""    return 'stuff'\n"" +
            ""  }\n"" +
            ""}\n"",

            ""Bar.groovy"",
            ""@groovy.transform.CompileStatic\n"" +
            ""class Bar {\n"" +
            ""  protected List<?> bars = []\n"" +
            ""  def doStuff() {\n"" +
            ""    new Foo().build {\n"" +
            ""      return bars.toString()\n"" +
            ""    }\n"" +
            ""  }\n"" +
            ""}\n"",

            ""Main.groovy"",
            ""assert new Bar().doStuff() == 'stuff'\n"",
{code}

StaticTypeCheckingVisitor:
{code:java}
// TODO: What if receiver implements get(String)/set(String,Object), getProperty(String)/setProperty(String,Object) or propertyMissing(String)?
if (!isPrimitiveType(getUnwrapper(testClass)) && objectExpression instanceof VariableExpression && typeCheckingContext.getEnclosingClosure() != null) {
    MethodNode mopMethod;
    if (readMode) {
        mopMethod = testClass.getMethod(""getProperty"", new Parameter[]{new Parameter(STRING_TYPE, ""name"")});
        if (mopMethod == null) mopMethod = testClass.getMethod(""get"", new Parameter[]{new Parameter(STRING_TYPE, ""name"")});
    } else {
        mopMethod = testClass.getMethod(""setProperty"", new Parameter[]{new Parameter(STRING_TYPE, ""name""), new Parameter(OBJECT_TYPE, ""value"")});
        if (mopMethod == null) mopMethod = testClass.getMethod(""set"", new Parameter[]{new Parameter(STRING_TYPE, ""name""), new Parameter(OBJECT_TYPE, ""value"")});
    }
    if (mopMethod == null) mopMethod = testClass.getMethod(""propertyMissing"", new Parameter[]{new Parameter(STRING_TYPE, ""name"")});

    if (mopMethod != null) {
        pexp.putNodeMetaData(DYNAMIC_RESOLUTION, Boolean.TRUE);
        pexp.removeNodeMetaData(DECLARATION_INFERRED_TYPE);
        pexp.removeNodeMetaData(INFERRED_TYPE);
        return true;
    }
}
{code};;;","08/Aug/20 10:44;paulk;I know this was a while ago, but in hindsight, I probably would have placed the methodMissing/get/set part of the fix into its own type checker extension, perhaps {{MopAwareChecker}}. That part of the current ""fix"" doesn't work for instance outside closures, e.g.:
{code:java}
@groovy.transform.CompileStatic
class Foo {
    int a = 40
    def main() {
        a + (int)b
    }
    def propertyMissing(String name) {
        2
    }
}
def foo = new Foo()
assert foo.main() == 42
{code}
Nor for method calls.;;;","10/Aug/20 13:44;emilles;[~paulk] Could you open a new ticket that references this one and describes the idea a bit more?  I'm familiar with {{StaticTypeCheckingVisitor}}, but not {{MopAwareChecker}}.  Is that something that is registered by default or would the user be expected to add the checking extension?  If available by default, are there other checks made by STCV that could be spun off to separate checker class?;;;","10/Aug/20 14:50;paulk;{{MopAwareChecker}} is just an idea - we'd need to work through the details. If we fix all of the type checker to be consistent with the GROOVY-7996 property handling, then any class with propertyMissing or methodMissing suddenly has a huge whole in its checking - basically any property or any method would be permitted. Some folks might not want to forgo that much checking. A type checking extension would allow it to be opt in - yes, currently it would need to be explicitly added in, e.g. {{@TypeChecked(extensions='MopAwareChecker')}}.;;;","10/Aug/20 15:03;emilles;Oh, I see.  So an enhancement that moves the checks to an optional component.;;;",,,,,,,,,,,
Short syntax of closure call invokes wrong closure if wrapped in another closure and @CompileStatic is applied,GROOVY-7995,13019638,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,krzysztof.kowalczyk,krzysztof.kowalczyk,09/Nov/16 20:09,06/Mar/18 23:25,14/Jul/23 06:02,12/Aug/17 17:45,2.4.7,,,,,,,,2.4.13,,,,Static compilation,,,,0,,,,,,,"The following would fail:

{code}
​import groovy.transform.CompileStatic

@CompileStatic
class Foo {
     Closure c = { ""ok"" }
     Closure wrap = {
         c()
     }

     def run(){
         wrap()
     }
}

assert new Foo().run()​ == ""ok""  // stack overflow
{code}

It works fine without CompileStatic or if invokation is done by c.call()",,githubbot,jwagenleitner,krzysztof.kowalczyk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 12 17:45:11 UTC 2017,,,,,,,,,,"0|i3654f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Nov/16 15:56;githubbot;GitHub user blindpirate opened a pull request:

    https://github.com/apache/groovy/pull/460

    GROOVY-7995: Short syntax of closure call invokes wrong closure if wrapped in another closure and @CompileStatic is applied

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/blindpirate/groovy groovy7995

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/460.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #460
    
----
commit b2d84738986fc83a589e78ec205bb206318a1e4a
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-09-16T00:29:11Z

    GROOVY-7922: Static type checking not strict enough in the presence of ambiguous method matching

commit be6396148d10f3a26983a0b93022639cf02a7839
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-09-16T14:27:50Z

    remove comment: GROOVY-6970

commit f5be26b2b747659a325b3d87cd3986e3373bd465
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-09-17T01:14:17Z

    use ParameterUtils method instead

commit 815e76b43a539a4c9e8cf3f8a1a2ff5fea13d55d
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-09-18T06:54:52Z

    refactor to move redundant parameters

commit 65e9fd1db1776b506a56ea9ebb1fce4097973b52
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-11-02T13:46:23Z

    resolve conflict

commit bc2d8374c06215a0adadd2bf507c29d928111df5
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-11-10T02:54:21Z

    Merge remote-tracking branch 'upstream/master'

commit 07cd803c5ca7c4e9916d431da5c9edcdb7cf9853
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-11-10T15:55:10Z

    fix groovy7995: CLOSURE_NO_ARG and CLOSURE_ONE_ARG are never used.

----
;;;","11/Nov/16 03:20;githubbot;Github user blindpirate closed the pull request at:

    https://github.com/apache/groovy/pull/460
;;;","11/Nov/16 03:20;githubbot;GitHub user blindpirate reopened a pull request:

    https://github.com/apache/groovy/pull/460

    GROOVY-7995: Short syntax of closure call invokes wrong closure if wrapped in another closure and @CompileStatic is applied

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/blindpirate/groovy groovy7995

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/460.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #460
    
----
commit b2d84738986fc83a589e78ec205bb206318a1e4a
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-09-16T00:29:11Z

    GROOVY-7922: Static type checking not strict enough in the presence of ambiguous method matching

commit be6396148d10f3a26983a0b93022639cf02a7839
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-09-16T14:27:50Z

    remove comment: GROOVY-6970

commit f5be26b2b747659a325b3d87cd3986e3373bd465
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-09-17T01:14:17Z

    use ParameterUtils method instead

commit 815e76b43a539a4c9e8cf3f8a1a2ff5fea13d55d
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-09-18T06:54:52Z

    refactor to move redundant parameters

commit 65e9fd1db1776b506a56ea9ebb1fce4097973b52
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-11-02T13:46:23Z

    resolve conflict

commit bc2d8374c06215a0adadd2bf507c29d928111df5
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-11-10T02:54:21Z

    Merge remote-tracking branch 'upstream/master'

commit 07cd803c5ca7c4e9916d431da5c9edcdb7cf9853
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-11-10T15:55:10Z

    fix groovy7995: CLOSURE_NO_ARG and CLOSURE_ONE_ARG are never used.

----
;;;","22/Jul/17 17:15;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/576

    GROOVY-7995: @CS closure call from closure

    Short syntax of closure call invokes wrong closure if wrapped in another
    closure. This fix includes a combination of the contributed commit from
    PR #460 along with the patch (see PR comments) provided by Jochen.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy pr460

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/576.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #576
    
----
commit 8916d43f298d26814c664555cae1a800e2cbfe5b
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2017-07-22T17:06:21Z

    GROOVY-7995: @CS closure call from closure
    
    Short syntax of closure call invokes wrong closure if wrapped in another
    closure. This fix includes a combination of the contributed commit from
    PR #460 along with the patch (see PR comments) provided by Jochen.
    
    Thanks for @blindpirate for the contribution.

----
;;;","12/Aug/17 16:36;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/460
;;;","12/Aug/17 16:36;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/576
;;;","12/Aug/17 17:45;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,
Anonymous inner class believes protected method in parent's superclass returns Object,GROOVY-7994,13019213,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,Schlogen,Schlogen,08/Nov/16 14:12,01/Feb/17 23:19,14/Jul/23 06:02,16/Nov/16 16:27,2.4.7,,,,,,,,2.4.8,,,,groovy-runtime,,,,0,,,,,,,"The below will execute the constructor on `Other` that takes an `Object`, even though `getName()` returns a `String`.

{code}
import groovy.transform.CompileStatic

@CompileStatic
class Parent {
    protected String getName() {
        ""sally""
    }
}

@CompileStatic
class Child extends Parent {

    Inner doSomething() {
        return new Inner() {
            void go() {
                new Other(name)
            }
        }
    }

}

@CompileStatic
class Other {
    Other(Object object) {
        println ""called with other""
    }
    Other(String string) {
        println ""called with string""
    }
}

@CompileStatic
abstract class Inner {
    abstract void go()
}

Inner inner = new Child().doSomething()
inner.go()
{code}",,githubbot,paulk,Schlogen,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Nov 16 16:27:57 UTC 2016,,,,,,,,,,"0|i362i7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Nov/16 00:51;paulk;This looks like an issue with properties referenced from inner classes. The workaround is to use the full property accessor: {{getName()}} instead of {{name}} or in very recent builds you can use {{Outer.this.name}}. for the example below.;;;","09/Nov/16 09:44;paulk;A slightly revised snippet showing that normal and anonymous inner classes are affected:
{code}
import groovy.transform.CompileStatic

@CompileStatic
class Outer {
    String getName() { ""sally"" }
    class Inner {
        String igo() { new Other(name).text + new Other(getName()).text }
    }
    def makeAIC() {
        println new Other(name).text + new Other(getName()).text
        new Object() {
            String go() { new Other(name).text + new Other(getName()).text }
        }
    }
}

@CompileStatic
class Other {
    public final String text
    Other(Object object) { text = ""Object:$object|"" }
    Other(String string) { text = ""String:$string|"" }
}

def o = new Outer()
println o.makeAIC().go()
println new Outer.Inner(o).igo()
{code}
Current result:
{noformat}
String:sally|String:sally|
Object:sally|String:sally|
Object:sally|String:sally|
{noformat};;;","10/Nov/16 06:32;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/459

    GROOVY-7994: Anonymous inner class believes protected method in paren…

    …t's superclass returns Object

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7994

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/459.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #459
    
----
commit b047e0961032b169c2f884d60f28e1c32e37135d
Author: paulk <paulk@asert.com.au>
Date:   2016-11-10T06:31:46Z

    GROOVY-7994: Anonymous inner class believes protected method in parent's superclass returns Object

----
;;;","10/Nov/16 21:13;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/459
;;;","16/Nov/16 16:27;paulk;Proposed PR merged. Thanks for raising the issue.;;;",,,,,,,,,,,,,,,,,
Sort methods that accept a comparator should accept Comparator<? super T> (fix type checker ability to cope with super in DGM methods),GROOVY-7992,13018709,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,mauromol,paulk,06/Nov/16 23:46,10/Feb/23 21:39,14/Jul/23 06:02,10/Dec/22 17:32,2.4.7,,,,,,,,4.0.7,,,,groovy-jdk,,,,0,,,,,,,"Methods like {{org.codehaus.groovy.runtime.DefaultGroovyMethods.sort(Iterable<T>, boolean, Comparator<T>)}} and all the others alike should be changed to accept a {{Comparator<? super T>}}, otherwise if you use {{@CompileStatic}} you'll get compiler errors as soon as you try to sort an Iterable/Collection using a comparator that accept superclass instances.",,emilles,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7976,,,,,,,,,GROOVY-9762,GROOVY-9803,GROOVY-9998,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Dec 10 17:32:27 UTC 2022,,,,,,,,,,"0|i35zdz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Nov/16 23:48;paulk;I cloned the issue to split out the two parts: the DGM signature fix and the type checker fix. Mainly in case both parts don't end up being resolved in the same release.;;;","03/Sep/22 02:22;githubbot;eric-milles opened a new pull request, #1779:
URL: https://github.com/apache/groovy/pull/1779

   https://issues.apache.org/jira/browse/GROOVY-7992


;;;","17/Sep/22 08:51;githubbot;daniellansun merged PR #1779:
URL: https://github.com/apache/groovy/pull/1779


;;;","17/Sep/22 08:51;githubbot;daniellansun commented on PR #1779:
URL: https://github.com/apache/groovy/pull/1779#issuecomment-1250031627

   Merged. Thanks.


;;;","10/Dec/22 17:32;emilles;https://github.com/apache/groovy/commit/326bd57de38dce7d7221193ec4594ec6f637bc62;;;",,,,,,,,,,,,,,,,,
VerifyError when calling protected method #clone(),GROOVY-7989,13017754,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,wu-lee,wu-lee,03/Nov/16 17:26,08/Mar/22 12:16,14/Jul/23 06:02,30/Mar/21 15:10,2.4.5,2.4.7,,,,,,,,,,,Static compilation,,,,0,,,,,,,"Running this demo code reproduces the error:

{code}
import groovy.transform.CompileStatic

@CompileStatic
class Foo {
	static {
        List list = []
        list.clone()
	}
}
{code}

This works when @CompileStatic is off, but when it is on, the compiler throws. It seems suspiciously low level - yes, Map#clone is protected and therefore inaccessible in this context, but obviously one would want something more user-friendly than this, not least because it doesn't indicate *where* the error is, so finding it can be tricky:

{code}
Caught: java.lang.VerifyError: (class: Foo, method: <clinit> signature: ()V) Bad access to protected data
java.lang.VerifyError: (class: Foo, method: <clinit> signature: ()V) Bad access to protected data
{code}
","Ubuntu Precise
x86_64 arch
Java 1.8.0_91",paulk,wu-lee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Nov 04 05:30:43 UTC 2016,,,,,,,,,,"0|i35thz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Nov/16 05:30;paulk;This seems to be already fixed on the master branch (targeted for 2.5) but not the 2_4_X branch.;;;",,,,,,,,,,,,,,,,,,,,,
Type checker doesn't flag static method calls to instance methods with otherwise the same signature,GROOVY-7987,13017063,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,02/Nov/16 01:27,16/Feb/23 18:53,14/Jul/23 06:02,06/Nov/16 23:42,,,,,,,,,2.4.8,,,,Static Type Checker,,,,0,,,,,,,"Example code which fails at runtime but should fail at compile time:
{code}
class Foo {
  def bar() {}
}

@groovy.transform.TypeChecked // MME at runtime, the same as dynamic groovy
//@groovy.transform.CompileStatic // would give GroovyCastException at runtime
def method() {
  Foo.bar()
}

method()
{code}",,djperano,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10939,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Nov 06 23:42:28 UTC 2016,,,,,,,,,,"0|i35p8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Nov/16 06:18;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/456

    GROOVY-7987: Type checker doesn't flag static method calls to instanc…

    …e methods with otherwise the same signature

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7987

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/456.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #456
    
----
commit f9e6fd9f1be5f6ee3e63414fdb0994743c32b97f
Author: paulk <paulk@asert.com.au>
Date:   2016-11-02T06:17:25Z

    GROOVY-7987: Type checker doesn't flag static method calls to instance methods with otherwise the same signature

----
;;;","06/Nov/16 23:37;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/456
;;;","06/Nov/16 23:42;paulk;Proposed PR merged.;;;",,,,,,,,,,,,,,,,,,,
Map sort gives an error : Comparison method violates its general contract!,GROOVY-7986,13016842,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,victus,victus,01/Nov/16 09:34,10/Dec/16 19:09,14/Jul/23 06:02,02/Nov/16 01:24,2.3.10,2.4.6,,,,,,,2.4.7,,,,Groovy Console,,,,0,newbie,,,,,,"Trying to sort of a map gives an error.
Code
{code}
usersPredictions = [guest697:[4, 10], guest809:[1, 6], guest993:[3, 6], guest785:[4, 15], guest893:[6, 6], guest399:[1, 6], guest206:[1, 7], guest202:[5, 7], admin:[4, 3], guest285:[1, 3], flo:[8, 52], guest753:[2, 3], guest635:[4, 3], guest754:[3, 11], guest024:[0, 4], guest971:[0, 5], guest824:[0, 6], guest295:[0, 6], guest421:[0, 6], guest389:[0, 6], guest095:[0, 7], guest000:[0, 6], guest430:[0,6], guest985:[0, 6], guest618:[0, 6], guest108:[0, 10], guest820:[0, 6], guest586:[0, 10], guest959:[0, 6], guest525:[0, 4], guest191:[0, 4], guest567:[0, 4], guest780:[0, 4], guest704:[0, 4], guest263:[0, 4], guest212:[0, 4], guest576:[0,4], guest494:[0, 4], guest378:[0, 4], guest589:[0, 4], guest507:[0, 4], guest580:[0, 4], guest396:[0, 4], guest879:[0, 4], guest647:[0, 4], guest128:[0, 4], guest234:[0, 10], guest040:[0, 4], guest510:[0, 10], guest583:[0, 4], guest247:[0,4], guest500:[0, 4], guest055:[0, 4], guest322:[0, 4], guest972:[0, 4], guest522:[0, 4], guest207:[0, 4], guest348:[0, 4], guest020:[0, 4], guest621:[0, 4], guest981:[0, 4], guest939:[0, 4], guest280:[0, 4], guest827:[0, 4], guest671:[0, 4], guest317:[0, 4], guest859:[0, 4], guest456:[0, 5], guest731:[0, 5], guest738:[0, 5], guest076:[0, 5], guest713:[0, 5], guest652:[0, 5], guest693:[0, 5], guest330:[0, 11], guest760:[0, 5], guest935:[0, 5], guest370:[0, 5], guest148:[0, 5], guest806:[0, 5], guest302:[0, 5], guest438:[0, 5], guest769:[0, 5], guest775:[0, 5], guest845:[0, 5], guest730:[0, 6], guest405:[0, 3], guest955:[0, 5], guest819:[0, 3], guest732:[0, 3], guest440:[0, 3], guest104:[0, 3], guest155:[0, 4], guest219:[0, 5], guest070:[0, 3], guest490:[0, 5], guest764:[0, 6], guest442:[0,6], guest067:[0, 6], guest185:[0, 6], guest484:[0, 6], guest739:[0, 6], guest073:[0, 6], guest179:[0, 6], guest275:[0, 6], guest631:[0, 6], guest755:[0, 6], guest221:[0, 6], guest232:[0, 6], guest152:[0, 6], guest485:[0, 6], guest911:[0, 6], guest925:[0, 6], guest626:[0, 6], guest675:[0, 3], guest457:[0, 4], guest923:[0, 4], guest605:[0, 3], guest624:[0, 4]]
println usersPredictions.sort {it.value}
{code}

Error:
{noformat}
Caught: java.lang.IllegalArgumentException: Comparison method violates its general contract!
java.lang.IllegalArgumentException: Comparison method violates its general contract!
	at indent.run(indent.groovy:124)
{noformat}

Removing some of the values - resolves the issue. In Online groovy console and version 1.8.6 this code is working without error.",,paulk,victus,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Nov 03 12:02:17 UTC 2016,,,,,,,,,,"0|i35nvr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Nov/16 23:50;paulk;Seems to be fixed in 2.4.7 due to one of these two fixes: GROOVY-7530, GROOVY-7602;;;","02/Nov/16 01:24;paulk;I'll mark as fixed in 2.4.7 but if you disagree, please reopen.;;;","03/Nov/16 12:02;victus;Yeah I've checked and it's fixed now. Thank you!;;;",,,,,,,,,,,,,,,,,,,
"Wrong ""incompatible generic type"" error",GROOVY-7985,13016652,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,mauromol,mauromol,31/Oct/16 16:49,13/Dec/19 22:41,14/Jul/23 06:02,11/May/18 06:12,2.4.7,,,,,,,,2.4.18,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,Static Type Checker,,,,1,,,,,,,"Consider the following:

{code}
package test;

import java.io.Serializable;

public final class Pair<L, R> implements Serializable {

	public static <L, R> Pair<L, R> of(final L left, final R right) {
		return new Pair<>(left, right);
	}

	public final L left;
	public final R right;

	private Pair(final L left, final R right) {
		this.left = left;
		this.right = right;
	}
}
{code}

And the following Groovy class:

{code}
package test2

import test.Pair

import java.util.Date;

import groovy.transform.CompileStatic

@CompileStatic
class Test {

	Pair<Pair<Integer, Pair<String, Date>>, Pair<Integer, Pair<String, Date>>> doSmething() {
		def left = (Pair<Integer, Pair<String, Date>>) null
		def right = (Pair<Integer, Pair<String, Date>>) null
		return Pair.of(left, right)
	}
}
{code}

Compilation fails with the following error message:

{noformat}
[Static type checking] - Incompatible generic argument types. Cannot assign test.Pair <test.Pair, test.Pair> to: test.Pair <Pair, Pair>
 @ line 15, column 10.
                return Pair.of(left, right)
{noformat}",,daniel_sun,jwagenleitner,mauromol,mwilkowski,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 11 06:12:14 UTC 2018,,,,,,,,,,"0|i35mpr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Feb/17 11:55;mwilkowski;Another example:

{code:title=GroovyFunctionTypeInferenceTest|borderStyle=solid}
import groovy.transform.CompileStatic
import org.apache.commons.lang3.tuple.Pair
import org.junit.Test
import java.util.function.Function

@CompileStatic
class GroovyFunctionTypeInferenceTest {
  @Test
  void functionWithoutPairTest() {
    // some function that operates on list and returns an element of this list
    Function<List<String>, String> function =
        { List<Pair<String, Integer>> it -> it[0] } as Function
    def list = new ArrayList<String>()
    function.apply(list)
  }

  @Test
  void functionWithPair1Test() {
    // some function that operates on list and returns an element of this list
    Function<List<Pair>, Pair> function =
        { List<Pair<String, Integer>> it -> it[0] } as Function
    def list = new ArrayList<Pair>()
    function.apply(list)
  }

  @Test
  void functionWithPair2Test() {
    // some function that operates on list and returns an element of this list
    Function<List<Pair<String, Integer>>, Pair<String, Integer>> function =
        { List<Pair<String, Integer>> it -> it[0] } as Function
    def list = new ArrayList<Pair<String,Integer>>()
    function.apply(list)
  }
}
{code}

functionWithoutPairTest() and functionWithPair1Test() compile, functionWithPair2Test() fails with the following error:
{code}
Error:(36, -1) Groovy-Eclipse: Groovy:[Static type checking] - Incompatible generic argument types. Cannot assign java.util.function.Function <java.util.List, org.apache.commons.lang3.tuple.Pair> to: java.util.function.Function <List, Pair>
Error:(38, -1) Groovy-Eclipse: Groovy:[Static type checking] - Cannot call java.util.function.Function <java.util.List, org.apache.commons.lang3.tuple.Pair>#apply(java.util.List <Pair>) with arguments [java.util.ArrayList <Pair>]
{code};;;","11/May/18 06:12;daniel_sun;Fixed by https://github.com/apache/groovy/commit/9f14993d9e260a1277311fad78d13bd6f4c8c95f

As for the example in the comment, it relies on 3rd party lib, so I can not verify it right now. Please simplify it and file a new JIRA ticket. Thanks.;;;",,,,,,,,,,,,,,,,,,,,
JsonSlurper parses a single minus character as a number,GROOVY-7979,13016273,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,jwagenleitner,jwagenleitner,28/Oct/16 21:10,06/Mar/18 23:14,14/Jul/23 06:02,27/May/17 21:32,2.4.7,,,,,,,,2.4.12,,,,JSON,,,,0,,,,,,,"A minus sign not followed by some digits should fail parsing but succeeds.  The Character Source parser correctly throws an exception..

{code}
import groovy.json.*
import static groovy.json.JsonParserType.*

println new JsonSlurper().setType(CHAR_BUFFER).parseText('[-]') // [-45]
println new JsonSlurper().setType(INDEX_OVERLAY).parseText('[-]') // [-45]
println new JsonSlurper().setType(LAX).parseText('[-]') // [-45]

println new JsonSlurper().setType(CHARACTER_SOURCE).parseText('[-]') // throws JsonException
{code}

The parsers fail to recognize that no digits are appearing after the minus and end up calculating a value based on the next char value.  For example, the char value of {{]}} is 93 and that from the char value of {{0}} (48) is 45.",,DmitryKh,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 27 21:07:28 UTC 2017,,,,,,,,,,"0|i35kdj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/May/17 22:40;githubbot;GitHub user JamesLaverack opened a pull request:

    https://github.com/apache/groovy/pull/552

    GROOVY-7979: Prevent JsonSlurper issue on a single minus

    Add bound checking to JSON parser code to account for a single minus character.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/JamesLaverack/groovy groovy7979

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/552.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #552
    
----
commit 082535c3e0e0044ed7cb138dde68e296e39ea74c
Author: James Laverack <james@jameslaverack.com>
Date:   2017-05-13T12:38:34Z

    GROOVY-7979: Add JSONSlurper test case for the string ""[-]"".

commit ac2b8f0584c3cced23fa51690d7c7ab40c2c29d8
Author: James Laverack <james@jameslaverack.com>
Date:   2017-05-14T19:21:43Z

    GROOVY-7979: Add check for end of negative number
    
    The check for the minus sign increments the character index by one. A
    check is added to ensure that this does not go over the end of the
    expected character substring.

commit a550df60a0714898dc9bbbe6512d0da57973a373
Author: James Laverack <james@jameslaverack.com>
Date:   2017-05-26T21:10:44Z

    GROOVY-7979: Check for single minus in NumberValue
    
    This check is performed at the time of parsing, rather than while
    reading the return from `JsonSlurper`. The intent is that the slurper
    should, to the best of it's ability, give you a structure which is
    valid.

commit f0e65f1765dcebaa4b24f8be0506adcc281c78c7
Author: James Laverack <james@jameslaverack.com>
Date:   2017-05-26T21:15:21Z

    Remove pointless sign handling
    
    This code is useless as both of these code paths ultimately call out to
    `CharScanner#parseIntFromTo` which handles the negative sign.

----
;;;","27/May/17 21:07;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/552
;;;",,,,,,,,,,,,,,,,,,,,
Code containing post-decrement in an assert can cause a VerifyError on instantiation,GROOVY-7978,13016153,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,wu-lee,wu-lee,28/Oct/16 13:19,08/Mar/22 12:16,14/Jul/23 06:02,30/Mar/21 15:10,2.4.5,2.4.7,,,,,,,,,,,,,,,0,,,,,,,"The program below attempts to show a minimal example. It fails with a VerifyError when an instance of class Bad is constructed. Removing the post-increment or the assert, or making it @CompileStatic makes the error go away.

{code}
// VerifyErrorExample.groovy
import groovy.transform.CompileStatic


class Bad {
	private int counter = 0;
	
	void bar() {
		assert (this.counter++) // Something about the post-decrement in an assert causes a VerifyError
	}
};

@CompileStatic
class Good {
	private int counter = 0;
	
	void bar() {
		assert (this.counter++) // This is fine
	}
};

println ""Java: ${System.getProperty('java.version')}, Groovy: ${GroovySystem.version}""
new Good();
println ""made a good""
new Bad();
println ""made a bad""

{code}

The error looks like this:
{code}
 $ groovy VerifyErrorExample.groovy
Java: 1.8.0_91, Groovy: 2.4.7
made a good
Caught: java.lang.VerifyError: (class: Bad, method: bar signature: ()V) Expecting to find integer on stack
java.lang.VerifyError: (class: Bad, method: bar signature: ()V) Expecting to find integer on stack
	at VerifyErrorExample.run(VerifyErrorExample.groovy:24)
{code}

I've seen other errors of a similar sort, which I've not been able to boil down to a short example like this, but one I can remember seemed to be the result of code which use a void method in an if-condition (which the compiler didn't warn about), something like this:

{code}
  class Foo {
    public void voidMethod() {}
    public void bad() {
      if (voidMethod()) {
        prinln ""hello""
      }
    }
  }

  new Foo(); // triggers the error
{code}
","Ubuntu 14.04.5 LTS (Trusty)
Java: 1.8.0_91
x86_64 arch (both OS and Java)",emilles,paulk,wu-lee,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 31 13:38:13 UTC 2021,,,,,,,,,,"0|i35jmv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Oct/16 03:40;paulk;This appears to be a bug in the power assert code. A workaround is to provide your own assertion message, e.g.:
{code}
assert this.counter++, 'should work'
{code}
For your second example, if you'd like that fixed, I'd suggest trying a bit more to create a reproducible example and post a separate issue. If you are just leaving it here as a possible hint for this issue, then that is fine as is.
;;;","31/Oct/16 09:45;wu-lee;Thanks for the workaround.  I included the second example mainly as a hint for this issue, but leaving open the question as to whether it was related or not, since although it has a similar error, I cannot tell.

I you have any pointers on why these exceptions occur, that would help me to narrow down and isolate examples such as this. I managed to do it this time by binary searching the code, deleting parts whilst keeping it compiling with the same error, but sometimes the two seem to be mutually incompatible!;;;","31/Oct/16 12:06;paulk;VerifyErrors should never occur. They mean that the compiler is producing incorrect bytecode. Perhaps it is not cleaning up the stack in some edge case. It's a bit hard to provide a general rule that makes that obvious from the source code. Given that it is typically an edge case - errors in commonly run code would typically get fixed pretty quick - so you can often get around the problem by writing your code slightly differently. I can only guess what is going on with the power assert code. It specifically tries to record (make copies) of the variable values in your assertion and these values are supposed to be constant - perhaps the ++ means that there is both a before and after value associated with some data structure and that isn't being handled properly. If I get time, I'll take a look. Not likely straight away.;;;","31/Oct/16 12:11;paulk;Actually, the primitive type seems important. Perhaps some boxing is missing. That's another workaround, use Integer instead of int.;;;","30/Mar/21 23:08;paulk;[~emilles] Do we know fix version?;;;","31/Mar/21 13:38;emilles;I do not.  I think the fix that popped the extra operand (GROOVY-9892) was the one that did it.;;;",,,,,,,,,,,,,,,,
Sort methods that accept a comparator should accept Comparator<? super T>  (fix DGM signatures),GROOVY-7976,13015443,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,mauromol,mauromol,26/Oct/16 14:51,01/Feb/17 23:19,14/Jul/23 06:02,07/Nov/16 00:51,2.4.7,,,,,,,,2.4.8,,,,groovy-jdk,,,,0,,,,,,,"Methods like {{org.codehaus.groovy.runtime.DefaultGroovyMethods.sort(Iterable<T>, boolean, Comparator<T>)}} and all the others alike should be changed to accept a {{Comparator<? super T>}}, otherwise if you use {{@CompileStatic}} you'll get compiler errors as soon as you try to sort an Iterable/Collection using a comparator that accept superclass instances.",,githubbot,mauromol,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7992,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 07 08:07:29 UTC 2016,,,,,,,,,,"0|i35f9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Oct/16 08:11;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/454

    GROOVY-7976: Sort methods that accept a comparator should accept Comp…

    …arator<? super T>

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7976

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/454.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #454
    
----
commit af383f08fe12bf4705bebefcbf528f2e916bcf62
Author: paulk <paulk@asert.com.au>
Date:   2016-10-31T08:10:30Z

    GROOVY-7976: Sort methods that accept a comparator should accept Comparator<? super T>

----
;;;","06/Nov/16 23:53;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/454
;;;","07/Nov/16 00:51;paulk;Proposed PR merged. Note: work still needs to be done for GROOVY-7992.;;;","07/Nov/16 08:07;mauromol;Thank you Paul!;;;",,,,,,,,,,,,,,,,,,
Use of static final field in an annotation element causes compile errors,GROOVY-7975,13015249,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,emilles,emilles,25/Oct/16 21:55,13/Dec/18 10:04,14/Jul/23 06:02,05/Nov/18 23:45,2.4.7,,,,,,,,2.5.4,3.0.0-alpha-4,,,Compiler,,,,0,,,,,,,"Using a class constant (static final field) in an annotation causes compile errors.  This works in Java and the fix is pretty small.

Ex:
{code}
class C {
    public static final String VALUE = 'rawtypes'
    @SuppressWarnings(VALUE)
    def method() {
    }
}
{code}

This is a bit contrived to be concise.  But we have examples in our code where Callable impls are tagged with a name, which is defined as a static constant on each class.

The fix appears to be pretty minor.  In ResolveVisitor.transformInlineConstants, a case for VariableExpression does the trick for me.
{code}
    } else if (exp instanceof VariableExpression) {
        VariableExpression ve = (VariableExpression) exp;
        if (ve.getAccessedVariable() instanceof FieldNode) {
            FieldNode fn = (FieldNode) ve.getAccessedVariable();
            if (!fn.isEnum() && fn.isStatic() && fn.isFinal() &&
                    fn.getInitialValueExpression() instanceof ConstantExpression) {
                return fn.getInitialValueExpression();
            }
        }
        ....
{code}
",,emilles,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 05 23:45:02 UTC 2018,,,,,,,,,,"0|i35e27:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Oct/16 22:18;jwagenleitner;Possibly related tickets are GROOVY-7854 and GROOVY-3278.;;;","04/Nov/18 10:13;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/819

    GROOVY-7975/GROOVY-3278/GROOVY-7854: improved accessing of constants …

    …for annotation attributes

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy annotationConstantFixes

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/819.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #819
    
----
commit 236e4d5c06cec60840209e0b3c83512a90badfda
Author: Paul King <paulk@...>
Date:   2018-11-04T10:10:43Z

    GROOVY-7975/GROOVY-3278/GROOVY-7854: improved accessing of constants for annotation attributes

----
;;;","04/Nov/18 13:42;githubbot;Github user danielsun1106 commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/819#discussion_r230589376
  
    --- Diff: src/main/java/org/apache/groovy/ast/tools/ExpressionUtils.java ---
    @@ -18,20 +18,205 @@
      */
     package org.apache.groovy.ast.tools;
     
    +import org.codehaus.groovy.ast.ClassHelper;
     import org.codehaus.groovy.ast.ClassNode;
     import org.codehaus.groovy.ast.FieldNode;
    +import org.codehaus.groovy.ast.expr.BinaryExpression;
     import org.codehaus.groovy.ast.expr.ClassExpression;
     import org.codehaus.groovy.ast.expr.ConstantExpression;
     import org.codehaus.groovy.ast.expr.Expression;
     import org.codehaus.groovy.ast.expr.ListExpression;
     import org.codehaus.groovy.ast.expr.PropertyExpression;
    +import org.codehaus.groovy.ast.expr.VariableExpression;
    +
    +import java.lang.reflect.Field;
    +import java.lang.reflect.Modifier;
    +import java.util.ArrayList;
    +
    +import static org.codehaus.groovy.syntax.Types.DIVIDE;
    +import static org.codehaus.groovy.syntax.Types.MINUS;
    +import static org.codehaus.groovy.syntax.Types.MULTIPLY;
    +import static org.codehaus.groovy.syntax.Types.PLUS;
     
     public class ExpressionUtils {
    +    private static ArrayList<Integer> handledTypes = new ArrayList<Integer>();
    +
         private ExpressionUtils() {
     
         }
     
    -    // resolve constant-looking expressions statically (do here as gets transformed away later)
    +    static {
    +        handledTypes.add(PLUS);
    +        handledTypes.add(MINUS);
    +        handledTypes.add(MULTIPLY);
    +        handledTypes.add(DIVIDE);
    +    }
    +
    +    public static ConstantExpression transformBinaryConstantExpression(BinaryExpression be, ClassNode targetType) {
    +        if (isTypeOrArrayOfType(targetType, ClassHelper.STRING_TYPE, false)) {
    +            if (be.getOperation().getType() == PLUS) {
    +                Expression left = transformInlineConstants(be.getLeftExpression(), targetType);
    +                Expression right = transformInlineConstants(be.getRightExpression(), targetType);
    +                if (left instanceof ConstantExpression && right instanceof ConstantExpression) {
    +                    ConstantExpression newExp = new ConstantExpression((String) ((ConstantExpression) left).getValue() +
    +                            ((ConstantExpression) right).getValue());
    +                    newExp.setSourcePosition(be);
    +                    return newExp;
    +                }
    +            }
    +        } else if (isTypeOrArrayOfType(targetType, ClassHelper.Integer_TYPE, false) || isTypeOrArrayOfType(targetType, ClassHelper.int_TYPE, false)) {
    +            int type = be.getOperation().getType();
    +            if (handledTypes.contains(type)) {
    +                Expression left = transformInlineConstants(be.getLeftExpression(), targetType);
    +                Expression right = transformInlineConstants(be.getRightExpression(), targetType);
    +                if (left instanceof ConstantExpression && right instanceof ConstantExpression) {
    +                    Integer newVal = null;
    +                    switch(type) {
    +                        case PLUS:
    +                            newVal = (Integer) ((ConstantExpression) left).getValue() +
    +                                    (Integer) ((ConstantExpression) right).getValue();
    +                            break;
    +                        case MINUS:
    +                            newVal = (Integer) ((ConstantExpression) left).getValue() -
    +                                    (Integer) ((ConstantExpression) right).getValue();
    +                            break;
    +                        case MULTIPLY:
    +                            newVal = (Integer) ((ConstantExpression) left).getValue() *
    +                                    (Integer) ((ConstantExpression) right).getValue();
    +                            break;
    +                        case DIVIDE:
    +                            newVal = (Integer) ((ConstantExpression) left).getValue() /
    +                                    (Integer) ((ConstantExpression) right).getValue();
    +                            break;
    +                    }
    +                    if (newVal != null) {
    +                        ConstantExpression newExp = new ConstantExpression(newVal, true);
    +                        newExp.setSourcePosition(be);
    +                        return newExp;
    +                    }
    +                }
    +            }
    +        } else if (isTypeOrArrayOfType(targetType, ClassHelper.Double_TYPE, false) || isTypeOrArrayOfType(targetType, ClassHelper.double_TYPE, false)) {
    --- End diff --
    
    looks like some template code, which is duplicated now. It's better to refactor it IMO
;;;","05/Nov/18 03:38;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/819#discussion_r230627859
  
    --- Diff: src/main/java/org/apache/groovy/ast/tools/ExpressionUtils.java ---
    @@ -18,20 +18,205 @@
      */
     package org.apache.groovy.ast.tools;
     
    +import org.codehaus.groovy.ast.ClassHelper;
     import org.codehaus.groovy.ast.ClassNode;
     import org.codehaus.groovy.ast.FieldNode;
    +import org.codehaus.groovy.ast.expr.BinaryExpression;
     import org.codehaus.groovy.ast.expr.ClassExpression;
     import org.codehaus.groovy.ast.expr.ConstantExpression;
     import org.codehaus.groovy.ast.expr.Expression;
     import org.codehaus.groovy.ast.expr.ListExpression;
     import org.codehaus.groovy.ast.expr.PropertyExpression;
    +import org.codehaus.groovy.ast.expr.VariableExpression;
    +
    +import java.lang.reflect.Field;
    +import java.lang.reflect.Modifier;
    +import java.util.ArrayList;
    +
    +import static org.codehaus.groovy.syntax.Types.DIVIDE;
    +import static org.codehaus.groovy.syntax.Types.MINUS;
    +import static org.codehaus.groovy.syntax.Types.MULTIPLY;
    +import static org.codehaus.groovy.syntax.Types.PLUS;
     
     public class ExpressionUtils {
    +    private static ArrayList<Integer> handledTypes = new ArrayList<Integer>();
    +
         private ExpressionUtils() {
     
         }
     
    -    // resolve constant-looking expressions statically (do here as gets transformed away later)
    +    static {
    +        handledTypes.add(PLUS);
    +        handledTypes.add(MINUS);
    +        handledTypes.add(MULTIPLY);
    +        handledTypes.add(DIVIDE);
    +    }
    +
    +    public static ConstantExpression transformBinaryConstantExpression(BinaryExpression be, ClassNode targetType) {
    +        if (isTypeOrArrayOfType(targetType, ClassHelper.STRING_TYPE, false)) {
    +            if (be.getOperation().getType() == PLUS) {
    +                Expression left = transformInlineConstants(be.getLeftExpression(), targetType);
    +                Expression right = transformInlineConstants(be.getRightExpression(), targetType);
    +                if (left instanceof ConstantExpression && right instanceof ConstantExpression) {
    +                    ConstantExpression newExp = new ConstantExpression((String) ((ConstantExpression) left).getValue() +
    +                            ((ConstantExpression) right).getValue());
    +                    newExp.setSourcePosition(be);
    +                    return newExp;
    +                }
    +            }
    +        } else if (isTypeOrArrayOfType(targetType, ClassHelper.Integer_TYPE, false) || isTypeOrArrayOfType(targetType, ClassHelper.int_TYPE, false)) {
    +            int type = be.getOperation().getType();
    +            if (handledTypes.contains(type)) {
    +                Expression left = transformInlineConstants(be.getLeftExpression(), targetType);
    +                Expression right = transformInlineConstants(be.getRightExpression(), targetType);
    +                if (left instanceof ConstantExpression && right instanceof ConstantExpression) {
    +                    Integer newVal = null;
    +                    switch(type) {
    +                        case PLUS:
    +                            newVal = (Integer) ((ConstantExpression) left).getValue() +
    +                                    (Integer) ((ConstantExpression) right).getValue();
    +                            break;
    +                        case MINUS:
    +                            newVal = (Integer) ((ConstantExpression) left).getValue() -
    +                                    (Integer) ((ConstantExpression) right).getValue();
    +                            break;
    +                        case MULTIPLY:
    +                            newVal = (Integer) ((ConstantExpression) left).getValue() *
    +                                    (Integer) ((ConstantExpression) right).getValue();
    +                            break;
    +                        case DIVIDE:
    +                            newVal = (Integer) ((ConstantExpression) left).getValue() /
    +                                    (Integer) ((ConstantExpression) right).getValue();
    +                            break;
    +                    }
    +                    if (newVal != null) {
    +                        ConstantExpression newExp = new ConstantExpression(newVal, true);
    +                        newExp.setSourcePosition(be);
    +                        return newExp;
    +                    }
    +                }
    +            }
    +        } else if (isTypeOrArrayOfType(targetType, ClassHelper.Double_TYPE, false) || isTypeOrArrayOfType(targetType, ClassHelper.double_TYPE, false)) {
    --- End diff --
    
    Already refactored - thanks for the suggestion.
;;;","05/Nov/18 23:40;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/819
;;;","05/Nov/18 23:45;paulk;Fixed as part of changes for GROOVY-3278.;;;",,,,,,,,,,,,,,,,
Class.this not evaluated correctly within a closure within an inner class,GROOVY-7973,13014713,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,24/Oct/16 13:16,01/Feb/17 23:18,14/Jul/23 06:02,28/Oct/16 04:18,,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"There is an incorrect calculation of a qualified 'this' within a closure within an inner class:
{code}
//@groovy.transform.CompileStatic
class Test {
  def op1() { this }
  def op2() { ''.with{ this } }
  def op3() { new Object() { def inner() { this } } }
  def op4() { new Object() { def inner() { ''.with{ this } } } }
  def op5() { new Object() { def inner() { Test.this } } }
  def op6() { new Object() { def inner() { ''.with{ Test.this } } } }
  class Inner {
    def inner1() { this }
    def inner2() { ''.with { this } }
    def inner3() { Test.this }
    def inner4() { ''.with { Test.this } }
  }
}

def t = new Test()
assert t.op1().class.name == 'Test'
assert t.op2().class.name == 'Test'
assert t.op3().inner().class.name == 'Test$1'
assert t.op4().inner().class.name == 'Test$2'
assert t.op5().inner().class.name == 'Test'
assert t.op6().inner().class.name == 'Test$4$_inner_closure1'  // Current
//assert t.op6().inner().class.name == 'Test'  // Expected

def inner = new Test.Inner(t)
assert inner.inner1().class.name == 'Test$Inner'
assert inner.inner2().class.name == 'Test$Inner'
assert inner.inner3().class.name == 'Test'
assert inner.inner4().class.name == 'Test$Inner$_inner4_closure2' // Current
// assert inner.inner4().class.name == 'Test' // Expected
{code}",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 28 04:18:51 UTC 2016,,,,,,,,,,"0|i35ar3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Oct/16 10:53;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/451

    GROOVY-7973: Class.this not evaluated correctly within a closure with…

    …in an inner class

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7973

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/451.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #451
    
----
commit 731d548396d8f641f78c7b87ea8a074eb9646c2b
Author: paulk <paulk@asert.com.au>
Date:   2016-10-27T10:51:22Z

    GROOVY-7973: Class.this not evaluated correctly within a closure within an inner class

----
;;;","28/Oct/16 04:16;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/451
;;;","28/Oct/16 04:18;paulk;Proposed PR merged.;;;",,,,,,,,,,,,,,,,,,,
Can't call private method from outer class when using anonymous inner classes and @CS,GROOVY-7970,13012274,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,graemerocher1,graemerocher1,14/Oct/16 07:40,02/May/17 02:03,14/Jul/23 06:02,19/Feb/17 21:45,2.4.7,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,"This example:

{code}
import groovy.json.*
import groovy.transform.*

@CompileStatic
class Bar {
    private Writable renderTemplate(Object o, Map args) {
    
    }
    def foo(Map map, Map arguments) {
    
        def writable = new Writable() {
            @Override
            Writer writeTo(Writer out) throws IOException {
                StreamingJsonBuilder builder = new StreamingJsonBuilder(out)
                builder.call {
                    for(key in map.keySet()) {
                        def o = map.get(key)
                        Writable writable = renderTemplate((Object)o, arguments)
                        call(key.toString(), writable)
                    }
                }
                return out
            }
        }
    }
}

writable = new Bar().foo([one:'two'],[foo:'bar'])

sw = new StringWriter()
writable.writeTo(sw)
println sw
{code}

Results in a compilation error:

{code}
[Static type checking] - Cannot find matching method Bar$1#renderTemplate(java.lang.Object, java.util.Map). Please check if the declared type is right and if the method exists.
 at line: 18, column: 45
{code}

If you attempt to use {{Bar.this}}:

{code}
Writable writable = Bar.this.renderTemplate((Object)o, arguments)
{code}

The result is a VerifierError

{code}
java.lang.VerifyError: (class: Bar$1$_writeTo_closure1, method: doCall signature: (Ljava/lang/Object;)Ljava/lang/Object;) Incompatible argument to function
	at Bar$1.writeTo(ConsoleScript11:15)
	at groovy.lang.Writable$writeTo.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	
{code}",,githubbot,graemerocher1,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Feb 19 21:45:13 UTC 2017,,,,,,,,,,"0|i34vtb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Oct/16 19:58;paulk;A slightly simpler example (and indicating that it isn't just private methods)::
{code}
@groovy.transform.CompileStatic
class Bar {
    String renderTemplate(String arg) { ""dummy$arg"" }
    def foo() {
        'A'.with{ renderTemplate(it) } // OK if not in inner class
        new Object() {
            String toString() {
               'B'.with{ renderTemplate(it) } // ERROR
               // renderTemplate('C') // OK if not within closure
            }
        }
    }
}

new Bar().foo()
{code}
which has this error:
{noformat}
[Static type checking] - Cannot find matching method Bar$1#renderTemplate(java.lang.String). Please check if the declared type is right and if the method exists.
{noformat};;;","27/Oct/16 11:05;paulk;After applying the proposed PR#451 from GROOVY-7973 the following script works (i.e. the above suggested workaround which was showing a VerifyError):
{code}
@groovy.transform.CompileStatic
class Bar {
    String renderTemplate(String arg) { ""dummy$arg"" }
    def foo() {
        new Object() {
            String bar() {
               'B'.with{ Bar.this.renderTemplate(it) }
            }
        }
    }
}

assert new Bar().foo().bar() == 'dummyB'
{code}
I also have a fix that lets the non-workaround case through the type checker but the generated code isn't right yet and causes cast exceptions (it was never written to properly generate code in that case). I still need to do a bit more work to fix that case.;;;","27/Oct/16 11:11;graemerocher1;Great news! I guess we need to work out if the former case should be allowed;;;","27/Oct/16 11:25;paulk;I think it probably should - but I'll work on that more tomorrow and see if any ugly cases come up. It is always tricky with closures since they are so flexible, you can't make as many assumptions about what they would definitely produce. The type checking extension mechanism is in place for that purpose. If we can't be certain what should happen we should leave it out of the main compilation path. ;;;","28/Oct/16 11:30;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/452

    GROOVY-7970: Can't call private method from outer class when using anonymous inner classes and @CS

    Not a final solution. This fixes public methods. Private/protected methods are handled by a different code path which isn't yet fixed.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7970

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/452.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #452
    
----
commit b75907f844f0abb44414ee3e53e9bb247ee33a55
Author: paulk <paulk@asert.com.au>
Date:   2016-10-25T04:30:08Z

    GROOVY-7970: Can't call private method from outer class when using anonymous inner classes and @CS (allow through the type checker)

commit 63e55bbd79a1fa5318feaf08c43ac9e86e9c0593
Author: paulk <paulk@asert.com.au>
Date:   2016-10-28T11:27:24Z

    GROOVY-7970: Can't call private method from outer class when using anonymous inner classes and @CS

----
;;;","10/Nov/16 20:20;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/452
;;;","10/Nov/16 21:52;paulk;Even though this is a bug fix, the fix relies on several other changes that have only happened on the 2.5 branch (current master). It could be back-ported but will be a little tedious and require some work. Is it important to have this fix in the 2_4_X branch?;;;","19/Feb/17 21:45;paulk;No further feedback - leaving as a 2.5 only fix for now.;;;",,,,,,,,,,,,,,
Incorrect modifers on setter for volatile property with @Bindable/@Vetoable,GROOVY-7969,13011321,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,11/Oct/16 11:53,01/Feb/17 23:18,14/Jul/23 06:02,13/Oct/16 07:29,,,,,,,,,2.4.8,,,,,,,,1,,,,,,,"As part of GROOVY-3726 we fixed getter/setter method modifiers for volatile (or transient) properties. The @Bindable and @Vetoable transforms however generate their own setters and bypass that fix.

Here is a script to reproduce the problem:
{code}
import static java.lang.reflect.Modifier.toString
import groovy.beans.Bindable

class Foo {
  volatile Date now
}

@Bindable class Bar {
  volatile Date then
}

void pretty(int mod) { println ""${mod.toString().padRight(10)}"" + toString(mod) }

pretty(Foo.getMethod('getNow').modifiers)
pretty(Foo.getMethod('setNow', Date).modifiers)
pretty(Bar.getMethod('getThen').modifiers)
pretty(Bar.getMethod('setThen', Date).modifiers)
{code}
which currently produces:
{noformat}
1         public
1         public
1         public
65        public volatile
{noformat}",,githubbot,paulk,PetiKoch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 13 07:31:19 UTC 2016,,,,,,,,,,"0|i34py7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Oct/16 11:44;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/448

    GROOVY-7969: Incorrect modifers on setter for volatile property with …

    …@Bindable/@Vetoable

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7969

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/448.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #448
    
----
commit 254e6038e033b29b7fd9d0512dc11e13997d8730
Author: paulk <paulk@asert.com.au>
Date:   2016-10-12T11:42:17Z

    GROOVY-7969: Incorrect modifers on setter for volatile property with @Bindable/@Vetoable

----
;;;","12/Oct/16 18:38;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/448#discussion_r83071079
  
    --- Diff: src/main/org/codehaus/groovy/ast/tools/PropertyNodeUtils.java ---
    @@ -0,0 +1,50 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.codehaus.groovy.ast.tools;
    +
    +import org.codehaus.groovy.ast.PropertyNode;
    +
    +import java.lang.reflect.Modifier;
    +
    +public class PropertyNodeUtils {
    +    /**
    +     * Fields within the AST that have no explicit visibility are deemed to be properties
    +     * and represented by a PropertyNode. The Groovy compiler creates accessor methods and
    +     * a backing field for such property nodes. During this process, all modifiers
    +     * from the property are carried over to the backing field (so a property marked as
    +     * {@code transient} will have a {@code transient} backing field) but when creating
    +     * the accessor methods we don't carry over modifier values which don't make sense for
    +     * methods (this includes VOLATILE and TRANSIENT) but other modifiers are carried over,
    +     * for example {@code static}.
    +     *
    +     * @param propNode the original property node
    +     * @return the modifiers which make sense for an accessor method
    +     */
    +    public static int adjustPropertyModifiersForMethod(PropertyNode propNode) {
    +        int propNodeModifiers = propNode.getModifiers();
    +        // GROOVY-3726: clear volatile, transient modifiers so that they don't get applied to methods
    +        if ((propNodeModifiers & Modifier.VOLATILE) != 0) {
    +            propNodeModifiers -= Modifier.VOLATILE;
    +        }
    +        if ((propNodeModifiers & Modifier.TRANSIENT) != 0) {
    +            propNodeModifiers -= Modifier.TRANSIENT;
    +        }
    --- End diff --
    
    or: propNodeModifiers = ~(Modifier.TRANSIENT | Modifier.VOLATILE) & propNodeModifiers
;;;","13/Oct/16 07:29;paulk;Proposed PR merged with Jochen's suggestions;;;","13/Oct/16 07:31;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/groovy/pull/448
;;;",,,,,,,,,,,,,,,,,,
"A field and a property with the same name and both having an initial value leads to an ambiguity over what the initial value should be, so should fail compilation",GROOVY-7968,13011311,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,11/Oct/16 10:18,02/May/21 09:18,14/Jul/23 06:02,21/Mar/21 11:51,,,,,,,,,4.0.0-alpha-3,,,,,,,,0,breaking,,,,,,"Two fields or two properties with the same name cause compilation to fail but the following script passes (showing that the backing field has precedence):
{code}
class HasDate {
    Date d = new Date(0)
    private Date d = new Date(1000)
}

println new HasDate().d // => 'Thu Jan 01 10:00:01 AEST 1970' which shows field has precedence
{code}
It was decided that having the field and property with the same name was deemed okay - allowing to override the default of a private backing field (for instance) but the double initial value was deemed ambiguous and should not compile.",,blindpirate,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-9993,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Mar 21 11:51:09 UTC 2021,,,,,,,,,,"0|i34pvz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Oct/16 14:29;blindpirate;I'm afraid it's by design. See [https://github.com/apache/groovy/blob/master/src/test/gls/scope/MultipleDefinitionOfSameVariableTest.groovy#L110](https://github.com/apache/groovy/blob/master/src/test/gls/scope/MultipleDefinitionOfSameVariableTest.groovy#L110);;;","23/Oct/16 22:11;paulk;Yes, it was by design but I think it was a mistake. We certainly underspecified it. Those tests don't specify which initial value should be used for instance.;;;","23/Oct/16 22:51;blindpirate;Oh, I wanted to fixed this yesterday but found the test case eventually. I think it is a mistake too.

 As a convenience, to fix this, just remove Line 1055~1059 of https://github.com/apache/groovy/blob/master/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java#L1055 .;;;","21/Mar/21 11:51;paulk;Proposed PR (Thanks!) tweaked to just handle the multiple (potentially different) initial values case. We still need further clarification but I'll clone the issue to handle that.;;;",,,,,,,,,,,,,,,,,,
AstNodeToScriptAdapter should output source using the recommended modifier order,GROOVY-7967,13011306,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,11/Oct/16 10:01,02/May/17 02:03,14/Jul/23 06:02,13/Oct/16 07:34,,,,,,,,,2.5.0-alpha-1,,,,,,,,0,breaking,,,,,,"This source file:
{code}
interface Foo { }
{code}
when 'reprinted' via the groovyConsole shows up as:
{code}
abstract interface public class Foo extends java.lang.Object {  }
{code}
We don't need to have both 'interface' and 'class' and the modifier order should follow the JLS recommendations.

In some sense this is a trviial change but we do have numerous tests which output the resulting source and check the value. We'll need to refactor those.

It is a breaking change only if the old source order was being relied upon.",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 13 07:34:49 UTC 2016,,,,,,,,,,"0|i34puv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Oct/16 10:53;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/447

    GROOVY-7967: AstNodeToScriptAdapter should output source using the re…

    …commended modifier order

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7967

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/447.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #447
    
----
commit 56ef98545aa48236d053bdf8190922c5c787e1e3
Author: paulk <paulk@asert.com.au>
Date:   2016-10-11T10:50:48Z

    GROOVY-7967: AstNodeToScriptAdapter should output source using the recommended modifier order

----
;;;","12/Oct/16 10:36;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/447
;;;","13/Oct/16 07:34;paulk;Proposed PR merged to master (targeting 2.5+);;;",,,,,,,,,,,,,,,,,,,
Change in source order changes output in Java+Groovy joint compilation,GROOVY-7966,13011189,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,lptr,lptr,10/Oct/16 22:44,01/Feb/17 23:19,14/Jul/23 06:02,09/Dec/16 12:13,2.4.7,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"When compiling these three classes

AbstractThing.groovy:
{code}
class AbstractThing {}
{code}

Thing.groovy:
{code}
class Thing extends AbstractThing {}
{code}

JavaThing.java:
{code}
public class JavaThing {}
{code}

Two different results are produced for {{Thing.class}} based on the order of the source files provided to the Groovy compiler:

{code}
$ groovyc -d output -j AbstrctThing.groovy Thing.groovy JavaThing.java
$ javap output/Thing.class
Compiled from ""Thing.groovy""
public class Thing extends AbstractThing {
  public static transient boolean __$stMC;
  public Thing();
  protected groovy.lang.MetaClass $getStaticMetaClass();
  public groovy.lang.MetaClass super$2$$getStaticMetaClass();
}
$ groovyc -d output -j Thing.groovy AbstrctThing.groovy JavaThing.java
$ javap output/Thing.class
Compiled from ""Thing.groovy""
public class Thing extends AbstractThing implements groovy.lang.GroovyObject {
  public static transient boolean __$stMC;
  public Thing();
  protected groovy.lang.MetaClass $getStaticMetaClass();
  public groovy.lang.MetaClass super$2$$getStaticMetaClass();
}
{code}

Notice that when the source for the abstract superclass follows the source of the concrete class, the concrete class ends up implementing {{GroovyObject}}, but not if the order of the two source files is reversed.",,blackdrag,githubbot,lptr,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Dec 09 12:13:55 UTC 2016,,,,,,,,,,"0|i34p53:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Oct/16 23:40;blackdrag;I assume AbstractThing does in both cases implement GroovyObject. The probable reason is that in your first case the super class information for AbstractThing in Thing got proper resolving information, while in case 2 joint compilation prevented this. Maybe it is the joint compilation resolve visitor marking the super class as resolved, even though it is not. What is supposed to happen is that resolving fails but the error is ignored. A later second resolving will set the proper information for the Groovy side. Ah yes, from the compiler output  version 1 should be the only output.;;;","08/Dec/16 07:01;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/471

    GROOVY-7966: Change in source order changes output in Java+Groovy joi…

    …nt compilation

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7966

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/471.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #471
    
----
commit 69ac3b69edacd644fde626a1c7015c7f3ecbec13
Author: paulk <paulk@asert.com.au>
Date:   2016-12-08T06:59:42Z

    GROOVY-7966: Change in source order changes output in Java+Groovy joint compilation

----
;;;","09/Dec/16 10:03;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/471
;;;","09/Dec/16 12:13;paulk;Proposed PR merged. This doesn't alter what is in the Java stub which is still impacted by ordering (i.e. different ordering can produce an equivalent but slightly differently defined class) but any final Groovy class is no longer impacted. I am assuming this meets the original intent for this issue.;;;",,,,,,,,,,,,,,,,,,
ObjectRange iterator returns null instead of NoSuchElementException,GROOVY-7961,13009957,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,jwagenleitner,jwagenleitner,05/Oct/16 18:59,02/May/17 02:03,14/Jul/23 06:02,07/Oct/16 04:07,2.4.7,,,,,,,,2.5.0-alpha-1,,,,,,,,0,breaking,,,,,,"Calling {{next()}} on an {{ObjectRange}} iterator returns {{null}} when {{hasNext{}}} returns false.  It should throw {{NoSuchElementException}} to adhere to the Iterator contract.

{code}
class ObjectRangeItrTest extends GroovyTestCase {
    void testItr() {
        def itr = ('a'..'b').iterator()        
        assert itr.next() == 'a'
        assert itr.next() == 'b'
        assert !itr.hasNext() 
        shouldFail(NoSuchElementException) {
            println itr.next()
        }
    }
}
{code}",,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7962,,,,,GROOVY-7960,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 07 05:07:34 UTC 2016,,,,,,,,,,"0|i34hjj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Oct/16 23:56;githubbot;GitHub user jt1796 opened a pull request:

    https://github.com/apache/groovy/pull/440

    Groovy-7961 : NoSuchElementException

    https://issues.apache.org/jira/browse/GROOVY-7961
    
    This is a similar PR to 
    https://github.com/apache/groovy/pull/412

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jt1796/groovy object-range-exception

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/440.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #440
    
----
commit 6e771ebe9ff24e73ba85f8c83ff3ef1f9081f716
Author: John Tompkins <tompkins.jt@gmail.com>
Date:   2016-10-06T03:25:24Z

    Merge pull request #1 from apache/master
    
    update

commit 317c625463169e36f9f1100b1becbd46806eaaee
Author: John Tompkins <tompkins.jt@gmail.com>
Date:   2016-10-06T23:54:58Z

    do not return null when exhausted

----
;;;","07/Oct/16 04:02;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/440
;;;","07/Oct/16 04:07;jwagenleitner;Merged PR from [~jt1796].;;;","07/Oct/16 05:07;jwagenleitner;See comments on GROOVY-7960 about potential breaking change.;;;",,,,,,,,,,,,,,,,,,
IntRange iterator returns null instead of NoSuchElementException,GROOVY-7960,13009955,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,jwagenleitner,jwagenleitner,05/Oct/16 18:52,02/May/17 02:03,14/Jul/23 06:02,07/Oct/16 04:07,2.4.7,,,,,,,,2.5.0-alpha-1,,,,,,,,0,breaking,,,,,,"Calling {{next()}} on an {{IntRange}} iterator returns {{null}} when {{hasNext{}}} returns false.  As stated in a comment in the class, it should throw {{NoSuchElementException}} to adhere to the Iterator contract.

{code}
class IntRangeItrTest extends GroovyTestCase {
    void testItr() {
        def itr = (1..2).iterator()        
        assert itr.next() == 1
        assert itr.next() == 2
        assert !itr.hasNext()        
        shouldFail(NoSuchElementException) {
            itr.next() // null
        }
    }
}
{code}",,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7961,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Oct 07 04:07:33 UTC 2016,,,,,,,,,,"0|i34hj3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Oct/16 23:26;paulk;I am happy for this change, but for completeness I think we need to document an edge case that will break after this change. I think it represents a style which we'd discourage but I don't know if someone intended it at some point or perhaps people might have used it by accident. In any case I don't think it would be in wide-spread use and I think documenting it here should suffice.

Before this change the following code works without exception:
{code}
def items = (3..5).iterator()
def x
while (x = items.next()) { println x }
{code}
It silently falls out of the loop once the null is returned (existing behavior). This differs from most other similar collection types, e.g.:
{code}
def items = [3, 4, 5].iterator()
def x
while (x = items.next()) { println x }
{code}
would throw the {{NoSuchElementException}} as the new behavior will now do.

Of course the preferred approach would be to use {{each}} or if the external iterator approach is really required, something like:
{code}
while(items.hasNext()) { println items.next() }
{code};;;","07/Oct/16 04:07;jwagenleitner;Merged PR from [~jt1796].;;;",,,,,,,,,,,,,,,,,,,,
Incorrect parsing of comma-separated variable declaration as single statement after if/while/for,GROOVY-7958,13009793,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,05/Oct/16 07:31,01/Feb/17 23:18,14/Jul/23 06:02,05/Oct/16 23:04,,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"Currently during parsing a single (comma-separated) variable declaration is turned into multiple statements on the fly. If this occurs when such a statement is the single statement after an if/while/for, then only the first statement is picked up and the next is left dangling within the AST tree. For 'if' it becomes the else statement! while in the 'for/while' cases I think it is ignored. So, the following code doesn't work as expected:
{code}
int xNext = 0, yNext = 0
if (false) int x = xNext++, y = yNext++
assert xNext == 0 && yNext == 0
if (true) int x = xNext++, y = yNext++
assert xNext == 1 && yNext == 1
{code}
This is very much an edge case (what good is a declaration if you then have no block in which to use it?) but is still worth fixing.",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 05 23:04:24 UTC 2016,,,,,,,,,,"0|i34gj3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Oct/16 08:11;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/437

    GROOVY-7958: Incorrect parsing of comma-separated variable declaratio…

    …n as single statement after if/while/for

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7958

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/437.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #437
    
----
commit baca8ea46a7d02b26832fcb58ba0b1e4ecdd620b
Author: paulk <paulk@asert.com.au>
Date:   2016-10-05T08:05:43Z

    GROOVY-7958: Incorrect parsing of comma-separated variable declaration as single statement after if/while/for

----
;;;","05/Oct/16 22:53;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/437#discussion_r82088116
  
    [--snip--]
    +    void testCoomaSepVariableDeclarationAfterIf() {
    --- End diff --
    
    fixed
;;;","05/Oct/16 23:02;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/437
;;;","05/Oct/16 23:04;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,,
Groovydoc fails to parse Java source files containing the diamond operator,GROOVY-7955,13009513,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,04/Oct/16 11:49,01/Feb/17 23:18,14/Jul/23 06:02,05/Oct/16 01:11,,,,,,,,,2.4.8,,,,GroovyDoc,,,,0,,,,,,,"Example failing source file:
{code}
import java.util.List;
import java.util.ArrayList;

public class Second {
    public List<String> names = new ArrayList<>();
}
{code}",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Oct 05 01:11:12 UTC 2016,,,,,,,,,,"0|i34et3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Oct/16 12:21;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/435

    GROOVY-7955: Groovydoc fails to parse Java source files containing th…

    …e diamond operator

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7955

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/435.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #435
    
----
commit 5e74067e817d4f4237f0daec5112796087c8d2c8
Author: paulk <paulk@asert.com.au>
Date:   2016-10-04T12:20:08Z

    GROOVY-7955: Groovydoc fails to parse Java source files containing the diamond operator

----
;;;","04/Oct/16 21:14;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/435
;;;","05/Oct/16 01:11;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,,,
Equal Operator for Classes implementing Comparable not Working on Interfaces,GROOVY-7954,13009507,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,jhasenbe,jhasenbe,04/Oct/16 11:30,06/Aug/19 15:54,14/Jul/23 06:02,20/Mar/19 13:09,2.4.7,,,,,,,,2.5.7,3.0.0-beta-1,,,groovy-runtime,,,,2,,,,,,,"Using the equal operator ""=="" on two instances A and B does not work correctly, when

1) A and B implement the same interface I1 but are not the same class and
2) interface I1 extends the ""Comparable"" interface.

The checking in DefaultTypeTransformation.compareToWithEqualityCheck(...) checks for assignable classes, and uses compareTo when assignable on class level (which is not the case for instance A and B). But it does not check on interface level.

That way, calling the compareTo(..) method is not performed.
In my use case, class A and B are actually considered equal, even so their concrete implementation is different. And the compareTo(...) method would actually return 0. 

How about doing real equality checking instead of returning -1 close to the end of method DefaultTypeTransformation.compareToWithEqualityCheck(...):

...
if (equalityCheckOnly) {
    return left.equals(right) ? 0 : -1;
}

throw new GroovyRuntimeException(""Cannot compare "" + left.getClass().getName() + "" with value '"" +
                left + ""' and "" + right.getClass().getName() + "" with value '"" + right + ""'"");

Thanks for your effort.","Windows 10, Java 7",jan.wittig,janArbeit,jhasenbe,nguillaumin,paulk,,,,"nguillaumin commented on pull request #895: GROOVY-7954 Fix equality check in special case
URL: https://github.com/apache/groovy/pull/895
 
 
   Fix equality check with two instances A & B when:
   - A and B implement the same interface but are not of the same class
   - The common interface implements `Comparable`
   
   `DefaultTypeTransformation.compareToWithEqualityCheck(...)` checks for
   assignable classes and use `compareTo()` when assignable on the class
   level, but it doesn't check it on the interface level.
   
   As a result `compareTo()` is not called at the interface level and `-1`
   is returned.  The fix performs an actual equality check instead of
   returning -1.
   
   I added a unit test, but I'm not completely sure of the right structure
   for unit tests so let me know if I should do it differently.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;12/Mar/19 09:53;githubbot;600","janArb commented on issue #895: GROOVY-7954 Fix equality check in special case
URL: https://github.com/apache/groovy/pull/895#issuecomment-471941764
 
 
   I could verify this merge fixes https://issues.apache.org/jira/browse/GROOVY-7954
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;12/Mar/19 10:23;githubbot;600","danielsun1106 commented on issue #895: GROOVY-7954 Fix equality check in special case
URL: https://github.com/apache/groovy/pull/895#issuecomment-473990243
 
 
   LGTM.
   
   @paulk-asert 
   What do you think about the PR? Any chance to catch the train of Groovy 3.0.0-beta-1?
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Mar/19 16:28;githubbot;600","paulk-asert commented on issue #895: GROOVY-7954 Fix equality check in special case
URL: https://github.com/apache/groovy/pull/895#issuecomment-474108356
 
 
   I'll take a look today
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Mar/19 21:27;githubbot;600","asfgit commented on pull request #895: GROOVY-7954 Fix equality check in special case
URL: https://github.com/apache/groovy/pull/895
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Mar/19 12:43;githubbot;600","paulk-asert commented on issue #895: GROOVY-7954 Fix equality check in special case
URL: https://github.com/apache/groovy/pull/895#issuecomment-474817185
 
 
   Merged with a minor tweak. I took a more conservative approach in the alternative logic since that was all that was required to make the described scenario work. We can always expand the logic further in line with your suggestion if further examples indicate the need. I also just moved your tests to an existing subdirectory for consistency.
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;20/Mar/19 12:57;githubbot;600","nguillaumin commented on issue #895: GROOVY-7954 Fix equality check in special case
URL: https://github.com/apache/groovy/pull/895#issuecomment-477320029
 
 
   Thanks!
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;27/Mar/19 19:44;githubbot;600","MykolaGolubyev commented on issue #895: GROOVY-7954 Fix equality check in special case
URL: https://github.com/apache/groovy/pull/895#issuecomment-518730902
 
 
   Thank you for working on this. I just hit an example where `lhs` implements `compareTo` in a way that `rhs` doesn't need to be `Comparable`. It is in the context of a testing framework and DSL surrounding it.
   
   https://github.com/twosigma/webtau/blob/e1d20cdaf12df6250c1a86034a3451bb9dc14423/webtau-http-groovy/src/test/groovy/com/twosigma/webtau/http/GroovyDataNodeTest.groovy#L107
   
   ```
   @Test
   void ""compare to complex values""() {
       def node = new GroovyDataNode(DataNodeBuilder.fromValue(new DataNodeId('test'), [1, 2, 3]))
   
       if (node == [1, 2, 3]) {
           // TODO
           // https://issues.apache.org/jira/browse/GROOVY-7954
           // this case is still not covered: left side is Comparable and its implementation would return 0 in this case
           // but the compareTo code is not being triggered
           throw new UnsupportedOperationException(""once this is fixed in groovy we should update examples and docs"")
       }
   }
   ```
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;06/Aug/19 15:53;githubbot;600","MykolaGolubyev commented on issue #895: GROOVY-7954 Fix equality check in special case
URL: https://github.com/apache/groovy/pull/895#issuecomment-518730902
 
 
   Thank you for working on this. I just hit an example where `lhs` implements `compareTo` in a way that `rhs` doesn't need to be `Comparable`. It is in the context of a testing framework I work on and DSL surrounding it.
   
   https://github.com/twosigma/webtau/blob/e1d20cdaf12df6250c1a86034a3451bb9dc14423/webtau-http-groovy/src/test/groovy/com/twosigma/webtau/http/GroovyDataNodeTest.groovy#L107
   
   ```
   @Test
   void ""compare to complex values""() {
       def node = new GroovyDataNode(DataNodeBuilder.fromValue(new DataNodeId('test'), [1, 2, 3]))
   
       if (node == [1, 2, 3]) {
           // TODO
           // https://issues.apache.org/jira/browse/GROOVY-7954
           // this case is still not covered: left side is Comparable and its implementation would return 0 in this case
           // but the compareTo code is not being triggered
           throw new UnsupportedOperationException(""once this is fixed in groovy we should update examples and docs"")
       }
   }
   ```
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;06/Aug/19 15:54;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,0,5400,,,0,5400,,,,,,,,,,,,,,,,,,,"06/Oct/16 07:27;jhasenbe;Example.zip;https://issues.apache.org/jira/secure/attachment/12831911/Example.zip",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 20 13:09:42 UTC 2019,,,,,,,,,,"0|i34err:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Oct/16 11:08;paulk;Do you have a self-contained example illustrating something close to your situation?;;;","06/Oct/16 07:27;jhasenbe;Please find attached a simple example project (main class: Example.groovy).
Thanks.;;;","06/Oct/16 07:27;jhasenbe;Please find attached a simple example project (main class: Example.groovy);;;","11/Nov/16 10:38;janArbeit;I could reproduce the error with the provided example. Will the patch be complicated or could this be fixed easily?;;;","12/Mar/19 10:23;jan.wittig;There is a new merge request that could fix this issue: https://github.com/apache/groovy/pull/895;;;","20/Mar/19 13:09;paulk;If the class on right is also Comparable, compareTo is now used in that additional case. We may want to use logic such as left.equals(right) in some scenarios but we are planning to revamp that in Groovy 4, so I refrained from making that change here for just some of the cases where we'd like it to apply.;;;",,,,,,,,,,,,,,,,
Property expressions for extension methods on primitives fail STC,GROOVY-7953,13009401,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,04/Oct/16 01:14,01/Feb/17 23:18,14/Jul/23 06:02,09/Oct/16 17:03,2.4.7,,,,,,,,2.4.8,,,,Static compilation,Static Type Checker,,,0,,,,,,,"If we include groovy's TimeCategory as an extension class in an extension module, we can make method calls like {{3.getDays()}} in type checked code, but we cannot call that same method as a property i.e. {{3.days}} fails static type checking.",,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6738,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Oct 09 17:03:35 UTC 2016,,,,,,,,,,"0|i34e47:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Oct/16 16:44;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/442

    GROOVY-7953: property expressions for extension methods on primitives…

    … fail STC

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7953

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/442.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #442
    
----
commit 1e374d184cf19fe2aad19f8058f7bb284c07a6ca
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2016-10-06T21:39:27Z

    GROOVY-7953: property expressions for extension methods on primitives fail STC

----
;;;","08/Oct/16 20:44;githubbot;Github user PascalSchumacher commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/442#discussion_r82509499
  
    --- Diff: src/spec/test-resources/META-INF/services/org.codehaus.groovy.runtime.ExtensionModule ---
    @@ -17,5 +17,5 @@
     # IT IS A WORKAROUND FOR 2 DESCRIPTORS ON CLASSPATH!
     moduleName=Test module
     moduleVersion=1.0-test
    -extensionClasses=support.MaxRetriesExtension,org.codehaus.groovy.runtime.m12n.TestStringExtension,org.codehaus.groovy.runtime.m12n.Groovy6496Extension
    +extensionClasses=support.MaxRetriesExtension,org.codehaus.groovy.runtime.m12n.TestStringExtension,org.codehaus.groovy.runtime.m12n.Groovy6496Extension,,org.codehaus.groovy.runtime.m12n.TestPrimitiveWrapperExtension
    --- End diff --
    
    superfluous comma
;;;","09/Oct/16 08:32;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/442#discussion_r82517775
  
    --- Diff: src/spec/test-resources/META-INF/services/org.codehaus.groovy.runtime.ExtensionModule ---
    @@ -17,5 +17,5 @@
     # IT IS A WORKAROUND FOR 2 DESCRIPTORS ON CLASSPATH!
     moduleName=Test module
     moduleVersion=1.0-test
    -extensionClasses=support.MaxRetriesExtension,org.codehaus.groovy.runtime.m12n.TestStringExtension,org.codehaus.groovy.runtime.m12n.Groovy6496Extension
    +extensionClasses=support.MaxRetriesExtension,org.codehaus.groovy.runtime.m12n.TestStringExtension,org.codehaus.groovy.runtime.m12n.Groovy6496Extension,,org.codehaus.groovy.runtime.m12n.TestPrimitiveWrapperExtension
    --- End diff --
    
    good catch, fixed
;;;","09/Oct/16 17:03;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/442
;;;",,,,,,,,,,,,,,,,,,
Property expressions for extension methods starting with 'is' fail STC,GROOVY-7952,13009399,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,04/Oct/16 01:02,01/Feb/17 23:19,14/Jul/23 06:02,06/Oct/16 03:06,2.4.7,,,,,,,,2.4.8,,,,Static compilation,Static Type Checker,,,0,,,,,,,"Example:
{code}
import groovy.transform.TypeChecked
void test() {
    assert !'abc'.allWhitespace
}
{code}

The code above fails static type checking with the following error:
{code}
[Static type checking] - No such property: allWhitespace for class: java.lang.String
{code}",,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6738,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 06 03:28:16 UTC 2016,,,,,,,,,,"0|i34e3r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Oct/16 21:15;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/436

    GROOVY-7952: Property expressions for extension methods starting with…

    … 'is' fail STC
    
    * Add support for 'is' getter method variants of GROOVY-5580

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7952

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/436.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #436
    
----
commit 2904683fad2429c457b3c40c302b9d5e7956810b
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2016-10-04T21:08:20Z

    GROOVY-7952: Property expressions for extension methods starting with 'is' fail STC
    * Add support for 'is' getter method variants of GROOVY-5580

----
;;;","06/Oct/16 02:59;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/436
;;;","06/Oct/16 03:28;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/436#discussion_r82111762
  
    --- Diff: src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java ---
    @@ -158,19 +158,24 @@ public void makeGetPropertySite(Expression receiver, final String methodName, fi
     
             // GROOVY-5580, it is still possible that we're calling a superinterface property
             String getterName = ""get"" + MetaClassHelper.capitalize(methodName);
    +        String altGetterName = ""is"" + MetaClassHelper.capitalize(methodName);
             if (receiverType.isInterface()) {
                 Set<ClassNode> allInterfaces = receiverType.getAllInterfaces();
                 MethodNode getterMethod = null;
                 for (ClassNode anInterface : allInterfaces) {
                     getterMethod = anInterface.getGetterMethod(getterName);
    -                if (getterMethod!=null) break;
    +                if (getterMethod == null) getterMethod = anInterface.getGetterMethod(altGetterName);
    +                if (getterMethod != null) break;
                 }
                 // GROOVY-5585
    -            if (getterMethod==null) {
    +            if (getterMethod == null) {
                     getterMethod = OBJECT_TYPE.getGetterMethod(getterName);
                 }
    +            if (getterMethod == null) {
    +                getterMethod = OBJECT_TYPE.getGetterMethod(altGetterName);
    --- End diff --
    
    There are no isXxx methods in Object? Is this needed?
;;;",,,,,,,,,,,,,,,,,,,
MethodCallExpression.transformExpression does not copy generic types,GROOVY-7951,13008371,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,emilles,emilles,28/Sep/16 21:58,01/Feb/17 23:19,14/Jul/23 06:02,13/Oct/16 05:14,2.4.7,,,,,,,,2.4.8,,,,ast builder,,,,0,,,,,,,"org.codehaus.groovy.ast.expr.MethodCallExpression.transformExpression(ExpressionTransformer) is not copying generics info.  Downstream visitors are unable to check generics on static calls like Collections.<String>emptyList().


My patched version:
{code:java}
    public Expression transformExpression(ExpressionTransformer transformer) {
        MethodCallExpression answer =
            new MethodCallExpression(transformer.transform(objectExpression), transformer.transform(method), transformer.transform(arguments));
        answer.setSafe(safe);
        answer.setSpreadSafe(spreadSafe);
        answer.setImplicitThis(implicitThis);
        // GRECLIPSE add
        answer.setGenericsTypes(genericsTypes);
        // GRECLIPSE end
        answer.setMethodTarget(target);
        answer.setSourcePosition(this);
        answer.copyNodeMetaData(this);
        return answer;
    }
{code}",,emilles,githubbot,jwagenleitner,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 13 05:14:31 UTC 2016,,,,,,,,,,"0|i347rz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/Oct/16 14:47;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/441

    GROOVY-7951: MethodCallExpression.transformExpression does not copy generic types

    PR created from patch supplied in [GROOVY-7951](https://issues.apache.org/jira/browse/GROOVY-7951).  It seems like a reasonable change to make, though I did have trouble thinking up a way to test it that would be meaningful.  If anyone can nudge me in the right direction I can try to write up a test if you think it's warranted in this case.
    
    I considered whether `genericsTypes.clone()` should be used, but it didn't seem to be common and most uses of the array seem to be read only.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7951

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/441.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #441
    
----
commit 76f9cdabd6e48baf5721b6b6dbff21a109f164a7
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-10-04T22:29:59Z

    GROOVY-7951: MethodCallExpression.transformExpression does not copy generic types

----
;;;","08/Oct/16 16:56;shils;[~bigehokie] do you have an example which fails without your change?;;;","10/Oct/16 11:32;paulk;I added an example as a comment in the PR. Also, this error is what is causing a couple of test failures in https://github.com/apache/groovy/pull/439. Adding macro support to testCompile removes the generics information that two tests are relying on.;;;","13/Oct/16 05:08;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/441
;;;","13/Oct/16 05:14;jwagenleitner;Thanks for reporting the issue and for providing a patched version.;;;",,,,,,,,,,,,,,,,,
tab completion for static imports in groovysh does not work,GROOVY-7948,13007796,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,heenenee,heenenee,27/Sep/16 03:20,01/Feb/17 23:18,14/Jul/23 06:02,16/Oct/16 05:58,2.4.7,,,,,,,,2.4.8,,,,Groovysh,,,,0,,,,,,,"Currently, if I run groovysh, and enter the following:

{noformat}
class MyMath {
    static int square(int x) {return x*x}
}
import static MyMath.*
{noformat}

Then enter {noformat}sq{noformat} followed by hitting the Tab key, groovysh does not provided any possible auto-completions.

Instead, hitting the Tab key should auto-complete to the square method in MyMath.

I fixed this already in my local groovy installation and can submit it as a pull request if that helps.",,githubbot,heenenee,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Oct 16 05:58:08 UTC 2016,,,,,,,,,,"0|i34487:",9223372036854775807,,,,,,,,,,,,,,,,,,,"28/Sep/16 00:17;jwagenleitner;Thanks for reporting the issue, a pull request would be great.;;;","05/Oct/16 18:45;githubbot;GitHub user heenenee opened a pull request:

    https://github.com/apache/groovy/pull/438

    GROOVY-7948: fix completion of static imports in groovysh

    Fixed completion of static imports; updated unit tests; did some refactorings in ImportsSyntaxCompletor; added comment explaining how imports are stored in Groovysh.  Also did some manual testing of completion functionality using groovysh.bat in a cleanly built binary distribution.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/heenenee/groovy GROOVY-7948

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/438.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #438
    
----
commit ff0a7208949a2d32a5be9732383436b98a36eb27
Author: Abraham Grief <abraham.grief@gmail.com>
Date:   2016-10-05T18:32:43Z

    GROOVY-7948: fix completion of static imports in groovysh

----
;;;","12/Oct/16 21:09;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/438#discussion_r83096173
  
    --- Diff: subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ImportsSyntaxCompletor.groovy ---
    @@ -87,51 +78,49 @@ class ImportsSyntaxCompletor implements IdentifierCompletor {
             return foundMatch
         }
     
    -    private static final String STATIC_IMPORT_PATTERN = ~/^import static ([a-z0-9]+\.)+[A-Z][a-zA-Z0-9]*(\.(\*|[^.]+))?$/
    +    private static final String STATIC_IMPORT_PATTERN = ~/^static ([a-zA-Z_][a-zA-Z_0-9]*\.)+([a-zA-Z_][a-zA-Z_0-9]*|\*)$/
     
         /**
          * finds matching imported classes or static methods
    -     * @param prefix
    -     * @param importSpec
    -     * @param matches
    -     * @return
    +     * @param importSpec an import statement without the leading 'import ' or trailing semicolon
    +     * @return all names matching the importSpec
          */
    -    void collectImportedSymbols(final String importSpec, final Collection<String> matches) {
    +    SortedSet<String> collectImportedSymbols(final String importSpec) {
    --- End diff --
    
    While I don't think `collectImportedSymbols` was meant to be called outside this class there is a chance it could be since it's a public method.  So to avoid a breaking change and to have the chance to include this in the next 2.4 release (2.4.8) it would be necessary to keep the `void collectImportedSymbols(String,Collection)` method.
;;;","13/Oct/16 07:16;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/438#discussion_r83155709
  
    --- Diff: subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ImportsSyntaxCompletor.groovy ---
    @@ -87,51 +78,49 @@ class ImportsSyntaxCompletor implements IdentifierCompletor {
             return foundMatch
         }
     
    -    private static final String STATIC_IMPORT_PATTERN = ~/^import static ([a-z0-9]+\.)+[A-Z][a-zA-Z0-9]*(\.(\*|[^.]+))?$/
    +    private static final String STATIC_IMPORT_PATTERN = ~/^static ([a-zA-Z_][a-zA-Z_0-9]*\.)+([a-zA-Z_][a-zA-Z_0-9]*|\*)$/
     
         /**
          * finds matching imported classes or static methods
    -     * @param prefix
    -     * @param importSpec
    -     * @param matches
    -     * @return
    +     * @param importSpec an import statement without the leading 'import ' or trailing semicolon
    +     * @return all names matching the importSpec
          */
    -    void collectImportedSymbols(final String importSpec, final Collection<String> matches) {
    +    SortedSet<String> collectImportedSymbols(final String importSpec) {
    --- End diff --
    
    we decided to be strict about such things in a bugfix release and 2.4.8 is one. So yeah, unless the method signature is made compatible no 2.4.x
;;;","16/Oct/16 05:41;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/438
;;;","16/Oct/16 05:58;jwagenleitner;Thanks for reporting the issue and for the pull request to fix it!;;;",,,,,,,,,,,,,,,,
Expect compilation error while resolving generic types,GROOVY-7945,13006314,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,dwarszawski,dwarszawski,20/Sep/16 21:12,01/Mar/22 20:05,14/Jul/23 06:02,20/Mar/21 02:19,2.4.7,,,,,,,,2.5.16,3.0.8,4.0.0-alpha-3,,Compiler,,,,0,,,,,,,"Should fail to compile groovy class while resolving generic types if super constructor is invoked with wrong type parameters. The attached link presents a gist to reproduce the issue.

https://gist.github.com/dwarszawski/89ab9f1f03304755728446d5e3cb7297","Linux 4.4.16-1-MANJARO x86_64 GNU/Linux
",dwarszawski,jwagenleitner,,,,,,,"eric-milles opened a new pull request #1521:
URL: https://github.com/apache/groovy/pull/1521


   https://issues.apache.org/jira/browse/GROOVY-7945


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Mar/21 20:18;githubbot;600","danielsun1106 merged pull request #1521:
URL: https://github.com/apache/groovy/pull/1521


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;19/Mar/21 20:01;githubbot;600","danielsun1106 commented on pull request #1521:
URL: https://github.com/apache/groovy/pull/1521#issuecomment-803085918


   Merged. Thanks!


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;19/Mar/21 20:01;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2016-09-20 21:12:16.0,,,,,,,,,,"0|i33v3z:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Bad class generation when trying to instantiate an inner class within a static method,GROOVY-7944,13006165,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,paulk,paulk,20/Sep/16 10:05,08/Mar/22 12:16,14/Jul/23 06:02,16/Mar/21 20:45,,,,,,,,,,,,,,,,,0,,,,,,,"The first constructor call is OK. The second constructor call is thought to be in a static context and the argument is replaced with it's class.
{code}
class Foo {
  class Bar { }
  static void main(args) {
    new Bar(new Foo()) // OK, matches Foo$Bar(Foo)
    new Foo().with {
      new Bar(this) // GRE: trying to match Foo$Bar(java.lang.Class)
    }
  }
}
{code}
It isn't specific to {{with}}. You could use {{any}}, {{every}}, etc.",,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Mar 16 20:45:39 UTC 2021,,,,,,,,,,"0|i33u73:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Mar/21 20:45;emilles;In static context, ""this"" refers to the enclosing class as does ""owner"" within the closure.  Either should produce an error.  Using ""delegate"" or ""it"" should work fine.;;;",,,,,,,,,,,,,,,,,,,,,
Inconsistent handling of undocumented primitive data types at the @Lazy annotation under use of extends,GROOVY-7940,13004867,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,MaikIgloffstein,MaikIgloffstein,14/Sep/16 12:45,01/Feb/17 23:18,14/Jul/23 06:02,18/Sep/16 05:33,2.4.5,,,,,,,,2.4.8,,,,groovy-jdk,,,,0,data,extends,lazy,primitives,super,types,"*Documentation:* http://docs.groovy-lang.org/latest/html/gapi/groovy/lang/Lazy.html

The documentations describes the usage of _@Lazy_ like:
{{@Lazy T x}}

I'm aware of that _T_ means no primitive data types, but groovy allows it and generates the code - so why not.

{code}
class Super {
    boolean aBoolean = true
    int aInt = 5
}

class Testing extends Super {

    @Lazy
    boolean aBoolean = { false }()
    
    @Lazy
    int aInt = { 5 * 5 }()

}

println new Testing().isaBoolean()
println new Testing().getaBoolean()
println new Testing().getaInt()
println new Testing().aBoolean
println new Testing().aInt
{code}

Result:
{code}
true
false
25
true
25
{code}

The behavior is inconsistent.
boolean: results are from the super class
int: results are from the child class


-Please fix it or throw a _'RuntimeException'_ when primitive data types are used.-
*Update:*
Please let _@Lazy_ implement \_is\_Boolean() instead of \_get\_Boolean() when using primitive data type boolean and document it or just throw a _'RuntimeException'_.",Any,blackdrag,githubbot,jwagenleitner,MaikIgloffstein,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 18 05:33:36 UTC 2016,,,,,,,,,,"0|i33m73:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Sep/16 12:56;blackdrag;The problem is more that @Lazy adds a getaBoolean Method and not isaBoolean method. And that isaBoolean() is preferred over getaBoolean(). If you change your test to use getaBoolean it will look different;;;","14/Sep/16 13:17;MaikIgloffstein;[~blackdrag] - thx for your input, I changed the description.;;;","15/Sep/16 00:27;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/420

    GROOVY-7940: @Lazy not generating ""is"" property accessor for booleans

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7940-lazy-booleans

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/420.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #420
    
----
commit afdbc4b07fbad1d0596ed714a1f844faba870893
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-09-15T00:26:11Z

    GROOVY-7940: @Lazy not generating ""is"" property accessor for booleans

----
;;;","17/Sep/16 21:26;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/420#discussion_r79292382
  
    --- Diff: src/main/org/codehaus/groovy/transform/LazyASTTransformation.java ---
    @@ -156,8 +156,11 @@ private static void addNonThreadSafeBody(BlockStatement body, FieldNode fieldNod
         private static void addMethod(FieldNode fieldNode, BlockStatement body, ClassNode type) {
             int visibility = ACC_PUBLIC;
             if (fieldNode.isStatic()) visibility |= ACC_STATIC;
    -        final String name = ""get"" + MetaClassHelper.capitalize(fieldNode.getName().substring(1));
    -        fieldNode.getDeclaringClass().addMethod(name, visibility, type, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body);
    +        String propName = MetaClassHelper.capitalize(fieldNode.getName().substring(1));
    +        fieldNode.getDeclaringClass().addMethod(""get"" + propName, visibility, type, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body);
    +        if (ClassHelper.boolean_TYPE.equals(type)) {
    +            fieldNode.getDeclaringClass().addMethod(""is"" + propName, visibility, type, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body);
    --- End diff --
    
    I'd probably use 'stmt(callThisX(""get"" + propName))' instead of 'body'. That should give a slightly smaller class.
;;;","17/Sep/16 22:59;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/420#discussion_r79293601
  
    --- Diff: src/main/org/codehaus/groovy/transform/LazyASTTransformation.java ---
    @@ -156,8 +156,11 @@ private static void addNonThreadSafeBody(BlockStatement body, FieldNode fieldNod
         private static void addMethod(FieldNode fieldNode, BlockStatement body, ClassNode type) {
             int visibility = ACC_PUBLIC;
             if (fieldNode.isStatic()) visibility |= ACC_STATIC;
    -        final String name = ""get"" + MetaClassHelper.capitalize(fieldNode.getName().substring(1));
    -        fieldNode.getDeclaringClass().addMethod(name, visibility, type, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body);
    +        String propName = MetaClassHelper.capitalize(fieldNode.getName().substring(1));
    +        fieldNode.getDeclaringClass().addMethod(""get"" + propName, visibility, type, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body);
    +        if (ClassHelper.boolean_TYPE.equals(type)) {
    +            fieldNode.getDeclaringClass().addMethod(""is"" + propName, visibility, type, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body);
    --- End diff --
    
    Thanks, I've updated so it delegates to the getter as suggested.
;;;","18/Sep/16 04:25;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/420
;;;","18/Sep/16 05:33;jwagenleitner;Thanks for reporting the issue!;;;",,,,,,,,,,,,,,,
inconsistent access of methods in outer class,GROOVY-7938,13004774,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,14/Sep/16 03:24,01/Feb/17 23:19,14/Jul/23 06:02,19/Sep/16 01:27,2.4.7,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"Groovy handles access to outer instance and static methods from inner classes but not nested (i.e. static) ones. The following code illustrates the problem:
{code}class Outer {
    static Integer fooCount = 0
    Integer barCount = 0
    static void incFoo() { fooCount++ }
    void incBar() { barCount++ }
    static class Nested {
        static void nestedIncFoo() { incFoo() }
    }
    Inner innerFactory() { new Inner() }
    class Inner { }
}

Outer.incFoo()
//Outer.Nested.nestedIncFoo() // => MME
assert Outer.fooCount == 1 // but should be 2 if no MME

new Outer().with {
    incBar()
    incFoo()
    innerFactory().with {
        incBar()
        incFoo()
    }
    assert barCount == 2
    assert fooCount == 3 // but should be 4 if no MME
}
{code}
After the fix, the following is expected to work:
{code}
class Outer {
    static Integer fooCount = 0
    Integer barCount = 0
    static void incFoo() { fooCount++ }
    void incBar() { barCount++ }
    static class Nested {
        static void nestedIncFoo() { incFoo() }
    }
    Inner innerFactory() { new Inner() }
    class Inner { }
}

Outer.incFoo()
Outer.Nested.nestedIncFoo()
assert Outer.fooCount == 2

new Outer().with {
    incBar()
    incFoo()
    innerFactory().with {
        incBar()
        incFoo()
    }
    assert barCount == 2
    assert fooCount == 4
}
{code}
Basically the commented out line should work.",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 19 01:27:05 UTC 2016,,,,,,,,,,"0|i33lmf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"15/Sep/16 09:03;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/421

    GROOVY-7938: inconsistent access of methods in outer class

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7938

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/421.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #421
    
----
commit 46d81cc6ffb4aa0b625511d6b7c84c97ebe1c627
Author: paulk <paulk@asert.com.au>
Date:   2016-09-15T09:01:27Z

    GROOVY-7938: inconsistent access of methods in outer class

----
;;;","19/Sep/16 01:22;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/421
;;;","19/Sep/16 01:27;paulk;Proposed PR merged.;;;",,,,,,,,,,,,,,,,,,,
CLONE - same linkedlist code different behavior between groovy and java (fix priority of DGM methods vs actual methods on an object),GROOVY-7937,13004507,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,farmer1992,paulk,13/Sep/16 06:30,17/May/17 15:39,14/Jul/23 06:02,16/Sep/16 21:54,,,,,,,,,2.5.0-alpha-1,,,,jdk conflict,,,,0,breaking,,,,,,"I am using `linkedlist` as a stack in groovy 

as doc says, `pop()` take elm from the first

    Stack Method  Equivalent Deque Method  
    push(e)       addFirst(e) 
    pop()         removeFirst()


so a `linkedlist` [1,2,3] should pop() 1 2 3

and it does in Java, but does NOT in groovy. WHY?

test below

{code:title=A.java}
import java.util.*;
    
public class A{
    
    
    public static void main(String[] args){
    
        String[] x = ""1/2/3/"".split(""/"");
        LinkedList <String> stack = new LinkedList<String>(Arrays.asList(x));
        System.out.println(stack.pop());
    }
}
{code}

compile and run
{noformat}
$ javac A.java
$ java A
1
{noformat}
runing in groovy
{noformat}    
$ ln -s A.java A.groovy
$ groovy A.groovy
3
{noformat}

here is my java and groovy version
{noformat}
$ java -version
java version ""1.6.0_51""
Java(TM) SE Runtime Environment (build 1.6.0_51-b11-457-11M4509)
Java HotSpot(TM) 64-Bit Server VM (build 20.51-b01-457, mixed mode)

$ groovy -version
Groovy Version: 2.1.5 JVM: 1.6.0_51 Vendor: Apple Inc. OS: Mac OS X
{noformat}
",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6396,,,,,,,,,GROOVY-4851,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 16 21:55:22 UTC 2016,,,,,,,,,,"0|i33jyv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Sep/16 06:35;paulk;There are two parts to this issue. One is that DGM methods on an interface are being selected ahead of methods already available within the instance. The other is that the DGM push/pop methods for Lists store/retrieve items in the reverse order to the backing list compared with Java's Deque interface. This issue will solve the former of those two issues. The clone will be for solving the latter.;;;","13/Sep/16 06:56;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/418

    GROOVY-7937: CLONE - same linkedlist code different behavior between …

    …groovy and java (fix priority of DGM methods vs actual methods on an object)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7937

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/418.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #418
    
----
commit 49e952c8926942060a7048afd3728f4a6d30a9e3
Author: paulk <paulk@asert.com.au>
Date:   2016-09-13T06:54:51Z

    GROOVY-7937: CLONE - same linkedlist code different behavior between groovy and java (fix priority of DGM methods vs actual methods on an object)

----
;;;","16/Sep/16 21:50;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/418
;;;","16/Sep/16 21:54;paulk;This is fixed in master (ready for 2.5) but I haven't back-ported to the 2_4_X branch at this stage. While technically a bug, it is a breaking change that people might be relying on without knowing it. They might not expect to have to change their code for a point release. If there is huge demand though, we could consider merging back into the 2_4_X branch.;;;","16/Sep/16 21:55;paulk;Thanks for spotting the error!;;;",,,,,,,,,,,,,,,,,
renaming static imports,GROOVY-7936,13004411,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Trivial,Fixed,paulk,tinne,tinne,12/Sep/16 20:11,01/Feb/17 23:18,14/Jul/23 06:02,12/Sep/16 22:08,2.4.7,,,,,,,,2.4.8,,,,Documentation,,,,0,documentation,,,,,,"The Groovy [style guide|http://groovy-lang.org/style-guide.html] introduces the renaming {{import... as}} statement and discusses {{import static}}. It should not leave as an exercise that {{import static... as}} works as well, but simply introduce it by a simple example, as in
{noformat}
import static java.lang.Math.abs as mabs
println mabs(-4)
{noformat}",http://groovy-lang.org/style-guide.html section 15,paulk,tinne,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 12 22:08:48 UTC 2016,,,,,,,,,,"0|i33jdr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Sep/16 22:08;paulk;Nice suggestion. Added. Feel free to create PRs for such changes in the future as per:
http://groovy-lang.org/contribute.html;;;",,,,,,,,,,,,,,,,,,,,,
Incorrect boxing of boolean primitive types,GROOVY-7933,13004164,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,henri,henri,11/Sep/16 17:43,01/Feb/17 23:19,14/Jul/23 06:02,25/Sep/16 21:15,2.4.7,,,,,,,,2.4.8,,,,groovy-runtime,,,,1,,,,,,,"A boolean primitive type seems to be boxed for no apparent reason. See the example below. The problem disappear when using @CompileStatic or if explicitly casting to (boolean).

{code:java}
public class Demo {

   public void a(boolean a){
       System.out.println(""boolean was called"");
   }

   public void a(Object a){
       System.out.println(""Object was called"");
   }

}
class Groovy {
   static void main(String[] args) {
       def demo = new Demo()
       demo.a(true)
   }
}
{code}

*Output:*
Object was called",,blackdrag,githubbot,joseignacio.acinpozo@gmail.com,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Sep 26 00:37:32 UTC 2016,,,,,,,,,,"0|i33huv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"12/Sep/16 11:22;blackdrag;I am not able to reproduce this;;;","12/Sep/16 16:53;jwagenleitner;I am able to reproduce and also find that, as reported, adding CompileStatic or casting makes it pass.

{code}
public class Demo {

   public String a(boolean a) {
        'boolean was called'
   }

   public String a(Object a) {
        'Object was called'
   }

   static void main(args) {
       assert new Demo().a((boolean)true) == 'boolean was called' //pass
       assert new Demo().a(true) == 'boolean was called'          //fail
   }
}
{code};;;","12/Sep/16 17:16;henri;Great. Thanks [~jwagenleitner].

Do you confirm this is not the intended behavior?;;;","12/Sep/16 18:54;blackdrag;no idea what went wrong, but now I can reproduce the behaviour. What is to be expected is that if a method call is done and there is an exact matching method to the argument types, that this method is called. so a(true) should call a(boolean) before a(Boolean) and also before a(Object);;;","12/Sep/16 20:11;joseignacio.acinpozo@gmail.com;That would be the expected method resolution. In Java.

Groovy documentation says otherwise, as the method resolution works in different way, because primitives are autowrapped:
http://docs.groovy-lang.org/latest/html/documentation/core-object-orientation.html#_primitive_types
http://docs.groovy-lang.org/latest/html/documentation/core-differences-java.html#_primitives_and_wrappers

So in Groovy the order for calling ""a(true)"" should be something like: a(Boolean), a(Object) and last but not least a(boolean).

You can test this behaviour by extending the code:

{code}
public class Demo {

   public String a(boolean a) {
        'boolean was called'
   }

   public String a(Object a) {
        'Object was called'
   }

   public String a(Boolean a) {
        'Boolean was called'
   }

   static void main(args) {
       assert new Demo().a((boolean)true) == 'boolean was called' //pass
       assert new Demo().a(true) == 'Boolean was called'          //fail
   }
}
{code}
I am happy to be corrected, but I have used Groovy for a long time, and learned this the hard way. If this is actually a bug, then the documentation is very wrong.

;;;","12/Sep/16 20:26;jwagenleitner;I think the issue here is that in the absence of a method taking Boolean, the call should be unboxed and the {{boolean}} method called over the one taking {{Object}}.;;;","12/Sep/16 20:41;jwagenleitner;It seems to work as expected for all primitives except for {{boolean}} and {{char}}.  Looks like those primitive types are not taken into account when calculating the method parameter distances which is causing the method taking an {{Object}} to be selected first.

https://github.com/apache/groovy/blob/53b99ebb460ae26fd8483bc894cc3703cd7af48f/src/main/org/codehaus/groovy/runtime/MetaClassHelper.java#L206-L231

Both {{boolean}} and {{char}} do not seem to be eligible for conversion to other types which may explain why they are missing from the distance table.  But perhaps they should be added and have a distance to the other types set to -1 except for their associated wrapper class and Object or maybe handled specially in the {{getPrimitiveDistance(Class from, Class to)}} method so as not to complicate the distance tables.;;;","12/Sep/16 21:03;joseignacio.acinpozo@gmail.com;Fair enough. 

I always went my way by doing defensive coding to avoid these situations, so seeing now that there are two exceptions for ""boolean"" and ""char"" while the rest work correctly feels very confusing. 

I also think this should be documented somewhere very clearly, as the mantra ""Groovy uses Objects for everything"" is pretty much everywhere in documentation, with special mentions when talking about method resolution and primitives autowrapping. 

If this behaviour is changed to satisfy ""boolean"" and ""char"" primitives as well, then, the method resolution should be something like this: a(Boolean) > a(boolean) > a(Object). Primitives like Integer should be something like: a(Integer) > a(int) > a(Number) > a(Object). In summary: Unboxed > Boxed > More concrete subclass or implementation (if any) > Object. Am I correct?;;;","12/Sep/16 21:29;jwagenleitner;If the methods are called in the same class it works, it's only when the sender/receiver are different.  So a script like this works:

{code}
String a(boolean b) { 'boolean' }
String a(Object o) { 'Object' }

String result = a(true)
assert result == 'boolean'
{code}

and one like this fails:

{code}
class Foo {
    String a(boolean b) { 'boolean' }
    String a(Object o) { 'Object' }
}
String result = new Foo().a(true)
assert result == 'boolean'
{code};;;","12/Sep/16 22:10;jwagenleitner;{quote}Primitives like Integer should be something like: a(Integer) > a(int) > a(Number) > a(Object). In summary: Unboxed > Boxed > More concrete subclass or implementation (if any) > Object. Am I correct?{quote}

For Integer I believe the resolution is:

{{Integer > int > long > Long > BigInteger > float > Float > double > Double > BigDecimal > Number > Object}}

However, there seems to be a difference between which of the first 2 are resolved (Integer vs int) depending on where the call originates.  For example, if you run the following it will fail in the {{test()}} instance method (sender/receiver are the same):

{code}
class Demo {

    String a(int i) { 'int' }
    String a(Integer bigI) { 'Integer' }

    void test() {
        String result = a(42)
        assert result == 'Integer'
    }

    static void main(args) {
        String result = new Demo().a(42)
        assert result == 'Integer'
        
        new Demo().test()
    }
}
{code}

Sorry, getting a little off-topic for this particular reported issue, but this doesn't seem right to me.  This is not just the case for Integer but also for the other boxed primitive types.  It looks like GROOVY-7850 has noted this inconsistency as well.;;;","12/Sep/16 22:20;joseignacio.acinpozo@gmail.com;Of course, your resolution makes more sense. I was not taking into account the widening possibility, just the boxed/unboxed possibilities for an Integer.

I think you meant:

{code}
​class Demo {
    String a(int i) { 'int' }
    String a(Integer bigI) { 'Integer' }

    void test() {
        String result = a(42)
        // 'int' instead of 'Integer'
        assert result == 'int'
    }

    static void main(args) {
        String result = new Demo().a(42)
        assert result == 'Integer'
        
        new Demo().test()
    }
}

{code}

This behaviour is way too confusing and I wonder how it went unnoticed for so many years, or if there was a real reason indeed for doing it this way and it is just not documented/explained properly.


;;;","13/Sep/16 02:50;henri;It think it should be fixed indeed. At least for one reason: Right now you have a different behavior between @CompileStatic and interpreted code. That doesn't make sense.

On my side, the issue would currently force me to add an overload dedicated to Groovy. Normally, in Java we need `foo(boolean)` and `foo(Object)`. This would also for me to add a `foo(Boolean)` to please Groovy. It seems sad for interoperability.;;;","13/Sep/16 09:56;joseignacio.acinpozo@gmail.com;This is probably a bit off-topic for this particular issue, but should @CompileStatic and interpreted behaviour actually be different? I think it sort of makes sense as @CompileStatic methods should be chosen at compile time(like Java does) instead of runtime (like Groovy does):

From http://groovy-lang.org/differences.html#_multi_methods :

""In Groovy, the methods which will be invoked are chosen at runtime. This is called runtime dispatch or multi-methods. It means that the method will be chosen based on the types of the arguments at runtime. In Java, this is the opposite: methods are chosen at compile time, based on the declared types.""

From http://docs.groovy-lang.org/latest/html/gapi/groovy/transform/CompileStatic.html :

""This will let the Groovy compiler use compile time checks in the style of Java then perform static compilation, thus bypassing the Groovy meta object protocol. When a class is annotated, all methods, properties, files, inner classes, etc. of the annotated class will be type checked.""

Also more info taken from here http://java-performance.info/static-code-compilation-groovy-2-0/ :

""Both these features are connected, because you need a type inference in order to statically choose the best matching method at compile time. Static type checking allows you to check your Groovy code for type safety as well as for absence of typos in the method/property names.""

""Static compilation allows Groovy 2.0 to generate direct method calls, which are no longer using Groovy runtime as an intermediary. This feature actually allows you to avoid going into the Groovy runtime for the huge share of methods – think how many overloaded methods do you usually have in your code – non-overloaded methods could always be safely converted into the normal method calls.""
;;;","15/Sep/16 10:22;blackdrag;ah... I get a feeling I know the problem this is coming from. when doing a(foo), we may be able to do a direct method call in some cases. If foo is a boolean, then there must be a a(boolean) exist to work. If we do x.a(foo), then this is in dynamic Groovy never a direct call. To relialize the method call foo will be wrapped in an Object[] at some point and the type taken for the dispatch is the one out of this array. Which means foo will be Boolean instead. For Groovy with indy, this is different. Here foo will be the primitive type. And there is also the problem of MOP methods. For example an a(foo) in a Closure. This will cause method dispatch to go through an invokeMethod somewhere, or the MetaClass system, which too takes only an Object[] and not possibly known types from the callsite. So here again a(foo) would prefer a(Boolean). Using a cast helps carrying the information over, but only to the first MetaClass. After that, the information might get lost.

Not sure what way we should go to fix this. For indy there is actually nothing to fix here, if we ignore the MOP. And I am not sure it is really worth fixing it for non-indy Groovy. ;;;","15/Sep/16 18:58;henri;[~blackdrag] But then, if I understand correctly, why does it work with Byte, Integer, Double, Float and Long?;;;","15/Sep/16 20:41;blackdrag;Actually I think I made a mistake once more in misunderstanding some of the comments here, plus mixing up plans and what is done.. the code part I was thinking of does actually not activate for overloaded methods at all.. I am sorry for causing confusion here.

Ok, let us first assess again what we have:
{code:Java}
def types = [
  [""int"" , ""Integer"", ""1""], [""byte"", ""Byte"", ""1""],
  [""boolean"", ""Boolean"", ""true""],  [""short"",""Short"", ""1""],
  [""long"", ""Long"", ""1""], [""char"", ""Character"", ""'c'""],
  [""double"", ""Double"", ""1""], [""float"", ""Float"", ""1""]
]

types.each {
  def code = """"""
     public int a(${it[0]} a) { 0 }
     public int a(${it[1]} a) { 1 }
     ${it[0]} val = ${it[2]}
     assert a(val) == 1
  """"""
  println code
  Eval.me code
}
{code}
this will test all primitives (unless I forgot one) against an overloaded a method with on version taking the primitive and the other the wrapper. In all cases the wrapper version will chosen. This is regardless of if the call is done from the same class or not. That this codes must behave like this, is because of the arguments being wrapped at one point before doing the method selection. And while consistent, it is not what Java would do. @CompileStatic orientates itself more on Java here, since it does not support multi methods of any kind and differs from normal Groovy.

Now, the more interesting part is that of primitive vs. Object. Now in the method selection algorithm we calculate the distance between argument and parameter type. Let us say going one level in inheritance is a distance of 2, then going from the wrapper to the primitive or from the primitive to the wrapper only 1.  So a call a(1), will be done using an Integer, but the distance to Object is 2, while the distance to int is only 1, resulting in a(int) to be chosen over a(Object).

And yes, boolean and char behave different, and yes, I consider that wrong. I assume we overlooked them because the code responsible for the half steps is actually only considering widening related types and char and boolean are not taking part in widening. So [~jwagenleitner] was absolutely right with {{Integer > int > long > Long > BigInteger > float > Float > double > Double > BigDecimal > Number > Object}} though for a call with int, what is supposed to be used is actually {{int > Integer > long > Long > BigInteger > float > Float > double > Double > BigDecimal > Number > Object}} and the first chain only applies because of boxing. Since there are no calls with int, but only with Integer, this case actually never happens.

So, yes, boolean and char behaviour should be fixed
;;;","15/Sep/16 21:55;paulk;Jochen, when you run this, do you get what you expect:
{code}
int a(int a) { 0 }
int a(Integer a) { 1 }
int val = 2
assert a(val) == 1
def x = a(val)
assert x == 1
{code}
;;;","15/Sep/16 23:23;blackdrag;Paul you are right, something is not quite right. Looking at the byte I see primopts being active in this, thus there exists a call to a(int). The ValueRecorder of the powerassert on the other hand prevents using the primitive directly and then you get the call using Integer. Sigh... So here primopts diverge from indy and normal non-primopts Groovy.;;;","18/Sep/16 05:49;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/424

    GROOVY-7933: fix method selection for boolean and char primitives

    boolean and char were not factored into the primitive distance tables which
    would cause methods with Object to be selected in preference to those
    with boolean/char and their respective Wrapper.
    
    Inserted `boolean` and `char` (and their wrappers) in the distance table and kept all distances the same for the existing classes in the table (adding boolean and char as the farthest dist from the existing classes).
    
    Had to fix one test because `HashCodeHelper` has overloaded methods and prior to this change it was selecting the method with `Object` instead of `boolean`.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7933

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/424.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #424
    
----
commit 156d3f72db9e80db6f62bdc3829f2d3767c9544e
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-09-18T05:41:06Z

    GROOVY-7933: fix method selection for boolean and char primitives
    
    boolean and char were not factored into the primitive distance tables which
    would cause methods with Object to be selected in preference to those
    with boolean/char and their respective Wrapper.

----
;;;","25/Sep/16 20:35;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/424
;;;","25/Sep/16 21:15;jwagenleitner;Thanks for reporting the issue.;;;","26/Sep/16 00:37;henri;Awesome. Thanks;;;"
Cannot call private constructor from closures with @CompileStatic,GROOVY-7932,13004067,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,cazacugmihai,cazacugmihai,10/Sep/16 12:55,01/Feb/17 23:19,14/Jul/23 06:02,22/Oct/16 21:31,2.4.7,2.5.x,,,,,,,2.4.8,,,,Static compilation,,,,0,,,,,,,"{code:title=Test.groovy|borderStyle=solid}
import groovy.transform.CompileStatic

@CompileStatic
interface Handler<E> {
    void handle(E event)
}

@CompileStatic
class Person {

    final String name

    // marking this method as 'protected' will fix the issue
    private Person(String name) {
        this.name = name
    }

    static void load(String name, Handler<Person> handler) {
        Thread.start {
            Person person = new Person(name)
            handler.handle(person)
        }
    }

}

Person.load('John') { Person p ->
    println p.name
}

{code}

Error:

{quote}
Test.groovy: 20: Cannot call private constructor for Person from class Person$_load_closure1 @ line 20, column 20.
   			Person person = new Person(name)
                      ^

1 error
{quote}","Ubuntu 16.04
openjdk version ""1.8.0_91""",cazacugmihai,githubbot,jwagenleitner,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6468,,,,,GROOVY-6468,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Oct 22 21:13:44 UTC 2016,,,,,,,,,,"0|i33h9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Oct/16 20:10;shils;The static compiler needs to generate bridge methods for constructors.;;;","15/Oct/16 17:59;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/449

    GROOVY-7932: generate bridge methods for private constructors during …

    …static compilation

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7932

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/449.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #449
    
----
commit 7b0b5f81b9bffc0c3223ae18921d7f23bca83f96
Author: Shil Sinha <shils@apache.org>
Date:   2016-10-09T20:57:47Z

    GROOVY-7932: generate bridge methods for private constructors during static compilation

----
;;;","22/Oct/16 20:18;jwagenleitner;I tested the proposed PR and it also fixes the test case provided in GROOVY-6468.;;;","22/Oct/16 21:13;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/449
;;;",,,,,,,,,,,,,,,,,,
javadoc generation fails for non-indy build,GROOVY-7931,13003709,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,tinne,tinne,08/Sep/16 22:30,02/May/17 02:03,14/Jul/23 06:02,09/Sep/16 00:46,2.5.0-beta-1,,,,,,,,2.5.0-alpha-1,,,,Documentation,,,,0,,,,,,,"running {{./gradlew build}} on the current head without the indy option lets the {{:javadoc}} target fail due to java 7 code (diamond operator) in groovy reflection code and the fact that {{gradle/docs.gradle}} sets {{source = rootProject.useIndy()?'1.7':'1.6'}}.

{{./gradlew -Pindy=true javadoc}} works, {{./gradlew -Pindy=false javadoc}} produces the following error

{noformat}
:javadocD:\Projekte\Groovy\groovy\src\main\org\codehaus\groovy\reflection\CachedClass.java:89: error: diamond operator is not supported in -source 1.6
            final ArrayList<AccessibleObject> ret = new ArrayList<>(aoa.length);
                                                                  ^
  (use -source 7 or higher to enable diamond operator)

1 error
:javadoc FAILED
{noformat}","windows 64bit, java 8_102 64bit, gradlew, current mingw, current github head (latest commit d1fdc38c2c2c0539b434326b37b813328ced96a4 of 2016-09-08)",blackdrag,jwagenleitner,tinne,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 09 00:46:47 UTC 2016,,,,,,,,,,"0|i33f1r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Sep/16 22:59;blackdrag;I think this is not 2.4.7, but current master branch, since I recognize those lines as something I did just a few days ago. Since master is set to require at least 1.7, I think docs.gradle needs an update;;;","09/Sep/16 00:46;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,,
@SelfType in hierarchy with an interface in the middle,GROOVY-7930,13002766,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,daniilo,daniilo,05/Sep/16 17:33,22/Sep/22 16:33,14/Jul/23 06:02,30/Sep/16 21:40,2.4.7,,,,,,,,2.4.8,,,,Compiler,,,,0,traits,,,,,,"{code}
interface Self {
    def bar()
}

@SelfType(Self)
trait T {
    def foo() {
        println ""foo called""
        bar()
    }
}

interface Middle extends T {}

class C implements Middle {}

new C().foo()
{code}

Above code compiles fine but fails at run time with:
{noformat}
groovy.lang.MissingMethodException: No signature of method: selftype.baseinterface.C.bar() is applicable for argument types: () values: []
{noformat}

The compilation should fail like if {{Middle}} was a trait.",,blackdrag,daniilo,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Sep 30 21:40:57 UTC 2016,,,,,,,,,,"0|i3398f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Sep/16 00:26;paulk;The workaround is to use:
{code}
trait Middle extends T {}
{code}
In fact it is probably clearer intent to do it that way. But given we support leaving it as interface, we should give the same error message in that case.;;;","22/Sep/16 01:12;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/428

    GROOVY-7930: @SelfType in hierarchy with an interface in the middle

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7930

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/428.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #428
    
----
commit cd8eac239b79b3387ab223f68e0853cf55f0cc55
Author: paulk <paulk@asert.com.au>
Date:   2016-09-22T01:10:54Z

    GROOVY-7930: @SelfType in hierarchy with an interface in the middle

----
;;;","22/Sep/16 06:47;blackdrag;So all in all the title is misleading, because the issue we have been talking about here is unrelated to SelfType. In fact SelfType is totally ignored here and I think it is used only for CompileStatic. But this on the other hand I think is wrong too. Even if Middle is a trait the code should not compile, because C does not implement Self;;;","22/Sep/16 08:28;paulk;You are correct that the code shouldn't compile but it is about SelfType. After applying the PR, the sample code won't compile just like it wouldn't if referencing the trait directly instead of via Middle. ClassCompletionVerifier#checkClassExtendsAllSelfTypes checks selftypes for traits even without @CompileStatic. Of course code that relies on the selftype class won't get checked without @CompileStatic.;;;","22/Sep/16 08:33;blackdrag;ok, thanks, then everything is fine;;;","30/Sep/16 21:40;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/428
;;;","30/Sep/16 21:40;paulk;Proposed PR merged. Thanks for spotting the issue!;;;",,,,,,,,,,,,,,,
@SelfType compilation fail,GROOVY-7929,13002720,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,daniilo,daniilo,05/Sep/16 12:30,06/Mar/18 23:14,14/Jul/23 06:02,25/Jan/18 03:28,2.4.6,2.4.7,,,,,,,2.4.14,,,,Compiler,Static Type Checker,,,0,,,,,,,"{code}
class C1 {
    def c1() {}
}

@groovy.transform.CompileStatic
@groovy.transform.SelfType(C1)
trait TT {
    def foo() {
        c2()
    }
}
{code}

Fails with:
{noformat}
java.lang.UnsupportedOperationException
       	at org.codehaus.groovy.transform.stc.UnionTypeClassNode.getInnerClasses(UnionTypeClassNode.java:269)
       	at org.codehaus.groovy.transform.trait.Traits.findHelpers(Traits.java:114)
       	at org.codehaus.groovy.transform.trait.Traits.findHelper(Traits.java:104)
       	at org.codehaus.groovy.transform.stc.TraitTypeCheckingExtension.handleMissingMethod(TraitTypeCheckingExtension.java:82)
       	at org.codehaus.groovy.transform.stc.DefaultTypeCheckingExtension.handleMissingMethod(DefaultTypeCheckingExtension.java:110)
       	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2925)
       	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:317)
       	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
       	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:71)
       	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:196)
       	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:42)
       	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:37)
       	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:166)
       	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
       	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:104)
       	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:115)
       	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1784)
       	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:126)
       	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2119)
       	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2078)
       	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:164)
       	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1078)
       	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:53)
       	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:249)
       	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:123)
       	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:63)
       	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:134)
       	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:178)
       	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1053)
       	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
       	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
       	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
       	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:525)
       	at org.codehaus.groovy.tools.FileSystemCompiler.compile(FileSystemCompiler.java:61)
       	at org.codehaus.groovy.tools.FileSystemCompiler.doCompilation(FileSystemCompiler.java:217)
       	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompile(FileSystemCompiler.java:150)
       	at org.codehaus.groovy.tools.FileSystemCompiler.commandLineCompileWithErrorHandling(FileSystemCompiler.java:180)
       	at org.codehaus.groovy.tools.FileSystemCompiler.main(FileSystemCompiler.java:164)
       	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
       	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
       	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
       	at java.lang.reflect.Method.invoke(Method.java:498)
       	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)
       	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131){noformat}",,daniilo,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jan 25 03:28:35 UTC 2018,,,,,,,,,,"0|i338y7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Jan/18 03:28;paulk;Fixed. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,,,
Static type checking,GROOVY-7927,13002443,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,cazacugmihai,cazacugmihai,02/Sep/16 19:04,01/Feb/17 23:18,14/Jul/23 06:02,03/Sep/16 10:50,2.4.7,,,,,,,,2.4.8,,,,Static compilation,,,,0,,,,,,,"I have a problem running this code: 
  
{code:title=Test.groovy|borderStyle=solid}
import groovy.transform.CompileStatic 
import java.util.function.Function 
  
@CompileStatic 
class Test { 
        static void main(String[] args) { 
               // this code fails 
                Function<Integer, Integer> fct = { Integer n -> 
                        -n 
                } 
  
                // this one works but it is too verbose 
                // Function<Integer, Integer> fct = ({ Integer n -> 
                // -n 
                // } as Function<Integer, Integer>) 
  
                println fct.apply(10) 
        } 
} 
{code}

Error: 

{quote}
Test.groovy: 9: [Static type checking] - Incompatible generic argument types. Cannot assign java.util.function.Function <java.lang.Integer, groovy.lang.Closure> to: java.util.function.Function <Integer, Integer>
 @ line 9, column 36. 
   	Function<Integer, Integer> fct = { Integer n -> 
                                      ^ 
1 error 
{quote}
",,blackdrag,cazacugmihai,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7748,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 04 10:44:56 UTC 2016,,,,,,,,,,"0|i3378v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Sep/16 19:38;cazacugmihai;Can you estimate a ETA for this issue, please? I have hundreds of classes that are negatively impacted by it and I'm in a situation where I have to think if switching back to Java is an alternative in order to keep the deadline of the project. Using ""as"" in each of these classes it makes the code too ugly.

Thank you!;;;","02/Sep/16 23:19;blackdrag;does this mean this issue is a regression? Because I don´t think this worked in any 2.4 or 2.3 version of Groovy. Did you automatically convert those hundreds of classes from Java to Groovy? And can you be a bit more clear about an appropriate ETA for your case?;;;","03/Sep/16 07:01;cazacugmihai;No, it is not a regression. We recently switched (manually modified hundreds of classes) from synchronous to async calls and we had to use a lot of this kind of code:

{code}
Function<Integer, Future<String>> asyncFct1 = { ... }
Function<String, Future<Integer>> asyncFct2 = { ... }
Function<Integer, Future<String>> asyncFct3 = { ... }
chain(asyncFct1, asyncFct2, asyncFct3) { ... } 
{code}

IntellijIdea did not find any syntax problems in code until we run it. If we remove _@CompileStatic_ annotation everything it works fine but I prefer do not do this.

About ETA, it will be nice to have it ASAP. Until then we can comment that _@CompileStatic_. But, if you think that the fix of this issue will take some significant time, we will port our code (only the affected one) to Java (because of the performance reason).

Thank you!;;;","03/Sep/16 10:50;blackdrag;fixed;;;","03/Sep/16 11:05;cazacugmihai;:) I'll test it now. Thank you so much!;;;","03/Sep/16 13:28;cazacugmihai;It works. Thanks again!;;;","03/Sep/16 20:49;cazacugmihai;@[~blackdrag]: Using the latest version of groovy (built from [source|https://github.com/apache/groovy.git]) I have another static compilation issue (which doesn't exist in <= 2.4.7). The reproducer can be found [here|https://github.com/cazacugmihai/groovy_static_bug]. Please clone the project and try to run _GroovyTest_ class. 

Do you consider that I should open another issue for this one? Thanks!;;;","04/Sep/16 10:27;blackdrag;I tried 
{code:Java}
import groovy.transform.*
import org.elasticsearch.index.query.QueryBuilder

import static org.elasticsearch.index.query.QueryBuilders.rangeQuery

@Grapes(
        @Grab(group='org.elasticsearch', module='elasticsearch', version='1.5.2')
)
@CompileStatic
class GroovyTest {

    static void addHandler(List<QueryBuilder> filters) {
        filters << rangeQuery('test')
        // but this one works:
        // filters << (QueryBuilder) rangeQuery('test')
    }

    static void main(String[] args) {
        List<QueryBuilder> list = []
        addHandler(list)
        list.each { println(it) }
    }
}
{code}
and this compiles and executes;;;","04/Sep/16 10:44;cazacugmihai;Using the latest version of groovy (master branch) from Github? I know, it is not related to this issue but I just wanted you to know.;;;",,,,,,,,,,,,,
Method that returns void in a Trait with generics produces questionable byte code,GROOVY-7926,13002329,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,graemerocher1,graemerocher1,02/Sep/16 11:32,01/Feb/17 23:19,14/Jul/23 06:02,11/Sep/16 22:35,2.4.7,,,,,,,,2.4.8,,,,,,,,1,,,,,,,"Given the following trait:

{code}
trait MyTrait<D> {
    void delete() {
        // no-op
    }
}
class MyImpl implements MyTrait<MyImpl> {
}
{code}

The delete method produces byte code that when decompiled looks like:

{code}
    public void delete() {
        CallSite[] var1 = $getCallSiteArray();
        void var10000 = (void)var1[1].call(Helper.class, this);
    }
{code}

As you can see ""void"" is used as a type of a variable. This results in the following exception on the IBM JVM (it works fine in Oracle and OpenJDK):

{code}
Caused by: java.lang.NoClassDefFoundError: void
	at it.dedagroup.Test.delete(Test.groovy)
	at org.grails.datastore.gorm.GormEntity$delete$0.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
{code}

Since the issue occurs only in IBM JVM it could be argued that this is a problem with that JVM, however the byte code produced does seem suspicious to me as ""void"" cannot be used as a type of a local variable. Thoughts?",,githubbot,graemerocher1,martin_s,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 11 22:35:33 UTC 2016,,,,,,,,,,"0|i336jj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Sep/16 10:03;githubbot;GitHub user graemerocher opened a pull request:

    https://github.com/apache/groovy/pull/416

    GROOVY-7926 - Don't use a CastExpression if the return type is void.

    As per https://issues.apache.org/jira/browse/GROOVY-7926 traits currently try to cast the void type which leads to mysterious exceptions on some JVMs (notably JRocket and the IBM JVM)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/graemerocher/incubator-groovy GROOVY-7926

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/416.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #416
    
----
commit 42f014e4ffadf3aea39e07031f7cf8a7f9babe73
Author: Graeme Rocher <graeme.rocher@gmail.com>
Date:   2016-09-08T10:00:08Z

    GROOVY-7926 - Don't use a CastExpression if the return type is void.

----
;;;","08/Sep/16 10:03;graemerocher1;I have submitted a pull request for this issue https://github.com/apache/groovy/pull/416;;;","09/Sep/16 15:52;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/416#discussion_r78203740
  
    --- Diff: src/test/org/codehaus/groovy/transform/traitx/Groovy7926Bug.groovy ---
    @@ -0,0 +1,50 @@
    +package org.codehaus.groovy.transform.traitx
    +
    +import org.codehaus.groovy.classgen.asm.AbstractBytecodeTestCase
    +import org.codehaus.groovy.classgen.asm.InstructionSequence
    +
    +/**
    + * Created by graemerocher on 08/09/2016.
    + */
    +class Groovy7926Bug extends AbstractBytecodeTestCase {
    --- End diff --
    
    Would probably be good to remove the class doc and add the license header.
;;;","09/Sep/16 15:54;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/416#discussion_r78204083
  
    --- Diff: src/main/org/codehaus/groovy/transform/trait/TraitComposer.java ---
    @@ -293,7 +293,8 @@ private static void createForwarderMethod(
     
             ClassNode[] exceptionNodes = correctToGenericsSpecRecurse(genericsSpec, copyExceptions(helperMethod.getExceptions()));
             ClassNode fixedReturnType = correctToGenericsSpecRecurse(genericsSpec, helperMethod.getReturnType());
    -        Expression forwardExpression = genericsSpec.isEmpty()?mce:new CastExpression(fixedReturnType,mce);
    +        boolean noCastRequired = genericsSpec.isEmpty() || fixedReturnType.getName().equals(ClassHelper.VOID_TYPE.getName());
    --- End diff --
    
    Just curious if you saw problems using just `fixedReturnType.equals(ClassHelper.VOID_TYPE)` that neccessitated comparing by name?  Most places that I see that compare types don't see to use the getName so am just curious.
;;;","09/Sep/16 17:24;githubbot;Github user graemerocher commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/416#discussion_r78217077
  
    --- Diff: src/main/org/codehaus/groovy/transform/trait/TraitComposer.java ---
    @@ -293,7 +293,8 @@ private static void createForwarderMethod(
     
             ClassNode[] exceptionNodes = correctToGenericsSpecRecurse(genericsSpec, copyExceptions(helperMethod.getExceptions()));
             ClassNode fixedReturnType = correctToGenericsSpecRecurse(genericsSpec, helperMethod.getReturnType());
    -        Expression forwardExpression = genericsSpec.isEmpty()?mce:new CastExpression(fixedReturnType,mce);
    +        boolean noCastRequired = genericsSpec.isEmpty() || fixedReturnType.getName().equals(ClassHelper.VOID_TYPE.getName());
    --- End diff --
    
    Just seemed more efficient. ClassNode.equals does this:
    
    ```groovy
        public boolean equals(Object o) {
            if (redirect!=null) return redirect().equals(o);
            if (!(o instanceof ClassNode)) return false;
            ClassNode cn = (ClassNode) o;
            return (cn.getText().equals(getText()));
        }
    ```
    
    The `getText()` method calls `getName()` anyway
;;;","09/Sep/16 18:37;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/416#discussion_r78228482
  
    --- Diff: src/main/org/codehaus/groovy/transform/trait/TraitComposer.java ---
    @@ -293,7 +293,8 @@ private static void createForwarderMethod(
     
             ClassNode[] exceptionNodes = correctToGenericsSpecRecurse(genericsSpec, copyExceptions(helperMethod.getExceptions()));
             ClassNode fixedReturnType = correctToGenericsSpecRecurse(genericsSpec, helperMethod.getReturnType());
    -        Expression forwardExpression = genericsSpec.isEmpty()?mce:new CastExpression(fixedReturnType,mce);
    +        boolean noCastRequired = genericsSpec.isEmpty() || fixedReturnType.getName().equals(ClassHelper.VOID_TYPE.getName());
    --- End diff --
    
    Thanks for the explanation.
;;;","11/Sep/16 22:21;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/416
;;;","11/Sep/16 22:35;paulk;PR merged. Thanks!;;;",,,,,,,,,,,,,,
'this' and 'super' as LHS of an assignment,GROOVY-7925,13002193,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,01/Sep/16 22:57,01/Feb/17 23:19,14/Jul/23 06:02,11/Sep/16 22:31,,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"The following code runs successfully.
{code}
class Foo {
  static void main(String[] args) {
    assert ""${this.name} ${super.name}"" == 'Foo java.lang.Object'
    super = true
    this = false
    assert ""${this.name} ${super.name}"" == 'Foo java.lang.Object'
  }
}
{code}
The attempt to change these 'special' variables is ignored but there should be some kind of error. I think it makes sense for this to be a compilation error and it should come late in the compilation phases to allow DSLs to include 'this' or 'super' and transform them into something sensible.",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 11 22:31:12 UTC 2016,,,,,,,,,,"0|i335pb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Sep/16 12:37;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/411

    GROOVY-7925: 'this' and 'super' as LHS of an assignment

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7925

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/411.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #411
    
----
commit 521abe7a283708954c6e2fad16d860264c7f9f56
Author: paulk <paulk@asert.com.au>
Date:   2016-09-04T12:35:54Z

    GROOVY-7925: 'this' and 'super' as LHS of an assignment

----
;;;","11/Sep/16 22:29;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/groovy/pull/411
;;;","11/Sep/16 22:31;paulk;Proposed PR merged;;;",,,,,,,,,,,,,,,,,,,
groovyc fails with NPE for dynamic method/property use on super,GROOVY-7924,13001900,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,jasoma,jasoma,01/Sep/16 05:31,28/Jul/22 15:21,14/Jul/23 06:02,01/Sep/16 22:50,2.4.7,,,,,,,,2.4.8,,,,class generator,,,,0,groovyc,,,,,,"Compilation of any class that makes a dynamic call to super will fail with an NPE. Example:

{code}
class TargetClass {

    def dynamicSuperInvoke(String name) {
        super.""$name""()
    }

    def dynamicSuperAccess(String name) {
        super.""$name""
    }

}
{code}

Example project: https://github.com/jasoma/groovyc-npe-repro
","OSX, Groovy-2.4.7, Gradle-3.0",githubbot,jasoma,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-10708,GROOVY-10707,,,,,"01/Sep/16 05:32;jasoma;class-generator-error.txt;https://issues.apache.org/jira/secure/attachment/12826557/class-generator-error.txt",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Sep 01 22:50:34 UTC 2016,,,,,,,,,,"0|i333wn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Sep/16 05:32;jasoma;Exception details from groovyc;;;","01/Sep/16 12:52;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/407

    GROOVY-7924: groovyc fails with NPE for dynamic method/property use o…

    …n super

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7924

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/407.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #407
    
----
commit f86c731248e412dd49eb10b5ab239199a389a566
Author: paulk <paulk@asert.com.au>
Date:   2016-09-01T12:50:16Z

    GROOVY-7924: groovyc fails with NPE for dynamic method/property use on super

----
;;;","01/Sep/16 22:42;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/407
;;;","01/Sep/16 22:50;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,
I want to report that your latest distibution contains a Trojan,GROOVY-7923,13000480,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,keegan,rmurphy,rmurphy,26/Aug/16 18:52,13/Jan/18 17:00,14/Jul/23 06:02,31/Aug/16 23:48,,,,,,,,,,,,,,,,,0,,,,,,,"Your latest distribution, 2.4.7 contains the Trojan Rundas!plock in its uninstall.exe.  If you wish to contact me for further information, use robert.murphy@harman.com

(I have no idea what to fill out for the Component field, and I can't spare the time today to figure it out.)

Thank you",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7900,,,,,,,,,,,"26/Aug/16 18:59;rmurphy;MSE_Groovy2_4_7.PNG;https://issues.apache.org/jira/secure/attachment/12825691/MSE_Groovy2_4_7.PNG",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 31 23:48:29 UTC 2016,,,,,,,,,,"0|i32v5r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Aug/16 18:58;rmurphy;Sorry, I should have specified that the distribution that I was referring to is Groovy 2.4.7.;;;","26/Aug/16 18:59;rmurphy;Screenshot from Microsoft Security Essentials

!MSE_Groovy2_4_7.PNG|thumbnail!;;;","26/Aug/16 19:09;sebb;Where did you get the distribution from?

What is the hash of the file that you downloaded?;;;","26/Aug/16 19:25;rmurphy;Downloaded from: http://www.groovy-lang.org/download.html

The installer is groovy-2.4.7-installer.exe, dated 8/24/2016 4:04 pm size 52,613,519 bytes;;;","26/Aug/16 19:28;rmurphy;How do you want me to obtain the hash of the .exe?

r

From: Sebb [mailto:jira@apache.org]
Sent: Friday, August 26, 2016 2:10 PM
To: Murphy, Robert
Subject: [jira] [Apache Infrastructure] I want to report that your latest distibution contains a Trojan

New comment for the request ""I want to report that your latest distibution contains a Trojan"" with key INFRA-12508 has been added...
Apache Infrastructure - Something else... <https://issues.apache.org/jira/servicedesk/customer/portal/1>

Reference: INFRA-12508<https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508>


I want to report that your latest distibution contains a Trojan<https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508> Waiting for Infra

Sebb
Today 19:09
Where did you get the distribution from?

What is the hash of the file that you downloaded?


You can view the full request<https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508>

Previous activity
Robert Murphy
Today 18:59
Screenshot from Microsoft Security Essentials

!MSE_Groovy2_4_7.PNG|thumbnail!

Robert Murphy
Today 18:58
Sorry, I should have specified that the distribution that I was referring to is Groovy 2.4.7.


Details
Description

Your latest distribution, 2.4.7 contains the Trojan Rundas!plock in its uninstall.exe. If you wish to contact me for further information, use robert.murphy@harman.com<mailto:robert.murphy@harman.com>

(I have no idea what to fill out for the Component field, and I can't spare the time today to figure it out.)

Thank you

Component/s

Dists





This message is automatically generated by JIRA Service Desk.
If you think it was sent incorrectly, please contact your JIRA administrators.
For more information on JIRA Service Desk, see: http://www.atlassian.com/software/jira/service-desk


;;;","26/Aug/16 19:45;sebb;There are various tools for calculating hashes.

I have used http://implbits.com/products/hashtab/ successfully in the past.

Note: I tried downloading from http://www.groovy-lang.org/download.html
The default download is called apache-groovy-sdk-2.4.7.zip which is different from what you reported

However there is also a Windows Installer download which is https://dl.bintray.com/groovy/Distributions/groovy-2.4.7-installer.exe
This was the same size, i.e. 52,613,519 bytes
I get the following hashes:
MD5 5278DB2AB0F0D1D45317CE1B7D76F61D
SHA1 C65A3E9C2FD68356DB858643C092D12C4A700092

I tried scanning it with an uptodate version of MS Essentials - no problems reported
I then ran the installer and checked the directory structure - again no problem;;;","26/Aug/16 20:01;rmurphy;I Sebb,

I used the utility HashCalc, which gave back the same hashes as you posted below for the Windows Installer download.

I updated MSE and I suppose that I’ll run the installer again and see if it traps it again.




From: Sebb [mailto:jira@apache.org]
Sent: Friday, August 26, 2016 2:47 PM
To: Murphy, Robert
Subject: [jira] [Apache Infrastructure] I want to report that your latest distibution contains a Trojan

New comment for the request ""I want to report that your latest distibution contains a Trojan"" with key INFRA-12508 has been added...
Apache Infrastructure - Something else... <https://issues.apache.org/jira/servicedesk/customer/portal/1>

Reference: INFRA-12508<https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508>


I want to report that your latest distibution contains a Trojan<https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508> Waiting for Infra

Sebb
Today 19:45
There are various tools for calculating hashes.

I have used http://implbits.com/products/hashtab/ successfully in the past.

Note: I tried downloading from http://www.groovy-lang.org/download.html
The default download is called apache-groovy-sdk-2.4.7.zip which is different from what you reported

However there is also a Windows Installer download which is https://dl.bintray.com/groovy/Distributions/groovy-2.4.7-installer.exe
This was the same size, i.e. 52,613,519 bytes
I get the following hashes:
MD5 5278DB2AB0F0D1D45317CE1B7D76F61D
SHA1 C65A3E9C2FD68356DB858643C092D12C4A700092

I tried scanning it with an uptodate version of MS Essentials - no problems reported
I then ran the installer and checked the directory structure - again no problem


You can view the full request<https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508>

Previous activity
Robert Murphy
Today 19:28
How do you want me to obtain the hash of the .exe?

r

From: Sebb [mailto: jira@apache.org<mailto:jira@apache.org>]
Sent: Friday, August 26, 2016 2:10 PM
To: Murphy, Robert
Subject: [jira] [Apache Infrastructure] I want to report that your latest distibution contains a Trojan

New comment for the request ""I want to report that your latest distibution contains a Trojan"" with key INFRA-12508<https://issues.apache.org/jira/browse/INFRA-12508> has been added...
Apache Infrastructure - Something else... < https://issues.apache.org/jira/servicedesk/customer/portal/1>

Reference: INFRA-12508<https://issues.apache.org/jira/browse/INFRA-12508>< https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508>


I want to report that your latest distibution contains a Trojan< https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508> Waiting for Infra

Sebb
Today 19:09
Where did you get the distribution from?

What is the hash of the file that you downloaded?


You can view the full request< https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508>

Previous activity
Robert Murphy
Today 18:59
Screenshot from Microsoft Security Essentials

!MSE_Groovy2_4_7.PNG|thumbnail!

Robert Murphy
Today 18:58
Sorry, I should have specified that the distribution that I was referring to is Groovy 2.4.7.


Details
Description

Your latest distribution, 2.4.7 contains the Trojan Rundas!plock in its uninstall.exe. If you wish to contact me for further information, use robert.murphy@harman.com<mailto:robert.murphy@harman.com><mailto: robert.murphy@harman.com<mailto:robert.murphy@harman.com>>

(I have no idea what to fill out for the Component field, and I can't spare the time today to figure it out.)

Thank you

Component/s

Dists





This message is automatically generated by JIRA Service Desk.
If you think it was sent incorrectly, please contact your JIRA administrators.
For more information on JIRA Service Desk, see: http://www.atlassian.com/software/jira/service-desk


Robert Murphy
Today 19:25
Downloaded from: http://www.groovy-lang.org/download.html

The installer is groovy-2.4.7-installer.exe, dated 8/24/2016 4:04 pm size 52,613,519 bytes

Sebb
Today 19:09
Where did you get the distribution from?

What is the hash of the file that you downloaded?


2 older messages<https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508>



Details
Description

Your latest distribution, 2.4.7 contains the Trojan Rundas!plock in its uninstall.exe. If you wish to contact me for further information, use robert.murphy@harman.com<mailto:robert.murphy@harman.com>

(I have no idea what to fill out for the Component field, and I can't spare the time today to figure it out.)

Thank you

Component/s

Dists





This message is automatically generated by JIRA Service Desk.
If you think it was sent incorrectly, please contact your JIRA administrators.
For more information on JIRA Service Desk, see: http://www.atlassian.com/software/jira/service-desk


;;;","26/Aug/16 20:27;rmurphy;Unfortunately, after updating MSE, reinstalling Groovy 2.4.7, and then running a scan using MSE, it flagged that uninstall.exe and the corresponding registry entrieswith the same message as it did previously.

r

From: Sebb [mailto:jira@apache.org]
Sent: Friday, August 26, 2016 2:47 PM
To: Murphy, Robert
Subject: [jira] [Apache Infrastructure] I want to report that your latest distibution contains a Trojan

New comment for the request ""I want to report that your latest distibution contains a Trojan"" with key INFRA-12508 has been added...
Apache Infrastructure - Something else... <https://issues.apache.org/jira/servicedesk/customer/portal/1>

Reference: INFRA-12508<https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508>


I want to report that your latest distibution contains a Trojan<https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508> Waiting for Infra

Sebb
Today 19:45
There are various tools for calculating hashes.

I have used http://implbits.com/products/hashtab/ successfully in the past.

Note: I tried downloading from http://www.groovy-lang.org/download.html
The default download is called apache-groovy-sdk-2.4.7.zip which is different from what you reported

However there is also a Windows Installer download which is https://dl.bintray.com/groovy/Distributions/groovy-2.4.7-installer.exe
This was the same size, i.e. 52,613,519 bytes
I get the following hashes:
MD5 5278DB2AB0F0D1D45317CE1B7D76F61D
SHA1 C65A3E9C2FD68356DB858643C092D12C4A700092

I tried scanning it with an uptodate version of MS Essentials - no problems reported
I then ran the installer and checked the directory structure - again no problem


You can view the full request<https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508>

Previous activity
Robert Murphy
Today 19:28
How do you want me to obtain the hash of the .exe?

r

From: Sebb [mailto: jira@apache.org<mailto:jira@apache.org>]
Sent: Friday, August 26, 2016 2:10 PM
To: Murphy, Robert
Subject: [jira] [Apache Infrastructure] I want to report that your latest distibution contains a Trojan

New comment for the request ""I want to report that your latest distibution contains a Trojan"" with key INFRA-12508<https://issues.apache.org/jira/browse/INFRA-12508> has been added...
Apache Infrastructure - Something else... < https://issues.apache.org/jira/servicedesk/customer/portal/1>

Reference: INFRA-12508<https://issues.apache.org/jira/browse/INFRA-12508>< https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508>


I want to report that your latest distibution contains a Trojan< https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508> Waiting for Infra

Sebb
Today 19:09
Where did you get the distribution from?

What is the hash of the file that you downloaded?


You can view the full request< https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508>

Previous activity
Robert Murphy
Today 18:59
Screenshot from Microsoft Security Essentials

!MSE_Groovy2_4_7.PNG|thumbnail!

Robert Murphy
Today 18:58
Sorry, I should have specified that the distribution that I was referring to is Groovy 2.4.7.


Details
Description

Your latest distribution, 2.4.7 contains the Trojan Rundas!plock in its uninstall.exe. If you wish to contact me for further information, use robert.murphy@harman.com<mailto:robert.murphy@harman.com><mailto: robert.murphy@harman.com<mailto:robert.murphy@harman.com>>

(I have no idea what to fill out for the Component field, and I can't spare the time today to figure it out.)

Thank you

Component/s

Dists





This message is automatically generated by JIRA Service Desk.
If you think it was sent incorrectly, please contact your JIRA administrators.
For more information on JIRA Service Desk, see: http://www.atlassian.com/software/jira/service-desk


Robert Murphy
Today 19:25
Downloaded from: http://www.groovy-lang.org/download.html

The installer is groovy-2.4.7-installer.exe, dated 8/24/2016 4:04 pm size 52,613,519 bytes

Sebb
Today 19:09
Where did you get the distribution from?

What is the hash of the file that you downloaded?


2 older messages<https://issues.apache.org/jira/servicedesk/customer/portal/1/INFRA-12508>



Details
Description

Your latest distribution, 2.4.7 contains the Trojan Rundas!plock in its uninstall.exe. If you wish to contact me for further information, use robert.murphy@harman.com<mailto:robert.murphy@harman.com>

(I have no idea what to fill out for the Component field, and I can't spare the time today to figure it out.)

Thank you

Component/s

Dists





This message is automatically generated by JIRA Service Desk.
If you think it was sent incorrectly, please contact your JIRA administrators.
For more information on JIRA Service Desk, see: http://www.atlassian.com/software/jira/service-desk


;;;","31/Aug/16 12:16;gmcdonald;Im going to move this ticket to the correct Jira project (Groovy)
;;;","31/Aug/16 23:48;paulk;Duplicates GROOVY-7900.;;;",,,,,,,,,,,,
Static type checking not strict enough in the presence of ambiguous method matching,GROOVY-7922,13000963,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,paulk,paulk,29/Aug/16 13:05,01/Feb/17 23:19,14/Jul/23 06:02,20/Sep/16 03:32,,,,,,,,,2.4.8,,,,Static Type Checker,,,,0,,,,,,,"This example:
{code}
import groovy.transform.CompileStatic

interface FooA {}
interface FooB {}
class FooAB implements FooA, FooB {}
@CompileStatic
class TestGroovy {
    static void test() { println new TestGroovy().foo(new FooAB()) }
    def foo(FooB x) { 43 }
    def foo(FooA x) { 42 }
}

TestGroovy.test()
{code}
Should probably throw some kind of ambiguous method error during compilation to match Java (and dynamic Groovy's runtime error).",,githubbot,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Sep 20 03:32:22 UTC 2016,,,,,,,,,,"0|i32y4f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Sep/16 11:38;githubbot;GitHub user blindpirate opened a pull request:

    https://github.com/apache/groovy/pull/422

    GROOVY-7922: Static type checking not strict enough in the presence o…

    …f ambiguous method matching
    
    
    the issue has been resolved and some refactor are done

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/blindpirate/groovy groovy7922bug

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/422.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #422
    
----
commit b2d84738986fc83a589e78ec205bb206318a1e4a
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-09-16T00:29:11Z

    GROOVY-7922: Static type checking not strict enough in the presence of ambiguous method matching

----
;;;","16/Sep/16 19:19;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/422#discussion_r79234404
  
    --- Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java ---
    @@ -1157,6 +1141,56 @@ private static ClassNode makeRawType(final ClassNode receiver) {
             return result;
         }
     
    +    private static void removeMethodInSuperInterface(List<MethodNode> toBeRemoved, MethodNode one, MethodNode two) {
    +        ClassNode oneDC=one.getDeclaringClass();
    +        ClassNode twoDC=two.getDeclaringClass();
    +        if(oneDC.implementsInterface(twoDC)){
    +            toBeRemoved.add(two);
    +        }else{
    +            toBeRemoved.add(one);
    +        }
    +    }
    +
    +    private static boolean areEquivalentInterfaceMethods(MethodNode one, MethodNode two, Parameter[] onePars, Parameter[] twoPars) {
    +        return one.getName().equals(two.getName())
    +                && one.getDeclaringClass().isInterface()
    +                && two.getDeclaringClass().isInterface()
    +                && allParameterTypesAreSame(onePars, twoPars);
    +    }
    +
    +    private static void removeSyntheticMethodIfOne(List<MethodNode> toBeRemoved, MethodNode one, MethodNode two) {
    +        if (one.isSynthetic() && !two.isSynthetic()) {
    +            toBeRemoved.add(one);
    +        } else if (two.isSynthetic() && !one.isSynthetic()) {
    +            toBeRemoved.add(two);
    +        }
    +    }
    +
    +    private static void removeMethodWithSuperReturnType(List<MethodNode> toBeRemoved, MethodNode one, MethodNode two) {
    +        ClassNode oneRT = one.getReturnType();
    +        ClassNode twoRT = two.getReturnType();
    +        if (oneRT.isDerivedFrom(twoRT) || oneRT.implementsInterface(twoRT)) {
    +            toBeRemoved.add(two);
    +        } else if (twoRT.isDerivedFrom(oneRT) || twoRT.implementsInterface(oneRT)) {
    +            toBeRemoved.add(one);
    +        }
    +    }
    +
    +    private static boolean areOverloadMethodsInSameClass(MethodNode one, MethodNode two){
    +        return one.getName().equals(two.getName()) && one.getDeclaringClass()==two.getDeclaringClass();
    +    }
    +
    +    private static boolean allParameterTypesAreSame(Parameter[] onePars, Parameter[] twoPars) {
    --- End diff --
    
    Might be able to use [`ParameterUtils#parametersEqual(Parameter[],Parameter[])`] (https://github.com/apache/groovy/blob/14266ad5b7c265b55334c029e87b1d79ebd2210e/src/main/org/codehaus/groovy/ast/tools/ParameterUtils.java#L26-L38) instead of this new method.
;;;","17/Sep/16 01:06;githubbot;Github user blindpirate commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/422#discussion_r79272298
  
    --- Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java ---
    @@ -1157,6 +1141,56 @@ private static ClassNode makeRawType(final ClassNode receiver) {
             return result;
         }
     
    +    private static void removeMethodInSuperInterface(List<MethodNode> toBeRemoved, MethodNode one, MethodNode two) {
    +        ClassNode oneDC=one.getDeclaringClass();
    +        ClassNode twoDC=two.getDeclaringClass();
    +        if(oneDC.implementsInterface(twoDC)){
    +            toBeRemoved.add(two);
    +        }else{
    +            toBeRemoved.add(one);
    +        }
    +    }
    +
    +    private static boolean areEquivalentInterfaceMethods(MethodNode one, MethodNode two, Parameter[] onePars, Parameter[] twoPars) {
    +        return one.getName().equals(two.getName())
    +                && one.getDeclaringClass().isInterface()
    +                && two.getDeclaringClass().isInterface()
    +                && allParameterTypesAreSame(onePars, twoPars);
    +    }
    +
    +    private static void removeSyntheticMethodIfOne(List<MethodNode> toBeRemoved, MethodNode one, MethodNode two) {
    +        if (one.isSynthetic() && !two.isSynthetic()) {
    +            toBeRemoved.add(one);
    +        } else if (two.isSynthetic() && !one.isSynthetic()) {
    +            toBeRemoved.add(two);
    +        }
    +    }
    +
    +    private static void removeMethodWithSuperReturnType(List<MethodNode> toBeRemoved, MethodNode one, MethodNode two) {
    +        ClassNode oneRT = one.getReturnType();
    +        ClassNode twoRT = two.getReturnType();
    +        if (oneRT.isDerivedFrom(twoRT) || oneRT.implementsInterface(twoRT)) {
    +            toBeRemoved.add(two);
    +        } else if (twoRT.isDerivedFrom(oneRT) || twoRT.implementsInterface(oneRT)) {
    +            toBeRemoved.add(one);
    +        }
    +    }
    +
    +    private static boolean areOverloadMethodsInSameClass(MethodNode one, MethodNode two){
    +        return one.getName().equals(two.getName()) && one.getDeclaringClass()==two.getDeclaringClass();
    +    }
    +
    +    private static boolean allParameterTypesAreSame(Parameter[] onePars, Parameter[] twoPars) {
    --- End diff --
    
    Oh, you're right. I will use this method instead.
;;;","17/Sep/16 16:03;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/422#discussion_r79286871
  
    --- Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java ---
    @@ -1157,6 +1141,56 @@ private static ClassNode makeRawType(final ClassNode receiver) {
             return result;
         }
     
    +    private static void removeMethodInSuperInterface(List<MethodNode> toBeRemoved, MethodNode one, MethodNode two) {
    +        ClassNode oneDC=one.getDeclaringClass();
    +        ClassNode twoDC=two.getDeclaringClass();
    +        if(oneDC.implementsInterface(twoDC)){
    +            toBeRemoved.add(two);
    +        }else{
    +            toBeRemoved.add(one);
    +        }
    +    }
    +
    +    private static boolean areEquivalentInterfaceMethods(MethodNode one, MethodNode two, Parameter[] onePars, Parameter[] twoPars) {
    +        return one.getName().equals(two.getName())
    +                && one.getDeclaringClass().isInterface()
    +                && two.getDeclaringClass().isInterface()
    +                && allParameterTypesAreSame(onePars, twoPars);
    +    }
    +
    +    private static void removeSyntheticMethodIfOne(List<MethodNode> toBeRemoved, MethodNode one, MethodNode two) {
    +        if (one.isSynthetic() && !two.isSynthetic()) {
    +            toBeRemoved.add(one);
    +        } else if (two.isSynthetic() && !one.isSynthetic()) {
    +            toBeRemoved.add(two);
    +        }
    +    }
    +
    +    private static void removeMethodWithSuperReturnType(List<MethodNode> toBeRemoved, MethodNode one, MethodNode two) {
    +        ClassNode oneRT = one.getReturnType();
    +        ClassNode twoRT = two.getReturnType();
    +        if (oneRT.isDerivedFrom(twoRT) || oneRT.implementsInterface(twoRT)) {
    +            toBeRemoved.add(two);
    +        } else if (twoRT.isDerivedFrom(oneRT) || twoRT.implementsInterface(oneRT)) {
    +            toBeRemoved.add(one);
    +        }
    +    }
    +
    +    private static boolean areOverloadMethodsInSameClass(MethodNode one, MethodNode two){
    +        return one.getName().equals(two.getName()) && one.getDeclaringClass()==two.getDeclaringClass();
    +    }
    +
    +    private static boolean allParameterTypesAreSame(Parameter[] onePars, Parameter[] twoPars) {
    --- End diff --
    
    I think I can +1 it after the change John suggested
;;;","18/Sep/16 05:30;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/422#discussion_r79297750
  
    --- Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java ---
    @@ -1157,6 +1142,45 @@ private static ClassNode makeRawType(final ClassNode receiver) {
             return result;
         }
     
    +    private static void removeMethodInSuperInterface(List<MethodNode> toBeRemoved, MethodNode one, MethodNode two) {
    +        ClassNode oneDC=one.getDeclaringClass();
    +        ClassNode twoDC=two.getDeclaringClass();
    +        if(oneDC.implementsInterface(twoDC)){
    +            toBeRemoved.add(two);
    +        }else{
    +            toBeRemoved.add(one);
    +        }
    +    }
    +
    +    private static boolean areEquivalentInterfaceMethods(MethodNode one, MethodNode two, Parameter[] onePars, Parameter[] twoPars) {
    --- End diff --
    
    I think it would simplify things if this just took 2 MethodNode's, the parameters can be gotten from the nodes so no need to pass them in I think?
;;;","18/Sep/16 05:30;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/422#discussion_r79297788
  
    --- Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java ---
    @@ -1116,39 +1117,23 @@ private static ClassNode makeRawType(final ClassNode receiver) {
                 for (int j=i+1;j<list.size();j++) {
                     MethodNode two = list.get(j);
                     if (toBeRemoved.contains(two)) continue;
    -                if (one.getName().equals(two.getName()) && one.getDeclaringClass()==two.getDeclaringClass()) {
    -                    Parameter[] onePars = one.getParameters();
    -                    Parameter[] twoPars = two.getParameters();
    -                    if (onePars.length == twoPars.length) {
    -                        boolean sameTypes = true;
    -                        for (int k = 0; k < onePars.length; k++) {
    -                            Parameter onePar = onePars[k];
    -                            Parameter twoPar = twoPars[k];
    -                            if (!onePar.getType().equals(twoPar.getType())) {
    -                                sameTypes = false;
    -                                break;
    -                            }
    -                        }
    -                        if (sameTypes) {
    -                            ClassNode oneRT = one.getReturnType();
    -                            ClassNode twoRT = two.getReturnType();
    -                            if (oneRT.isDerivedFrom(twoRT) || oneRT.implementsInterface(twoRT)) {
    -                                toBeRemoved.add(two);
    -                            } else if (twoRT.isDerivedFrom(oneRT) || twoRT.implementsInterface(oneRT)) {
    -                                toBeRemoved.add(one);
    -                            }
    +                Parameter[] onePars = one.getParameters();
    +                Parameter[] twoPars = two.getParameters();
    +                if (onePars.length == twoPars.length) {
    +                    if (areOverloadMethodsInSameClass(one,two)) {
    +                        if (ParameterUtils.parametersEqual(onePars, twoPars)){
    --- End diff --
    
    If the `Parameter[]` parameters are removed from `areEquivalentInterfaceMethods` method I think these arguments can be replaced with `one.getParameters(), two.getParameters()` and then the local variables wouldn't be needed.  Just a suggestion.
;;;","18/Sep/16 06:52;githubbot;Github user blindpirate commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/422#discussion_r79298948
  
    --- Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java ---
    @@ -1157,6 +1142,45 @@ private static ClassNode makeRawType(final ClassNode receiver) {
             return result;
         }
     
    +    private static void removeMethodInSuperInterface(List<MethodNode> toBeRemoved, MethodNode one, MethodNode two) {
    +        ClassNode oneDC=one.getDeclaringClass();
    +        ClassNode twoDC=two.getDeclaringClass();
    +        if(oneDC.implementsInterface(twoDC)){
    +            toBeRemoved.add(two);
    +        }else{
    +            toBeRemoved.add(one);
    +        }
    +    }
    +
    +    private static boolean areEquivalentInterfaceMethods(MethodNode one, MethodNode two, Parameter[] onePars, Parameter[] twoPars) {
    --- End diff --
    
    Yes, good suggestion. I will do that.
;;;","20/Sep/16 03:26;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/422
;;;","20/Sep/16 03:32;jwagenleitner;Proposed PR merged.;;;",,,,,,,,,,,,,
"using ""this"" as the target of an assignment not working with Category annotation",GROOVY-7921,13000691,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,kyon.mm@gmail.com,kyon.mm@gmail.com,27/Aug/16 15:42,01/Feb/17 23:18,14/Jul/23 06:02,31/Aug/16 02:45,2.4.7,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"when I executed this code in GroovyConsole
{code:java}
@Category(Integer)
class IntegerEx {
  def reset(int value) {
    this = value
    this
  }
}
use(IntegerEx){
  println (1 + 2).reset(1)
}
{code}

Then, I get this exception log
{code}
Exception thrown

BUG! exception in phase 'semantic analysis' in source unit 'ConsoleScript17' null
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:935)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:593)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:542)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:688)
	at groovy.lang.GroovyShell.run(GroovyShell.java:517)
	at groovy.lang.GroovyShell.run(GroovyShell.java:497)
	at groovy.lang.GroovyShell.run(GroovyShell.java:170)
	at groovy.lang.GroovyShell$run$1.call(Unknown Source)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy:1005)
	at groovy.ui.Console$_runScriptImpl_closure16.doCall(Console.groovy)
	at sun.reflect.GeneratedMethodAccessor218.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:294)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1024)
	at groovy.lang.Closure.call(Closure.java:414)
	at groovy.lang.Closure.call(Closure.java:408)
	at groovy.lang.Closure.run(Closure.java:495)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.classgen.VariableScopeVisitor.checkForFinal(VariableScopeVisitor.java:388)
	at org.codehaus.groovy.classgen.VariableScopeVisitor.checkFinalFieldAccess(VariableScopeVisitor.java:381)
	at org.codehaus.groovy.classgen.VariableScopeVisitor.visitBinaryExpression(VariableScopeVisitor.java:365)
	at org.codehaus.groovy.ast.expr.BinaryExpression.visit(BinaryExpression.java:51)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:196)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:42)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:37)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:166)
	at org.codehaus.groovy.classgen.VariableScopeVisitor.visitBlockStatement(VariableScopeVisitor.java:308)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:104)
	at org.codehaus.groovy.classgen.VariableScopeVisitor.visitConstructorOrMethod(VariableScopeVisitor.java:505)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:126)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1078)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:53)
	at org.codehaus.groovy.classgen.VariableScopeVisitor.visitClass(VariableScopeVisitor.java:473)
	at org.codehaus.groovy.control.CompilationUnit$11.call(CompilationUnit.java:648)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:931)
	... 22 more
{code}

Is this behavior groovy-language specification ?","mac os x 10.10.5
jdk 1.8.0_51",blackdrag,githubbot,kyon.mm@gmail.com,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6947,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 31 22:41:57 UTC 2016,,,,,,,,,,"0|i32wgn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Aug/16 16:36;blackdrag;You are not supposed to ever see the ""BUG! exception"" message. So no, this is not right. ""this = value"" is not supposed to compile;;;","27/Aug/16 17:13;kyon.mm@gmail.com;[~blackdrag] thank you comment.

In my case, I will change this code as follows:
{code:java}
@Category(Integer)
class IntegerEx {
  def static reset(Integer self, Integer value) { // change
    self = value // change
    self
  }
}
use(IntegerEx){
  println ((1 + 2).reset(1))
}
{code}
;;;","27/Aug/16 17:25;blackdrag;Your category will return a new Integer, not mutate the old one. In that case 
{code}
  def static reset(Integer self, Integer value) {
    self
  }
{code}
would be already good enough. In Groovy you can in theory mutate the Integer, but you really should not. The lower few Integer objects are cached (see Integer.valueOf), so mutating one Integer here would have undesired side effects elsewhere.;;;","27/Aug/16 17:38;kyon.mm@gmail.com;Oh, certainly it's right.

I will carefully design. thx.;;;","28/Aug/16 09:18;paulk;{{this}} will be changed to {{$this}} by the Category transform (basically {{self}} as per examples above). So your code isn't incorrect but a little strange. In any case final variable analysis is being run prior to the Category transform which is how the error occurs - since it doesn't make sense to check {{this}} in the same way as other variables. In any case, just returning the {{value}} parameter will accomplish the same thing, so I'd avoid using the strange style. But perhaps you have shortened a more complex example and there might be some scenario where it could make sense to use {{this}}. Just remember that it will be transformed to {{$this}}.;;;","28/Aug/16 09:23;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/400

    GROOVY-7921: using ""this"" as the target of an assignment not working …

    …with Category annotation

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7921

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/400.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #400
    
----
commit db2bbcce46528bb87afd68855caa1118da5b0164
Author: paulk <paulk@asert.com.au>
Date:   2016-08-28T09:21:37Z

    GROOVY-7921: using ""this"" as the target of an assignment not working with Category annotation

----
;;;","30/Aug/16 07:27;kyon.mm@gmail.com;[~paulk] thank you for your comments.
I can not explain my code simply, so I have shortened my code. I'm sorry for that strange example.
these comments are helpful for me.;;;","31/Aug/16 02:42;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/400
;;;","31/Aug/16 02:45;paulk;Proposed PR merged. You can now use 'this' as the target of an assignment for the purposes of @Category or your own DSL. It makes no sense to use 'this' for normal purposes.;;;","31/Aug/16 16:14;blackdrag;in a normal Groovy program ""this=1"" should not compile. A DSL must transform it to something useful. I get the impression, that after PR 400 we are now simply ignoring a ""this=1"". And I think that is not right either.  If we want to error this, but still want to allow it for DSLs, we need a check for it in the verfier for example. Or fail in VariableScopeVisitor, but then it is useless for most DSLs;;;","31/Aug/16 22:41;paulk;Totally agree. I was keeping this issue to just removing the ""BUG! exception"". We need to raise another issue for catching and reporting left over ""this"" assignments. Implemented in somewhere like the Verifier sounds right to me.;;;",,,,,,,,,,,
Simple getAt example produces a BUG exception,GROOVY-7920,13000495,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,teras,teras,26/Aug/16 19:41,02/May/17 02:03,14/Jul/23 06:02,29/Aug/16 13:03,2.4.7,,,,,,,,2.5.0-alpha-1,,,,groovy-runtime,,,,0,,,,,,,"When I created this simple class:
{code}
package com.panayotis
import groovy.transform.CompileStatic
@CompileStatic
class TestGroovy {
    void test() { new TestGroovy()[3] }
    def getAt(def x) { 42 }	
}
{code}

when compiling with gradle I was informed that there is a bug and I should report it.
This is the simplest class I could make.

The exception follows
{noformat}
org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':compileGroovy'.
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:69)
        at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)
        at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)
        at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)
        at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)
        at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:52)
        at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)
        at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)
        at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)
        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:203)
        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:185)
        at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:74)
        at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:55)
        at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.process(DefaultTaskPlanExecutor.java:32)
        at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:110)
        at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:37)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:37)
        at org.gradle.execution.DefaultBuildExecuter.access$000(DefaultBuildExecuter.java:23)
        at org.gradle.execution.DefaultBuildExecuter$1.proceed(DefaultBuildExecuter.java:43)
        at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:37)
        at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:30)
        at org.gradle.initialization.DefaultGradleLauncher$4.run(DefaultGradleLauncher.java:153)
        at org.gradle.internal.Factories$1.create(Factories.java:22)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:91)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:53)
        at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:150)
        at org.gradle.initialization.DefaultGradleLauncher.access$200(DefaultGradleLauncher.java:32)
        at org.gradle.initialization.DefaultGradleLauncher$1.create(DefaultGradleLauncher.java:98)
        at org.gradle.initialization.DefaultGradleLauncher$1.create(DefaultGradleLauncher.java:92)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:91)
        at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:63)
        at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:92)
        at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:83)
        at org.gradle.launcher.exec.InProcessBuildActionExecuter$DefaultBuildController.run(InProcessBuildActionExecuter.java:94)
        at org.gradle.tooling.internal.provider.ExecuteBuildActionRunner.run(ExecuteBuildActionRunner.java:28)
        at org.gradle.launcher.exec.ChainingBuildActionRunner.run(ChainingBuildActionRunner.java:35)
        at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:43)
        at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:28)
        at org.gradle.launcher.exec.ContinuousBuildActionExecuter.execute(ContinuousBuildActionExecuter.java:82)
        at org.gradle.launcher.exec.ContinuousBuildActionExecuter.execute(ContinuousBuildActionExecuter.java:49)
        at org.gradle.launcher.daemon.server.exec.ExecuteBuild.doBuild(ExecuteBuild.java:59)
        at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:36)
        at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:120)
        at org.gradle.launcher.daemon.server.exec.WatchForDisconnection.execute(WatchForDisconnection.java:49)
        at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:120)
        at org.gradle.launcher.daemon.server.exec.ResetDeprecationLogger.execute(ResetDeprecationLogger.java:26)
        at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:120)
        at org.gradle.launcher.daemon.server.exec.RequestStopIfSingleUsedDaemon.execute(RequestStopIfSingleUsedDaemon.java:34)
        at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:120)
        at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:74)
        at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:72)
        at org.gradle.util.Swapper.swap(Swapper.java:38)
        at org.gradle.launcher.daemon.server.exec.ForwardClientInput.execute(ForwardClientInput.java:72)
        at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:120)
        at org.gradle.launcher.daemon.server.exec.LogAndCheckHealth.execute(LogAndCheckHealth.java:55)
        at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:120)
        at org.gradle.launcher.daemon.server.exec.LogToClient.doBuild(LogToClient.java:60)
        at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:36)
        at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:120)
        at org.gradle.launcher.daemon.server.exec.EstablishBuildEnvironment.doBuild(EstablishBuildEnvironment.java:72)
        at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:36)
        at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:120)
        at org.gradle.launcher.daemon.server.exec.HintGCAfterBuild.execute(HintGCAfterBuild.java:44)
        at org.gradle.launcher.daemon.server.api.DaemonCommandExecution.proceed(DaemonCommandExecution.java:120)
        at org.gradle.launcher.daemon.server.exec.StartBuildOrRespondWithBusy$1.run(StartBuildOrRespondWithBusy.java:50)
        at org.gradle.launcher.daemon.server.DaemonStateCoordinator$1.run(DaemonStateCoordinator.java:240)
        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
        at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
Caused by: BUG! exception in phase 'class generation' in source unit '/Users/teras/Downloads/workshop/swing-example/src/main/groovy/com/panayotis/TestGroovy.groovy' At line 5 column 19
On receiver: new com.panayotis.TestGroovy() with message: getAt and arguments: 3
This method should not have been called. Please try to create a simple example reproducing this error and filea bug report at https://issues.apache.org/jira/browse/GROOVY
        at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:173)
        at org.gradle.api.internal.tasks.compile.ApiGroovyCompiler.execute(ApiGroovyCompiler.java:59)
        at org.gradle.api.internal.tasks.compile.daemon.CompilerDaemonServer.execute(CompilerDaemonServer.java:31)
        at org.gradle.process.internal.worker.request.WorkerAction.run(WorkerAction.java:87)
        at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
        at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
        at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:377)
        ... 2 more
{noformat}
","OS X, gradle 3.0",githubbot,paulk,teras,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Aug 29 13:03:26 UTC 2016,,,,,,,,,,"0|i32v93:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Aug/16 03:24;paulk;Not related to gradle. We should obviously handle this case but the workaround is to use {{int x}} instead of {{def x}}. ;;;","27/Aug/16 04:39;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/399

    GROOVY-7920: Simple getAt example produces a BUG exception

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7920

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/399.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #399
    
----
commit 7fdf19188961a229b4d491275643418c03645007
Author: paulk <paulk@asert.com.au>
Date:   2016-08-27T04:37:35Z

    GROOVY-7920: Simple getAt example produces a BUG exception

----
;;;","29/Aug/16 13:00;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/399
;;;","29/Aug/16 13:03;paulk;Proposed PR merged. Thanks for reporting the issue. Fixed just on master for now (targeting 2.5).;;;",,,,,,,,,,,,,,,,,,
Sub class can't override final static property,GROOVY-7917,12999790,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,cott@redstonecontentsolutions.com,cott@redstonecontentsolutions.com,24/Aug/16 20:36,01/Feb/17 23:19,14/Jul/23 06:02,25/Aug/16 06:49,2.4.7,,,,,,,,2.4.8,,,,class generator,,,,0,,,,,,,"Running the code below, ""Derived Class"" is expected to be printed out, but instead ""Base Class"" is printed.

{code:java}
class Base {
    static final String CONST = ""Base Class""
}

class Derived extends Base {
    static final String CONST = ""Derived Class""
}

println Derived.CONST
{code}

When writing this same code in Java, ""Derived Class"" is properly printed out.",,cott@redstonecontentsolutions.com,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 25 06:49:22 UTC 2016,,,,,,,,,,"0|i32qw7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Aug/16 00:49;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/394

    GROOVY-7917: Sub class can't override final static property

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7917

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/394.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #394
    
----
commit 5f5dec72bc8f1e84ac9c29341968017a49ea7c5f
Author: paulk <paulk@asert.com.au>
Date:   2016-08-25T00:47:47Z

    GROOVY-7917: Sub class can't override final static property

----
;;;","25/Aug/16 06:46;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/394
;;;","25/Aug/16 06:49;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,
MissingPropertyException when accessing a static inner class member from a sub class,GROOVY-7916,12999779,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,cott@redstonecontentsolutions.com,cott@redstonecontentsolutions.com,24/Aug/16 19:58,01/Feb/17 23:18,14/Jul/23 06:02,28/Aug/16 05:23,2.4.7,,,,,,,,2.4.8,,,,class generator,,,,0,,,,,,,"Run the following code in groovy to get the error.

{code:java}
class Base {
    static class Inner {
        static final String CONST = ""Hello World"";
    }
}

class Derived extends Base {
    // empty for this example
}

println Derived.Inner.CONST
{code}

Error:
{code}
Caught: groovy.lang.MissingPropertyException: No such property: Inner for class: Derived
groovy.lang.MissingPropertyException: No such property: Inner for class: Derived
{code}

This code can be easily converted to Java and in Java everything works as it should.

GROOVY-7762 seems to be a related issue.

I've verified the issue is on this line...
{code}println Derived.Inner.CONST{code}
...because I tried writing the two classes in Java and still have the same issue.",,cott@redstonecontentsolutions.com,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 28 05:23:19 UTC 2016,,,,,,,,,,"0|i32qtr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Aug/16 02:27;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/397

    GROOVY-7916: MissingPropertyException when accessing a static inner c…

    …lass member from a sub class

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7916

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/397.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #397
    
----

----
;;;","26/Aug/16 06:05;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/397#discussion_r76368032
  
    --- Diff: src/main/org/codehaus/groovy/control/ResolveVisitor.java ---
    @@ -852,6 +858,21 @@ protected Expression transformPropertyExpression(PropertyExpression pe) {
             return ret;
         }
     
    +    private boolean isVisibleNestedClass(ClassNode type, ClassNode ceType) {
    +        if (!type.isRedirectNode()) return false;
    +        ClassNode redirect = type.redirect();
    +        // public or private
    +        if (Modifier.isPublic(redirect.getModifiers()) || Modifier.isProtected(redirect.getModifiers())) return true;
    --- End diff --
    
    The comment is misleading (private -> protected), but the code reads very good so maybe no comment needed.
;;;","26/Aug/16 06:29;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/397#discussion_r76369713
  
    --- Diff: src/main/org/codehaus/groovy/control/ResolveVisitor.java ---
    @@ -852,6 +858,21 @@ protected Expression transformPropertyExpression(PropertyExpression pe) {
             return ret;
         }
     
    +    private boolean isVisibleNestedClass(ClassNode type, ClassNode ceType) {
    +        if (!type.isRedirectNode()) return false;
    +        ClassNode redirect = type.redirect();
    +        // public or private
    +        if (Modifier.isPublic(redirect.getModifiers()) || Modifier.isProtected(redirect.getModifiers())) return true;
    +        // package local
    +        PackageNode classPackage = ceType.getPackage();
    +        PackageNode nestedPackage = redirect.getPackage();
    +        if ((redirect.getModifiers() & (Modifier.PROTECTED | Modifier.PUBLIC | Modifier.PRIVATE)) == 0 &&
    +                ((classPackage == null && nestedPackage == null) ||
    +                        classPackage != null && nestedPackage != null && classPackage.equals(nestedPackage)))
    +            return true;
    +        return false;
    --- End diff --
    
    Comment says package local but it could be private at this point.  If you added an early exit `if (Modifier.isPrivate(redirect.getModifiers()) return false;` above the comment this would be package-private and the modifier check could be eliminated.
    
    If that's the case then the return could be simplified:
    
    ```
    return (classPackage == null && nestedPackage == null) || 
             (classPackage != null && classPackage.equals(nestedPackage))
    ```
    
    I notice that `PackageNode` doesn't implement `equals` so it will end up being an `==` check.  I'm not that familiar with how the AST is built and if the same `PackageNode` is used for a given name so just wanted to bring that up.
;;;","26/Aug/16 11:57;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/397#discussion_r76406515
  
    --- Diff: src/main/org/codehaus/groovy/control/ResolveVisitor.java ---
    @@ -852,6 +858,21 @@ protected Expression transformPropertyExpression(PropertyExpression pe) {
             return ret;
         }
     
    +    private boolean isVisibleNestedClass(ClassNode type, ClassNode ceType) {
    +        if (!type.isRedirectNode()) return false;
    +        ClassNode redirect = type.redirect();
    +        // public or private
    +        if (Modifier.isPublic(redirect.getModifiers()) || Modifier.isProtected(redirect.getModifiers())) return true;
    --- End diff --
    
    Oops, comment is obviously wrong - I'll fix or remove it
;;;","26/Aug/16 12:00;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/397#discussion_r76406865
  
    --- Diff: src/main/org/codehaus/groovy/control/ResolveVisitor.java ---
    @@ -852,6 +858,21 @@ protected Expression transformPropertyExpression(PropertyExpression pe) {
             return ret;
         }
     
    +    private boolean isVisibleNestedClass(ClassNode type, ClassNode ceType) {
    +        if (!type.isRedirectNode()) return false;
    +        ClassNode redirect = type.redirect();
    +        // public or private
    +        if (Modifier.isPublic(redirect.getModifiers()) || Modifier.isProtected(redirect.getModifiers())) return true;
    +        // package local
    +        PackageNode classPackage = ceType.getPackage();
    +        PackageNode nestedPackage = redirect.getPackage();
    +        if ((redirect.getModifiers() & (Modifier.PROTECTED | Modifier.PUBLIC | Modifier.PRIVATE)) == 0 &&
    +                ((classPackage == null && nestedPackage == null) ||
    +                        classPackage != null && nestedPackage != null && classPackage.equals(nestedPackage)))
    +            return true;
    +        return false;
    --- End diff --
    
    I should probably use getName() on the package. It won't be private or the binary and will pick that up.
;;;","28/Aug/16 05:22;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/397
;;;","28/Aug/16 05:23;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,
ClassInfo.globalClassValue lead  to GroovyClassLoader can't unload classes,GROOVY-7913,12998804,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,chenxiaojie,chenxiaojie,22/Aug/16 04:09,01/Feb/17 23:18,14/Jul/23 06:02,11/Sep/16 04:08,2.4.6,,,,,,,,2.4.8,,,,class generator,,,,0,,,,,,,"org.codehaus.groovy.reflection.ClassInfo:
{code}
private static final GroovyClassValue<ClassInfo> globalClassValue = GroovyClassValueFactory.createGroovyClassValue(new ComputeValue<ClassInfo>(){
		@Override
		public ClassInfo computeValue(Class<?> type) {
			ClassInfo ret = new ClassInfo(type);
			globalClassSet.add(ret);
			return ret;
		}
	});
{code}

dynamic load groovy classes will be cached in globalClassValue
can't unload classes
cause java.lang.OutOfMemoryError: PermGen space",,chenxiaojie,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7683,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 11 04:08:05 UTC 2016,,,,,,,,,,"0|i32ktj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/Sep/16 04:08;jwagenleitner;Thanks for reporting the issue.  I believe the fix for GROOVY-7683 will fix the issue, but please re-open if you find that to not be the case.;;;",,,,,,,,,,,,,,,,,,,,,
MissingPropertyException when referencing a static import in a closure's optional parameters,GROOVY-7912,12998315,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,mjjustin,mjjustin,18/Aug/16 21:12,01/Feb/17 23:19,14/Jul/23 06:02,25/Aug/16 23:58,2.4.7,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"A MissingPropertyException is thrown when calling a closure which references a statically imported field in the value of an optional parameter for a closure.  Likewise, a MissingMethodException is thrown when referencing a statically imported method in the same manner.  This only occurs when calling the method without specifying the optional parameter.

I have confirmed that this issue does not impact methods with optional parameters.

The following code illustrates the issue:
{code}import static java.util.Collections.EMPTY_LIST
import static java.util.Collections.emptyList

Closure closureWithStaticImport = { List list = EMPTY_LIST -> }
Closure closureWithoutStaticImport = { List list = Collections.EMPTY_LIST -> }

try {
  // An exception is thrown when the statically imported optional parameter is not specified
  closureWithStaticImport()
} catch (MissingPropertyException e) {
  assert e.message == 'No such property: EMPTY_LIST for class: staticImportTest'
  e.printStackTrace()
}

// No exception is thrown when the optional parameter is specified
closureWithStaticImport(EMPTY_LIST)

// No exception is thrown when the optional parameter is not statically imported
closureWithoutStaticImport()


void methodWithStaticImport(List list = EMPTY_LIST) {}

// No exception is thrown when a method's optional parameter uses a static import
methodWithStaticImport()


Closure closureWithStaticImportMethod = { List list = emptyList() -> }

try {
  // An exception is thrown when the statically imported optional parameter is not specified
  closureWithStaticImportMethod()
} catch (MissingMethodException e) {
  assert e.message == 'No signature of method: staticImportTest.emptyList() is applicable for argument types: () values: []'
  e.printStackTrace()
}{code}",,githubbot,mjjustin,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 25 23:58:21 UTC 2016,,,,,,,,,,"0|i32hsv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Aug/16 03:28;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/392

    GROOVY-7912: MissingPropertyException when referencing a static impor…

    …t in a closure's optional parameters

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7912

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/392.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #392
    
----
commit b3ff90b5a23cdd13736ab026090f6be1e3befe76
Author: paulk <paulk@asert.com.au>
Date:   2016-08-23T03:26:54Z

    GROOVY-7912: MissingPropertyException when referencing a static import in a closure's optional parameters

----
;;;","25/Aug/16 22:26;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/392
;;;","25/Aug/16 23:58;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,,,,
Calling parents method from trait using Parent.super.method() fail depending on trait declaration order,GROOVY-7909,12997644,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,sebcworks,sebcworks,16/Aug/16 17:02,18/Mar/17 09:56,14/Jul/23 06:02,08/Mar/17 08:14,2.4.7,,,,,,,,2.4.10,,,,Compiler,,,,0,,,,,,,"I'm using trait for multiple inheritance and I faced an issue when compiling my project (using Grails 3.1.9, so with the gradle task CompileGroovy).
My traits are sharing a common method ({{def method()}}) and I'm referencing parent's version through ParentClassName.super.method()

I'm seeing this error:
{quote}
> BUG! exception in phase 'semantic analysis' in source unit 'xxx.groovy' ClassNode#getTypeClass for YYY is called before the type class is set
{quote}

When testing different cases it seems that this problem appears because classes are not compiled in the right order.

For example, a script with 
{code}
trait Three implements One, Two {
    def postMake() {
        One.super.postMake()
        Two.super.postMake()
        println ""Three""
    }
}
trait One {
    def postMake() { println ""One""}
}
trait Two {
    def postMake() { println ""Two""}
}
class Four implements Three {
    def make() {
        Three.super.postMake()
        println ""All done?""
    }
}
Four f = new Four()
f.make()
{code}
will fail, whereas putting Three method after One and Two will succeed.
Beside, keeping this trait's declaration order but changing method names to be unique (and removing {{XXX.super}}) will compile and execute correctly.

I hope I'm clear enough...",Grails 3.1.9,githubbot,paulk,sebcworks,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 08 08:14:55 UTC 2017,,,,,,,,,,"0|i32dnr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"26/Sep/16 02:38;githubbot;GitHub user blindpirate opened a pull request:

    https://github.com/apache/groovy/pull/430

    GROOVY-7909 Calling parents method from trait using Parent.super.method() fail depending on trait declaration order

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/blindpirate/groovy groovy7909bug

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/430.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #430
    
----
commit d1c9d3fce074949dee7c2f4514965272333c1254
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-09-26T02:29:16Z

    groovy 7922 bug

----
;;;","26/Sep/16 02:47;githubbot;Github user blindpirate closed the pull request at:

    https://github.com/apache/groovy/pull/430
;;;","26/Sep/16 02:54;githubbot;GitHub user blindpirate opened a pull request:

    https://github.com/apache/groovy/pull/431

    GROOVY-7909 Calling parents method from trait using Parent.super.method() fail depending on trait declaration order

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/blindpirate/groovy groovy7909

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/431.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #431
    
----
commit d1c9d3fce074949dee7c2f4514965272333c1254
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-09-26T02:29:16Z

    groovy 7922 bug

----
;;;","26/Sep/16 02:56;githubbot;Github user blindpirate closed the pull request at:

    https://github.com/apache/groovy/pull/431
;;;","26/Sep/16 03:07;githubbot;GitHub user blindpirate opened a pull request:

    https://github.com/apache/groovy/pull/432

    GROOVY-7909 Calling parents method from trait using Parent.super.method() fail depending on trait declaration order 

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/blindpirate/groovy groovy7909

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/432.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #432
    
----
commit 546dd0dcbf4c340624a5ec5a23bc92500e729a54
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-09-26T02:29:16Z

    groovy 7909 bug

----
;;;","07/Oct/16 15:04;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/432#discussion_r82406821
  
    --- Diff: src/test/groovy/bugs/Groovy7909Bug.groovy ---
    @@ -0,0 +1,57 @@
    +package groovy.bugs
    --- End diff --
    
    Could you add the license header to this file, should be able to grab it from another file in the same package.
;;;","16/Oct/16 06:21;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/432#discussion_r83546094
  
    --- Diff: src/main/org/codehaus/groovy/transform/trait/SuperCallTraitTransformer.java ---
    @@ -36,13 +38,19 @@
     
     import java.util.List;
     
    +import static org.objectweb.asm.Opcodes.ACC_ABSTRACT;
    +import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
    +import static org.objectweb.asm.Opcodes.ACC_STATIC;
    +import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
    +
     /**
      * This transformer is used to transform calls to <code>SomeTrait.super.foo()</code> into the appropriate trait call.
      *
      * @author Cédric Champeau
      * @since 2.3.0
      */
     class SuperCallTraitTransformer extends ClassCodeExpressionTransformer {
    +    public static final String UNRESOLVED_HELPER_CLASS = ""UNRESOLVED_HELPER_CLASS"";
    --- End diff --
    
    This is only used in the same package, I think package-private would be better than public.
;;;","16/Oct/16 10:05;githubbot;Github user blindpirate commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/432#discussion_r83548596
  
    --- Diff: src/main/org/codehaus/groovy/transform/trait/SuperCallTraitTransformer.java ---
    @@ -36,13 +38,19 @@
     
     import java.util.List;
     
    +import static org.objectweb.asm.Opcodes.ACC_ABSTRACT;
    +import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
    +import static org.objectweb.asm.Opcodes.ACC_STATIC;
    +import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
    +
     /**
      * This transformer is used to transform calls to <code>SomeTrait.super.foo()</code> into the appropriate trait call.
      *
      * @author Cédric Champeau
      * @since 2.3.0
      */
     class SuperCallTraitTransformer extends ClassCodeExpressionTransformer {
    +    public static final String UNRESOLVED_HELPER_CLASS = ""UNRESOLVED_HELPER_CLASS"";
    --- End diff --
    
    Yes, I haven't realize it. Done as you say.
;;;","08/Mar/17 08:12;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/432
;;;","08/Mar/17 08:14;paulk;Proposed PR merged. Thanks!;;;",,,,,,,,,,,,
"Cannot assign value of type java.lang.Object with varargs, parameterized method and @CompileStatic",GROOVY-7907,12997271,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,szpak,szpak,15/Aug/16 11:15,01/Feb/17 23:18,14/Jul/23 06:02,19/Aug/16 04:41,2.4.7,,,,,,,,2.4.8,,,,Static compilation,,,,0,,,,,,,"Static compilation fails when method is parameterized and there are varargs arguments which are not used in the call.
{code}
Error:(9, 23) Groovyc: [Static type checking] - Cannot assign value of type java.lang.Object to variable of type Ext.
{code}

Simple classes to reproduce the problem:
{code}
public class FooInJava { //needs to be in Java, a class in Groovy works fine
    <T> T create(Class<T> type, Object... args) { return null; }
}

class Ext {}

@CompileStatic
class FooMain {
    static void main(String[] args) {
        Ext create = new FooInJava().create(Ext) //casting is required to make compilation pass
    }
}
{code}

It only occurs if a class with unfortunate method signature is written in Java and static compilation is enabled. Casting to the right type helps. Originally spotted with Gradle - `ExtensionContainer.create(...)`.
",Groovy 2.4.7 (tested also with 2.4.4),githubbot,paulk,szpak,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Sep 07 08:15:10 UTC 2016,,,,,,,,,,"0|i32bcv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Aug/16 12:45;paulk;For what it's worth, the same problem happens with pre-compiled Groovy. The Groovy compiler is leaving the upperBounds on the generic type T as null but when loading classes, the upperBounds on T is set as java.lang.Object which then confuses the inferencing code. I haven't had time to work out exactly where we'd need to fix it yet. It might actually fix a couple of similar errors I noticed recently in slightly different contexts.;;;","17/Aug/16 02:10;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/385

    GROOVY-7907: Cannot assign value of type java.lang.Object with vararg…

    …s, perameterized method and @CompileStatic

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7907

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/385.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #385
    
----
commit 174e64ef7e8eb5d8726c1f55c00c50f8fee2527e
Author: paulk <paulk@asert.com.au>
Date:   2016-08-17T02:08:49Z

    GROOVY-7907: Cannot assign value of type java.lang.Object with varargs, perameterized method and @CompileStatic

----
;;;","19/Aug/16 04:20;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/385
;;;","19/Aug/16 04:41;paulk;Proposed PR merged. Thanks for raising the issue.;;;","07/Sep/16 08:15;szpak;Thanks for a quick fix.;;;",,,,,,,,,,,,,,,,,
groovy-2.4.7/bin/startGroovy: line 275: syntax error: bad substitution,GROOVY-7906,12997162,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,typek_pb,typek_pb,14/Aug/16 00:34,06/Mar/18 23:25,14/Jul/23 06:02,21/Jan/18 17:55,2.4.7,,,,,,,,,,,,,,,,3,,,,,,,"running groovy in alpine linux results in:
{code}
/tmp/groovy-2.4.7/bin/startGroovy: line 275: syntax error: bad substitution
{code}

as a workaround I'm running:
{code}
sed -ie '274,275d' /tmp/groovy-2.4.7/bin/startGroovy
{code}
prior to invoking groovy","Alpine linux (=> no bash, busybox only)",blackdrag,devitis.luca@gmail.com,jwagenleitner,keegan,SR-G,typek_pb,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Important,,,,,,,,9223372036854775807,,,Sun Jan 21 19:21:08 UTC 2018,,,,,,,,,,"0|i32aon:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Aug/16 09:18;blackdrag;for those not so familiar with sed, like me: what do you actually replace?;;;","19/Aug/16 03:03;jwagenleitner;I believe that will delete lines 274 through 275 from the file:

https://github.com/apache/groovy/blob/042950dc23257bbc65cd2258f2fd2a197a98f802/src/bin/startGroovy#L274-L275

What is odd is that it should only execute those lines if cygwin is detected, but at least on Alpine 3.4.3 the {{`uname`}} command returns just ""Linux"" for me.  Would be interested to know what it returns for you [~typek_pb];;;","19/Aug/16 07:09;blackdrag;what I would like to know is actually why in busybox $BASH is set. The failure happens because the script assumes $BASH is set only if the shell is bash. And according to the description the shell is not bash;;;","23/Aug/16 10:57;SR-G;Exact same problem for me, running (or willing to run) groovy inside a docker container based on alpine, same error.

My envs are out of the box :
{quote}
[ root@c4e4ab3a291b:/opt/groovy/bin ]$ echo $BASH
/bin/bash
[ root@c4e4ab3a291b:/opt/groovy/bin ]$ uname
Linux
[ root@c4e4ab3a291b:/opt/groovy/bin ]$ uname -a
Linux c4e4ab3a291b 4.4.16-1-lts #1 SMP Thu Jul 28 16:21:18 CEST 2016 x86_64 Linux
{quote}
;;;","23/Aug/16 14:10;jwagenleitner;If possible could you share your Dockerfile or, if a public image, at least what the FROM is using?;;;","23/Aug/16 14:19;SR-G;Sure, here's the sum of my dockerfiles (internal images).
One layer used as a base from alpine.
One layer adding JDK8
One layer adding groovy.

{code}
# Layer 1 - base
FROM    alpine:3.4

ENV     TIMEZONE Europe/Paris
ENV     LANG fr_FR.UTF-8
ENV     LANGUAGE fr_FR.UTF-8
ENV     LC_ALL fr_FR.UTF-8
ENV     HOME /root
ENV     TERM xterm

# Insert bashrc
ADD     bashrc /root/.bashrc

RUN     apk add --update bash tzdata
RUN     echo $TIMEZONE > /etc/timezone && \
        cp /usr/share/zoneinfo/${TIMEZONE} /etc/localtime
RUN     apk del tzdata && rm -rf /var/cache/apk/*

# Layer 2 - base + java

# Install cURL
ENV     GLIBC_VERSION   2.23-r3
ENV     GLIBC_URL https://github.com/sgerrand/alpine-pkg-glibc/releases/download/unreleased
RUN     apk --no-cache --update add curl ca-certificates tar && \
        echo ""${GLIBC_URL}/glibc-${GLIBC_VERSION}.apk"" && \
        curl -sLo /tmp/glibc-${GLIBC_VERSION}.apk ${GLIBC_URL}/glibc-${GLIBC_VERSION}.apk && \
        curl -sLo /tmp/glibc-bin-${GLIBC_VERSION}.apk ${GLIBC_URL}/glibc-bin-${GLIBC_VERSION}.apk && \
        curl -sLo /tmp/glibc-i18n-${GLIBC_VERSION}.apk ${GLIBC_URL}/glibc-i18n-${GLIBC_VERSION}.apk && \
        apk add --no-cache --allow-untrusted /tmp/glibc-${GLIBC_VERSION}.apk /tmp/glibc-bin-${GLIBC_VERSION}.apk /tmp/glibc-i18n-${GLIBC_VERSION}.apk && \
        /usr/glibc-compat/bin/localedef -i fr_FR -f UTF-8 fr_FR.UTF-8

# Java Version
ENV     JAVA_VERSION_MAJOR 8
ENV     JAVA_VERSION_MINOR 102
ENV     JAVA_VERSION_BUILD 14
ENV     JAVA_PACKAGE       jdk

# Download and unarchive Java
RUN mkdir /opt && curl -jksSLH ""Cookie: oraclelicense=accept-securebackup-cookie""\
  http://download.oracle.com/otn-pub/java/jdk/${JAVA_VERSION_MAJOR}u${JAVA_VERSION_MINOR}-b${JAVA_VERSION_BUILD}/${JAVA_PACKAGE}-${JAVA_VERSION_MAJOR}u${JAVA_VERSION_MINOR}-linux-x64.tar.gz \
    | tar -xzf - -C /opt &&\
    echo 'hosts: files mdns4_minimal [NOTFOUND=return] dns mdns4' >> /etc/nsswitch.conf && \
    ln -s /opt/jdk1.${JAVA_VERSION_MAJOR}.0_${JAVA_VERSION_MINOR} /opt/jdk &&\
    rm -rf /opt/jdk/*src.zip \
           /opt/jdk/lib/missioncontrol \
           /opt/jdk/lib/visualvm \
           /opt/jdk/lib/*javafx* \
           /opt/jdk/jre/lib/plugin.jar \
           /opt/jdk/jre/lib/ext/jfxrt.jar \
           /opt/jdk/jre/bin/javaws \
           /opt/jdk/jre/lib/javaws.jar \
           /opt/jdk/jre/lib/desktop \
           /opt/jdk/jre/plugin \
           /opt/jdk/jre/lib/deploy* \
           /opt/jdk/jre/lib/*javafx* \
           /opt/jdk/jre/lib/*jfx* \
           /opt/jdk/jre/lib/amd64/libdecora_sse.so \
           /opt/jdk/jre/lib/amd64/libprism_*.so \
           /opt/jdk/jre/lib/amd64/libfxplugins.so \
           /opt/jdk/jre/lib/amd64/libglass.so \
           /opt/jdk/jre/lib/amd64/libgstreamer-lite.so \
           /opt/jdk/jre/lib/amd64/libjavafx*.so \
           /opt/jdk/jre/lib/amd64/libjfx*.so && \
    rm -rf /opt/jdk/jre/bin/jjs \
           /opt/jdk/jre/bin/keytool \
           /opt/jdk/jre/bin/orbd \
           /opt/jdk/jre/bin/pack200 \
           /opt/jdk/jre/bin/policytool \
           /opt/jdk/jre/bin/rmid \
           /opt/jdk/jre/bin/rmiregistry \
           /opt/jdk/jre/bin/servertool \
           /opt/jdk/jre/bin/tnameserv \
           /opt/jdk/jre/bin/unpack200 \
           /opt/jdk/jre/lib/ext/nashorn.jar \
           /opt/jdk/jre/lib/jfr.jar \
           /opt/jdk/jre/lib/jfr \
           /opt/jdk/jre/lib/oblique-fonts

# Set environment
ENV     JAVA_HOME /opt/jdk
ENV     PATH ${PATH}:${JAVA_HOME}/bin

# Layer 3 - groovy

WORKDIR /opt/
ENV     GROOVY_HOME /opt/groovy/
ENV     PATH ${PATH}:${GROOVY_HOME}/bin
ENV     GROOVY_VERSION 2.4.7

RUN     apk --update add curl unzip && \
        curl -sLo /opt/groovy.zip https://bintray.com/artifact/download/groovy/maven/apache-groovy-binary-${GROOVY_VERSION}.zip && \
        unzip /opt/groovy.zip && \
        rm -f /opt/groovy.zip && \
        ln -s /opt/groovy-${GROOVY_VERSION} /opt/groovy
{code};;;","23/Aug/16 17:34;jwagenleitner;Looks like Alpine's default shell {{ash}} pre-processes substitutions even for code it wont exec.  Possibly similar to (https://github.com/ansible/ansible/issues/17011) and their fix was to wrap in an {{eval}} (https://github.com/ansible/ansible/pull/17054/files).;;;","23/Aug/16 17:54;SR-G;Ok as a workaround i've added in my dockerfile
{code}
RUN rm /bin/sh && ln -s /bin/bash /bin/sh
{code}

(i still have echo $SHELL = ash and echo $BASH = bash)

And thereafter, groovy can starts.

It is indeed related to the fact that the groovy shells are using /bin/sh, and in an alpine installation, /bin/sh is a symbolic link to /bin/busybox.;;;","11/Dec/16 08:19;keegan;I'm working on creating some official Groovy Docker images and encountered the same issue.  It'd be less intrusive to use Bash just for Groovy, while not affecting the rest of the environment.  One way is to just change the shebangs:
{code}
RUN set -ex \
	&& sed -i ""s|#!/bin/sh|#!/bin/bash|"" /opt/groovy/bin/grape \
	&& sed -i ""s|#!/bin/sh|#!/bin/bash|"" /opt/groovy/bin/groovy \
	&& sed -i ""s|#!/bin/sh|#!/bin/bash|"" /opt/groovy/bin/groovyc \
	&& sed -i ""s|#!/bin/sh|#!/bin/bash|"" /opt/groovy/bin/groovyConsole \
	&& sed -i ""s|#!/bin/sh|#!/bin/bash|"" /opt/groovy/bin/groovydoc \
	&& sed -i ""s|#!/bin/sh|#!/bin/bash|"" /opt/groovy/bin/groovysh \
	&& sed -i ""s|#!/bin/sh|#!/bin/bash|"" /opt/groovy/bin/java2groovy
{code}
I mentioned the idea on the related mailing list [discussion|http://groovy.329449.n5.nabble.com/Groovy-Docker-images-td5735270.html].;;;","03/May/17 13:59;devitis.luca@gmail.com;These are all useful workaround, but I would like that we don't miss the real issue here.

Bash syntax is kind of a super-set of the sh syntax: it is wrong for an sh script to source a bash script. Might be acceptable the other way around: however I wouldn't do that either. Just pick up one and stick with it.

In fact, I think that ""no bash, busybox only"" is not correct. You can have bash on alpine, as long as you tell me that you need it.

This problem is coming from the fact that many Linux distributions ship bash as an sh interpreter, but bash is not exactly sh compliant and that led to the misconception that sh and bash are so similar.;;;","28/Sep/17 06:46;keegan;Agreed.  I left this issue open so we can do a more permanent fix.;;;","21/Jan/18 17:55;keegan;This has been fixed already (by [042dbdb3f74a238a09768676f03ea05dcce95606|https://github.com/apache/groovy/commit/042dbdb3f74a238a09768676f03ea05dcce95606] and [28d2f6a5f34f44f524ffea0e44be70c3c6a5c24e|https://github.com/apache/groovy/commit/28d2f6a5f34f44f524ffea0e44be70c3c6a5c24e]).;;;","21/Jan/18 18:43;keegan;I'll cherry pick these changes (as well as [87c68fba3b599238d5c900d8eb18975074fa926d|https://github.com/apache/groovy/commit/87c68fba3b599238d5c900d8eb18975074fa926d] and [92bd96fcdfe35e502987e1846715a08a45620db1|https://github.com/apache/groovy/commit/92bd96fcdfe35e502987e1846715a08a45620db1]) to the 2_4_X, 2_5_X, and 2_6_X branches.;;;","21/Jan/18 19:21;keegan;Actually, testing with 2.4.13 is passing event without cherry-picking these changes in.  It looks like {{$\{BASH}}} is no longer set in Alpine.  Although these are probably good things to get merged anyway.;;;",,,,,,,,
collate() infinite loop with zeroed step,GROOVY-7902,12995709,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,ftmamud,ftmamud,08/Aug/16 17:24,02/May/17 02:03,14/Jul/23 06:02,10/Aug/16 08:02,2.4.7,,,,,,,,2.5.0-alpha-1,,,,groovy-jdk,groovy-runtime,,,0,,,,,,,"Fixing infinite loop in Iterable.collate method when step parameter is equals to zero.

Example:

{code:java}
[ 1, 2, 3 ].collate( 2, 0 )
{code}

The result is a infinite loop because the step parameter is used directly in the for increment: pos += step

In the fixing I assumed that the step parameter should be equals to size parameter, looks like in the collate(self, size, size, keepRemainder) overloaded method, with absence of step and I considered backward compatibility with negative steps.

PR opened in Github: https://github.com/apache/groovy/pull/378

Thks.
Felipe Mamud",Groovy Version: 2.4.7 JVM: 1.8.0_92 Vendor: Oracle Corporation OS: Mac OS X,ftmamud,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 10 08:02:42 UTC 2016,,,,,,,,,,"0|i321q7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Aug/16 23:17;ftmamud;PR opened in Github: https://github.com/apache/groovy/pull/378;;;","10/Aug/16 08:01;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/378
;;;","10/Aug/16 08:02;paulk;Fixed, thanks!;;;",,,,,,,,,,,,,,,,,,,
CLONE - ClassCastException when calling DefaultTypeTransformation#compareEqual,GROOVY-7892,12992423,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,aewhite,paulk,25/Jul/16 22:52,02/May/17 02:03,14/Jul/23 06:02,25/Jul/16 22:56,2.4.6,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,"It appears that comparing two objects that both implement comparable with DefaultTypeTransformation#compareEqual is not safe in all cases. Consider enums for example, which throw exceptions when compared to differing classes. 

This is using Eclipse Collections for pairs but the idea is the same in general. 

{code}
    enum E1 {A, B, C}
    enum E2 {D, E, F}

    def ""test groovy oddness""() {
        when:
        def test = DefaultTypeTransformation.compareEqual(
            Tuples.pair(E1.A, 1), 
            Tuples.pair(E2.D, 1))

        then:
        assert test == false
    }
{code}

Stacktrace

{code}
java.lang.ClassCastException
	at java.lang.Enum.compareTo(Enum.java:180)
	at java.lang.Enum.compareTo(Enum.java:55)
	at org.eclipse.collections.impl.tuple.PairImpl.compareTo(PairImpl.java:95)
	at org.eclipse.collections.impl.tuple.PairImpl.compareTo(PairImpl.java:22)
	at com.GroovyTests.test groovy oddness(GroovyTests.groovy:36)
{code}",,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7876,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 25 22:56:01 UTC 2016,,,,,,,,,,"0|i31hg7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Jul/16 22:56;paulk;As part of fixing the cloned issue, we also changed the exception returned for the relevant code when comparing using compareTo. The now thrown IllegalArgumentException is more informative but is a breaking change if you were expecting the previous ClassCastException which is now the cause of the new exception. This was done for 2.5+ only.;;;",,,,,,,,,,,,,,,,,,,,,
Lack of compilation error while statically compiled the closure.,GROOVY-7890,12991582,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,dwarszawski,dwarszawski,21/Jul/16 19:25,29/Aug/22 21:05,14/Jul/23 06:02,22/Dec/21 15:25,2.4.5,2.4.7,,,,,,,2.5.19,3.0.13,4.0.0-rc-2,,Compiler,,,,1,features,,,,,,"Expecting compile time error that cannot reference non-static variable from static context but stacktrace presents runtime MissingPropertyException. @CompileStatic is enabled on the class level. The code block to reproduce the issue can be found in the attached link. It also includes the output of running the sample code.

https://gist.github.com/dwarszawski/41aed2cf53486a5603447f54a44b4ac3 ",Linux version 3.13.0-24-generic (gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) ),alien11689,blackdrag,dwarszawski,emilles,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,https://gist.github.com/dwarszawski/41aed2cf53486a5603447f54a44b4ac3,,Important,,,,,,,,9223372036854775807,,,Wed Dec 22 15:25:17 UTC 2021,,,,,,,,,,"0|i31c9b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jul/16 10:47;blackdrag;confirmed and independent of @CompileStatic;;;","22/Jul/16 11:34;paulk;Agreed on the @CompileStatic case.

For me, the dynamic case is worthy of debate. One might expect that for a dynamic language the following would work. And it does now.
{code}
class Foo {
  private final List<String> foo
  Foo(List<String> foo) {
    this.foo = foo
  }
  private static String bar() {
    String foobar = ""foobar""
    return foobar.collectReplacements {
      return ((it as String) in foo) ? 'o' : null
    }
  }
}
Foo.metaClass.static.getFoo << { ['a'] }
Foo o1 = new Foo([""a"", ""b"", ""c""])
println(o1.bar()) // => foobor
{code}
I think it is ugly style and I would highly discourage it, but it worries me that existing code might be relying on this behavior.;;;","23/Jul/16 06:27;blackdrag;ok, let us go a bit more into detail{code}
class X {
  def b
  static a=b
}
{code}
that one fails, As does this:{code}
class X {
  def b
  static foo(){b}
}{code}
Which shows, it is not per se legal in Groovy to have access to a ""static dynamic"" variable. Now in the case at hand a closure is involved, which automatically opens a dynamic context. Which also means the access to foo is not done in a static context.  So for the dynamic case I would not make this an error. 

For the comile static case I think this should be a compilation error though.;;;","27/Jul/16 11:09;paulk;It looks like in {{StaticTypeCheckingVisitor#visitVariableExpression}} we call {{tryVariableExpressionAsProperty}} which at first glance seems to be looking for an instance property. I would have though it should take into account that when the closure is in a static context the class will end up being the delegate. I haven't had time to properly investigate yet though.;;;","22/Dec/21 15:25;emilles;https://github.com/apache/groovy/commit/c2a6c4b2fc0ff2c43c61425900725c78165d2672;;;",,,,,,,,,,,,,,,,,
Type checker infers wrong type on compound assignment (e.g. += for collection) for property,GROOVY-7888,12991085,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,wolfs,wolfs,20/Jul/16 10:51,01/Feb/17 23:19,14/Jul/23 06:02,24/Aug/16 07:40,2.4.7,,,,,,,,2.4.8,,,,Static Type Checker,,,,0,,,,,,,"Given the Java class
{code}
public class ContainsSet extends GroovyObjectSupport {
    private Set<File> files = new HashSet<File>();

    public Set<File> getFiles() {
        return files;
    }

    public void setFiles(Set<File> files) {
        this.files = files;
    }
}
{code}

the following Groovy code will not type check:
{code}
@TypeChecked
private Set<File> modifyIdeaModel() {
    set.files += new File('foo')
}
{code}

The failure is: 
{code}
Error: Groovyc: [Static type checking] - Cannot assign value of type java.io.File to variable of type java.util.Set <java.io.File>
{code}

Without the {{@TypeChecked}} the code runs with dynamic Groovy.

Using the following Groovy class type checking the code above works.
{code}
class ContainsSet {
    Set<File> files = new HashSet<>()
}
{code}",,githubbot,jwagenleitner,paulk,wolfs,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Aug 24 07:40:53 UTC 2016,,,,,,,,,,"0|i31973:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Jul/16 06:30;paulk;The long-hand version is correctly handled too:
{code}
set.files = set.files + new File('foo')
{code};;;","21/Aug/16 10:44;paulk;A smaller self-contained example illustrating the problem:
{code}
class ContainsSet { void setFiles(Set<File> files) { } }
@groovy.transform.TypeChecked modifyIdeaModel(ContainsSet set) { set.files += new File('foo') }
modifyIdeaModel(new ContainsSet())
{code};;;","22/Aug/16 06:54;paulk;Updated the summary since it's not related to accessing a Java class;;;","22/Aug/16 06:58;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/390

    GROOVY-7888: Type checker infers wrong type on compound assignment (e…

    ….g. += for collection) for property

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7888

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/390.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #390
    
----
commit c6aacaf01a347504422abc5d3567b758aab5ef84
Author: paulk <paulk@asert.com.au>
Date:   2016-08-22T06:53:25Z

    GROOVY-7888: Type checker infers wrong type on compound assignment (e.g. += for collection) for property

----
;;;","24/Aug/16 07:38;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/390
;;;","24/Aug/16 07:40;paulk;Proposed PR merged. Thanks for spotting the issue.;;;",,,,,,,,,,,,,,,,
GroovyScriptEngineImpl usage of CompilerConfiguration can lead to memory leaks,GROOVY-7884,12989076,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,rste79,rste79,13/Jul/16 09:59,01/Feb/17 23:18,14/Jul/23 06:02,07/Aug/16 03:14,2.4.5,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"In the constructor of GroovyScriptEngineImpl the CompilerConfiguration is created each time, while it should use CompilerConfiguration.DEFAULT.

This can lead to memory leaks in environments where there is an high usage of GroovyScriptEngineImpl because CompilerConfiguration creates a PrintWriter on System.err (i.e. under the hood it creates a BufferedWriter with a default buffer of 8192 elements) when setting the field ""output"".
I have observed this behaviour using Apache Camel.
I don't know if all the GroovyScriptEngineImpl instances are legit or are themselves a leak: I will investigate on this later and report to the Apache Camel team.",,blackdrag,githubbot,jwagenleitner,rste79,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Aug 07 03:14:03 UTC 2016,,,,,,,,,,"0|i30wsv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jul/16 13:47;blackdrag;you are right, using CompilerConfiguration() is not really right, we should use new CompilerConfiguration(CompilerConfiguration.DEFAULT). This will also not create yet another print writer.;;;","13/Jul/16 15:09;rste79;Thanks Jochen. I agree, using the copy constructor is the right solution.;;;","05/Aug/16 01:12;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/377

    GROOVY-7884: GroovyScriptEngineImpl usage of CompilerConfiguration can lead to memory leaks

    Also includes some minor refactoring/cleanup as separate commits.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7884

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/377.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #377
    
----
commit f6ea716311bbc3d5952d475665b6bf0a6e3089b8
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-08-04T23:27:47Z

    GROOVY-7884: GroovyScriptEngineImpl usage of CompilerConfiguration can lead to memory leaks

commit ac9197f50b7f7a4601d497858fcd9ce91522b528
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-08-04T23:46:26Z

    minor refactor: use enhanced for loop

commit f6019be6190e6f799dc14944e98d6d76830201c4
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-08-04T23:58:40Z

    minor cleanup: no need to import classes from java.lang

commit 76c7941b5d449603ef2a03f988ad6975173af4cb
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-08-05T00:49:24Z

    minor refactor: remove use of raw types

----
;;;","07/Aug/16 02:59;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/377
;;;","07/Aug/16 03:14;jwagenleitner;I applied the change [~blackdrag] recommended.

Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,
Static compiler prefers private constructor over public if private matches better,GROOVY-7883,12987516,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,gillius,gillius,07/Jul/16 15:44,26/Jul/18 04:38,14/Jul/23 06:02,12/May/18 06:16,2.4.7,,,,,,,,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,,Static compilation,,,,1,,,,,,,"When constructing an AssertionError for example, it has a public constructor taking Object and a private constructor taking String. The static compiler ""chooses"" the private constructor over the public one and this results in a compile error.

{code}
@groovy.transform.CompileStatic
void doIt() {
  //Cannot call private constructor for java.lang.AssertionError. However, it should call AssertionError(Object)
  throw new AssertionError(""abc"")
}
{code}",,blackdrag,daniel_sun,gillius,githubbot,jmsotuyo,jwagenleitner,upadhyayap,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 12 06:16:31 UTC 2018,,,,,,,,,,"0|i30npb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Aug/16 10:09;upadhyayap;I believe this is how java compiler works. There is matching argument constructor  available but  restricted through access modifier. By adding compileSatic groovy just bypass the meta object protocol and the compilation is done in very regular java way. I think this compileStatic is doing correctly. One way to test is convert this into java and then try to compile using javac. I get the same error.;;;","17/Aug/16 11:18;blackdrag;I did read this as ""private constructor is taken instead of the public one"", which means the access modifier restriction is ignored. This would be wrong;;;","17/Aug/16 12:40;gillius;That's right, for example the following Java program throws the exception:

{code}
class X {
	public static void main(String[] args) {
		throw new AssertionError(""test"");
	}
}
{code}

Javac picks the public constructor taking Object rather than the private constructor taking String.;;;","22/Sep/16 20:52;jmsotuyo;I'm seeing the exact same problem. new AssertionError(""any string"") is valid java code calling AssertionError(java.lang.Object). Groovy with @CompileStatic fails due to private constructor AssertionError(java.lang.String).

As a workaround in the meantime, writing new AssertionError('any string' as Object) gets the static compiler to actually compile the code.;;;","12/May/18 05:10;githubbot;GitHub user danielsun1106 opened a pull request:

    https://github.com/apache/groovy/pull/705

    GROOVY-7883  Static compiler prefers private constructor over public …

    …if private matches be

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/danielsun1106/groovy GROOVY-7883

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/705.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #705
    
----
commit 394db983d51446f849205efc4f9cca21601cc47c
Author: Daniel Sun <realbluesun@...>
Date:   2018-05-12T04:35:01Z

    GROOVY-7883  Static compiler prefers private constructor over public if private matches be

----
;;;","12/May/18 05:14;githubbot;Github user danielsun1106 commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/705#discussion_r187764707
  
    --- Diff: subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java ---
    @@ -3973,7 +3973,7 @@ protected final ResultSet executePreparedQuery(String sql, List<Object> params)
          * @return the resulting list of rows
          * @throws SQLException if a database error occurs
          */
    -    protected List<GroovyRowResult> asList(String sql, ResultSet rs,
    +    public List<GroovyRowResult> asList(String sql, ResultSet rs,
    --- End diff --
    
    The test accesses the `protected` method `asList`, which is not allowed. so I change its visibility to `public`.
    groovy.sql.SqlSTCTest#testAsList
    ```
        void testAsList() {
            shell.evaluate '''
                def test(groovy.sql.Sql sql, java.sql.ResultSet rs) { 
                    sql.asList('SELECT * FROM FOO', rs) { println it.columnCount } 
                }
            '''
        }
    ```
;;;","12/May/18 06:06;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/705
;;;","12/May/18 06:16;daniel_sun;Fixed by https://github.com/apache/groovy/commit/b1d1232770aade9672668df4dbc6aa2e2076fa9e
https://github.com/apache/groovy/commit/6560ce8e5541e4333a418d8dcf7f0f5ae92a71d0;;;",,,,,,,,,,,,,,
Diamond Operator for own class causes NullPointerException if Static Compilation is enabled,GROOVY-7880,12986869,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,leuprechtroman,leuprechtroman,05/Jul/16 16:23,01/Feb/17 23:18,14/Jul/23 06:02,11/Aug/16 09:08,2.4.3,2.4.7,,,,,,,2.4.8,,,,Compiler,Static compilation,Static Type Checker,,0,,,,,,,"When the diamond operator is used to instantiate a generic and the generic is specialized on the class the method is in, static compilation fails with a Nullpointer Exception. Dynamic compilation works, also replacing the diamond operator with the exact type or using ""raw"" typing.

The following code reproduces the bug on both machines(listed in Environment):

{code:java}
import groovy.transform.CompileStatic

@CompileStatic
class BugTest {
    private class CompilerKiller<T> {
        private T t
        public CompilerKiller(T t){
            this.t = t
        }
    }

    public void ""This causes a NPE""(){
        CompilerKiller<BugTest> sample = new CompilerKiller<>(this)
    }

    public void ""This causes a NPE as well""(){
        CompilerKiller<BugTest> sample = new CompilerKiller<>(new BugTest())
    }

    public void ""This does work""(){
        CompilerKiller<BugTest> sample = new CompilerKiller<BugTest>(this)
    }

    public void ""This works as well""(){
        CompilerKiller<BugTest> sample = new CompilerKiller(this)
    }
}
{code}","Test Machine 1: ArchLinux x64,
openjdk version ""1.8.0_92""
OpenJDK Runtime Environment (build 1.8.0_92-b14)
OpenJDK 64-Bit Server VM (build 25.92-b14, mixed mode)

Test Machine 2: MacOSX 10.11.3
Oracle Java Version: 1.8.0_05",githubbot,leuprechtroman,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Aug 11 09:08:45 UTC 2016,,,,,,,,,,"0|i30jpb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"10/Aug/16 13:08;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/382

    GROOVY-7880: Diamond Operator for own class causes NullPointerExcepti…

    …on if Static Compilation is enabled

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7880

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/382.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #382
    
----
commit 9a9b039c26826c326dd539cbfee78a3650a7d98e
Author: paulk <paulk@asert.com.au>
Date:   2016-08-10T13:07:01Z

    GROOVY-7880: Diamond Operator for own class causes NullPointerException if Static Compilation is enabled

----
;;;","11/Aug/16 09:07;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/382
;;;","11/Aug/16 09:08;paulk;Proposed PR merged. Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,
Groovy calls wrong method if there is a static method on an interface,GROOVY-7879,12986789,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,wolfs,wolfs,05/Jul/16 11:35,02/May/17 02:03,14/Jul/23 06:02,21/Apr/17 11:04,2.4.7,,,,,,,,2.4.11,,,,Compiler,,,,2,,,,,,,"If there is an interface having the static method {{foo}} and a class {{Impl}} implementing this interface also having a static method {{foo}}, then calling {{Impl.foo()}} calls the method on the interface. For an easy self contained example have a look at https://github.com/wolfs/groovy-static-interface-method-test/blob/master/src/test/groovy/StaticInterfaceTest.groovy.

This can yield class cast exceptions on Java 8 and from Java 9 build 125 onwards this yields 
{code}
java.lang.IncompatibleClassChangeError: Method ... must be InterfaceMethodref constant
{code}
This verification has been introduced here: https://bugs.openjdk.java.net/browse/JDK-8145148.",,DmitryKh,Don-vip,githubbot,jwagenleitner,nlebas,paulk,wolfs,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 21 11:04:00 UTC 2017,,,,,,,,,,"0|i30j7r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Apr/17 22:46;githubbot;GitHub user dkhamitov opened a pull request:

    https://github.com/apache/groovy/pull/521

    GROOVY-7879 Groovy calls wrong method if there is a static method on …

    Hi guys, can we consider a small kind of tactical fix (imho) to GROOVY-7879 or is it a bad idea/solution? It fixes the situation when we have:
    ```java
    interface Foo {
        static String foo() {
            return ""I'm Foo"";
        }
    }
    
    class Bar implements Foo {
        static String foo() {
            return ""I'm Bar"";
        }
    }
    ```
    but assert fails:
    ```java
    assert Bar.foo() == ""I'm Bar"" //Output: I'm Foo
    ```
    This pull request is for the parrot branch because static methods on interfaces were introduced in Java 8

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/dkhamitov/groovy GROOVY-7879-wrong-static-method

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/521.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #521
    
----
commit 07ba4cb300d0b26ff5742b4a11d5b164b688c381
Author: Dmitrii Kahmitov <khamitov.dm@gmail.com>
Date:   2017-04-05T06:49:54Z

    GROOVY-7879 Groovy calls wrong method if there is a static method on an interface

----
;;;","21/Apr/17 03:50;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/521
;;;","21/Apr/17 11:04;paulk;PR merged. Thanks!;;;",,,,,,,,,,,,,,,,,,,
Prevent namespaces to be inserted in tags,GROOVY-7878,12986292,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,,acarlstein,acarlstein,01/Jul/16 19:22,02/May/17 02:03,14/Jul/23 06:02,04/Jul/16 04:56,,,,,,,,,,,,,XML Processing,,,,0,,,,,,,"*Short Explanation*
The engine is removing the namespace from the header and inserting in each tag related with the namespace. This makes the XML result to be unusable in some systems.

*Long Explanation*

Let's say we have this XML file :

{code}
<?xml version=""1.0"" encoding=""UTF-8""?>
<linguacode xmlns=""http://xmlns.iqnavigator.com/linguacode/core"" xmlns:req=""http://xmlns.iqnavigator.com/linguacode/profiles/requisition"" xmlns:gsp=""http://groovy.codehaus.org/2005/gsp"">
    <organizationKey>${orgKey}</organizationKey>
    <req:hiringManager>${username}</req:hiringManager>
</linguacode>
{code}

After we bind the map with the information:

{code}
       def result = null
        try{
            def resource = grailsApplication.mainContext.getResource(xmlTemplateFilename)
            if (resource.exists()) {
                def engine = new XmlTemplateEngine()
                result = engine.createTemplate(resource.getFile()).make(mapToBind)
            }
        }catch(ex){
            ex.printStackTrace()
        }

{code}

We get this xml result:
{code}
<?xml version=""1.0"" encoding=""UTF-8""?>
<linguacode xmlns='http://xmlns.iqnavigator.com/linguacode/core'>
    <organizationKey>ABC Key</organizationKey>
    <req:hiringManager xmlns:req=""http://xmlns.iqnavigator.com/linguacode/profiles/requisition"" >Batman</req:hiringManager>
</linguacode>
{code}

The correct result should be: 
{code}
<?xml version=""1.0"" encoding=""UTF-8""?>
<linguacode xmlns='http://xmlns.iqnavigator.com/linguacode/core' xmlns:req=""http://xmlns.iqnavigator.com/linguacode/profiles/requisition"" >
    <organizationKey>ABC Key</organizationKey>
    <req:hiringManager>Batman</req:hiringManager>
</linguacode>
{code}

Perhaps adding a flag or some way to inject a closure that would allow us to prevent this behavior would be welcome.

Everything else is fantastic. Thanks for creating this plugin.",Grails,acarlstein,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Important,,,,,,,,9223372036854775807,,,Mon Jul 04 04:56:27 UTC 2016,,,,,,,,,,"0|i30g5j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jul/16 02:24;paulk;The two XML fragments are technically identical. I presume you have some other system that is broken though and can't handle that form?;;;","04/Jul/16 04:55;acarlstein;I just happen to solve the issue I was having.

Instead of using the common constructor:

def engine = new XmlTemplateEngine()

I needed to use this other contructor, XmlTemplateEngine(XmlParser xmlParser, GroovyShell groovyShell) by using 
XmlParser(boolean validating, boolean namespaceAware)

def xmlParser = new XmlParser(true, false)
def groovyShell = new GroovyShell()
def engine = XmlTemplateEngine(xmlParser, groovyShell)

;;;","04/Jul/16 04:56;acarlstein;I just happen to solve the issue I was having.

Instead of using the common constructor:

def engine = new XmlTemplateEngine()

I needed to use this other contructor, XmlTemplateEngine(XmlParser xmlParser, GroovyShell groovyShell) by using
XmlParser(boolean validating, boolean namespaceAware)

def xmlParser = new XmlParser(true, false)
def groovyShell = new GroovyShell()
def engine = XmlTemplateEngine(xmlParser, groovyShell)
;;;",,,,,,,,,,,,,,,,,,,
ClassCastException when calling DefaultTypeTransformation#compareEqual,GROOVY-7876,12984146,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,aewhite,aewhite,27/Jun/16 22:33,01/Feb/17 23:18,14/Jul/23 06:02,21/Jul/16 23:33,2.4.6,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"It appears that comparing two objects that both implement comparable with DefaultTypeTransformation#compareEqual is not safe in all cases. Consider enums for example, which throw exceptions when compared to differing classes. 

This is using Eclipse Collections for pairs but the idea is the same in general. 

{code}
    enum E1 {A, B, C}
    enum E2 {D, E, F}

    def ""test groovy oddness""() {
        when:
        def test = DefaultTypeTransformation.compareEqual(
            Tuples.pair(E1.A, 1), 
            Tuples.pair(E2.D, 1))

        then:
        assert test == false
    }
{code}

Stacktrace

{code}
java.lang.ClassCastException
	at java.lang.Enum.compareTo(Enum.java:180)
	at java.lang.Enum.compareTo(Enum.java:55)
	at org.eclipse.collections.impl.tuple.PairImpl.compareTo(PairImpl.java:95)
	at org.eclipse.collections.impl.tuple.PairImpl.compareTo(PairImpl.java:22)
	at com.GroovyTests.test groovy oddness(GroovyTests.groovy:36)
{code}",,aewhite,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7892,,,,,,,,GROOVY-4046,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 25 22:49:21 UTC 2016,,,,,,,,,,"0|i307vr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jul/16 10:56;paulk;A standalone example:
{code}
@Grab('org.eclipse.collections:eclipse-collections:7.1.0')
import org.eclipse.collections.impl.tuple.Tuples

enum E1 {A, B, C}
enum E2 {D, E, F}

assert Tuples.pair(E1.A, 1) != Tuples.pair(E2.D, 1) // ClassCastException
{code}
but my comment is, isn't this a flaw in the Eclipse collections PairImpl class because this also fails:
{code}
assert Tuples.pair(E1.A, 1).compareTo(Tuples.pair(E2.D, 1)) // ClassCastException
{code}
but this succeeds:
{code}
assert E1.A != E2.D
{code}
I guess though we could easily catch that exception and return false.;;;","19/Jul/16 12:03;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/368

    GROOVY-7876: ClassCastException when calling DefaultTypeTransformatio…

    …n#compareEqual

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7876

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/368.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #368
    
----
commit ee4242301a8eee9f558434e36b0d456cf8939ecb
Author: paulk <paulk@asert.com.au>
Date:   2016-07-19T12:02:01Z

    GROOVY-7876: ClassCastException when calling DefaultTypeTransformation#compareEqual

----
;;;","21/Jul/16 23:30;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/368
;;;","21/Jul/16 23:33;paulk;Proposed PR merged;;;","25/Jul/16 14:55;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/372

    GROOVY-7876 - ClassCastException when calling DefaultTypeTransformati…

    …on#compareEqual (additional refactoring)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7876b

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/372.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #372
    
----
commit 65362bdfad86cc785a9fa039a58d512beabff032
Author: paulk <paulk@asert.com.au>
Date:   2016-07-25T14:53:39Z

    GROOVY-7876 - ClassCastException when calling DefaultTypeTransformation#compareEqual (additional refactoring)

----
;;;","25/Jul/16 22:49;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/372
;;;",,,,,,,,,,,,,,,,
IntRange fail fast on too large a range out by one,GROOVY-7875,12983439,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,paulk,27/Jun/16 09:59,01/Feb/17 23:18,14/Jul/23 06:02,27/Jun/16 10:12,,,,,,,,,2.4.8,,,,,,,,0,,,,,,,The error message creating a too large range is out by one.,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 27 10:12:43 UTC 2016,,,,,,,,,,"0|i304l3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Jun/16 10:12;paulk;error message tweaked appropriately;;;",,,,,,,,,,,,,,,,,,,,,
Regression performance issue in string methods,GROOVY-7873,12982307,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,jwagenleitner,tadaskay,tadaskay,23/Jun/16 12:11,01/Feb/17 23:19,14/Jul/23 06:02,25/Jun/16 05:37,2.4.7,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"Starting with 2.4.7, performance in string processing (in certain scenarios) has decreased dramatically. Specifically, it happens when using {{stripMargin()}} on a {{GString}} that has a variable substitution with a huge String value. In our app performance decrease was from tens of miliseconds to 1+ minute. 
I suspect the latest refactoring in string methods.

Attaching a test case.

{code}
R2D2:groovystrperf tadaskay$ /usr/local/Cellar/groovy/2.4.7/bin/groovy test.groovy
Took 1456 ms
R2D2:groovystrperf tadaskay$ /usr/local/Cellar/groovy/2.4.5/bin/groovy test.groovy
Took 43 ms
{code}",,githubbot,jwagenleitner,paulk,tadaskay,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"23/Jun/16 12:11;tadaskay;test.groovy;https://issues.apache.org/jira/secure/attachment/12812809/test.groovy",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 27 05:29:24 UTC 2016,,,,,,,,,,"0|i2zyw7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jun/16 23:02;paulk;There was a performance increase in other scenarios. Obviously our scenario coverage wasn't good enough. We'll possibly have to revert if we can't find something that improves your case too.;;;","25/Jun/16 01:16;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/356

    GROOVY-7873 - Regression performance issue in string methods

    In order to implement CharSequence the GString implementation must call toString each time a CharSequence method is invoked.  This is expensive, so GStrings should be converted toString if methods such as charAt are going to be called from a loop.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7873

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/356.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #356
    
----
commit 1019df6be01b1898312797534ccc8406fd4f4fad
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-06-25T01:08:57Z

    GROOVY-7873 - Regression performance issue in string methods
    
    In order to implement CharSequence the GString implementation must call toString each time a CharSequence method is invoked.  This is expensive, so GStrings should be converted toString if methods such as charAt are going to be called from a loop.

commit 720115d7444d758f0c057ec8d47772d2ffb81154
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-06-25T01:09:45Z

    GROOVY-7873 - test for demo purposes, not to be merged

----
;;;","25/Jun/16 05:25;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/356
;;;","25/Jun/16 05:37;jwagenleitner;Thanks for reporting the issue.

A work-around until the next release would be to call toString on the gstr before calling stripMargin or stripIndent.;;;","27/Jun/16 05:29;tadaskay;Thank you for the quick response and the fix.;;;",,,,,,,,,,,,,,,,,
Nested calls between @Lazy static properties throws MissingPropertyException,GROOVY-7872,12982300,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,endSly,endSly,23/Jun/16 11:42,01/Feb/17 23:18,14/Jul/23 06:02,17/Jul/16 12:46,,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"This piece of code throws {{MissingPropertyException}}
{noformat}
class LazyTesting {
  @Lazy static final Set<String> STRING_SET = ['a', 'b', 'c'] as Set
  @Lazy static final Set<String> BIGGER_STRING_SET = (['d', 'e', 'f'] + STRING_SET) as Set
}
println LazyTesting.BIGGER_STRING_SET
{noformat}

{noformat}
java.lang.ExceptionInInitializerError
	at LazyTesting.getBIGGER_STRING_SET(test.groovy)
	at test.run(test.groovy:6)
Caused by: groovy.lang.MissingPropertyException: No such property: STRING_SET for class: LazyTesting$SetHolder_BIGGER_STRING_SET
{noformat}",,endSly,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jul 17 12:46:03 UTC 2016,,,,,,,,,,"0|i2zyun:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Jul/16 12:44;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/354
;;;","17/Jul/16 12:46;paulk;merged, thanks!;;;",,,,,,,,,,,,,,,,,,,,
Implicit returns of transformed binary expressions do not have line numbers when statically compiled,GROOVY-7870,12981399,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,21/Jun/16 16:14,01/Feb/17 23:18,14/Jul/23 06:02,07/Jul/16 02:58,2.4.7,,,,,,,,2.4.8,,,,Static compilation,,,,0,,,,,,,"If certain transformed binary expressions (<=>, ==, <<,  >>, >>>) are implicitly returned, their line numbers are not reported. Example:
{code}
@groovy.transform.CompileStatic
def test() {
    def l = []
    l << 3
}
{code}

The code above is compiled to the following bytecode (as seen using GroovyConsole):
{code}
  public test()Ljava/lang/Object;
   L0
    LINENUMBER 3 L0
    ICONST_0
    ANEWARRAY java/lang/Object
    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.createList ([Ljava/lang/Object;)Ljava/util/List;
    ASTORE 1
   L1
    ALOAD 1
    POP
    ALOAD 1
    ICONST_3
    INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
    INVOKESTATIC org/codehaus/groovy/runtime/DefaultGroovyMethods.leftShift (Ljava/util/List;Ljava/lang/Object;)Ljava/util/List;
    ARETURN
   L2
    ACONST_NULL
    ARETURN
    LOCALVARIABLE this Lscript1466525199339; L0 L2 0
    LOCALVARIABLE l Ljava/util/List; L1 L2 1
    MAXSTACK = 2
    MAXLOCALS = 2
{code}
There is no line number corresponding to L1, which includes the leftShift call (should be line number 4.)

This is occurs because 1) BinaryExpressionTransformer does not copy the source position of the original expression to the transformed expression in some cases, and 2) ReturnAdder set the source position of the generated return for an expression statement with that of the expression.",,githubbot,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jul 07 02:55:14 UTC 2016,,,,,,,,,,"0|i2ztjb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/Jun/16 07:31;paulk;Shil Sinha, were you planning on looking into this?;;;","23/Jun/16 15:17;shils;I have code ready for a PR, but I haven't had a chance to push it yet. It should be up later today (eastern U.S. time.) ;;;","23/Jun/16 22:48;paulk;Cool! No rush at all. I was just wondering whether I should look at the issue. But seems you have it well in hand.;;;","02/Jul/16 15:31;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/362

    GROOVY-7870: BinaryExpressionTransformer: Set line numbers on transfo…

    …rmed binary expressions

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7870

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/362.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #362
    
----
commit 388a6ca39a709e60c245baa5705efd82de305dd9
Author: Shil Sinha <shils@apache.org>
Date:   2016-07-02T15:29:21Z

    GROOVY-7870: BinaryExpressionTransformer: Set line numbers on transformed binary expressions

----
;;;","07/Jul/16 02:55;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/362
;;;",,,,,,,,,,,,,,,,,
"Calling super constructor with in-line casted Closure param does not compile: unexpected ""constructor call must be first statement"" error",GROOVY-7868,12980611,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,kadblas,kadblas,19/Jun/16 00:07,11/Nov/20 02:01,14/Jul/23 06:02,31/Oct/19 23:54,2.4.6,,,,,,,,3.0.0-beta-3,,,,Compiler,,,,0,,,,,,,"Running the following code in Groovy Console should result ""successfully"" with ""Could not find matching constructor for 'SomeObject'""

Instead, code fails with issue ""Constructor call must be the first statement in a constructor,"" which is weird because it is...

Code only runs correctly (e.g. fails in the expected way) in 5 cases:
* ""{} as BiConsumer"" line in the super constructor is commented out
* all arguments past Closure-cast line must be commented out 
* Closure is cast to a different object (say String)
* the first ""Collections.emptyList()"" is changed to a different type (say String) but the second remains the same
* The BiConsumer's second generic type (Collection<String>) is changed to a different type (say String)

{code}
import java.util.function.BiConsumer

public class ProblematicObject extends SomeObject {

    public ProblematicObject() {
        super(
            { } as BiConsumer<String, Collection<String>>, 
            
            Collections.emptyList(),
            Collections.emptyList()
        )
    }
    
}

new ProblematicObject()
{code}
",Linux Mint 17.3,daniel_sun,emilles,kadblas,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Oct 31 23:53:48 UTC 2019,,,,,,,,,,"0|i2zp8f:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Jun/16 07:28;paulk;Looks like the {{argList}} production in the grammar isn't quite right. It is probably getting the '>>' confused as a shiftRight operator. Workarounds are to add a space between the two greater than signs (ugly I know), e.g.:
{code}
{ } as BiConsumer<String, Collection<String> >,
...
{code}
or place the whole argument within round brackets:
{code}
({ } as BiConsumer<String, Collection<String>>),
...
{code}
I should point out that everything is being ultimately parsed correctly (no >> by mistake or anything) however in deciding whether this is a special super call or a standard method, the latter is being selected as the parsing path. So it's lookahead logic that is wrong.;;;","31/Oct/19 18:31;emilles;Confirmed still and issue for the parser.  Here is a slightly simplified case to recreate:
{code:groovy}
import java.util.function.Supplier

class One7868 {
  One7868(Supplier<List<String>> strings, whatever) {
    this.strings = strings
  }

  Supplier<List<String>> strings

  String getString() {
    strings.get()[0]
  }
}

class Two7868 extends One7868 {
  Two7868() {
    super(
      { -> ['works']} as Supplier<List<String>>, // remove generics and all is well
      Collections.emptyList()
    )
  }
}

println new Two7868().string
{code};;;","31/Oct/19 23:53;daniel_sun;The issue is fixed in Groovy 3

{code:java}
import java.util.function.Supplier

class One7868 {
  One7868(Supplier<List<String>> strings, whatever) {
    this.strings = strings
  }

  Supplier<List<String>> strings

  String getString() {
    strings.get()[0]
  }
}

class Two7868 extends One7868 {
  Two7868() {
    super(
      { -> ['works']} as Supplier<List<String>>, // remove generics and all is well
      Collections.emptyList()
    )
  }
}

assert 'works' == new Two7868().strings.get()[0]

{code};;;",,,,,,,,,,,,,,,,,,,
"asType(Collection col, Class clazz) ingnores exceptions in clazz constructor",GROOVY-7867,12980171,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,DameNoSupaplex,DameNoSupaplex,17/Jun/16 12:14,03/Feb/22 22:34,14/Jul/23 06:02,12/Jul/21 14:34,2.4.3,2.4.4,2.4.5,2.4.6,2.4.7,2.4.8,2.5.0-beta-1,3.x,3.0.9,4.0.0-beta-1,,,groovy-runtime,,,,0,,,,,,,"Method ignores exception in clazz constructor, and if any - throws exception later, when try find constructor with args matches collection items.

public static <T> T asType(Collection col, Class<T> clazz) in DefaultGroovyMethods.java, line 10623:
{code:title=DefaultGroovyMethods.java|borderStyle=solid}
        Object[] args = {col};
        try {
            return (T) InvokerHelper.invokeConstructorOf(clazz, args);
        } catch (Exception e) {
            // ignore, the constructor that takes a Collection as an argument may not exist
        }
{code}

In my opinion, should ignore only if such constroctor not found",no matter,DameNoSupaplex,paulk,,,,,,,"eric-milles commented on pull request #1590:
URL: https://github.com/apache/groovy/pull/1590#issuecomment-874766107


   Instead of stashing `ex` into `e` and then extracting in the `GroovyCastException` constructor, can you save the reference as a peer to the `nested` local variable and then call `addSuppressed` on the new cast exception instance?  I can't really say how many places make use of the `GroovyCastException` constructor.
   
   Also, you don't need a package statement for your test scripts.  They should run just fine from the default package.  Usually we add that only if there is a need to check a scenario involving separate packages.


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;06/Jul/21 13:35;githubbot;600","nineninesevenfour commented on pull request #1590:
URL: https://github.com/apache/groovy/pull/1590#issuecomment-877655321


   @eric-milles 
   Thank you so much for your review! I did the requested changes. Honestly I have no idea why I made it unnecessarily complicated like this, it's much better now.


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;10/Jul/21 15:25;githubbot;600","eric-milles merged pull request #1590:
URL: https://github.com/apache/groovy/pull/1590


   


-- 
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

To unsubscribe, e-mail: notifications-unsubscribe@groovy.apache.org

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;12/Jul/21 20:01;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jun 20 06:05:41 UTC 2016,,,,,,,,,,"0|i2zmif:",9223372036854775807,,,,,,,,,,,,,,,,,,,"20/Jun/16 04:59;paulk;Can you provide an example to motivate why you want such a change? The current behavior is by design. It permits the following behavior for instance:
{code}
class SingletonList extends Vector {
    SingletonList(Collection c) {
        super(c)
        if (c.size() != 1) throw new IllegalStateException()
    }
    SingletonList(int capacity, int increment) {
        super(capacity, increment)
    }
}

def myList = [10, 5] as SingletonList
assert myList.size() == 0
assert myList.capacity() == 10
{code}
Although I suspect that reliance on such behavior would not be in widespread use.;;;","20/Jun/16 05:37;DameNoSupaplex;You right. I'm not figured such use. But maybe possible some changes to help in use case, when only one matches constructor is Constructir(collection c). In such situation if Exception in constructor complitely ignored it's hard to find mistake, because throwed exception tells about not fond constructor on args from list elements.;;;","20/Jun/16 06:05;DameNoSupaplex;Mabe something like java's suppressedExceptions?;;;",,,,,,,,,,,,,,,,,,,
Better error message in the presence of Generics arity errors,GROOVY-7865,12979715,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,16/Jun/16 08:30,12/Apr/18 09:07,14/Jul/23 06:02,24/Jun/16 22:03,2.4.7,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,"Currently there are many places in the codebase which make assumptions that they are working with valid generics information. Generics information is checked but not until the classgen phase. Consequently, we get a very uninformative ArrayIndexOutOfBoundsException from the compiler - either along with or instead of the subsequent generics checking. These are all examples which should fail compilation since I have intentionally tried to instantiate the generics type with an incorrect number of parameters. It is just the error message which is not currently useful and masking the subsequent message that would occur had not the exception got in the way. 

Example with TraitComposer:
{code}
class MyNames implements Queue<Integer, String> { }
// java.lang.ArrayIndexOutOfBoundsException: 1
// TraitComposer calls GenericsUtils.parameterizeType()
// which calls GenericsUtils.createGenericsSpec()
{code}
Example with StaticTypeCheckingVisitor:
{code}
@CompileStatic
def foo() {
  List<String> ss = new LinkedList<Integer, String>()
}
// => java.lang.ArrayIndexOutOfBoundsException: 1
{code}
Example with Verifier:
{code}
class MyNames extends Queue<Integer, String> { }
{code}
which gives
{noformat}
2 compilation errors:
The class java.util.Queue refers to the class java.util.Queue and uses 2 parameters, but the referred class needs 1
 at line: 5, column: 23
Exception thrown
java.lang.ArrayIndexOutOfBoundsException: 1
	at org.codehaus.groovy.ast.tools.GenericsUtils.createGenericsSpec(GenericsUtils.java:410)
{noformat}
So we get one error from the generics checking but then continue on to the Verifier.

I suspect the fix for this is to move just the arity checking part of that visitor to an earlier phase.",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-6660,,,,,,,GROOVY-8211,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 24 22:03:04 UTC 2016,,,,,,,,,,"0|i2zjpb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jun/16 08:33;paulk;I should point out that any transforms that use {{GenericsUtils.parameterizeType()}} or {{GenericsUtils.createGenericsSpec()}} are also subject to this error. There are currently about 20 such usages.;;;","17/Jun/16 08:40;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/352

    GROOVY-7865: Better error message in the presence of Generics arity e…

    …rrors (spike)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7865

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/352.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #352
    
----
commit d4250bc36893ccfa4a575c260e4df586f2c761fa
Author: paulk <paulk@asert.com.au>
Date:   2016-06-17T08:38:25Z

    GROOVY-7865: Better error message in the presence of Generics arity errors (spike)

----
;;;","23/Jun/16 09:32;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/353

    GROOVY-7865: Better error message and earlier detection of Generics errors

    reworked version

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7865b

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/353.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #353
    
----
commit 2b8d488f0519add9aef73f59d998769f8808cbfe
Author: paulk <paulk@asert.com.au>
Date:   2016-06-17T08:38:25Z

    GROOVY-7865: Better error message in the presence of Generics arity errors (spike)

----
;;;","24/Jun/16 21:47;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/353
;;;","24/Jun/16 21:48;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/groovy/pull/352
;;;","24/Jun/16 22:03;paulk;PR #353 applied but only in the master branch.;;;",,,,,,,,,,,,,,,,
Statically compiled calls to private outer class methods fail with multiple levels of nesting,GROOVY-7863,12979154,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,14/Jun/16 21:19,01/Feb/17 23:19,14/Jul/23 06:02,16/Jun/16 03:31,2.4.7,,,,,,,,2.4.8,,,,Static compilation,,,,0,,,,,,,"Example:
{code}
@groovy.transform.CompileStatic
class A {
    private int bar() { 123 }
    
    class B {
        int testInner() { new C().barInner() }
        
        class C {
            int barInner() { bar() }
        }
    }

    int test() {
        new B().testInner()
    }
}
assert new A().test() == 123
{code}
The code above fails with the following error at runtime:
{code}
org.codehaus.groovy.runtime.typehandling.GroovyCastException: Cannot cast object 'A$B@4c1d9d4b' with class 'A$B' to class 'A'
{code}

This occurs because the bridge method owner for an 'implicit this' private method call is assumed to be the immediate outer class.",,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 16 03:30:02 UTC 2016,,,,,,,,,,"0|i2zgm7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Jun/16 22:29;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/350

    GROOVY-7863: Statically compiled calls to private outer class methods…

    … fail with multiple levels of nesting

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7863

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/350.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #350
    
----
commit b492a3465920121e6b825400f039849dc8ef6cc3
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2016-06-14T22:27:08Z

    GROOVY-7863: Statically compiled calls to private outer class methods fail with multiple levels of nesting

----
;;;","16/Jun/16 03:30;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/350
;;;",,,,,,,,,,,,,,,,,,,,
Statically compiled calls to protected methods of an outerclass' superclass result in IllegalAccessErrors,GROOVY-7862,12978544,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,14/Jun/16 00:17,02/May/17 02:03,14/Jul/23 06:02,17/Jul/16 15:27,2.4.7,,,,,,,,2.5.0-alpha-1,,,,Static compilation,,,,0,,,,,,,"Example:
{code}
package one;
public class Base {
    protected int foo() {
        123
    }
}
{code}
{code}
package two;
class SubBase extends Base {
    class Inner {
        int test() {
            foo()
        }
    }
    
    int innerTest() {
        new Inner().test()
    }
}
assert new SubBase().innerTest() == 123
{code}

The code above will fail with the following error:
{code}
java.lang.IllegalAccessError: tried to access method one.Base.foo()I from class two.SubBase$Inner
{code}


This is due to bridge methods for protected methods not being correctly generated (and subsequently used when writing protected method invocations.)
",,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jul 17 15:27:03 UTC 2016,,,,,,,,,,"0|i2zevj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Jun/16 04:22;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/351

    GROOVY-7862: Statically compiled calls to protected methods of an out…

    …erclass' superclass result in IllegalAccessErrors

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7862

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/351.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #351
    
----
commit daa0c34d6261d0bbc98f9edbf5814da3dd5200e6
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2016-06-15T23:16:34Z

    GROOVY-7862: Statically compiled calls to protected methods of an outerclass' superclass result in IllegalAccessErrors

----
;;;","17/Jul/16 15:24;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/351
;;;","17/Jul/16 15:27;shils;Merged to Master only as the fix uses changes made for GROOVY-7325 which were not backported.;;;",,,,,,,,,,,,,,,,,,,
Erroneous method pointer expressions pass STC,GROOVY-7859,12977765,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,shils,shils,10/Jun/16 21:45,10/Feb/23 21:40,14/Jul/23 06:02,04/Dec/22 16:22,2.4.7,,,,,,,,3.0.14,4.0.7,,,Static Type Checker,,,,1,,,,,,,"Method pointer expressions are not type checked (with STC enabled). The following example should not compile for a number of reasons:

{code}
@groovy.transform.TypeChecked
void test() {
  def x = 'abc'.&bar //bar is not a String method
  x() // groovy.lang.MissingMethodException
  x = String.&length //length is a non-static method
  x() // java.lang.IllegalArgumentException: object is not an instance of declaring class
  x = String.&size //size is a non-static extension method
  x() // java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.String
}
test()
{code}

",,daniilo,emilles,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 04 16:22:40 UTC 2022,,,,,,,,,,"0|i2zbcf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Sep/17 06:20;paulk;The corresponding method reference equivalents using the Parrot parser suffer from the same errors:
{code}
x = 'abc'::bar
x = String::length
x = String::size
{code}
This is to be expected given the current implementation.;;;","14/Oct/17 15:18;emilles;I also found that {{String.&toLowerCase}} (for example) is not usable.
{code}
assert ['ABC','XYZ'].collect(String.&toLowerCase) == ['abc','xyz']

groovy.lang.MissingMethodException: No signature of method: java.lang.String.toLowerCase() is applicable for argument types: (java.lang.String) values: [ABC]
Possible solutions: toLowerCase(), toLowerCase(java.util.Locale), toUpperCase(), toUpperCase(java.util.Locale)
	at Script1.run(Script1.groovy:1)
{code}

Should I file a separate bug report for this?;;;","14/Oct/17 15:57;shils;[~emilles] That issue was addressed in https://issues.apache.org/jira/browse/GROOVY-7772, though it's unclear reading the comments whether the resolution means that 2.6 has the behavior for groovy style method pointers, or java style method references.;;;","12/Nov/20 21:13;emilles;This may have been addressed by GROOVY-9463;;;","19/Dec/21 19:20;emilles;Is the expectation that STC know that ""x"" requires 1 argument when initialized from ""String.&length"" or ""String.&size""?  ""x"" is callable if a string argument is supplied.;;;","04/Dec/22 16:22;emilles;For pointer or reference, the following is current behavior:
{code:groovy}
@groovy.transform.TypeChecked
void test7859() {
  def x = 'abc'.&bar // STC: Cannot find matching method java.lang.String#bar

  x = String.&length // instance method closure that requires String as first argument

  x = String.&size // instance extension method closure that requires String as first argument
}
{code};;;",,,,,,,,,,,,,,,,
Adding CompileStatic via compiler config script to class with eachWithIndex results in exception in instruction selection phase,GROOVY-7856,12977236,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,rvenutolo,rvenutolo,09/Jun/16 13:55,20/May/19 07:31,14/Jul/23 06:02,16/Mar/19 10:40,2.4.7,,,,,,,,2.5.7,3.0.0-beta-1,,,Compiler,,,,1,,,,,,,"I have run into an issue when adding the CompileStatic AST transformation to a class via the Groovy compiler configscript argument.

{code:title=Demo.groovy|borderStyle=solid}
class Demo {
    void test() {
        ['a', 'b'].eachWithIndex {String s, int i -> println ""$i: $s""}
    }
}
{code}

{code:title=config.groovy|borderStyle=solid}
import groovy.transform.CompileStatic
import org.codehaus.groovy.ast.ClassNode

withConfig(configuration) {
    source(classValidator: {ClassNode classNode -> classNode.nameWithoutPackage == 'Demo'}) {
        ast(CompileStatic)
    }
}
{code}

{code:title=Compile using --configscript|borderStyle=solid}
$ groovyc --configscript config.groovy Demo.groovy
{code}

{code:title=Output (abbreviated)|borderStyle=solid}
>>> a serious error occurred: BUG! exception in phase 'instruction selection' in source unit 'Demo.groovy' unexpected NullpointerException
>>> stacktrace:
BUG! exception in phase 'instruction selection' in source unit 'Demo.groovy' unexpected NullpointerException
    at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1058)
    at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
    at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
    ...
Caused by: java.lang.NullPointerException
    at org.codehaus.groovy.control.ClassNodeResolver.tryAsLoaderClassOrScript(ClassNodeResolver.java:180)
    at org.codehaus.groovy.control.ClassNodeResolver.findClassNode(ClassNodeResolver.java:170)
    at org.codehaus.groovy.control.ClassNodeResolver.resolveName(ClassNodeResolver.java:126)
  ...
{code}

*Notes*
* Groovy & JVM versions: {{Groovy Version: 2.4.7 JVM: 1.8.0_92 Vendor: Oracle Corporation OS: Linux}}
** Have tried Groovy versions going back to 2.4.3 and Oracle JVM 1.7.0_79
* Changing any of the following will result in no compilation error:
** Remove the {{source(classValidator: ...)}} code around {{ast}}, leaving {{ast(CompileStatic)}}, in the compiler config script
** Replace the {{eachWithIndex}} call in Demo with {{each}}
** Annotate {{Demo}} with {{@CompileStatic}} and compile without {{--configscript}}


I have detailed and demoed the bug [here|https://github.com/rvenutolo/compilestatic-compiler-config] with some code you can clone and run.
",Groovy Version: 2.4.7 JVM: 1.8.0_92 Vendor: Oracle Corporation OS: Linux,emilles,paulk,rvenutolo,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Mar 16 10:40:44 UTC 2019,,,,,,,,,,"0|i2z833:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Jul/16 01:39;paulk;I have a temporary fix in the master branch. Basically the static compiler is trying to find the class {{Integer}} (no package). This is taken directly from the {{@ClosureParams}} options attribute hint. I haven't had enough time yet to work out why using {{configscript}} doesn't do the same package name resolving as seems to occur normally (without {{configscript}}). So for now I have {{java.lang.Integer}} in the hint. We should really understand why this is occurring and also I haven't created a test case yet, so I'll leave the issue open for now. But any feedback in the meantime on whether this fixes things for you would be appreciated.;;;","18/Jul/16 15:01;rvenutolo;Your temporary fix in the master branch does appear to fix this issue. This wasn't anything critical for me, so I worked around it when I encountered the issue. I am very curious to see what you find as I was only able to hit the bug under very particular circumstances, as detailed above.

Thanks and good luck.;;;","15/Mar/19 20:36;emilles;It appears that {{SourceAwareCustomizer}} is not {{CompilationUnitAware}}...and when its delegate is, it fails to pass along a compilation unit reference that would normally be set by {{org.codehaus.groovy.control.CompilationUnit.applyCompilationCustomizers(CompilerConfiguration)}}.;;;","15/Mar/19 20:48;emilles;This should take care of it:
{code:java}
package org.codehaus.groovy.control.customizers;
...
public abstract class DelegatingCustomizer extends CompilationCustomizer /*GRECLIPSE add*/implements CompilationUnitAware/*GRECLIPSE end*/ {
    protected final CompilationCustomizer delegate;

    public DelegatingCustomizer(final CompilationCustomizer delegate) {
        super(delegate.getPhase());
        this.delegate = delegate;
    }

    // GRECLIPSE add
    @Override
    public void setCompilationUnit(final CompilationUnit compilationUnit) {
        if (delegate instanceof CompilationUnitAware) {
            ((CompilationUnitAware) delegate).setCompilationUnit(compilationUnit);
        }
    }
    // GRECLIPSE end

    @Override
    public void call(final SourceUnit source, final GeneratorContext context, final ClassNode classNode) throws CompilationFailedException {
        delegate.call(source, context, classNode);
    }
}
{code};;;","16/Mar/19 10:40;paulk;Fix from Eric merged.;;;",,,,,,,,,,,,,,,,,
NullPointerException in GenericsTypeMatcher,GROOVY-7855,12977163,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,graemerocher1,graemerocher1,09/Jun/16 09:23,08/Mar/22 12:16,14/Jul/23 06:02,19/Dec/21 19:15,2.4.7,,,,,,,,,,,,,,,,0,,,,,,,"I am getting the following exception when compiling some classes:

{code}
Error:Groovyc: BUG! exception in phase 'instruction selection' in source unit 'grails-datastore-gorm/src/main/groovy/org/grails/datastore/gorm/GormEnhancer.groovy' unexpected NullpointerException
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1058)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:62)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:115)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.intMain2(GroovycRunner.java:134)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.jetbrains.jps.incremental.groovy.InProcessGroovyc.runGroovycInThisProcess(InProcessGroovyc.java:156)
	at org.jetbrains.jps.incremental.groovy.InProcessGroovyc.access$000(InProcessGroovyc.java:51)
	at org.jetbrains.jps.incremental.groovy.InProcessGroovyc$1.call(InProcessGroovyc.java:85)
	at org.jetbrains.jps.incremental.groovy.InProcessGroovyc$1.call(InProcessGroovyc.java:82)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NullPointerException
	at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.compareGenericsWithBound(GenericsType.java:457)
	at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.matches(GenericsType.java:294)
	at org.codehaus.groovy.ast.GenericsType.isCompatibleWith(GenericsType.java:198)
	at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.compareGenericsWithBound(GenericsType.java:457)
	at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.checkGenerics(GenericsType.java:307)
	at org.codehaus.groovy.ast.GenericsType$GenericsTypeMatcher.matches(GenericsType.java:276)
	at org.codehaus.groovy.ast.GenericsType.isCompatibleWith(GenericsType.java:198)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.checkTypeGenerics(StaticTypeCheckingVisitor.java:970)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.checkReturnType(StaticTypeCheckingVisitor.java:1829)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor$1.returnStatementAdded(StaticTypeCheckingVisitor.java:173)
	at org.codehaus.groovy.classgen.ReturnAdder.addReturnsIfNeeded(ReturnAdder.java:120)
	at org.codehaus.groovy.classgen.ReturnAdder.addReturnsIfNeeded(ReturnAdder.java:186)
	at org.codehaus.groovy.classgen.ReturnAdder.visitMethod(ReturnAdder.java:76)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1787)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:126)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2119)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2078)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:164)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1078)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:53)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:249)
	at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:123)
	at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:63)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:134)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:178)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1053)
	... 22 more
{code}",,graemerocher1,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 16 06:33:01 UTC 2016,,,,,,,,,,"0|i2z7mv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Jun/16 09:29;graemerocher1;Seems to be caused by this method:

{code}
    @CompileStatic
    protected <D> List<AbstractGormApi<D>> getInstanceMethodApiProviders(Class<D> cls) {
        [getInstanceApi(cls), getValidationApi(cls)]
    }
{code}

Removing `CompileStatic` solves the issue;;;","13/Jun/16 10:54;paulk;I haven't worked out why yet, but some debug info at the point where the exception occurs. I had trouble trying to replicate with a simple self-contained example.
{code}
classNode = org.grails.datastore.gorm.AbstractGormApi <java.lang.Object>
bound = org.grails.datastore.gorm.AbstractGormApi <D> -> org.grails.datastore.gorm.AbstractGormApi <D>
classNodeType = java.lang.Object (previous value: org.grails.datastore.gorm.AbstractGormApi <java.lang.Object>)
name = D
classNodePlaceholders = {}
boundPlaceHolders = {D=D}
redirectBoundType = null (previous value: D)
{code}
;;;","14/Jun/16 13:21;paulk;I put in a fix which avoids the NPE. I haven't had time to craft a suitable standalone test yet. Leaving open until a test is added.;;;","16/Jun/16 06:33;graemerocher1;Thanks for looking into this;;;",,,,,,,,,,,,,,,,,,
Annotation value cannot be concatenated constant,GROOVY-7854,12975760,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,situokko,situokko,04/Jun/16 18:41,13/Dec/18 10:04,14/Jul/23 06:02,05/Nov/18 23:45,2.4.6,,,,,,,,2.5.4,3.0.0-alpha-4,,,Compiler,Static compilation,,,2,,,,,,,"Following code as .java class works ok:

{code:title=UserDAO.java|borderStyle=solid}
public abstract class UserDAO {
    public static final String Select_User_join_Addresses_Features_Images =
        ""select ""+
        ""u.*, a.*, f.*, i.* ""+
        ""from users u ""+
        ""left outer join addresses a on (u.id = a.user_id) ""+
        ""left outer join userfeatures f on (u.id = f.user_id) ""+
        ""left outer join images i on (u.id = i.user_id) "";

    public static final String Select_User_by_id =
            Select_User_join_Addresses_Features_Images + ""where u.id = :id"";

    public static final String Select_User_by_email =
            Select_User_join_Addresses_Features_Images + ""where u.email = lower(:email)"";

    @SqlQuery(Select_User_by_id)
    abstract FoldingList<User> findById(@Bind(""id"") long id);
}
{code}

However if I write and compile it as Groovy, I get ""Expected 'UserDAO.Select_User_by_id' to be an inline constant of type java.lang.String not a property expression"" error from compiler.

Also if works if those constant String are in separate .java class that is accessed from annotation (within a .groovy class), but not if they are in separate .groovy file.

So the difference seems to be that constant strings are not concatenated at compile-time in Groovy, but in Java they are? Is this by design or is it a bug that can be fixed?","- OS X 
- Java(TM) SE Runtime Environment (build 1.8.0_66-b17) 
- IntelliJ Idea 14 CE \w Groovy plugin 
- Gradle 2.2",dmurat,johnnyjian,paulk,situokko,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Nov 05 23:45:29 UTC 2018,,,,,,,,,,"0|i2yzpj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Jun/16 13:43;paulk;This is a known limitation. We could remove this limitation - a sketch of the idea is below - shown just for Strings not numbers yet - in case anyone else wants to play before I get time again to look further. But this would be the first time we have done such inlining, so we'd need to think it through a little carefully.
{code}
+++ src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
@@ -76,9 +76,9 @@
         Map<String, Expression> attributes = node.getMembers();
         for (Map.Entry<String, Expression> entry : attributes.entrySet()) {
             String attrName = entry.getKey();
-            Expression attrExpr = transformInlineConstants(entry.getValue());
-            entry.setValue(attrExpr);
             ClassNode attrType = getAttributeType(node, attrName);
+            Expression attrExpr = transformInlineConstants(entry.getValue(), attrType);
+            entry.setValue(attrExpr);
             visitExpression(attrName, attrExpr, attrType);
         }
         VMPluginFactory.getPlugin().configureAnnotation(node);
@@ -119,7 +119,7 @@
         return true;
     }
 
-    private Expression transformInlineConstants(Expression exp) {
+    private Expression transformInlineConstants(Expression exp, ClassNode attrType) {
         if (exp instanceof PropertyExpression) {
             PropertyExpression pe = (PropertyExpression) exp;
             if (pe.getObjectExpression() instanceof ClassExpression) {
@@ -133,15 +133,26 @@
                     if (field != null && Modifier.isStatic(field.getModifiers()) && Modifier.isFinal(field.getModifiers())) {
                         return new ConstantExpression(field.get(null));
                     }
                } catch (Exception e) {
                     // ignore, leave property expression in place and we'll report later
                 }
             }
+        } else if (exp instanceof BinaryExpression && (ClassHelper.STRING_TYPE.equals(attrType) || attrType
+                .isArray() && ClassHelper.STRING_TYPE.equals(attrType.getComponentType()))) {
+            BinaryExpression be = (BinaryExpression) exp;
+            if (be.getOperation().getText().equals(""+"")) {
+                Expression left = transformInlineConstants(be.getLeftExpression(), attrType);
+                Expression right = transformInlineConstants(be.getRightExpression(), attrType);
+                if (left instanceof ConstantExpression && right instanceof ConstantExpression) {
+                    return new ConstantExpression((String) ((ConstantExpression)left).getValue() +
+                            (String) ((ConstantExpression) right).getValue());
+                }
+            }
         } else if (exp instanceof ListExpression) {
             ListExpression le = (ListExpression) exp;
             ListExpression result = new ListExpression();
             for (Expression e : le.getExpressions()) {
-                result.addExpression(transformInlineConstants(e));
+                result.addExpression(transformInlineConstants(e, attrType));
             }
             return result;
         }
{code};;;","05/Jun/16 22:05;situokko;I'd love to be able to write such SQL-annotations in Groovy due to multi-line string support, as seen above, Java-still doesn't have them so more boilerplate is required.

When considering such inlining one need to think how to work with interpolation and GStrings and such. It would make sense to evaluate everything that is final at compile-time already then (like Java is doing now).;;;","05/Nov/18 23:45;paulk;Fixed as part of changes for GROOVY-3278.;;;",,,,,,,,,,,,,,,,,,,
o.c.g.r.t.DefaultTypeTransformation does not apply the right toString on primitve arrays when transforming to String,GROOVY-7853,12975096,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,jbaruch,jbaruch,02/Jun/16 08:42,02/May/17 02:03,14/Jul/23 06:02,23/Aug/16 03:53,2.4.6,,,,,,,,2.5.0-alpha-1,,,,,,,,0,breaking,,,,,,"As shown in #groovypuzzlers S3:

{code:borderStyle=solid}
byte[] data = ""hello"".bytes

String convert(byte[] data) {
    data
}

assert data.toString() == convert(data)
{code}",,githubbot,jbaruch,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 23 03:53:01 UTC 2016,,,,,,,,,,"0|i2yvmn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Jun/16 04:17;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/345

    GROOVY-7853: o.c.g.r.t.DefaultTypeTransformation does not apply the r…

    …ight toString on primitve arrays when transforming to String

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7853

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/345.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #345
    
----
commit 5c914153d3c97708d10cf210cf62989e51008368
Author: paulk <paulk@asert.com.au>
Date:   2016-06-03T04:15:09Z

    GROOVY-7853: o.c.g.r.t.DefaultTypeTransformation does not apply the right toString on primitve arrays when transforming to String

----
;;;","15/Jun/16 12:27;githubbot;Github user gillius commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/345#discussion_r67151385
  
    --- Diff: src/main/org/codehaus/groovy/runtime/typehandling/ShortTypeHandling.java ---
    @@ -41,7 +43,15 @@ public static Class castToClass(Object object) {
     
         public static String castToString(Object object) {
             if (object==null) return null;
    -        if (object instanceof Class) return (String) object;
    +        if (object instanceof boolean[]) return Arrays.toString((boolean[])object);
    --- End diff --
    
    Would it be more efficient to put this within an `if(object.getClass().isArray)` block?
;;;","15/Jun/16 12:37;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/345#discussion_r67152793
  
    --- Diff: src/main/org/codehaus/groovy/runtime/typehandling/ShortTypeHandling.java ---
    @@ -41,7 +43,15 @@ public static Class castToClass(Object object) {
     
         public static String castToString(Object object) {
             if (object==null) return null;
    -        if (object instanceof Class) return (String) object;
    +        if (object instanceof boolean[]) return Arrays.toString((boolean[])object);
    --- End diff --
    
    Good catch. Yes, that's probably a good optimization. Thanks for the
    suggestion.
    
    On Wed, Jun 15, 2016 at 10:27 PM, Jason Winnebeck <notifications@github.com>
    wrote:
    
    > In
    > src/main/org/codehaus/groovy/runtime/typehandling/ShortTypeHandling.java
    > <https://github.com/apache/groovy/pull/345#discussion_r67151385>:
    >
    > > @@ -41,7 +43,15 @@ public static Class castToClass(Object object) {
    > >
    > >      public static String castToString(Object object) {
    > >          if (object==null) return null;
    > > -        if (object instanceof Class) return (String) object;
    > > +        if (object instanceof boolean[]) return Arrays.toString((boolean[])object);
    >
    > Would it be more efficient to put this within an
    > if(object.getClass().isArray) block?
    >
    > —
    > You are receiving this because you authored the thread.
    > Reply to this email directly, view it on GitHub
    > <https://github.com/apache/groovy/pull/345/files/5c914153d3c97708d10cf210cf62989e51008368#r67151385>,
    > or mute the thread
    > <https://github.com/notifications/unsubscribe/AARF0Pnh0PV29an3T3l9GqZFHA3iJZtvks5qL--pgaJpZM4ItMJP>
    > .
    >

;;;","23/Aug/16 03:52;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/345
;;;","23/Aug/16 03:53;paulk;Proposed PR merged. It is a minor breaking change if people were relying on the legacy Java-like formatting for primitive arrays.;;;",,,,,,,,,,,,,,,,,
Inconsistent checking of final for multi-assignments,GROOVY-7852,12975001,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,02/Jun/16 01:05,02/May/17 02:03,14/Jul/23 06:02,03/Jun/16 04:19,,,,,,,,,2.5.0-alpha-1,,,,Compiler,,,,0,,,,,,,"The following code passes but should fail final variable analysis:
{code}
final x = 3
def y = 4
(x, y) = [30, 40]
assert x + y == 70
{code}",,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 03 04:19:54 UTC 2016,,,,,,,,,,"0|i2yv1j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jun/16 02:31;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/343

    GROOVY-7852: Inconsistent checking of final for multi-assignments

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7852

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/343.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #343
    
----
commit 0795f3eefd5ee9d0952d355098edc50e38639aaa
Author: paulk <paulk@asert.com.au>
Date:   2016-06-02T02:29:42Z

    GROOVY-7852: Inconsistent checking of final for multi-assignments

----
;;;","03/Jun/16 04:19;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/343
;;;","03/Jun/16 04:19;paulk;PR merged;;;",,,,,,,,,,,,,,,,,,,
groovysh classpath switch not working under Windows,GROOVY-7851,12974227,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,deisner,deisner,31/May/16 13:43,04/Jul/22 01:28,14/Jul/23 06:02,04/Jul/22 01:28,2.4.6,2.4.7,,,,,,,,,,,Groovysh,,,,0,windows,,,,,,"I'm trying to set the classpath for a groovysh session with the classpath switch (e.g. ""-cp"" or ""-classpath""). On Linux (and under Cygwin with an sdkman-installed Groovy), it works fine.

But under Windows (both Windows 7 64-bit and Windows 10 64-bit, installed using the Windows installer) I get this error:
{quote}
PS C:\> groovysh -cp .
Unrecognized option: -cp
error: jvm creation failed with code -1: unknown error
PS C:\> groovysh -classpath .
Unrecognized option: -classpath
error: jvm creation failed with code -1: unknown error
{quote}
I'm using the current directory as an example argument, but I get the same error no matter what I try.

In all cases (Linux, Cygwin w/ sdkman, Windows 7 and 10) this is Groovy 2.4.6 with JVM 1.8.0_91). One other thing: the problem occurs whether I'm using PowerShell or cmd.exe.
","Windows 7 64-bit, Windows 10 64-bit",deisner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Jul 04 01:28:04 UTC 2022,,,,,,,,,,"0|i2yqmn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jul/16 13:23;deisner;Workaround: groovysh.bat [-classpath|-cp] <classpath>

;;;","04/Jul/22 01:28;paulk;I think this was fixed a long time ago via other changes. I tried with Groovy 2.4.21 and Groovy 4.0.3:
{noformat}
> groovysh -cp commons-math3-3.6.1.jar
Groovy Shell (2.4.21, JVM: 1.8.0_282)
Type ':help' or ':h' for help.
-----------------------------------------------------------------------------------
groovy:000> import org.apache.commons.math3.fraction.*
===> org.apache.commons.math3.fraction.*
groovy:000> Fraction.FOUR_FIFTHS
===> 4 / 5
groovy:000> _.percentageValue()
===> 80.0
groovy:000> :q
{noformat};;;",,,,,,,,,,,,,,,,,,,,
Incompatible covariant array return type,GROOVY-7849,12973409,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,daniilo,daniilo,27/May/16 12:47,25/Jul/17 07:47,14/Jul/23 06:02,04/Jun/16 04:13,2.4.6,,,,,,,,2.4.8,,,,Compiler,,,,1,,,,,,,"Probably duplicates/is related to GROOVY-7185.

Consider the snippet:
{code}
interface Base {}

interface Derived extends Base {}

interface I {
  Base[] foo()
}

interface I2 extends I {
  Derived[] foo()
}

class C implements I2 {
  Derived[] foo() { null }
}
{code}

Compilation fails with:
{noformat}
The return type of Derived[] foo() in C is incompatible with Base[] in I
{noformat}",,daniilo,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7185,,,,,GROOVY-7721,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jun 04 03:36:55 UTC 2016,,,,,,,,,,"0|i2yll3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Jun/16 14:45;shils;The error occurs without I2 as well e.g. if C implements I instead of I2.;;;","03/Jun/16 05:04;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/346

    GROOVY-7849: Verifier should be aware of array type covariance when c…

    …hecking overriding method return types

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7849

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/346.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #346
    
----
commit 861638e3ee7514fe391d1d4633e11f04caaa7445
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2016-06-02T17:54:13Z

    GROOVY-7849: Verifier should be aware of array type covariance when checking overriding method return types

----
;;;","04/Jun/16 03:36;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/346
;;;",,,,,,,,,,,,,,,,,,,
Closure generic parameters ignored and return types missing from collections methods,GROOVY-7848,12973342,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,berdario,berdario,27/May/16 08:38,23/Jul/20 14:16,14/Jul/23 06:02,18/Jul/20 07:20,,,,,,,,,2.5.13,3.0.5,4.0.0-alpha-1,,,,,,0,,,,,,,"The theme of this ticket is type failures even specifying the correct input parameter type in a Closure, specifically these 2 methods fail to compile with CompileStatic/TypeChecked:

{code}
@CompileStatic
static List foo(){
    [[1,2], [3,4]].collect{List<Integer> pair -> pair[0]+pair[1]}
}

@CompileStatic
static bar(){
    [[1, 3], [1, 2]].transpose().inject(true){acc, List pair -> acc && pair[0] == pair[1]}
}
{code}

The first is due to the generic parameter Integer apparently being ignored.

bq. Error:(15, 48) Groovyc: [Static type checking] - Cannot find matching method java.lang.Object#plus(java.lang.Object). Please check if the declared type is right and if the method exists.

Ignoring it is just fine when compiling in Dynamic mode, but makes it apparently impossible to write a similar Type Safe method

Apparently, this part of the language is as yet undocumented:

http://docs.groovy-lang.org/latest/html/documentation/index.html#generics

The second method instead, has a similar failure to locate Object#getAt(int), but the actual error is this one:

bq. Error:(20, 50) Groovyc: Expected parameter of type java.lang.Object but got java.util.List

Which is imho a bit unhelpful: I'm obviously passing it a List, at runtime... and the the Closure parameter type is List, given that I would expect the error to be the other way around: expected parameter of type List, but got Object

But the problem is not actually with Closure types, inference or the like... I suspect it might simply be an imprecise type specified for transpose() result: it should be List<List>, but is instead List (once I understood this I simply created an intermedia variable with the explicit type as a workaround)",,berdario,emilles,paulk,,,,,,"eric-milles opened a new pull request #1311:
URL: https://github.com/apache/groovy/pull/1311


   https://issues.apache.org/jira/browse/GROOVY-7848
   
       `[[1],[2]]` should infer as `List<List<Integer>>`
       `[1:['a'],2:['b']]` should infer as `Map<Integer,List<String>>`


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;13/Jul/20 14:54;githubbot;600","asfgit closed pull request #1311:
URL: https://github.com/apache/groovy/pull/1311


   


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Jul/20 06:05;githubbot;600","paulk-asert commented on pull request #1311:
URL: https://github.com/apache/groovy/pull/1311#issuecomment-660442083


   Proposed PR merged. Thanks!


----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on to GitHub and use the
URL above to go to the specific comment.

For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;18/Jul/20 07:19;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,1800,,,0,1800,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Jul 18 07:20:01 UTC 2020,,,,,,,,,,"0|i2yl67:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Jul/20 14:46;emilles;{{transpose()}} accepts and returns a plain List, so there is not much hope for type inferencing down the line.

In the collect case, {{[[1,2], [3,4]]}} is inferred as {{List<List>}} and that is why the plus operation gives an error.  Pull request is incomoing.;;;","13/Jul/20 16:06;emilles;You can rewrite the ""bar"" case like this for no STC errors:
{code:groovy}
@groovy.transform.CompileStatic
def bar() {
  List<List<Integer>> pairs = [[1,3], [1,2]].transpose()
  pairs.inject(true) { flag, pair -> flag && pair[0] == pair[1] }
}
{code}
;;;","18/Jul/20 07:20;paulk;Proposed PR merged. Thanks all.;;;",,,,,,,,,,,,,,,,,,,
"A trait that defines a static method that uses generic return types throws ""BUG! Type is null""",GROOVY-7846,12972706,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,graemerocher1,graemerocher1,25/May/16 12:48,12/Jun/16 08:45,14/Jul/23 06:02,31/May/16 04:53,2.4.6,,,,,,,,2.4.7,,,,,,,,0,,,,,,,"If you have a trait that defines a method such as:

{code}
    static <T> T withClient(MyTrait myTrait, @DelegatesTo(MyTrait) Closure<T> callable ) {
        // no-op
    }
{code}

Compilation will fail with:

{code}
BUG! Type is null. Most probably you let a transform reuse existing ClassNodes with generics information, that is now used in a wrong context.
{code}",,githubbot,graemerocher1,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"25/May/16 13:08;graemerocher1;groovy-trait-generics.zip;https://issues.apache.org/jira/secure/attachment/12806124/groovy-trait-generics.zip",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 31 04:53:14 UTC 2016,,,,,,,,,,"0|i2yh8v:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/May/16 12:49;graemerocher1;Attached example reproducing the problem;;;","25/May/16 13:08;graemerocher1;correct example app;;;","25/May/16 13:11;graemerocher1;I narrowed it down to this script

{code}
import org.codehaus.groovy.ast.ClassNode

trait Foo  {
    static <T> T withClient(@DelegatesTo(Foo) Closure<T> callable ) {
        // no-op
    }
}

cls = new GroovyClassLoader().parseClass('''
class Bar implements Foo {}

''')

new ClassNode(cls).methods
{code};;;","25/May/16 20:04;graemerocher1;This is the workaround I have applied in the Grails codebase for now

https://github.com/grails/grails-data-mapping/blob/master/grails-datastore-gorm/src/main/groovy/org/grails/compiler/gorm/GlobalTraitRepairTransformation.groovy#L46;;;","27/May/16 09:28;githubbot;GitHub user graemerocher opened a pull request:

    https://github.com/apache/groovy/pull/340

    Make sure generics are correct for generified return types

    Fixes https://issues.apache.org/jira/browse/GROOVY-7846

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/graemerocher/incubator-groovy Groovy7846

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/340.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #340
    
----
commit d4c9951290f033320f2a1a4f9ed848b57aa345ee
Author: graemerocher <graeme.rocher@gmail.com>
Date:   2016-05-27T09:26:20Z

    Make sure generics are correct for generified return types. Fixes https://issues.apache.org/jira/browse/GROOVY-7846

----
;;;","31/May/16 04:52;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/340
;;;","31/May/16 04:53;paulk;PR merged - thanks!;;;",,,,,,,,,,,,,,,
Trait method calling closure cannot be inherited while using CompileStatic,GROOVY-7843,12971896,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,arnaud.cavailhez@gmail.com,arnaud.cavailhez@gmail.com,22/May/16 19:00,11/Nov/20 02:00,14/Jul/23 06:02,10/Aug/20 13:54,,,,,,,,,3.0.6,4.0.0-alpha-1,,,,,,,0,,,,,,,"A trait extending another and calling itself more than 3 times:

{code}@CompileStatic
trait UpperTrait {
    void call(Closure body){
        body()
    }
}{code}

{code}@CompileStatic
trait LowerTrait extends UpperTrait {

    void threeCalls() {
        call {
            call {
                call {

                }
            }
        }
    }
}{code}

Will generate a `ClassCastException` when called:
{code}class ImplementsTrait implements LowerTrait {
}
new ImplementsTrait().threeCalls()
{code}

raises:

{code}Caught: java.lang.ClassCastException: LowerTrait$Trait$Helper$_threeCalls_closure1 cannot be cast to UpperTrait
java.lang.ClassCastException: LowerTrait$Trait$Helper$_threeCalls_closure1 cannot be cast to UpperTrait
	at LowerTrait$Trait$Helper$_threeCalls_closure1$_closure2.doCall(LowerTrait.groovy:9)
etc..{code}




",,arnaud.cavailhez@gmail.com,emilles,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 08 18:39:06 UTC 2020,,,,,,,,,,"0|i2yc9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Aug/20 18:39;emilles;Fixed by GROOVY-9386;;;",,,,,,,,,,,,,,,,,,,,,
MarkupTemplateEngine totally broken when used with a Security Manager,GROOVY-7842,12971730,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,jwagenleitner,alwaysvip,alwaysvip,21/May/16 04:07,01/Feb/17 23:19,14/Jul/23 06:02,30/Jun/16 16:36,2.4.5,2.4.6,,,,,,,2.4.8,,,,Templating,,,,0,,,,,,,"{code:title=TemplateServlet.java|borderStyle=solid}
TemplateServer.createAndStoreTemplate(String key, InputStream inputStream, File file)
// ...
    Template template = engine.createTemplate(reader);
{code}


{code:title=MarkupTemplateEngine.java|borderStyle=solid}
    public Template createTemplate(final Reader reader) throws CompilationFailedException, ClassNotFoundException, IOException {
        return new MarkupTemplateMaker(reader, null, null);
    }
{code}

Calls MarkupTemplateEngine.MarkupTemplateMaker

{code:title=MarkupTemplateEngine.java|borderStyle=solid}
        public MarkupTemplateMaker(final Reader reader, String sourceName, Map<String, String> modelTypes) {
            String name = sourceName != null ? sourceName : ""GeneratedMarkupTemplate"" + counter.getAndIncrement();
            templateClass = groovyClassLoader.parseClass(new GroovyCodeSource(reader, name, """"), modelTypes);
            this.modeltypes = modelTypes;
        }
{code}

Note: GroovyCodeSource(reader, name, """")

{code:title=GroovyCodeSource.java|borderStyle=solid}
    public GroovyCodeSource(Reader reader, String name, String codeBase) {
        this.name = name;
        this.codeSource = createCodeSource(codeBase);
{code}

Note: createCodeSource(codeBase); -> createCodeSource("""");

{code:title=GroovyCodeSource.java|borderStyle=solid}
    private static CodeSource createCodeSource(final String codeBase) {
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(new GroovyCodeSourcePermission(codeBase));
        }
{code}

Note: GroovyCodeSourcePermission(codeBase) -> GroovyCodeSourcePermission("""")

{code:title=GroovyCodeSourcePermission.java|borderStyle=solid}
public final class GroovyCodeSourcePermission extends BasicPermission {

    public GroovyCodeSourcePermission(String name) {
        super(name);
    }

    public BasicPermission(String name)
    {
        super(name);
        init(name);
    }

    /**
     * initialize a BasicPermission object. Common to all constructors.
     *
     */
    private void init(String name)
    {
        if (name == null)
            throw new NullPointerException(""name can't be null"");

        int len = name.length();

        if (len == 0) {
            throw new IllegalArgumentException(""name can't be empty"");
        }
{code}
BOOM -> IllegalArgumentException

In summary: MarkupTemplateMaker creates a GroovyCodeSource where codeBase is equal to """".  BasicPermission does not allow names to have zero length thus causing an exception.


",,alwaysvip,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Important,,,,,,,,9223372036854775807,,,Thu Jun 30 16:36:55 UTC 2016,,,,,,,,,,"0|i2yb8n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"29/Jun/16 00:57;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/358

    GROOVY-7842 - MarkupTemplateEngine Totally Broken

    When running under a Security Manager an exception would be thrown because
    the empty codebase value was added as a Permission name which can not be
    empty.  So use the same codebase value that is used by GStringTemplateEngine
    and StreamingTemplateEngine for unnamed code sources.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7842

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/358.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #358
    
----
commit 111206ae879469ac2864941508c85dd9edb2e470
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-06-29T00:50:40Z

    GROOVY-7842 - MarkupTemplateEngine Totally Broken
    
    When running under a Security Manager an exception would be thrown because
    the empty codebase value was added as a Permission name which can not be
    empty.  So use the same codebase value that is used by GStringTemplateEngine
    and StreamingTemplateEngine for unnamed code sources.

----
;;;","30/Jun/16 16:33;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/358
;;;","30/Jun/16 16:36;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,
Assert fails when accessing particular primitive values with @CompileStatic,GROOVY-7841,12971634,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,pablo72,pablo72,20/May/16 19:30,12/Jun/16 08:45,14/Jul/23 06:02,25/May/16 10:45,2.4.5,,,,,,,,2.4.7,,,,,,,,0,,,,,,,"The following assert for a non-zero long value fails when annotated with CompileStatic. For example:

{code}
def foo() {
  long value = 17179869184 
  assert value, ""Foo is OK""
}

@groovy.transform.CompileStatic
def bar() {
  long value = 17179869184 
  assert value, ""Bar failed""
}

foo()
bar()


java.lang.AssertionError: Bar failed. Expression: value. Values: value = 17179869184
	at ConsoleScript31.bar(ConsoleScript31:10)
	at ConsoleScript31.run(ConsoleScript31:14)

{code}",,blackdrag,githubbot,pablo72,paulk,sbalachandran,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 25 12:17:09 UTC 2016,,,,,,,,,,"0|i2yanb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"23/May/16 18:46;sbalachandran;This seems to happen only with that specific number (17179869184). It is working fine for other values that I checked randomly. That specific number exactly is 16 GB (16 * 1024 * 1024* 1024). I am not sure why it fails exactly for that.;;;","24/May/16 02:54;paulk;Any multiple of 4294967296 will have the same result. Looking at the bytecode, there is an L2I inserted for the @CompileStatic case which just keeps the lowest 32 bits. Workaround is to use the longhand equivalent {{assert value != 0}}.

My suspicion is we are applying this optimization a bit too aggressively:
https://github.com/apache/groovy/blob/master/src/main/org/codehaus/groovy/transform/sc/transformers/BooleanExpressionTransformer.java#L137;;;","24/May/16 04:27;blackdrag;The usages of F2I and D2I look wrong too.;;;","24/May/16 10:58;paulk;Indeed, both {{assert 0.1f}} and {{assert 0.1d}} also fail (within @CompileStatic) but should succeed.;;;","24/May/16 11:53;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/338

    GROOVY-7841: Assert fails when accessing particular primitive values …

    …with @CompileStatic

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7841

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/338.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #338
    
----
commit c7d106315226667248dca01af793bb24b96d8d97
Author: paulk <paulk@asert.com.au>
Date:   2016-05-24T11:52:12Z

    GROOVY-7841: Assert fails when accessing particular primitive values with @CompileStatic

----
;;;","24/May/16 23:05;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/338#discussion_r64490605
  
    --- Diff: src/main/org/codehaus/groovy/transform/sc/transformers/BooleanExpressionTransformer.java ---
    @@ -134,15 +134,19 @@ public void visit(final GroovyCodeVisitor visitor) {
                                 // int on stack
                             } else if (top.equals(ClassHelper.long_TYPE)) {
                                 MethodVisitor mv = controller.getMethodVisitor();
    -                            mv.visitInsn(L2I);
    +                            mv.visitInsn(LCONST_0);
    +                            mv.visitInsn(LCMP);
                                 controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
                             } else if (top.equals(ClassHelper.float_TYPE)) {
                                 MethodVisitor mv = controller.getMethodVisitor();
    -                            mv.visitInsn(F2I);
    +                            mv.visitInsn(F2D);
    --- End diff --
    
    Why not use a compare float operation here?
;;;","25/May/16 10:22;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/338#discussion_r64549052
  
    --- Diff: src/main/org/codehaus/groovy/transform/sc/transformers/BooleanExpressionTransformer.java ---
    @@ -134,15 +134,19 @@ public void visit(final GroovyCodeVisitor visitor) {
                                 // int on stack
                             } else if (top.equals(ClassHelper.long_TYPE)) {
                                 MethodVisitor mv = controller.getMethodVisitor();
    -                            mv.visitInsn(L2I);
    +                            mv.visitInsn(LCONST_0);
    +                            mv.visitInsn(LCMP);
                                 controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
                             } else if (top.equals(ClassHelper.float_TYPE)) {
                                 MethodVisitor mv = controller.getMethodVisitor();
    -                            mv.visitInsn(F2I);
    +                            mv.visitInsn(F2D);
    --- End diff --
    
    We probably could. In general, comparisons with floats are notoriously ugly, e.g. see:
    https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
    But given we are comparing against 0.0, it is probably an edge case that isn't as bad as the general case (but see 'Infernal zero' in the aforementioned link). A general recommendation is to use doubles instead of floats but I don't really know for sure whether it does in this case. My rationale was to look at what bytecode was produced from `assert floatValue != 0.0f` and then replicating that - which is where the `F2D` and `DCMPG` came from.
;;;","25/May/16 10:44;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/groovy/pull/338
;;;","25/May/16 10:45;paulk;PR merged;;;","25/May/16 12:17;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/338#discussion_r64561363
  
    --- Diff: src/main/org/codehaus/groovy/transform/sc/transformers/BooleanExpressionTransformer.java ---
    @@ -134,15 +134,19 @@ public void visit(final GroovyCodeVisitor visitor) {
                                 // int on stack
                             } else if (top.equals(ClassHelper.long_TYPE)) {
                                 MethodVisitor mv = controller.getMethodVisitor();
    -                            mv.visitInsn(L2I);
    +                            mv.visitInsn(LCONST_0);
    +                            mv.visitInsn(LCMP);
                                 controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
                             } else if (top.equals(ClassHelper.float_TYPE)) {
                                 MethodVisitor mv = controller.getMethodVisitor();
    -                            mv.visitInsn(F2I);
    +                            mv.visitInsn(F2D);
    --- End diff --
    
    Thanks for the explanation.
;;;",,,,,,,,,,,,
Verifier#makeDescriptorWithoutReturnType uses ClassNode#toString with generics,GROOVY-7840,12971518,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,blackdrag,blackdrag,20/May/16 12:56,12/Jun/17 00:12,14/Jul/23 06:02,17/May/17 01:37,,,,,,,,,2.5.0-beta-1,,,,,,,,0,easyfix,,,,,,"As noted in GROOVY-7826, commit [74089c1|https://github.com/apache/groovy/commit/74089c1156d6c296d64e68e766575e86c4119c67] contains the addition of Verifier#makeDescriptorWithoutReturnType. The method is based on ClassNode#toString, which will include redirects and their generics information. This should not be the case
",,blackdrag,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed May 17 01:37:47 UTC 2017,,,,,,,,,,"0|i2y9xj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/May/17 09:08;paulk;Jochen, just to clarify. For this method:
{code}
def bar(List<String> someList, Date someDate) { ... }
{code}
We might expect the following output:
{noformat}
java.lang.Object bar(List, Date) // getTypeDescriptor
bar:List <String>,Date, // current output of GeneralUtils.makeDescriptorWithoutReturnType
bar:List,Date, // desired output
{noformat}
Note: exact output varies depending on which phase of compilation you are at when displaying above, e.g. whether you get fully qualified names or not.;;;","03/May/17 09:14;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/533

    GROOVY-7840: Verifier#makeDescriptorWithoutReturnType uses ClassNode#…

    …toString with generics

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7840

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/533.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #533
    
----
commit 8fc3816afaa475fa5ef3ad57a391dc08ef587274
Author: paulk <paulk@asert.com.au>
Date:   2017-05-03T09:12:31Z

    GROOVY-7840: Verifier#makeDescriptorWithoutReturnType uses ClassNode#toString with generics

----
;;;","13/May/17 18:41;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/533#discussion_r116363829
  
    --- Diff: src/main/org/apache/groovy/ast/tools/MethodNodeUtils.java ---
    @@ -0,0 +1,66 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.apache.groovy.ast.tools;
    +
    +import org.codehaus.groovy.ast.MethodNode;
    +import org.codehaus.groovy.ast.Parameter;
    +
    +public class MethodNodeUtils {
    +    /**
    +     * Return the method node's descriptor including its
    +     * name and parameter types without generics.
    +     *
    +     * @param mNode the method node
    +     * @return the method node's abbreviated descriptor excluding the return type
    +     */
    +    public static String methodDescriptorWithoutReturnType(MethodNode mNode) {
    +        StringBuilder sb = new StringBuilder();
    +        mNode.getTypeDescriptor();
    +        sb.append(mNode.getName()).append(':');
    +        for (Parameter p : mNode.getParameters()) {
    +            sb.append(ClassNodeUtils.formatTypeName(p.getType())).append(',');
    +        }
    +        return sb.toString();
    +    }
    +
    +    /**
    +     * Return the method node's descriptor which includes its return type,
    +     * name and parameter types without generics.
    +     *
    +     * @param mNode the method node
    +     * @return the method node's descriptor
    +     */
    +    public static String methodDescriptor(MethodNode mNode) {
    --- End diff --
    
    This could be the body of `MethodNode#getTypeDescriptor` instance method.
;;;","13/May/17 18:41;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/533#discussion_r116363767
  
    --- Diff: src/main/org/apache/groovy/ast/tools/ClassNodeUtils.java ---
    @@ -0,0 +1,48 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.apache.groovy.ast.tools;
    +
    +import org.codehaus.groovy.ast.ClassNode;
    +
    +public class ClassNodeUtils {
    +    /**
    +     * Formats a type name into a human readable version. For arrays, appends ""[]"" to the formatted
    +     * type name of the component. For unit class nodes, uses the class node name.
    +     *
    +     * @param cNode the type to format
    +     * @return a human readable version of the type name (java.lang.String[] for example)
    +     */
    +    public static String formatTypeName(ClassNode cNode) {
    --- End diff --
    
    This seems like a candidate to be a package-private instance method on `ClassNode`.  Package-private part assumes the moving of the `MethodNodeUtils` methods into `MethodNode`.
;;;","13/May/17 18:41;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/533#discussion_r116363909
  
    --- Diff: src/main/org/apache/groovy/ast/tools/MethodNodeUtils.java ---
    @@ -0,0 +1,66 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.apache.groovy.ast.tools;
    +
    +import org.codehaus.groovy.ast.MethodNode;
    +import org.codehaus.groovy.ast.Parameter;
    +
    +public class MethodNodeUtils {
    +    /**
    +     * Return the method node's descriptor including its
    +     * name and parameter types without generics.
    +     *
    +     * @param mNode the method node
    +     * @return the method node's abbreviated descriptor excluding the return type
    +     */
    +    public static String methodDescriptorWithoutReturnType(MethodNode mNode) {
    --- End diff --
    
    This seems like it could be an instance method such as `MethodNode#getSignature()` ([JLS 8.4.2](http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.2)) or `MethodNode#getTypeDescriptorWithoutReturnType()`.
;;;","15/May/17 10:49;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/533#discussion_r116460943
  
    --- Diff: src/main/org/apache/groovy/ast/tools/MethodNodeUtils.java ---
    @@ -0,0 +1,66 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.apache.groovy.ast.tools;
    +
    +import org.codehaus.groovy.ast.MethodNode;
    +import org.codehaus.groovy.ast.Parameter;
    +
    +public class MethodNodeUtils {
    +    /**
    +     * Return the method node's descriptor including its
    +     * name and parameter types without generics.
    +     *
    +     * @param mNode the method node
    +     * @return the method node's abbreviated descriptor excluding the return type
    +     */
    +    public static String methodDescriptorWithoutReturnType(MethodNode mNode) {
    --- End diff --
    
    I kept it distinct because I wasn't really sure that we should tie the particular formatting we have chosen to the more general method that some might expect to find in MethodNode. If you look at:
    org.objectweb.asm.Type#getMethodDescriptor(java.lang.reflect.Method)
    It would produce different output.
    
    For example, for this method:
    `int[] method(List arg1, String arg2)`
    ASM would produce the familiar:
    `(Ljava/util/List;Ljava/lang/String;)[I`
    whereas we produce:
    `[I method(java.util.List, java.lang.String)`
    What we produce is suitable for our purposes (and we need the name) but I wonder what people would expect in MethodNode.

;;;","15/May/17 10:50;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/533#discussion_r116460996
  
    --- Diff: src/main/org/apache/groovy/ast/tools/MethodNodeUtils.java ---
    @@ -0,0 +1,66 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.apache.groovy.ast.tools;
    +
    +import org.codehaus.groovy.ast.MethodNode;
    +import org.codehaus.groovy.ast.Parameter;
    +
    +public class MethodNodeUtils {
    +    /**
    +     * Return the method node's descriptor including its
    +     * name and parameter types without generics.
    +     *
    +     * @param mNode the method node
    +     * @return the method node's abbreviated descriptor excluding the return type
    +     */
    +    public static String methodDescriptorWithoutReturnType(MethodNode mNode) {
    +        StringBuilder sb = new StringBuilder();
    +        mNode.getTypeDescriptor();
    +        sb.append(mNode.getName()).append(':');
    +        for (Parameter p : mNode.getParameters()) {
    +            sb.append(ClassNodeUtils.formatTypeName(p.getType())).append(',');
    +        }
    +        return sb.toString();
    +    }
    +
    +    /**
    +     * Return the method node's descriptor which includes its return type,
    +     * name and parameter types without generics.
    +     *
    +     * @param mNode the method node
    +     * @return the method node's descriptor
    +     */
    +    public static String methodDescriptor(MethodNode mNode) {
    --- End diff --
    
    See above.
;;;","15/May/17 16:10;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/533#discussion_r116533820
  
    --- Diff: src/main/org/apache/groovy/ast/tools/MethodNodeUtils.java ---
    @@ -0,0 +1,66 @@
    +/*
    + *  Licensed to the Apache Software Foundation (ASF) under one
    + *  or more contributor license agreements.  See the NOTICE file
    + *  distributed with this work for additional information
    + *  regarding copyright ownership.  The ASF licenses this file
    + *  to you under the Apache License, Version 2.0 (the
    + *  ""License""); you may not use this file except in compliance
    + *  with the License.  You may obtain a copy of the License at
    + *
    + *    http://www.apache.org/licenses/LICENSE-2.0
    + *
    + *  Unless required by applicable law or agreed to in writing,
    + *  software distributed under the License is distributed on an
    + *  ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    + *  KIND, either express or implied.  See the License for the
    + *  specific language governing permissions and limitations
    + *  under the License.
    + */
    +package org.apache.groovy.ast.tools;
    +
    +import org.codehaus.groovy.ast.MethodNode;
    +import org.codehaus.groovy.ast.Parameter;
    +
    +public class MethodNodeUtils {
    +    /**
    +     * Return the method node's descriptor including its
    +     * name and parameter types without generics.
    +     *
    +     * @param mNode the method node
    +     * @return the method node's abbreviated descriptor excluding the return type
    +     */
    +    public static String methodDescriptorWithoutReturnType(MethodNode mNode) {
    --- End diff --
    
    That is what is sort of confusing, the method descriptor for bytecode vs the method signature used to detect duplicate signatures.  Agree that the formatting is particular to it's use in the `Verifier` and having in a separate utils class is probably the best approach.
;;;","17/May/17 01:34;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/533
;;;","17/May/17 01:37;paulk;Proposed PR merged;;;",,,,,,,,,,,,
TupleConstructor should provide pre and post annotation attributes like MapConstructor,GROOVY-7837,12967381,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,paulk,11/May/16 12:02,02/May/17 02:03,14/Jul/23 06:02,20/May/16 10:30,,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,,,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 20 10:30:34 UTC 2016,,,,,,,,,,"0|i2xkgn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/May/16 12:07;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/332

    GROOVY-7837: TupleConstructor should provide pre and post annotation …

    …attributes like MapConstructor

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7837

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/332.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #332
    
----
commit 3fd2d9d55d4c0c7944f7b57ca5d73f280e4af56c
Author: paulk <paulk@asert.com.au>
Date:   2016-05-11T12:04:45Z

    GROOVY-7837: TupleConstructor should provide pre and post annotation attributes like MapConstructor

----
;;;","20/May/16 10:30;paulk;PR merged;;;","20/May/16 10:30;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/groovy/pull/332
;;;",,,,,,,,,,,,,,,,,,,
CompileStatic + static inner class + EqualsAndHashCode gives VerifyError in equals,GROOVY-7836,12967177,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,gillius,gillius,10/May/16 19:48,02/Nov/16 00:15,14/Jul/23 06:02,26/Aug/16 02:10,2.4.6,,,,,,,,2.4.7,,,,Static compilation,,,,0,,,,,,,"{code}
import groovy.transform.CompileStatic
import groovy.transform.EqualsAndHashCode

@CompileStatic
class Parent {
    List<Integer> getInts() { [0] }

    @EqualsAndHashCode
    static class Child {
        List<Integer> ints
    }
}

println GroovySystem.version
println new Parent.Child()
{code}

The key is the inner class having a property matching the parent's.

Result:

{code}
2.4.6
java.lang.VerifyError: (class: Parent$Child, method: equals signature: (Ljava/lang/Object;)Z) Incompatible object argument for function call
{code}

Inspecting the bytecode, I see the following:

{code}
   L13
    ALOAD 0
    INVOKEVIRTUAL Parent.getInts ()Ljava/util/List;
    ALOAD 2
    INVOKEVIRTUAL Parent$Child.getInts ()Ljava/util/List;
    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.compareEqual (Ljava/lang/Object;Ljava/lang/Object;)Z
    IFNE L14
    ICONST_1
{code}

It appears that the bytecode is attempting to call a method on the outer class, even though the inner class is static and there is no reason to access the outer class.",,gillius,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Aug 26 15:33:40 UTC 2016,,,,,,,,,,"0|i2xj7j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"11/May/16 02:09;paulk;Just confirming that I get the error (@CompileStatic is required to get the error) on 2.4.6 and the 2_4_X branch but not on master. I'll investigate some more when I get a chance. I haven't done a git bisect as yet.

Bytecode corresponding to that shown above but as per master:
{code}
   L13
    LDC LParent$Child;.class
    ALOAD 0
    LDC ""getInts""
    CHECKCAST java/lang/String
    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.invokeMethodOnCurrent0 (Ljava/lang/Class;Lgroovy/lang/GroovyObject;Ljava/lang/String;)Ljava/lang/Object;
    ALOAD 2
    INVOKEVIRTUAL Parent$Child.getInts ()Ljava/util/List;
    INVOKESTATIC org/codehaus/groovy/runtime/ScriptBytecodeAdapter.compareEqual (Ljava/lang/Object;Ljava/lang/Object;)Z
    IFNE L14
    ICONST_1
{code};;;","14/May/16 21:33;gillius;if I read that right, the master branch is making a dynamic call to getInts followed by a static call to getInts, so it's still trying to call the method twice. I'm also confused as to why it's invoking compareEqual when it's just a getter. ;;;","14/May/16 21:35;gillius;Sorry, I look silly for just making that comment it's in the generated equals method so of course it's calling compareEqual. But it still seems odd with compile static that the first call is ""dynamic"";;;","26/Aug/16 02:10;jwagenleitner;I checked and this was fixed in commit https://github.com/apache/groovy/commit/e4ea67c38e695fc78b4c60411322d72da2467bd0 as part of GROOVY-7813 and I verified the test code runs in 2.4.7.  It looked like the tests in that commit cover this issue, so am resolving this.

Thanks for reporting the issue.;;;","26/Aug/16 15:33;gillius;Thanks, I can confirm this was fixed in 2.4.7;;;",,,,,,,,,,,,,,,,,
Calling hashCode on IntRange iterates through all elements in the range.,GROOVY-7834,12965860,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,jlntlanyl,jlntlanyl,07/May/16 23:58,01/Feb/17 23:19,14/Jul/23 06:02,23/Aug/16 03:01,,,,,,,,,2.4.8,,,,,,,,0,,,,,,,"{code}
new IntRange(0, Integer.MAX_VALUE-1).hashCode()
{code}
The above code takes a few seconds to complete.
I believe the hashCode method is not overridden and it defaults to AbstractList which iterates through all elements.  I don't think this should be the default behavior.

http://grepcode.com/file_/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/AbstractList.java/?v=source",,blackdrag,githubbot,jlntlanyl,jwagenleitner,upadhyayap,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 23 03:01:01 UTC 2016,,,,,,,,,,"0|i2xb5b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"18/Aug/16 11:19;githubbot;GitHub user upadhyayap opened a pull request:

    https://github.com/apache/groovy/pull/386

    Calculating hashCode of IntRange by pairing function

    https://issues.apache.org/jira/browse/GROOVY-7834?jql=status%20%3D%20Open%20AND%20project%20%3D%20Groovy%20AND%20type%20%3D%20Bug%20ORDER%20BY%20created%20DESC

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/upadhyayap/incubator-groovy GROOVY-7834

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/386.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #386
    
----
commit 256a9f462b066cd4a2dfc124c0fb6c5b4edfccd8
Author: Anand upadhyay <anand.upadhyay.consultant@nielsen.com>
Date:   2016-08-18T11:09:00Z

    Calculating hashCode of IntRange by pairing function

----
;;;","19/Aug/16 06:08;upadhyayap;I am taking only lower and upper bound to generate hash code. Pairing function grantees the output no to be deterministic. Have look at the pull request and let me know;;;","19/Aug/16 07:10;blackdrag;which means to ranges with different steppings have the same hashcode... probably no problem;;;","19/Aug/16 10:46;githubbot;Github user upadhyayap closed the pull request at:

    https://github.com/apache/groovy/pull/386
;;;","19/Aug/16 11:10;githubbot;GitHub user upadhyayap opened a pull request:

    https://github.com/apache/groovy/pull/387

    Calculating IntRange hashcode by pairing function

    https://issues.apache.org/jira/browse/GROOVY-7834?jql=project%20%3D%20GROOVY%20AND%20id%20%3D%20GROOVY-7834

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/upadhyayap/incubator-groovy GROOVY-7834

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/387.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #387
    
----
commit ddc925a2d80e0a05c6332aaaa87497ff1c86678b
Author: Anand upadhyay <anand.upadhyay.consultant@nielsen.com>
Date:   2016-08-19T11:03:30Z

    Calculating IntRange hashcode by pairing function

----
;;;","19/Aug/16 11:41;githubbot;Github user upadhyayap closed the pull request at:

    https://github.com/apache/groovy/pull/387
;;;","19/Aug/16 11:45;githubbot;GitHub user upadhyayap opened a pull request:

    https://github.com/apache/groovy/pull/388

    Calculating hashcode of IntRange by pairing function

    https://issues.apache.org/jira/browse/GROOVY-7834?jql=project%20%3D%20GROOVY%20AND%20id%20%3D%20GROOVY-7834

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/upadhyayap/incubator-groovy GROOVY-7834

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/388.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #388
    
----
commit da39cc1fda39f61424471cff23df3f13867ab9d3
Author: Anand upadhyay <anand.upadhyay.consultant@nielsen.com>
Date:   2016-08-19T11:43:08Z

    Calculating hashcode of IntRange by pairing function

----
;;;","23/Aug/16 02:16;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/388
;;;","23/Aug/16 03:01;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,
exception in phase 'conversion' if META-INF files contain comment headers,GROOVY-7833,12965799,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,magnus.reftel,magnus.reftel,07/May/16 04:43,26/Jun/16 10:44,14/Jul/23 06:02,03/Jun/16 04:59,2.4.6,,,,,,,,2.4.7,,,,Grape,,,,0,,,,,,,"The following script makes Grovy 2.4.6 exit with the message ""Caught: BUG! exception in phase 'conversion' in source unit /path-to-code/conversion.groovy' # Licensed to the Apache Software Foundation (ASF) under one or more"":

     @GrabResolver(name='jenkins', root='http://repo.jenkins-ci.org/releases')
    @Grapes([
    @Grab(group='com.google.inject', module='guice', version='4.0-beta'),
    @Grab(group='org.springframework', module='spring-beans', version='3.0.5.RELEASE'),
    @Grab(group='org.jenkins-ci.main', module='jenkins-core', version='2.1')
    ])
    
    import java.lang.String

The stack trace prints when run with --debug is:

BUG! exception in phase 'conversion' in source unit '/path-to-code/conversion.groovy' # Licensed to the Apache Software Foundation (ASF) under one or more
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:935)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:593)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
	at groovy.lang.GroovyClassLoader.doParseClass(GroovyClassLoader.java:298)
	at groovy.lang.GroovyClassLoader.parseClass(GroovyClassLoader.java:268)
	at groovy.lang.GroovyShell.parseClass(GroovyShell.java:688)
	at groovy.lang.GroovyShell.run(GroovyShell.java:517)
	at groovy.lang.GroovyShell.run(GroovyShell.java:507)
	at groovy.ui.GroovyMain.processOnce(GroovyMain.java:652)
	at groovy.ui.GroovyMain.run(GroovyMain.java:384)
	at groovy.ui.GroovyMain.process(GroovyMain.java:370)
	at groovy.ui.GroovyMain.processArgs(GroovyMain.java:129)
	at groovy.ui.GroovyMain.main(GroovyMain.java:109)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:109)
	at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:131)
Caused by: java.lang.ClassNotFoundException: # Licensed to the Apache Software Foundation (ASF) under one or more
	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:677)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:787)
	at groovy.lang.GroovyClassLoader.loadClass(GroovyClassLoader.java:775)
	at groovy.lang.GroovyClassLoader$loadClass$0.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at groovy.grape.GrapeIvy$_processRunners_closure4.doCall(GrapeIvy.groovy:341)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at org.codehaus.groovy.runtime.metaclass.ClosureMetaClass.invokeMethod(ClosureMetaClass.java:294)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1021)
	at groovy.lang.Closure.call(Closure.java:426)
	at groovy.lang.Closure.call(Closure.java:442)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:2030)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:2015)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.each(DefaultGroovyMethods.java:2056)
	at org.codehaus.groovy.runtime.dgm$162.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:274)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:56)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)
	at groovy.grape.GrapeIvy.processRunners(GrapeIvy.groovy:340)
	at groovy.grape.GrapeIvy$processRunners$3.callCurrent(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:182)
	at groovy.grape.GrapeIvy.processOtherServices(GrapeIvy.groovy:325)
	at groovy.grape.GrapeIvy$processOtherServices$2.callCurrent(Unknown Source)
	at groovy.grape.GrapeIvy.grab(GrapeIvy.groovy:266)
	at groovy.grape.Grape.grab(Grape.java:167)
	at groovy.grape.GrabAnnotationTransformation.visit(GrabAnnotationTransformation.java:378)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$3.call(ASTTransformationVisitor.java:321)
	at org.codehaus.groovy.control.CompilationUnit.applyToSourceUnits(CompilationUnit.java:931)
	... 19 more
",Mac OS X 10.11.4 (15E65),githubbot,magnus.reftel,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7613,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Jun 03 04:59:36 UTC 2016,,,,,,,,,,"0|i2xarr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"07/May/16 08:44;githubbot;GitHub user blackdrag opened a pull request:

    https://github.com/apache/groovy/pull/329

    GROOVY-7833: let grape ignore runner lines with hash to enable comments.

    When getting a groovy jar via grab, there will be a TestNG runner configuration in the jar. This configuration contains the Apache License 2 text, as required by the foundation. The code expected the class only. With this change the comments will be ignored.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/blackdrag/groovy patch-1

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/329.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #329
    
----
commit faf48c4d89fb0c7999a7d1134f1d09b8eb815d81
Author: Jochen Theodorou <blackdrag@gmx.org>
Date:   2016-05-07T08:44:22Z

    GROOVY-7833: let grape ignore runner lines with hash to enable comments.
    
    When getting a groovy jar via grab, there will be a TestNG runner configuration in the jar. This configuration contains the Apache License 2 text, as required by the foundation. The code expected the class only. With this change the comments will be ignored.

----
;;;","03/Jun/16 04:58;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/329
;;;","03/Jun/16 04:59;paulk;PR merged (with empty line tweak);;;",,,,,,,,,,,,,,,,,,,
NullPointerException in GroovyConsole with an input method,GROOVY-7832,12964524,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,blackdrag,Muneyuki Noguchi,Muneyuki Noguchi,03/May/16 04:43,12/Jun/16 08:45,14/Jul/23 06:02,20/May/16 19:34,2.4.6,,,,,,,,2.4.7,,,,Groovy Console,,,,0,,,,,,,"When an input method is enabled and focus is set to a Groovy Console window, the Groovy Console sometimes throws NullPointerException.

Here is a message from the Groovy Console:
{code}
Exception in thread ""AWT-EventQueue-0"" 
java.lang.NullPointerException
	at groovy.ui.text.StructuredSyntaxDocumentFilter.replaceMetaCharacters(StructuredSyntaxDocumentFilter.java:285)
	at groovy.ui.text.StructuredSyntaxDocumentFilter.replace(StructuredSyntaxDocumentFilter.java:274)
	at javax.swing.text.AbstractDocument.replace(AbstractDocument.java:662)
	at javax.swing.JTextPane.replaceSelection(JTextPane.java:192)
	at javax.swing.JTextPane.replaceSelection(JTextPane.java:175)
	at groovy.ui.text.TextEditor.replaceSelection(TextEditor.java:367)
	at javax.swing.text.JTextComponent.replaceInputMethodText(JTextComponent.java:4767)
	at javax.swing.text.JTextComponent.processInputMethodEvent(JTextComponent.java:4506)
	at java.awt.Component.processEvent(Component.java:6298)
	at java.awt.Container.processEvent(Container.java:2229)
	at java.awt.Component.dispatchEventImpl(Component.java:4872)
	at java.awt.Container.dispatchEventImpl(Container.java:2287)
	at java.awt.Component.dispatchEvent(Component.java:4698)
	at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:735)
	at java.awt.EventQueue.access$200(EventQueue.java:103)
	at java.awt.EventQueue$3.run(EventQueue.java:694)
	at java.awt.EventQueue$3.run(EventQueue.java:692)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:87)
	at java.awt.EventQueue$4.run(EventQueue.java:708)
	at java.awt.EventQueue$4.run(EventQueue.java:706)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:705)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:242)
	at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:161)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:150)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:146)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:138)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:91)
java.lang.reflect.InvocationTargetException
	at sun.lwawt.macosx.LWCToolkit.invokeAndWait(LWCToolkit.java:572)
	at sun.lwawt.macosx.CInputMethod.attributedSubstringFromRange(CInputMethod.java:586)
Caused by: java.lang.IllegalArgumentException: Invalid substring range
	at java.text.AttributedString$AttributedStringIterator.<init>(AttributedString.java:756)
	at java.text.AttributedString.getIterator(AttributedString.java:583)
	at sun.lwawt.macosx.CInputMethod$3.run(CInputMethod.java:605)
	at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:302)
	at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:733)
	at java.awt.EventQueue.access$200(EventQueue.java:103)
	at java.awt.EventQueue$3.run(EventQueue.java:694)
	at java.awt.EventQueue$3.run(EventQueue.java:692)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:87)
	at java.awt.EventQueue$4.run(EventQueue.java:708)
	at java.awt.EventQueue$4.run(EventQueue.java:706)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:705)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:242)
	at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:161)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:150)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:146)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:138)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:91)
Exception in thread ""AWT-EventQueue-0"" 
java.lang.NullPointerException
	at groovy.ui.text.StructuredSyntaxDocumentFilter.replaceMetaCharacters(StructuredSyntaxDocumentFilter.java:285)
	at groovy.ui.text.StructuredSyntaxDocumentFilter.replace(StructuredSyntaxDocumentFilter.java:274)
	at javax.swing.text.AbstractDocument.replace(AbstractDocument.java:662)
	at javax.swing.JTextPane.replaceSelection(JTextPane.java:192)
	at javax.swing.JTextPane.replaceSelection(JTextPane.java:175)
	at groovy.ui.text.TextEditor.replaceSelection(TextEditor.java:367)
	at javax.swing.text.JTextComponent.replaceInputMethodText(JTextComponent.java:4767)
	at javax.swing.text.JTextComponent.processInputMethodEvent(JTextComponent.java:4506)
	at java.awt.Component.processEvent(Component.java:6298)
	at java.awt.Container.processEvent(Container.java:2229)
	at java.awt.Component.dispatchEventImpl(Component.java:4872)
	at java.awt.Container.dispatchEventImpl(Container.java:2287)
	at java.awt.Component.dispatchEvent(Component.java:4698)
	at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:735)
	at java.awt.EventQueue.access$200(EventQueue.java:103)
	at java.awt.EventQueue$3.run(EventQueue.java:694)
	at java.awt.EventQueue$3.run(EventQueue.java:692)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:87)
	at java.awt.EventQueue$4.run(EventQueue.java:708)
	at java.awt.EventQueue$4.run(EventQueue.java:706)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:705)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:242)
	at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:161)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:150)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:146)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:138)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:91)
Exception in thread ""AWT-EventQueue-0"" 
java.lang.NullPointerException
	at groovy.ui.text.StructuredSyntaxDocumentFilter.replaceMetaCharacters(StructuredSyntaxDocumentFilter.java:285)
	at groovy.ui.text.StructuredSyntaxDocumentFilter.replace(StructuredSyntaxDocumentFilter.java:274)
	at javax.swing.text.AbstractDocument.replace(AbstractDocument.java:662)
	at javax.swing.JTextPane.replaceSelection(JTextPane.java:192)
	at javax.swing.JTextPane.replaceSelection(JTextPane.java:175)
	at groovy.ui.text.TextEditor.replaceSelection(TextEditor.java:367)
	at javax.swing.text.JTextComponent.replaceInputMethodText(JTextComponent.java:4767)
	at javax.swing.text.JTextComponent.processInputMethodEvent(JTextComponent.java:4506)
	at java.awt.Component.processEvent(Component.java:6298)
	at java.awt.Container.processEvent(Container.java:2229)
	at java.awt.Component.dispatchEventImpl(Component.java:4872)
	at java.awt.Container.dispatchEventImpl(Container.java:2287)
	at java.awt.Component.dispatchEvent(Component.java:4698)
	at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:735)
	at java.awt.EventQueue.access$200(EventQueue.java:103)
	at java.awt.EventQueue$3.run(EventQueue.java:694)
	at java.awt.EventQueue$3.run(EventQueue.java:692)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:87)
	at java.awt.EventQueue$4.run(EventQueue.java:708)
	at java.awt.EventQueue$4.run(EventQueue.java:706)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:705)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:242)
	at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:161)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:150)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:146)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:138)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:91)
java.lang.reflect.InvocationTargetException
	at sun.lwawt.macosx.LWCToolkit.invokeAndWait(LWCToolkit.java:572)
	at sun.lwawt.macosx.CInputMethod.characterIndexForPoint(CInputMethod.java:757)
Caused by: java.lang.NullPointerException
	at javax.swing.text.JTextComponent$InputMethodRequestsHandler.getLocationOffset(JTextComponent.java:4651)
	at sun.awt.im.InputMethodContext.getLocationOffset(InputMethodContext.java:286)
	at sun.lwawt.macosx.CInputMethod$7.run(CInputMethod.java:759)
	at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:302)
	at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:733)
	at java.awt.EventQueue.access$200(EventQueue.java:103)
	at java.awt.EventQueue$3.run(EventQueue.java:694)
	at java.awt.EventQueue$3.run(EventQueue.java:692)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:87)
	at java.awt.EventQueue$4.run(EventQueue.java:708)
	at java.awt.EventQueue$4.run(EventQueue.java:706)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:705)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:242)
	at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:161)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:150)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:146)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:138)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:91)
java.lang.reflect.InvocationTargetException
	at sun.lwawt.macosx.LWCToolkit.invokeAndWait(LWCToolkit.java:572)
	at sun.lwawt.macosx.CInputMethod.characterIndexForPoint(CInputMethod.java:757)
Caused by: java.lang.NullPointerException
	at javax.swing.text.JTextComponent$InputMethodRequestsHandler.getLocationOffset(JTextComponent.java:4651)
	at sun.awt.im.InputMethodContext.getLocationOffset(InputMethodContext.java:286)
	at sun.lwawt.macosx.CInputMethod$7.run(CInputMethod.java:759)
	at java.awt.event.InvocationEvent.dispatch(InvocationEvent.java:302)
	at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:733)
	at java.awt.EventQueue.access$200(EventQueue.java:103)
	at java.awt.EventQueue$3.run(EventQueue.java:694)
	at java.awt.EventQueue$3.run(EventQueue.java:692)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:87)
	at java.awt.EventQueue$4.run(EventQueue.java:708)
	at java.awt.EventQueue$4.run(EventQueue.java:706)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.security.ProtectionDomain$1.doIntersectionPrivilege(ProtectionDomain.java:76)
	at java.awt.EventQueue.dispatchEvent(EventQueue.java:705)
	at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:242)
	at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:161)
	at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:150)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:146)
	at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:138)
	at java.awt.EventDispatchThread.run(EventDispatchThread.java:91)
{code}

Here is a message from Terminal.app:
{code}
$ bin/groovyConsole
^[[A2016-05-03 13:22:04.418 java[2464:278618] An uncaught exception was raised
2016-05-03 13:22:04.418 java[2464:278618] NSConcreteAttributedString initWithString:: nil value
2016-05-03 13:22:04.421 java[2464:278618] (
	0   CoreFoundation                      0x00007fff903554f2 __exceptionPreprocess + 178
	1   libobjc.A.dylib                     0x00007fff88c7073c objc_exception_throw + 48
	2   CoreFoundation                      0x00007fff903bc4bd +[NSException raise:format:] + 205
	3   Foundation                          0x00007fff8e4b5255 -[NSConcreteAttributedString initWithString:] + 132
	4   liblwawt.dylib                      0x000000011b3193fe -[AWTView attributedSubstringForProposedRange:actualRange:] + 135
	5   AppKit                              0x00007fff87fba58d -[NSTextInputContext(NSInputContext_WithCompletion) attributedSubstringForProposedRange:completionHandler:] + 105
	6   AppKit                              0x00007fff87fb60a2 __55-[NSTextInputContext handleTSMEvent:completionHandler:]_block_invoke_3520 + 115
	7   AppKit                              0x00007fff87fb361a -[NSTextInputContext tryHandleTSMEvent_attributedSubstringForProposedRange_withContext:dispatchCondition:dispatchWork:continuation:] + 101
	8   AppKit                              0x00007fff87fb6005 __55-[NSTextInputContext handleTSMEvent:completionHandler:]_block_invoke516 + 461
	9   AppKit                              0x00007fff87fb5d09 __55-[NSTextInputContext handleTSMEvent:completionHandler:]_block_invoke_2499 + 474
	10  AppKit                              0x00007fff87fba873 -[NSTextInputContext(NSInputContext_WithCompletion) firstRectForCharacterRange:completionHandler:] + 397
	11  AppKit                              0x00007fff87fb5b24 __55-[NSTextInputContext handleTSMEvent:completionHandler:]_block_invoke498 + 198
	12  AppKit                              0x00007fff87fb3279 __178-[NSTextInputContext tryHandleTSMEvent_offsetToPos_markedOrSelRange_withContext:markedOrSelRangeDispatchCondition:markedRangeContinuation:selectedRangeContinuation:continuation:]_block_invoke + 99
	13  AppKit                              0x00007fff87fb3209 -[NSTextInputContext tryHandleTSMEvent_offsetToPos_markedOrSelRange_withContext:markedOrSelRangeDispatchCondition:markedRangeContinuation:selectedRangeContinuation:continuation:] + 213
	14  AppKit                              0x00007fff87fb56cb __55-[NSTextInputContext handleTSMEvent:completionHandler:]_block_invoke461 + 372
	15  AppKit                              0x00007fff878a4947 -[NSTextInputContext handleTSMEvent:completionHandler:] + 2429
	16  AppKit                              0x00007fff878a3f5e _NSTSMEventHandler + 324
	17  HIToolbox                           0x00007fff948987be _ZL23DispatchEventToHandlersP14EventTargetRecP14OpaqueEventRefP14HandlerCallRec + 1231
	18  HIToolbox                           0x00007fff94897c48 _ZL30SendEventToEventTargetInternalP14OpaqueEventRefP20OpaqueEventTargetRefP14HandlerCallRec + 404
	19  HIToolbox                           0x00007fff94897aab SendEventToEventTargetWithOptions + 43
	20  HIToolbox                           0x00007fff948ecf7d SendTSMEvent_WithCompletionHandler + 417
	21  HIToolbox                           0x00007fff94a9f105 __SendTextInputEvent_WithCompletionHandler_block_invoke + 586
	22  HIToolbox                           0x00007fff94a9d3fd SendTextInputEvent_WithCompletionHandler + 1228
	23  HIToolbox                           0x00007fff94b09474 -[IMKInputSession _postEvent:completionHandler:] + 184
	24  HIToolbox                           0x00007fff94b09336 -[IMKInputSession _createAndSendOffsetToPointEvent:completionHandler:] + 300
	25  HIToolbox                           0x00007fff94b1d014 -[IMKInputSession attributesForCharacterIndex_andLineRect:completionHandler:] + 597
	26  HIToolbox                           0x00007fff94b1dcc8 -[IMKInputSession attributesForCharacterIndex:completionHandler:] + 113
	27  HIToolbox                           0x00007fff94b0b19b __60-[IMKInputSession imkxpc_attributesForCharacterIndex:reply:]_block_invoke + 502
	28  CoreFoundation                      0x00007fff902ea4ac __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ + 12
	29  CoreFoundation                      0x00007fff902c9d05 __CFRunLoopDoBlocks + 341
	30  CoreFoundation                      0x00007fff902c94ce __CFRunLoopRun + 910
	31  CoreFoundation                      0x00007fff902c8ed8 CFRunLoopRunSpecific + 296
	32  HIToolbox                           0x00007fff948c0935 RunCurrentEventLoopInMode + 235
	33  HIToolbox                           0x00007fff948c0677 ReceiveNextEventCommon + 184
	34  HIToolbox                           0x00007fff948c05af _BlockUntilNextEventMatchingListInModeWithFilter + 71
	35  AppKit                              0x00007fff876fdefa _DPSNextEvent + 1067
	36  AppKit                              0x00007fff876fd32a -[NSApplication _nextEventMatchingEventMask:untilDate:inMode:dequeue:] + 454
	37  libosxapp.dylib                     0x000000011b16a4e3 -[NSApplicationAWT nextEventMatchingMask:untilDate:inMode:dequeue:] + 124
	38  AppKit                              0x00007fff876f1e84 -[NSApplication run] + 682
	39  libosxapp.dylib                     0x000000011b16a346 +[NSApplicationAWT runAWTLoopWithApp:] + 156
	40  liblwawt.dylib                      0x000000011b30c539 -[AWTStarter starter:] + 873
	41  Foundation                          0x00007fff8e4dcf5e __NSThreadPerformPerform + 279
	42  CoreFoundation                      0x00007fff902ea881 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 17
	43  CoreFoundation                      0x00007fff902c9fbc __CFRunLoopDoSources0 + 556
	44  CoreFoundation                      0x00007fff902c94df __CFRunLoopRun + 927
	45  CoreFoundation                      0x00007fff902c8ed8 CFRunLoopRunSpecific + 296
	46  java                                0x000000010fbd23b0 CreateExecutionEnvironment + 871
	47  java                                0x000000010fbccb5c JLI_Launch + 1952
	48  java                                0x000000010fbd270d main + 101
	49  java                                0x000000010fbcc3b4 start + 52
	50  ???                                 0x0000000000000011 0x0 + 17
)
{code}","OS X El Capitan (version 10.11.4), JDK 7u71, Google Japanese Input 2.17.2400.1 ",githubbot,Muneyuki Noguchi,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"03/May/16 04:44;Muneyuki Noguchi;NullPointerException_in_groovyConsole.png;https://issues.apache.org/jira/secure/attachment/12801898/NullPointerException_in_groovyConsole.png",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 20 19:34:38 UTC 2016,,,,,,,,,,"0|i2x2w7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/May/16 05:39;githubbot;GitHub user blackdrag opened a pull request:

    https://github.com/apache/groovy/pull/326

    GROOVY-7832: add null guard

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/blackdrag/groovy GROOVY-7832

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/326.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #326
    
----
commit 6388dbda1ede5b9fc94fc4d6f5456a788b51fa1a
Author: Jochen Theodorou <blackdrag@gmx.org>
Date:   2016-05-03T05:36:11Z

    GROOVY-7832: add null guard

----
;;;","20/May/16 19:32;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/326
;;;","20/May/16 19:34;pascalschumacher;merged Jochens pull request;;;",,,,,,,,,,,,,,,,,,,
Created a class loader that override loadClass can calls protected methods results in VerifyError,GROOVY-7828,12962541,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,graemerocher1,graemerocher1,26/Apr/16 09:58,02/May/17 02:03,14/Jul/23 06:02,25/Sep/16 20:52,2.4.6,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,"The following script results in a VerifyError:

{code}
java.lang.VerifyError: (class: FooClassLoader, method: loadClass signature: (Ljava/lang/String;Z)Ljava/lang/Class;) Bad access to protected data
	at java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.lang.Class.privateGetDeclaredConstructors(Class.java:2671)
	at java.lang.Class.getDeclaredConstructors(Class.java:2020)
	at org.codehaus.groovy.reflection.CachedClass$2$1.run(CachedClass.java:77)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.codehaus.groovy.reflection.CachedClass$2.initValue(CachedClass.java:74)
	at org.codehaus.groovy.reflection.CachedClass$2.initValue(CachedClass.java:72)
	at org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:49)
	at org.codehaus.groovy.util.LazyReference.get(LazyReference.java:36)
	at org.codehaus.groovy.reflection.CachedClass.getConstructors(CachedClass.java:271)
	at groovy.lang.MetaClassImpl.<init>(MetaClassImpl.java:220)
{code}

It should fail with a compilation error since the `loadClass` method is protected.

{code}
import groovy.transform.*

@CompileStatic
class FooClassLoader extends URLClassLoader {

        protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
            try {
                return super.loadClass(name, resolve)
            } catch (ClassNotFoundException cnfe) {
                return ClassLoader.systemClassLoader.loadClass(name, resolve)
            }
        }
}

def cl = new FooClassLoader()
{code}",,blackdrag,graemerocher1,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 25 20:52:14 UTC 2016,,,,,,,,,,"0|i2wqpb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Apr/16 18:06;blackdrag;I assume you mean the loadClass call in the catch block, because the super.loadClass call is supposed to be legal.;;;","26/Aug/16 03:06;jwagenleitner;This is fixed in master.  I confirmed that commit https://github.com/apache/groovy/commit/415b95545a9e2ca3a22e2d29fad4a3b65278fb84 for GROOVY-7325 now causes a compile time error as expected.  The commit applies cleanly to GROOVY_2_4_X, so maybe worth applying to get it into 2.4.8?;;;","25/Sep/16 20:52;jwagenleitner;Since this is fixed in master I'm going to go ahead and resolve this.  If there's a desire to port the fix to 2.4.x we can pursue that.;;;",,,,,,,,,,,,,,,,,,,
Allow groovyc ant task to select all available target bytecode versions,GROOVY-7827,12961993,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,paulk,paulk,23/Apr/16 03:37,02/May/17 02:02,14/Jul/23 06:02,23/Apr/16 03:47,,,,,,,,,2.5.0-alpha-1,,,,,,,,0,,,,,,,Issue to track: https://github.com/apache/groovy/pull/317,,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2016-04-23 03:37:40.0,,,,,,,,,,"0|i2wnbr:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
Infinite recursion in genericTypeAsString,GROOVY-7826,12961578,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,magnus.reftel,magnus.reftel,22/Apr/16 09:13,12/Jun/16 08:45,14/Jul/23 06:02,18/May/16 19:13,2.2.0-beta-2,,,,,,,,2.4.7,,,,,,,,1,regresion,,,,,,"The following two Java classes C1 and C2 cause Groovy to enter infinite recursion in genericTypeAsString when a method that takes a C1 is declared:

C1.java:
{code}
public class C1 <T2 extends C2<T2,T1>,T1 extends C1<T2,T1>> { }
class C2<T2 extends C2<T2, T1>, T1 extends C1<T2, T1>> { }
{code}
repro.groovy
{code}
def f(C1 c1) { }
{code}
This is reduced from actual code in Jenkins, where Run and Job have type parameters like this.",Groovy Version: 2.4.6 JVM: 1.8.0_91 Vendor: Oracle Corporation OS: Linux,blackdrag,daniel.spilker@hamburg.de,githubbot,jglick@netbeans.org,magnus.reftel,pascalschumacher,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,"22/Apr/16 09:16;magnus.reftel;groovy-7826.zip;https://issues.apache.org/jira/secure/attachment/12800188/groovy-7826.zip",,,,1.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri May 20 12:57:31 UTC 2016,,,,,,,,,,"0|i2wkuv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/May/16 11:02;magnus.reftel;This is a regression, as it works fine with

Groovy Version: 1.8.6 JVM: 1.8.0_31 Vendor: Oracle Corporation OS: Linux
;;;","04/May/16 11:25;magnus.reftel;Tested with a couple of different versions, and it seems like the problem was introduced in 2.2.0-beta-2, as all tested versions up to and including 2.2.0-beta-1 works. 

Log follows:

$ for a in ~/opt/groovy-*; do echo `basename $a`; $a/bin/groovy -cp . repro.groovy; done
groovy-1.8.9
groovy-2.1.9
groovy-2.2.0
Caught: java.lang.StackOverflowError
java.lang.StackOverflowError
groovy-2.2.0-beta-1
groovy-2.2.0-beta-2
Caught: java.lang.StackOverflowError
java.lang.StackOverflowError
groovy-2.2.0-rc-1
Caught: java.lang.StackOverflowError
java.lang.StackOverflowError
groovy-2.2.0-rc-3
Caught: java.lang.StackOverflowError
java.lang.StackOverflowError
groovy-2.2.1
Caught: java.lang.StackOverflowError
java.lang.StackOverflowError
groovy-2.2.2
Caught: java.lang.StackOverflowError
java.lang.StackOverflowError
groovy-2.3.11
Caught: java.lang.StackOverflowError
java.lang.StackOverflowError
groovy-2.4.6
Caught: java.lang.StackOverflowError
java.lang.StackOverflowError
$;;;","04/May/16 11:35;blackdrag;it is not really a regression since 2,2.0 was the first version to not to ignore that code. Still has to be fixed;;;","13/May/16 04:57;paulk;I also get the problem on the 2_4_X branch but not on master. Needs further investigation to see if some fix has already been applied and whether the fix can be backported onto the 2_4_X branch. I haven't done a git bisect as yet;;;","17/May/16 10:03;daniel.spilker@hamburg.de;See [PR #333|https://github.com/apache/groovy/pull/333] for a reproducer. As far as I could see in the debugger, on master the ClassNodes of the generic type bounds are {{org.codehaus.groovy.ast.decompiled.DecompiledClassNode}} which do not carry the generic type information. And that breaks the recursion. When disabling ASM resolving, the problem can be reproduced on master.

It would be great if this could be fixed in 2.4. I backported my fix to 2.4 and testing this Jenkins ([JENKINS-34751|https://issues.jenkins-ci.org/browse/JENKINS-34751]) has been successful.;;;","17/May/16 10:59;blackdrag;I feel bad about the change in PR #333. If DecompiledClassNode misses the  generic type information it is actually a bug, unless the information is invalid, then this needs to be fixed. if the information is valid, then of course it should not cause a problem.  Comparing the generics information when C1 is in Java and when it is in Groovy should reveal the problem.;;;","17/May/16 13:48;daniel.spilker@hamburg.de;DecompiledClassNode should be fixed if that behavior is not expected. But ClassNode#toString needs to fixed in any case.

What is bad about the fix in PR #333? Are the redirects for type arguments really important for #toString? What is the expected behavior for #toString?

This is the computed value with the fix:
{code}
C1 -> C1 <T2 extends C2 <T2, T1>, T1 extends C1>
{code}

This is the computed value without the fix and with ASM resolving enabled:
{code}
C1 -> C1 <T2 extends C2 <T2, T1> -> C2, T1 extends C1>
{code}

Without the fix and without ASM resolving, the computation never stops:
{code}
C1 -> C1 <T2 extends C2 <T2, T1> -> C2 <T2 extends C2, T1 extends C1 <T2, T1> -> C1 <T2 extends C2 <T2, T1> -> C2 <T2 extends C2, T1 extends C1 <T2, T1> -> ...
{code}

This is the same ouput as above without the fix and with ASM resolving enabled, but I added (class.name@identityHashCode) to the type name to show the instances:
{code}
C1(org.codehaus.groovy.ast.ClassNode@12e335ef) -> C1(org.codehaus.groovy.ast.decompiled.DecompiledClassNode@2e9e799) <T2 extends C2(org.codehaus.groovy.ast.ClassNode@4a63ef4d) <T2, T1> -> C2(org.codehaus.groovy.ast.decompiled.DecompiledClassNode@66f3ce62), T1 extends C1>
{code}

... and with ASM resolving disabled:
{code}
C1(org.codehaus.groovy.ast.ClassNode@7c91f442) -> C1(org.codehaus.groovy.ast.ClassNode@523b58f2) <T2 extends C2(org.codehaus.groovy.ast.ClassNode@364ca20b) <T2, T1> -> C2(org.codehaus.groovy.ast.ClassNode@61229c06) <T2 extends C2, T1 extends C1(org.codehaus.groovy.ast.ClassNode@27317fbc) <T2, T1> -> C1(org.codehaus.groovy.ast.ClassNode@523b58f2) <T2 ...
{code}

PS: I removed the {{org.codehaus.groovy.ast.Groovy7862Bug$}} prefix for the names of C1 and C2 for brevity.

PPS: Shouldn't the expected value should be this?
{code}
C1 -> C1<T2 extends C2<T2, T1>, T1 extends C1<T2, T1>>
{code}
;;;","18/May/16 06:02;blackdrag;thanks for taking the time to explain the problem in more detail. Actually I was misunderstanding something and not really understanding the issue. But the recursive use of C2 is indeed something that can be solved with your patch. And since we need to break the toString somewhere I think you have chosen a good place for that.;;;","18/May/16 19:13;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/333
;;;","18/May/16 19:13;pascalschumacher;Pull request merged. Thanks!;;;","20/May/16 12:28;daniel.spilker@hamburg.de;The problem has been (indirectly) introduced in 2.2.0-beta-2 by commit [74089c1|https://github.com/apache/groovy/commit/74089c1156d6c296d64e68e766575e86c4119c67].

Can someone please update the ""Affects Version"" field?;;;","20/May/16 12:57;blackdrag;see also GROOVY-7840;;;",,,,,,,,,,
Redundant computation in ObservableSet,GROOVY-7822,12960572,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,jwagenleitner,jwagenleitner,21/Apr/16 02:29,03/Jun/16 20:16,14/Jul/23 06:02,23/Apr/16 04:43,2.4.6,,,,,,,,2.4.7,,,,groovy-runtime,,,,0,,,,,,,"There appears to be redundant computaions in ""ObservableList.retainAll""
methods in version 2.4.6. I have attached a test and proposed a small 
patch which ensures that ""contains"" method is called on hashset of
input collection. This patch gives 1739X speed up on my 
machine for the provided test. 

Also, one more possibility to fix the issue is by using TreeSet as suggested in 
https://issues.apache.org/jira/browse/GROOVY-5739 as well. 
Similar patches can be applied for three other methods, ObservableList.removeAll, ObservableSet.retainAll, ObservableSet.removeAll.",,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7783,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Sat Apr 23 04:38:57 UTC 2016,,,,,,,,,,"0|i2wf3r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Apr/16 16:27;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/316

    GROOVY-7822 - Redundant computation in ObservableSet

    Related to PR #314, performance significantly improved for `retainAll`, similar change to `removeAll` did not yield any significant performance difference.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7822-ObservableSet

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/316.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #316
    
----
commit 459a141bf4f558e3340c8df3c125b540a49fa9d4
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-04-21T16:17:46Z

    GROOVY-7822 - Redundant computation in ObservableSet

----
;;;","23/Apr/16 04:38;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/316
;;;",,,,,,,,,,,,,,,,,,,,
"CachedMethod.compareToCachedMethod throws ""Should never happen""",GROOVY-7820,12959891,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,ftmamud,ftmamud,19/Apr/16 04:05,12/Jun/16 08:45,14/Jul/23 06:02,02/May/16 02:23,2.4.6,,,,,,,,2.4.7,,,,groovy-jdk,groovy-runtime,,,0,,,,,,,"When running the code below:

{code:java}
String.metaClass.methods.unique()
{code}

The exception occurs:

{noformat}
Exception in thread ""main"" java.lang.RuntimeException: Should never happen
	at org.codehaus.groovy.reflection.CachedMethod.compareToCachedMethod(CachedMethod.java:171)
	at org.codehaus.groovy.reflection.CachedMethod.compareTo(CachedMethod.java:140)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.compareToWithEqualityCheck(DefaultTypeTransformation.java:588)
	at org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation.compareTo(DefaultTypeTransformation.java:543)
	at org.codehaus.groovy.runtime.NumberAwareComparator.compare(NumberAwareComparator.java:34)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.numberAwareCompareTo(DefaultGroovyMethods.java:1119)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.coercedEquals(DefaultGroovyMethods.java:11493)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.unique(DefaultGroovyMethods.java:1071)
	at org.codehaus.groovy.runtime.DefaultGroovyMethods.unique(DefaultGroovyMethods.java:1044)
	at org.codehaus.groovy.runtime.dgm$739.invoke(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite$PojoMetaMethodSiteNoUnwrapNoCoerce.invoke(PojoMetaMethodSite.java:274)
	at org.codehaus.groovy.runtime.callsite.PojoMetaMethodSite.call(PojoMetaMethodSite.java:56)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:117)
	at com.study.Main.run(Main.groovy:3)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:93)
	at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:325)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1212)
	at groovy.lang.MetaClassImpl.invokeMethod(MetaClassImpl.java:1021)
	at org.codehaus.groovy.runtime.InvokerHelper.invokePogoMethod(InvokerHelper.java:923)
	at org.codehaus.groovy.runtime.InvokerHelper.invokeMethod(InvokerHelper.java:906)
	at org.codehaus.groovy.runtime.InvokerHelper.runScript(InvokerHelper.java:410)
	at org.codehaus.groovy.runtime.InvokerHelper$runScript.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:133)
	at com.study.Main.main(Main.groovy)
{noformat}

It is seen that is being compared to the same cached method with distinct instances. It should be treated as a cached method?

{code:java}
self.toString()
(Java.lang.String) public boolean java.lang.String.equals (java.lang.Object)

other.toString()
(Java.lang.String) public boolean java.lang.Object.equals (java.lang.Object)
{code}

Thanks!",Groovy Version: 2.4.6 JVM: 1.8.0_72 Vendor: Oracle Corporation OS: Linux,ftmamud,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon May 02 12:29:35 UTC 2016,,,,,,,,,,"0|i2wawn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Apr/16 04:53;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/315

    GROOVY-7820: CachedMethod.compareToCachedMethod throws ""Should never …

    …happen""

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7820

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/315.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #315
    
----
commit f61d0329295ff1be1f6f0f683c27c9c0bddae95a
Author: paulk <paulk@asert.com.au>
Date:   2016-04-21T04:50:50Z

    GROOVY-7820: CachedMethod.compareToCachedMethod throws ""Should never happen""

----
;;;","02/May/16 02:21;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/315
;;;","02/May/16 02:23;paulk;merged proposed PR, thanks for reporting the issue;;;","02/May/16 12:29;ftmamud;Thanks!;;;",,,,,,,,,,,,,,,,,,
ObservableList addAll method property change event index off by one,GROOVY-7816,12959223,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,jwagenleitner,jwagenleitner,15/Apr/16 16:33,17/Apr/16 19:09,14/Jul/23 06:02,17/Apr/16 19:09,2.4.6,,,,,,,,2.4.7,,,,groovy-jdk,,,,0,,,,,,,"The {{ObservableList#addAll()}} method incorrectly calculates the index of the added elements.  The elements are correctly appended to the list, but the property change event index value does not point to the start of the appended elements but to the element just prior.

{code}
import java.beans.*

class MyListener implements PropertyChangeListener {
    PropertyChangeEvent event
    public void propertyChange(PropertyChangeEvent evt) {
        event = evt
    }
}

ObservableList olist = new ObservableList()
def listener = new MyListener()
olist.addPropertyChangeListener(ObservableList.CONTENT_PROPERTY, listener)

olist.add('one')
assert listener.event.index == 0

olist.add('two')
assert listener.event.index == 1

olist.add('three')
assert listener.event.index == 2

listener.event = null  //clear event to make sure one fires for addAll
olist.addAll(['four','five'])
assert olist == ['one','two','three','four','five']
assert olist.get(3) == 'four'
assert listener.event.index == 3  // fails == 2

olist.remove('four')
assert listener.event.index == 3  // passes
{code}",,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Apr 17 18:44:10 UTC 2016,,,,,,,,,,"0|i2w6s7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Apr/16 18:22;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/313

    GROOVY-7816 - ObservableList addAll method property change event index off by one

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7816

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/313.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #313
    
----
commit 94fcc0249b700462b4efeae813b839c5be0bfffe
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-04-17T17:38:31Z

    GROOVY-7816 - ObservableList addAll method property change event index off by one

commit 35342f4ccbbb32d1f81764ae8fc6fc8d8d65bfbd
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-04-17T18:11:22Z

    removed redundant null checks and some minor refactoring

----
;;;","17/Apr/16 18:44;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/313
;;;",,,,,,,,,,,,,,,,,,,,
Calling a non-static outer class method from a static class passes STC,GROOVY-7813,12957471,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,shils,shils,09/Apr/16 19:48,12/Jun/16 08:45,14/Jul/23 06:02,26/May/16 15:07,2.4.6,,,,,,,,2.4.7,,,,Static Type Checker,,,,0,,,,,,,"Example:
{code}
@groovy.transform.TypeChecked
class Foo {
    def bar() { 2 }

    static class Baz {
        def doBar() {
            bar()
        }
    }
}
new Foo.Baz().doBar()
{code}

The {{doBar()}} call in the method above results in a MissingMethodException. If the code is statically compiled rather than just type checked, a VerifyError occurs instead.  

The usage of {{ClassNode#isStaticClass()}} within {{StaticTypeCheckingVisitor#findMethod(ClassNode, String, ClassNode...)}} seems to be responsible, as the former does not return true when the receiver is a static class.",,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun May 01 20:35:57 UTC 2016,,,,,,,,,,"0|i2vvzb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"09/Apr/16 19:55;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/309

    GROOVY-7813: Calling a non-static outer class method from a static cl…

    …ass should fail STC

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7813

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/309.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #309
    
----
commit ef18f20a62a99ade18a4fac9028fca7edf61419a
Author: Shil Sinha <shils@apache.org>
Date:   2016-04-09T19:54:08Z

    GROOVY-7813: Calling a non-static outer class method from a static class should fail STC

----
;;;","10/Apr/16 17:23;githubbot;Github user shils closed the pull request at:

    https://github.com/apache/groovy/pull/309
;;;","10/Apr/16 19:26;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/310

    GROOVY-7813: Calling a non-static outer class method from a static cl…

    …ass should fail STC

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7813

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/310.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #310
    
----
commit 95937844973ffe19b3d6a0954e41a79cee089c99
Author: Shil Sinha <shils@apache.org>
Date:   2016-04-09T19:54:08Z

    GROOVY-7813: Calling a non-static outer class method from a static class should fail STC

----
;;;","01/May/16 20:35;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/310
;;;",,,,,,,,,,,,,,,,,,
Static inner classes cannot be accessed from other files when running by 'groovy' command,GROOVY-7812,12957133,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,chashnikov,chashnikov,08/Apr/16 07:50,21/Feb/19 06:18,14/Jul/23 06:02,16/Jan/19 14:49,2.4.6,,,,,,,,2.5.6,3.0.0-beta-1,,,Compiler,,,,3,,,,,,,"Create the following files
{code:title=Outer.groovy}
class Outer {
  static class Inner {
  }
}
{code}
{code:title=Main.groovy}
println new Outer()
println new Outer.Inner()
{code}
and run 'groovy Main.groovy'. It'll fail with the following message:
{quote}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/home/.../Main.groovy: 2: unable to resolve class Outer.Inner 
 @ line 2, column 9.
   println new Outer.Inner()
{quote}",,alexey.subach,chashnikov,daniel_sun,ian.springer,jwagenleitner,,,,"danielsun1106 commented on pull request #853: GROOVY-7812: Static inner classes cannot be accessed from other files…
URL: https://github.com/apache/groovy/pull/853
 
 
   … when running by 'groovy' command
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;12/Jan/19 19:06;githubbot;600","blackdrag commented on issue #853: GROOVY-7812: Static inner classes cannot be accessed from other files…
URL: https://github.com/apache/groovy/pull/853#issuecomment-453829509
 
 
   +1
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;13/Jan/19 13:24;githubbot;600","danielsun1106 commented on pull request #853: GROOVY-7812: Static inner classes cannot be accessed from other files…
URL: https://github.com/apache/groovy/pull/853#discussion_r247377408
 
 

 ##########
 File path: src/test/groovy/bugs/Groovy7812Bug.groovy
 ##########
 @@ -19,12 +19,34 @@
 package groovy.bugs
 
 import org.codehaus.groovy.tools.GroovyStarter
-import org.junit.Ignore
 
-@Ignore('To be fixed')
 class Groovy7812Bug extends GroovyTestCase {
-    void test() {
+    void testResolvingOuterNestedClass() {
         def mainScriptPath = new File(this.getClass().getResource('/groovy/bugs/groovy7812/Main.groovy').toURI()).absolutePath
-        new GroovyStarter().main([""--main"", ""groovy.ui.GroovyMain"", mainScriptPath] as String[])
+        runScript(mainScriptPath)
+    }
+
+//   Even if try to catch `Throwable`, the expected error is thrown all the same..., as a result, the test fails due to the weired problem...
 
 Review comment:
   @paulk-asert Have you ever ecountered the similar problem?
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;14/Jan/19 02:56;githubbot;600","danielsun1106 commented on pull request #853: GROOVY-7812: Static inner classes cannot be accessed from other files…
URL: https://github.com/apache/groovy/pull/853#discussion_r247377408
 
 

 ##########
 File path: src/test/groovy/bugs/Groovy7812Bug.groovy
 ##########
 @@ -19,12 +19,34 @@
 package groovy.bugs
 
 import org.codehaus.groovy.tools.GroovyStarter
-import org.junit.Ignore
 
-@Ignore('To be fixed')
 class Groovy7812Bug extends GroovyTestCase {
-    void test() {
+    void testResolvingOuterNestedClass() {
         def mainScriptPath = new File(this.getClass().getResource('/groovy/bugs/groovy7812/Main.groovy').toURI()).absolutePath
-        new GroovyStarter().main([""--main"", ""groovy.ui.GroovyMain"", mainScriptPath] as String[])
+        runScript(mainScriptPath)
+    }
+
+//   Even if try to catch `Throwable`, the expected error is thrown all the same..., as a result, the test fails due to the weired problem...
 
 Review comment:
   @paulk-asert Have you ever encountered the similar problem?
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;14/Jan/19 05:40;githubbot;600","asfgit commented on pull request #853: GROOVY-7812: Static inner classes cannot be accessed from other files…
URL: https://github.com/apache/groovy/pull/853
 
 
   
 
----------------------------------------------------------------
This is an automated message from the Apache Git Service.
To respond to the message, please log on GitHub and use the
URL above to go to the specific comment.
 
For queries about this service, please contact Infrastructure at:
users@infra.apache.org
;16/Jan/19 13:59;githubbot;600",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0,3000,,,0,3000,,,,,,GROOVY-7990,,,,,,,GROOVY-4287,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Jan 16 14:49:19 UTC 2019,,,,,,,,,,"0|i2vtw7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Jan/17 05:04;jwagenleitner;Related to GROOVY-4287.;;;","08/Jan/19 10:54;alexey.subach;Seems like quite a substantial issue - any chances to fix it?;;;","08/Jan/19 14:52;daniel_sun;I will set aside some time to look into the issue.;;;","11/Jan/19 17:02;daniel_sun;I add a test for this issue, passed in my local machine(master branch)

https://github.com/apache/groovy/commit/e61557fe8169056ee722cc9e38bc1b46a7fa4e98
;;;","11/Jan/19 17:31;daniel_sun;Fails when run via groovy.bat under Windows...

{code:java}
D:\_TEMP\src>groovy Main.groovy
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.codehaus.groovy.reflection.CachedClass (file:/D:/_DEV/groovy-3.0.0-SNAPSHOT/lib/groovy-3.0.0-SNAPSHOT.jar) to method java.lang.Object.finalize()
WARNING: Please consider reporting this to the maintainers of org.codehaus.groovy.reflection.CachedClass
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
D:\_TEMP\src\Main.groovy: 2: unable to resolve class Outer.Inner
 @ line 2, column 8.
   assert new Outer.Inner()
          ^

1 error

{code}
;;;","11/Jan/19 19:10;daniel_sun;The issue can be reproduced:
https://github.com/apache/groovy/commit/20d895aec59a813a1f9f022df834bf047d0a960c


{code:java}
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by org.codehaus.groovy.reflection.CachedClass (file:/D:/_APPS/git_apps/groovy/target/bootstrap/groovy-3.0.0-SNAPSHOT-bootstrap.jar) to method java.lang.Object.finalize()
WARNING: Please consider reporting this to the maintainers of org.codehaus.groovy.reflection.CachedClass
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
D:\_APPS\git_apps\groovy\out\test\resources\groovy\bugs\groovy7812\Main.groovy: 22: unable to resolve class Outer.Inner 
 @ line 22, column 8.
   assert new Outer.Inner()
          ^

1 error
{code}
;;;","11/Jan/19 20:03;alexey.subach;[~daniel_sun] Thanks a lot for already taking a look at it Daniel! I hope the issue is not too hard to fix..;;;","12/Jan/19 17:37;daniel_sun;Though I can fix the sample code, it's quite hard to iron out all wrinkles... I've debugged for hours... ;;;","12/Jan/19 19:36;daniel_sun;Fixed just now, but I want to tweak the PR later. It is too late for me to sleep(03:36 a.m now)...;;;","13/Jan/19 08:58;daniel_sun; The proposed PR is ready to review: 
https://github.com/apache/groovy/pull/853

P.S. Merged in 72 hours if no one rejects.;;;","16/Jan/19 14:49;daniel_sun;Fixed by https://github.com/apache/groovy/commit/ade7ecb915ece738193deaa667c54b8a483093a2;;;",,,,,,,,,,,
XmlSluper default constructor documentation about namespace aware incorrect.,GROOVY-7810,12956267,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,gillius,gillius,05/Apr/16 20:08,12/Jun/16 08:45,14/Jul/23 06:02,06/Apr/16 01:24,2.4.6,,,,,,,,2.4.7,,,,,,,,0,,,,,,,"Here is the current implementation of XmlSlurper's default constructor as of 2.4.6:

{code}
    /**
     * Creates a non-validating and non-namespace-aware <code>XmlSlurper</code> which does not allow DOCTYPE declarations in documents.
     *
     * @throws ParserConfigurationException if no parser which satisfies the requested configuration can be created.
     * @throws SAXException for SAX errors.
     */
    public XmlSlurper() throws ParserConfigurationException, SAXException {
        this(false, true);
    }
{code}

It clearly creates a namespace-aware slurper.",,gillius,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Wed Apr 06 01:24:31 UTC 2016,,,,,,,,,,"0|i2vokf:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Apr/16 20:11;githubbot;GitHub user gillius opened a pull request:

    https://github.com/apache/groovy/pull/305

    GROOVY-7810 fix XmlSlurper default ctor doc

    Javadoc for default constructor says it creates a non-namespace-aware slurper, when it creates a namespace-aware one.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/gillius/incubator-groovy patch-1

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/305.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #305
    
----
commit 0d3e0cffe45978fab0d296b518d23574a474cb88
Author: Jason Winnebeck <gillius@gillius.org>
Date:   2016-04-05T20:11:31Z

    GROOVY-7810 fix XmlSlurper default ctor doc
    
    Javadoc for default constructor says it creates a non-namespace-aware slurper, when it creates a namespace-aware one.

----
;;;","06/Apr/16 01:20;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/305
;;;","06/Apr/16 01:24;jwagenleitner;Merged PR, thanks!;;;",,,,,,,,,,,,,,,,,,,
XmlSlurper unprefixed attributes should not be in the default namespace,GROOVY-7808,12955937,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,jwagenleitner,jwagenleitner,04/Apr/16 21:41,09/Apr/16 20:11,14/Jul/23 06:02,09/Apr/16 20:11,2.4.6,,,,,,,,2.4.7,,,,XML Processing,,,,0,,,,,,,"According to https://www.w3.org/TR/xml-names/#defaulting the namespace name for an unprefixed attribute name always has no value.  Currently when using XmlSlurper unprefixed attributes have the default namespace.

{code:java}
def xml = '''
<root xmlns=""urn:test"">
    <foo id=""7"">bar</foo>
</root>
'''

def root = new XmlSlurper(false, true).parseText(xml).declareNamespace(ns: 'urn:test')

assert root.foo[0].namespaceURI() == 'urn:test'
assert root.'ns:foo'.text() == 'bar'

assert root.foo.@id == '7'
assert root.foo.'@ns:id' == '' // fails returns 7
assert root.foo.@id[0].namespaceURI() == '' // fails returns 'urn:test'
{code}

Based on the specs I believe the following asserts in the [XmlSlurperTest|https://github.com/apache/groovy/blob/c04e4df42ca3ed25570acc730d87807012c39887/subprojects/groovy-xml/src/test/groovy/groovy/util/XmlSlurperTest.groovy#L142-L143] are incorrect.",,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7781,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Apr 04 21:43:24 UTC 2016,,,,,,,,,,"0|i2vmj3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Apr/16 21:43;jwagenleitner;Fix for this is included in fix for GROOVY-7781 in [GitHub PR 302|https://github.com/apache/groovy/pull/302].;;;",,,,,,,,,,,,,,,,,,,,,
@interface has too-stringent requirement for newline,GROOVY-7806,12955370,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,hackst8r,hackst8r,01/Apr/16 17:50,12/Jun/16 08:45,14/Jul/23 06:02,03/Apr/16 02:00,2.4.6,,,,,,,,2.4.7,,,,syntax,,,,0,,,,,,,"{code}
// this causes an error
@interface ANNOTATION_A 
{
}
{code}

{code}
// this does not cause an error
@interface ANNOTATION_A  {
}
{code}

the first example should work , it does (for example) work for a class :

{code}
// this does not cause an error
class CLASS_A 
{
}
{code}
",,githubbot,hackst8r,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Apr 03 02:00:25 UTC 2016,,,,,,,,,,"0|i2vj1j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"01/Apr/16 21:41;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/301

    GROOVY-7806 - @interface has too-stringent requirement for newline

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7806

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/301.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #301
    
----
commit a7bb1c15bf4bef4ca5bf2da3648f3054fb06155c
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-04-01T21:21:57Z

    GROOVY-7806 - @interface has too-stringent requirement for newline

----
;;;","03/Apr/16 01:19;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/301
;;;","03/Apr/16 02:00;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,
@CompileStatic/@TypeChecked unexpected NullpointerException compiler bug,GROOVY-7804,12954970,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,manuc66,manuc66,31/Mar/16 14:09,12/Jun/16 08:45,14/Jul/23 06:02,27/Apr/16 03:59,2.4.6,,,,,,,,2.4.7,,,,Compiler,,,,0,,,,,,,"Those code produce compiler bug exception (see below) when @CompileStatic or  @TypeChecked is used :

@CompileStatic
class KeywordApiMain {
    static main(args) {
        Optional.of(""MH370"").orElseThrow({ -> new RuntimeException() });
    }
}

@CompileStatic
class KeywordApiMain {
    static main(args) {
        Optional.of(""MH370"").orElseThrow { -> new RuntimeException() };
    }
}

Those code just produce the expected behaviour when compiled and run without the annotation. The workaround is simplifying the code to this :
class KeywordApiMain {
    static main(args) {
        Optional.of(""MH370"").orElseThrow { new RuntimeException() };
    }
}

The compiler output :
Error:Groovyc: BUG! exception in phase 'instruction selection' in source unit '-------\XXXX.groovy' unexpected NullpointerException
                at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1060)
                at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
                at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
                at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
                at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:62)
                at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:115)
                at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
                at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
                at java.lang.reflect.Method.invoke(Method.java:497)
                at org.jetbrains.groovy.compiler.rt.GroovycRunner.intMain2(GroovycRunner.java:134)
                at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
                at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
                at java.lang.reflect.Method.invoke(Method.java:497)
                at org.jetbrains.jps.incremental.groovy.InProcessGroovyc.runGroovycInThisProcess(InProcessGroovyc.java:156)
                at org.jetbrains.jps.incremental.groovy.InProcessGroovyc.access$000(InProcessGroovyc.java:51)
                at org.jetbrains.jps.incremental.groovy.InProcessGroovyc$1.call(InProcessGroovyc.java:85)
                at org.jetbrains.jps.incremental.groovy.InProcessGroovyc$1.call(InProcessGroovyc.java:82)
                at java.util.concurrent.FutureTask.run(FutureTask.java:266)
                at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
                at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
                at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NullPointerException
                at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.extractTypesFromParameters(StaticTypeCheckingVisitor.java:4694)
                at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.convertClosureTypeToSAMType(StaticTypeCheckingVisitor.java:4364)
                at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferReturnTypeGenerics(StaticTypeCheckingVisitor.java:4259)
                at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2938)
                at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethodCallExpression(StaticCompilationVisitor.java:318)
                at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
                at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:71)
                at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:196)
                at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:42)
                at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:37)
                at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:166)
                at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
                at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:104)
                at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:115)
                at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1784)
                at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:126)
                at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2119)
                at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2078)
                at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitMethod(StaticCompilationVisitor.java:165)
                at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1086)
                at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:53)
                at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:249)
                at org.codehaus.groovy.transform.sc.StaticCompilationVisitor.visitClass(StaticCompilationVisitor.java:124)
                at org.codehaus.groovy.transform.sc.StaticCompileTransformation.visit(StaticCompileTransformation.java:63)
                at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:134)
                at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:178)
                at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1055)
                ... 22 more
","Windows, jdk1.8.0_60",githubbot,manuc66,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Apr 09 17:21:29 UTC 2016,,,,,,,,,,"0|i2vgkn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"06/Apr/16 01:58;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/306

    GROOVY-7804: Coercion of parameterless closure to generic SAM type th…

    …rows NPE during STC

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7804

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/306.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #306
    
----
commit 419403ce2d0272c70bd59fe402d9eb38cf3c041f
Author: Shil Sinha <shils@apache.org>
Date:   2016-04-06T01:57:46Z

    GROOVY-7804: Coercion of parameterless closure to generic SAM type throws NPE during STC

----
;;;","09/Apr/16 17:21;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/306
;;;",,,,,,,,,,,,,,,,,,,,
MapWithDefault should be able to be configured to not store its default value,GROOVY-7802,12953947,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,papuska@gmail.com,papuska@gmail.com,28/Mar/16 12:03,16/Apr/23 16:15,14/Jul/23 06:02,26/Feb/22 11:27,2.4.6,,,,,,,,4.0.1,,,,groovy-jdk,,,,0,,,,,,,"As described in https://github.com/apache/groovy/pull/267, a Groovy map with a default value stores all the accessed elements, even if they weren't added explicitly, just queried.

In certain algorithms (e.g. https://github.com/careercup/CtCI-6th-Edition-Groovy/blob/d116d65469bdf17d1e215e89f3e76ac3a97660a9/src/main/groovy/Ch04_TreesAndGraphs/_04_12_PathsWithSum.groovy#L21) the complexity would automatically be reduced, if default values would be deleted (i.e. a default of 0 that is incremented and decremented in a recursive algorithm).

Topics of discussion:
* Currently a `getAt` will `add` also, therefore `containsKey` isn't the same as `getAt(...) != null`
* After the change `keySet()/entrySet()` wouldn't include default values

I proposed alternatives:
* `removeIfDefault(Object)` // removes current key, if value is equal to default
* `consolidate()` // removes all default values
* constructor parameter `STORE_DEFAULT storeDefaultValues = STORE_DEFAULT.FALSE`, or maybe with a `boolean`, though I find primitive parameters confusing

others:
* `containsKey` should always return `true`, or throw an exception, since its behavior is inconsistent

Waiting for your thoughts :)",,papuska@gmail.com,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-9848,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Sat Feb 26 11:27:18 UTC 2022,,,,,,,,,,"0|i2va9j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Apr/16 15:35;jwagenleitner;I find the current behavior of {{withDefault}} makes sense and I definitely would not want to see a breaking change made to it.  

For the alternatives, the first two would only apply to {{MapWithDefault}} maps, so seems odd to add those methods to {{Map}}.  So in my opinion the constructor parameter would be my choice of the options available.  Though I don't usually like boolean parameters I think in this case it would be better than an Enum.  I think the GDK docs for a {{#withDefault(boolean, Closure)}} method could make it sufficiently clear what the boolean switch will do in terms of behavior along with code samples in the docs.

I think the current behavior of {{get}} and {{containsKey}} are valid.  I don't agree that contains key should always return {{true}} or throw.  If the map doesn't contain the key it should return false.  Even though {{get}} will insert into the map that to me has no bearing on how {{containsKey}} should work, since I think it should work based on the current state of the map.

I find the proposed change more confusing than the current behavior, but that may just be that my use cases fit more with how it's currently implemented.  But if the change can be introduced without affecting the current behavior or by adding addtional methods to {{Map}} that only apply to {{MapWithDefault}} then it seems reasonable.  

Am curious what others may think.;;;","02/Aug/16 12:38;paulk;There are already quite a few options around default values that users of Groovy maps need to be aware of:
* Groovy adds a DGM method for maps: {{get(K key, V defaultValue)}} which adds the default entry into the map
* {{MapWithDefault}} allows the default value to be specified as a closure (taking the key as parameter) at map creation time rather than at the point of extraction
* Java 8 adds a {{getOrDefault(Object key, V defaultValue)}} default method which is similar to the DGM method but doesn't change the map

I'd be inclined not to try to wedge further functionality into this mix but rather create a new {{SparseMap}} (or some similar name) which ensures as part of creation and every subsequent operation that default values aren't stored. I'd not assume that {{putAll}} necessarily funneled through {{put}} and I'd remove entries during construction. I wouldn't override the normal {{containsKey}} behavior once the other changes are in place - so an attempt to put a default value into such a map would leave it unchanged and {{containsKey}} would return false.

The implementation of {{SparseMap}} might be close to {{MapWithDefault}} so some refactoring of an abstract class with the common functionality might be useful. We can work out syntactic sugar factory methods later, e.g.: {{withDefault(boolean, Closure)}} or {{withSparseDefault(Closure)}}. We already have {{withLazyDefault/withEagerDefault}} for lists, so there is a precedent if we go that way.;;;","25/Feb/22 10:01;paulk;There is a revised PR here:
https://github.com/apache/groovy/pull/1692;;;","26/Feb/22 11:27;paulk;Proposed PR merged.;;;",,,,,,,,,,,,,,,,,,
Extended generic types with var args isn't compiled if they contains in different files,GROOVY-7799,12952957,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,ikuchmin,ikuchmin,23/Mar/16 20:02,03/Feb/22 22:29,14/Jul/23 06:02,20/Dec/21 13:47,2.4.6,,,,,,,,4.0.0-rc-2,,,,Compiler,,,,0,,,,,,,"Hi

I created two files.

{code:title=A.groovy|borderStyle=solid}
package example;

interface EE {

}

interface A<T extends EE> {
    A<T> method(T args)

    A<T> method(T[] args)

    A<T> method(Collection<T> args)
}

class AB<T extends EE> implements A<T> {
    @Override
    AB<T> method(T args) {
        return null
    }

    @Override
    AB<T> method(T[] args) {
        return this
    }

    @Override
    AB<T> method(Collection<T> args) {
        return this
    }
}
{code}

{code:title=ABC.groovy|borderStyle=solid}
package example;

class ABC<T extends EE> extends AB<T> {}
{code}

If you would like get bug that you should compile A.groovy and then compile ABC.groovy. For second file you should use compiled classes from file A.groovy. For second file compile throw exception: 
{noformat}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
ABC.groovy: 3: Can't have an abstract method in a non-abstract class. The class 'example.ABC' must be declared abstract or the method 'example.A method(java.lang.Object[])' must be implemented.
 @ line 3, column 1.
   class ABC<T extends EE> extends AB<T> {}
   ^

1 error
{noformat}

I can remove var args methods or replace ""T extends EE"" on T. It is workaround for compiler. Code will be compiled.",Oracle JRE 1.8_66,emilles,ikuchmin,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 19 19:10:00 UTC 2021,,,,,,,,,,"0|i2v45j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"19/Dec/21 19:10;emilles;In order for types to be discoverable from their source units, they must use Java-like naming.  For your example, ""interface EE"" needs to be in file ""EE.groovy"" and ""class AB"" needs to be in ""AB.groovy"".  With that small change, the compiler can find the source units and has handling for resolving via https://github.com/apache/groovy/pull/1664/commits/3831eb20b0bf183af9fac6ea036196d91a03880e;;;",,,,,,,,,,,,,,,,,,,,,
"Sql.query methods pass java.sql.ResultSet to the closure, instead of GroovyResultSet",GROOVY-7798,12952320,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,a.atapin@gmail.com,a.atapin@gmail.com,22/Mar/16 05:05,12/Jun/16 08:45,14/Jul/23 06:02,03/Apr/16 01:51,2.4.6,,,,,,,,2.4.7,,,,,,,,0,easyfix,,,,,,"The documentation says:
{code}
* @param closure called for each row with a GroovyResultSet
{code}

Instead, the java ResultSet is passed which prevents from using convenient groovy methods on the result passed over to the closure",,a.atapin@gmail.com,jwagenleitner,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Apr 03 01:51:32 UTC 2016,,,,,,,,,,"0|i2v07z:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Mar/16 05:29;paulk;Actually, if you are referring to the {{query}} method variants, then I believe this is a documentation copy-n-paste error. The point of those variants is to minimise adding overhead (creating wrapper objects etc.); otherwise, {{eachRow}} or similar could be used. So, instead I suggest we fix the doco.;;;","03/Apr/16 01:51;jwagenleitner;Thanks for reporting the issue, I've [updated the javadocs|https://github.com/apache/groovy/commit/9dcd0c8997ad143918a3e54a1c4313dcafc6cf1d].;;;",,,,,,,,,,,,,,,,,,,,
"Private trait method called from within a closure has the wrong ""this"" context",GROOVY-7797,12952060,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Critical,Fixed,paulk,longwa_uk,longwa_uk,21/Mar/16 15:09,18/Mar/17 09:56,14/Jul/23 06:02,02/Mar/17 09:13,2.4.6,,,,,,,,2.4.10,,,,,,,,0,,,,,,,"Calling a private trait method from within a closure results in a MethodMissing exception. It looks like within the closure, `this` is referring to the implementing Class and not the instance.

This might be related to GROOVY-7373. The problem is that calling getDelegate() doesn't work as delegate also seems to have the wrong context.

{code}
trait MyTrait {
    void greeter() {
        {-> doGreeting(""hi"")}.call()
    }
    private void doGreeting(String message) { println message }  
}

class MyClass implements MyTrait { }

new MyClass().greeter()
{code}

If you make the doGreeting method above `static`, it will work properly.",,githubbot,jwagenleitner,longwa_uk,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Mar 02 09:13:03 UTC 2017,,,,,,,,,,"0|i2uym7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Mar/16 15:16;longwa_uk;This issue does not affect Groovy 2.4.1. It seems to have been introduced with the other breaking trait changes in 2.4.2;;;","02/Nov/16 06:01;githubbot;GitHub user blindpirate opened a pull request:

    https://github.com/apache/groovy/pull/455

    GROOVY-7797 Private trait method called from within a closure has the wrong ""this"" context

    Use helper class as method receiver instead of wrong ""this"" when private trait method in a closure is called.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/blindpirate/groovy groovy7797

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/455.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #455
    
----
commit 626e1d4734b701b3576886448cb578fc71ecc8c7
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-11-02T05:33:32Z

    fix groovy7797 - assign correct receiver in closure

commit 824845f989cdd203c2cf3a8875167e99d1d49685
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-11-02T05:39:06Z

    refactor to remove duplicate code

commit ac9098892b788902ba97bd3e2e6cfd88c70ae4c6
Author: zhangbo <zhangbo@nanchao.org>
Date:   2016-11-02T05:46:33Z

    refactor a huge monster method which is over 100 lines

----
;;;","02/Mar/17 09:04;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/455
;;;","02/Mar/17 09:13;paulk;Thanks Aaron for reporting the issue and Bo Zhang for the PR. Proposed PR merged with some minor tweaking.;;;",,,,,,,,,,,,,,,,,,
Compiler compiles class with private abstract method,GROOVY-7793,12951236,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,situokko,situokko,17/Mar/16 15:03,22/May/22 16:03,14/Jul/23 06:02,07/May/16 17:49,2.3.11,,,,,,,,2.4.7,,,,bytecode,Compiler,,,0,ClassFormatError,,,,,,"Using Groovy and JDBI in following class:

{code:title=ItemDAO.groovy|borderStyle=solid}
abstract class ItemDAO {
    @SqlUpdate(""..."")
    @GetGeneratedKeys
    private abstract long insertItem(@BindBean Item item)
}
{code}

When class is used JDBI will create proxy-implementation based on the the abstract class (or interface).

It will compile without any issues, but running it causes (shown below) class-loading/verify error. This is programmers fault to have ""private abstract"" methods, but I guess Groovy-compiler should not let this thru? Maybe IntelliJ Idea groovy-plugin should say it's illegal as well?

I haven't tried this with the latest Groovy-version but unless it has been specifically fixed it might still occur?

---

Exception in thread ""main"" java.lang.ClassFormatError: Method insertDish in class com/company/ItemDAO has illegal modifiers: 0x402
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:760)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)
	at java.net.URLClassLoader.access$100(URLClassLoader.java:73)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:368)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:362)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:361)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.Class.getDeclaredMethods0(Native Method)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)
	at java.lang.Class.getDeclaredMethods(Class.java:1975)
	at org.codehaus.groovy.reflection.CachedClass$3$1.run(CachedClass.java:85)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.codehaus.groovy.reflection.CachedClass$3.initValue(CachedClass.java:82)
	at org.codehaus.groovy.reflection.CachedClass$3.initValue(CachedClass.java:80)
	at org.codehaus.groovy.util.LazyReference.getLocked(LazyReference.java:46)
	at org.codehaus.groovy.util.LazyReference.get(LazyReference.java:33)
	at org.codehaus.groovy.reflection.CachedClass.getMethods(CachedClass.java:251)
	at groovy.lang.MetaClassImpl.populateMethods(MetaClassImpl.java:390)
	at groovy.lang.MetaClassImpl.fillMethodIndex(MetaClassImpl.java:340)
	at groovy.lang.MetaClassImpl.initialize(MetaClassImpl.java:3224)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClassUnderLock(ClassInfo.java:222)
	at org.codehaus.groovy.reflection.ClassInfo.getMetaClass(ClassInfo.java:253)
	at org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl.getMetaClass(MetaClassRegistryImpl.java:255)
	at org.codehaus.groovy.runtime.InvokerHelper.getMetaClass(InvokerHelper.java:859)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.createCallConstructorSite(CallSiteArray.java:84)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:57)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:182)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:194)
","- OS X
- Java(TM) SE Runtime Environment (build 1.8.0_66-b17)
- IntelliJ Idea 14 CE \w Groovy plugin
- Gradle 2.2",githubbot,pascalschumacher,situokko,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat May 07 17:49:54 UTC 2016,,,,,,,,,,"0|i2utzz:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/May/16 09:35;githubbot;GitHub user andresteingress opened a pull request:

    https://github.com/apache/groovy/pull/328

    GROOVY-7793: Compiler compiles class with private abstract method

    This PR adds some logic to the class completion verifier that adds an error to the error collector when private abstract methods are detected in abstract classes or enums (for interfaces such a check is already available).

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/andresteingress/groovy GROOVY-7793

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/328.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #328
    
----
commit 81945cb177a588bb6d7ff0a5868691ed92d89260
Author: Andre Steingress <me@andresteingress.com>
Date:   2016-05-04T21:17:03Z

    GROOVY-7793: Compiler compiles class with private abstract method

----
;;;","07/May/16 13:14;githubbot;Github user PascalSchumacher commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/328#discussion_r62416234
  
    --- Diff: src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java ---
    @@ -73,13 +73,22 @@
                 ""Method 'prom' is protected but should be public in interface 'zzz'."";
         private static final String EXPECTED_PRIVATE_METHOD_ERROR_MESSAGE =
                 ""Method 'prim' is private but should be public in interface 'zzz'."";
    +    private static final String EXPECTED_ABSTRACT_PRIVATE_METHOD_ERROR_MESSAGE =
    +            ""Method 'y' from class 'X' must not be private as it is declared as abstract method."";
    --- End diff --
    
    Should this be ""... as an abstract method""?
;;;","07/May/16 16:43;githubbot;Github user andresteingress commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/328#discussion_r62419225
  
    --- Diff: src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java ---
    @@ -73,13 +73,22 @@
                 ""Method 'prom' is protected but should be public in interface 'zzz'."";
         private static final String EXPECTED_PRIVATE_METHOD_ERROR_MESSAGE =
                 ""Method 'prim' is private but should be public in interface 'zzz'."";
    +    private static final String EXPECTED_ABSTRACT_PRIVATE_METHOD_ERROR_MESSAGE =
    +            ""Method 'y' from class 'X' must not be private as it is declared as abstract method."";
    --- End diff --
    
    Yes, ""as an"" sounds more correct, I will fix it.
;;;","07/May/16 17:48;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/328
;;;","07/May/16 17:49;pascalschumacher;Pull request merged. Thanks!;;;",,,,,,,,,,,,,,,,,
ClosureParams type inference compilation error when wrapping closure with object,GROOVY-7789,12950051,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,kbialek,kbialek,14/Mar/16 20:45,10/Feb/23 21:40,14/Jul/23 06:02,05/Nov/22 19:36,2.4.6,2.5.15,3.0.9,4.0.0-beta-1,,,,,2.5.20,3.0.14,4.0.7,,Static compilation,,,,0,,,,,,,"The following code does not compile:
{code}
import groovy.transform.*
import groovy.transform.stc.*

@CompileStatic
class Test {

    class A<IN> {
        Closure c

        A(@ClosureParams(value = FromString, options = 'IN') Closure c) {
            this.c = c
        }

        void call(IN param) {
            c.call(param)
        }
    }

    def <IN> A wrap(@ClosureParams(value = FromString, options = 'IN') Closure c) {
        new A<IN>(c)
    }

    def test() {
        (wrap { i -> i.size() }).call([])
    }

}
{code}

Compilation error:
{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
/tmp/groovy-2.4.6/test.groovy: 25: [Static type checking] - Cannot find matching method java.lang.Object#size(). Please check if the declared type is right and if the method exists.
 @ line 24, column 22.
           (wrap { i -> i.size() }).call([])
{code}

I'd expect 'i' being infered as java.util.List
Explicit this.<List>wrap does not help neither",,emilles,kbialek,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Nov 05 19:36:40 UTC 2022,,,,,,,,,,"0|i2umov:",9223372036854775807,,,,,,,,,,,,,,,,,,,"25/Oct/21 16:10;emilles;{{wrap}} returns a raw type {{A}} regardless of what ""IN"" can be determined to be.  There is no actual type witness for ""IN"".  One can be supplied like this:  {{def a_of_list = this.<List>wrap \{ i -> i.size() \};}}

In the case where an explicit type argument is supplied to the method call, Groovy 2.5 does not properly propagate the closure param type to the variable expression ""i"" in ""i.size()"".

{code:groovy}
import groovy.transform.stc.*

class A<T> {
  Closure c
  A(@ClosureParams(value=FromString, options='T') Closure c) {
    this.c = c
  }
  def call(T param) {
    c.call(param)
  }
}

def <U> A<U> wrap(@ClosureParams(value=FromString, options='U') Closure c) {
    new A<U>(c)
}

@groovy.transform.CompileStatic
def test7789() {
  def a_of_list = this.<List>wrap { i -> i.size(); } // STC error: Cannot find matching method Object#size()
  def x = a_of_list.call([])
}
{code};;;","05/Nov/22 19:36;emilles;https://github.com/apache/groovy/commit/9d0f47a002617c05e1d0139bae4811d9cebfe502;;;",,,,,,,,,,,,,,,,,,,,
TypeChecked/CompileStatic: IndexOutOfBoundsException,GROOVY-7784,12948828,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,greg2001,greg2001,10/Mar/16 15:28,12/Jun/16 08:45,14/Jul/23 06:02,26/May/16 23:55,2.4.6,,,,,,,,2.4.7,,,,Compiler,,,,0,,,,,,,"Compiling the following:

{code:title=IOOBE.groovy|borderStyle=solid}
import groovy.transform.TypeChecked

import java.nio.file.Files
import java.nio.file.Paths

@TypeChecked
class IOOBE
{
  def ioobe()
  {
    Files.write(Paths.get('foo.bar'), { ['foo', 'bar'].iterator() });
  }
}
{code}

(closure is used to automatically coerce Iterator to Iterable),
produces the following exception during compilation:

{code}
Error:Groovyc: java.lang.IndexOutOfBoundsException: Index: 2, Size: 2
	at java.util.LinkedList.checkElementIndex(LinkedList.java:555)
	at java.util.LinkedList.get(LinkedList.java:476)
	at org.codehaus.groovy.ast.expr.TupleExpression.getExpression(TupleExpression.java:89)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferSAMType(StaticTypeCheckingVisitor.java:2342)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferClosureParameterTypes(StaticTypeCheckingVisitor.java:2318)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallArguments(StaticTypeCheckingVisitor.java:2282)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethodCallExpression(StaticTypeCheckingVisitor.java:2970)
	at org.codehaus.groovy.ast.expr.MethodCallExpression.visit(MethodCallExpression.java:66)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitExpressionStatement(CodeVisitorSupport.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitExpressionStatement(ClassCodeVisitorSupport.java:196)
	at org.codehaus.groovy.ast.stmt.ExpressionStatement.visit(ExpressionStatement.java:42)
	at org.codehaus.groovy.ast.CodeVisitorSupport.visitBlockStatement(CodeVisitorSupport.java:37)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitBlockStatement(ClassCodeVisitorSupport.java:166)
	at org.codehaus.groovy.ast.stmt.BlockStatement.visit(BlockStatement.java:71)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClassCodeContainer(ClassCodeVisitorSupport.java:104)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitConstructorOrMethod(ClassCodeVisitorSupport.java:115)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitConstructorOrMethod(StaticTypeCheckingVisitor.java:1774)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitMethod(ClassCodeVisitorSupport.java:126)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.startMethodInference(StaticTypeCheckingVisitor.java:2107)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitMethod(StaticTypeCheckingVisitor.java:2066)
	at org.codehaus.groovy.ast.ClassNode.visitContents(ClassNode.java:1086)
	at org.codehaus.groovy.ast.ClassCodeVisitorSupport.visitClass(ClassCodeVisitorSupport.java:53)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.visitClass(StaticTypeCheckingVisitor.java:249)
	at org.codehaus.groovy.transform.StaticTypesTransformation.visit(StaticTypesTransformation.java:66)
	at org.codehaus.groovy.transform.ASTTransformationVisitor.visitClass(ASTTransformationVisitor.java:134)
	at org.codehaus.groovy.transform.ASTTransformationVisitor$2.call(ASTTransformationVisitor.java:178)
	at org.codehaus.groovy.control.CompilationUnit.applyToPrimaryClassNodes(CompilationUnit.java:1055)
	at org.codehaus.groovy.control.CompilationUnit.doPhaseOperation(CompilationUnit.java:591)
	at org.codehaus.groovy.control.CompilationUnit.processPhaseOperations(CompilationUnit.java:569)
	at org.codehaus.groovy.control.CompilationUnit.compile(CompilationUnit.java:546)
	at org.jetbrains.groovy.compiler.rt.GroovyCompilerWrapper.compile(GroovyCompilerWrapper.java:62)
	at org.jetbrains.groovy.compiler.rt.DependentGroovycRunner.runGroovyc(DependentGroovycRunner.java:115)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.jetbrains.groovy.compiler.rt.GroovycRunner.intMain2(GroovycRunner.java:134)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.jetbrains.jps.incremental.groovy.InProcessGroovyc.runGroovycInThisProcess(InProcessGroovyc.java:156)
	at org.jetbrains.jps.incremental.groovy.InProcessGroovyc.access$000(InProcessGroovyc.java:51)
	at org.jetbrains.jps.incremental.groovy.InProcessGroovyc$1.call(InProcessGroovyc.java:85)
	at org.jetbrains.jps.incremental.groovy.InProcessGroovyc$1.call(InProcessGroovyc.java:82)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
{code}
",,githubbot,greg2001,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu May 26 23:55:06 UTC 2016,,,,,,,,,,"0|i2uh3b:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Mar/16 15:09;shils;This occurs during SAM type inference when the target method has a var args parameter for which no argument is supplied - in this case {{Paths.write(Path, Iterable<? extends CharSequence>, OpenOptions...)}}. The number of parameters being greater than the number of arguments causes the exception.;;;","26/May/16 13:34;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/339

    GROOVY-7784: TypeChecked/CompileStatic: IndexOutOfBoundsException

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7784

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/339.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #339
    
----
commit 2d1029f6b933a1bc45f6a6f0b3e8e62c5d29ed5c
Author: paulk <paulk@asert.com.au>
Date:   2016-05-26T13:27:55Z

    GROOVY-7784: TypeChecked/CompileStatic: IndexOutOfBoundsException

----
;;;","26/May/16 23:54;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/339
;;;","26/May/16 23:55;paulk;PR merged;;;",,,,,,,,,,,,,,,,,,
Redundant computation in ObservableList,GROOVY-7783,12948771,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,monikadhok,monikadhok,10/Mar/16 12:48,12/Jun/16 08:45,14/Jul/23 06:02,21/Apr/16 02:31,2.4.6,,,,,,,,2.4.7,,,,groovy-runtime,,,,0,,,,,,,"There appears to be redundant computaions in ""ObservableList.retainAll""
methods in version 2.4.6. I have attached a test and proposed a small 
patch which ensures that ""contains"" method is called on hashset of
input collection. This patch gives 1739X speed up on my 
machine for the provided test. 

Also, one more possibility to fix the issue is by using TreeSet as suggested in 
https://issues.apache.org/jira/browse/GROOVY-5739 as well. 
Similar patches can be applied for three other methods, ObservableList.removeAll, ObservableSet.retainAll, ObservableSet.removeAll.",,githubbot,jwagenleitner,monikadhok,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7822,,,,,,,,,,,,,,,,"10/Mar/16 12:50;monikadhok;ObservableList.patch;https://issues.apache.org/jira/secure/attachment/12792505/ObservableList.patch","10/Mar/16 12:50;monikadhok;Test.java;https://issues.apache.org/jira/secure/attachment/12792503/Test.java",,,2.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,Patch,,,,,,,,9223372036854775807,,,Thu Apr 21 02:31:06 UTC 2016,,,,,,,,,,"0|i2ugqn:",9223372036854775807,,,,,,,,,,,,,,,,,,,"17/Apr/16 23:52;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/314

    GROOVY-7783 - Redundant computation in ObservableList

    Patch provided thanks to Monika Dhok.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7783

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/314.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #314
    
----
commit b20eaafa82d9ed70995c47ddbb449ed7c081a66f
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-04-17T23:48:25Z

    GROOVY-7783 - Redundant computation in ObservableList
    
    Patch provided thanks to Monika Dhok.

----
;;;","21/Apr/16 02:16;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/314
;;;","21/Apr/16 02:31;jwagenleitner;Thanks for providing the patch, a slightly modified version was applied to both the removeAll and retainAll methods.  I have cloned this to create an issue for fixing ObservableSet as well.;;;",,,,,,,,,,,,,,,,,,,
GPathResult: Cannot retrieve XML attribute with namespace,GROOVY-7781,12947693,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,gillius,gillius,07/Mar/16 13:58,12/Jun/16 08:45,14/Jul/23 06:02,09/Apr/16 20:10,2.4.5,2.4.6,,,,,,,2.4.7,,,,XML Processing,,,,0,,,,,,,"When using GPathResult with XmlSlurper, if an attribute is in a namespace, you must retrieve it using the namespace prefix defined in the document and not that defined by declareNamespace. This issue prevents safe retrieval of namespaced XML attributes since the document generator is free to choose namespace prefix.

{code}
def text = """"""<x:root xmlns:x=""blah"">
  <x:child x:id='1'>c</x:child>
</x:root>""""""

def xml =
    new XmlSlurper() 
        .parseText(text)
        .declareNamespace(x:'blah')
//        .declareNamespace(t:'blah')

println xml.child.text()     //""c"" always
println xml.'x:child'.text() //""c"" when declareNamespace x, else """"
println xml.'t:child'.text() //""c"" when declareNamespace t, else """"
println xml.child.'@x:id'    //""1"" always
println xml.child.'@t:id'    //"""" always
{code}

Looking in the debugger, there is namespaceMap and namespaceTagHints in GPathResult. namespaceMap is updated by declareNamespace but namespaceTagHints is not, and namespaceTagHints is used when looking up attributes. I don't see a way to update namespaceTagHints and namespaceMap doesn't really even seem to be used.",,gillius,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7808,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Apr 09 20:10:52 UTC 2016,,,,,,,,,,"0|i2ua33:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Apr/16 04:41;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/302

    GROOVY-7781 - Cannot retrieve XML attribute with namespace

    This change broke another test that asserted that an unprefixed attribute's namespace is the default namespace, but default namespace declarations do not apply to attribute names, see https://www.w3.org/TR/xml-names/#defaulting.
    
    > The namespace name for an unprefixed attribute name always has no value.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7781

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/302.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #302
    
----
commit 7b652bb329bc64fcaa978fef0778fc720d3e9029
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-03-23T22:15:54Z

    GROOVY-7781 - Cannot retrieve XML attribute with namespace

----
;;;","04/Apr/16 14:08;gillius;Not sure if GH comments get copied to here, but I did check out the pull request, and it looks like the changes I would expect and the unit test looks like it would properly reproduce the bug as well as pass when the fix is good.;;;","09/Apr/16 19:55;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/302
;;;","09/Apr/16 20:10;jwagenleitner;Thanks for reporting the issue and for reviewing and commenting on the proposed fix, really appreciate it.;;;",,,,,,,,,,,,,,,,,,
"CLONE - Enum constructor with value throws ""unexpected token"" error",GROOVY-7778,12946878,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,daniel_sun,brianeray,paulk,04/Mar/16 04:33,21/Feb/19 01:49,14/Jul/23 06:02,21/Feb/19 01:49,2.4.6,,,,,,,,3.0.0-alpha-4,,,,Compiler,,,,0,,,,,,,"First time submitter to this JIRA so let me know if I've specified anything incorrectly. I just upgraded from 2.4.4 to 2.4.6 and now declaring an enum constructor accepting a value as follows:

{code:title=UsStates.groovy}
enum UsState {
  
  ID('Idaho'),
  IL('Illinois'),
  IN('Indiana'),
  
  UsState( String value ) { this.value = value }

  private final String value
  
  String toString() { return value }

}

println UsState.ID //Idaho
{code}

throws the following compile error:

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
C:\svn_qa\jenkins_trunk\scripts\UsStates.groovy: 7: unexpected token: this @ line 7, column 29.
     UsState( String value ) { this.value = value }
                               ^

1 error
{code}

No such error occurred in 2.4.4, nor does it happen in 2.4.5. Here are a few contrasting things that do seem to work in 2.4.6:

{code:title=UsStatesBoring.groovy}
enum UsState {
  
  ID,
  IL,
  IN,

}

println UsState.ID //ID
{code}

{code:title=UsStatesNoEnum.groovy}
class UsState {
  
  UsState( String value ) { this.value = value }

  private final String value
  
  String toString() { return value }

}

final idaho = new UsState('Idaho')
println idaho //Idaho
{code}

Though this seems higher priority than Minor, I can work around it by simply downgrading to 2.4.5. I wish there was a Medium priority.","Windows 7 Professional
JDK 1.8.0_45",brianeray,daniel_sun,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7773,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Feb 21 01:49:21 UTC 2019,,,,,,,,,,"0|i2u527:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Mar/16 04:35;paulk;This is cloned from the original. This issue is to address whether we can tweak/finesse the grammar to remove the need for a semi-colon for the case of a dangling comma.;;;","20/Feb/19 22:36;paulk;This appears fixed in the Parrot parser.;;;","20/Feb/19 23:49;daniel_sun;Yep. The issue does not exist in Groovy 3.0.0;;;","21/Feb/19 01:49;paulk;Marking as resolved in 3.0.0-alpha-4 though it may have been an earlier version incorporating the Parrot parser.;;;",,,,,,,,,,,,,,,,,,
groovysh cannot load script with shebang,GROOVY-7777,12946597,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,plgruener,plgruener,03/Mar/16 16:30,12/Jun/16 08:45,14/Jul/23 06:02,23/Mar/16 05:18,2.4.6,,,,,,,,2.4.7,,,,Groovysh,,,,0,,,,,,,"The following file runs nicely when executing {{$ ./shebang.groovy}} :
{code:title=shebang.groovy|borderStyle=solid}
#!/usr/bin/env groovy
println ""Hello from the Shebang""
{code}

But, loading that file into groovysh results in:
{{$ groovysh shebang.groovy}}
{{groovysh_parse: 2: unexpected char: '#' @ line 2, column 1.}}

tested under Ubuntu14.04 with Groovy 2.4.6",,githubbot,jwagenleitner,plgruener,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Wed Mar 23 05:18:43 UTC 2016,,,,,,,,,,"0|i2u3vb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"22/Mar/16 01:25;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/297

    GROOVY-7777 - groovysh cannot load script with shebang

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7777

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/297.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #297
    
----
commit 13cc9ff55ca334693774ae7ba531b2276ee693cc
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-03-22T01:22:53Z

    GROOVY-7777 - groovysh cannot load script with shebang

----
;;;","23/Mar/16 04:53;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/297
;;;","23/Mar/16 05:18;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,
Collection addAll fails CompileStatic type checking when adding a collection of subtypes,GROOVY-7774,12946520,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,darren.hurt@gmail.com,darren.hurt@gmail.com,03/Mar/16 11:29,01/Feb/17 23:19,14/Jul/23 06:02,01/Aug/16 23:16,2.4.3,,,,,,,,2.4.8,,,,groovy-jdk,,,,0,,,,,,,"Suppose X is an interface and Y an interface such that Y extends X
The following code throws a compilation error (the outer class is annotated as @CompileStatic).
{code}
Set<X> set = new HashSet<X>()
Set<Y> toAdd = ......
set.addAll(toAdd)
{code}

However, the following works, which to me is inconsistent:

{code}
Set<X> set = new HashSet<X>()
Set<Y> toAdd = ......
for(Y y in toAdd) {
  set.add(y)
}
{code}


","Windows, Java 8.",darren.hurt@gmail.com,githubbot,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Aug 02 11:53:32 UTC 2016,,,,,,,,,,"0|i2u3e7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Mar/16 15:45;shils;The compiler determines the target method for {{set.addAll(toAdd)}} to be {{DefaultGroovyMethods#addAll(Collection<T>, Iterable<T>)}} rather than {{Collection<E>#addAll(Collection<? extends E>)}}, resulting in the error you described due to the lack of wildcard on the iterable parameter of the DGM addAll method.;;;","30/Jul/16 05:33;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/376

    GROOVY-7774: Collection addAll fails CompileStatic type checking when…

    … adding a collection of subtypes

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7774

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/376.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #376
    
----
commit 456fe6f089901668fd2e98f005da7240ca778827
Author: paulk <paulk@asert.com.au>
Date:   2016-07-30T05:31:50Z

    GROOVY-7774: Collection addAll fails CompileStatic type checking when adding a collection of subtypes

----
;;;","31/Jul/16 14:31;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/376#discussion_r72905143
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -5169,12 +5170,13 @@ public static Map groupBy(Object[] self, List<Closure> closures) {
          * @return a new Map grouped by keys
          * @since 1.0
          */
    -    public static <G, K, V> Map<G, Map<K, V>> groupBy(Map<K, V> self, @ClosureParams(MapEntryOrKeyValue.class) Closure<G> closure) {
    -        final Map<G, List<Map.Entry<K, V>>> initial = groupEntriesBy(self, closure);
    -        final Map<G, Map<K, V>> answer = new LinkedHashMap<G, Map<K, V>>();
    -        for (Map.Entry<G, List<Map.Entry<K, V>>> outer : initial.entrySet()) {
    +    public static <G, K, V> Map<G, Map<? extends  K, ? extends V>> groupBy(
    +            Map<K, V> self, @ClosureParams(MapEntryOrKeyValue.class) Closure<G> closure) {
    --- End diff --
    
    Should the wildcards be on the self parameter instead?  Just not used to seeing them on return types, but nested wildcards often confuse me :smile:
    
    Would the closure parameter benefit from having `? extends G`?
;;;","01/Aug/16 04:03;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/376#discussion_r72922015
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -5169,12 +5170,13 @@ public static Map groupBy(Object[] self, List<Closure> closures) {
          * @return a new Map grouped by keys
          * @since 1.0
          */
    -    public static <G, K, V> Map<G, Map<K, V>> groupBy(Map<K, V> self, @ClosureParams(MapEntryOrKeyValue.class) Closure<G> closure) {
    -        final Map<G, List<Map.Entry<K, V>>> initial = groupEntriesBy(self, closure);
    -        final Map<G, Map<K, V>> answer = new LinkedHashMap<G, Map<K, V>>();
    -        for (Map.Entry<G, List<Map.Entry<K, V>>> outer : initial.entrySet()) {
    +    public static <G, K, V> Map<G, Map<? extends  K, ? extends V>> groupBy(
    +            Map<K, V> self, @ClosureParams(MapEntryOrKeyValue.class) Closure<G> closure) {
    --- End diff --
    
    Nevermind my comments on wildcards on self param, the more I think about it that doesn't make sense.
    
    However, wont changing the return type to have wildcards extends mean that nothing can be put in the map that is mapped to the groupBy key which some may rely on being able to do?
;;;","01/Aug/16 04:35;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/376#discussion_r72923109
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -5169,12 +5170,13 @@ public static Map groupBy(Object[] self, List<Closure> closures) {
          * @return a new Map grouped by keys
          * @since 1.0
          */
    -    public static <G, K, V> Map<G, Map<K, V>> groupBy(Map<K, V> self, @ClosureParams(MapEntryOrKeyValue.class) Closure<G> closure) {
    -        final Map<G, List<Map.Entry<K, V>>> initial = groupEntriesBy(self, closure);
    -        final Map<G, Map<K, V>> answer = new LinkedHashMap<G, Map<K, V>>();
    -        for (Map.Entry<G, List<Map.Entry<K, V>>> outer : initial.entrySet()) {
    +    public static <G, K, V> Map<G, Map<? extends  K, ? extends V>> groupBy(
    +            Map<K, V> self, @ClosureParams(MapEntryOrKeyValue.class) Closure<G> closure) {
    --- End diff --
    
    It isn't exactly what I would like but groupBy calls putAll and the other changes are to make Java happy. We might have to do some casting and suppress some warnings instead.
;;;","01/Aug/16 08:09;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/376#discussion_r72938131
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -5169,12 +5170,13 @@ public static Map groupBy(Object[] self, List<Closure> closures) {
          * @return a new Map grouped by keys
          * @since 1.0
          */
    -    public static <G, K, V> Map<G, Map<K, V>> groupBy(Map<K, V> self, @ClosureParams(MapEntryOrKeyValue.class) Closure<G> closure) {
    -        final Map<G, List<Map.Entry<K, V>>> initial = groupEntriesBy(self, closure);
    -        final Map<G, Map<K, V>> answer = new LinkedHashMap<G, Map<K, V>>();
    -        for (Map.Entry<G, List<Map.Entry<K, V>>> outer : initial.entrySet()) {
    +    public static <G, K, V> Map<G, Map<? extends  K, ? extends V>> groupBy(
    +            Map<K, V> self, @ClosureParams(MapEntryOrKeyValue.class) Closure<G> closure) {
    --- End diff --
    
    we should use the following guideline: no wildcards on self or returns, only on parameters we use as input. In mutating calls, even the (in/)out parameters should not have wildcards. Because wildcards make it very very difficult to use the container for any adding.
;;;","01/Aug/16 15:42;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/376#discussion_r73000754
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -5176,7 +5176,9 @@ public static Map groupBy(Object[] self, List<Closure> closures) {
                 G key = outer.getKey();
                 List<Map.Entry<K, V>> entries = outer.getValue();
                 Map<K, V> target = createSimilarMap(self);
    -            putAll(target, entries);
    --- End diff --
    
    you removed the putAll here because of generics?
;;;","01/Aug/16 23:11;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/376#discussion_r73069688
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -5176,7 +5176,9 @@ public static Map groupBy(Object[] self, List<Closure> closures) {
                 G key = outer.getKey();
                 List<Map.Entry<K, V>> entries = outer.getValue();
                 Map<K, V> target = createSimilarMap(self);
    -            putAll(target, entries);
    --- End diff --
    
    Yes, but feel free to play around with other options if you have a strong preference.
;;;","01/Aug/16 23:14;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/376
;;;","01/Aug/16 23:16;paulk;Proposed PR merged.;;;","02/Aug/16 07:59;githubbot;Github user blackdrag commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/376#discussion_r73109779
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -5176,7 +5176,9 @@ public static Map groupBy(Object[] self, List<Closure> closures) {
                 G key = outer.getKey();
                 List<Map.Entry<K, V>> entries = outer.getValue();
                 Map<K, V> target = createSimilarMap(self);
    -            putAll(target, entries);
    --- End diff --
    
    my suggestion would be to change putAll to `public static <K, V> Map<K, V> putAll(Map<K, V> self, Collection<? extends Map.Entry<? extends K, ? extends V>> entries) `
    which more or less adds `? extends` before the Map.Entry part and to change back to use the putAll instead of the loop
;;;","02/Aug/16 11:53;githubbot;Github user paulk-asert commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/376#discussion_r73140995
  
    --- Diff: src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java ---
    @@ -5176,7 +5176,9 @@ public static Map groupBy(Object[] self, List<Closure> closures) {
                 G key = outer.getKey();
                 List<Map.Entry<K, V>> entries = outer.getValue();
                 Map<K, V> target = createSimilarMap(self);
    -            putAll(target, entries);
    --- End diff --
    
    Nice suggestion. Done.
;;;",,,,,,,,,,
"Enum constructor with value throws ""unexpected token"" error",GROOVY-7773,12946219,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,brianeray,brianeray,02/Mar/16 18:07,12/Jun/16 08:45,14/Jul/23 06:02,07/Mar/16 06:49,2.4.6,,,,,,,,2.4.7,,,,Compiler,,,,0,,,,,,,"First time submitter to this JIRA so let me know if I've specified anything incorrectly. I just upgraded from 2.4.4 to 2.4.6 and now declaring an enum constructor accepting a value as follows:

{code:title=UsStates.groovy}
enum UsState {
  
  ID('Idaho'),
  IL('Illinois'),
  IN('Indiana'),
  
  UsState( String value ) { this.value = value }

  private final String value
  
  String toString() { return value }

}

println UsState.ID //Idaho
{code}

throws the following compile error:

{code}
org.codehaus.groovy.control.MultipleCompilationErrorsException: startup failed:
C:\svn_qa\jenkins_trunk\scripts\UsStates.groovy: 7: unexpected token: this @ line 7, column 29.
     UsState( String value ) { this.value = value }
                               ^

1 error
{code}

No such error occurred in 2.4.4, nor does it happen in 2.4.5. Here are a few contrasting things that do seem to work in 2.4.6:

{code:title=UsStatesBoring.groovy}
enum UsState {
  
  ID,
  IL,
  IN,

}

println UsState.ID //ID
{code}

{code:title=UsStatesNoEnum.groovy}
class UsState {
  
  UsState( String value ) { this.value = value }

  private final String value
  
  String toString() { return value }

}

final idaho = new UsState('Idaho')
println idaho //Idaho
{code}

Though this seems higher priority than Minor, I can work around it by simply downgrading to 2.4.5. I wish there was a Medium priority.","Windows 7 Professional
JDK 1.8.0_45",githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7778,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Mar 07 06:49:54 UTC 2016,,,,,,,,,,"0|i2u1jb:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Mar/16 00:10;paulk;We did do a slight tweak to the grammar for enums (851fd58). Perhaps it is related to that. If you remove the last comma (i.e. after IN) then your example works. So, I think the priority is fine at least until we look into it more and decide which variations we want to support. Java would require a semicolon after such a dangling comma but we don't support that either. I suspect though that this edge case wasn't noted as a breaking change, I'll mark it as such once I confirm.;;;","03/Mar/16 00:46;brianeray;That change is a good suspect. Dangling commas are handy for adding new list items but deleting that comma is a much better workaround than downgrading. Thanks for looking into this.;;;","03/Mar/16 07:06;paulk;Agreed, we would like to support the dangling case as we did previously but the change I mentioned earlier was made for a reason, so we just need to check whether we can support both. It could just be that the previous fix just needs a little bit of finessing or it could end up being a limitation because of Groovy's support for removing semicolons. I imagine as a minimum we could (and should) support having the semicolon straight after the dangling comma.;;;","04/Mar/16 04:39;paulk;I have cloned this issue. Firstly, I think we should at least support Java's syntax in this case (to be covered by this issue) by allowing a semi-colon to close off the constant declarations (with or without the dangling comma - but optional for the non-dangling case). Secondly, in the cloned issue, we can explore whether it is possible to tweak the grammar to remove that need, i.e. make it optional for the dangling case too if possible.;;;","04/Mar/16 04:44;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/279

    GROOVY-7773: Enum constructor with value throws ""unexpected token"" er…

    …ror (closes #279)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7773

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/279.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #279
    
----
commit 5b5a166c9e7cd89a7064bef369dbd96f599e5e7a
Author: paulk <paulk@asert.com.au>
Date:   2016-03-04T04:41:11Z

    GROOVY-7773: Enum constructor with value throws ""unexpected token"" error (closes #279)

----
;;;","04/Mar/16 16:55;brianeray;Thank you.;;;","07/Mar/16 06:49;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/279
;;;","07/Mar/16 06:49;paulk;PR merged;;;",,,,,,,,,,,,,,
Groovydoc incorrectly rejects dollar signs and mucks up some backslashes during @code tag replacement.,GROOVY-7761,12940925,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,paulk,paulk,paulk,21/Feb/16 23:32,12/Jun/16 08:45,14/Jul/23 06:02,27/Feb/16 03:58,,,,,,,,,2.4.7,,,,,,,,0,,,,,,,,,githubbot,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Mon Feb 22 00:53:16 UTC 2016,,,,,,,,,,"0|i2t4vj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"21/Feb/16 23:40;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/268

    GROOVY-7761: Groovydoc incorrectly rejects dollar signs and mucks up …

    …some backslashes during @code tag replacement. (closes #268)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7761

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/268.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #268
    
----
commit 9a35f1a87fabf7ee4cf9c213557f6255482c63f4
Author: paulk <paulk@asert.com.au>
Date:   2016-02-21T23:39:00Z

    GROOVY-7761: Groovydoc incorrectly rejects dollar signs and mucks up some backslashes during @code tag replacement. (closes #268)

----
;;;","22/Feb/16 00:53;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/268
;;;","22/Feb/16 00:53;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/268
;;;",,,,,,,,,,,,,,,,,,,
@Lazy does not work when used in a Trait,GROOVY-7759,12940899,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,emilles,lewisdavidcole,lewisdavidcole,21/Feb/16 17:32,11/Nov/20 02:01,14/Jul/23 06:02,10/Aug/20 13:53,2.4.6,,,,,,,,3.0.6,4.0.0-alpha-1,,,groovy-runtime,,,,1,,,,,,,"@Lazy annotation is not honored when used in a trait.
Here is an example script demonstrating the issue:

{code}
    class MyBase{
      @Lazy String test = { 'test' }()
    }
    class TestBaseClass extends MyBase{}
    def tb = new TestBaseClass();

    //Dump the current state to output an assert test hasn't been initialized
    println ""Testing @Lazy on a Class..""
    println tb.dump()
    assert tb.dump().contains('test=null') //FOR A CLASS, THIS WILL SUCCEED

    //Access the test property causing initialization
    println ""Accessing the test property.""
    assert tb.test

    //Dump the current state to output an assert test has now been initialized
    println tb.dump()
    assert tb.test == 'test'

    trait MyTrait{
      @Lazy String test = { 'test' }()
    }
    class TestClass implements MyTrait{}
    def t = new TestClass();

    //Dump the current state to output an assert test hasn't been initialized
    println ""\nTesting @Lazy on a Trait..""
    println t.dump()
    assert t.dump().contains('test=null') //FOR A TRAIT, THIS WILL FAIL THE ASSERTION - A BUG?

    //Access the test property causing initialization
    println ""Accessing the test property.""
    assert t.test

    //Dump the current state to output an assert test has now been initialized
    println t.dump()
    assert t.test == 'test'
{code}
",,emilles,fabrizio.fortino@gmail.com,grv87,lewisdavidcole,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7760,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Aug 08 18:47:33 UTC 2020,,,,,,,,,,"0|i2t4pr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Aug/20 18:47;emilles;{code:groovy}
trait T {
  @Lazy String x = { -> 'works' }()
}
class C implements T {
}
print new C().dump() // outputs""<C@52f9aa7f T__x=works>""
{code}
;;;",,,,,,,,,,,,,,,,,,,,,
GroovyCastException when both @CompileStatic and @Newify are used,GROOVY-7758,12939819,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,shils,Ziphil,Ziphil,17/Feb/16 12:54,12/Jun/16 08:45,14/Jul/23 06:02,18/Mar/16 12:35,2.4.5,,,,,,,,2.4.7,,,,Static compilation,,,,0,,,,,,,"The following code gives {{GroovyCastException}}.
{code}
class Main {
  public static void main(String... args) {
    Test test = new Test()
  }
}

@CompileStatic @Newify
class Test {
  private HashMap<String, A> hashMap = [:]
  public Test() {
    set()
    test()
  }
  public void test() {
    hashMap.each() { String string, A a ->
      a.printString()
    }
  }
  public void set() {
    hashMap.put(""aaa"", B.new(""xxx""))
    hashMap.put(""bbb"", B.new(""yyy""))
  }
}

class A {
  public String string = """"
  public void printString() {
    println(string)
  }
}

class B extends A {
  public B(String string) {
    this.string = string
  }
}
{code}
The code below is a part of the decompiled {{Test.class}}. Groovy tries to cast {{this}} instead of {{a}}.
{code}
public Object doCall(String string, A a) {
  ((A)ScriptBytecodeAdapter.castToType(((_test_closure1)this).getThisObject(), A.class)).printString();
  return null;
}
{code}
When {{@CompileStatic}} is omitted, or when {{@Newify}} is omitted and {{B.new}} is replaced by {{new B}}, the code above gives no exception and runs as expected.",,githubbot,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 18 12:28:29 UTC 2016,,,,,,,,,,"0|i2sy1r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/Mar/16 19:14;shils;This occurs because 'implicitThis' is not set correctly in Newify transformed method calls. A simpler example:
{code}
class A {
    String foo() { 'abc' }
}

@groovy.transform.CompileStatic
@groovy.lang.Newify
String test(A arg) {
    Closure<String> cl = { A it -> it.foo() }
    cl.call(arg)
}

assert test(new A()) == 'abc'
{code}

The above fails with the same error (and for the same reason) as the example in the issue description.
;;;","14/Mar/16 19:37;githubbot;GitHub user shils opened a pull request:

    https://github.com/apache/groovy/pull/294

    GROOVY-7758: GroovyCastException when both @CompileStatic and @Newify…

    … are used

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/shils/groovy GROOVY-7758

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/294.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #294
    
----
commit da9666567fd5a6400521c1d2bc096e989f44bff5
Author: Shil Sinha <shil.sinha@gmail.com>
Date:   2016-03-14T19:21:30Z

    GROOVY-7758: GroovyCastException when both @CompileStatic and @Newify are used

----
;;;","18/Mar/16 12:28;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/294
;;;",,,,,,,,,,,,,,,,,,,
regression of return type from ternary operator,GROOVY-7753,12938328,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,daniel_sun,gillius,gillius,10/Feb/16 20:46,26/Jul/18 04:38,14/Jul/23 06:02,14/May/18 10:57,2.4.6,,,,,,,,2.5.0-rc-3,2.6.0-alpha-4,3.0.0-alpha-3,,Static compilation,Static Type Checker,,,2,,,,,,,"In Groovy 2.4.5 the following code works, but in Groovy 2.4.6, it fails to compile:

{code}
@groovy.transform.Field
String x = ""X""

@groovy.transform.CompileStatic
public List<String> getStrings() {
	x ? [x] : Collections.emptyList()
}

getStrings()
{code}

In Groovy 2.4.6 the compile error is:
{code}
[Static type checking] - Incompatible generic argument types. Cannot assign java.util.List <? extends java.lang.Object> to: java.util.List <String>
 @ line 6, column 2.
    x ? [x] : Collections.emptyList()
    ^
{code}

Workaround is to cast the result of emptyList to the erased type, (List) in this case.",,daniel_sun,gillius,jwagenleitner,lari.hotari@sagire.fi,mjjustin,pascalschumacher,paulk,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7598,,GROOVY-7763,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue May 22 23:26:33 UTC 2018,,,,,,,,,,"0|i2sow7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"16/Feb/16 19:05;pascalschumacher;[~jwagenleitner] I think it is not related to [GROOVY-7598], because [GROOVY-7598] is fixed in current master (at least the test from your pull request passes), but this still fails.;;;","16/Feb/16 19:58;jwagenleitner;I should have commented when I linked the issues that I believe the fix for GROOVY-7598 caused this.  Prior to GROOVY-7598 return types were not checked and because that introduced return type checking this is now an issue.  I don't think there is any problem with the fix in GROOVY-7598 just that it brought this issue up.

Another workaround that should work in addition to casting to a raw {{List}} you can also cast to the type:

{code}
x ? [x] : Collections.<String>emptyList()
{code}

It just seems to be a problem when using the ternary and elvis operators, since returning {{Collections.emptyList()}} by itself does not cause a compile error.;;;","16/Feb/16 20:06;pascalschumacher;Hi John,

it was my fault. I somehow confused [GROOVY-7598] with [GROOVY-7742]. :( Sorry.;;;","22/Feb/16 15:58;shils;Changed the title to reflect that this issue is about the ternary operator and not the elvis.;;;","07/Feb/17 15:44;mjjustin;I have the same issue when I attempt to assign the value to a variable, as well as when I use the empty list literal instead of Collections.emptyList.  Is this the same issue, or should I open a new issue for it?

{code}List<String> stringList1 = ['a'] ?: []
List<String> stringList2 = true ? ['b'] : []{code}

This is one place where Java has @CompileStatic Groovy beat, as its type inference does a better job with this sort of thing.;;;","21/Nov/17 07:49;paulk;@mjjustin This should be fixed for assignments (GROOVY-8255) and field/property initializers (GROOVY-8382) but not currently for return types.;;;","14/May/18 10:57;daniel_sun;Fixed by https://github.com/apache/groovy/commit/d88dfe679d1cd958c29acaf64b7d7631c041e194

Current solution can infer the return type properly, but has a limitation: `return` is required.

I will file a new JIRA issue.;;;","22/May/18 23:26;paulk;Hi Daniel, can you link the new issue to this one. Thanks.;;;",,,,,,,,,,,,,,
CallableStatement leak in Sql.call() method,GROOVY-7751,12937972,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,avladykin,avladykin,09/Feb/16 19:21,11/Mar/16 03:01,14/Jul/23 06:02,11/Mar/16 03:01,2.4.5,,,,,,,,2.4.7,,,,SQL processing,,,,0,,,,,,,"All {{Sql.call(...)}} methods ultimately delegate to {{Sql.callWithRows(...)}} method where we have:
{code:java}
try {
    statement = connection.prepareCall(sql);
    // ...
} finally {
    // ...
    closeResources(connection, statement);
}
{code}

The problem is that statement is unconditionally parsed and compiled each time, but the {{closeResources()}} method only closes it when statement caching is disabled. So with statement caching enabled we end up allocating and leaking a new CallableStatement instance per {{Sql.call()}} invocation.",,avladykin,githubbot,jwagenleitner,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 11 03:01:24 UTC 2016,,,,,,,,,,"0|i2smp3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"13/Feb/16 21:51;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/263

    GROOVY-7751 - CallableStatement leak in Sql.call() method

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7751

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/263.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #263
    
----
commit 0b628560afaa56de550ee2bc5d076851612a8363
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-02-13T20:57:04Z

    GROOVY-7751 - CallableStatement leak in Sql.call() method

----
;;;","11/Mar/16 02:52;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/263
;;;","11/Mar/16 03:01;jwagenleitner;Merged the PR that should ensure the {{CallableStatement}}'s are added to the statement cache if caching is enabled.

Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,
@Lazy allows instantiation of abstract class,GROOVY-7750,12936901,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,johann,johann,04/Feb/16 22:49,02/May/17 02:03,14/Jul/23 06:02,24/May/16 12:06,2.4.4,,,,,,,,2.5.0-alpha-1,,,,groovy-runtime,,,,0,usability,,,,,,"Given this code:

{code:java}
@Lazy
Foo foo

abstract class Foo {}
{code}

You'll get:

{code}
java.lang.InstantiationException
	at sun.reflect.InstantiationExceptionConstructorAccessorImpl.newInstance(InstantiationExceptionConstructorAccessorImpl.java:48)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:526)
	at org.codehaus.groovy.reflection.CachedConstructor.invoke(CachedConstructor.java:80)
	at org.codehaus.groovy.runtime.callsite.ConstructorSite$ConstructorSiteNoUnwrapNoCoerce.callConstructor(ConstructorSite.java:105)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallConstructor(CallSiteArray.java:60)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:235)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callConstructor(AbstractCallSite.java:239)
{code}

This isn't really helpful. If I mistype a method name, Groovy will help me out with suggestions, why not here?

MODIFICATION by blackdrag:
@Lazy should recognize this and fail compilation to avoid the initialization of an abstract class.",,blackdrag,githubbot,johann,paulk,rahulsom,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Thu Jun 02 02:41:21 UTC 2016,,,,,,,,,,"0|i2sgbj:",9223372036854775807,,,,,,,,,,,,,,,,,,,"14/May/16 02:29;rahulsom;I tried this in 2.4.5

{code}
abstract class Foo {}
class Demo {
  @Lazy Foo foo
}
new Demo().foo
{code}

It rightly complains 
{code}
java.lang.InstantiationException
	at Demo.getFoo(ConsoleScript2)
	at ConsoleScript2.run(ConsoleScript2:7)
	at ConsoleScript2.main(ConsoleScript2)
{code}

I believe this can be considered fixed.;;;","14/May/16 07:24;blackdrag;wasn´t the report exactly about getting this exception and not finding the message helpful? Infact this message is from the JVM and we could not do much but catch it and rethrow a better version. The problem though is, how to get a better version. We do not easily know what classes are available, which is different to methods and properties. So I do not see how we could improve this right now.  Well, that is from the exception side;;;","14/May/16 07:26;blackdrag;I changed this to a bug, because @Lazy should not cause initialization of an abstract class and thus should fail compilation here. I changed title and description accordingly;;;","16/May/16 11:34;paulk;It is an interesting edge case that raises a few questions in my mind. It should be noted that there are arguably some slight inconsistencies in current behavior even ignoring @Lazy for the moment, e.g. take this code:
{code}
abstract class Foo {}
new Foo()
{code}
This currently returns a compilation error:
{noformat}
You cannot create an instance from the abstract class 'Foo'.
{noformat}
However, this slight change:
{code}
abstract class Foo {}
Foo.newInstance()
{code}
gives the previously mentioned {{InstantiationException}}. However, with some metaprogramming, this works fine:
{code}
abstract class Foo {}
Foo.metaClass.constructor = { new Foo() {} }
Foo.newInstance()
{code}
So, perhaps the compilation error (which we added 6 years ago) is arguably too strong for a dynamic language - but fine if TypeChecked or CompileStatic were in play. I can't recall all the discussion but I suspect at the time we were trying to catch a common developer mistake without the benefit of having TypeChecked/CompileStatic as an option. We can't easily cover all reflective code possibilities so we only handle the most common case. I don't necessarily have a problem with this inconsistency but I suspect it isn't well documented.

So, now looking at the @Lazy situation, I think the case which needs to be handled is the special behavior when no initial value is given and the no-arg constructor is lazily called if needed to create a new instance (that's the equivalent to the {{new Foo()}} case above). If we wanted to be fully dynamic, there isn't much we can do apart from catching the {{InstantiationException}} and re-wrapping it in a nicer way. Ideally, we'd check more rigorously for TypeChecked/CompileStatic but that isn't simple. If however, we wanted to have some compromise (trading off some dynamic capability in return for catching a few more likely error cases at compile time), then we can easily check the type that would be instantiated for the case when there is no initial value and return a compilation error somewhat similar to the initial compilation exception at the start of this comment.

So, I'm suggesting that this code:
{code}
abstract class Foo {}
class Demo {
  @Lazy Foo foo
}
{code}
might fail compilation with a message something like:
{noformat}
You cannot lazily create an instance from the abstract class 'Foo' for field 'foo'.
{noformat}
There'll be other cases which fail with existing errors:
{code}
@Lazy Foo foo = new Foo() // existing compilation error
@Lazy Foo foo = Foo.newInstance() // InstantiationException
{code};;;","17/May/16 11:08;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/334

    GROOVY-7750: @Lazy allows instantiation of abstract class

    

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/groovy groovy7750

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/334.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #334
    
----
commit 58bcbac0f354a7da678fd23b23df196c9edda743
Author: paulk <paulk@asert.com.au>
Date:   2016-05-17T11:06:50Z

    GROOVY-7750: @Lazy allows instantiation of abstract class

----
;;;","24/May/16 12:08;paulk;Proposed PR merged onto master;;;","02/Jun/16 02:41;githubbot;Github user paulk-asert closed the pull request at:

    https://github.com/apache/groovy/pull/334
;;;",,,,,,,,,,,,,,,
SAM & @CompileStatic failure,GROOVY-7748,12936647,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,,maxim.medvedev,maxim.medvedev,04/Feb/16 08:33,01/Feb/17 23:18,14/Jul/23 06:02,08/Jan/17 19:48,,,,,,,,,2.4.8,,,,Static Type Checker,,,,0,,,,,,,"Groovyc fails to compile SAM coercion used in variable declaration
{code}
interface Function<D, I> {
  I fun(D dom)
}

class A{}; class B{}

@CompileStatic
void sample() {
  Function<A, B> f = {A dom -> return new B() } //compilation fails here
}

void bar(Function<A, B> fun) {}

@CompileStatic
void sample2() {
  bar {A dom -> return new B() } //compiles & runs ok
}
{code}
",,blackdrag,jwagenleitner,maxim.medvedev,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7927,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Jan 08 19:48:46 UTC 2017,,,,,,,,,,"0|i2ser3:",9223372036854775807,,,,,,,,,,,,,,,,,,,"04/Feb/16 08:38;blackdrag;The error message is {code}[Static type checking] - Incompatible generic argument types. Cannot assign Function <A, groovy.lang.Closure> to: Function <A, B>{code};;;","08/Jan/17 19:48;jwagenleitner;Verified that this issue was fixed in GROOVY-7927 by commit [776ea2cdfd2aa0|https://github.com/apache/groovy/commit/776ea2cdfd2aa0ba1525354f62f1f49faa920ff4].  The test added for that commit looks like it sufficiently covers this issue.

Thanks for reporting.;;;",,,,,,,,,,,,,,,,,,,,
Generated Java stub for enum with abstract method is invalid,GROOVY-7747,12936601,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,paulk,jonpeterson,jonpeterson,04/Feb/16 04:20,22/Feb/16 20:48,14/Jul/23 06:02,06/Feb/16 06:38,,,,,,,,,2.4.6,,,,,,,,0,,,,,,,"When generating Java stub for enum with an abstract method results in invalid Java source. The generated source class is defined as ""abstract enum"".

{code:title=EnumWithAbstractMethod.groovy}
enum EnumWithAbstractMethod {
    ONE {
        @Override
        int getInt() {
            return 1
        }
    },
    TWO {
        @Override
        int getInt() {
            return 2
        }
    }

    abstract int getInt()
}
{code}

{code:title=Driver.groovy}
class Driver {

    public static void main(String[] args) {
        def stubCompiler = new JavaStubCompilationUnit(
            new CompilerConfiguration(),
            new GroovyClassLoader(),
            new File('tmp')
        )

        stubCompiler.addSource(new File('EnumWithAbstractMethod.groovy'))

        stubCompiler.compile()
    }
}
{code}

{code:title=EnumWithAbstractMethod.java}
public abstract enum EnumWithAbstractMethod
  implements
    groovy.lang.GroovyObject {
...
{code}",Groovy 2.4.5,githubbot,jonpeterson,paulk,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Feb 06 06:38:34 UTC 2016,,,,,,,,,,"0|i2segv:",9223372036854775807,,,,,,,,,,,,,,,,,,,"05/Feb/16 11:09;githubbot;GitHub user paulk-asert opened a pull request:

    https://github.com/apache/groovy/pull/254

    GROOVY-7747: Generated Java stub for enum with abstract method is inv…

    …alid (closes #254)

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/paulk-asert/incubator-groovy groovy7747

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/254.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #254
    
----
commit ae606a540a36fa4bda465e42d880595e52e0feec
Author: paulk <paulk@asert.com.au>
Date:   2016-02-05T11:07:05Z

    GROOVY-7747: Generated Java stub for enum with abstract method is invalid (closes #254)

----
;;;","05/Feb/16 11:11;paulk;I can confirm this is a bug. Proposed fix as per above PR.

Cheers, Paul.;;;","06/Feb/16 06:37;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/254
;;;","06/Feb/16 06:37;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/254
;;;","06/Feb/16 06:38;paulk;PR merged.;;;",,,,,,,,,,,,,,,,,
Download page must link to ASF mirrors for sources,GROOVY-7743,12936172,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Blocker,Fixed,pascalschumacher,sebb,sebb,02/Feb/16 23:07,04/Mar/16 21:50,14/Jul/23 06:02,04/Mar/16 21:50,,,,,,,,,,,,,,,,,0,,,,,,,"The ASF requires that projects release source through the ASF mirror system [1]

However I could not find any links to the source from the website.

[1] http://www.apache.org/dev/release-publishing.html#distribution",https://dist.apache.org/repos/dist/release/groovy/,jwagenleitner,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Mar 04 21:50:43 UTC 2016,,,,,,,,,,"0|i2sbu7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"03/Feb/16 18:10;pascalschumacher;The source download on [http://groovy-lang.org/download.html] now uses dist.apache.org.

Thanks for notifying us of this and sorry that we did not update the download links after moving to Apache. ;;;","03/Feb/16 18:38;sebb;Releases are published by putting them in the SVN dist tree, and svpubsub copies them to the ASF mirror hosts.

However the SVN dist tree is *not* the correct place to link for downloads.
(The page is not very clear on that - I can see why you used it)

Downloaders must be directed to the ASF mirror system.

Please see:

http://www.apache.org/dev/release-download-pages.html;;;","03/Feb/16 19:00;sebb;I've updated the page to hopefully make it a bit clearer.
Further clarifications welcome!;;;","03/Feb/16 20:23;pascalschumacher;Thanks for clarifying. In my opinion the updated description is clear.

The source download of [http://www.groovy-lang.org/download.html] now uses [http://www.apache.org/dyn/closer.cgi/groovy/2.4.5-incubating/sources/apache-groovy-src-2.4.5-incubating.zip].;;;","04/Mar/16 15:59;sebb;The source download link is wrong; it is missing the path segment

2.4.6/sources/;;;","04/Mar/16 21:50;pascalschumacher;Fixed again. Thanks for reporting.;;;",,,,,,,,,,,,,,,,
CompileStatic stackoverflow with generic method with different placeholder as type argument,GROOVY-7742,12936117,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,pascalschumacher,jwagenleitner,jwagenleitner,02/Feb/16 21:09,22/Feb/16 20:48,14/Jul/23 06:02,16/Feb/16 07:10,2.4.6,2.5.0-beta-1,,,,,,,2.4.6,,,,Static compilation,,,,0,,,,,,,"The fix in [commit fae29119a|https://github.com/apache/groovy/commit/fae29119a1102393ae5d1645c3fc1e06547b0ad8] for master and [commit 197472cb|https://github.com/apache/groovy/commit/197472cb626bdada5e079c7f0cd145b85502f034] for 2.4 branch corrected behavior that as a result can create a stackoverflow:

To reproduce compile the following:

{code}
@groovy.transform.CompileStatic
class Foo {
    public <T> Class<T> firstClass(List<Class<T>> classes) {
        return classes.first()
    }
}
{code}

If you change the placeholder from {{T}} to {{E}} (the placeholder used by List) it compiles successfully.  The [{{StaticTypeCheckingSupport#applyGenericConnections}} method |https://github.com/apache/groovy/blob/d6bb5b8ff84b57c2c337c3db5008103b7c6d13d5/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java#L1509] receives both {{E}} and {{T}} in the {{resolvePlaceholders}} map and because there is no connection and with the fix to {{equalIncludingGenerics}} a stackoverflow results.

Stacktrace produced:

{code}
java.lang.StackOverflowError
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.applyGenericsContext(StaticTypeCheckingSupport.java:1722)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.applyGenericsContext(StaticTypeCheckingSupport.java:1750)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.applyGenericsContext(StaticTypeCheckingSupport.java:1722)
	at org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.applyGenericsContext(StaticTypeCheckingSupport.java:1750)
{code}

Found as a result of testing master against a Grails build and noticing a stackoverflow when compiling [a method within GparsPromiseFactory|https://github.com/jwagenleitner/grails-core/blob/69e7bb967fb8e8e331927cf2521b48cea93ee059/grails-async/src/main/groovy/org/grails/async/factory/gpars/GparsPromiseFactory.groovy#L106-L109]
",,fpavageau,githubbot,jwagenleitner,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Tue Feb 16 19:25:11 UTC 2016,,,,,,,,,,"0|i2sbi7:",9223372036854775807,,,,,,,,,,,,,,,,,,,"02/Feb/16 22:48;fpavageau;Chiming in as the author of the fix, which I did after finding the incorrect code while debugging something else. I'd unsuccessfully tried to create a synthetic test case showing the effect of the fix, which [~blackdrag] had asked for, I'd even wondered if the code was actually used at all.

I've spent quite some time recently in the handling of generics in the static type checker, and I'd already noticed there probably were lingering issues with the way placeholders are managed, e.g. using a single flattened context (mapping of the placeholders) instead of more isolated ones (I'm probably thinking of {{GenericsUtils.extractPlaceholders()}}). GROOVY-7719 and GROOVY-5839 could be some of those.

I'll see if I can find something tomorrow. Of course, the fix can also be reverted until a more complete solution addressing this new bug is found, since Groovy had the incorrect code for quite a while without anyone noticing.;;;","03/Feb/16 10:59;fpavageau;OK, this is similar to what I've encountered while trying to fix GROOVY-7720: it's trying to resolve all placeholders without considering those that are legal types in the current context, i.e. {{T}} is a valid (if generic) type inside {{Foo#firstClass()}}.

Because of that, {{StaticTypeCheckingSupport#applyGenericConnections()}} goes into a loop trying to define {{E}}, which is {{Class<T>}}, then {{Class<Class<T>>}}, then {{Class<Class<Class<T>>>}}, etc. This is managed in a while loop bounded to a maximum of 10000 iterations, but the stack overflow actually happens before that many iterations and we get a crash instead of an error message.;;;","05/Feb/16 01:41;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/253

    GROOVY-7742 - Stackoverflow when method parameters have different placeholders

    Not sure about this fix, but putting it out there for review.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7742

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/253.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #253
    
----
commit 600b31f1277724c286ebc916c5032e8f5825fcd6
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-02-05T01:39:33Z

    GROOVY-7742 - Stackoverflow when method parameters have different placeholders

----
;;;","07/Feb/16 21:30;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/253#discussion_r52125211
  
    --- Diff: src/test/groovy/transform/stc/GenericsSTCTest.groovy ---
    @@ -1800,6 +1800,19 @@ assert result == 'ok'
     '''
         }
     
    +    // GROOVY-7742
    +    void testMethodParamWithDifferentPlaceholderForTypeArgument() {
    +        // We use <T> here while List uses <E>
    --- End diff --
    
    I don't think using a different placeholder than the generic type is the issue here e.g. if 'T' is replaced with 'U' in this test, it passes without your change.
;;;","07/Feb/16 21:59;githubbot;Github user fpavageau commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/253#discussion_r52125721
  
    --- Diff: src/test/groovy/transform/stc/GenericsSTCTest.groovy ---
    @@ -1800,6 +1800,19 @@ assert result == 'ok'
     '''
         }
     
    +    // GROOVY-7742
    +    void testMethodParamWithDifferentPlaceholderForTypeArgument() {
    +        // We use <T> here while List uses <E>
    --- End diff --
    
    The problem does not appear when using a different placeholder than `List` (i.e. not `E`), it appears when using the same as `Class` (`T`).
;;;","07/Feb/16 22:20;githubbot;Github user shils commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/253#discussion_r52126075
  
    --- Diff: src/test/groovy/transform/stc/GenericsSTCTest.groovy ---
    @@ -1800,6 +1800,19 @@ assert result == 'ok'
     '''
         }
     
    +    // GROOVY-7742
    +    void testMethodParamWithDifferentPlaceholderForTypeArgument() {
    +        // We use <T> here while List uses <E>
    --- End diff --
    
    That was my thought initially as well, but in that case I would expect the following to fail since AtomicReference uses 'V' as a placeholder:
    ```
    import java.util.concurrent.atomic.AtomicReference
    
    @groovy.transform.CompileStatic
    class Foo {
        public <V> AtomicReference<V> firstReference(List<AtomicReference<V>> references) {
            return references.first()
        }
    }
    ```
    
    The code above compiles but, interestingly enough, the variant below does not:
    
    ```
    import java.util.concurrent.atomic.AtomicReference                                 
    
    @groovy.transform.CompileStatic                                                                                   
    class Foo {                                                                        
        public <T> AtomicReference<T> firstClass(List<AtomicReference<T>> references) {
            return references.first()                                                  
        }                                                                              
    }
    ```                                                                                  
;;;","08/Feb/16 00:05;githubbot;Github user jwagenleitner commented on a diff in the pull request:

    https://github.com/apache/groovy/pull/253#discussion_r52127643
  
    --- Diff: src/test/groovy/transform/stc/GenericsSTCTest.groovy ---
    @@ -1800,6 +1800,19 @@ assert result == 'ok'
     '''
         }
     
    +    // GROOVY-7742
    +    void testMethodParamWithDifferentPlaceholderForTypeArgument() {
    +        // We use <T> here while List uses <E>
    --- End diff --
    
    Looks like when it resolves the placeholders it adds T based on DGM `static <T> T first(List<T> self)` since it uses `T` as placeholder.  The real code that produced this error used `collect` which also uses `T`.  Changing the code to use `return classes.get(0)` fixes it.
;;;","10/Feb/16 21:37;githubbot;GitHub user fpavageau opened a pull request:

    https://github.com/apache/groovy/pull/259

    Fix the comparison of generic types

    The comparison cannot shortcut when a condition passes, only when one fails,
    since it's basically a big AND. E.g. even if both lower bounds are null (and
    therefore equal), the upper bounds still need to be compared. The only
    obvious shortcut is if the operands are the same object, as the first
    condition.
    
    I did not manage to create a test that would fail without the change. However, it's a change similar to fae2911 which ended up causing [GROOVY-7742](https://issues.apache.org/jira/browse/GROOVY-7742), so I think it should only be applied to `master` for the moment.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/fpavageau/groovy generic_comparison

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/259.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #259
    
----
commit 69de81104f45bb2ef3b2285ac269ebf8b62ecb2a
Author: Frank Pavageau <fpavageau@ekino.com>
Date:   2016-02-10T14:37:02Z

    Fix the comparison of generic types
    
    The comparison cannot shortcut when a condition passes, only when one fails,
    since it's basically a big AND. E.g. even if both lower bounds are null (and
    therefore equal), the upper bounds still need to be compared. The only
    obvious shortcut is if the operands are the same object, as the first
    condition.

----
;;;","16/Feb/16 07:08;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/253
;;;","16/Feb/16 07:10;pascalschumacher;I reverted fae29119a for master and commit 197472cb for GROOVY_2_4_X. Thanks for reporting and analyzing this. :);;;","16/Feb/16 19:25;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/259
;;;",,,,,,,,,,,
StackoverflowError with Closure and CompileStatic,GROOVY-7741,12935430,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,emilles,gerhard6,gerhard6,31/Jan/16 12:55,08/Mar/22 12:16,14/Jul/23 06:02,19/Dec/21 18:28,2.4.5,,,,,,,,,,,,Static compilation,,,,1,StackOverflowError,,,,,,"run the code below - it fails with a stackoverflow:
{code}
$ groovy ClosureStackOverflow.groovy
Caught: java.lang.StackOverflowError
java.lang.StackOverflowError
        at ClosureStackOverflow$_f_closure2.call(ClosureStackOverflow.groovy)
        at ClosureStackOverflow$_f_closure2.doCall(ClosureStackOverflow.groovy:17)
        at ClosureStackOverflow$_f_closure2.call(ClosureStackOverflow.groovy)
        at ClosureStackOverflow$_f_closure2.doCall(ClosureStackOverflow.groovy:17)
        at ClosureStackOverflow$_f_closure2.call(ClosureStackOverflow.groovy)
        at ClosureStackOverflow$_f_closure2.doCall(ClosureStackOverflow.groovy:17)

{code}

{code}
import groovy.transform.CompileStatic

@CompileStatic
class ClosureStackOverflow {
    Closure addTextClosure = { ""xx"" }

    void f()
    {
        List nodes = [ ""sth"" ]

        nodes.each {
            // here we get the overflow:
            addTextClosure()
        }
    }
    static void main(String[] args) {
        new ClosureStackOverflow().f()
    }
}
{code}",,blackdrag,emilles,gerhard6,jkeys089,shils,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7805,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Dec 19 18:28:00 UTC 2021,,,,,,,,,,"0|i2s79r:",9223372036854775807,,,,,,,,,,,,,,,,,,,"31/Jan/16 14:53;blackdrag;I can verify this bug happens and it happens only with static compilation enabled;;;","05/Feb/16 21:26;shils;The closure passed to nodes.each calls itself in its doCall method instead of calling addTextClosure:

{code}
  public doCall(Ljava/lang/Object;)Ljava/lang/Object;
   L0
    LINENUMBER 11 L0
    ALOAD 0
    CHECKCAST ClosureStackOverflow$_f_closure2
    INVOKEVIRTUAL ClosureStackOverflow$_f_closure2.call ()Ljava/lang/Object;
    ARETURN
   L1
{code}

The exception does not occur if addTextClosure is called explicitly like {{addTextClosure.call()}}.;;;","19/Dec/21 18:28;emilles;Fixed in Groovy 2.5+;;;",,,,,,,,,,,,,,,,,,,
OutOfMemoryError starting from groovy-2.4.5 version.,GROOVY-7731,12931658,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Major,Fixed,jwagenleitner,Artyom Kravchenko,Artyom Kravchenko,16/Jan/16 13:03,01/Feb/17 23:18,14/Jul/23 06:02,11/Sep/16 04:06,2.4.5,,,,,,,,2.4.8,,,,GroovyScriptEngine,,,,2,,,,,,,"I have faced with memory leak as soon as I upgraded groovy from 2.4.4 to the latest version (2.4.5).

As I see groovy-2.4.5 version already contains fix for https://issues.apache.org/jira/browse/GROOVY-7591
and uses ClassInfo.class by default. But such fix causes the other memory leak. It is easy to reproduce by simple test:

public class ScriptsMemoryLeak {
	public static void main(String[] args) throws ScriptException {
		while (true) {
			ScriptEngineManager engineManager = new ScriptEngineManager();

			ScriptEngine engine = engineManager.getEngineByName(""groovy"");

			engine.eval(""println 'test'"");
		}
	}
}


I have run this test with -Xmx20m and OutOfMemoryError  occurs after about 400 iterations:

Exception in thread ""main"" java.lang.OutOfMemoryError: GC overhead limit exceeded
	at sun.misc.URLClassPath$JarLoader.checkResource(URLClassPath.java:771)
	at sun.misc.URLClassPath$JarLoader.getResource(URLClassPath.java:843)
	at sun.misc.URLClassPath.getResource(URLClassPath.java:199)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:364)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:360)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at org.codehaus.groovy.runtime.callsite.PogoMetaClassSite.callCurrent(PogoMetaClassSite.java:81)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCallCurrent(CallSiteArray.java:52)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:154)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.callCurrent(AbstractCallSite.java:166)
	at Script478.run(Script478.groovy:1)
	at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:352)
	at org.codehaus.groovy.jsr223.GroovyScriptEngineImpl.eval(GroovyScriptEngineImpl.java:153)
	at javax.script.AbstractScriptEngine.eval(AbstractScriptEngine.java:264)
	at ish.oncourse.server.scripting.ScriptsMemoryLeak.main(ScriptsMemoryLeak.java:21)



When I added -Dgroovy.use.classvalue=true (followed advice in https://issues.apache.org/jira/browse/GROOVY-7591 to reactivate use of ClassValue) the leak goes away and my test can works infinitely.

Currently I forced to use -Dgroovy.use.classvalue=true option to proper work of my code.

Also I have find other task which was already closed (but probably was not fully done):
https://issues.apache.org/jira/browse/GROOVY-6704
From comment I can see that users still faces with the same issue. 

Can someone please advise me will be this memory leak fixed in groovy. If yes, then when I will be able to get rid ""-Dgroovy.use.classvalue=true"" from my code



","Ubuntu 14.04, Mac osx 10.11.1 
Java openJDK 1.8, Java HotSpot 1.8

",ari,Artyom Kravchenko,jexler,jkemnade,jwagenleitner,lari.hotari@sagire.fi,moshe@egis-software.com,PetiKoch,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-7733,,,,,GROOVY-7683,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sun Sep 11 04:06:52 UTC 2016,,,,,,,,,,"0|i2rk1j:",9223372036854775807,,,,,,,,,,,,,,,,,,,"24/Aug/16 07:50;PetiKoch;We see also a memory leak with using {{groovy.util.Eval#me}} in our Application (using Groovy 2.4.6). 

*-Dgroovy.use.classvalue=true* works as workaround for us, too.;;;","11/Sep/16 04:06;jwagenleitner;Thanks for reporting the issue.  I believe the fix for GROOVY-7683 will fix the issue and no longer require the system property setting, but please re-open if you find that to not be the case.;;;",,,,,,,,,,,,,,,,,,,,
LAX parser: Commenting out key/val pairs doesn't work ,GROOVY-7728,12928732,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,luyseyal,luyseyal,08/Jan/16 20:55,12/Jun/16 08:45,14/Jul/23 06:02,29/Apr/16 02:39,2.4.5,,,,,,,,2.4.7,,,,JSON,,,,0,,,,,,,"This is in regards to {{JsonParserType.LAX}}. I'm calling it with this code:
{code}
def slurpOpts = new JsonSlurper().setType(JsonParserType.LAX).parse(new File(ConfigFileName))

slurpOpts.each {k, v -> myOpts.put(k, slurpOpts.get(k))}
{code}

Here is my JSON. {{appUserId}} is parsed but it should be commented out. The key {{baseFolderName}} is correctly commented out.

{code}
{
    ""enterpriseDomain"": ""@example.com""
    ,""enterpriseId"": ""123456""
    ,""clientId"": ""abcdefghijklmnopqrstuvwxyz123456""
    ,""clientSecret"": ""abcdefghijklmnopqrstuvwxyz123456""
    ,""keyId"": ""12345678""
    ,""keyFileName"": ""/etc/PrintToBox/PrintToBox_private_key.pem""
    ,""keyPassword"": ""12345678901234567890""
    // ,""appUserId"": ""123456789"" 

    //  Optional parameters with defaults shown
    // ,""baseFolderName"": ""PrintToBox""
}
{code}","Linux OpenJDK 7 (java version ""1.7.0_91"")",githubbot,jwagenleitner,luyseyal,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Fri Apr 29 02:39:22 UTC 2016,,,,,,,,,,"0|i2r1zr:",9223372036854775807,,,,,,,,,,,,,,,,,,,"27/Apr/16 00:09;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/322

    GROOVY-7728 - LAX parser: Commenting out key/val pairs doesn't work

    Changed loop to process comments and end of object marker after processing
    key/values because skipWhitespace leaves the cursor on the first
    non-whitespace character and that character needs to be processed before
    the loop increments the index counter.  This same logic is used by
    JsonFastParser#decodeJsonObjectLazyFinalParse.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7728

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/322.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #322
    
----
commit af3800f4f6534e0771b624b7d8bc99bd2d0f6a93
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-04-27T00:07:45Z

    GROOVY-7728 - LAX parser: Commenting out key/val pairs doesn't work
    
    Changed loop to process comments and end of object marker after processing
    key/values because skipWhitespace leaves the cursor on the first
    non-whitespace character and that character needs to be processed before
    the loop increments the index counter.  This same logic is used by
    JsonFastParser#decodeJsonObjectLazyFinalParse.

----
;;;","29/Apr/16 02:31;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/322
;;;","29/Apr/16 02:39;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,,
Groovysh doc command fails when using Java 9,GROOVY-7726,12928090,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,pascalschumacher,pascalschumacher,pascalschumacher,06/Jan/16 18:38,22/Feb/16 20:48,14/Jul/23 06:02,06/Jan/16 18:43,2.4.5,,,,,,,,2.4.6,,,,Groovysh,,,,0,,,,,,,"The command fails because the format of the version string returned by the ""java.version"" system property has changed (see [http://openjdk.java.net/jeps/223] for details).",,pascalschumacher,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,2016-01-06 18:38:17.0,,,,,,,,,,"0|i2qy1j:",9223372036854775807,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
"propertyMissing(String,Object) called for missing getter",GROOVY-7723,12925186,Bug,Closed,GROOVY,Groovy,software,paulk,Groovy programming language: a modern multi-faceted language for the JVM,https://groovy.apache.org,Minor,Fixed,jwagenleitner,yihtserns,yihtserns,01/Jan/16 10:12,12/Jun/16 08:45,14/Jul/23 06:02,09/Apr/16 17:49,2.4.0,,,,,,,,2.4.7,,,,,,,,0,,,,,,,"GROOVY-2098 says that {{propertyMissing(String)}} is for getters, while {{propertyMissing(String,Object)}} is for setters.

But as the code snippet below shows, when {{propertyMissing(String)}} is missing, missing getters are handled by {{propertyMissing(String,Object)}}:
{code:java}
class Sample {

    /**
    def propertyMissing(String name) {
        return ""propertyMissing(String)""
    }
    **/

    def propertyMissing(String name, value) {
        return ""propertyMissing(String,Object)""
    }
}

println new Sample().missing // Prints `propertyMissing(String,Object)`
{code}

Is this a bug?","Tested with Groovy 1.8.0, 2.1.0, 2.2.2, and 2.4.0.",githubbot,jwagenleitner,yihtserns,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,GROOVY-2098,,,,,,,,,,,,0.0,,,,,,,,,,,,,,,,,,,,,,false,,,,,,,,,,,,,,,,,9223372036854775807,,,Sat Apr 09 17:49:30 UTC 2016,,,,,,,,,,"0|i2qg4n:",9223372036854775807,,,,,,,,,,,,,,,,,,,"08/Apr/16 19:16;jwagenleitner;Looks like [commit 97a45dfb3e3c5212c36|https://github.com/apache/groovy/commit/97a45dfb3e3c5212c3610cd90fe1e7434614b260#diff-c1354c0d7df171ad8cafcb3d1bf63857L535] introduced this change.  The original code would not have delegated to the setter method.  I don't think the intent of the commit was to change the behavior but resulted inadvertently due to the refactoring.;;;","09/Apr/16 09:59;githubbot;GitHub user jwagenleitner opened a pull request:

    https://github.com/apache/groovy/pull/307

    GROOVY-7723 - propertyMissing(String,Object) called for missing getter

    Looks like commit 97a45dfb3e3c5212c36 introduced [this change] (https://github.com/apache/groovy/commit/97a45dfb3e3c5212c3610cd90fe1e7434614b260#diff-c1354c0d7df171ad8cafcb3d1bf63857L535). The original code would not have delegated to the setter method. I don't think the intent of the commit was to change the behavior but resulted inadvertently due to the refactoring.

You can merge this pull request into a Git repository by running:

    $ git pull https://github.com/jwagenleitner/groovy GROOVY-7723

Alternatively you can review and apply these changes as the patch at:

    https://github.com/apache/groovy/pull/307.patch

To close this pull request, make a commit to your master/trunk branch
with (at least) the following in the commit message:

    This closes #307
    
----
commit 930c41d10d41cc9923db90afec53357e15b1d822
Author: John Wagenleitner <jwagenleitner@apache.org>
Date:   2016-04-09T09:56:08Z

    GROOVY-7723 - propertyMissing(String,Object) called for missing getter

----
;;;","09/Apr/16 17:17;githubbot;Github user asfgit closed the pull request at:

    https://github.com/apache/groovy/pull/307
;;;","09/Apr/16 17:49;jwagenleitner;Thanks for reporting the issue.;;;",,,,,,,,,,,,,,,,,,
